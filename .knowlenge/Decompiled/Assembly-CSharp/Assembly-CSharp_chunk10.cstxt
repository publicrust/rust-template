using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using GamePhysicsJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using UnityEngine;
using UtilityJobs;

public static class GamePhysics
{
	public enum Realm
	{
		Client,
		Server
	}

	[Flags]
	public enum MasksToValidate : byte
	{
		None = 0,
		Terrain = 1,
		Water = 2,
		All = 3
	}

	public const int BufferLength = 32768;

	private static RaycastHit[] hitBuffer = (RaycastHit[])(object)new RaycastHit[32768];

	private static RaycastHit[] hitBufferB = (RaycastHit[])(object)new RaycastHit[32768];

	private static Collider[] colBuffer = (Collider[])(object)new Collider[32768];

	public const int DefaultMaxResultsPerQuery = 16;

	public static bool CheckSphere(Vector3 position, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position, layerMask);
		return Physics.CheckSphere(position, radius, layerMask, triggerInteraction);
	}

	public static void CheckSpheres(ReadOnly<Vector3> pos, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<bool> results, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckSpheres", 0);
		try
		{
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(pos.Length, (Allocator)3, (NativeArrayOptions)0);
			OverlapSpheres(pos, radii, layerMasks, hits, 1, triggerInteraction, validate);
			CheckHitsJob checkHitsJob = default(CheckHitsJob);
			checkHitsJob.Results = results;
			checkHitsJob.Hits = hits.AsReadOnly();
			CheckHitsJob checkHitsJob2 = checkHitsJob;
			IJobExtensions.RunByRef<CheckHitsJob>(ref checkHitsJob2);
			hits.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision((start + end) * 0.5f, layerMask);
		return Physics.CheckCapsule(start, end, radius, layerMask, triggerInteraction);
	}

	public static void CheckCapsules(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<bool> results, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All, bool mitigateSpheres = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckCapsules", 0);
		try
		{
			ReadOnly<int> layerMasks2 = layerMasks;
			NativeArray<int> array = default(NativeArray<int>);
			if (validate != 0)
			{
				array = new NativeArray<int>(layerMasks.Length, (Allocator)3, (NativeArrayOptions)0);
				layerMasks.CopyTo(array);
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(starts.Length, (Allocator)3, (NativeArrayOptions)0);
				CalcMidpoingJob calcMidpoingJob = default(CalcMidpoingJob);
				calcMidpoingJob.Results = results2;
				calcMidpoingJob.From = starts;
				calcMidpoingJob.To = ends;
				CalcMidpoingJob calcMidpoingJob2 = calcMidpoingJob;
				IJobExtensions.RunByRef<CalcMidpoingJob>(ref calcMidpoingJob2);
				HandleIgnoreCollision(results2.AsReadOnly(), array, validate);
				results2.Dispose();
				layerMasks2 = array.AsReadOnly();
			}
			NativeArray<OverlapCapsuleCommand> val2 = new NativeArray<OverlapCapsuleCommand>(starts.Length, (Allocator)3, (NativeArrayOptions)0);
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob = default(GenerateOverlapCapsuleCommandsJob);
			generateOverlapCapsuleCommandsJob.CapsuleCommands = val2;
			generateOverlapCapsuleCommandsJob.From = starts;
			generateOverlapCapsuleCommandsJob.To = ends;
			generateOverlapCapsuleCommandsJob.Radiii = radii;
			generateOverlapCapsuleCommandsJob.LayerMasks = layerMasks2;
			generateOverlapCapsuleCommandsJob.TriggerInteraction = triggerInteraction;
			generateOverlapCapsuleCommandsJob.HitBackfaces = false;
			generateOverlapCapsuleCommandsJob.HitMultipleFaces = false;
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob2 = generateOverlapCapsuleCommandsJob;
			IJobExtensions.RunByRef<GenerateOverlapCapsuleCommandsJob>(ref generateOverlapCapsuleCommandsJob2);
			NativeArrayEx.SafeDispose(ref array);
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(starts.Length, (Allocator)3, (NativeArrayOptions)0);
			if (mitigateSpheres)
			{
				MitigateSphereCapsuleCommands(val2, hits, 1);
			}
			else
			{
				ExecuteOverlapCapsuleCommands(val2, hits, 1);
			}
			val2.Dispose();
			CheckHitsJob checkHitsJob = default(CheckHitsJob);
			checkHitsJob.Results = results;
			checkHitsJob.Hits = hits.AsReadOnly();
			CheckHitsJob checkHitsJob2 = checkHitsJob;
			IJobExtensions.RunByRef<CheckHitsJob>(ref checkHitsJob2);
			hits.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool CheckOBB(OBB obb, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		return Physics.CheckBox(obb.position, obb.extents, obb.rotation, layerMask, triggerInteraction);
	}

	public static bool CheckOBBAndEntity(OBB obb, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		int num = Physics.OverlapBoxNonAlloc(obb.position, obb.extents, colBuffer, obb.rotation, layerMask, triggerInteraction);
		for (int i = 0; i < num; i++)
		{
			BaseEntity baseEntity = colBuffer[i].ToBaseEntity();
			if (!((Object)(object)baseEntity != (Object)null) || !((Object)(object)ignoreEntity != (Object)null) || (baseEntity.isServer == ignoreEntity.isServer && !((Object)(object)baseEntity == (Object)(object)ignoreEntity)))
			{
				return true;
			}
		}
		return false;
	}

	public static bool CheckBounds(Bounds bounds, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(((Bounds)(ref bounds)).center, layerMask);
		return Physics.CheckBox(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).extents, Quaternion.identity, layerMask, triggerInteraction);
	}

	public static bool CheckInsideNonConvexMesh(Vector3 point, int layerMask = -5)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		bool queriesHitBackfaces = Physics.queriesHitBackfaces;
		Physics.queriesHitBackfaces = true;
		int num = Physics.RaycastNonAlloc(point, Vector3.up, hitBuffer, 100f, layerMask);
		int num2 = Physics.RaycastNonAlloc(point, -Vector3.up, hitBufferB, 100f, layerMask);
		if (num >= hitBuffer.Length)
		{
			Debug.LogWarning((object)"CheckInsideNonConvexMesh query is exceeding hitBuffer length.");
			return false;
		}
		if (num2 > hitBufferB.Length)
		{
			Debug.LogWarning((object)"CheckInsideNonConvexMesh query is exceeding hitBufferB length.");
			return false;
		}
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num2; j++)
			{
				if ((Object)(object)((RaycastHit)(ref hitBuffer[i])).collider == (Object)(object)((RaycastHit)(ref hitBufferB[j])).collider)
				{
					Physics.queriesHitBackfaces = queriesHitBackfaces;
					return true;
				}
			}
		}
		Physics.queriesHitBackfaces = queriesHitBackfaces;
		return false;
	}

	public static bool CheckInsideAnyCollider(Vector3 point, int layerMask = -5)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (Physics.CheckSphere(point, 0f, layerMask))
		{
			return true;
		}
		if (CheckInsideNonConvexMesh(point, layerMask))
		{
			return true;
		}
		if ((Object)(object)TerrainMeta.HeightMap != (Object)null && TerrainMeta.HeightMap.GetHeight(point) > point.y)
		{
			return true;
		}
		return false;
	}

	public static void OverlapSphere(Vector3 position, float radius, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position, layerMask);
		int count = Physics.OverlapSphereNonAlloc(position, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapSpheres(ReadOnly<Vector3> positions, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<ColliderHit> hits, int maxResPerCast, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.OverlapSpheres", 0);
		try
		{
			ReadOnly<int> layerMasks2 = layerMasks;
			NativeArray<int> array = default(NativeArray<int>);
			if (validate != 0)
			{
				array = new NativeArray<int>(layerMasks.Length, (Allocator)3, (NativeArrayOptions)0);
				layerMasks.CopyTo(array);
				HandleIgnoreCollision(positions, array, validate);
				layerMasks2 = array.AsReadOnly();
			}
			NativeArray<OverlapSphereCommand> val2 = new NativeArray<OverlapSphereCommand>(positions.Length, (Allocator)3, (NativeArrayOptions)0);
			GenerateOverlapSphereCommandsJob generateOverlapSphereCommandsJob = default(GenerateOverlapSphereCommandsJob);
			generateOverlapSphereCommandsJob.SphereCommands = val2;
			generateOverlapSphereCommandsJob.Pos = positions;
			generateOverlapSphereCommandsJob.Radiii = radii;
			generateOverlapSphereCommandsJob.LayerMasks = layerMasks2;
			generateOverlapSphereCommandsJob.TriggerInteraction = triggerInteraction;
			generateOverlapSphereCommandsJob.HitBackfaces = false;
			generateOverlapSphereCommandsJob.HitMultipleFaces = false;
			GenerateOverlapSphereCommandsJob generateOverlapSphereCommandsJob2 = generateOverlapSphereCommandsJob;
			IJobExtensions.RunByRef<GenerateOverlapSphereCommandsJob>(ref generateOverlapSphereCommandsJob2);
			NativeArrayEx.SafeDispose(ref array);
			ExecuteOverlapSphereCommands(val2, hits, maxResPerCast);
			val2.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void ExecuteOverlapSphereCommands(NativeArray<OverlapSphereCommand> commands, NativeArray<ColliderHit> hits, int maxResPerCast)
	{
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		if (Debug.isDebugBuild)
		{
			NativeList<int> invalidIndices = default(NativeList<int>);
			invalidIndices..ctor(commands.Length, AllocatorHandle.op_Implicit((Allocator)3));
			ValidateOverlapSphereCommandsJob validateOverlapSphereCommandsJob = default(ValidateOverlapSphereCommandsJob);
			validateOverlapSphereCommandsJob.InvalidIndices = invalidIndices;
			validateOverlapSphereCommandsJob.Commands = commands.AsReadOnly();
			ValidateOverlapSphereCommandsJob validateOverlapSphereCommandsJob2 = validateOverlapSphereCommandsJob;
			IJobExtensions.RunByRef<ValidateOverlapSphereCommandsJob>(ref validateOverlapSphereCommandsJob2);
			if (!invalidIndices.IsEmpty)
			{
				int num = invalidIndices[0];
				OverlapSphereCommand val = commands[num];
				Debug.LogError((object)string.Concat(string.Concat(string.Concat($"OverlapSpheres has {invalidIndices.Length} invalid sphere commands!" + $"\nFirst one was at index {num}:", $"\n\tPos: {((OverlapSphereCommand)(ref val)).point}"), $"\n\tRadius: {((OverlapSphereCommand)(ref val)).radius}"), "\nThese queries will be skipped!"));
			}
			invalidIndices.Dispose();
		}
		int batchSize = GetBatchSize(commands.Length);
		JobHandle val2 = OverlapSphereCommand.ScheduleBatch(commands, hits, batchSize, maxResPerCast, default(JobHandle));
		((JobHandle)(ref val2)).Complete();
	}

	public static void OBBSweep(OBB obb, Vector3 direction, float distance, List<RaycastHit> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		HitBufferToList(Physics.BoxCastNonAlloc(obb.position, obb.extents, direction, hitBuffer, obb.rotation, distance, layerMask, triggerInteraction), list);
	}

	public static void CapsuleSweep(Vector3 position0, Vector3 position1, float radius, Vector3 direction, float distance, List<RaycastHit> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position0, layerMask);
		layerMask = HandleIgnoreCollision(position1, layerMask);
		HitBufferToList(Physics.CapsuleCastNonAlloc(position0, position1, radius, direction, hitBuffer, distance, layerMask, triggerInteraction), list);
	}

	public static void OverlapCapsule(Vector3 point0, Vector3 point1, float radius, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(point0, layerMask);
		layerMask = HandleIgnoreCollision(point1, layerMask);
		int count = Physics.OverlapCapsuleNonAlloc(point0, point1, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapCapsules(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<ColliderHit> hits, int maxResPerCast, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All, bool mitigateSpheres = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.OverlapCapsules", 0);
		try
		{
			ReadOnly<int> layerMasks2 = layerMasks;
			NativeArray<int> array = default(NativeArray<int>);
			if (validate != 0)
			{
				array = new NativeArray<int>(layerMasks.Length, (Allocator)3, (NativeArrayOptions)0);
				layerMasks.CopyTo(array);
				HandleIgnoreCollision(starts, array, validate);
				HandleIgnoreCollision(ends, array, validate);
				layerMasks2 = array.AsReadOnly();
			}
			NativeArray<OverlapCapsuleCommand> val2 = new NativeArray<OverlapCapsuleCommand>(starts.Length, (Allocator)3, (NativeArrayOptions)0);
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob = default(GenerateOverlapCapsuleCommandsJob);
			generateOverlapCapsuleCommandsJob.CapsuleCommands = val2;
			generateOverlapCapsuleCommandsJob.From = starts;
			generateOverlapCapsuleCommandsJob.To = ends;
			generateOverlapCapsuleCommandsJob.Radiii = radii;
			generateOverlapCapsuleCommandsJob.LayerMasks = layerMasks2;
			generateOverlapCapsuleCommandsJob.TriggerInteraction = triggerInteraction;
			generateOverlapCapsuleCommandsJob.HitBackfaces = false;
			generateOverlapCapsuleCommandsJob.HitMultipleFaces = false;
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob2 = generateOverlapCapsuleCommandsJob;
			IJobExtensions.RunByRef<GenerateOverlapCapsuleCommandsJob>(ref generateOverlapCapsuleCommandsJob2);
			NativeArrayEx.SafeDispose(ref array);
			if (mitigateSpheres)
			{
				MitigateSphereCapsuleCommands(val2, hits, maxResPerCast);
			}
			else
			{
				ExecuteOverlapCapsuleCommands(val2, hits, maxResPerCast);
			}
			val2.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void MitigateSphereCapsuleCommands(NativeArray<OverlapCapsuleCommand> commands, NativeArray<ColliderHit> hits, int maxResPerCast)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		NativeList<int> val = default(NativeList<int>);
		val..ctor(commands.Length, AllocatorHandle.op_Implicit((Allocator)3));
		FindSphereCmdsInCapsuleCmdsJob findSphereCmdsInCapsuleCmdsJob = default(FindSphereCmdsInCapsuleCmdsJob);
		findSphereCmdsInCapsuleCmdsJob.SphereIndices = val;
		findSphereCmdsInCapsuleCmdsJob.Commands = commands.AsReadOnly();
		FindSphereCmdsInCapsuleCmdsJob findSphereCmdsInCapsuleCmdsJob2 = findSphereCmdsInCapsuleCmdsJob;
		IJobExtensions.RunByRef<FindSphereCmdsInCapsuleCmdsJob>(ref findSphereCmdsInCapsuleCmdsJob2);
		if (val.IsEmpty)
		{
			val.Dispose();
			ExecuteOverlapCapsuleCommands(commands, hits, maxResPerCast);
			return;
		}
		int num = Math.Max(val.Length, commands.Length - val.Length);
		NativeArray<ColliderHit> hits2 = default(NativeArray<ColliderHit>);
		hits2..ctor(num * maxResPerCast, (Allocator)3, (NativeArrayOptions)0);
		NativeList<OverlapSphereCommand> sphereCommands = default(NativeList<OverlapSphereCommand>);
		sphereCommands..ctor(val.Length, AllocatorHandle.op_Implicit((Allocator)3));
		GenerateSphereCmdsFromCapsuleCmdsJob generateSphereCmdsFromCapsuleCmdsJob = default(GenerateSphereCmdsFromCapsuleCmdsJob);
		generateSphereCmdsFromCapsuleCmdsJob.SphereCommands = sphereCommands;
		generateSphereCmdsFromCapsuleCmdsJob.Commands = commands.AsReadOnly();
		generateSphereCmdsFromCapsuleCmdsJob.Indices = val.AsReadOnly();
		GenerateSphereCmdsFromCapsuleCmdsJob generateSphereCmdsFromCapsuleCmdsJob2 = generateSphereCmdsFromCapsuleCmdsJob;
		IJobExtensions.RunByRef<GenerateSphereCmdsFromCapsuleCmdsJob>(ref generateSphereCmdsFromCapsuleCmdsJob2);
		ExecuteOverlapSphereCommands(sphereCommands.AsArray(), hits2, maxResPerCast);
		ScatterColliderHitsJob scatterColliderHitsJob = default(ScatterColliderHitsJob);
		scatterColliderHitsJob.To = hits;
		scatterColliderHitsJob.From = hits2.AsReadOnly();
		scatterColliderHitsJob.Indices = val.AsReadOnly();
		scatterColliderHitsJob.MaxHitsPerRay = maxResPerCast;
		ScatterColliderHitsJob scatterColliderHitsJob2 = scatterColliderHitsJob;
		IJobExtensions.RunByRef<ScatterColliderHitsJob>(ref scatterColliderHitsJob2);
		sphereCommands.Dispose();
		if (val.Length != commands.Length)
		{
			NativeArray<bool> workBuffer = default(NativeArray<bool>);
			workBuffer..ctor(commands.Length, (Allocator)3, (NativeArrayOptions)0);
			InvertIndexListJob invertIndexListJob = default(InvertIndexListJob);
			invertIndexListJob.Indices = val;
			invertIndexListJob.WorkBuffer = workBuffer;
			InvertIndexListJob invertIndexListJob2 = invertIndexListJob;
			IJobExtensions.RunByRef<InvertIndexListJob>(ref invertIndexListJob2);
			workBuffer.Dispose();
			NativeArray<OverlapCapsuleCommand> val2 = default(NativeArray<OverlapCapsuleCommand>);
			val2..ctor(val.Length, (Allocator)3, (NativeArrayOptions)0);
			GatherJob<OverlapCapsuleCommand> gatherJob = default(GatherJob<OverlapCapsuleCommand>);
			gatherJob.Results = val2;
			gatherJob.Source = commands.AsReadOnly();
			gatherJob.Indices = val.AsReadOnly();
			GatherJob<OverlapCapsuleCommand> gatherJob2 = gatherJob;
			IJobExtensions.RunByRef<GatherJob<OverlapCapsuleCommand>>(ref gatherJob2);
			ExecuteOverlapCapsuleCommands(val2, hits2, maxResPerCast);
			scatterColliderHitsJob = default(ScatterColliderHitsJob);
			scatterColliderHitsJob.To = hits;
			scatterColliderHitsJob.From = hits2.AsReadOnly();
			scatterColliderHitsJob.Indices = val.AsReadOnly();
			scatterColliderHitsJob.MaxHitsPerRay = maxResPerCast;
			ScatterColliderHitsJob scatterColliderHitsJob3 = scatterColliderHitsJob;
			IJobExtensions.RunByRef<ScatterColliderHitsJob>(ref scatterColliderHitsJob3);
			val2.Dispose();
		}
		hits2.Dispose();
		val.Dispose();
	}

	private static void ExecuteOverlapCapsuleCommands(NativeArray<OverlapCapsuleCommand> commands, NativeArray<ColliderHit> hits, int maxResPerCast)
	{
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (Debug.isDebugBuild)
		{
			NativeList<int> invalidIndices = default(NativeList<int>);
			invalidIndices..ctor(commands.Length, AllocatorHandle.op_Implicit((Allocator)3));
			ValidateOverlapCapsuleCommandsJob validateOverlapCapsuleCommandsJob = default(ValidateOverlapCapsuleCommandsJob);
			validateOverlapCapsuleCommandsJob.InvalidIndices = invalidIndices;
			validateOverlapCapsuleCommandsJob.Commands = commands.AsReadOnly();
			ValidateOverlapCapsuleCommandsJob validateOverlapCapsuleCommandsJob2 = validateOverlapCapsuleCommandsJob;
			IJobExtensions.RunByRef<ValidateOverlapCapsuleCommandsJob>(ref validateOverlapCapsuleCommandsJob2);
			if (!invalidIndices.IsEmpty)
			{
				int num = invalidIndices[0];
				OverlapCapsuleCommand val = commands[num];
				Debug.LogError((object)string.Concat(string.Concat(string.Concat(string.Concat($"OverlapCapsules has {invalidIndices.Length} invalid sphere commands!" + $"\nFirst one was at index {num}:", $"\n\tPoint0: {((OverlapCapsuleCommand)(ref val)).point0}"), $"\n\tPoint1: {((OverlapCapsuleCommand)(ref val)).point1}"), $"\n\tRadius: {((OverlapCapsuleCommand)(ref val)).radius}"), "\nThese queries will be skipped!"));
			}
			invalidIndices.Dispose();
		}
		int batchSize = GetBatchSize(commands.Length);
		JobHandle val2 = OverlapCapsuleCommand.ScheduleBatch(commands, hits, batchSize, maxResPerCast, default(JobHandle));
		((JobHandle)(ref val2)).Complete();
	}

	public static void OverlapOBB(OBB obb, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		int count = Physics.OverlapBoxNonAlloc(obb.position, obb.extents, colBuffer, obb.rotation, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapBounds(Bounds bounds, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(((Bounds)(ref bounds)).center, layerMask);
		int count = Physics.OverlapBoxNonAlloc(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).extents, colBuffer, Quaternion.identity, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	private static void BufferToList(Collider[] buffer, int count, List<Collider> list)
	{
		for (int i = 0; i < count; i++)
		{
			list.Add(buffer[i]);
			buffer[i] = null;
		}
	}

	public static bool CheckSphere<T>(Vector3 pos, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapSphere(pos, radius, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static void CheckSpheres<T>(ReadOnly<Vector3> positions, ReadOnly<float> radii, ReadOnly<int> layerMasks, Span<bool> results, QueryTriggerInteraction triggerInteraction = 1, int maxResPerCast = 16, MasksToValidate validate = MasksToValidate.All) where T : Component
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckSpheres<T>", 0);
		try
		{
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(positions.Length * maxResPerCast, (Allocator)3, (NativeArrayOptions)0);
			OverlapSpheres(positions, radii, layerMasks, hits, maxResPerCast, triggerInteraction, validate);
			TimeWarning val2 = TimeWarning.New("FindComponent", 0);
			try
			{
				T val4 = default(T);
				for (int i = 0; i < positions.Length; i++)
				{
					bool flag = false;
					int num = i * maxResPerCast;
					for (int j = 0; j < maxResPerCast; j++)
					{
						ColliderHit val3 = hits[num + j];
						if (((ColliderHit)(ref val3)).instanceID == 0)
						{
							break;
						}
						if (((Component)((ColliderHit)(ref val3)).collider).TryGetComponent<T>(ref val4))
						{
							flag = true;
							break;
						}
					}
					results[i] = flag;
				}
				hits.Dispose();
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool CheckCapsule<T>(Vector3 start, Vector3 end, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapCapsule(start, end, radius, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckOBB<T>(OBB obb, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapOBB(obb, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckBounds<T>(Bounds bounds, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapBounds(bounds, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private static bool CheckComponent<T>(List<Collider> list)
	{
		T val = default(T);
		for (int i = 0; i < list.Count; i++)
		{
			if (((Component)list[i]).gameObject.TryGetComponent<T>(ref val))
			{
				return true;
			}
		}
		return false;
	}

	public static void OverlapSphere<T>(Vector3 position, float radius, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position, layerMask);
		int count = Physics.OverlapSphereNonAlloc(position, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void CheckCapsules<T>(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> layerMasks, Span<bool> results, QueryTriggerInteraction triggerInteraction = 1, int maxResPerCast = 16, MasksToValidate validate = MasksToValidate.All, bool mitigateSpheres = true) where T : Component
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckCapsules<T>", 0);
		try
		{
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(starts.Length * maxResPerCast, (Allocator)3, (NativeArrayOptions)0);
			OverlapCapsules(starts, ends, radii, layerMasks, hits, maxResPerCast, triggerInteraction, validate, mitigateSpheres);
			TimeWarning val2 = TimeWarning.New("FindComponent", 0);
			try
			{
				T val4 = default(T);
				for (int i = 0; i < starts.Length; i++)
				{
					bool flag = false;
					int num = i * maxResPerCast;
					for (int j = 0; j < maxResPerCast; j++)
					{
						ColliderHit val3 = hits[num + j];
						if (((ColliderHit)(ref val3)).instanceID == 0)
						{
							break;
						}
						if (((Component)((ColliderHit)(ref val3)).collider).TryGetComponent<T>(ref val4))
						{
							flag = true;
							break;
						}
					}
					results[i] = flag;
				}
				hits.Dispose();
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void OverlapCapsule<T>(Vector3 point0, Vector3 point1, float radius, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(point0, layerMask);
		layerMask = HandleIgnoreCollision(point1, layerMask);
		int count = Physics.OverlapCapsuleNonAlloc(point0, point1, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapOBB<T>(OBB obb, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		int count = Physics.OverlapBoxNonAlloc(obb.position, obb.extents, colBuffer, obb.rotation, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapBounds<T>(Bounds bounds, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(((Bounds)(ref bounds)).center, layerMask);
		int count = Physics.OverlapBoxNonAlloc(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).extents, colBuffer, Quaternion.identity, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	private static void BufferToList<T>(Collider[] buffer, int count, List<T> list) where T : Component
	{
		T item = default(T);
		for (int i = 0; i < count; i++)
		{
			if (((Component)buffer[i]).TryGetComponent<T>(ref item))
			{
				list.Add(item);
			}
			buffer[i] = null;
		}
	}

	private static void HitBufferToList(int count, List<RaycastHit> list)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (count >= hitBuffer.Length)
		{
			Debug.LogWarning((object)"Physics query is exceeding collider buffer length.");
		}
		for (int i = 0; i < count; i++)
		{
			list.Add(hitBuffer[i]);
		}
	}

	public static bool TraceRealm(Realm realm, Ray ray, float radius, out RaycastHit hitInfo, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (Trace(ray, radius, out var hitInfo2, maxDistance, layerMask, triggerInteraction, ignoreEntity))
		{
			hitInfo = hitInfo2;
			return true;
		}
		hitInfo = default(RaycastHit);
		return false;
	}

	public static BaseNetworkable TraceRealmEntity(Realm realm, Ray ray, float radius = 0f, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!Trace(ray, radius, out var hitInfo, maxDistance, layerMask, triggerInteraction, ignoreEntity))
		{
			return null;
		}
		return hitInfo.GetEntity();
	}

	public static bool Trace(Ray ray, float radius, out RaycastHit hitInfo, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		TraceAllUnordered(ray, radius, list, maxDistance, layerMask, triggerInteraction, ignoreEntity);
		if (list.Count == 0)
		{
			hitInfo = default(RaycastHit);
			Pool.FreeUnmanaged<RaycastHit>(ref list);
			return false;
		}
		Sort(list);
		hitInfo = list[0];
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return true;
	}

	public static void TraceAll(Ray ray, float radius, List<RaycastHit> hits, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		TraceAllUnordered(ray, radius, hits, maxDistance, layerMask, triggerInteraction, ignoreEntity);
		Sort(hits);
	}

	public static void TraceAllUnordered(Ray ray, float radius, List<RaycastHit> hits, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		int num = ((radius != 0f) ? Physics.SphereCastNonAlloc(ray, radius, hitBuffer, maxDistance, layerMask, triggerInteraction) : Physics.RaycastNonAlloc(ray, hitBuffer, maxDistance, layerMask, triggerInteraction));
		if (num < hitBuffer.Length && (layerMask & 0x10) != 0 && WaterSystem.Trace(ray, out var position, out var normal, maxDistance))
		{
			RaycastHit val = default(RaycastHit);
			((RaycastHit)(ref val)).point = position;
			((RaycastHit)(ref val)).normal = normal;
			Vector3 val2 = position - ((Ray)(ref ray)).origin;
			((RaycastHit)(ref val)).distance = ((Vector3)(ref val2)).magnitude;
			RaycastHit val3 = val;
			hitBuffer[num++] = val3;
		}
		if (num == 0)
		{
			return;
		}
		if (num >= hitBuffer.Length)
		{
			Debug.LogWarning((object)"Physics query is exceeding hit buffer length.");
		}
		for (int i = 0; i < num; i++)
		{
			RaycastHit val4 = hitBuffer[i];
			if (Verify(val4, ((Ray)(ref ray)).origin, ignoreEntity))
			{
				hits.Add(val4);
			}
		}
	}

	public static void TraceRaysUnordered(NativeArray<RaycastCommand> rays, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.TraceRaysUnordered", 0);
		try
		{
			int batchSize = GetBatchSize(rays.Length);
			JobHandle inputDeps = RaycastCommand.ScheduleBatch(rays, hits, batchSize, maxHitsPerTrace, default(JobHandle));
			if (traceWater)
			{
				inputDeps = TraceWaterRaysDeferred(hits, rays, maxHitsPerTrace, inputDeps);
			}
			((JobHandle)(ref inputDeps)).Complete();
			VerifyRays(hits, rays, maxHitsPerTrace);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static JobHandle TraceWaterRaysDeferred(NativeArray<RaycastHit> hits, NativeArray<RaycastCommand> rays, int maxHitsPerTrace, JobHandle inputDeps)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ScheduleTraceWaterRaysDeferred", 0);
		try
		{
			if (!rays.IsCreated || rays.Length == 0)
			{
				return inputDeps;
			}
			NativeList<Vector2i> waterIndices = new NativeList<Vector2i>(rays.Length, AllocatorHandle.op_Implicit((Allocator)3));
			NativeList<Ray> val2 = new NativeList<Ray>(rays.Length, AllocatorHandle.op_Implicit((Allocator)3));
			NativeArray<bool> val3 = new NativeArray<bool>(rays.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<float> val4 = new NativeArray<float>(rays.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<Vector3> val5 = new NativeArray<Vector3>(rays.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<Vector3> val6 = new NativeArray<Vector3>(rays.Length, (Allocator)3, (NativeArrayOptions)0);
			PreProcessWaterRaysJob preProcessWaterRaysJob = default(PreProcessWaterRaysJob);
			preProcessWaterRaysJob.hits = hits;
			preProcessWaterRaysJob.rays = rays;
			preProcessWaterRaysJob.maxHitsPerTrace = maxHitsPerTrace;
			preProcessWaterRaysJob.WaterIndices = waterIndices;
			preProcessWaterRaysJob.WaterRays = val2;
			preProcessWaterRaysJob.WaterMaxDists = val4;
			PreProcessWaterRaysJob preProcessWaterRaysJob2 = preProcessWaterRaysJob;
			inputDeps = IJobExtensions.ScheduleByRef<PreProcessWaterRaysJob>(ref preProcessWaterRaysJob2, inputDeps);
			inputDeps = WaterSystem.ScheduleTraceBatchDefer(val2, val4, val3, val5, val6, inputDeps);
			PostProcessWaterRaysJob postProcessWaterRaysJob = default(PostProcessWaterRaysJob);
			postProcessWaterRaysJob.hits = hits;
			postProcessWaterRaysJob.rays = val2.AsDeferredJobArray();
			postProcessWaterRaysJob.WaterIndices = waterIndices;
			postProcessWaterRaysJob.hitsSub = val3;
			postProcessWaterRaysJob.positionsSub = val5;
			postProcessWaterRaysJob.normalsSub = val6;
			PostProcessWaterRaysJob postProcessWaterRaysJob2 = postProcessWaterRaysJob;
			inputDeps = IJobExtensions.ScheduleByRef<PostProcessWaterRaysJob>(ref postProcessWaterRaysJob2, inputDeps);
			waterIndices.Dispose(inputDeps);
			val2.Dispose(inputDeps);
			val3.Dispose(inputDeps);
			val4.Dispose(inputDeps);
			val5.Dispose(inputDeps);
			val6.Dispose(inputDeps);
			return inputDeps;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void VerifyRays(NativeArray<RaycastHit> hits, NativeArray<RaycastCommand> rays, int maxHitsPerCast)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("VerifyRays", 0);
		try
		{
			for (int i = 0; i < rays.Length; i++)
			{
				RaycastCommand val2 = rays[i];
				int num = i * maxHitsPerCast;
				int num2 = 0;
				RaycastHit val4;
				for (int j = 0; j < maxHitsPerCast; j++)
				{
					int num3 = i * maxHitsPerCast + j;
					RaycastHit val3 = hits[num3];
					val4 = hits[num3];
					if (((RaycastHit)(ref val4)).normal == Vector3.zero)
					{
						break;
					}
					if (Verify(val3, ((RaycastCommand)(ref val2)).from))
					{
						hits[num + num2++] = val3;
					}
				}
				if (num2 < maxHitsPerCast)
				{
					val4 = (hits[num + num2] = default(RaycastHit));
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void TraceRays(NativeArray<RaycastCommand> rays, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		TraceRaysUnordered(rays, hits, maxHitsPerTrace, traceWater);
		Sort(hits, rays.Length, maxHitsPerTrace);
	}

	public static void TraceSpheresUnordered(NativeArray<SpherecastCommand> spheres, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.TraceSpheresUnordered", 0);
		try
		{
			int batchSize = GetBatchSize(spheres.Length);
			JobHandle inputDeps = SpherecastCommand.ScheduleBatch(spheres, hits, batchSize, maxHitsPerTrace, default(JobHandle));
			if (traceWater)
			{
				inputDeps = TraceWaterSpheresDeferred(hits, spheres, maxHitsPerTrace, inputDeps);
			}
			((JobHandle)(ref inputDeps)).Complete();
			VerifySpheres(hits, spheres, maxHitsPerTrace);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static JobHandle TraceWaterSpheresDeferred(NativeArray<RaycastHit> hits, NativeArray<SpherecastCommand> spheres, int maxHitsPerTrace, JobHandle inputDeps)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ScheduleTraceWaterSpheresDeferred", 0);
		try
		{
			if (!spheres.IsCreated || spheres.Length == 0)
			{
				return inputDeps;
			}
			NativeList<Vector2i> waterIndices = new NativeList<Vector2i>(spheres.Length, AllocatorHandle.op_Implicit((Allocator)3));
			NativeList<Ray> val2 = new NativeList<Ray>(spheres.Length, AllocatorHandle.op_Implicit((Allocator)3));
			NativeArray<bool> val3 = new NativeArray<bool>(spheres.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<float> val4 = new NativeArray<float>(spheres.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<Vector3> val5 = new NativeArray<Vector3>(spheres.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<Vector3> val6 = new NativeArray<Vector3>(spheres.Length, (Allocator)3, (NativeArrayOptions)0);
			PreProcessWaterSpheresJob preProcessWaterSpheresJob = default(PreProcessWaterSpheresJob);
			preProcessWaterSpheresJob.hits = hits;
			preProcessWaterSpheresJob.rays = spheres;
			preProcessWaterSpheresJob.maxHitsPerTrace = maxHitsPerTrace;
			preProcessWaterSpheresJob.WaterIndices = waterIndices;
			preProcessWaterSpheresJob.WaterRays = val2;
			preProcessWaterSpheresJob.WaterMaxDists = val4;
			PreProcessWaterSpheresJob preProcessWaterSpheresJob2 = preProcessWaterSpheresJob;
			inputDeps = IJobExtensions.ScheduleByRef<PreProcessWaterSpheresJob>(ref preProcessWaterSpheresJob2, inputDeps);
			inputDeps = WaterSystem.ScheduleTraceBatchDefer(val2, val4, val3, val5, val6, inputDeps);
			PostProcessWaterRaysJob postProcessWaterRaysJob = default(PostProcessWaterRaysJob);
			postProcessWaterRaysJob.hits = hits;
			postProcessWaterRaysJob.rays = val2.AsDeferredJobArray();
			postProcessWaterRaysJob.WaterIndices = waterIndices;
			postProcessWaterRaysJob.hitsSub = val3;
			postProcessWaterRaysJob.positionsSub = val5;
			postProcessWaterRaysJob.normalsSub = val6;
			PostProcessWaterRaysJob postProcessWaterRaysJob2 = postProcessWaterRaysJob;
			inputDeps = IJobExtensions.ScheduleByRef<PostProcessWaterRaysJob>(ref postProcessWaterRaysJob2, inputDeps);
			waterIndices.Dispose(inputDeps);
			val2.Dispose(inputDeps);
			val3.Dispose(inputDeps);
			val4.Dispose(inputDeps);
			val5.Dispose(inputDeps);
			val6.Dispose(inputDeps);
			return inputDeps;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void VerifySpheres(NativeArray<RaycastHit> hits, NativeArray<SpherecastCommand> spheres, int maxHitsPerCast)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("VerifySpheres", 0);
		try
		{
			for (int i = 0; i < spheres.Length; i++)
			{
				SpherecastCommand val2 = spheres[i];
				int num = i * maxHitsPerCast;
				int num2 = 0;
				RaycastHit val4;
				for (int j = 0; j < maxHitsPerCast; j++)
				{
					int num3 = i * maxHitsPerCast + j;
					RaycastHit val3 = hits[num3];
					val4 = hits[num3];
					if (((RaycastHit)(ref val4)).normal == Vector3.zero)
					{
						break;
					}
					if (Verify(val3, ((SpherecastCommand)(ref val2)).origin))
					{
						hits[num + num2++] = val3;
					}
				}
				if (num2 < maxHitsPerCast)
				{
					val4 = (hits[num + num2] = default(RaycastHit));
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void TraceSpheres(NativeArray<SpherecastCommand> spheres, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		TraceSpheresUnordered(spheres, hits, maxHitsPerTrace, traceWater);
		Sort(hits, spheres.Length, maxHitsPerTrace);
	}

	public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding0, float padding1, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightInternal(p0, p1, layerMask, radius, padding0, padding1, ignoreEntity);
	}

	public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightInternal(p0, p1, layerMask, radius, padding, padding, ignoreEntity);
	}

	public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightInternal(p0, p1, layerMask, radius, 0f, 0f, ignoreEntity);
	}

	public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding0, float padding1, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightRadius(p0, p1, layerMask, 0f, padding0, padding1, ignoreEntity);
	}

	public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightRadius(p0, p1, layerMask, 0f, padding, padding, ignoreEntity);
	}

	public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightRadius(p0, p1, layerMask, 0f, 0f, 0f, ignoreEntity);
	}

	private static bool LineOfSightInternal(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding0, float padding1, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		if (!ValidBounds.TestOuterBounds(p0))
		{
			return false;
		}
		if (!ValidBounds.TestOuterBounds(p1))
		{
			return false;
		}
		Vector3 val = p1 - p0;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (magnitude <= padding0 + padding1)
		{
			return true;
		}
		Vector3 val2 = val / magnitude;
		Ray val3 = default(Ray);
		((Ray)(ref val3))..ctor(p0 + val2 * padding0, val2);
		float num = magnitude - padding0 - padding1;
		bool flag;
		RaycastHit hitInfo = default(RaycastHit);
		if (!ignoreEntity.IsRealNull() || (layerMask & 0x800000) != 0)
		{
			flag = Trace(val3, 0f, out hitInfo, num, layerMask, (QueryTriggerInteraction)1, ignoreEntity);
			if (radius > 0f && !flag)
			{
				flag = Trace(val3, radius, out hitInfo, num, layerMask, (QueryTriggerInteraction)1, ignoreEntity);
			}
		}
		else
		{
			flag = Physics.Raycast(val3, ref hitInfo, num, layerMask, (QueryTriggerInteraction)1);
			if (radius > 0f && !flag)
			{
				flag = Physics.SphereCast(val3, radius, ref hitInfo, num, layerMask, (QueryTriggerInteraction)1);
			}
		}
		if (!flag)
		{
			if (ConVar.Vis.lineofsight)
			{
				ConsoleNetwork.BroadcastToAllClients("ddraw.line", 60f, Color.green, p0, p1);
			}
			return true;
		}
		if (ConVar.Vis.lineofsight)
		{
			ConsoleNetwork.BroadcastToAllClients("ddraw.line", 60f, Color.red, p0, p1);
			ConsoleNetwork.BroadcastToAllClients("ddraw.text", 60f, Color.white, ((RaycastHit)(ref hitInfo)).point, ((Object)((RaycastHit)(ref hitInfo)).collider).name);
		}
		return false;
	}

	public static bool Verify(RaycastHit hitInfo, Vector3 rayOrigin, BaseEntity ignoreEntity = null)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((RaycastHit)(ref hitInfo)).point;
		if (((RaycastHit)(ref hitInfo)).collider is TerrainCollider && val == Vector3.zero && ((RaycastHit)(ref hitInfo)).distance == 0f)
		{
			val = rayOrigin;
		}
		return Verify(((RaycastHit)(ref hitInfo)).collider, val, ignoreEntity);
	}

	public static bool Verify(Collider collider, Vector3 point, BaseEntity ignoreEntity = null)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)collider == (Object)null)
		{
			if (Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(point))
			{
				return false;
			}
			return true;
		}
		if (collider is TerrainCollider)
		{
			if (Object.op_Implicit((Object)(object)TerrainMeta.Collision) && TerrainMeta.Collision.GetIgnore(point))
			{
				return false;
			}
			return true;
		}
		if (!ignoreEntity.IsRealNull() && CompareEntity(collider.ToBaseEntity(), ignoreEntity))
		{
			return false;
		}
		return collider.enabled;
	}

	public static bool CompareEntity(BaseEntity a, BaseEntity b)
	{
		if (a.IsRealNull() || b.IsRealNull())
		{
			return false;
		}
		if ((Object)(object)a == (Object)(object)b)
		{
			return true;
		}
		return false;
	}

	public static int HandleIgnoreCollision(Vector3 position, int layerMask)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		int num = 8388608;
		if ((layerMask & num) != 0 && Object.op_Implicit((Object)(object)TerrainMeta.Collision) && TerrainMeta.Collision.GetIgnore(position))
		{
			layerMask &= ~num;
		}
		int num2 = 16;
		if ((layerMask & num2) != 0 && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(position))
		{
			layerMask &= ~num2;
		}
		return layerMask;
	}

	public static void HandleIgnoreTerrain(ReadOnly<Vector3> positions, NativeArray<bool> hitIgnoreVolumes)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<float> values = default(NativeArray<float>);
		values..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
		FillJob<float> fillJob = default(FillJob<float>);
		fillJob.Values = values;
		fillJob.Value = 0.01f;
		FillJob<float> fillJob2 = fillJob;
		IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
		TerrainMeta.Collision.GetIgnore(positions, values.AsReadOnly(), hitIgnoreVolumes);
		values.Dispose();
	}

	public static void HandleIgnoreWater(ReadOnly<Vector3> positions, NativeArray<bool> hitIgnoreVolumes)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<float> values = default(NativeArray<float>);
		values..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
		FillJob<float> fillJob = default(FillJob<float>);
		fillJob.Values = values;
		fillJob.Value = 0.01f;
		FillJob<float> fillJob2 = fillJob;
		IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
		WaterSystem.Collision.GetIgnore(positions, values.AsReadOnly(), hitIgnoreVolumes);
		values.Dispose();
	}

	public static void HandleIgnoreCollision(ReadOnly<Vector3> positions, NativeArray<int> layerMasks, MasksToValidate validate = MasksToValidate.All)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (validate.HasFlag(MasksToValidate.Terrain))
		{
			NativeArray<bool> hitIgnoreVolumes = default(NativeArray<bool>);
			hitIgnoreVolumes..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
			HandleIgnoreTerrain(positions, hitIgnoreVolumes);
			RemoveLayerMaskJob removeLayerMaskJob = default(RemoveLayerMaskJob);
			removeLayerMaskJob.LayerMasks = layerMasks;
			removeLayerMaskJob.ShouldIgnore = hitIgnoreVolumes.AsReadOnly();
			removeLayerMaskJob.MaskToRemove = 8388608;
			RemoveLayerMaskJob removeLayerMaskJob2 = removeLayerMaskJob;
			IJobExtensions.RunByRef<RemoveLayerMaskJob>(ref removeLayerMaskJob2);
			hitIgnoreVolumes.Dispose();
		}
		if (validate.HasFlag(MasksToValidate.Water))
		{
			NativeArray<bool> hitIgnoreVolumes2 = default(NativeArray<bool>);
			hitIgnoreVolumes2..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
			HandleIgnoreWater(positions, hitIgnoreVolumes2);
			RemoveLayerMaskJob removeLayerMaskJob = default(RemoveLayerMaskJob);
			removeLayerMaskJob.LayerMasks = layerMasks;
			removeLayerMaskJob.ShouldIgnore = hitIgnoreVolumes2.AsReadOnly();
			removeLayerMaskJob.MaskToRemove = 16;
			RemoveLayerMaskJob removeLayerMaskJob3 = removeLayerMaskJob;
			IJobExtensions.RunByRef<RemoveLayerMaskJob>(ref removeLayerMaskJob3);
			hitIgnoreVolumes2.Dispose();
		}
	}

	public static void Sort(List<RaycastHit> hits)
	{
		hits.Sort((RaycastHit a, RaycastHit b) => ((RaycastHit)(ref a)).distance.CompareTo(((RaycastHit)(ref b)).distance));
	}

	public static void Sort(RaycastHit[] hits)
	{
		Array.Sort(hits, (RaycastHit a, RaycastHit b) => ((RaycastHit)(ref a)).distance.CompareTo(((RaycastHit)(ref b)).distance));
	}

	public static void Sort(NativeArray<RaycastHit> hits, int queryCount, int maxHitsPerQuery)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.Sort", 0);
		try
		{
			NativeArray<int> counts = new NativeArray<int>(queryCount, (Allocator)3, (NativeArrayOptions)0);
			CountRaycastHitsJobs countRaycastHitsJobs = default(CountRaycastHitsJobs);
			countRaycastHitsJobs.Counts = counts;
			countRaycastHitsJobs.Hits = hits.AsReadOnly();
			countRaycastHitsJobs.MaxHitsPerRay = maxHitsPerQuery;
			CountRaycastHitsJobs countRaycastHitsJobs2 = countRaycastHitsJobs;
			IJobExtensions.RunByRef<CountRaycastHitsJobs>(ref countRaycastHitsJobs2);
			for (int i = 0; i < counts.Length; i++)
			{
				int num = counts[i];
				if (num > 1)
				{
					SortJob<RaycastHit, RaycastHitComparer> val2 = NativeSortExtension.SortJob<RaycastHit, RaycastHitComparer>(hits.GetSubArray(i * maxHitsPerQuery, num), default(RaycastHitComparer));
					JobHandle val3 = default(JobHandle);
					val3 = val2.Schedule(val3);
					((JobHandle)(ref val3)).Complete();
				}
			}
			counts.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static int GetBatchSize(int count, int subdivideFactor = 4, int minBatchSize = 64)
	{
		return Math.Max(count / JobsUtility.JobWorkerCount / subdivideFactor, minBatchSize);
	}
}


public enum Realm
{
	Client,
	Server
}


using System;

[Flags]
public enum MasksToValidate : byte
{
	None = 0,
	Terrain = 1,
	Water = 2,
	All = 3
}


using EZhex1991.EZSoftBone;
using UnityEngine;

[RequireComponent(typeof(HitboxSystem))]
public class EZSoftBoneHitboxSystemCollider : EZSoftBoneColliderBase, IClientComponent
{
	public float radius = 2f;

	public override void Collide(ref Vector3 position, float spacing)
	{
	}
}


public class HitboxCollision : BaseCollision
{
}


using UnityEngine;

public class HitboxDefinition : MonoBehaviour
{
	public enum Type
	{
		BOX,
		CAPSULE
	}

	public Vector3 center;

	public Vector3 rotation;

	public Type type;

	public int priority;

	public PhysicMaterial physicMaterial;

	[SerializeField]
	private Vector3 scale = Vector3.one;

	public Vector3 Scale
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return scale;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			scale = new Vector3(Mathf.Abs(value.x), Mathf.Abs(value.y), Mathf.Abs(value.z));
		}
	}

	public Matrix4x4 LocalMatrix => Matrix4x4.TRS(center, Quaternion.Euler(rotation), scale);

	private void OnValidate()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Scale = Scale;
	}

	protected virtual void OnDrawGizmosSelected()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		switch (type)
		{
		case Type.BOX:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), scale);
			Gizmos.color = new Color(0f, 1f, 0f, 0.2f);
			Gizmos.DrawCube(Vector3.zero, Vector3.one);
			Gizmos.color = Color.green;
			Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		case Type.CAPSULE:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), Vector3.one);
			Gizmos.color = Color.green;
			GizmosUtil.DrawWireCapsuleY(Vector3.zero, scale.x, scale.y);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		}
	}

	protected virtual void OnDrawGizmos()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		switch (type)
		{
		case Type.BOX:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), scale);
			Gizmos.color = Color.black;
			Gizmos.DrawSphere(Vector3.zero, 0.005f);
			Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
			Gizmos.color = new Color(1f, 0f, 0f, 0.2f);
			Gizmos.DrawCube(Vector3.zero, Vector3.one);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		case Type.CAPSULE:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), Vector3.one);
			Gizmos.color = Color.black;
			Gizmos.DrawSphere(Vector3.zero, 0.005f);
			GizmosUtil.DrawWireCapsuleY(Vector3.zero, scale.x, scale.y);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		}
	}
}


public enum Type
{
	BOX,
	CAPSULE
}


using System;
using System.Collections.Generic;
using System.Linq;
using Development.Attributes;
using Facepunch;
using UnityEngine;

[ResetStaticFields]
public class HitboxSystem : MonoBehaviour, IPrefabPreProcess
{
	[Serializable]
	public class HitboxShape
	{
		public struct JobStruct
		{
			public Matrix4x4 transform;

			public Matrix4x4 inverseTransform;

			public Vector3 size;

			public HitboxDefinition.Type type;
		}

		public Transform bone;

		public HitboxDefinition.Type type;

		public Matrix4x4 localTransform;

		public PhysicMaterial colliderMaterial;

		private Matrix4x4 transform;

		private Matrix4x4 inverseTransform;

		public Matrix4x4 Transform => transform;

		public Vector3 Position => ((Matrix4x4)(ref transform)).MultiplyPoint(Vector3.zero);

		public Quaternion Rotation => ((Matrix4x4)(ref transform)).rotation;

		public Vector3 Size { get; private set; }

		public void UpdateTransform()
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("HitboxSystem.UpdateTransform", 0);
			try
			{
				transform = bone.localToWorldMatrix * localTransform;
				Size = ((Matrix4x4)(ref transform)).lossyScale;
				transform = Matrix4x4.TRS(Position, Rotation, Vector3.one);
				inverseTransform = ((Matrix4x4)(ref transform)).inverse;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public Vector3 TransformPoint(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref transform)).MultiplyPoint(pt);
		}

		public Vector3 InverseTransformPoint(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref inverseTransform)).MultiplyPoint(pt);
		}

		public Vector3 TransformDirection(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref transform)).MultiplyVector(pt);
		}

		public Vector3 InverseTransformDirection(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref inverseTransform)).MultiplyVector(pt);
		}

		public JobStruct GetJobStruct()
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			JobStruct result = default(JobStruct);
			result.transform = transform;
			result.inverseTransform = inverseTransform;
			result.size = Size;
			result.type = type;
			return result;
		}

		public bool Trace(Ray ray, out RaycastHit hit, float forgivness = 0f, float maxDistance = float.PositiveInfinity)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("Hitbox.Trace", 0);
			try
			{
				((Ray)(ref ray)).origin = InverseTransformPoint(((Ray)(ref ray)).origin);
				((Ray)(ref ray)).direction = InverseTransformDirection(((Ray)(ref ray)).direction);
				if (type == HitboxDefinition.Type.BOX)
				{
					AABB val2 = default(AABB);
					((AABB)(ref val2))..ctor(Vector3.zero, Size);
					if (!((AABB)(ref val2)).Trace(ray, ref hit, forgivness, maxDistance))
					{
						return false;
					}
				}
				else
				{
					Capsule val3 = default(Capsule);
					((Capsule)(ref val3))..ctor(Vector3.zero, Size.x, Size.y * 0.5f);
					if (!((Capsule)(ref val3)).Trace(ray, ref hit, forgivness, maxDistance))
					{
						return false;
					}
				}
				((RaycastHit)(ref hit)).point = TransformPoint(((RaycastHit)(ref hit)).point);
				((RaycastHit)(ref hit)).normal = TransformDirection(((RaycastHit)(ref hit)).normal);
				return true;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public Bounds GetBounds()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			Matrix4x4 val = Transform;
			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					((Matrix4x4)(ref val))[i, j] = Mathf.Abs(((Matrix4x4)(ref val))[i, j]);
				}
			}
			Bounds result = default(Bounds);
			Matrix4x4 val2 = Transform;
			((Bounds)(ref result)).center = ((Matrix4x4)(ref val2)).MultiplyPoint(Vector3.zero);
			((Bounds)(ref result)).extents = ((Matrix4x4)(ref val)).MultiplyVector(Size);
			return result;
		}
	}

	public List<HitboxShape> hitboxes = new List<HitboxShape>();

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		List<HitboxDefinition> list = Pool.Get<List<HitboxDefinition>>();
		((Component)this).GetComponentsInChildren<HitboxDefinition>(list);
		if (serverside)
		{
			foreach (HitboxDefinition item2 in list)
			{
				if (preProcess != null)
				{
					preProcess.RemoveComponent((Component)(object)item2);
				}
			}
			if (preProcess != null)
			{
				preProcess.RemoveComponent((Component)(object)this);
			}
		}
		if (clientside)
		{
			hitboxes.Clear();
			foreach (HitboxDefinition item3 in list.OrderBy((HitboxDefinition x) => x.priority))
			{
				HitboxShape item = new HitboxShape
				{
					bone = ((Component)item3).transform,
					localTransform = item3.LocalMatrix,
					colliderMaterial = item3.physicMaterial,
					type = item3.type
				};
				hitboxes.Add(item);
				if (preProcess != null)
				{
					preProcess.RemoveComponent((Component)(object)item3);
				}
			}
		}
		Pool.FreeUnmanaged<HitboxDefinition>(ref list);
	}
}


using System;
using UnityEngine;

[Serializable]
public class HitboxShape
{
	public struct JobStruct
	{
		public Matrix4x4 transform;

		public Matrix4x4 inverseTransform;

		public Vector3 size;

		public HitboxDefinition.Type type;
	}

	public Transform bone;

	public HitboxDefinition.Type type;

	public Matrix4x4 localTransform;

	public PhysicMaterial colliderMaterial;

	private Matrix4x4 transform;

	private Matrix4x4 inverseTransform;

	public Matrix4x4 Transform => transform;

	public Vector3 Position => ((Matrix4x4)(ref transform)).MultiplyPoint(Vector3.zero);

	public Quaternion Rotation => ((Matrix4x4)(ref transform)).rotation;

	public Vector3 Size { get; private set; }

	public void UpdateTransform()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("HitboxSystem.UpdateTransform", 0);
		try
		{
			transform = bone.localToWorldMatrix * localTransform;
			Size = ((Matrix4x4)(ref transform)).lossyScale;
			transform = Matrix4x4.TRS(Position, Rotation, Vector3.one);
			inverseTransform = ((Matrix4x4)(ref transform)).inverse;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Vector3 TransformPoint(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref transform)).MultiplyPoint(pt);
	}

	public Vector3 InverseTransformPoint(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref inverseTransform)).MultiplyPoint(pt);
	}

	public Vector3 TransformDirection(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref transform)).MultiplyVector(pt);
	}

	public Vector3 InverseTransformDirection(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref inverseTransform)).MultiplyVector(pt);
	}

	public JobStruct GetJobStruct()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		JobStruct result = default(JobStruct);
		result.transform = transform;
		result.inverseTransform = inverseTransform;
		result.size = Size;
		result.type = type;
		return result;
	}

	public bool Trace(Ray ray, out RaycastHit hit, float forgivness = 0f, float maxDistance = float.PositiveInfinity)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Hitbox.Trace", 0);
		try
		{
			((Ray)(ref ray)).origin = InverseTransformPoint(((Ray)(ref ray)).origin);
			((Ray)(ref ray)).direction = InverseTransformDirection(((Ray)(ref ray)).direction);
			if (type == HitboxDefinition.Type.BOX)
			{
				AABB val2 = default(AABB);
				((AABB)(ref val2))..ctor(Vector3.zero, Size);
				if (!((AABB)(ref val2)).Trace(ray, ref hit, forgivness, maxDistance))
				{
					return false;
				}
			}
			else
			{
				Capsule val3 = default(Capsule);
				((Capsule)(ref val3))..ctor(Vector3.zero, Size.x, Size.y * 0.5f);
				if (!((Capsule)(ref val3)).Trace(ray, ref hit, forgivness, maxDistance))
				{
					return false;
				}
			}
			((RaycastHit)(ref hit)).point = TransformPoint(((RaycastHit)(ref hit)).point);
			((RaycastHit)(ref hit)).normal = TransformDirection(((RaycastHit)(ref hit)).normal);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Bounds GetBounds()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 val = Transform;
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				((Matrix4x4)(ref val))[i, j] = Mathf.Abs(((Matrix4x4)(ref val))[i, j]);
			}
		}
		Bounds result = default(Bounds);
		Matrix4x4 val2 = Transform;
		((Bounds)(ref result)).center = ((Matrix4x4)(ref val2)).MultiplyPoint(Vector3.zero);
		((Bounds)(ref result)).extents = ((Matrix4x4)(ref val)).MultiplyVector(Size);
		return result;
	}
}


using UnityEngine;

public struct JobStruct
{
	public Matrix4x4 transform;

	public Matrix4x4 inverseTransform;

	public Vector3 size;

	public HitboxDefinition.Type type;
}


using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public class Buttons
{
	public class ConButton : IConsoleButton
	{
		private int frame;

		private TimeSince _timePressed;

		public bool IsDown { get; set; }

		public TimeSince TimePressed
		{
			get
			{
				//IL_0014: Unknown result type (might be due to invalid IL or missing references)
				//IL_000d: Unknown result type (might be due to invalid IL or missing references)
				if (!IsDown)
				{
					return TimeSince.op_Implicit(0f);
				}
				return _timePressed;
			}
		}

		public bool JustPressed
		{
			get
			{
				if (IsDown)
				{
					return frame == Time.frameCount;
				}
				return false;
			}
		}

		public bool JustReleased
		{
			get
			{
				if (!IsDown)
				{
					return frame == Time.frameCount;
				}
				return false;
			}
		}

		public bool IsPressed
		{
			get
			{
				return IsDown;
			}
			set
			{
				//IL_0022: Unknown result type (might be due to invalid IL or missing references)
				//IL_0027: Unknown result type (might be due to invalid IL or missing references)
				if (value != IsDown)
				{
					IsDown = value;
					frame = Time.frameCount;
					_timePressed = TimeSince.op_Implicit(0f);
				}
			}
		}

		public void Reset()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			_timePressed = default(TimeSince);
			IsDown = false;
			frame = 0;
		}

		public void Call(Arg arg)
		{
		}
	}
}


using UnityEngine;

public class ConButton : IConsoleButton
{
	private int frame;

	private TimeSince _timePressed;

	public bool IsDown { get; set; }

	public TimeSince TimePressed
	{
		get
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			if (!IsDown)
			{
				return TimeSince.op_Implicit(0f);
			}
			return _timePressed;
		}
	}

	public bool JustPressed
	{
		get
		{
			if (IsDown)
			{
				return frame == Time.frameCount;
			}
			return false;
		}
	}

	public bool JustReleased
	{
		get
		{
			if (!IsDown)
			{
				return frame == Time.frameCount;
			}
			return false;
		}
	}

	public bool IsPressed
	{
		get
		{
			return IsDown;
		}
		set
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			if (value != IsDown)
			{
				IsDown = value;
				frame = Time.frameCount;
				_timePressed = TimeSince.op_Implicit(0f);
			}
		}
	}

	public void Reset()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		_timePressed = default(TimeSince);
		IsDown = false;
		frame = 0;
	}

	public void Call(Arg arg)
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[Factory("meta")]
public class Meta : ConsoleSystem
{
	[ServerVar(Clientside = true, Help = "add <convar> <amount> - adds amount to convar")]
	public static void add(Arg args)
	{
		string @string = args.GetString(0, "");
		float @float = args.GetFloat(1, 0.1f);
		Command val = Find(@string);
		float result;
		if (val == null)
		{
			args.ReplyWith("Convar not found: " + (@string ?? "<null>"));
		}
		else if (args.IsClientside && val.Replicated)
		{
			args.ReplyWith("Cannot set replicated convars from the client (use sv to do this)");
		}
		else if (args.IsServerside && val.ServerAdmin && !args.IsAdmin)
		{
			args.ReplyWith("Permission denied");
		}
		else if (!float.TryParse(val.String, out result))
		{
			args.ReplyWith("Convar value cannot be parsed as a number");
		}
		else
		{
			val.Set(result + @float);
		}
	}

	[ClientVar(Help = "if_true <command> <condition> - runs a command if the condition is true")]
	public static void if_true(Arg args)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		bool @bool = args.GetBool(1, false);
		if (@bool)
		{
			ConsoleSystem.Run(Option.Client, @string, new object[1] { @bool });
		}
	}

	[ClientVar(Help = "if_false <command> <condition> - runs a command if the condition is false")]
	public static void if_false(Arg args)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		bool @bool = args.GetBool(1, true);
		if (!@bool)
		{
			ConsoleSystem.Run(Option.Client, @string, new object[1] { @bool });
		}
	}

	[ClientVar(Help = "reset_cycle <key> - resets a cycled bind to the beginning")]
	public static void reset_cycle(Arg args)
	{
		string @string = args.GetString(0, "");
		List<KeyCode> list = default(List<KeyCode>);
		KeyCombos.TryParse(ref @string, ref list);
		Button button = Input.GetButton(@string);
		if (button == null)
		{
			args.ReplyWith("Button not found");
		}
		else if (!button.Cycle)
		{
			args.ReplyWith("Button does not have a cycled bind");
		}
		else
		{
			button.CycleIndex = 0;
		}
	}

	[ClientVar(Help = "exec [command_1] ... - runs all of the commands passed as arguments (also, if the last argument is true/false then that will flow into each command's arguments)")]
	public static void exec(Arg args)
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		List<string> list = Pool.Get<List<string>>();
		for (int i = 0; i < 32; i++)
		{
			string @string = args.GetString(i, "");
			if (string.IsNullOrWhiteSpace(@string))
			{
				break;
			}
			list.Add(@string);
		}
		if (list.Count > 0)
		{
			string text = null;
			string text2 = list[list.Count - 1];
			if (bool.TryParse(text2, out var _))
			{
				text = text2;
				list.RemoveAt(list.Count - 1);
			}
			foreach (string item in list)
			{
				if (text != null)
				{
					ConsoleSystem.Run(Option.Client, item, new object[1] { text });
				}
				else
				{
					ConsoleSystem.Run(Option.Client, item, Array.Empty<object>());
				}
			}
		}
		Pool.FreeUnmanaged<string>(ref list);
	}

	private static Command Find(string name)
	{
		Command val = Server.Find(name);
		if (val != null)
		{
			return val;
		}
		return null;
	}
}


using System;
using System.Runtime.InteropServices;

public static class WindowsAffinityShim
{
	[DllImport("kernel32.dll")]
	public static extern bool SetProcessAffinityMask(IntPtr process, IntPtr mask);

	[DllImport("kernel32.dll")]
	public static extern bool SetPriorityClass(IntPtr process, uint mask);
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public class ArticulatedOccludee : BaseMonoBehaviour
{
	private const float UpdateBoundsFadeStart = 20f;

	private const float UpdateBoundsFadeLength = 1000f;

	private const float UpdateBoundsMaxFrequency = 15f;

	private const float UpdateBoundsMinFrequency = 0.5f;

	private LODGroup lodGroup;

	public List<Collider> colliders = new List<Collider>();

	private OccludeeSphere localOccludee = new OccludeeSphere(-1);

	private List<Renderer> renderers = new List<Renderer>();

	private bool isVisible = true;

	private Action TriggerUpdateVisibilityBoundsDelegate;

	public bool IsVisible => isVisible;

	protected virtual void OnDisable()
	{
		if (!Application.isQuitting)
		{
			UnregisterFromCulling();
			ClearVisibility();
		}
	}

	private void ClearVisibility()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)lodGroup != (Object)null)
		{
			lodGroup.localReferencePoint = Vector3.zero;
			lodGroup.RecalculateBounds();
			lodGroup = null;
		}
		if (renderers != null)
		{
			renderers.Clear();
		}
		localOccludee = new OccludeeSphere(-1);
	}

	public void ProcessVisibility(LODGroup lod)
	{
		lodGroup = lod;
		if ((Object)(object)lod != (Object)null)
		{
			renderers = new List<Renderer>(16);
			LOD[] lODs = lod.GetLODs();
			for (int i = 0; i < lODs.Length; i++)
			{
				Renderer[] array = lODs[i].renderers;
				foreach (Renderer val in array)
				{
					if ((Object)(object)val != (Object)null)
					{
						renderers.Add(val);
					}
				}
			}
		}
		UpdateCullingBounds();
	}

	private void RegisterForCulling(OcclusionCulling.Sphere sphere, bool visible)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (localOccludee.IsRegistered)
		{
			UnregisterFromCulling();
		}
		int num = OcclusionCulling.RegisterOccludee(sphere.position, sphere.radius, visible, 0.25f, isStatic: false, ((Component)this).gameObject.layer, OnVisibilityChanged);
		if (num >= 0)
		{
			localOccludee = new OccludeeSphere(num, localOccludee.sphere);
			return;
		}
		localOccludee.Invalidate();
		Debug.LogWarning((object)("[OcclusionCulling] Occludee registration failed for " + ((Object)this).name + ". Too many registered."));
	}

	private void UnregisterFromCulling()
	{
		if (localOccludee.IsRegistered)
		{
			OcclusionCulling.UnregisterOccludee(localOccludee.id);
			localOccludee.Invalidate();
		}
	}

	public void UpdateCullingBounds()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0315: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		Vector3 val2 = Vector3.zero;
		bool flag = false;
		int num = ((renderers != null) ? renderers.Count : 0);
		int num2 = ((colliders != null) ? colliders.Count : 0);
		if (num > 0 && (num2 == 0 || num < num2))
		{
			for (int i = 0; i < renderers.Count; i++)
			{
				if (renderers[i].isVisible)
				{
					Bounds bounds = renderers[i].bounds;
					Vector3 min = ((Bounds)(ref bounds)).min;
					Vector3 max = ((Bounds)(ref bounds)).max;
					if (!flag)
					{
						val = min;
						val2 = max;
						flag = true;
						continue;
					}
					val.x = ((val.x < min.x) ? val.x : min.x);
					val.y = ((val.y < min.y) ? val.y : min.y);
					val.z = ((val.z < min.z) ? val.z : min.z);
					val2.x = ((val2.x > max.x) ? val2.x : max.x);
					val2.y = ((val2.y > max.y) ? val2.y : max.y);
					val2.z = ((val2.z > max.z) ? val2.z : max.z);
				}
			}
		}
		if (!flag && num2 > 0)
		{
			flag = true;
			Bounds bounds2 = colliders[0].bounds;
			val = ((Bounds)(ref bounds2)).min;
			bounds2 = colliders[0].bounds;
			val2 = ((Bounds)(ref bounds2)).max;
			for (int j = 1; j < colliders.Count; j++)
			{
				Bounds bounds3 = colliders[j].bounds;
				Vector3 min2 = ((Bounds)(ref bounds3)).min;
				Vector3 max2 = ((Bounds)(ref bounds3)).max;
				val.x = ((val.x < min2.x) ? val.x : min2.x);
				val.y = ((val.y < min2.y) ? val.y : min2.y);
				val.z = ((val.z < min2.z) ? val.z : min2.z);
				val2.x = ((val2.x > max2.x) ? val2.x : max2.x);
				val2.y = ((val2.y > max2.y) ? val2.y : max2.y);
				val2.z = ((val2.z > max2.z) ? val2.z : max2.z);
			}
		}
		if (!flag)
		{
			return;
		}
		Vector3 val3 = val2 - val;
		Vector3 position = val + val3 * 0.5f;
		float radius = Mathf.Max(Mathf.Max(val3.x, val3.y), val3.z) * 0.5f;
		OcclusionCulling.Sphere sphere = new OcclusionCulling.Sphere(position, radius);
		if (localOccludee.IsRegistered)
		{
			OcclusionCulling.UpdateDynamicOccludee(localOccludee.id, sphere.position, sphere.radius);
			localOccludee.sphere = sphere;
			return;
		}
		bool visible = true;
		if ((Object)(object)lodGroup != (Object)null)
		{
			visible = lodGroup.enabled;
		}
		RegisterForCulling(sphere, visible);
	}

	protected virtual bool CheckVisibility()
	{
		if (localOccludee.state != null)
		{
			return localOccludee.state.isVisible;
		}
		return true;
	}

	private void ApplyVisibility(bool vis)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)lodGroup != (Object)null)
		{
			float num = ((!vis) ? 100000 : 0);
			if (num != lodGroup.localReferencePoint.x)
			{
				lodGroup.localReferencePoint = new Vector3(num, num, num);
			}
		}
	}

	protected virtual void OnVisibilityChanged(bool visible)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)MainCamera.mainCamera != (Object)null && localOccludee.IsRegistered)
		{
			float dist = Vector3.Distance(MainCamera.position, ((Component)this).transform.position);
			VisUpdateUsingCulling(dist, visible);
			ApplyVisibility(isVisible);
		}
	}

	private void UpdateVisibility(float delay)
	{
	}

	private void VisUpdateUsingCulling(float dist, bool visibility)
	{
	}

	public virtual void TriggerUpdateVisibilityBounds()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (((Behaviour)this).enabled)
		{
			Vector3 val = ((Component)this).transform.position - MainCamera.position;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			float num = 400f;
			float num2;
			if (sqrMagnitude < num)
			{
				num2 = 1f / Random.Range(5f, 25f);
			}
			else
			{
				float num3 = Mathf.Clamp01((Mathf.Sqrt(sqrMagnitude) - 20f) * 0.001f);
				float num4 = Mathf.Lerp(1f / 15f, 2f, num3);
				num2 = Random.Range(num4, num4 + 1f / 15f);
			}
			UpdateVisibility(num2);
			ApplyVisibility(isVisible);
			if (TriggerUpdateVisibilityBoundsDelegate == null)
			{
				TriggerUpdateVisibilityBoundsDelegate = TriggerUpdateVisibilityBounds;
			}
			((FacepunchBehaviour)this).Invoke(TriggerUpdateVisibilityBoundsDelegate, num2);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public static class DamageUtil
{
	public static void RadiusDamage(BaseEntity attackingPlayer, BaseEntity weaponPrefab, Vector3 pos, float minradius, float radius, List<DamageTypeEntry> damage, int layers, bool useLineOfSight, bool ignoreAI = false, bool ignoreAttackingPlayer = false, bool extendedLineOfSight = false, List<DamageTypeEntry> playerDamage = null, bool removeWallpaper = false)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("DamageUtil.RadiusDamage", 0);
		try
		{
			List<HitInfo> list = Pool.Get<List<HitInfo>>();
			List<BaseEntity> list2 = Pool.Get<List<BaseEntity>>();
			List<BaseEntity> list3 = Pool.Get<List<BaseEntity>>();
			Vis.Entities(pos, radius, list3, layers, (QueryTriggerInteraction)2);
			for (int i = 0; i < list3.Count; i++)
			{
				BaseEntity baseEntity = list3[i];
				if (!baseEntity.isServer || list2.Contains(baseEntity) || (ignoreAI && IsIgnoredAI(baseEntity)))
				{
					continue;
				}
				Vector3 val2 = baseEntity.ClosestPoint(pos);
				float num = Mathf.Clamp01((Vector3.Distance(val2, pos) - minradius) / (radius - minradius));
				if (num > 1f)
				{
					continue;
				}
				float amount = 1f - num;
				if (removeWallpaper && baseEntity is BuildingBlock buildingBlock)
				{
					buildingBlock.RemoveWallpaper(0);
					buildingBlock.RemoveWallpaper(1);
				}
				if ((!extendedLineOfSight || GamePhysics.LineOfSight(baseEntity.CenterPoint(), pos, 1218519041, baseEntity)) && (!useLineOfSight || baseEntity.IsVisible(pos)))
				{
					HitInfo hitInfo = new HitInfo();
					hitInfo.Initiator = attackingPlayer;
					hitInfo.WeaponPrefab = weaponPrefab;
					if (playerDamage != null && playerDamage.Count > 0 && baseEntity is BasePlayer)
					{
						hitInfo.damageTypes.Add(playerDamage);
					}
					else
					{
						hitInfo.damageTypes.Add(damage);
					}
					hitInfo.damageTypes.ScaleAll(amount);
					hitInfo.HitPositionWorld = val2;
					Vector3 val3 = pos - val2;
					hitInfo.HitNormalWorld = ((Vector3)(ref val3)).normalized;
					hitInfo.PointStart = pos;
					hitInfo.PointEnd = hitInfo.HitPositionWorld;
					list.Add(hitInfo);
					list2.Add(baseEntity);
				}
			}
			for (int j = 0; j < list2.Count; j++)
			{
				BaseEntity baseEntity2 = list2[j];
				HitInfo info = list[j];
				if (!ignoreAttackingPlayer || !((Object)(object)attackingPlayer != (Object)null) || !baseEntity2.EqualNetID((BaseNetworkable)attackingPlayer))
				{
					baseEntity2.OnAttacked(info);
				}
			}
			Pool.FreeUnmanaged<HitInfo>(ref list);
			Pool.FreeUnmanaged<BaseEntity>(ref list2);
			Pool.FreeUnmanaged<BaseEntity>(ref list3);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static bool IsIgnoredAI(BaseEntity ent)
	{
		return ent is ScientistNPC;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class CinematicEntity : BaseEntity
{
	[Serializable]
	public struct DisableGroup
	{
		public GameObject[] gameObjects;
	}

	private const Flags HideMesh = Flags.Reserved1;

	private const Flags HideMesh2 = Flags.Reserved2;

	private const Flags HideMesh3 = Flags.Reserved3;

	private const Flags HideMesh4 = Flags.Reserved4;

	public List<DisableGroup> DisableObjects;

	private static List<CinematicEntity> serverList = new List<CinematicEntity>();

	public override void ServerInit()
	{
		base.ServerInit();
		if (!serverList.Contains(this))
		{
			serverList.Add(this);
		}
	}

	[ServerVar(Help = "Hides cinematic entities by group (0= none, 1= lights, 2= BGs, 3= props, 4= misc)")]
	public static void HideObjects(Arg args)
	{
		HideObjectShared(args, serverList);
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer && serverList.Contains(this))
		{
			serverList.Remove(this);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool state = !HasFlag(Flags.Reserved1) && !HasFlag(Flags.Reserved2) && !HasFlag(Flags.Reserved3) && !HasFlag(Flags.Reserved4);
		ToggleObjects(state);
	}

	private void ToggleObjects(bool state)
	{
		for (int i = 0; i < DisableObjects.Count; i++)
		{
			DisableGroup disableGroup = DisableObjects[i];
			bool active = state;
			if (!state)
			{
				int f = 1 << 7 + i;
				active = !HasFlag((Flags)f);
			}
			GameObject[] gameObjects = disableGroup.gameObjects;
			for (int j = 0; j < gameObjects.Length; j++)
			{
				gameObjects[j].SetActive(active);
			}
		}
	}

	public static void HideObjectShared(Arg args, List<CinematicEntity> entList)
	{
		if (args.GetString(0, "") == "")
		{
			return;
		}
		List<int> list = new List<int>();
		if (args.GetInt(0, 0) != 0)
		{
			for (int i = 0; i < 4 && !(args.GetString(i, "") == ""); i++)
			{
				int @int = args.GetInt(i, 0);
				if (@int == 0)
				{
					break;
				}
				list.Add(@int - 1);
			}
		}
		foreach (CinematicEntity ent in entList)
		{
			for (int j = 0; j < 4; j++)
			{
				int f = 1 << 7 + j;
				ent.SetFlag((Flags)f, list.Contains(j));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct DisableGroup
{
	public GameObject[] gameObjects;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch.Rust;
using Network;
using UnityEngine;
using UnityEngine.SceneManagement;

[Factory("global")]
public class DiagnosticsConSys : ConsoleSystem
{
	private static void DumpAnimators(string targetFolder)
	{
		Animator[] array = Object.FindObjectsOfType<Animator>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All animators");
		stringBuilder.AppendLine();
		Animator[] array2 = array;
		foreach (Animator val in array2)
		{
			stringBuilder.AppendFormat("{1}\t{0}", ((Component)val).transform.GetRecursiveName(), ((Behaviour)val).enabled);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Animators.List.txt", stringBuilder.ToString());
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("All animators - grouped by object name");
		stringBuilder2.AppendLine();
		foreach (IGrouping<string, Animator> item in from x in array
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder2.AppendFormat("{1:N0}\t{0}", ((Component)item.First()).transform.GetRecursiveName(), item.Count());
			stringBuilder2.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Animators.Counts.txt", stringBuilder2.ToString());
		StringBuilder stringBuilder3 = new StringBuilder();
		stringBuilder3.AppendLine("All animators - grouped by enabled/disabled");
		stringBuilder3.AppendLine();
		foreach (IGrouping<string, Animator> item2 in from x in array
			group x by ((Component)x).transform.GetRecursiveName(((Behaviour)x).enabled ? "" : " (DISABLED)") into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder3.AppendFormat("{1:N0}\t{0}", ((Component)item2.First()).transform.GetRecursiveName(((Behaviour)item2.First()).enabled ? "" : " (DISABLED)"), item2.Count());
			stringBuilder3.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Animators.Counts.Enabled.txt", stringBuilder3.ToString());
	}

	[ServerVar]
	[ClientVar]
	public static void dump(Arg args)
	{
		if (Directory.Exists("diagnostics"))
		{
			Directory.CreateDirectory("diagnostics");
		}
		int num = 1;
		while (Directory.Exists("diagnostics/" + num))
		{
			num++;
		}
		Directory.CreateDirectory("diagnostics/" + num);
		string targetFolder = "diagnostics/" + num + "/";
		DumpLODGroups(targetFolder);
		DumpSystemInformation(targetFolder);
		for (int i = 0; i < SceneManager.sceneCount; i++)
		{
			DumpSceneGameObjects(targetFolder, i);
		}
		DumpAllGameObjects(targetFolder);
		DumpObjects(targetFolder);
		DumpEntities(targetFolder);
		DumpNetwork(targetFolder);
		DumpPhysics(targetFolder);
		DumpAnimators(targetFolder);
		DumpWarmup(targetFolder);
	}

	private static void DumpSystemInformation(string targetFolder)
	{
		WriteTextToFile(targetFolder + "System.Info.txt", SystemInfoGeneralText.currentInfo);
	}

	private static void WriteTextToFile(string file, string text)
	{
		File.WriteAllText(file, text);
	}

	private static void DumpEntities(string targetFolder)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All entities");
		stringBuilder.AppendLine();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				stringBuilder.AppendFormat("{1}\t{0}", current.PrefabName, ((NetworkableId)(((??)current.net?.ID) ?? default(NetworkableId))).Value);
				stringBuilder.AppendLine();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Entity.SV.List.txt", stringBuilder.ToString());
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("All entities");
		stringBuilder2.AppendLine();
		foreach (IGrouping<uint, BaseNetworkable> item in from x in BaseNetworkable.serverEntities
			group x by x.prefabID into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder2.AppendFormat("{1:N0}\t{0}", item.First().PrefabName, item.Count());
			stringBuilder2.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Entity.SV.Counts.txt", stringBuilder2.ToString());
		StringBuilder stringBuilder3 = new StringBuilder();
		stringBuilder3.AppendLine("Saved entities");
		stringBuilder3.AppendLine();
		foreach (IGrouping<uint, BaseEntity> item2 in from x in BaseEntity.saveList
			group x by x.prefabID into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder3.AppendFormat("{1:N0}\t{0}", item2.First().PrefabName, item2.Count());
			stringBuilder3.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Entity.SV.Savelist.Counts.txt", stringBuilder3.ToString());
	}

	private static void DumpLODGroups(string targetFolder)
	{
		DumpLODGroupTotals(targetFolder);
	}

	private static void DumpLODGroupTotals(string targetFolder)
	{
		LODGroup[] source = Object.FindObjectsOfType<LODGroup>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("LODGroups");
		stringBuilder.AppendLine();
		foreach (IGrouping<string, LODGroup> item in from x in source
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", item.Key, item.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "LODGroups.Objects.txt", stringBuilder.ToString());
	}

	private static void DumpNetwork(string targetFolder)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (!((BaseNetwork)Net.sv).IsConnected())
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Server Network Statistics");
		stringBuilder.AppendLine();
		stringBuilder.Append(((BaseNetwork)Net.sv).GetDebug((Connection)null).Replace("\n", "\r\n"));
		stringBuilder.AppendLine();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				stringBuilder.AppendLine("Name: " + current.displayName);
				stringBuilder.AppendLine("SteamID: " + current.userID.Get());
				stringBuilder.Append((current.net == null) ? "INVALID - NET IS NULL" : ((BaseNetwork)Net.sv).GetDebug(current.net.connection).Replace("\n", "\r\n"));
				stringBuilder.AppendLine();
				stringBuilder.AppendLine();
				stringBuilder.AppendLine();
				stringBuilder.AppendLine();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		WriteTextToFile(targetFolder + "Network.Server.txt", stringBuilder.ToString());
	}

	private static void DumpObjects(string targetFolder)
	{
		Object[] array = Object.FindObjectsOfType<Object>();
		Object[] array2 = Object.FindObjectsOfType<Object>(true);
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All active UnityEngine.Object, ordered by count");
		stringBuilder.AppendLine($"Total: {array.Length}");
		stringBuilder.AppendLine();
		foreach (IGrouping<Type, Object> item in from x in array
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((object)item.First()).GetType().Name, item.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object.Count.txt", stringBuilder.ToString());
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("All active + inactive UnityEngine.Object, ordered by count");
		stringBuilder2.AppendLine($"Total: {array2.Length}");
		stringBuilder2.AppendLine();
		foreach (IGrouping<Type, Object> item2 in from x in array2
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder2.AppendFormat("{1:N0}\t{0}", ((object)item2.First()).GetType().Name, item2.Count());
			stringBuilder2.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object_All.Count.txt", stringBuilder2.ToString());
		StringBuilder stringBuilder3 = new StringBuilder();
		stringBuilder3.AppendLine("All active + inactive UnityEngine.Object, ordered by count");
		stringBuilder3.AppendLine($"Total: {array.Length}");
		stringBuilder3.AppendLine();
		foreach (IGrouping<Type, Object> item3 in from x in array
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder3.AppendFormat("{1:N0}\t{0}", ((object)item3.First()).GetType().Name, item3.Count());
			stringBuilder3.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object.Count.txt", stringBuilder3.ToString());
		StringBuilder stringBuilder4 = new StringBuilder();
		stringBuilder4.AppendLine("All active UnityEngine.ScriptableObject, ordered by count");
		stringBuilder4.AppendLine();
		foreach (IGrouping<Type, Object> item4 in from x in array
			where x is ScriptableObject
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder4.AppendFormat("{1:N0}\t{0}", ((object)item4.First()).GetType().Name, item4.Count());
			stringBuilder4.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.ScriptableObject.Count.txt", stringBuilder4.ToString());
	}

	private static void DumpPhysics(string targetFolder)
	{
		DumpTotals(targetFolder);
		DumpColliders(targetFolder);
		DumpRigidBodies(targetFolder);
	}

	private static void DumpTotals(string targetFolder)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Physics Information");
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Total Colliders:\t{0:N0}", Object.FindObjectsOfType<Collider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Active Colliders:\t{0:N0}", (from x in Object.FindObjectsOfType<Collider>()
			where x.enabled
			select x).Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Total RigidBodys:\t{0:N0}", Object.FindObjectsOfType<Rigidbody>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Mesh Colliders:\t{0:N0}", Object.FindObjectsOfType<MeshCollider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Box Colliders:\t{0:N0}", Object.FindObjectsOfType<BoxCollider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Sphere Colliders:\t{0:N0}", Object.FindObjectsOfType<SphereCollider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Capsule Colliders:\t{0:N0}", Object.FindObjectsOfType<CapsuleCollider>().Count());
		stringBuilder.AppendLine();
		WriteTextToFile(targetFolder + "Physics.txt", stringBuilder.ToString());
	}

	private static void DumpColliders(string targetFolder)
	{
		Collider[] source = Object.FindObjectsOfType<Collider>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Physics Colliders");
		stringBuilder.AppendLine();
		foreach (IGrouping<string, Collider> item in from x in source
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0} ({2:N0} triggers) ({3:N0} enabled)", item.Key, item.Count(), item.Count((Collider x) => x.isTrigger), item.Count((Collider x) => x.enabled));
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "Physics.Colliders.Objects.txt", stringBuilder.ToString());
	}

	private static void DumpRigidBodies(string targetFolder)
	{
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody[] source = Object.FindObjectsOfType<Rigidbody>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("RigidBody");
		stringBuilder.AppendLine();
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("RigidBody");
		stringBuilder2.AppendLine();
		foreach (IGrouping<string, Rigidbody> item in from x in source
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0} ({2:N0} awake) ({3:N0} kinematic) ({4:N0} non-discrete)", item.Key, item.Count(), item.Count((Rigidbody x) => !x.IsSleeping()), item.Count((Rigidbody x) => x.isKinematic), item.Count((Rigidbody x) => (int)x.collisionDetectionMode > 0));
			stringBuilder.AppendLine();
			foreach (Rigidbody item2 in item)
			{
				stringBuilder2.AppendFormat("{0} -{1}{2}{3}", item.Key, item2.isKinematic ? " KIN" : "", item2.IsSleeping() ? " SLEEP" : "", item2.useGravity ? " GRAVITY" : "");
				stringBuilder2.AppendLine();
				stringBuilder2.AppendFormat("Mass: {0}\tVelocity: {1}\tsleepThreshold: {2}", item2.mass, item2.velocity, item2.sleepThreshold);
				stringBuilder2.AppendLine();
				stringBuilder2.AppendLine();
			}
		}
		WriteTextToFile(targetFolder + "Physics.RigidBody.Objects.txt", stringBuilder.ToString());
		WriteTextToFile(targetFolder + "Physics.RigidBody.All.txt", stringBuilder2.ToString());
	}

	private static string GetOutputDirectoryForScene(string targetFolder, int sceneIndex, Scene scene)
	{
		string arg = ((Scene)(ref scene)).name.Replace("\\", "_").Replace("/", "_").Replace(" ", "_");
		targetFolder = Path.Combine(targetFolder, "Scenes", $"{sceneIndex}_{arg}/");
		Directory.CreateDirectory(targetFolder);
		return targetFolder;
	}

	private static void DumpSceneGameObjects(string targetFolder, int sceneIndex)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Scene sceneAt = SceneManager.GetSceneAt(sceneIndex);
		Transform[] rootObjects = (from x in ((Scene)(ref sceneAt)).GetRootGameObjects()
			select x.transform).ToArray();
		targetFolder = GetOutputDirectoryForScene(targetFolder, sceneIndex, sceneAt);
		DumpGameObjects(targetFolder, rootObjects);
	}

	private static void DumpAllGameObjects(string targetFolder)
	{
		Transform[] rootObjects = TransformUtil.GetRootObjects();
		DumpGameObjects(targetFolder, rootObjects);
	}

	private static void DumpGameObjects(string targetFolder, Transform[] rootObjects)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All active game objects");
		stringBuilder.AppendLine();
		Transform[] array = rootObjects;
		foreach (Transform tx in array)
		{
			DumpGameObjectRecursive(stringBuilder, tx, 0);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Hierarchy.txt", stringBuilder.ToString());
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All active game objects including components");
		stringBuilder.AppendLine();
		array = rootObjects;
		foreach (Transform tx2 in array)
		{
			DumpGameObjectRecursive(stringBuilder, tx2, 0, includeComponents: true);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Hierarchy.Components.txt", stringBuilder.ToString());
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Root gameobjects, grouped by name, ordered by the total number of objects excluding children");
		stringBuilder.AppendLine();
		foreach (IGrouping<string, Transform> item in from x in rootObjects
			group x by ((Object)x).name into x
			orderby x.Count() descending
			select x)
		{
			Transform val = item.First();
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((Object)val).name, item.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Count.txt", stringBuilder.ToString());
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Root gameobjects, grouped by name, ordered by the total number of objects including children");
		stringBuilder.AppendLine();
		foreach (KeyValuePair<Transform, int> item2 in from x in rootObjects
			group x by ((Object)x).name into x
			select new KeyValuePair<Transform, int>(x.First(), x.Sum((Transform y) => y.GetAllChildren().Count)) into x
			orderby x.Value descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((Object)item2.Key).name, item2.Value);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Count.Children.txt", stringBuilder.ToString());
		Component[] source = (from x in rootObjects.SelectMany((Transform x) => ((Component)x).GetComponentsInChildren<Component>(true))
			where (Object)(object)x != (Object)null
			select x).ToArray();
		Object[] array2 = source.Select((Component x) => x.gameObject).Distinct().ToArray()
			.OfType<Object>()
			.Concat(source.OfType<Object>())
			.ToArray();
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All UnityEngine.Object active + inactive, ordered by count");
		stringBuilder.AppendLine($"Total: {array2.Length}");
		foreach (IGrouping<Type, Object> item3 in from x in array2
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((object)item3.First()).GetType().Name, item3.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object.Count.txt", stringBuilder.ToString());
	}

	private static void DumpGameObjectRecursive(StringBuilder str, Transform tx, int indent, bool includeComponents = false)
	{
		if ((Object)(object)tx == (Object)null)
		{
			return;
		}
		str.Append(' ', indent);
		str.Append(((Component)tx).gameObject.activeSelf ? "+ " : "- ");
		str.Append(((Object)tx).name);
		str.Append(" [").Append(((Component)tx).GetComponents<Component>().Length - 1).Append(']');
		str.AppendLine();
		if (includeComponents)
		{
			Component[] components = ((Component)tx).GetComponents<Component>();
			foreach (Component val in components)
			{
				if (!(val is Transform))
				{
					str.Append(' ', indent + 3);
					bool? flag = val.IsEnabled();
					if (!flag.HasValue)
					{
						str.Append("[~] ");
					}
					else if (flag == true)
					{
						str.Append("[] ");
					}
					else
					{
						str.Append("[ ] ");
					}
					str.Append(((Object)(object)val == (Object)null) ? "NULL" : ((object)val).GetType().ToString());
					str.AppendLine();
				}
			}
		}
		for (int j = 0; j < tx.childCount; j++)
		{
			DumpGameObjectRecursive(str, tx.GetChild(j), indent + 4, includeComponents);
		}
	}

	private static void DumpWarmup(string targetFolder)
	{
		DumpWarmupTimings(targetFolder);
		DumpWorldSpawnTimings(targetFolder);
	}

	private static void DumpWarmupTimings(string targetFolder)
	{
		if (!FileSystem_Warmup.GetWarmupTimes().Any())
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("index,prefab,time");
		int num = 0;
		foreach (var warmupTime in FileSystem_Warmup.GetWarmupTimes())
		{
			object arg = num;
			var (arg2, timeSpan) = warmupTime;
			stringBuilder.AppendLine($"{arg},{arg2},{timeSpan.Ticks * EventRecord.TicksToNS}");
			num++;
		}
		WriteTextToFile(targetFolder + "Asset.Warmup.csv", stringBuilder.ToString());
	}

	private static void DumpWorldSpawnTimings(string targetFolder)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (!World.GetSpawnTimings().Any())
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("index,prefab,time,category,position,rotation");
		int num = 0;
		foreach (World.SpawnTiming spawnTiming in World.GetSpawnTimings())
		{
			object[] obj = new object[6]
			{
				num,
				spawnTiming.prefab.Name,
				null,
				null,
				null,
				null
			};
			TimeSpan time = spawnTiming.time;
			obj[2] = time.Ticks * EventRecord.TicksToNS;
			obj[3] = spawnTiming.category;
			obj[4] = spawnTiming.position;
			obj[5] = spawnTiming.rotation;
			stringBuilder.AppendLine(string.Format("{0},{1},{2},{3},{4},{5}", obj));
			num++;
		}
		WriteTextToFile(targetFolder + "World.Spawn.csv", stringBuilder.ToString());
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;

public class DirectionalDamageTrigger : TriggerBase
{
	public float repeatRate = 1f;

	public List<DamageTypeEntry> damageType;

	public GameObjectRef attackEffect;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (!(baseEntity is BaseCombatEntity))
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)OnTick, repeatRate, repeatRate);
	}

	public override void OnEmpty()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
	}

	private void OnTick()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		if (attackEffect.isValid)
		{
			Effect.server.Run(attackEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		}
		if (entityContents == null)
		{
			return;
		}
		BaseEntity[] array = entityContents.ToArray();
		foreach (BaseEntity baseEntity in array)
		{
			if (baseEntity.IsValid())
			{
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				if (!((Object)(object)baseCombatEntity == (Object)null))
				{
					HitInfo hitInfo = new HitInfo();
					hitInfo.damageTypes.Add(damageType);
					hitInfo.DoHitEffects = true;
					hitInfo.DidHit = true;
					hitInfo.PointStart = ((Component)this).transform.position;
					hitInfo.PointEnd = ((Component)baseCombatEntity).transform.position;
					baseCombatEntity.Hurt(hitInfo);
				}
			}
		}
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[ExecuteInEditMode]
public class DofExposer : ListComponent<DofExposer>
{
	public PostProcessVolume PostVolume;

	public bool DofEnabled;

	public float FocalLength = 15.24f;

	public float Blur = 2f;

	public float FocalAperture = 13.16f;

	public float AnamorphicSqueeze;

	public float AnamorphicBarrel;

	public bool debug;
}


using UnityEngine;

public class DrawArrow : MonoBehaviour
{
	public Color color = new Color(1f, 1f, 1f, 1f);

	public float length = 0.2f;

	public float arrowLength = 0.02f;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 up = ((Component)Camera.current).transform.up;
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = ((Component)this).transform.position + forward * length;
		Gizmos.color = color;
		Gizmos.DrawLine(position, val);
		Gizmos.DrawLine(val, val + up * arrowLength - forward * arrowLength);
		Gizmos.DrawLine(val, val - up * arrowLength - forward * arrowLength);
		Gizmos.DrawLine(val + up * arrowLength - forward * arrowLength, val - up * arrowLength - forward * arrowLength);
	}
}


using UnityEngine;

public class DrawSkeleton : MonoBehaviour
{
	private void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.white;
		DrawTransform(((Component)this).transform);
	}

	private static void DrawTransform(Transform t)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < t.childCount; i++)
		{
			Gizmos.DrawLine(t.position, t.GetChild(i).position);
			DrawTransform(t.GetChild(i));
		}
	}
}


using System;
using System.Collections.Generic;
using Rust.UI.MainMenu;
using UnityEngine;

public class FakeSteamItemStub : IPlayerItemDefinition, IEquatable<IPlayerItemDefinition>
{
	private readonly SteamInventoryItem _steamItemSource;

	private readonly IPlayerItemDefinition _itemSource;

	public readonly ItemStoreTakeover TakeoverSource;

	private string tags;

	public IPlayerItemDefinition Source => _itemSource;

	public int DefinitionId => _steamItemSource.id;

	public string Name
	{
		get
		{
			if (!TakeoverSource.IsValid())
			{
				return _steamItemSource.displayName.translated;
			}
			return TakeoverSource.NameOverride.english;
		}
	}

	public string Description => string.Empty;

	public string Type
	{
		get
		{
			IPlayerItemDefinition itemSource = _itemSource;
			if (itemSource == null)
			{
				return null;
			}
			return itemSource.Type;
		}
	}

	public string IconUrl => string.Empty;

	public int LocalPrice => 0;

	public string LocalPriceFormatted
	{
		get
		{
			IPlayerItemDefinition itemSource = _itemSource;
			if (itemSource == null)
			{
				return null;
			}
			return itemSource.LocalPriceFormatted;
		}
	}

	public string PriceCategory
	{
		get
		{
			IPlayerItemDefinition itemSource = _itemSource;
			if (itemSource == null)
			{
				return null;
			}
			return itemSource.PriceCategory;
		}
	}

	public bool IsGenerator => false;

	public bool IsTradable => false;

	public bool IsMarketable => false;

	public string StoreTags => tags;

	public DateTime Created { get; }

	public DateTime Modified { get; }

	public string ItemShortName => _steamItemSource.itemname;

	public ulong WorkshopId
	{
		get
		{
			if (!(_steamItemSource is ItemSkin itemSkin))
			{
				return 0uL;
			}
			return itemSkin.workshopID;
		}
	}

	public ulong WorkshopDownload { get; }

	public FakeSteamItemStub(ItemStoreTakeover backing, IPlayerItemDefinition itemDef)
	{
		if ((Object)(object)backing.Item != (Object)null)
		{
			TakeoverSource = backing;
			_steamItemSource = backing.Item;
			_itemSource = itemDef;
		}
	}

	public FakeSteamItemStub(SteamInventoryItem steamInventoryItemSource, string tags = null)
	{
		_steamItemSource = steamInventoryItemSource;
		this.tags = tags;
	}

	public FakeSteamItemStub(SteamDLCItem dlcItemBacking)
	{
		SteamInventoryItem steamInventoryItem = ScriptableObject.CreateInstance<SteamInventoryItem>();
		steamInventoryItem.id = dlcItemBacking.dlcAppID;
		steamInventoryItem.displayName = dlcItemBacking.dlcName;
		tags = "DLC";
		_steamItemSource = steamInventoryItem;
	}

	public bool Equals(IPlayerItemDefinition other)
	{
		return other.DefinitionId == DefinitionId;
	}

	public IEnumerable<PlayerItemRecipe> GetRecipesContainingThis()
	{
		return null;
	}
}


using System;
using System.Threading;
using UnityEngine;

public class InvokeSpammer : MonoBehaviour
{
	public int InvokeMilliseconds = 1;

	public float RepeatTime = 0.6f;

	private void Start()
	{
		((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).InvokeRepeating((Action)TestInvoke, RepeatTime, RepeatTime);
	}

	private void TestInvoke()
	{
		Thread.Sleep(InvokeMilliseconds);
	}
}


using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class ItemButtonTools : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler, IScrollHandler
{
	public ScrollRect MainScroll;

	public Image image;

	public Image backgroundImage;

	public ItemDefinition itemDef;

	public void GiveSelf(int amount)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		DebugLog();
		ConsoleSystem.Run(Option.Client, "inventory.giveid", new object[2] { itemDef.itemid, amount });
	}

	public void GiveArmed()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		DebugLog();
		ConsoleSystem.Run(Option.Client, "inventory.givearm", new object[1] { itemDef.itemid });
	}

	public void GiveStack()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		DebugLog();
		ConsoleSystem.Run(Option.Client, "inventory.giveid", new object[2] { itemDef.itemid, itemDef.stackable });
	}

	public void GiveBlueprint()
	{
	}

	private void DebugLog()
	{
		if (Input.GetKey((KeyCode)308))
		{
			Debug.Log((object)((Object)((Component)itemDef).gameObject).name, (Object)(object)((Component)itemDef).gameObject);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		MainScroll.OnBeginDrag(eventData);
	}

	public void OnDrag(PointerEventData eventData)
	{
		MainScroll.OnDrag(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		MainScroll.OnEndDrag(eventData);
	}

	public void OnScroll(PointerEventData data)
	{
		MainScroll.OnScroll(data);
	}
}


using System.Linq;
using Facepunch.Extend;
using Rust;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ItemListTools : MonoBehaviour
{
	public GameObject categoryButton;

	public GameObject itemButtonPrefab;

	public Transform itemButtonParent;

	public RustInput searchInputText;

	internal Button lastCategory;

	public ScrollRect MainScrollRect;

	private IOrderedEnumerable<ItemDefinition> currentItems;

	private IOrderedEnumerable<ItemDefinition> allItems;

	public void OnPanelOpened()
	{
		CacheAllItems();
		Refresh();
		searchInputText.InputField.ActivateInputField();
	}

	private void OnOpenDevTools()
	{
		searchInputText.InputField.ActivateInputField();
	}

	private void CacheAllItems()
	{
		if (allItems == null)
		{
			allItems = from x in ItemManager.GetItemDefinitions()
				orderby x.displayName.translated
				select x;
		}
	}

	public void Refresh()
	{
		RebuildCategories();
	}

	private void RebuildCategories()
	{
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Expected O, but got Unknown
		for (int i = 0; i < categoryButton.transform.parent.childCount; i++)
		{
			Transform child = categoryButton.transform.parent.GetChild(i);
			if (!((Object)(object)child == (Object)(object)categoryButton.transform))
			{
				GameManager.Destroy(((Component)child).gameObject);
			}
		}
		categoryButton.SetActive(true);
		foreach (IGrouping<ItemCategory, ItemDefinition> item in from x in ItemManager.GetItemDefinitions()
			group x by x.category into x
			orderby x.First().category
			select x)
		{
			GameObject val = Object.Instantiate<GameObject>(categoryButton);
			val.transform.SetParent(categoryButton.transform.parent, false);
			((TMP_Text)val.GetComponentInChildren<TextMeshProUGUI>()).text = item.First().category.ToString();
			Button btn = val.GetComponentInChildren<Button>();
			ItemDefinition[] itemArray = item.ToArray();
			((UnityEvent)btn.onClick).AddListener((UnityAction)delegate
			{
				if (Object.op_Implicit((Object)(object)lastCategory))
				{
					((Selectable)lastCategory).interactable = true;
				}
				lastCategory = btn;
				((Selectable)lastCategory).interactable = false;
				SwitchItemCategory(itemArray);
			});
			if ((Object)(object)lastCategory == (Object)null)
			{
				lastCategory = btn;
				((Selectable)lastCategory).interactable = false;
				SwitchItemCategory(itemArray);
			}
		}
		categoryButton.SetActive(false);
	}

	private void SwitchItemCategory(ItemDefinition[] defs)
	{
		currentItems = defs.OrderBy((ItemDefinition x) => x.displayName.translated);
		searchInputText.Text = "";
		FilterItems(null);
		MainScrollRect.verticalNormalizedPosition = 1f;
	}

	public void FilterItems(string searchText)
	{
		if ((Object)(object)itemButtonPrefab == (Object)null)
		{
			return;
		}
		TransformEx.DestroyAllChildren(itemButtonParent, false);
		bool flag = !string.IsNullOrEmpty(searchText);
		string search = (flag ? searchText.ToLower() : null);
		IOrderedEnumerable<ItemDefinition> obj = (flag ? allItems : currentItems);
		int num = 0;
		foreach (ItemDefinition item in obj)
		{
			if (!item.Hidden() && (!flag || ItemSearchUtils.IsValidSearchResult(search, item, checkItemIsValid: false)))
			{
				GameObject obj2 = Object.Instantiate<GameObject>(itemButtonPrefab, itemButtonParent);
				((TMP_Text)obj2.GetComponentInChildren<TextMeshProUGUI>()).text = item.displayName.translated;
				obj2.GetComponentInChildren<ItemButtonTools>().itemDef = item;
				obj2.GetComponentInChildren<ItemButtonTools>().MainScroll = MainScrollRect;
				obj2.GetComponentInChildren<ItemButtonTools>().image.sprite = item.iconSprite;
				((Behaviour)obj2.GetComponentInChildren<ItemButtonTools>().backgroundImage).enabled = (Object)(object)item != (Object)null && !item.IsAllowed((EraRestriction)0);
				num++;
				if (num >= 160)
				{
					break;
				}
			}
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class MeshTrimTester : MonoBehaviour
{
	public MeshTrimSettings Settings = MeshTrimSettings.Default;

	public Mesh SourceMesh;

	public MeshFilter TargetMeshFilter;

	public int SubtractIndex;
}


using UnityEngine;

public class MoveObjectOverTime : MonoBehaviour
{
	public Transform Mover;

	public Vector3 OffsetAmount;

	public float Speed = 1f;
}


using Network;
using TMPro;
using UnityEngine;

public class NetworkInfoGeneralText : MonoBehaviour
{
	public TextMeshProUGUI text;

	private void Update()
	{
		UpdateText();
	}

	private void UpdateText()
	{
		string text = "";
		if (Net.sv != null)
		{
			text += "Server\n";
			text += ((BaseNetwork)Net.sv).GetDebug((Connection)null);
			text += "\n";
		}
		((TMP_Text)this.text).text = text;
	}

	private static string ChannelStat(int window, int left)
	{
		return $"{left}/{window}";
	}
}


using UnityEngine;

public class ObjectSpam : MonoBehaviour
{
	public GameObject source;

	public int amount = 1000;

	public float radius;

	private void Start()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < amount; i++)
		{
			GameObject obj = Object.Instantiate<GameObject>(source);
			obj.transform.position = ((Component)this).transform.position + Vector3Ex.Range(0f - radius, radius);
			((Object)obj).hideFlags = (HideFlags)3;
		}
	}
}


using UnityEngine;

public class PingPongRotate : MonoBehaviour
{
	public Vector3 rotationSpeed = Vector3.zero;

	public Vector3 offset = Vector3.zero;

	public Vector3 rotationAmount = Vector3.zero;

	private void Update()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.identity;
		for (int i = 0; i < 3; i++)
		{
			val *= GetRotation(i);
		}
		((Component)this).transform.rotation = val;
	}

	public Quaternion GetRotation(int index)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		switch (index)
		{
		case 0:
			val = Vector3.right;
			break;
		case 1:
			val = Vector3.up;
			break;
		case 2:
			val = Vector3.forward;
			break;
		}
		return Quaternion.AngleAxis(Mathf.Sin((((Vector3)(ref offset))[index] + Time.time) * ((Vector3)(ref rotationSpeed))[index]) * ((Vector3)(ref rotationAmount))[index], val);
	}
}


using UnityEngine;

public class RotateObject : MonoBehaviour
{
	public float rotateSpeed_X = 1f;

	public float rotateSpeed_Y = 1f;

	public float rotateSpeed_Z = 1f;

	public bool localSpace;

	public bool randomizeRotation;

	public Vector3 randomVariationRange = new Vector3(0.5f, 0.5f, 0.5f);

	private void Start()
	{
		if (randomizeRotation)
		{
			rotateSpeed_Y = Random.Range(0f - Mathf.Abs(rotateSpeed_X), Mathf.Abs(rotateSpeed_X));
			rotateSpeed_Z = Random.Range(0f - Mathf.Abs(rotateSpeed_X), Mathf.Abs(rotateSpeed_X));
		}
		rotateSpeed_X *= 1f + Random.Range(0f - randomVariationRange.x, randomVariationRange.x);
		rotateSpeed_Y *= 1f + Random.Range(0f - randomVariationRange.y, randomVariationRange.y);
		rotateSpeed_Z *= 1f + Random.Range(0f - randomVariationRange.z, randomVariationRange.z);
	}

	protected void Update()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		if (localSpace)
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(rotateSpeed_X, rotateSpeed_Y, rotateSpeed_Z);
			((Component)this).transform.Rotate(val * Time.deltaTime, (Space)1);
			return;
		}
		if (rotateSpeed_X != 0f)
		{
			((Component)this).transform.Rotate(Vector3.up, Time.deltaTime * rotateSpeed_X);
		}
		if (rotateSpeed_Y != 0f)
		{
			((Component)this).transform.Rotate(((Component)this).transform.forward, Time.deltaTime * rotateSpeed_Y);
		}
		if (rotateSpeed_Z != 0f)
		{
			((Component)this).transform.Rotate(((Component)this).transform.right, Time.deltaTime * rotateSpeed_Z);
		}
	}
}


public static class SafeMode
{
}


using UnityEngine;
using UnityEngine.UI;

public class SeedPosInfo : MonoBehaviour
{
	public CanvasGroup Canvas;

	public Text WorldPos;

	public Text LevelName;

	public Text WorldSize;

	public Text Seed;
}


using System;
using ConVar;
using Facepunch;
using UnityEngine;

public class ServerConsole : SingletonComponent<ServerConsole>
{
	private static bool consoleEnabled => !CommandLine.HasSwitch("-noconsole");

	private DateTime currentGameTime
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)TOD_Sky.Instance))
			{
				return DateTime.Now;
			}
			return TOD_Sky.Instance.Cycle.DateTime;
		}
	}

	private int currentPlayerCount => BasePlayer.activePlayerList.Count;

	private int maxPlayerCount => Server.maxplayers;

	private int currentEntityCount => BaseNetworkable.serverEntities.Count;

	private int currentSleeperCount => BasePlayer.sleepingPlayerList.Count;

	public void OnEnable()
	{
	}

	private void OnDisable()
	{
		Output.OnMessage -= HandleLog;
	}

	private void OnInputText(string obj)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		ConsoleSystem.Run(Option.Server, obj, Array.Empty<object>());
	}

	public static void PrintColoured(params object[] objects)
	{
	}

	private void HandleLog(string message, string stackTrace, LogType type)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Invalid comparison between Unknown and I4
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Invalid comparison between Unknown and I4
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Invalid comparison between Unknown and I4
		if (message.StartsWith("[CHAT]") || message.StartsWith("[TEAM CHAT]") || message.StartsWith("[CARDS CHAT]"))
		{
			return;
		}
		if ((int)type == 2)
		{
			if (!message.StartsWith("HDR RenderTexture format is not") && !message.StartsWith("The image effect") && !message.StartsWith("Image Effects are not supported on this platform") && !message.StartsWith("[AmplifyColor]") && !message.StartsWith("Skipping profile frame.") && !message.StartsWith("Kinematic body only supports Speculative Continuous collision detection"))
			{
				System.Console.ForegroundColor = ConsoleColor.Yellow;
			}
		}
		else if ((int)type == 0)
		{
			System.Console.ForegroundColor = ConsoleColor.Red;
		}
		else if ((int)type == 4)
		{
			System.Console.ForegroundColor = ConsoleColor.Red;
		}
		else if ((int)type == 1)
		{
			System.Console.ForegroundColor = ConsoleColor.Red;
		}
		else
		{
			System.Console.ForegroundColor = ConsoleColor.Gray;
		}
	}
}


using System;
using System.Runtime.InteropServices;
using UnityEngine;

public static class SystemInfoEx
{
	private static bool[] supportedRenderTextureFormats;

	public static int systemMemoryUsed => (int)(System_GetMemoryUsage() / 1024 / 1024);

	[DllImport("RustNative")]
	private static extern ulong System_GetMemoryUsage();

	public static bool SupportsRenderTextureFormat(RenderTextureFormat format)
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if (supportedRenderTextureFormats == null)
		{
			Array values = Enum.GetValues(typeof(RenderTextureFormat));
			int num = (int)values.GetValue(values.Length - 1);
			supportedRenderTextureFormats = new bool[num + 1];
			for (int i = 0; i <= num; i++)
			{
				bool flag = Enum.IsDefined(typeof(RenderTextureFormat), i);
				supportedRenderTextureFormats[i] = flag && SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)i);
			}
		}
		return supportedRenderTextureFormats[format];
	}
}


using System.Text;
using ConVar;
using Rust;
using TMPro;
using UnityEngine;

public class SystemInfoGeneralText : MonoBehaviour
{
	public TextMeshProUGUI text;

	public static string currentInfo
	{
		get
		{
			BaseGameMode.GetActiveGameMode(serverside: false);
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("System");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tName: ");
			stringBuilder.Append(SystemInfo.deviceName);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tOS:   ");
			stringBuilder.Append(SystemInfo.operatingSystem);
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("CPU");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tModel:  ");
			stringBuilder.Append(SystemInfo.processorType);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tCores:  ");
			stringBuilder.Append(SystemInfo.processorCount);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory: ");
			stringBuilder.Append(SystemInfo.systemMemorySize);
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("GPU");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tModel:  ");
			stringBuilder.Append(SystemInfo.graphicsDeviceName);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tAPI:    ");
			stringBuilder.Append(SystemInfo.graphicsDeviceVersion);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory: ");
			stringBuilder.Append(SystemInfo.graphicsMemorySize);
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tSM:     ");
			stringBuilder.Append(SystemInfo.graphicsShaderLevel);
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("Process");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory:   ");
			stringBuilder.Append(SystemInfoEx.systemMemoryUsed);
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("Mono");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tCollects: ");
			stringBuilder.Append(Rust.GC.CollectionCount());
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory:   ");
			stringBuilder.Append(Rust.GC.GetTotalMemory());
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			if (World.Seed != 0 && World.Size != 0)
			{
				stringBuilder.Append("World");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tSeed:        ");
				if (!ConVar.Server.mapenabled || ConVar.Server.fogofwar)
				{
					stringBuilder.Append("?");
				}
				else
				{
					stringBuilder.Append(World.Seed);
				}
				stringBuilder.AppendLine();
				stringBuilder.Append("\tSize:        ");
				stringBuilder.Append(KM2(World.Size));
				stringBuilder.Append(" km");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tHeightmap:   ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) ? TerrainMeta.HeightMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tWatermap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) ? TerrainMeta.WaterMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tSplatmap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.SplatMap) ? TerrainMeta.SplatMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tBiomemap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tTopologymap: ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) ? TerrainMeta.TopologyMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tAlphamap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.AlphaMap) ? TerrainMeta.AlphaMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
			}
			stringBuilder.AppendLine();
			if (!string.IsNullOrEmpty(World.Checksum))
			{
				stringBuilder.AppendLine("Checksum");
				stringBuilder.Append('\t');
				stringBuilder.AppendLine(World.Checksum);
			}
			return stringBuilder.ToString();
		}
	}

	protected void Update()
	{
		((TMP_Text)text).text = currentInfo;
	}

	private static long MB(long bytes)
	{
		return bytes / 1048576;
	}

	private static long MB(ulong bytes)
	{
		return MB((long)bytes);
	}

	private static int KM2(float meters)
	{
		return Mathf.RoundToInt(meters * meters * 1E-06f);
	}
}


using UnityEngine;

public class TriangleIdentifier : MonoBehaviour
{
	public int TriangleID;

	public int SubmeshID;

	public float LineLength = 1.5f;

	private void OnDrawGizmosSelected()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		MeshFilter component = ((Component)this).GetComponent<MeshFilter>();
		if (!((Object)(object)component == (Object)null) && !((Object)(object)component.sharedMesh == (Object)null))
		{
			int[] triangles = component.sharedMesh.GetTriangles(SubmeshID);
			if (TriangleID >= 0 && TriangleID * 3 <= triangles.Length)
			{
				Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
				Vector3 val = component.sharedMesh.vertices[TriangleID * 3];
				Vector3 val2 = component.sharedMesh.vertices[TriangleID * 3 + 1];
				Vector3 val3 = component.sharedMesh.vertices[TriangleID * 3 + 2];
				Vector3 val4 = component.sharedMesh.normals[TriangleID * 3];
				Vector3 val5 = component.sharedMesh.normals[TriangleID * 3 + 1];
				Vector3 val6 = component.sharedMesh.normals[TriangleID * 3 + 2];
				Vector3 val7 = (val + val2 + val3) / 3f;
				Vector3 val8 = (val4 + val5 + val6) / 3f;
				Gizmos.DrawLine(val7, val7 + val8 * LineLength);
			}
		}
	}
}


[JsonModel]
public struct ClientPerformanceReport
{
	public int request_id;

	public string user_id;

	public float fps_average;

	public int fps;

	public int frame_id;

	public float frame_time;

	public float frame_time_average;

	public long memory_system;

	public long memory_collections;

	public long memory_managed_heap;

	public float realtime_since_startup;

	public bool streamer_mode;

	public int ping;

	public int tasks_invokes;

	public int tasks_load_balancer;

	public int workshop_skins_queued;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DevBotSpawner : FacepunchBehaviour
{
	public GameObjectRef bot;

	public Transform waypointParent;

	public bool autoSelectLatestSpawnedGameObject = true;

	public float spawnRate = 1f;

	public int maxPopulation = 1;

	private Transform[] waypoints;

	private List<BaseEntity> _spawned = new List<BaseEntity>();

	public bool HasFreePopulation()
	{
		for (int num = _spawned.Count - 1; num >= 0; num--)
		{
			BaseEntity baseEntity = _spawned[num];
			if ((Object)(object)baseEntity == (Object)null || baseEntity.Health() <= 0f)
			{
				_spawned.Remove(baseEntity);
			}
		}
		if (_spawned.Count < maxPopulation)
		{
			return true;
		}
		return false;
	}

	public void SpawnBot()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		while (HasFreePopulation())
		{
			Vector3 position = waypoints[0].position;
			BaseEntity baseEntity = GameManager.server.CreateEntity(bot.resourcePath, position);
			if ((Object)(object)baseEntity == (Object)null)
			{
				break;
			}
			_spawned.Add(baseEntity);
			((Component)baseEntity).SendMessage("SetWaypoints", (object)waypoints, (SendMessageOptions)1);
			baseEntity.Spawn();
		}
	}

	public void Start()
	{
		waypoints = ((Component)waypointParent).GetComponentsInChildren<Transform>();
		((FacepunchBehaviour)this).InvokeRepeating((Action)SpawnBot, 5f, spawnRate);
	}
}


using UnityEngine;

public class DevCamera : MonoBehaviour
{
	public float movementScale = 1f;
}


using UnityEngine;

[ExecuteInEditMode]
public class DevControls : MonoBehaviour
{
	public GUISkin skin;
}


public class DevControlsTab : BaseMonoBehaviour
{
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class DevDressPlayer : MonoBehaviour
{
	public bool DressRandomly;

	public List<ItemAmount> clothesToWear;

	private void ServerInitComponent()
	{
		BasePlayer component = ((Component)this).GetComponent<BasePlayer>();
		if (DressRandomly)
		{
			DoRandomClothes(component);
		}
		foreach (ItemAmount item in clothesToWear)
		{
			if (!((Object)(object)item.itemDef == (Object)null))
			{
				ItemManager.Create(item.itemDef, 1, 0uL).MoveToContainer(component.inventory.containerWear);
			}
		}
	}

	private void DoRandomClothes(BasePlayer player)
	{
		string text = "";
		foreach (ItemDefinition item in (from x in ItemManager.GetItemDefinitions()
			where Object.op_Implicit((Object)(object)((Component)x).GetComponent<ItemModWearable>())
			orderby Guid.NewGuid()
			select x).Take(Random.Range(0, 4)))
		{
			ItemManager.Create(item, 1, 0uL).MoveToContainer(player.inventory.containerWear);
			text = text + item.shortname + " ";
		}
		text = text.Trim();
		if (text == "")
		{
			text = "naked";
		}
		player.displayName = text;
	}
}


using System.Linq;
using Facepunch;
using Facepunch.Models;
using UnityEngine;

public static class DeveloperList
{
	public static bool Contains(string steamid)
	{
		if (Application.Manifest == null)
		{
			return false;
		}
		if (Application.Manifest.Administrators == null)
		{
			return false;
		}
		return Application.Manifest.Administrators.Any((Administrator x) => x.UserId == steamid);
	}

	public static bool Contains(ulong steamid)
	{
		return Contains(steamid.ToString());
	}

	public static bool IsDeveloper(BasePlayer ply)
	{
		if ((Object)(object)ply != (Object)null)
		{
			return Contains(ply.UserIDString);
		}
		return false;
	}
}


using UnityEngine;

public class DevEnableDisable : DevControlsTab
{
	public GameObject[] Objects;

	public string CookieName = "Cookie";

	public string TabName = "Scene";
}


public class DevEnvironment : DevControlsTab
{
	public TOD_Sky sky;
}


using UnityEngine;

public class DevImpactEffectTest : MonoBehaviour
{
}


using System;
using UnityEngine;

public class DevMovePlayer : BaseMonoBehaviour
{
	public BasePlayer player;

	public Transform[] Waypoints;

	public bool moveRandomly;

	public Vector3 destination = Vector3.zero;

	public Vector3 lookPoint = Vector3.zero;

	private int waypointIndex;

	private float randRun;

	public void Awake()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		randRun = Random.Range(5f, 10f);
		player = ((Component)this).GetComponent<BasePlayer>();
		if (Waypoints.Length != 0)
		{
			destination = Waypoints[0].position;
		}
		else
		{
			destination = ((Component)this).transform.position;
		}
		if (!player.isClient)
		{
			if ((Object)(object)player.eyes == (Object)null)
			{
				player.eyes = ((Component)player).GetComponent<PlayerEyes>();
			}
			((FacepunchBehaviour)this).Invoke((Action)LateSpawn, 1f);
		}
	}

	public void LateSpawn()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		Item item = ItemManager.CreateByName("rifle.semiauto", 1, 0uL);
		player.inventory.GiveItem(item, player.inventory.containerBelt);
		player.UpdateActiveItem(item.uid);
		player.health = 100f;
	}

	public void SetWaypoints(Transform[] wps)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Waypoints = wps;
		destination = wps[0].position;
	}

	public void Update()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		if (player.isClient || !player.IsAlive() || player.IsWounded())
		{
			return;
		}
		if (Vector3.Distance(destination, ((Component)this).transform.position) < 0.25f)
		{
			if (moveRandomly)
			{
				waypointIndex = Random.Range(0, Waypoints.Length);
			}
			else
			{
				waypointIndex++;
			}
			if (waypointIndex >= Waypoints.Length)
			{
				waypointIndex = 0;
			}
		}
		if (Waypoints.Length > waypointIndex)
		{
			destination = Waypoints[waypointIndex].position;
			Vector3 val = destination - ((Component)this).transform.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float running = Mathf.Sin(Time.time + randRun);
			float speed = player.GetSpeed(running, 0f, 0f);
			Vector3 position = ((Component)this).transform.position;
			float range = 1f;
			LayerMask mask = LayerMask.op_Implicit(1537286401);
			if (TransformUtil.GetGroundInfo(((Component)this).transform.position + normalized * speed * Time.deltaTime, out var hitOut, range, mask, ((Component)player).transform))
			{
				position = ((RaycastHit)(ref hitOut)).point;
			}
			((Component)this).transform.position = position;
			val = new Vector3(destination.x, 0f, destination.z) - new Vector3(((Component)player).transform.position.x, 0f, ((Component)player).transform.position.z);
			_ = ((Vector3)(ref val)).normalized;
			player.SendNetworkUpdate();
		}
	}
}


using UnityEngine;

public class DevTimeAdjust : MonoBehaviour
{
	private void Start()
	{
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			TOD_Sky.Instance.Cycle.Hour = PlayerPrefs.GetFloat("DevTime");
		}
	}

	private void OnGUI()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			float num = (float)Screen.width * 0.2f;
			Rect val = default(Rect);
			((Rect)(ref val))..ctor((float)Screen.width - (num + 20f), (float)Screen.height - 30f, num, 20f);
			float hour = TOD_Sky.Instance.Cycle.Hour;
			hour = GUI.HorizontalSlider(val, hour, 0f, 24f);
			((Rect)(ref val)).y = ((Rect)(ref val)).y - 20f;
			GUI.Label(val, "Time Of Day");
			if (hour != TOD_Sky.Instance.Cycle.Hour)
			{
				TOD_Sky.Instance.Cycle.Hour = hour;
				PlayerPrefs.SetFloat("DevTime", hour);
			}
		}
	}
}


using System;
using UnityEngine;

public class DevWeatherAdjust : MonoBehaviour
{
	protected void Awake()
	{
		SingletonComponent<Climate>.Instance.Overrides.Clouds = 0f;
		SingletonComponent<Climate>.Instance.Overrides.Fog = 0f;
		SingletonComponent<Climate>.Instance.Overrides.Wind = 0f;
		SingletonComponent<Climate>.Instance.Overrides.Rain = 0f;
	}

	protected void OnGUI()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)Screen.width * 0.2f;
		GUILayout.BeginArea(new Rect((float)Screen.width - num - 20f, 20f, num, 400f), "", GUIStyle.op_Implicit("box"));
		GUILayout.Box("Weather", Array.Empty<GUILayoutOption>());
		GUILayout.FlexibleSpace();
		GUILayout.Label("Clouds", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Clouds = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Clouds, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.Label("Fog", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Fog = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Fog, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.Label("Wind", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Wind = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Wind, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.Label("Rain", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Rain = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Rain, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.FlexibleSpace();
		GUILayout.EndArea();
	}
}


using System.Collections.Generic;

[JsonModel]
public class ClientFrametimeReport
{
	public int request_id;

	public int start_frame;

	public List<int> frame_times;
}


[JsonModel]
public class ClientFrametimeRequest
{
	public int request_id;

	public int start_frame;

	public int max_frames;
}


using System.Collections.Generic;
using UnityEngine;

public class GameContentList : MonoBehaviour
{
	public enum ResourceType
	{
		Audio,
		Textures,
		Models
	}

	public ResourceType resourceType;

	public List<Object> foundObjects;
}


public enum ResourceType
{
	Audio,
	Textures,
	Models
}


public static class ItemIconUpload
{
}


using UnityEngine;

public class ItemTools : MonoBehaviour
{
}


using UnityEngine;

public class LodLevelDisplay : MonoBehaviour, IEditorComponent
{
	public Color TextColor = Color.green;

	[Range(1f, 6f)]
	public float TextScaleMultiplier = 1f;
}


using UnityEngine;

public class MidiConvar : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using Rust.Workshop;
using UnityEngine;

public class Performance : SingletonComponent<Performance>
{
	public struct Tick
	{
		public int frameID;

		public int frameRate;

		public float frameTime;

		public float frameRateAverage;

		public float frameTimeAverage;

		public long memoryUsageSystem;

		public long memoryAllocations;

		public long memoryCollections;

		public long loadBalancerTasks;

		public long invokeHandlerTasks;

		public long workshopSkinsQueued;

		public int ping;

		public bool gcTriggered;

		public PerformanceSamplePoint performanceSample;
	}

	private struct LagSpike
	{
		public int Index;

		public int Time;
	}

	public static Tick current;

	public static Tick report;

	public const int FrameHistoryCount = 1000;

	private const int HistoryLength = 60;

	private static long cycles = 0L;

	private static int[] frameRateHistory = new int[60];

	private static float[] frameTimeHistory = new float[60];

	private static int[] frameTimes = new int[1000];

	private int frames;

	private float time;

	private void Update()
	{
		frameTimes[Time.frameCount % 1000] = (int)(1000f * Time.deltaTime);
		TimeWarning val = TimeWarning.New("FPSTimer", 0);
		try
		{
			FPSTimer();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public List<int> GetFrameTimes(int requestedStart, int maxCount, out int startIndex)
	{
		startIndex = Math.Max(requestedStart, Math.Max(Time.frameCount - 1000 - 1, 0));
		int num = Math.Min(Math.Min(1000, maxCount), Time.frameCount);
		List<int> list = Pool.Get<List<int>>();
		for (int i = 0; i < num; i++)
		{
			int num2 = (startIndex + i) % 1000;
			list.Add(frameTimes[num2]);
		}
		return list;
	}

	private void FPSTimer()
	{
		frames++;
		time += Time.unscaledDeltaTime;
		if (!(time < 1f))
		{
			long memoryCollections = current.memoryCollections;
			current.frameID = Time.frameCount;
			current.frameRate = frames;
			current.frameTime = time / (float)frames * 1000f;
			frameRateHistory[cycles % frameRateHistory.Length] = current.frameRate;
			frameTimeHistory[cycles % frameTimeHistory.Length] = current.frameTime;
			current.frameRateAverage = AverageFrameRate();
			current.frameTimeAverage = AverageFrameTime();
			current.memoryUsageSystem = SystemInfoEx.systemMemoryUsed;
			current.memoryAllocations = Rust.GC.GetTotalMemory();
			current.memoryCollections = Rust.GC.CollectionCount();
			current.loadBalancerTasks = LoadBalancer.Count();
			current.invokeHandlerTasks = InvokeHandler.Count();
			current.workshopSkinsQueued = WorkshopSkin.QueuedCount;
			current.performanceSample = PerformanceMetrics.PerformancePerSecond;
			PerformanceMetrics.PerformancePerSecond = default(PerformanceSamplePoint);
			current.gcTriggered = memoryCollections != current.memoryCollections;
			frames = 0;
			time = 0f;
			cycles++;
			report = current;
		}
	}

	private float AverageFrameRate()
	{
		float num = 0f;
		int num2 = Math.Min(frameRateHistory.Length, (int)cycles);
		for (int i = 0; i < num2; i++)
		{
			num += (float)frameRateHistory[i];
		}
		return num / (float)num2;
	}

	private float AverageFrameTime()
	{
		float num = 0f;
		int num2 = Math.Min(frameTimeHistory.Length, (int)cycles);
		for (int i = 0; i < frameTimeHistory.Length; i++)
		{
			num += frameTimeHistory[i];
		}
		return num / (float)num2;
	}
}


public struct Tick
{
	public int frameID;

	public int frameRate;

	public float frameTime;

	public float frameRateAverage;

	public float frameTimeAverage;

	public long memoryUsageSystem;

	public long memoryAllocations;

	public long memoryCollections;

	public long loadBalancerTasks;

	public long invokeHandlerTasks;

	public long workshopSkinsQueued;

	public int ping;

	public bool gcTriggered;

	public PerformanceSamplePoint performanceSample;
}


private struct LagSpike
{
	public int Index;

	public int Time;
}


using UnityEngine;

public class PrefabPrepare : MonoBehaviour
{
}


using UnityEngine;

public class PrefabValidate : MonoBehaviour
{
}


using UnityEngine;

public class ProjectileTestSpawner : MonoBehaviour
{
	public Projectile TargetProjectile;

	public float RepeatTime = 1f;

	public float VelocityScale = 1f;
}


using UnityEngine;

public class SteamInventoryGen : MonoBehaviour
{
}


using Rust;
using UnityEngine;

public class DoorAnimEvents : MonoBehaviour, IClientComponent
{
	public GameObjectRef openStart;

	public GameObjectRef openEnd;

	public GameObjectRef closeStart;

	public GameObjectRef closeEnd;

	public GameObject soundTarget;

	public bool checkAnimSpeed;

	public Animator animator => ((Component)this).GetComponent<Animator>();

	public void DoorOpenStart()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !openStart.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime > 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed < 0f)
			{
				return;
			}
		}
		Effect.client.Run(openStart.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}

	public void DoorOpenEnd()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !openEnd.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime < 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed < 0f)
			{
				return;
			}
		}
		Effect.client.Run(openEnd.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}

	public void DoorCloseStart()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !closeStart.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime > 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed > 0f)
			{
				return;
			}
		}
		Effect.client.Run(closeStart.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}

	public void DoorCloseEnd()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !closeEnd.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime < 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed > 0f)
			{
				return;
			}
		}
		Effect.client.Run(closeEnd.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}
}


using UnityEngine;

public class AnimationEvents : BaseMonoBehaviour
{
	public Transform rootObject;

	public HeldEntity targetEntity;

	[Tooltip("Path to the effect folder for these animations. Relative to this object.")]
	public string effectFolder;

	public bool enforceClipWeights;

	public string localFolder;

	[Tooltip("If true the localFolder field won't update with manifest updates, use for custom paths")]
	public bool customLocalFolder;

	public HeldEntity worldModelEntity;

	public bool IsBusy;

	protected void OnEnable()
	{
		if ((Object)(object)rootObject == (Object)null)
		{
			rootObject = ((Component)this).transform;
		}
	}
}


using UnityEngine;

public class AnimationEventsStub : MonoBehaviour
{
}


using UnityEngine;

public abstract class BaseFootstepEffect : MonoBehaviour, IClientComponent
{
	public LayerMask validImpactLayers = LayerMask.op_Implicit(-1);
}


using UnityEngine;

public class BucketVMFluidSim : MonoBehaviour, IClientComponent
{
	public Animator waterbucketAnim;

	public ParticleSystem waterPour;

	public ParticleSystem waterTurbulence;

	public ParticleSystem waterFill;

	public float waterLevel;

	public float targetWaterLevel;

	public AudioSource waterSpill;
}


using UnityEngine;

public class ColdBreath : BaseMonoBehaviour
{
	public GameObjectRef effect;

	private BasePlayer player;

	private Transform jawBone;
}


using System.Collections.Generic;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;

public class Effect : EffectData
{
	public enum Type : uint
	{
		Generic,
		Projectile,
		GenericGlobal
	}

	public static class client
	{
		public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
		{
		}

		public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
		{
			string.IsNullOrEmpty(strName);
		}

		public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3))
		{
		}

		public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3), Type overrideType = Type.Generic)
		{
			string.IsNullOrEmpty(strName);
		}

		public static void Run(string strName, GameObject obj)
		{
			string.IsNullOrEmpty(strName);
		}

		public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			if (info.HitEntity.IsValid())
			{
				Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal + info.HitNormalLocal * 0.1f, info.HitNormalLocal);
			}
			else
			{
				Run(effectName, info.HitPositionWorld + info.HitNormalWorld * 0.1f, info.HitNormalWorld);
			}
		}

		private static bool CanPlayImpactEffect(HitInfo info)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
			{
				return false;
			}
			return true;
		}

		private static Type GetOverrideType(HitInfo info)
		{
			return Type.Generic;
		}

		private static void HandleAdditiveEffects(HitInfo info)
		{
			if (info.damageTypes.Has(DamageType.Explosion))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
			}
			if (info.damageTypes.Has(DamageType.Heat))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
			}
		}

		public static void ImpactEffect(HitInfo info, string customEffect = null)
		{
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0156: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			if (!info.DoHitEffects)
			{
				return;
			}
			string materialName = StringPool.Get(info.HitMaterial);
			string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
			string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
			if (!CanPlayImpactEffect(info))
			{
				return;
			}
			if (info.HitEntity.IsValid())
			{
				if (customEffect == null)
				{
					GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
					if (impactEffect.isValid)
					{
						strName = impactEffect.resourcePath;
					}
				}
				Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
				if (info.DoDecals)
				{
					Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
				}
			}
			else
			{
				Type overrideType = GetOverrideType(info);
				Run(strName, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
				Run(decal, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
			}
			if (info.WeaponPrefab is BaseMelee baseMelee)
			{
				string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
				if (info.HitEntity.IsValid())
				{
					Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
				}
				else
				{
					Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld);
				}
			}
			HandleAdditiveEffects(info);
		}
	}

	public static class server
	{
		public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			reusableInstace.Init(fxtype, ent, boneID, posLocal, normLocal, sourceConnection);
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}

		public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			if (!string.IsNullOrEmpty(strName))
			{
				reusableInstace.Init(Type.Generic, ent, boneID, posLocal, normLocal, sourceConnection);
				reusableInstace.pooledString = strName;
				reusableInstace.broadcast = broadcast;
				reusableInstace.targets = targets;
				EffectNetwork.Send(reusableInstace);
			}
		}

		public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			reusableInstace.Init(fxtype, posWorld, normWorld, sourceConnection);
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}

		public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			if (!string.IsNullOrEmpty(strName))
			{
				reusableInstace.Init(Type.Generic, posWorld, normWorld, sourceConnection);
				reusableInstace.pooledString = strName;
				reusableInstace.broadcast = broadcast;
				reusableInstace.targets = targets;
				EffectNetwork.Send(reusableInstace);
			}
		}

		public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			if (info.HitEntity.IsValid())
			{
				Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			}
			else
			{
				Run(effectName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			}
		}

		private static bool CanPlayImpactEffect(HitInfo info)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
			{
				return false;
			}
			return true;
		}

		private static void HandleAdditiveEffects(HitInfo info)
		{
			if (info.damageTypes.Has(DamageType.Explosion))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
			}
			if (info.damageTypes.Has(DamageType.Heat))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
			}
		}

		private static void HandleWeaponEffects(HitInfo info, string materialName)
		{
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)info.WeaponPrefab))
			{
				return;
			}
			BaseMelee baseMelee = info.WeaponPrefab as BaseMelee;
			if ((Object)(object)baseMelee != (Object)null)
			{
				string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
				if (info.HitEntity.IsValid())
				{
					Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
				}
				else
				{
					Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
				}
			}
		}

		private static bool IsLegalPlacement(HitInfo info)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			Bounds bounds = info.HitEntity.bounds;
			float num = info.HitEntity.BoundsPadding();
			((Bounds)(ref bounds)).extents = ((Bounds)(ref bounds)).extents + new Vector3(num, num, num);
			if (!((Bounds)(ref bounds)).Contains(info.HitPositionLocal))
			{
				BasePlayer initiatorPlayer = info.InitiatorPlayer;
				if ((Object)(object)initiatorPlayer != (Object)null && ((object)initiatorPlayer).GetType() == typeof(BasePlayer))
				{
					float num2 = Mathf.Sqrt(((Bounds)(ref bounds)).SqrDistance(info.HitPositionLocal));
					if (num2 > ConVar.AntiHack.impact_effect_distance_forgiveness)
					{
						AntiHack.Log(initiatorPlayer, AntiHackType.EffectHack, $"Tried to run an impact effect outside of entity '{info.HitEntity.ShortPrefabName}' bounds by {num2}m");
					}
				}
				return false;
			}
			return true;
		}

		public static void ImpactEffect(HitInfo info, string customEffect = null)
		{
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0117: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			if (Interface.CallHook("OnImpactEffectCreate", (object)info, (object)customEffect) != null || (Object.op_Implicit((Object)(object)info.InitiatorPlayer) && info.InitiatorPlayer.limitNetworking) || !info.DoHitEffects)
			{
				return;
			}
			string materialName = StringPool.Get(info.HitMaterial);
			if (!CanPlayImpactEffect(info))
			{
				return;
			}
			string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
			string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
			if (info.HitEntity.IsValid())
			{
				if (customEffect == null)
				{
					GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
					if (impactEffect.isValid)
					{
						strName = impactEffect.resourcePath;
					}
				}
				if (!IsLegalPlacement(info))
				{
					return;
				}
				Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
				Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			}
			else
			{
				Run(strName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
				Run(decal, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			}
			HandleWeaponEffects(info, materialName);
			HandleAdditiveEffects(info);
		}
	}

	public Vector3 upDir;

	public Vector3 worldPos;

	public Vector3 worldNrm;

	public bool attached;

	public Transform transform;

	public GameObject gameObject;

	public string pooledString;

	public bool broadcast;

	public List<Connection> targets;

	private static Effect reusableInstace = new Effect();

	public Effect()
	{
	}

	public Effect(string effectName, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		Init(Type.Generic, posWorld, normWorld, sourceConnection);
		pooledString = effectName;
	}

	public Effect(string effectName, BaseEntity ent, uint boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection = null)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		Init(Type.Generic, ent, boneID, posLocal, normLocal, sourceConnection);
		pooledString = effectName;
	}

	public void Init(Type fxtype, BaseEntity ent, uint boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection = null)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		Clear();
		base.type = (uint)fxtype;
		attached = true;
		base.origin = posLocal;
		base.normal = normLocal;
		if ((Object)(object)ent != (Object)null && !ent.IsValid())
		{
			Debug.LogWarning((object)"Effect.Init - invalid entity");
		}
		base.entity = (NetworkableId)(ent.IsValid() ? ent.net.ID : default(NetworkableId));
		base.source = sourceConnection?.userid ?? 0;
		base.bone = boneID;
	}

	public void Init(Type fxtype, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		Clear();
		base.type = (uint)fxtype;
		attached = false;
		base.origin = (worldPos = posWorld);
		base.normal = (worldNrm = normWorld);
		base.source = sourceConnection?.userid ?? 0;
	}

	public void Clear()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		base.type = 0u;
		base.pooledstringid = 0u;
		base.number = 0;
		base.origin = default(Vector3);
		base.normal = default(Vector3);
		base.scale = 0f;
		base.entity = default(NetworkableId);
		base.bone = 0u;
		base.source = 0uL;
		base.distanceOverride = 0f;
		upDir = Vector3.zero;
		worldPos = Vector3.zero;
		worldNrm = Vector3.zero;
		attached = false;
		transform = null;
		gameObject = null;
		pooledString = null;
		broadcast = false;
		targets = null;
	}
}


public enum Type : uint
{
	Generic,
	Projectile,
	GenericGlobal
}


using Rust;
using UnityEngine;

public static class client
{
	public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
	{
	}

	public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
	{
		string.IsNullOrEmpty(strName);
	}

	public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3))
	{
	}

	public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3), Type overrideType = Type.Generic)
	{
		string.IsNullOrEmpty(strName);
	}

	public static void Run(string strName, GameObject obj)
	{
		string.IsNullOrEmpty(strName);
	}

	public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (info.HitEntity.IsValid())
		{
			Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal + info.HitNormalLocal * 0.1f, info.HitNormalLocal);
		}
		else
		{
			Run(effectName, info.HitPositionWorld + info.HitNormalWorld * 0.1f, info.HitNormalWorld);
		}
	}

	private static bool CanPlayImpactEffect(HitInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
		{
			return false;
		}
		return true;
	}

	private static Type GetOverrideType(HitInfo info)
	{
		return Type.Generic;
	}

	private static void HandleAdditiveEffects(HitInfo info)
	{
		if (info.damageTypes.Has(DamageType.Explosion))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
		}
		if (info.damageTypes.Has(DamageType.Heat))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
		}
	}

	public static void ImpactEffect(HitInfo info, string customEffect = null)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		if (!info.DoHitEffects)
		{
			return;
		}
		string materialName = StringPool.Get(info.HitMaterial);
		string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
		string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
		if (!CanPlayImpactEffect(info))
		{
			return;
		}
		if (info.HitEntity.IsValid())
		{
			if (customEffect == null)
			{
				GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
				if (impactEffect.isValid)
				{
					strName = impactEffect.resourcePath;
				}
			}
			Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
			if (info.DoDecals)
			{
				Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
			}
		}
		else
		{
			Type overrideType = GetOverrideType(info);
			Run(strName, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
			Run(decal, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
		}
		if (info.WeaponPrefab is BaseMelee baseMelee)
		{
			string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
			if (info.HitEntity.IsValid())
			{
				Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
			}
			else
			{
				Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld);
			}
		}
		HandleAdditiveEffects(info);
	}
}


using System.Collections.Generic;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;

public static class server
{
	public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		reusableInstace.Init(fxtype, ent, boneID, posLocal, normLocal, sourceConnection);
		reusableInstace.broadcast = broadcast;
		reusableInstace.targets = targets;
		EffectNetwork.Send(reusableInstace);
	}

	public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (!string.IsNullOrEmpty(strName))
		{
			reusableInstace.Init(Type.Generic, ent, boneID, posLocal, normLocal, sourceConnection);
			reusableInstace.pooledString = strName;
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}
	}

	public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		reusableInstace.Init(fxtype, posWorld, normWorld, sourceConnection);
		reusableInstace.broadcast = broadcast;
		reusableInstace.targets = targets;
		EffectNetwork.Send(reusableInstace);
	}

	public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!string.IsNullOrEmpty(strName))
		{
			reusableInstace.Init(Type.Generic, posWorld, normWorld, sourceConnection);
			reusableInstace.pooledString = strName;
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}
	}

	public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (info.HitEntity.IsValid())
		{
			Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
		}
		else
		{
			Run(effectName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
		}
	}

	private static bool CanPlayImpactEffect(HitInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
		{
			return false;
		}
		return true;
	}

	private static void HandleAdditiveEffects(HitInfo info)
	{
		if (info.damageTypes.Has(DamageType.Explosion))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
		}
		if (info.damageTypes.Has(DamageType.Heat))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
		}
	}

	private static void HandleWeaponEffects(HitInfo info, string materialName)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)info.WeaponPrefab))
		{
			return;
		}
		BaseMelee baseMelee = info.WeaponPrefab as BaseMelee;
		if ((Object)(object)baseMelee != (Object)null)
		{
			string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
			if (info.HitEntity.IsValid())
			{
				Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			}
			else
			{
				Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			}
		}
	}

	private static bool IsLegalPlacement(HitInfo info)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = info.HitEntity.bounds;
		float num = info.HitEntity.BoundsPadding();
		((Bounds)(ref bounds)).extents = ((Bounds)(ref bounds)).extents + new Vector3(num, num, num);
		if (!((Bounds)(ref bounds)).Contains(info.HitPositionLocal))
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((Object)(object)initiatorPlayer != (Object)null && ((object)initiatorPlayer).GetType() == typeof(BasePlayer))
			{
				float num2 = Mathf.Sqrt(((Bounds)(ref bounds)).SqrDistance(info.HitPositionLocal));
				if (num2 > ConVar.AntiHack.impact_effect_distance_forgiveness)
				{
					AntiHack.Log(initiatorPlayer, AntiHackType.EffectHack, $"Tried to run an impact effect outside of entity '{info.HitEntity.ShortPrefabName}' bounds by {num2}m");
				}
			}
			return false;
		}
		return true;
	}

	public static void ImpactEffect(HitInfo info, string customEffect = null)
	{
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnImpactEffectCreate", (object)info, (object)customEffect) != null || (Object.op_Implicit((Object)(object)info.InitiatorPlayer) && info.InitiatorPlayer.limitNetworking) || !info.DoHitEffects)
		{
			return;
		}
		string materialName = StringPool.Get(info.HitMaterial);
		if (!CanPlayImpactEffect(info))
		{
			return;
		}
		string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
		string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
		if (info.HitEntity.IsValid())
		{
			if (customEffect == null)
			{
				GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
				if (impactEffect.isValid)
				{
					strName = impactEffect.resourcePath;
				}
			}
			if (!IsLegalPlacement(info))
			{
				return;
			}
			Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
		}
		else
		{
			Run(strName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			Run(decal, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
		}
		HandleWeaponEffects(info, materialName);
		HandleAdditiveEffects(info);
	}
}


using UnityEngine;

public class EffectAudioPerspectiveSwitcher : MonoBehaviour, IEffect
{
	[HideInInspector]
	public EffectParentToWeaponBone parentToWeaponComponent;
}


public interface IEffectRecycle
{
}


public interface IEffect
{
}


public static class EffectLibrary
{
}


using UnityEngine;

public class EffectMuzzleFlash : MonoBehaviour, IEffect
{
}


using System;
using System.IO;
using Network;
using Network.Visibility;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public static class EffectNetwork
{
	public static void Send(Effect effect)
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null || !((BaseNetwork)Net.sv).IsConnected())
		{
			return;
		}
		TimeWarning val = TimeWarning.New("EffectNetwork.Send", 0);
		try
		{
			Group val2 = null;
			if (!string.IsNullOrEmpty(effect.pooledString))
			{
				((EffectData)effect).pooledstringid = StringPool.Get(effect.pooledString);
			}
			if (((EffectData)effect).pooledstringid == 0)
			{
				Debug.Log((object)("String ID is 0 - unknown effect " + effect.pooledString));
				return;
			}
			if (effect.broadcast)
			{
				NetWrite val3 = ((BaseNetwork)Net.sv).StartWrite();
				val3.PacketID((Type)13);
				ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val3, false, 2097152);
				val3.Send(new SendInfo(BaseNetworkable.GlobalNetworkGroup.subscribers));
				return;
			}
			if (effect.targets != null)
			{
				NetWrite val4 = ((BaseNetwork)Net.sv).StartWrite();
				val4.PacketID((Type)13);
				ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val4, false, 2097152);
				val4.Send(new SendInfo(effect.targets));
				return;
			}
			if (((NetworkableId)(ref ((EffectData)effect).entity)).IsValid)
			{
				BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(((EffectData)effect).entity) as BaseEntity;
				if (!baseEntity.IsValid())
				{
					return;
				}
				val2 = baseEntity.net.group;
			}
			else
			{
				val2 = Net.sv.visibility.GetGroup(effect.worldPos);
			}
			if (val2 != null)
			{
				NetWrite val5 = ((BaseNetwork)Net.sv).StartWrite();
				val5.PacketID((Type)13);
				ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val5, false, 2097152);
				val5.Send(new SendInfo(val2.subscribers));
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void Send(Effect effect, Connection target)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		((EffectData)effect).pooledstringid = StringPool.Get(effect.pooledString);
		if (((EffectData)effect).pooledstringid == 0)
		{
			Debug.LogWarning((object)("EffectNetwork.Send - unpooled effect name: " + effect.pooledString));
			return;
		}
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		val.PacketID((Type)13);
		ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val, false, 2097152);
		val.Send(new SendInfo(target));
	}
}


public class EffectParentToWeaponBone : BaseMonoBehaviour, IEffect
{
	public string boneName;

	public bool singleFrame;
}


using UnityEngine;

public class EffectScaleWithCameraDistance : MonoBehaviour, IEffect
{
	public float minScale = 1f;

	public float maxScale = 2.5f;

	public float scaleStartDistance = 50f;

	public float scaleEndDistance = 150f;
}


using UnityEngine;

public class EmissionBlink : FacepunchBehaviour, IClientComponent, INotifyLOD
{
	public EmissionToggle emissionToggle;

	public float blinkDuration = 1f;

	public float blinkInterval = 3f;

	public Light light;

	public float onIntensity = 3f;

	public float offIntensity = 1f;

	[Header("Optional Secondary Light")]
	public bool useSecondaryLight;

	public Light secondaryLight;

	public float secondaryOnIntensity = 2f;

	public float secondaryOffIntensity = 0.5f;
}


using UnityEngine;

public class EmissionScaledByLight : MonoBehaviour, IClientComponent
{
	private Color emissionColor;

	public Renderer[] targetRenderers;

	public int materialIndex = -1;

	private static MaterialPropertyBlock block;

	public Light lightToFollow;

	public float maxEmissionValue = 3f;
}


using UnityEngine;

public class EmissionToggle : MonoBehaviour, IClientComponent
{
	private Color emissionColor;

	public Renderer[] targetRenderers;

	public int materialIndex = -1;
}


using UnityEngine;

public class EyeBlink : MonoBehaviour
{
	public Transform LeftEye;

	public Transform LeftEyelid;

	public Vector3 LeftEyeOffset = new Vector3(0.01f, -0.002f, 0f);

	public Transform RightEye;

	public Transform RightEyelid;

	public Vector3 RightEyeOffset = new Vector3(0.01f, -0.002f, 0f);

	public Vector3 ClosedEyelidPosition;

	public Vector3 ClosedEyelidRotation;

	public Vector2 TimeWithoutBlinking = new Vector2(1f, 10f);

	public float BlinkSpeed = 0.2f;

	public Vector3 LeftEyeInitial;

	public Vector3 RightEyeInitial;
}


using UnityEngine;

public class EyeController : MonoBehaviour
{
	public const float MaxLookDot = 0.8f;

	public bool debug;

	public Transform LeftEye;

	public Transform RightEye;

	public Transform EyeTransform;

	public Vector3 Fudge = new Vector3(0f, 90f, 0f);

	public Vector3 FlickerRange;

	private Transform Focus;

	private float FocusUpdateTime;
}


using UnityEngine;

public class FireBomb : MonoBehaviour, IClientComponent
{
	public GameObject fireParticle;

	public float bombRadius;

	public float particleDuration;

	public float emitDuration;
}


using UnityEngine;

public class FirstPersonEffect : MonoBehaviour, IEffect
{
	public bool isGunShot;

	[HideInInspector]
	public EffectParentToWeaponBone parentToWeaponComponent;
}


using UnityEngine;

public class FootstepEffects : BaseFootstepEffect
{
	public Transform leftFoot;

	public Transform rightFoot;

	public string footstepEffectName = "footstep/barefoot";

	public string jumpStartEffectName = "jump-start/barefoot";

	public string jumpLandEffectName = "jump-land/barefoot";

	public SoundDefinition accentSound;
}


public interface IAnimationEventReceiver
{
}


using UnityEngine;

public class LightPulse : MonoBehaviour, IClientComponent
{
	public Light TargetLight;

	public float PulseSpeed = 1f;

	public float Lifetime = 3f;

	public float MaxIntensity = 3f;

	public float FadeOutSpeed = 2f;
}


using UnityEngine;

public class MaterialSwap : MonoBehaviour, IClientComponent
{
	public int materialIndex;

	public Renderer myRenderer;

	public Material OverrideMaterial;
}


using UnityEngine;

public class Muzzleflash_AlphaRandom : MonoBehaviour
{
	public ParticleSystem[] muzzleflashParticles;

	private Gradient grad = new Gradient();

	private GradientColorKey[] gck = (GradientColorKey[])(object)new GradientColorKey[3];

	private GradientAlphaKey[] gak = (GradientAlphaKey[])(object)new GradientAlphaKey[3];

	private void Start()
	{
	}

	private void OnEnable()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		gck[0].color = Color.white;
		gck[0].time = 0f;
		gck[1].color = Color.white;
		gck[1].time = 0.6f;
		gck[2].color = Color.black;
		gck[2].time = 0.75f;
		float alpha = Random.Range(0.2f, 0.85f);
		gak[0].alpha = alpha;
		gak[0].time = 0f;
		gak[1].alpha = alpha;
		gak[1].time = 0.45f;
		gak[2].alpha = 0f;
		gak[2].time = 0.5f;
		grad.SetKeys(gck, gak);
		ParticleSystem[] array = muzzleflashParticles;
		foreach (ParticleSystem val in array)
		{
			if ((Object)(object)val == (Object)null)
			{
				Debug.LogWarning((object)("Muzzleflash_AlphaRandom : null particle system in " + ((Object)((Component)this).gameObject).name));
				continue;
			}
			ColorOverLifetimeModule colorOverLifetime = val.colorOverLifetime;
			((ColorOverLifetimeModule)(ref colorOverLifetime)).color = MinMaxGradient.op_Implicit(grad);
		}
	}
}


using UnityEngine;

public class MuzzleFlash_Flamelet : MonoBehaviour
{
	public ParticleSystem flameletParticle;

	private void OnEnable()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		ShapeModule shape = flameletParticle.shape;
		((ShapeModule)(ref shape)).angle = Random.Range(6, 13);
		float num = Random.Range(7f, 9f);
		flameletParticle.startSpeed = Random.Range(2.5f, num);
		flameletParticle.startSize = Random.Range(0.05f, num * 0.015f);
	}
}


using UnityEngine;

public class NPCFootstepEffects : BaseFootstepEffect
{
	public string impactEffectDirectory = "footstep/stag";

	public Transform frontLeftFoot;

	public Transform frontRightFoot;

	public Transform backLeftFoot;

	public Transform backRightFoot;
}


using UnityEngine;

public class ParticleEmissionSound : FacepunchBehaviour, IClientComponent, ILOD
{
	public ParticleSystem particleSystem;

	public SoundDefinition soundDefinition;

	public float soundCooldown;
}


using UnityEngine;

public class ParticleEmitFromParentObject : MonoBehaviour
{
	public string bonename;

	private Bounds bounds;

	private Transform bone;

	private BaseEntity entity;

	private float lastBoundsUpdate;
}


using ConVar;
using UnityEngine;

public class PhysicsEffects : MonoBehaviour
{
	public BaseEntity entity;

	public SoundDefinition physImpactSoundDef;

	public float minTimeBetweenEffects = 0.25f;

	public float minDistBetweenEffects = 0.1f;

	public float hardnessScale = 1f;

	public float lowMedThreshold = 0.4f;

	public float medHardThreshold = 0.7f;

	public float enableDelay = 0.1f;

	public LayerMask ignoreLayers;

	public bool useCollisionPositionInsteadOfTransform;

	public float minimumRigidbodyImpactWeight;

	private float lastEffectPlayed;

	private float enabledAt = float.PositiveInfinity;

	private float ignoreImpactThreshold = 0.02f;

	private Vector3 lastCollisionPos;

	public void OnEnable()
	{
		enabledAt = Time.time;
	}

	public void OnCollisionEnter(Collision collision)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if (!Physics.sendeffects || Time.time < enabledAt + enableDelay || Time.time < lastEffectPlayed + minTimeBetweenEffects || ((1 << collision.gameObject.layer) & LayerMask.op_Implicit(ignoreLayers)) != 0)
		{
			return;
		}
		Vector3 relativeVelocity = collision.relativeVelocity;
		float magnitude = ((Vector3)(ref relativeVelocity)).magnitude;
		magnitude = magnitude * 0.055f * hardnessScale;
		Rigidbody val = default(Rigidbody);
		if (!(magnitude <= ignoreImpactThreshold) && (!((useCollisionPositionInsteadOfTransform ? Vector3.Distance(((ContactPoint)(ref collision.contacts[0])).point, lastCollisionPos) : Vector3.Distance(((Component)this).transform.position, lastCollisionPos)) < minDistBetweenEffects) || lastEffectPlayed == 0f) && (!(minimumRigidbodyImpactWeight > 0f) || !collision.gameObject.TryGetComponent<Rigidbody>(ref val) || !(val.mass < minimumRigidbodyImpactWeight)))
		{
			if ((Object)(object)entity != (Object)null)
			{
				entity.SignalBroadcast(BaseEntity.Signal.PhysImpact, magnitude.ToString());
			}
			lastEffectPlayed = Time.time;
			if (useCollisionPositionInsteadOfTransform)
			{
				lastCollisionPos = ((Component)this).transform.InverseTransformPoint(((ContactPoint)(ref collision.contacts[0])).point);
			}
			else
			{
				lastCollisionPos = ((Component)this).transform.position;
			}
		}
	}
}


using UnityEngine;

public class RottingFlies : MonoBehaviour, IClientComponent
{
	public GameObjectRef effect;

	public SoundDefinition soundDef;

	public Transform rootBone;
}


using UnityEngine;

public class Sandstorm : MonoBehaviour
{
	public ParticleSystem m_psSandStorm;

	public float m_flSpeed;

	public float m_flSwirl;

	public float m_flEmissionRate;

	private void Start()
	{
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.RotateAround(((Component)this).transform.position, Vector3.up, Time.deltaTime * m_flSwirl);
		Vector3 eulerAngles = ((Component)this).transform.eulerAngles;
		eulerAngles.x = -7f + Mathf.Sin(Time.time * 2.5f) * 7f;
		((Component)this).transform.eulerAngles = eulerAngles;
		if ((Object)(object)m_psSandStorm != (Object)null)
		{
			m_psSandStorm.startSpeed = m_flSpeed;
			ParticleSystem psSandStorm = m_psSandStorm;
			psSandStorm.startSpeed += Mathf.Sin(Time.time * 0.4f) * (m_flSpeed * 0.75f);
			m_psSandStorm.emissionRate = m_flEmissionRate + Mathf.Sin(Time.time * 1f) * (m_flEmissionRate * 0.3f);
		}
	}
}


using System;
using UnityEngine;

public class ScaleParticleSystem : ScaleRenderer
{
	public ParticleSystem pSystem;

	public bool scaleGravity;

	[NonSerialized]
	private float startSize;

	[NonSerialized]
	private float startLifeTime;

	[NonSerialized]
	private float startSpeed;

	[NonSerialized]
	private float startGravity;

	public override void GatherInitialValues()
	{
		base.GatherInitialValues();
		startGravity = pSystem.gravityModifier;
		startSpeed = pSystem.startSpeed;
		startSize = pSystem.startSize;
		startLifeTime = pSystem.startLifetime;
	}

	public override void SetScale_Internal(float scale)
	{
		base.SetScale_Internal(scale);
		pSystem.startSize = startSize * scale;
		pSystem.startLifetime = startLifeTime * scale;
		pSystem.startSpeed = startSpeed * scale;
		pSystem.gravityModifier = startGravity * scale;
	}
}


using UnityEngine;

public class ScaleRenderer : MonoBehaviour
{
	public bool useRandomScale;

	public float scaleMin = 1f;

	public float scaleMax = 1f;

	private float lastScale = -1f;

	protected bool hasInitialValues;

	public Renderer myRenderer;

	private bool ScaleDifferent(float newScale)
	{
		return newScale != lastScale;
	}

	public void Start()
	{
		if (useRandomScale)
		{
			SetScale(Random.Range(scaleMin, scaleMax));
		}
	}

	public void SetScale(float scale)
	{
		if (!hasInitialValues)
		{
			GatherInitialValues();
		}
		if (ScaleDifferent(scale) || (scale > 0f && !myRenderer.enabled))
		{
			SetRendererEnabled(scale != 0f);
			SetScale_Internal(scale);
		}
	}

	public virtual void SetScale_Internal(float scale)
	{
		lastScale = scale;
	}

	public virtual void SetRendererEnabled(bool isEnabled)
	{
		if (Object.op_Implicit((Object)(object)myRenderer) && myRenderer.enabled != isEnabled)
		{
			myRenderer.enabled = isEnabled;
		}
	}

	public virtual void GatherInitialValues()
	{
		hasInitialValues = true;
	}
}


using System;
using UnityEngine;

public class ScaleTrailRenderer : ScaleRenderer
{
	private TrailRenderer trailRenderer;

	[NonSerialized]
	private float startWidth;

	[NonSerialized]
	private float endWidth;

	[NonSerialized]
	private float duration;

	[NonSerialized]
	private float startMultiplier;

	public override void GatherInitialValues()
	{
		base.GatherInitialValues();
		if (Object.op_Implicit((Object)(object)myRenderer))
		{
			trailRenderer = ((Component)myRenderer).GetComponent<TrailRenderer>();
		}
		else
		{
			trailRenderer = ((Component)this).GetComponentInChildren<TrailRenderer>();
		}
		startWidth = trailRenderer.startWidth;
		endWidth = trailRenderer.endWidth;
		duration = trailRenderer.time;
		startMultiplier = trailRenderer.widthMultiplier;
	}

	public override void SetScale_Internal(float scale)
	{
		if (scale == 0f)
		{
			trailRenderer.emitting = false;
			((Renderer)trailRenderer).enabled = false;
			trailRenderer.time = 0f;
			trailRenderer.Clear();
			return;
		}
		if (!trailRenderer.emitting)
		{
			trailRenderer.Clear();
		}
		trailRenderer.emitting = true;
		((Renderer)trailRenderer).enabled = true;
		base.SetScale_Internal(scale);
		trailRenderer.widthMultiplier = startMultiplier * scale;
		trailRenderer.time = duration * scale;
	}
}


using UnityEngine;

public class ScaleTransform : ScaleRenderer
{
	private Vector3 initialScale;

	public override void SetScale_Internal(float scale)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.SetScale_Internal(scale);
		((Component)myRenderer).transform.localScale = initialScale * scale;
	}

	public override void GatherInitialValues()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		initialScale = ((Component)myRenderer).transform.localScale;
		base.GatherInitialValues();
	}
}


using UnityEngine;

public class AnimatedScreenShake : BaseScreenShake
{
	public AnimationClip TargetClip;

	[ReadOnly]
	public AnimationCurve rotX;

	[ReadOnly]
	public AnimationCurve rotY;

	[ReadOnly]
	public AnimationCurve rotZ;

	[ReadOnly]
	public AnimationCurve posX;

	[ReadOnly]
	public AnimationCurve posY;

	[ReadOnly]
	public AnimationCurve posZ;

	private const float VALID_RANGE = 0.1f;

	private bool canPlay;

	public override void Setup()
	{
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		if (canPlay)
		{
			float num = rotX.Evaluate(delta);
			float num2 = rotY.Evaluate(delta);
			float num3 = rotZ.Evaluate(delta);
			float num4 = posX.Evaluate(delta);
			float num5 = posY.Evaluate(delta);
			float num6 = posZ.Evaluate(delta);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(num, num2, num3);
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(num4, num5, num6);
			if ((bool)cam)
			{
				cam.rotation = Quaternion.Euler(((Quaternion)(ref cam.rotation)).eulerAngles + val);
				ref Vector3 position = ref cam.position;
				position += val2;
			}
			if ((bool)vm)
			{
				vm.rotation = Quaternion.Euler(((Quaternion)(ref vm.rotation)).eulerAngles + val);
				ref Vector3 position2 = ref vm.position;
				position2 += val2;
			}
		}
	}
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public abstract class BaseScreenShake : MonoBehaviour
{
	public static List<BaseScreenShake> list = new List<BaseScreenShake>();

	internal static float punchFadeScale = 0f;

	internal static float bobScale = 0f;

	internal static float animPunchMagnitude = 10f;

	internal static AnimationCurve InverseCurve = AnimationCurve.Linear(0f, 1f, 1f, 0.05f);

	public float length = 2f;

	internal float timeTaken;

	private int currentFrame = -1;

	public static void Apply(Camera cam, BaseViewModel vm)
	{
		CachedTransform<Camera> cam2 = new CachedTransform<Camera>(cam);
		CachedTransform<BaseViewModel> vm2 = new CachedTransform<BaseViewModel>(vm);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].Run(ref cam2, ref vm2);
		}
		cam2.Apply();
		vm2.Apply();
	}

	protected void OnEnable()
	{
		list.Add(this);
		timeTaken = 0f;
		Setup();
	}

	protected void OnDisable()
	{
		if (!Application.isQuitting)
		{
			list.Remove(this);
		}
	}

	public void Run(ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		if (!(timeTaken > length))
		{
			if (Time.frameCount != currentFrame)
			{
				timeTaken += Time.deltaTime;
				currentFrame = Time.frameCount;
			}
			float delta = Mathf.InverseLerp(0f, length, timeTaken);
			Run(delta, ref cam, ref vm);
		}
	}

	public abstract void Setup();

	public abstract void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm);
}


using UnityEngine;
using UnityEngine.Serialization;

public class ExplosionScreenBounceFade : ScreenBounceFade
{
	[FormerlySerializedAs("explosionVolumeWeight")]
	public AnimationCurve volumeWeight;
}


using UnityEngine;

public class ScreenBounce : BaseScreenShake
{
	public AnimationCurve bounceScale;

	public AnimationCurve bounceSpeed;

	public AnimationCurve bounceViewmodel;

	private float bounceTime;

	private Vector3 bounceVelocity = Vector3.zero;

	public override void Setup()
	{
		bounceTime = Random.Range(0f, 1000f);
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		bounceTime += Time.deltaTime * bounceSpeed.Evaluate(delta);
		float num = bounceScale.Evaluate(delta) * 0.1f;
		bounceVelocity.x = Mathf.Sin(bounceTime * 20f) * num;
		bounceVelocity.y = Mathf.Cos(bounceTime * 25f) * num;
		bounceVelocity.z = 0f;
		Vector3 zero = Vector3.zero;
		zero += bounceVelocity.x * cam.right;
		zero += bounceVelocity.y * cam.up;
		if ((bool)cam)
		{
			ref Vector3 position = ref cam.position;
			position += zero;
		}
		if ((bool)vm)
		{
			ref Vector3 position2 = ref vm.position;
			position2 += zero * -1f * bounceViewmodel.Evaluate(delta);
		}
	}
}


using UnityEngine;

public class ScreenBounceFade : BaseScreenShake
{
	public AnimationCurve bounceScale;

	public AnimationCurve bounceSpeed;

	public AnimationCurve bounceViewmodel;

	public AnimationCurve distanceFalloff;

	public AnimationCurve timeFalloff;

	private float bounceTime;

	private Vector3 bounceVelocity = Vector3.zero;

	public float maxDistance = 10f;

	public float scale = 1f;

	public override void Setup()
	{
		bounceTime = Random.Range(0f, 1000f);
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(cam.position, ((Component)this).transform.position);
		float num2 = 1f - Mathf.InverseLerp(0f, maxDistance, num);
		bounceTime += Time.deltaTime * bounceSpeed.Evaluate(delta);
		float num3 = distanceFalloff.Evaluate(num2);
		float num4 = bounceScale.Evaluate(delta) * 0.1f * num3 * scale * timeFalloff.Evaluate(delta);
		bounceVelocity.x = Mathf.Sin(bounceTime * 20f) * num4;
		bounceVelocity.y = Mathf.Cos(bounceTime * 25f) * num4;
		bounceVelocity.z = 0f;
		Vector3 zero = Vector3.zero;
		zero += bounceVelocity.x * cam.right;
		zero += bounceVelocity.y * cam.up;
		zero *= num2;
		if ((bool)cam)
		{
			ref Vector3 position = ref cam.position;
			position += zero;
		}
		if ((bool)vm)
		{
			ref Vector3 position2 = ref vm.position;
			position2 += zero * -1f * bounceViewmodel.Evaluate(delta);
		}
	}
}


using UnityEngine;

public class ScreenFov : BaseScreenShake
{
	public AnimationCurve FovAdjustment;

	public override void Setup()
	{
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		if ((bool)cam)
		{
			Camera component = cam.component;
			component.fieldOfView += FovAdjustment.Evaluate(delta);
		}
	}
}


using UnityEngine;

public class ScreenRotate : BaseScreenShake
{
	public AnimationCurve Pitch;

	public AnimationCurve Yaw;

	public AnimationCurve Roll;

	public AnimationCurve ViewmodelEffect;

	public float scale = 1f;

	public bool useViewModelEffect = true;

	public override void Setup()
	{
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		zero.x = Pitch.Evaluate(delta);
		zero.y = Yaw.Evaluate(delta);
		zero.z = Roll.Evaluate(delta);
		if ((bool)cam)
		{
			ref Quaternion rotation = ref cam.rotation;
			rotation *= Quaternion.Euler(zero * scale);
		}
		if ((bool)vm && useViewModelEffect)
		{
			ref Quaternion rotation2 = ref vm.rotation;
			rotation2 *= Quaternion.Euler(zero * scale * -1f * (1f - ViewmodelEffect.Evaluate(delta)));
		}
	}
}


using UnityEngine;

public class Shaker : MonoBehaviour
{
	public float Frequency = 0.1f;

	public Vector3 PositionMagnitude;

	public Vector3 RotationMagnitude;

	public float GlobalMultiplier = 1f;
}


using System;
using UnityEngine;

public class SwapAmmoParticle : MonoBehaviour, IClientComponent, IEffect
{
	[Serializable]
	public struct Override
	{
		public ItemDefinition TargetAmmo;

		public Material TargetMaterial;
	}

	public ParticleSystem Target;

	public Override[] Overrides;
}


using System;
using UnityEngine;

[Serializable]
public struct Override
{
	public ItemDefinition TargetAmmo;

	public Material TargetMaterial;
}


using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

public class TransformLineRenderer : MonoBehaviour, IClientComponent
{
	internal struct LineRendererUpdateJob : IJobParallelForTransform
	{
		[NativeMatchesParallelForLength]
		[WriteOnly]
		public NativeArray<Vector3> ResultWorldPositions;

		public void Execute(int index, [ReadOnly] TransformAccess transform)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			ResultWorldPositions[index] = ((TransformAccess)(ref transform)).position;
		}
	}

	public Transform[] TransformSequence;

	public LineRenderer TargetRenderer;

	public bool IsEnabled = true;

	[Tooltip("Will keep the line renderer enabled when IsEnabled is false, allowing you to freeze the update while keeping the visuals.")]
	public bool KeepLastUpdate;
}


using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

internal struct LineRendererUpdateJob : IJobParallelForTransform
{
	[NativeMatchesParallelForLength]
	[WriteOnly]
	public NativeArray<Vector3> ResultWorldPositions;

	public void Execute(int index, [ReadOnly] TransformAccess transform)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		ResultWorldPositions[index] = ((TransformAccess)(ref transform)).position;
	}
}


using UnityEngine;

public class EmissionOffsetStepped : MonoBehaviour, IClientComponent
{
	public Material material;

	public float offsetAmount = 0.1f;

	public float minInterval = 0.5f;

	public float maxInterval = 2f;
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch.Rust.Profiling;
using Network;
using Oxide.Core;
using UnityEngine;

public static class ConsoleNetwork
{
	private static Stopwatch timer = new Stopwatch();

	internal static void Init()
	{
	}

	internal static void OnClientCommand(Message packet)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		if (packet.read.Unread > Server.maxpacketsize_command)
		{
			Debug.LogWarning((object)"Dropping client command due to size");
			return;
		}
		timer.Restart();
		string text = packet.read.StringRaw(8388608, false);
		if (packet.connection == null || !packet.connection.connected)
		{
			Debug.LogWarning((object)("Client without connection tried to run command: " + text));
		}
		else if (Interface.CallHook("OnClientCommand", (object)packet.connection, (object)text) == null)
		{
			Option val = Option.Server;
			val = ((Option)(ref val)).FromConnection(packet.connection);
			string text2 = ConsoleSystem.Run(((Option)(ref val)).Quiet(), text, Array.Empty<object>());
			if (!string.IsNullOrEmpty(text2))
			{
				SendClientReply(packet.connection, text2);
			}
			if (timer.Elapsed > RuntimeProfiler.ConsoleCommandWarningThreshold)
			{
				LagSpikeProfiler.ConsoleCommand(timer.Elapsed, packet, text);
			}
		}
	}

	internal static void SendClientReply(Connection cn, string strCommand)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)11);
			obj.String(strCommand, false);
			obj.Send(new SendInfo(cn));
		}
	}

	public static void SendClientCommand(Connection cn, string strCommand, params object[] args)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && Interface.CallHook("OnSendCommand", (object)cn, (object)strCommand, (object)args) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			string text = ConsoleSystem.BuildCommand(strCommand, args);
			obj.String(text, false);
			obj.Send(new SendInfo(cn));
		}
	}

	public static void SendClientCommandImmediate(Connection cn, string strCommand, params object[] args)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			string text = ConsoleSystem.BuildCommand(strCommand, args);
			obj.String(text, false);
			SendInfo val = default(SendInfo);
			((SendInfo)(ref val))..ctor(cn);
			val.priority = (Priority)0;
			obj.SendImmediate(val);
		}
	}

	public static void SendClientCommand(List<Connection> cn, string strCommand, params object[] args)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && Interface.CallHook("OnSendCommand", (object)cn, (object)strCommand, (object)args) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			obj.String(ConsoleSystem.BuildCommand(strCommand, args), false);
			obj.Send(new SendInfo(cn));
		}
	}

	public static void BroadcastToAllClients(string strCommand, params object[] args)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && Interface.CallHook("OnBroadcastCommand", (object)strCommand, (object)args) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			obj.String(ConsoleSystem.BuildCommand(strCommand, args), false);
			obj.Send(new SendInfo(Net.sv.connections));
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch.Models;
using Newtonsoft.Json.Linq;
using UnityEngine;

public class CpuAffinity
{
	private static bool _appliedAutoCpuAffinity;

	public static void Apply()
	{
	}

	private static void ApplyImpl(Manifest manifest)
	{
		try
		{
			string cpuModel = SystemInfo.processorType;
			(string, int, int) tuple = ReadManifestCoreRanges(manifest).FirstOrDefault(((string Cpu, int Min, int Max) r) => cpuModel.Contains(r.Cpu, StringComparison.OrdinalIgnoreCase));
			if (tuple.Item2 >= 0 && tuple.Item3 > tuple.Item2)
			{
				ulong num = 0uL;
				for (int i = tuple.Item2; i <= tuple.Item3; i++)
				{
					num |= (ulong)(1L << i);
				}
				if (SystemCommands.SetCpuAffinity(num))
				{
					Debug.Log((object)$"Automatically set CPU affinity to cores {tuple.Item2}-{tuple.Item3} ({tuple.Item1})");
				}
			}
		}
		catch (Exception arg)
		{
			Debug.LogWarning((object)$"Failed to auto set CPU affinity: {arg}");
		}
	}

	private static List<(string Cpu, int Min, int Max)> ReadManifestCoreRanges(Manifest manifest)
	{
		List<(string, int, int)> list = new List<(string, int, int)>();
		JObject obj = manifest?.Metadata;
		JToken obj2 = ((obj != null) ? obj["PreferredCoreRanges"] : null);
		JArray val = (JArray)(object)((obj2 is JArray) ? obj2 : null);
		if (val == null || ((JContainer)val).Count <= 0)
		{
			return list;
		}
		foreach (JToken item in val)
		{
			JObject val2 = (JObject)(object)((item is JObject) ? item : null);
			if (val2 != null)
			{
				JToken obj3 = val2["Cpu"];
				string text = ((obj3 != null) ? Extensions.Value<string>((IEnumerable<JToken>)obj3) : null);
				JToken obj4 = val2["Min"];
				int? num = ((obj4 != null) ? new int?(Extensions.Value<int>((IEnumerable<JToken>)obj4)) : ((int?)null));
				JToken obj5 = val2["Max"];
				int? num2 = ((obj5 != null) ? new int?(Extensions.Value<int>((IEnumerable<JToken>)obj5)) : ((int?)null));
				if (text != null && num.HasValue && num2.HasValue)
				{
					list.Add((text, num.Value, num2.Value));
				}
			}
		}
		return list;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Facepunch;
using Facepunch.Utility;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class VDDraw : SingletonComponent<VDDraw>, IServerComponent
{
	private const int maxLogFiles = 10;

	private const string prefix = "VDDraw";

	private const string extension = "vddraw";

	private const string compressionExtension = "gz";

	private const float defaultEntryDuration = 0.2f;

	private const float saveIntervalSeconds = 60f;

	private ConcurrentQueue<VDDrawEntry> logEntries = new ConcurrentQueue<VDDrawEntry>();

	private bool _isRecording;

	private string currentLogPath;

	public static bool isRecording => SingletonComponent<VDDraw>.Instance._isRecording;

	private static string logDirectoryPath => Path.Combine(Application.persistentDataPath, "Logs");

	[ServerVar]
	public static void SetIsRecording(Arg arg)
	{
		bool flag = (arg.HasArgs(1) ? arg.GetBool(0, false) : (!SingletonComponent<VDDraw>.Instance._isRecording));
		if (SingletonComponent<VDDraw>.Instance._isRecording == flag)
		{
			if (SingletonComponent<VDDraw>.Instance._isRecording)
			{
				arg.ReplyWith("Already recording");
			}
			else
			{
				arg.ReplyWith("Not recording");
			}
		}
		else if (flag)
		{
			SingletonComponent<VDDraw>.Instance.StartRecording();
			arg.ReplyWith("Recording started");
		}
		else
		{
			SingletonComponent<VDDraw>.Instance.StopRecording();
			arg.ReplyWith("Recording stopped");
		}
	}

	private void StartRecording()
	{
		if (!_isRecording)
		{
			_isRecording = true;
			if (!Directory.Exists(logDirectoryPath))
			{
				Directory.CreateDirectory(logDirectoryPath);
			}
			ManageLogFiles();
			currentLogPath = GetNewLogFilePath();
			((FacepunchBehaviour)this).InvokeRepeating((Action)SaveLogs, 0f, 60f);
			Application.quitting += StopRecording;
		}
	}

	private void StopRecording()
	{
		if (_isRecording)
		{
			_isRecording = false;
			((FacepunchBehaviour)this).CancelInvoke((Action)SaveLogs);
			SaveLogs();
			CompressCurrentLog();
			currentLogPath = null;
			Application.quitting -= StopRecording;
		}
	}

	public static void Log(BaseEntity entity, bool display, string label, string message)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)1;
			val.message = message;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	public static void Line(BaseEntity entity, bool display, string label, Vector3 start, Vector3 end, Color color, float duration = 0f)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)0;
			val.start = start;
			val.end = end;
			val.color = color;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	public static void Text(BaseEntity entity, bool display, string label, string message, Vector3 position, Color color, float duration = 0f, float scaleMulti = 1f, bool alsoLog = false)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid())
		{
			if (SingletonComponent<VDDraw>.Instance._isRecording)
			{
				VDDrawEntry val = Pool.Get<VDDrawEntry>();
				val.entityName = GetEntityReadableName(entity);
				val.label = label;
				val.frame = Time.frameCount;
				val.category = (Category)2;
				val.start = position;
				val.message = message;
				val.color = color;
				SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
			}
			if (alsoLog)
			{
				Log(entity, display, label, message);
			}
		}
	}

	public static void Sphere(BaseEntity entity, bool display, string label, Vector3 position, float size, Color color, float duration = 0f)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)3;
			val.start = position;
			val.sizeX = size;
			val.color = color;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	public static void Box(BaseEntity entity, bool display, string label, Vector3 center, Quaternion rotation, Vector3 size, Color color, float duration = 0f)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)4;
			val.start = center;
			val.end = rotation * Vector3.forward;
			val.sizeX = size.x;
			val.sizeY = size.y;
			val.sizeZ = size.z;
			val.color = color;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	private static string GetNewLogFilePath()
	{
		string text = DateTime.Now.ToString("yyyyMMdd_HHmmss");
		return Path.Combine(logDirectoryPath, "VDDraw_" + text + ".vddraw");
	}

	public static string GetLastLogFilePath()
	{
		List<FileInfo> list = (from f in new DirectoryInfo(logDirectoryPath).GetFiles("VDDraw_*")
			orderby f.CreationTime
			select f).ToList();
		if (list.Count == 0)
		{
			return null;
		}
		return list.Last().FullName;
	}

	private void CompressCurrentLog()
	{
		TimeWarning val = TimeWarning.New("VDDraw:CompressCurrentLog", 0);
		try
		{
			string lastLogFilePath = GetLastLogFilePath();
			byte[] data = File.ReadAllBytes(lastLogFilePath);
			File.WriteAllBytes(bytes: Compression.Compress(data), path: lastLogFilePath + ".gz");
			File.Delete(lastLogFilePath);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SaveLogs()
	{
		TimeWarning val = TimeWarning.New("VDDraw:SaveLogs", 0);
		try
		{
			using FileStream fileStream = new FileStream(currentLogPath, FileMode.Append, FileAccess.Write, FileShare.None, 4096, useAsync: true);
			VDDrawEntry result;
			while (logEntries.TryDequeue(out result))
			{
				ProtoStreamExtensions.WriteToStream((IProto)(object)result, (Stream)fileStream, true, 2097152);
				Pool.Free<VDDrawEntry>(ref result);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void ManageLogFiles()
	{
		List<FileInfo> list = (from f in new DirectoryInfo(logDirectoryPath).GetFiles("VDDraw_*")
			orderby f.CreationTime
			select f).ToList();
		if (list.Count > 10)
		{
			int num = list.Count - 10;
			for (int i = 0; i < num; i++)
			{
				Debug.Log((object)("Deleting log file: " + list[i].FullName));
				list[i].Delete();
			}
		}
	}

	public static string GetEntityReadableName(BaseEntity entity)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		string name = ((object)entity).GetType().Name;
		NetworkableId iD = entity.net.ID;
		return name + "_" + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Threading;
using UnityEngine;

public class FileSystem_Warmup : MonoBehaviour
{
	private static List<(string, TimeSpan)> warmupTimes = new List<(string, TimeSpan)>();

	private static bool run = true;

	private static string[] ExcludeFilter = new string[13]
	{
		"/bundled/prefabs/autospawn/monument", "/bundled/prefabs/autospawn/mountain", "/bundled/prefabs/autospawn/canyon", "/bundled/prefabs/autospawn/decor", "/bundled/prefabs/autospawn/tunnel", "/bundled/prefabs/remapped", "/bundled/prefabs/navmesh", "/content/ui/", "/prefabs/ui/", "/prefabs/world/",
		"/prefabs/system/", "/standard assets/", "/third party/"
	};

	private static Stopwatch warmupTimer = new Stopwatch();

	public static IEnumerable<(string, TimeSpan)> GetWarmupTimes()
	{
		return warmupTimes;
	}

	public static void Run()
	{
		if (!run)
		{
			return;
		}
		FileSystemBackend backend = FileSystem.Backend;
		AssetBundleBackend val = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
		if (val != null && val.GetAssetSceneProgress() < 1f)
		{
			Debug.LogError((object)"Cannot run synchronous asset warmup until all asset scenes are finished loading");
			return;
		}
		List<string> assetList = GetAssetList();
		for (int i = 0; i < assetList.Count; i++)
		{
			PrefabWarmup(assetList[i]);
		}
		run = false;
	}

	public static IEnumerator Run(Action<string> statusFunction, string format = null, CancellationToken ct = default(CancellationToken))
	{
		if (!run)
		{
			yield break;
		}
		FileSystemBackend backend = FileSystem.Backend;
		AssetBundleBackend assetBundleBackend = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
		if (assetBundleBackend != null)
		{
			float lastProgress = 0f;
			while (!ct.IsCancellationRequested)
			{
				float assetSceneProgress = assetBundleBackend.GetAssetSceneProgress();
				if (assetSceneProgress >= 1f)
				{
					break;
				}
				if (!Mathf.Approximately(assetSceneProgress, lastProgress))
				{
					lastProgress = assetSceneProgress;
					statusFunction?.Invoke($"Loading Game Prefabs {assetSceneProgress * 100f:0.0}%");
				}
				yield return null;
			}
		}
		Timing timer = new Timing("asset_warmup");
		List<string> assetList = GetAssetList();
		yield return RunForAssets(assetList, statusFunction, format, ct);
		timer.End();
		run = false;
	}

	public static IEnumerator RunForAssets(List<string> assetList, Action<string> statusFunction, string format = null, CancellationToken ct = default(CancellationToken))
	{
		if (assetList.Count == 0)
		{
			yield break;
		}
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < assetList.Count; i++)
		{
			if (ct.IsCancellationRequested)
			{
				break;
			}
			if (sw.Elapsed.TotalSeconds > (double)CalculateFrameBudget() || i == 0 || i == assetList.Count - 1)
			{
				statusFunction?.Invoke(string.Format((format != null) ? format : "{0}/{1}", i + 1, assetList.Count));
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Restart();
			}
			PrefabWarmup(assetList[i]);
		}
	}

	private static float CalculateFrameBudget()
	{
		return 2f;
	}

	private static bool ShouldIgnore(string path)
	{
		for (int i = 0; i < ExcludeFilter.Length; i++)
		{
			if (StringEx.Contains(path, ExcludeFilter[i], CompareOptions.OrdinalIgnoreCase))
			{
				return true;
			}
		}
		return false;
	}

	private static List<string> GetAssetList()
	{
		FileSystemBackend backend = FileSystem.Backend;
		AssetBundleBackend val = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
		if (val == null)
		{
			return new List<string>();
		}
		return (from t in val.GetAssetScenePrefabs(AssetSceneManifest.Current.AutoLoadScenes)
			where !ShouldIgnore(t.Path)
			select t.Path).ToList();
	}

	private static void PrefabWarmup(string path)
	{
		warmupTimer.Restart();
		GameManager.server.FindPrefab(path);
		warmupTimer.Stop();
		warmupTimes.Add(ValueTuple.Create(path, warmupTimer.Elapsed));
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch.Extend;
using Facepunch.Utility;
using Ionic.Zlib;
using UnityEngine;

public static class ProfileExporter
{
	private struct MainThreadInfo
	{
		public List<uint> SyncIndices;

		public List<uint> FrameStarts;

		public uint Frames;
	}

	public static class JSON
	{
		private struct ThreadMetadata
		{
			internal int ThreadId;

			internal int AllocationThreadId;

			internal void Emit(StringStream builder)
			{
				bool isMainThread = ThreadId == ServerProfiler.GetMainThreadId();
				EmitThreadName(isMainThread, isAllocThread: false, ThreadId, ThreadId, builder);
				builder.Append(',');
				EmitThreadName(isMainThread, isAllocThread: true, AllocationThreadId, ThreadId, builder);
			}

			private static void EmitThreadName(bool isMainThread, bool isAllocThread, int id, int origId, StringStream builder)
			{
				builder.Append("{\"name\":\"thread_name\",\"ph\":\"M\",\"pid\":0,\"tid\":");
				builder.Append(id);
				builder.Append(",\"args\":{\"name\":\"");
				if (isMainThread)
				{
					builder.Append("Main Thread");
				}
				else
				{
					builder.Append("Thread");
				}
				if (isAllocThread)
				{
					if (!isMainThread)
					{
						builder.Append(' ');
						builder.Append(origId);
					}
					builder.Append(" Allocations");
				}
				builder.Append("\"}}");
			}
		}

		public class StringStream : MemoryStream
		{
			private GZipStream outputStream;

			public StringStream(int capacity, GZipStream outputStream)
				: base(capacity)
			{
				this.outputStream = outputStream;
			}

			public override void Write(byte[] buffer, int offset, int count)
			{
				if (base.Position + count < base.Capacity)
				{
					base.Write(buffer, offset, count);
					return;
				}
				int num = base.Capacity - (int)base.Position;
				if (num > 0)
				{
					base.Write(buffer, offset, num);
				}
				Flush();
				if (count - num > 0)
				{
					base.Write(buffer, offset + num, count - num);
				}
			}

			public override void Write(ReadOnlySpan<byte> source)
			{
				throw new NotSupportedException("Write(ReadOnlySpan<byte>) not implemented!");
			}

			public override void WriteByte(byte value)
			{
				if (base.Position + 1 < base.Capacity)
				{
					base.WriteByte(value);
					return;
				}
				Flush();
				base.WriteByte(value);
			}

			public void Append(char c)
			{
				WriteByte((byte)c);
			}

			public void Append(string text)
			{
				foreach (char c in text)
				{
					Append(c);
				}
			}

			public void Append(int num)
			{
				Span<char> destination = stackalloc char[32];
				num.TryFormat(destination, out var charsWritten);
				Append(destination.Slice(0, charsWritten));
			}

			public void Append(long num)
			{
				Span<char> destination = stackalloc char[32];
				num.TryFormat(destination, out var charsWritten);
				Append(destination.Slice(0, charsWritten));
			}

			public void Append(ulong num)
			{
				Span<char> destination = stackalloc char[32];
				num.TryFormat(destination, out var charsWritten);
				Append(destination.Slice(0, charsWritten));
			}

			public void Append(ReadOnlySpan<char> chars)
			{
				ReadOnlySpan<char> readOnlySpan = chars;
				for (int i = 0; i < readOnlySpan.Length; i++)
				{
					char c = readOnlySpan[i];
					Append(c);
				}
			}

			public override void Flush()
			{
				long position = Position;
				if (position > 0)
				{
					byte[] buffer = GetBuffer();
					((Stream)(object)outputStream).Write(buffer, 0, (int)position);
					Position = 0L;
				}
			}
		}

		public static bool Export(string filename, IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
		{
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Expected O, but got Unknown
			try
			{
				Debug.Log((object)"Starting JSON snapshot generation...");
				Preprocess(profiles, out var mainInfo, out var _);
				string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
				if (!Directory.Exists(text))
				{
					Directory.CreateDirectory(text);
				}
				using (FileStream fileStream = new FileStream(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".json.gz")), FileMode.Create, FileAccess.Write, FileShare.None, 20480))
				{
					GZipStream val = new GZipStream((Stream)fileStream, (CompressionMode)0);
					try
					{
						val.FlushMode = (FlushType)2;
						using StringStream stringStream = new StringStream(16384, val);
						stringStream.Append('[');
						int num = 0;
						foreach (ServerProfiler.Profile profile2 in profiles)
						{
							num = Math.Max(num, profile2.ThreadId);
						}
						List<ThreadMetadata> list = new List<ThreadMetadata>();
						for (int i = 0; i < profiles.Count; i++)
						{
							ServerProfiler.Profile profile = profiles[i];
							ThreadMetadata item = default(ThreadMetadata);
							item.ThreadId = profile.ThreadId;
							num = (item.AllocationThreadId = num + 1);
							if (i != 0)
							{
								stringStream.Append(',');
							}
							item.Emit(stringStream);
							list.Add(item);
						}
						long firstMarkTimestamp = 0L;
						for (int j = 0; j < profiles.Count; j++)
						{
							ServerProfiler.Profile mainProfile = profiles[j];
							if (mainProfile.ThreadId == ServerProfiler.GetMainThreadId())
							{
								if (ProcessMainProfile(in mainProfile, in mainInfo, list[j], stringStream, out firstMarkTimestamp))
								{
									break;
								}
								return false;
							}
						}
						for (int k = 0; k < profiles.Count; k++)
						{
							ServerProfiler.Profile workerProfile = profiles[k];
							if (workerProfile.ThreadId != ServerProfiler.GetMainThreadId() && !ProcessWorkerProfile(in workerProfile, list[k], firstMarkTimestamp, stringStream))
							{
								return false;
							}
						}
						ProcessMemoryState(in memState, firstMarkTimestamp, stringStream);
						stringStream.Append("]");
						stringStream.Flush();
						Debug.Log((object)"Generation done, flushing...");
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
				}
				Debug.Log((object)"Snapshot json export done!");
				return true;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				return false;
			}
		}

		private unsafe static bool ProcessMainProfile(in ServerProfiler.Profile mainProfile, in MainThreadInfo info, in ThreadMetadata metadata, StringStream builder, out long firstMarkTimestamp)
		{
			if (info.FrameStarts == null || info.Frames == 0)
			{
				Debug.LogError((object)"ServerProfiler: Didn't find any main frame info!");
				firstMarkTimestamp = 0L;
				return false;
			}
			int num = 0;
			byte* data = mainProfile.Data;
			uint num2 = info.FrameStarts[0];
			firstMarkTimestamp = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num2).Timestamp;
			long num3 = 0L;
			for (int i = 0; i < info.Frames; i++)
			{
				uint num4 = info.FrameStarts[i];
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num4);
				uint num5 = mainProfile.WriteEnd;
				if (i < info.Frames - 1)
				{
					num5 = info.FrameStarts[i + 1];
				}
				ServerProfiler.Mark mark2 = default(ServerProfiler.Mark);
				mark2.Event = ServerProfiler.Mark.Type.Enter;
				mark2.Timestamp = mark.Timestamp;
				AddMark(mark2, $"UnityFrame{i}", mainProfile.ThreadId, firstMarkTimestamp, builder);
				uint totalMem = 0u;
				long offset = ServerProfiler.TimestampToMicros(mark.Timestamp - firstMarkTimestamp);
				EmitCounter("Main Thread", offset, "Total(B)", totalMem, builder);
				uint readInd = num4;
				while (readInd < num5)
				{
					ServerProfiler.Mark mark3 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + readInd);
					num3 = mark3.Timestamp;
					num += AdjustCallstackDepth(in mark3);
					if (num < 0)
					{
						Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {num}, offset: {readInd}, frame: {i}");
						return false;
					}
					AddMark(in mainProfile, in metadata, readInd, ref totalMem, firstMarkTimestamp, builder);
					if (!AdvanceReadInd(in mark3, data, ref readInd))
					{
						return false;
					}
				}
				long timestamp = ((i < info.Frames - 1) ? Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num5).Timestamp : num3);
				mark2 = default(ServerProfiler.Mark);
				mark2.Event = ServerProfiler.Mark.Type.Exit;
				mark2.Timestamp = timestamp;
				AddMark(mark2, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
			}
			while (num > 0)
			{
				ServerProfiler.Mark mark4 = default(ServerProfiler.Mark);
				mark4.Event = ServerProfiler.Mark.Type.Exit;
				mark4.Timestamp = num3;
				AddMark(mark4, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
				num--;
			}
			return true;
		}

		private unsafe static bool ProcessWorkerProfile(in ServerProfiler.Profile workerProfile, in ThreadMetadata metadata, long firstMarkTimestamp, StringStream builder)
		{
			uint readInd = 0u;
			int num = 0;
			while (readInd < workerProfile.WriteEnd)
			{
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd);
				if (mark.Timestamp >= firstMarkTimestamp)
				{
					break;
				}
				if (mark.Event == ServerProfiler.Mark.Type.Sync)
				{
					Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
					return false;
				}
				num += AdjustCallstackDepth(in mark);
				if (!AdvanceReadInd(in mark, workerProfile.Data, ref readInd))
				{
					return false;
				}
			}
			if (readInd >= workerProfile.WriteEnd)
			{
				return true;
			}
			bool flag = false;
			uint readInd2 = readInd;
			while (readInd2 < workerProfile.WriteEnd)
			{
				ServerProfiler.Mark mark2 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd2);
				if (mark2.Event == ServerProfiler.Mark.Type.Sync)
				{
					Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
					return false;
				}
				if (mark2.Event != ServerProfiler.Mark.Type.Alloc)
				{
					flag = true;
					break;
				}
				if (!AdvanceReadInd(in mark2, workerProfile.Data, ref readInd2))
				{
					return false;
				}
			}
			if (!flag)
			{
				return true;
			}
			if (!FindStartingDepth(in workerProfile, 0u, workerProfile.WriteEnd, out var minDepth))
			{
				return false;
			}
			minDepth = num - minDepth;
			for (int num2 = minDepth; num2 > 0; num2--)
			{
				ServerProfiler.Mark mark3 = default(ServerProfiler.Mark);
				mark3.Event = ServerProfiler.Mark.Type.Enter;
				mark3.Timestamp = firstMarkTimestamp;
				AddMark(mark3, "Unknown", workerProfile.ThreadId, firstMarkTimestamp, builder);
			}
			uint totalMem = 0u;
			long timestamp = 0L;
			uint readInd3 = readInd;
			while (readInd3 < workerProfile.WriteEnd)
			{
				ServerProfiler.Mark mark4 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd3);
				timestamp = mark4.Timestamp;
				minDepth += AdjustCallstackDepth(in mark4);
				if (minDepth < 0)
				{
					Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {minDepth}, offset: {readInd3}, thread: {workerProfile.ThreadId}");
					return false;
				}
				if (mark4.Event == ServerProfiler.Mark.Type.Alloc || (mark4.Event == ServerProfiler.Mark.Type.AllocWithStack && totalMem == 0))
				{
					EmitCounter("Thread", metadata.ThreadId, 0L, "Total(B)", 0uL, builder);
				}
				AddMark(in workerProfile, in metadata, readInd3, ref totalMem, firstMarkTimestamp, builder);
				if (!AdvanceReadInd(in mark4, workerProfile.Data, ref readInd3))
				{
					return false;
				}
			}
			while (minDepth > 0)
			{
				ServerProfiler.Mark mark5 = default(ServerProfiler.Mark);
				mark5.Event = ServerProfiler.Mark.Type.Exit;
				mark5.Timestamp = timestamp;
				AddMark(mark5, null, workerProfile.ThreadId, firstMarkTimestamp, builder);
				minDepth--;
			}
			return true;
		}

		private unsafe static void ProcessMemoryState(in ServerProfiler.MemoryState memState, long firstMarkTimestamp, StringStream builder)
		{
			ulong num = 0uL;
			ulong num2 = 0uL;
			for (uint num3 = 0u; num3 < memState.Created; num3++)
			{
				ServerProfiler.MemoryReading memoryReading = memState.Readings[num3];
				long timestamp = memoryReading.Timestamp;
				if (timestamp >= firstMarkTimestamp)
				{
					ulong num4 = memoryReading.WorkingSet / 1024;
					if (num4 != num)
					{
						long offset = ((num == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
						EmitCounter("ws", offset, "WorkingSet(KB)", num4, builder);
						num = num4;
					}
					ulong num5 = memoryReading.VirtualSet / 1024;
					if (num5 != num2)
					{
						long offset2 = ((num2 == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
						EmitCounter("vs", offset2, "VirtualSet(KB)", num5, builder);
						num2 = num5;
					}
				}
			}
		}

		private unsafe static void AddMark(in ServerProfiler.Profile threadProfile, in ThreadMetadata metadata, uint markInd, ref uint totalMem, long startTimestamp, StringStream builder)
		{
			byte* ptr = threadProfile.Data + markInd;
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
			ptr += sizeof(ServerProfiler.Mark);
			switch (mark.Event)
			{
			case ServerProfiler.Mark.Type.Enter:
				builder.Append(",{\"name\":\"");
				ServerProfiler.AppendNameTo(*(ServerProfiler.Native.MonoMethod**)ptr, builder);
				builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append("}");
				break;
			case ServerProfiler.Mark.Type.Exit:
			case ServerProfiler.Mark.Type.Exception:
			case ServerProfiler.Mark.Type.GCEnd:
				builder.Append(",{\"ph\":\"E\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append("}");
				break;
			case ServerProfiler.Mark.Type.Alloc:
			{
				ServerProfiler.Alloc alloc2 = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
				long num2 = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
				builder.Append(",{\"name\":\"");
				builder.Append("Alloc ");
				builder.Append(alloc2.AlignedSize);
				builder.Append("b\",\"ph\":\"i\",\"ts\":");
				builder.Append(num2);
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
				builder.Append(alloc2.AlignedSize);
				builder.Append(",\"type\":\"");
				ServerProfiler.AppendNameTo(alloc2, builder);
				builder.Append("\",\"lastMethod\":\"");
				if (alloc2.LastMethod != null)
				{
					ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
				}
				else
				{
					builder.Append("<mono-native-runtime>");
				}
				builder.Append("\"}}");
				builder.Append(",{\"name\":\"");
				builder.Append("Alloc ");
				builder.Append(alloc2.AlignedSize);
				builder.Append("b\",\"ph\":\"i\",\"ts\":");
				builder.Append(num2);
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(metadata.AllocationThreadId);
				builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
				builder.Append(alloc2.AlignedSize);
				builder.Append(",\"type\":\"");
				ServerProfiler.AppendNameTo(alloc2, builder);
				builder.Append("\",\"lastMethod\":\"");
				if (alloc2.LastMethod != null)
				{
					ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
				}
				else
				{
					builder.Append("<mono-native-runtime>");
				}
				builder.Append("\"}}");
				totalMem += alloc2.AlignedSize;
				if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
				{
					EmitCounter("Main Thread", num2, "Total(B)", totalMem, builder);
				}
				else
				{
					EmitCounter("Thread", metadata.ThreadId, num2, "Total(B)", totalMem, builder);
				}
				break;
			}
			case ServerProfiler.Mark.Type.AllocWithStack:
			{
				ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
				ptr += sizeof(ServerProfiler.Alloc);
				long num = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
				builder.Append(",{\"name\":\"");
				builder.Append("Alloc ");
				builder.Append(alloc.AlignedSize);
				builder.Append("b\",\"ph\":\"i\",\"ts\":");
				builder.Append(num);
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(metadata.ThreadId);
				builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
				builder.Append(alloc.AlignedSize);
				builder.Append(",\"type\":\"");
				ServerProfiler.AppendNameTo(alloc, builder);
				builder.Append("\",\"lastMethod\":\"");
				if (alloc.LastMethod != null)
				{
					ServerProfiler.AppendNameTo(alloc.LastMethod, builder);
				}
				else
				{
					builder.Append("<mono-native-runtime>");
				}
				builder.Append('"');
				byte b = *ptr;
				ptr++;
				if (b > 0)
				{
					builder.Append(",\"callstack\":{");
					ServerProfiler.Native.MonoMethod** ptr2 = (ServerProfiler.Native.MonoMethod**)ptr;
					for (byte b2 = 0; b2 < b; b2++)
					{
						ServerProfiler.Native.MonoMethod* method = ptr2[(int)b2];
						builder.Append('"');
						char c = (char)(b2 + 32);
						if (c >= '"')
						{
							c = (char)(c + 1);
						}
						if (c >= '.')
						{
							c = (char)(c + 1);
						}
						if (c >= '\\')
						{
							c = (char)(c + 1);
						}
						if (c < '\u007f')
						{
							builder.Append(c);
						}
						else
						{
							builder.Append(b2);
						}
						builder.Append("\":\"");
						ServerProfiler.AppendNameTo(method, builder);
						builder.Append('"');
						if (b2 != b - 1)
						{
							builder.Append(',');
						}
					}
					builder.Append('}');
				}
				builder.Append("}}");
				totalMem += alloc.AlignedSize;
				if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
				{
					EmitCounter("Main Thread", num, "Total(B)", totalMem, builder);
				}
				else
				{
					EmitCounter("Thread", metadata.ThreadId, num, "Total(B)", totalMem, builder);
				}
				break;
			}
			case ServerProfiler.Mark.Type.GCBegin:
				builder.Append(",{\"name\":\"");
				builder.Append("GC.Collect");
				builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append("}");
				break;
			}
		}

		private static void AddMark(ServerProfiler.Mark mark, string name, int threadId, long startTimestamp, StringStream builder)
		{
			switch (mark.Event)
			{
			case ServerProfiler.Mark.Type.Enter:
				builder.Append(",{\"name\":\"");
				builder.Append(name);
				builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadId);
				builder.Append("}");
				break;
			case ServerProfiler.Mark.Type.Exit:
			case ServerProfiler.Mark.Type.Exception:
				builder.Append(",{\"ph\":\"E\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadId);
				builder.Append("}");
				break;
			}
		}

		private static void EmitCounter(string markName, long offset, string counterName, ulong value, StringStream builder)
		{
			builder.Append(",{\"name\":\"");
			builder.Append(markName);
			builder.Append("\",\"ph\":\"C\",\"ts\":");
			builder.Append(offset);
			builder.Append(",\"args\":{\"");
			builder.Append(counterName);
			builder.Append("\":");
			builder.Append(value);
			builder.Append("}}");
		}

		private static void EmitCounter(string markName, int threadId, long offset, string counterName, ulong value, StringStream builder)
		{
			builder.Append(",{\"name\":\"");
			builder.Append(markName);
			builder.Append(" ");
			builder.Append(threadId);
			builder.Append("\",\"ph\":\"C\",\"ts\":");
			builder.Append(offset);
			builder.Append(",\"args\":{\"");
			builder.Append(counterName);
			builder.Append("\":");
			builder.Append(value);
			builder.Append("}}");
		}

		private unsafe static bool FindStartingDepth(in ServerProfiler.Profile threadProfile, uint start, uint end, out int minDepth)
		{
			int num = 0;
			minDepth = 0;
			uint readInd = start;
			while (readInd < end)
			{
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(threadProfile.Data + readInd);
				num += AdjustCallstackDepth(in mark);
				if (mark.Event == ServerProfiler.Mark.Type.Exit || mark.Event == ServerProfiler.Mark.Type.Exception)
				{
					minDepth = Math.Min(num, minDepth);
				}
				if (!AdvanceReadInd(in mark, threadProfile.Data, ref readInd))
				{
					return false;
				}
			}
			return true;
		}

		private static int AdjustCallstackDepth(in ServerProfiler.Mark mark)
		{
			switch (mark.Event)
			{
			case ServerProfiler.Mark.Type.Enter:
				return 1;
			case ServerProfiler.Mark.Type.Exit:
			case ServerProfiler.Mark.Type.Exception:
				return -1;
			default:
				return 0;
			}
		}
	}

	public static class Binary
	{
		private enum Section : byte
		{
			Info,
			Thread,
			Marks
		}

		private struct SectionBlock : IDisposable
		{
			private MemoryStream stream;

			private long startPos;

			public static SectionBlock New(Section section, MemoryStream stream)
			{
				SectionBlock result = default(SectionBlock);
				result.stream = stream;
				result.startPos = stream.Position;
				result.Begin(section);
				return result;
			}

			private void Begin(Section section)
			{
				Write(4276993775u);
				Write((byte)section);
				Write(ulong.MaxValue);
			}

			private void End()
			{
				long num = startPos + 5;
				long num2 = stream.Position - num - 8;
				byte[] buffer = stream.GetBuffer();
				for (byte b = 0; b < 8; b++)
				{
					buffer[num + b] = (byte)(num2 >> 56 - b * 8);
				}
				Write(3735928559u);
			}

			public void Write(string text)
			{
				Write((ushort)text.Length);
				for (int i = 0; i < text.Length; i++)
				{
					stream.WriteByte((byte)text[i]);
				}
			}

			public void Write(ulong value)
			{
				for (byte b = 0; b < 8; b++)
				{
					stream.WriteByte((byte)(value >> 56 - b * 8));
				}
			}

			public void Write(uint value)
			{
				for (byte b = 0; b < 4; b++)
				{
					stream.WriteByte((byte)(value >> 24 - b * 8));
				}
			}

			public void Write(ushort value)
			{
				stream.WriteByte((byte)(value >> 8));
				stream.WriteByte((byte)value);
			}

			public void Write(byte value)
			{
				stream.WriteByte(value);
			}

			void IDisposable.Dispose()
			{
				End();
			}
		}

		public unsafe static void Export(string filename, IList<ServerProfiler.Profile> profiles)
		{
			Debug.Log((object)"Starting BIN snapshot generation...");
			MemoryStream memoryStream = new MemoryStream(134217728);
			using (SectionBlock sectionBlock = SectionBlock.New(Section.Info, memoryStream))
			{
				sectionBlock.Write("Nothing");
			}
			foreach (ServerProfiler.Profile profile in profiles)
			{
				using SectionBlock sectionBlock2 = SectionBlock.New(Section.Thread, memoryStream);
				sectionBlock2.Write((uint)profile.ThreadId);
				using SectionBlock sectionBlock3 = SectionBlock.New(Section.Marks, memoryStream);
				uint readInd = 0u;
				while (readInd < profile.WriteEnd)
				{
					byte* ptr = profile.Data + readInd;
					ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
					sectionBlock3.Write((byte)mark.Event);
					sectionBlock3.Write((ulong)mark.Timestamp);
					switch (mark.Event)
					{
					case ServerProfiler.Mark.Type.Enter:
						ServerProfiler.SerializeNameTo(*(ServerProfiler.Native.MonoMethod**)(ptr + sizeof(ServerProfiler.Mark)), memoryStream);
						break;
					case ServerProfiler.Mark.Type.Alloc:
					{
						ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr + sizeof(ServerProfiler.Mark));
						ServerProfiler.SerializeNameTo(alloc, memoryStream);
						sectionBlock3.Write(alloc.AlignedSize);
						break;
					}
					}
					AdvanceReadInd(in mark, profile.Data, ref readInd);
				}
			}
			Debug.Log((object)"Generation done, compressing...");
			byte[] array = new byte[memoryStream.Position];
			Buffer.BlockCopy(memoryStream.GetBuffer(), 0, array, 0, (int)memoryStream.Position);
			string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
			if (!Directory.Exists(text))
			{
				Directory.CreateDirectory(text);
			}
			File.WriteAllBytes(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".bin.gz")), Compression.Compress(array));
			Debug.Log((object)"Snapshot bin export done!");
		}
	}

	private const string OutputDir = "profiler";

	private unsafe static void Preprocess(IList<ServerProfiler.Profile> profiles, out MainThreadInfo mainInfo, out uint totalBytes)
	{
		mainInfo = default(MainThreadInfo);
		totalBytes = 0u;
		uint num = 0u;
		foreach (ServerProfiler.Profile profile in profiles)
		{
			if (profile.ThreadId == ServerProfiler.GetMainThreadId())
			{
				mainInfo.SyncIndices = new List<uint>(10);
				mainInfo.FrameStarts = new List<uint>(10);
				sbyte b = 0;
				sbyte b2 = 0;
				uint num2 = 0u;
				uint num3 = 0u;
				uint readInd = 0u;
				while (readInd < profile.WriteEnd)
				{
					ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(profile.Data + readInd);
					switch (mark.Event)
					{
					case ServerProfiler.Mark.Type.Enter:
						b++;
						if (num3 <= num2)
						{
							num3 = readInd;
						}
						break;
					case ServerProfiler.Mark.Type.Exit:
					case ServerProfiler.Mark.Type.Exception:
						b--;
						if (b < b2)
						{
							b2 = b;
							num2 = readInd;
						}
						break;
					case ServerProfiler.Mark.Type.Sync:
						mainInfo.SyncIndices.Add(readInd);
						mainInfo.FrameStarts.Add(num3);
						mainInfo.Frames++;
						b = 0;
						b2 = 0;
						break;
					}
					AdvanceReadInd(in mark, profile.Data, ref readInd);
				}
				uint num4 = 0u;
				long num5 = profile.Timestamp;
				for (int i = 0; i < mainInfo.Frames; i++)
				{
					uint num6 = mainInfo.SyncIndices[i];
					long timestamp = Unsafe.ReadUnaligned<ServerProfiler.Mark>(profile.Data + num6).Timestamp;
					_ = ServerProfiler.TimestampToTimespan(timestamp - num5).TotalMilliseconds;
					uint num7 = num6 - num4;
					num += num7;
					num5 = timestamp;
					num4 = num6;
				}
				totalBytes += num;
			}
			else
			{
				totalBytes += profile.WriteEnd;
			}
		}
		Debug.Log((object)("Total data: " + NumberExtensions.FormatBytes<uint>(totalBytes, false) + " (main: " + NumberExtensions.FormatBytes<uint>(num, false) + ", workers: " + NumberExtensions.FormatBytes<uint>(totalBytes - num, false) + ")"));
	}

	public unsafe static bool AdvanceReadInd(in ServerProfiler.Mark mark, byte* data, ref uint readInd)
	{
		readInd += (uint)sizeof(ServerProfiler.Mark);
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			readInd += (uint)sizeof(ServerProfiler.Native.MonoMethod*);
			break;
		case ServerProfiler.Mark.Type.Alloc:
			readInd += (uint)sizeof(ServerProfiler.Alloc);
			break;
		case ServerProfiler.Mark.Type.AllocWithStack:
		{
			readInd += (uint)sizeof(ServerProfiler.Alloc);
			byte b = data[readInd];
			readInd++;
			readInd += (uint)(b * sizeof(ServerProfiler.Native.MonoMethod*));
			break;
		}
		default:
			Debug.LogError((object)"Unhandled ServerProfiler.Mark.Type!");
			return false;
		case ServerProfiler.Mark.Type.Sync:
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
		case ServerProfiler.Mark.Type.GCBegin:
		case ServerProfiler.Mark.Type.GCEnd:
			break;
		}
		return true;
	}
}


using System.Collections.Generic;

private struct MainThreadInfo
{
	public List<uint> SyncIndices;

	public List<uint> FrameStarts;

	public uint Frames;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Ionic.Zlib;
using UnityEngine;

public static class JSON
{
	private struct ThreadMetadata
	{
		internal int ThreadId;

		internal int AllocationThreadId;

		internal void Emit(StringStream builder)
		{
			bool isMainThread = ThreadId == ServerProfiler.GetMainThreadId();
			EmitThreadName(isMainThread, isAllocThread: false, ThreadId, ThreadId, builder);
			builder.Append(',');
			EmitThreadName(isMainThread, isAllocThread: true, AllocationThreadId, ThreadId, builder);
		}

		private static void EmitThreadName(bool isMainThread, bool isAllocThread, int id, int origId, StringStream builder)
		{
			builder.Append("{\"name\":\"thread_name\",\"ph\":\"M\",\"pid\":0,\"tid\":");
			builder.Append(id);
			builder.Append(",\"args\":{\"name\":\"");
			if (isMainThread)
			{
				builder.Append("Main Thread");
			}
			else
			{
				builder.Append("Thread");
			}
			if (isAllocThread)
			{
				if (!isMainThread)
				{
					builder.Append(' ');
					builder.Append(origId);
				}
				builder.Append(" Allocations");
			}
			builder.Append("\"}}");
		}
	}

	public class StringStream : MemoryStream
	{
		private GZipStream outputStream;

		public StringStream(int capacity, GZipStream outputStream)
			: base(capacity)
		{
			this.outputStream = outputStream;
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (base.Position + count < base.Capacity)
			{
				base.Write(buffer, offset, count);
				return;
			}
			int num = base.Capacity - (int)base.Position;
			if (num > 0)
			{
				base.Write(buffer, offset, num);
			}
			Flush();
			if (count - num > 0)
			{
				base.Write(buffer, offset + num, count - num);
			}
		}

		public override void Write(ReadOnlySpan<byte> source)
		{
			throw new NotSupportedException("Write(ReadOnlySpan<byte>) not implemented!");
		}

		public override void WriteByte(byte value)
		{
			if (base.Position + 1 < base.Capacity)
			{
				base.WriteByte(value);
				return;
			}
			Flush();
			base.WriteByte(value);
		}

		public void Append(char c)
		{
			WriteByte((byte)c);
		}

		public void Append(string text)
		{
			foreach (char c in text)
			{
				Append(c);
			}
		}

		public void Append(int num)
		{
			Span<char> destination = stackalloc char[32];
			num.TryFormat(destination, out var charsWritten);
			Append(destination.Slice(0, charsWritten));
		}

		public void Append(long num)
		{
			Span<char> destination = stackalloc char[32];
			num.TryFormat(destination, out var charsWritten);
			Append(destination.Slice(0, charsWritten));
		}

		public void Append(ulong num)
		{
			Span<char> destination = stackalloc char[32];
			num.TryFormat(destination, out var charsWritten);
			Append(destination.Slice(0, charsWritten));
		}

		public void Append(ReadOnlySpan<char> chars)
		{
			ReadOnlySpan<char> readOnlySpan = chars;
			for (int i = 0; i < readOnlySpan.Length; i++)
			{
				char c = readOnlySpan[i];
				Append(c);
			}
		}

		public override void Flush()
		{
			long position = Position;
			if (position > 0)
			{
				byte[] buffer = GetBuffer();
				((Stream)(object)outputStream).Write(buffer, 0, (int)position);
				Position = 0L;
			}
		}
	}

	public static bool Export(string filename, IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Expected O, but got Unknown
		try
		{
			Debug.Log((object)"Starting JSON snapshot generation...");
			Preprocess(profiles, out var mainInfo, out var _);
			string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
			if (!Directory.Exists(text))
			{
				Directory.CreateDirectory(text);
			}
			using (FileStream fileStream = new FileStream(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".json.gz")), FileMode.Create, FileAccess.Write, FileShare.None, 20480))
			{
				GZipStream val = new GZipStream((Stream)fileStream, (CompressionMode)0);
				try
				{
					val.FlushMode = (FlushType)2;
					using StringStream stringStream = new StringStream(16384, val);
					stringStream.Append('[');
					int num = 0;
					foreach (ServerProfiler.Profile profile2 in profiles)
					{
						num = Math.Max(num, profile2.ThreadId);
					}
					List<ThreadMetadata> list = new List<ThreadMetadata>();
					for (int i = 0; i < profiles.Count; i++)
					{
						ServerProfiler.Profile profile = profiles[i];
						ThreadMetadata item = default(ThreadMetadata);
						item.ThreadId = profile.ThreadId;
						num = (item.AllocationThreadId = num + 1);
						if (i != 0)
						{
							stringStream.Append(',');
						}
						item.Emit(stringStream);
						list.Add(item);
					}
					long firstMarkTimestamp = 0L;
					for (int j = 0; j < profiles.Count; j++)
					{
						ServerProfiler.Profile mainProfile = profiles[j];
						if (mainProfile.ThreadId == ServerProfiler.GetMainThreadId())
						{
							if (ProcessMainProfile(in mainProfile, in mainInfo, list[j], stringStream, out firstMarkTimestamp))
							{
								break;
							}
							return false;
						}
					}
					for (int k = 0; k < profiles.Count; k++)
					{
						ServerProfiler.Profile workerProfile = profiles[k];
						if (workerProfile.ThreadId != ServerProfiler.GetMainThreadId() && !ProcessWorkerProfile(in workerProfile, list[k], firstMarkTimestamp, stringStream))
						{
							return false;
						}
					}
					ProcessMemoryState(in memState, firstMarkTimestamp, stringStream);
					stringStream.Append("]");
					stringStream.Flush();
					Debug.Log((object)"Generation done, flushing...");
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			Debug.Log((object)"Snapshot json export done!");
			return true;
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			return false;
		}
	}

	private unsafe static bool ProcessMainProfile(in ServerProfiler.Profile mainProfile, in MainThreadInfo info, in ThreadMetadata metadata, StringStream builder, out long firstMarkTimestamp)
	{
		if (info.FrameStarts == null || info.Frames == 0)
		{
			Debug.LogError((object)"ServerProfiler: Didn't find any main frame info!");
			firstMarkTimestamp = 0L;
			return false;
		}
		int num = 0;
		byte* data = mainProfile.Data;
		uint num2 = info.FrameStarts[0];
		firstMarkTimestamp = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num2).Timestamp;
		long num3 = 0L;
		for (int i = 0; i < info.Frames; i++)
		{
			uint num4 = info.FrameStarts[i];
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num4);
			uint num5 = mainProfile.WriteEnd;
			if (i < info.Frames - 1)
			{
				num5 = info.FrameStarts[i + 1];
			}
			ServerProfiler.Mark mark2 = default(ServerProfiler.Mark);
			mark2.Event = ServerProfiler.Mark.Type.Enter;
			mark2.Timestamp = mark.Timestamp;
			AddMark(mark2, $"UnityFrame{i}", mainProfile.ThreadId, firstMarkTimestamp, builder);
			uint totalMem = 0u;
			long offset = ServerProfiler.TimestampToMicros(mark.Timestamp - firstMarkTimestamp);
			EmitCounter("Main Thread", offset, "Total(B)", totalMem, builder);
			uint readInd = num4;
			while (readInd < num5)
			{
				ServerProfiler.Mark mark3 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + readInd);
				num3 = mark3.Timestamp;
				num += AdjustCallstackDepth(in mark3);
				if (num < 0)
				{
					Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {num}, offset: {readInd}, frame: {i}");
					return false;
				}
				AddMark(in mainProfile, in metadata, readInd, ref totalMem, firstMarkTimestamp, builder);
				if (!AdvanceReadInd(in mark3, data, ref readInd))
				{
					return false;
				}
			}
			long timestamp = ((i < info.Frames - 1) ? Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num5).Timestamp : num3);
			mark2 = default(ServerProfiler.Mark);
			mark2.Event = ServerProfiler.Mark.Type.Exit;
			mark2.Timestamp = timestamp;
			AddMark(mark2, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
		}
		while (num > 0)
		{
			ServerProfiler.Mark mark4 = default(ServerProfiler.Mark);
			mark4.Event = ServerProfiler.Mark.Type.Exit;
			mark4.Timestamp = num3;
			AddMark(mark4, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
			num--;
		}
		return true;
	}

	private unsafe static bool ProcessWorkerProfile(in ServerProfiler.Profile workerProfile, in ThreadMetadata metadata, long firstMarkTimestamp, StringStream builder)
	{
		uint readInd = 0u;
		int num = 0;
		while (readInd < workerProfile.WriteEnd)
		{
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd);
			if (mark.Timestamp >= firstMarkTimestamp)
			{
				break;
			}
			if (mark.Event == ServerProfiler.Mark.Type.Sync)
			{
				Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
				return false;
			}
			num += AdjustCallstackDepth(in mark);
			if (!AdvanceReadInd(in mark, workerProfile.Data, ref readInd))
			{
				return false;
			}
		}
		if (readInd >= workerProfile.WriteEnd)
		{
			return true;
		}
		bool flag = false;
		uint readInd2 = readInd;
		while (readInd2 < workerProfile.WriteEnd)
		{
			ServerProfiler.Mark mark2 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd2);
			if (mark2.Event == ServerProfiler.Mark.Type.Sync)
			{
				Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
				return false;
			}
			if (mark2.Event != ServerProfiler.Mark.Type.Alloc)
			{
				flag = true;
				break;
			}
			if (!AdvanceReadInd(in mark2, workerProfile.Data, ref readInd2))
			{
				return false;
			}
		}
		if (!flag)
		{
			return true;
		}
		if (!FindStartingDepth(in workerProfile, 0u, workerProfile.WriteEnd, out var minDepth))
		{
			return false;
		}
		minDepth = num - minDepth;
		for (int num2 = minDepth; num2 > 0; num2--)
		{
			ServerProfiler.Mark mark3 = default(ServerProfiler.Mark);
			mark3.Event = ServerProfiler.Mark.Type.Enter;
			mark3.Timestamp = firstMarkTimestamp;
			AddMark(mark3, "Unknown", workerProfile.ThreadId, firstMarkTimestamp, builder);
		}
		uint totalMem = 0u;
		long timestamp = 0L;
		uint readInd3 = readInd;
		while (readInd3 < workerProfile.WriteEnd)
		{
			ServerProfiler.Mark mark4 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd3);
			timestamp = mark4.Timestamp;
			minDepth += AdjustCallstackDepth(in mark4);
			if (minDepth < 0)
			{
				Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {minDepth}, offset: {readInd3}, thread: {workerProfile.ThreadId}");
				return false;
			}
			if (mark4.Event == ServerProfiler.Mark.Type.Alloc || (mark4.Event == ServerProfiler.Mark.Type.AllocWithStack && totalMem == 0))
			{
				EmitCounter("Thread", metadata.ThreadId, 0L, "Total(B)", 0uL, builder);
			}
			AddMark(in workerProfile, in metadata, readInd3, ref totalMem, firstMarkTimestamp, builder);
			if (!AdvanceReadInd(in mark4, workerProfile.Data, ref readInd3))
			{
				return false;
			}
		}
		while (minDepth > 0)
		{
			ServerProfiler.Mark mark5 = default(ServerProfiler.Mark);
			mark5.Event = ServerProfiler.Mark.Type.Exit;
			mark5.Timestamp = timestamp;
			AddMark(mark5, null, workerProfile.ThreadId, firstMarkTimestamp, builder);
			minDepth--;
		}
		return true;
	}

	private unsafe static void ProcessMemoryState(in ServerProfiler.MemoryState memState, long firstMarkTimestamp, StringStream builder)
	{
		ulong num = 0uL;
		ulong num2 = 0uL;
		for (uint num3 = 0u; num3 < memState.Created; num3++)
		{
			ServerProfiler.MemoryReading memoryReading = memState.Readings[num3];
			long timestamp = memoryReading.Timestamp;
			if (timestamp >= firstMarkTimestamp)
			{
				ulong num4 = memoryReading.WorkingSet / 1024;
				if (num4 != num)
				{
					long offset = ((num == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
					EmitCounter("ws", offset, "WorkingSet(KB)", num4, builder);
					num = num4;
				}
				ulong num5 = memoryReading.VirtualSet / 1024;
				if (num5 != num2)
				{
					long offset2 = ((num2 == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
					EmitCounter("vs", offset2, "VirtualSet(KB)", num5, builder);
					num2 = num5;
				}
			}
		}
	}

	private unsafe static void AddMark(in ServerProfiler.Profile threadProfile, in ThreadMetadata metadata, uint markInd, ref uint totalMem, long startTimestamp, StringStream builder)
	{
		byte* ptr = threadProfile.Data + markInd;
		ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
		ptr += sizeof(ServerProfiler.Mark);
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			builder.Append(",{\"name\":\"");
			ServerProfiler.AppendNameTo(*(ServerProfiler.Native.MonoMethod**)ptr, builder);
			builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append("}");
			break;
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
		case ServerProfiler.Mark.Type.GCEnd:
			builder.Append(",{\"ph\":\"E\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append("}");
			break;
		case ServerProfiler.Mark.Type.Alloc:
		{
			ServerProfiler.Alloc alloc2 = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
			long num2 = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
			builder.Append(",{\"name\":\"");
			builder.Append("Alloc ");
			builder.Append(alloc2.AlignedSize);
			builder.Append("b\",\"ph\":\"i\",\"ts\":");
			builder.Append(num2);
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
			builder.Append(alloc2.AlignedSize);
			builder.Append(",\"type\":\"");
			ServerProfiler.AppendNameTo(alloc2, builder);
			builder.Append("\",\"lastMethod\":\"");
			if (alloc2.LastMethod != null)
			{
				ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
			}
			else
			{
				builder.Append("<mono-native-runtime>");
			}
			builder.Append("\"}}");
			builder.Append(",{\"name\":\"");
			builder.Append("Alloc ");
			builder.Append(alloc2.AlignedSize);
			builder.Append("b\",\"ph\":\"i\",\"ts\":");
			builder.Append(num2);
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(metadata.AllocationThreadId);
			builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
			builder.Append(alloc2.AlignedSize);
			builder.Append(",\"type\":\"");
			ServerProfiler.AppendNameTo(alloc2, builder);
			builder.Append("\",\"lastMethod\":\"");
			if (alloc2.LastMethod != null)
			{
				ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
			}
			else
			{
				builder.Append("<mono-native-runtime>");
			}
			builder.Append("\"}}");
			totalMem += alloc2.AlignedSize;
			if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
			{
				EmitCounter("Main Thread", num2, "Total(B)", totalMem, builder);
			}
			else
			{
				EmitCounter("Thread", metadata.ThreadId, num2, "Total(B)", totalMem, builder);
			}
			break;
		}
		case ServerProfiler.Mark.Type.AllocWithStack:
		{
			ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
			ptr += sizeof(ServerProfiler.Alloc);
			long num = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
			builder.Append(",{\"name\":\"");
			builder.Append("Alloc ");
			builder.Append(alloc.AlignedSize);
			builder.Append("b\",\"ph\":\"i\",\"ts\":");
			builder.Append(num);
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(metadata.ThreadId);
			builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
			builder.Append(alloc.AlignedSize);
			builder.Append(",\"type\":\"");
			ServerProfiler.AppendNameTo(alloc, builder);
			builder.Append("\",\"lastMethod\":\"");
			if (alloc.LastMethod != null)
			{
				ServerProfiler.AppendNameTo(alloc.LastMethod, builder);
			}
			else
			{
				builder.Append("<mono-native-runtime>");
			}
			builder.Append('"');
			byte b = *ptr;
			ptr++;
			if (b > 0)
			{
				builder.Append(",\"callstack\":{");
				ServerProfiler.Native.MonoMethod** ptr2 = (ServerProfiler.Native.MonoMethod**)ptr;
				for (byte b2 = 0; b2 < b; b2++)
				{
					ServerProfiler.Native.MonoMethod* method = ptr2[(int)b2];
					builder.Append('"');
					char c = (char)(b2 + 32);
					if (c >= '"')
					{
						c = (char)(c + 1);
					}
					if (c >= '.')
					{
						c = (char)(c + 1);
					}
					if (c >= '\\')
					{
						c = (char)(c + 1);
					}
					if (c < '\u007f')
					{
						builder.Append(c);
					}
					else
					{
						builder.Append(b2);
					}
					builder.Append("\":\"");
					ServerProfiler.AppendNameTo(method, builder);
					builder.Append('"');
					if (b2 != b - 1)
					{
						builder.Append(',');
					}
				}
				builder.Append('}');
			}
			builder.Append("}}");
			totalMem += alloc.AlignedSize;
			if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
			{
				EmitCounter("Main Thread", num, "Total(B)", totalMem, builder);
			}
			else
			{
				EmitCounter("Thread", metadata.ThreadId, num, "Total(B)", totalMem, builder);
			}
			break;
		}
		case ServerProfiler.Mark.Type.GCBegin:
			builder.Append(",{\"name\":\"");
			builder.Append("GC.Collect");
			builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append("}");
			break;
		}
	}

	private static void AddMark(ServerProfiler.Mark mark, string name, int threadId, long startTimestamp, StringStream builder)
	{
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			builder.Append(",{\"name\":\"");
			builder.Append(name);
			builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadId);
			builder.Append("}");
			break;
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
			builder.Append(",{\"ph\":\"E\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadId);
			builder.Append("}");
			break;
		}
	}

	private static void EmitCounter(string markName, long offset, string counterName, ulong value, StringStream builder)
	{
		builder.Append(",{\"name\":\"");
		builder.Append(markName);
		builder.Append("\",\"ph\":\"C\",\"ts\":");
		builder.Append(offset);
		builder.Append(",\"args\":{\"");
		builder.Append(counterName);
		builder.Append("\":");
		builder.Append(value);
		builder.Append("}}");
	}

	private static void EmitCounter(string markName, int threadId, long offset, string counterName, ulong value, StringStream builder)
	{
		builder.Append(",{\"name\":\"");
		builder.Append(markName);
		builder.Append(" ");
		builder.Append(threadId);
		builder.Append("\",\"ph\":\"C\",\"ts\":");
		builder.Append(offset);
		builder.Append(",\"args\":{\"");
		builder.Append(counterName);
		builder.Append("\":");
		builder.Append(value);
		builder.Append("}}");
	}

	private unsafe static bool FindStartingDepth(in ServerProfiler.Profile threadProfile, uint start, uint end, out int minDepth)
	{
		int num = 0;
		minDepth = 0;
		uint readInd = start;
		while (readInd < end)
		{
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(threadProfile.Data + readInd);
			num += AdjustCallstackDepth(in mark);
			if (mark.Event == ServerProfiler.Mark.Type.Exit || mark.Event == ServerProfiler.Mark.Type.Exception)
			{
				minDepth = Math.Min(num, minDepth);
			}
			if (!AdvanceReadInd(in mark, threadProfile.Data, ref readInd))
			{
				return false;
			}
		}
		return true;
	}

	private static int AdjustCallstackDepth(in ServerProfiler.Mark mark)
	{
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			return 1;
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
			return -1;
		default:
			return 0;
		}
	}
}


private struct ThreadMetadata
{
	internal int ThreadId;

	internal int AllocationThreadId;

	internal void Emit(StringStream builder)
	{
		bool isMainThread = ThreadId == ServerProfiler.GetMainThreadId();
		EmitThreadName(isMainThread, isAllocThread: false, ThreadId, ThreadId, builder);
		builder.Append(',');
		EmitThreadName(isMainThread, isAllocThread: true, AllocationThreadId, ThreadId, builder);
	}

	private static void EmitThreadName(bool isMainThread, bool isAllocThread, int id, int origId, StringStream builder)
	{
		builder.Append("{\"name\":\"thread_name\",\"ph\":\"M\",\"pid\":0,\"tid\":");
		builder.Append(id);
		builder.Append(",\"args\":{\"name\":\"");
		if (isMainThread)
		{
			builder.Append("Main Thread");
		}
		else
		{
			builder.Append("Thread");
		}
		if (isAllocThread)
		{
			if (!isMainThread)
			{
				builder.Append(' ');
				builder.Append(origId);
			}
			builder.Append(" Allocations");
		}
		builder.Append("\"}}");
	}
}


using System;
using System.IO;
using Ionic.Zlib;

public class StringStream : MemoryStream
{
	private GZipStream outputStream;

	public StringStream(int capacity, GZipStream outputStream)
		: base(capacity)
	{
		this.outputStream = outputStream;
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		if (base.Position + count < base.Capacity)
		{
			base.Write(buffer, offset, count);
			return;
		}
		int num = base.Capacity - (int)base.Position;
		if (num > 0)
		{
			base.Write(buffer, offset, num);
		}
		Flush();
		if (count - num > 0)
		{
			base.Write(buffer, offset + num, count - num);
		}
	}

	public override void Write(ReadOnlySpan<byte> source)
	{
		throw new NotSupportedException("Write(ReadOnlySpan<byte>) not implemented!");
	}

	public override void WriteByte(byte value)
	{
		if (base.Position + 1 < base.Capacity)
		{
			base.WriteByte(value);
			return;
		}
		Flush();
		base.WriteByte(value);
	}

	public void Append(char c)
	{
		WriteByte((byte)c);
	}

	public void Append(string text)
	{
		foreach (char c in text)
		{
			Append(c);
		}
	}

	public void Append(int num)
	{
		Span<char> destination = stackalloc char[32];
		num.TryFormat(destination, out var charsWritten);
		Append(destination.Slice(0, charsWritten));
	}

	public void Append(long num)
	{
		Span<char> destination = stackalloc char[32];
		num.TryFormat(destination, out var charsWritten);
		Append(destination.Slice(0, charsWritten));
	}

	public void Append(ulong num)
	{
		Span<char> destination = stackalloc char[32];
		num.TryFormat(destination, out var charsWritten);
		Append(destination.Slice(0, charsWritten));
	}

	public void Append(ReadOnlySpan<char> chars)
	{
		ReadOnlySpan<char> readOnlySpan = chars;
		for (int i = 0; i < readOnlySpan.Length; i++)
		{
			char c = readOnlySpan[i];
			Append(c);
		}
	}

	public override void Flush()
	{
		long position = Position;
		if (position > 0)
		{
			byte[] buffer = GetBuffer();
			((Stream)(object)outputStream).Write(buffer, 0, (int)position);
			Position = 0L;
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch.Utility;
using UnityEngine;

public static class Binary
{
	private enum Section : byte
	{
		Info,
		Thread,
		Marks
	}

	private struct SectionBlock : IDisposable
	{
		private MemoryStream stream;

		private long startPos;

		public static SectionBlock New(Section section, MemoryStream stream)
		{
			SectionBlock result = default(SectionBlock);
			result.stream = stream;
			result.startPos = stream.Position;
			result.Begin(section);
			return result;
		}

		private void Begin(Section section)
		{
			Write(4276993775u);
			Write((byte)section);
			Write(ulong.MaxValue);
		}

		private void End()
		{
			long num = startPos + 5;
			long num2 = stream.Position - num - 8;
			byte[] buffer = stream.GetBuffer();
			for (byte b = 0; b < 8; b++)
			{
				buffer[num + b] = (byte)(num2 >> 56 - b * 8);
			}
			Write(3735928559u);
		}

		public void Write(string text)
		{
			Write((ushort)text.Length);
			for (int i = 0; i < text.Length; i++)
			{
				stream.WriteByte((byte)text[i]);
			}
		}

		public void Write(ulong value)
		{
			for (byte b = 0; b < 8; b++)
			{
				stream.WriteByte((byte)(value >> 56 - b * 8));
			}
		}

		public void Write(uint value)
		{
			for (byte b = 0; b < 4; b++)
			{
				stream.WriteByte((byte)(value >> 24 - b * 8));
			}
		}

		public void Write(ushort value)
		{
			stream.WriteByte((byte)(value >> 8));
			stream.WriteByte((byte)value);
		}

		public void Write(byte value)
		{
			stream.WriteByte(value);
		}

		void IDisposable.Dispose()
		{
			End();
		}
	}

	public unsafe static void Export(string filename, IList<ServerProfiler.Profile> profiles)
	{
		Debug.Log((object)"Starting BIN snapshot generation...");
		MemoryStream memoryStream = new MemoryStream(134217728);
		using (SectionBlock sectionBlock = SectionBlock.New(Section.Info, memoryStream))
		{
			sectionBlock.Write("Nothing");
		}
		foreach (ServerProfiler.Profile profile in profiles)
		{
			using SectionBlock sectionBlock2 = SectionBlock.New(Section.Thread, memoryStream);
			sectionBlock2.Write((uint)profile.ThreadId);
			using SectionBlock sectionBlock3 = SectionBlock.New(Section.Marks, memoryStream);
			uint readInd = 0u;
			while (readInd < profile.WriteEnd)
			{
				byte* ptr = profile.Data + readInd;
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
				sectionBlock3.Write((byte)mark.Event);
				sectionBlock3.Write((ulong)mark.Timestamp);
				switch (mark.Event)
				{
				case ServerProfiler.Mark.Type.Enter:
					ServerProfiler.SerializeNameTo(*(ServerProfiler.Native.MonoMethod**)(ptr + sizeof(ServerProfiler.Mark)), memoryStream);
					break;
				case ServerProfiler.Mark.Type.Alloc:
				{
					ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr + sizeof(ServerProfiler.Mark));
					ServerProfiler.SerializeNameTo(alloc, memoryStream);
					sectionBlock3.Write(alloc.AlignedSize);
					break;
				}
				}
				AdvanceReadInd(in mark, profile.Data, ref readInd);
			}
		}
		Debug.Log((object)"Generation done, compressing...");
		byte[] array = new byte[memoryStream.Position];
		Buffer.BlockCopy(memoryStream.GetBuffer(), 0, array, 0, (int)memoryStream.Position);
		string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
		if (!Directory.Exists(text))
		{
			Directory.CreateDirectory(text);
		}
		File.WriteAllBytes(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".bin.gz")), Compression.Compress(array));
		Debug.Log((object)"Snapshot bin export done!");
	}
}


private enum Section : byte
{
	Info,
	Thread,
	Marks
}


using System;
using System.IO;

private struct SectionBlock : IDisposable
{
	private MemoryStream stream;

	private long startPos;

	public static SectionBlock New(Section section, MemoryStream stream)
	{
		SectionBlock result = default(SectionBlock);
		result.stream = stream;
		result.startPos = stream.Position;
		result.Begin(section);
		return result;
	}

	private void Begin(Section section)
	{
		Write(4276993775u);
		Write((byte)section);
		Write(ulong.MaxValue);
	}

	private void End()
	{
		long num = startPos + 5;
		long num2 = stream.Position - num - 8;
		byte[] buffer = stream.GetBuffer();
		for (byte b = 0; b < 8; b++)
		{
			buffer[num + b] = (byte)(num2 >> 56 - b * 8);
		}
		Write(3735928559u);
	}

	public void Write(string text)
	{
		Write((ushort)text.Length);
		for (int i = 0; i < text.Length; i++)
		{
			stream.WriteByte((byte)text[i]);
		}
	}

	public void Write(ulong value)
	{
		for (byte b = 0; b < 8; b++)
		{
			stream.WriteByte((byte)(value >> 56 - b * 8));
		}
	}

	public void Write(uint value)
	{
		for (byte b = 0; b < 4; b++)
		{
			stream.WriteByte((byte)(value >> 24 - b * 8));
		}
	}

	public void Write(ushort value)
	{
		stream.WriteByte((byte)(value >> 8));
		stream.WriteByte((byte)value);
	}

	public void Write(byte value)
	{
		stream.WriteByte(value);
	}

	void IDisposable.Dispose()
	{
		End();
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using UnityEngine;

[SuppressUnmanagedCodeSecurity]
public static class ServerProfiler
{
	[StructLayout(LayoutKind.Sequential, Pack = 1, Size = 9)]
	public struct Mark
	{
		public enum Type : byte
		{
			Sync,
			Enter,
			Exit,
			Exception,
			Alloc,
			GCBegin,
			GCEnd,
			AllocWithStack
		}

		public long Timestamp;

		public Type Event;
	}

	public struct Alloc
	{
		public unsafe Native.MonoClass* Class;

		public unsafe Native.MonoMethod* LastMethod;

		public uint AlignedSize;

		public uint FlatArraySize;
	}

	public struct Profile
	{
		public unsafe byte* Data;

		private uint WriteInd;

		public uint Capacity;

		public uint WriteEnd;

		public int ThreadId;

		public long Timestamp;
	}

	[StructLayout(LayoutKind.Sequential, Size = 64)]
	public struct MemoryReading
	{
		public long Timestamp;

		public ulong WorkingSet;

		public ulong VirtualSet;
	}

	public struct MemoryState
	{
		public unsafe MemoryReading* Readings;

		public uint Created;

		public uint Capacity;
	}

	public enum NotifyMetric : byte
	{
		TotalAllocCount,
		TotalMem,
		MainAllocCount,
		MainMem,
		WorkerAllocCount,
		WorkerMem,
		Count
	}

	public static class Native
	{
		[StructLayout(LayoutKind.Explicit)]
		public struct MonoImage
		{
			[FieldOffset(48)]
			public unsafe byte* AssemblyName;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoClass
		{
			private const int ImageOffset = 56;

			[FieldOffset(56)]
			public unsafe MonoImage* Image;

			[FieldOffset(64)]
			public unsafe byte* Name;

			[FieldOffset(72)]
			public unsafe byte* Namespace;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoMethod
		{
			[FieldOffset(8)]
			public unsafe MonoClass* Class;

			[FieldOffset(24)]
			public unsafe byte* Name;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoVTable
		{
			[FieldOffset(0)]
			public unsafe MonoClass* Class;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoObject
		{
			[FieldOffset(0)]
			public unsafe MonoVTable* VTable;
		}

		public enum StorageType : byte
		{
			FrameLimited,
			FixedBuffer
		}

		[DllImport("ServerProfiler.Core")]
		public static extern void Install();

		[DllImport("ServerProfiler.Core")]
		public static extern void SetStorageType(byte aStorageType);

		[DllImport("ServerProfiler.Core")]
		public static extern bool SetFramesToRecord(byte aFrameCount);

		[DllImport("ServerProfiler.Core")]
		public static extern bool SetFixedBufferCap(uint aMainThreadCap, uint aWorkerThreadCap);

		[DllImport("ServerProfiler.Core")]
		public static extern void TakeSnapshot();

		[DllImport("ServerProfiler.Core")]
		public static extern void StartContinuousProfiling(byte aMaxStackDepth);

		[DllImport("ServerProfiler.Core")]
		public static extern void StopContinuousProfiling();

		[DllImport("ServerProfiler.Core")]
		public static extern void ResumeContinuousProfiling();

		[DllImport("ServerProfiler.Core")]
		public static extern void SetContinuousProfilerNotifySettings(NotifyMetric aSetting, uint aValue);

		[DllImport("ServerProfiler.Core")]
		public static extern bool OnFrameEnd();

		[DllImport("ServerProfiler.Core")]
		public unsafe static extern void GetData(out Profile** profiles, out byte count);

		[DllImport("ServerProfiler.Core")]
		public unsafe static extern void GetMemoryUsage(out MemoryState* state);

		[DllImport("ServerProfiler.Core")]
		public static extern bool ReleaseResources();
	}

	public const byte MaxFrames = 10;

	private static bool canBeActivated;

	private static Action<IList<Profile>, MemoryState> onDoneCallback;

	private static bool isContinuous;

	private static int mainThreadId;

	public static bool IsRunning => onDoneCallback != null;

	[RuntimeInitializeOnLoadMethod(/*Could not decode attribute arguments.*/)]
	public static void Init()
	{
		if (!Environment.CommandLine.Contains("-enableProfiler"))
		{
			Debug.Log((object)"Profiler Disabled!");
			return;
		}
		mainThreadId = Environment.CurrentManagedThreadId;
		Native.Install();
		canBeActivated = true;
		Debug.Log((object)"Profiler Initialized!");
		PostUpdateHook.EndOfFrame = (Action)Delegate.Combine(PostUpdateHook.EndOfFrame, new Action(OnFrameEnd));
	}

	public static void RecordNextFrames(int frames, Action<IList<Profile>, MemoryState> onDone)
	{
		if (onDone != null && IsEnabled())
		{
			onDoneCallback = onDone;
			Native.SetStorageType(0);
			Native.SetFramesToRecord((byte)Math.Clamp(frames, 1, 10));
			Native.TakeSnapshot();
			isContinuous = false;
		}
	}

	public static void RecordIntoBuffer(uint mainThreadCap, uint workerThreadCap, Action<IList<Profile>, MemoryState> onDone)
	{
		if (onDone != null && IsEnabled())
		{
			onDoneCallback = onDone;
			Native.SetStorageType(1);
			Native.SetFixedBufferCap(mainThreadCap, workerThreadCap);
			Native.TakeSnapshot();
			isContinuous = false;
		}
	}

	public static void StartContinuousRecording(byte maxStackDepth, Action<IList<Profile>, MemoryState> onDone)
	{
		if (onDone != null && IsEnabled())
		{
			onDoneCallback = onDone;
			Native.SetStorageType(1);
			Native.SetFixedBufferCap(33554432u, 8388608u);
			Native.StartContinuousProfiling(maxStackDepth);
			isContinuous = true;
		}
	}

	public static void StopContinuousRecording()
	{
		Native.StopContinuousProfiling();
		onDoneCallback = null;
	}

	public static void ResumeContinuousRecording()
	{
		Native.ResumeContinuousProfiling();
	}

	public static void ReleaseResources()
	{
		Native.ReleaseResources();
	}

	public static bool IsEnabled()
	{
		return canBeActivated;
	}

	private unsafe static void OnFrameEnd()
	{
		if (!Native.OnFrameEnd())
		{
			return;
		}
		List<Profile> list = null;
		Native.GetData(out var profiles, out var count);
		list = new List<Profile>(count);
		for (byte b = 0; b < count; b++)
		{
			if (profiles[(int)b]->WriteEnd != 0)
			{
				list.Add(*profiles[(int)b]);
			}
		}
		Native.GetMemoryUsage(out var state);
		MemoryState arg = *state;
		onDoneCallback(list, arg);
		if (!isContinuous)
		{
			onDoneCallback = null;
		}
	}

	public static TimeSpan TimestampToTimespan(long stamp)
	{
		return TimeSpan.FromMilliseconds((double)stamp / 1000000.0);
	}

	public static long TimestampToMicros(long stamp)
	{
		return stamp / 1000;
	}

	public unsafe static void AppendNameTo(Native.MonoMethod* method, StringBuilder builder)
	{
		for (byte* ptr = method->Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = method->Class->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append("::");
		for (byte* ptr = method->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
	}

	public unsafe static void AppendNameTo(Native.MonoMethod* method, ProfileExporter.JSON.StringStream builder)
	{
		for (byte* ptr = method->Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = method->Class->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append("::");
		for (byte* ptr = method->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
	}

	public unsafe static void SerializeNameTo(Native.MonoMethod* method, MemoryStream stream)
	{
		long position = stream.Position;
		ushort num = 0;
		stream.WriteByte(0);
		stream.WriteByte(0);
		byte* ptr = method->Class->Image->AssemblyName;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		stream.WriteByte(33);
		num++;
		ptr = method->Class->Name;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		stream.WriteByte(58);
		stream.WriteByte(58);
		num += 2;
		ptr = method->Name;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		byte[] buffer = stream.GetBuffer();
		buffer[position] = (byte)(num >> 8);
		buffer[position + 1] = (byte)num;
	}

	public unsafe static void AppendNameTo(Alloc alloc, StringBuilder builder)
	{
		for (byte* ptr = alloc.Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = alloc.Class->Name; *ptr != 0; ptr++)
		{
			char c = (char)(*ptr);
			builder.Append(c);
			if (alloc.FlatArraySize != 0 && c == '[')
			{
				builder.Append(alloc.FlatArraySize);
			}
		}
	}

	public unsafe static void AppendNameTo(Alloc alloc, ProfileExporter.JSON.StringStream builder)
	{
		for (byte* ptr = alloc.Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = alloc.Class->Name; *ptr != 0; ptr++)
		{
			char c = (char)(*ptr);
			builder.Append(c);
			if (alloc.FlatArraySize != 0 && c == '[')
			{
				builder.Append(alloc.FlatArraySize);
			}
		}
	}

	public unsafe static void SerializeNameTo(Alloc alloc, MemoryStream stream)
	{
		long position = stream.Position;
		ushort num = 0;
		stream.WriteByte(0);
		stream.WriteByte(0);
		byte* ptr = alloc.Class->Image->AssemblyName;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		stream.WriteByte(33);
		num++;
		ptr = alloc.Class->Name;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		byte[] buffer = stream.GetBuffer();
		buffer[position] = (byte)(num >> 8);
		buffer[position + 1] = (byte)num;
	}

	public static int GetMainThreadId()
	{
		return mainThreadId;
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 1, Size = 9)]
public struct Mark
{
	public enum Type : byte
	{
		Sync,
		Enter,
		Exit,
		Exception,
		Alloc,
		GCBegin,
		GCEnd,
		AllocWithStack
	}

	public long Timestamp;

	public Type Event;
}


public enum Type : byte
{
	Sync,
	Enter,
	Exit,
	Exception,
	Alloc,
	GCBegin,
	GCEnd,
	AllocWithStack
}


public struct Alloc
{
	public unsafe Native.MonoClass* Class;

	public unsafe Native.MonoMethod* LastMethod;

	public uint AlignedSize;

	public uint FlatArraySize;
}


public struct Profile
{
	public unsafe byte* Data;

	private uint WriteInd;

	public uint Capacity;

	public uint WriteEnd;

	public int ThreadId;

	public long Timestamp;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 64)]
public struct MemoryReading
{
	public long Timestamp;

	public ulong WorkingSet;

	public ulong VirtualSet;
}


public struct MemoryState
{
	public unsafe MemoryReading* Readings;

	public uint Created;

	public uint Capacity;
}


public enum NotifyMetric : byte
{
	TotalAllocCount,
	TotalMem,
	MainAllocCount,
	MainMem,
	WorkerAllocCount,
	WorkerMem,
	Count
}


using System.Runtime.InteropServices;

public static class Native
{
	[StructLayout(LayoutKind.Explicit)]
	public struct MonoImage
	{
		[FieldOffset(48)]
		public unsafe byte* AssemblyName;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoClass
	{
		private const int ImageOffset = 56;

		[FieldOffset(56)]
		public unsafe MonoImage* Image;

		[FieldOffset(64)]
		public unsafe byte* Name;

		[FieldOffset(72)]
		public unsafe byte* Namespace;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoMethod
	{
		[FieldOffset(8)]
		public unsafe MonoClass* Class;

		[FieldOffset(24)]
		public unsafe byte* Name;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoVTable
	{
		[FieldOffset(0)]
		public unsafe MonoClass* Class;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoObject
	{
		[FieldOffset(0)]
		public unsafe MonoVTable* VTable;
	}

	public enum StorageType : byte
	{
		FrameLimited,
		FixedBuffer
	}

	[DllImport("ServerProfiler.Core")]
	public static extern void Install();

	[DllImport("ServerProfiler.Core")]
	public static extern void SetStorageType(byte aStorageType);

	[DllImport("ServerProfiler.Core")]
	public static extern bool SetFramesToRecord(byte aFrameCount);

	[DllImport("ServerProfiler.Core")]
	public static extern bool SetFixedBufferCap(uint aMainThreadCap, uint aWorkerThreadCap);

	[DllImport("ServerProfiler.Core")]
	public static extern void TakeSnapshot();

	[DllImport("ServerProfiler.Core")]
	public static extern void StartContinuousProfiling(byte aMaxStackDepth);

	[DllImport("ServerProfiler.Core")]
	public static extern void StopContinuousProfiling();

	[DllImport("ServerProfiler.Core")]
	public static extern void ResumeContinuousProfiling();

	[DllImport("ServerProfiler.Core")]
	public static extern void SetContinuousProfilerNotifySettings(NotifyMetric aSetting, uint aValue);

	[DllImport("ServerProfiler.Core")]
	public static extern bool OnFrameEnd();

	[DllImport("ServerProfiler.Core")]
	public unsafe static extern void GetData(out Profile** profiles, out byte count);

	[DllImport("ServerProfiler.Core")]
	public unsafe static extern void GetMemoryUsage(out MemoryState* state);

	[DllImport("ServerProfiler.Core")]
	public static extern bool ReleaseResources();
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoImage
{
	[FieldOffset(48)]
	public unsafe byte* AssemblyName;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoClass
{
	private const int ImageOffset = 56;

	[FieldOffset(56)]
	public unsafe MonoImage* Image;

	[FieldOffset(64)]
	public unsafe byte* Name;

	[FieldOffset(72)]
	public unsafe byte* Namespace;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoMethod
{
	[FieldOffset(8)]
	public unsafe MonoClass* Class;

	[FieldOffset(24)]
	public unsafe byte* Name;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoVTable
{
	[FieldOffset(0)]
	public unsafe MonoClass* Class;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoObject
{
	[FieldOffset(0)]
	public unsafe MonoVTable* VTable;
}


public enum StorageType : byte
{
	FrameLimited,
	FixedBuffer
}


using ProtoBuf;

public class AggressionTimerAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public AggressionTimerAIEvent()
		: base(AIEventType.AggressionTimer)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		AggressionTimerAIEventData aggressionTimerData = data.aggressionTimerData;
		Value = aggressionTimerData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.aggressionTimerData = new AggressionTimerAIEventData();
		obj.aggressionTimerData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Inverted)
		{
			base.Result = senses.TimeInAgressiveState < Value;
		}
		else
		{
			base.Result = senses.TimeInAgressiveState >= Value;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using Rust.Ai;
using UnityEngine;

public class AIBrainSenses
{
	[ServerVar]
	public static float UpdateInterval = 0.5f;

	[ServerVar]
	public static float HumanKnownPlayersLOSUpdateInterval = 0.2f;

	[ServerVar]
	public static float KnownPlayersLOSUpdateInterval = 0.5f;

	public float knownPlayersLOSUpdateInterval = 0.2f;

	[NonSerialized]
	public float MemoryDuration = 10f;

	[NonSerialized]
	public float LastThreatTimestamp;

	[NonSerialized]
	public float TimeInAgressiveState;

	public static BaseEntity[] queryResults = new BaseEntity[64];

	public static BasePlayer[] playerQueryResults = new BasePlayer[64];

	public float nextUpdateTime;

	public float nextKnownPlayersLOSUpdateTime;

	public BaseEntity owner;

	public BasePlayer playerOwner;

	public IAISenses ownerSenses;

	public float maxRange;

	public float targetLostRange;

	public float visionCone;

	public bool checkVision;

	public bool checkLOS;

	public bool ignoreNonVisionSneakers;

	public float listenRange;

	public bool hostileTargetsOnly;

	public bool senseFriendlies;

	public bool refreshKnownLOS;

	[NonSerialized]
	public bool ignoreTutorialPlayers;

	public EntityType senseTypes;

	public IAIAttack ownerAttack;

	[NonSerialized]
	public BaseAIBrain brain;

	private Func<BaseEntity, bool> aiCaresAbout;

	public float TimeSinceThreat => Time.realtimeSinceStartup - LastThreatTimestamp;

	public SimpleAIMemory Memory { get; set; } = new SimpleAIMemory();

	public float TargetLostRange => targetLostRange;

	public bool ignoreSafeZonePlayers { get; set; }

	public List<BaseEntity> Players => Memory.Players;

	public void Init(BaseEntity owner, BaseAIBrain brain, float memoryDuration, float range, float targetLostRange, float visionCone, bool checkVision, bool checkLOS, bool ignoreNonVisionSneakers, float listenRange, bool hostileTargetsOnly, bool senseFriendlies, bool ignoreSafeZonePlayers, EntityType senseTypes, bool refreshKnownLOS)
	{
		aiCaresAbout = AiCaresAbout;
		this.owner = owner;
		this.brain = brain;
		MemoryDuration = memoryDuration;
		ownerAttack = owner as IAIAttack;
		playerOwner = owner as BasePlayer;
		maxRange = range;
		this.targetLostRange = targetLostRange;
		this.visionCone = visionCone;
		this.checkVision = checkVision;
		this.checkLOS = checkLOS;
		this.ignoreNonVisionSneakers = ignoreNonVisionSneakers;
		this.listenRange = listenRange;
		this.hostileTargetsOnly = hostileTargetsOnly;
		this.senseFriendlies = senseFriendlies;
		this.ignoreSafeZonePlayers = ignoreSafeZonePlayers;
		this.senseTypes = senseTypes;
		LastThreatTimestamp = Time.realtimeSinceStartup;
		this.refreshKnownLOS = refreshKnownLOS;
		ownerSenses = owner as IAISenses;
		knownPlayersLOSUpdateInterval = ((owner is HumanNPC) ? HumanKnownPlayersLOSUpdateInterval : KnownPlayersLOSUpdateInterval);
	}

	public void DelaySenseUpdate(float delay)
	{
		nextUpdateTime = Time.time + delay;
	}

	public void Update()
	{
		if (!((Object)(object)owner == (Object)null))
		{
			UpdateSenses();
			UpdateKnownPlayersLOS();
		}
	}

	private void UpdateSenses()
	{
		if (Time.time < nextUpdateTime)
		{
			return;
		}
		nextUpdateTime = Time.time + UpdateInterval;
		if (senseTypes != 0)
		{
			if (senseTypes == EntityType.Player)
			{
				SensePlayers();
			}
			else
			{
				SenseBrains();
				if (senseTypes.HasFlag(EntityType.Player))
				{
					SensePlayers();
				}
			}
		}
		Memory.Forget(MemoryDuration);
	}

	public void UpdateKnownPlayersLOS()
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time < nextKnownPlayersLOSUpdateTime)
		{
			return;
		}
		nextKnownPlayersLOSUpdateTime = Time.time + knownPlayersLOSUpdateInterval;
		foreach (BaseEntity player in Memory.Players)
		{
			if (!((Object)(object)player == (Object)null) && !player.IsNpc)
			{
				bool flag = ownerAttack.CanSeeTarget(player);
				Memory.SetLOS(player, flag);
				if (refreshKnownLOS && (Object)(object)owner != (Object)null && flag && Vector3.Distance(((Component)player).transform.position, ((Component)owner).transform.position) <= TargetLostRange)
				{
					Memory.SetKnown(player, owner, this);
				}
			}
		}
	}

	private void SensePlayers()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int playersInSphereFast = BaseEntity.Query.Server.GetPlayersInSphereFast(((Component)owner).transform.position, maxRange, playerQueryResults, aiCaresAbout);
		for (int i = 0; i < playersInSphereFast; i++)
		{
			BasePlayer ent = playerQueryResults[i];
			Memory.SetKnown(ent, owner, this);
		}
	}

	private void SenseBrains()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int brainsInSphereFast = BaseEntity.Query.Server.GetBrainsInSphereFast(((Component)owner).transform.position, maxRange, queryResults, aiCaresAbout);
		for (int i = 0; i < brainsInSphereFast; i++)
		{
			BaseEntity ent = queryResults[i];
			Memory.SetKnown(ent, owner, this);
		}
	}

	private bool AiCaresAbout(BaseEntity entity)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (!entity.isServer)
		{
			return false;
		}
		if (entity.EqualNetID((BaseNetworkable)owner))
		{
			return false;
		}
		if (entity.Health() <= 0f)
		{
			return false;
		}
		if (entity.IsTransferProtected())
		{
			return false;
		}
		if (!IsValidSenseType(entity))
		{
			return false;
		}
		BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsDead())
			{
				return false;
			}
			if (ignoreTutorialPlayers && basePlayer.IsInTutorial)
			{
				return false;
			}
		}
		if (ignoreSafeZonePlayers && (Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
		{
			return false;
		}
		if (listenRange > 0f && (Object)(object)baseCombatEntity != (Object)null && baseCombatEntity.TimeSinceLastNoise <= 1f && baseCombatEntity.CanLastNoiseBeHeard(((Component)owner).transform.position, listenRange))
		{
			return true;
		}
		if (senseFriendlies && ownerSenses != null && ownerSenses.IsFriendly(entity))
		{
			return true;
		}
		float num = float.PositiveInfinity;
		if ((Object)(object)baseCombatEntity != (Object)null && AI.accuratevisiondistance)
		{
			num = Vector3.Distance(((Component)owner).transform.position, ((Component)baseCombatEntity).transform.position);
			if (num > maxRange)
			{
				return false;
			}
		}
		if (checkVision && !IsTargetInVision(entity))
		{
			if (!ignoreNonVisionSneakers)
			{
				return false;
			}
			if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsNpc)
			{
				if (!AI.accuratevisiondistance)
				{
					num = Vector3.Distance(((Component)owner).transform.position, ((Component)basePlayer).transform.position);
				}
				if ((basePlayer.IsDucked() && num >= brain.IgnoreSneakersMaxDistance) || num >= brain.IgnoreNonVisionMaxDistance)
				{
					return false;
				}
			}
		}
		if (hostileTargetsOnly && (Object)(object)baseCombatEntity != (Object)null && !baseCombatEntity.IsHostile() && !(baseCombatEntity is ScarecrowNPC))
		{
			return false;
		}
		if (checkLOS && ownerAttack != null)
		{
			bool flag = ownerAttack.CanSeeTarget(entity);
			Memory.SetLOS(entity, flag);
			if (!flag)
			{
				return false;
			}
		}
		return true;
	}

	private bool IsValidSenseType(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsNpc)
			{
				if (ent is BasePet)
				{
					return true;
				}
				if (ent is ScarecrowNPC)
				{
					return true;
				}
				if (senseTypes.HasFlag(EntityType.BasePlayerNPC))
				{
					return true;
				}
			}
			else if (senseTypes.HasFlag(EntityType.Player))
			{
				return true;
			}
		}
		if (senseTypes.HasFlag(EntityType.NPC) && ent is BaseNpc)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.WorldItem) && ent is WorldItem)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.Corpse) && ent is BaseCorpse)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.TimedExplosive) && ent is TimedExplosive)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.Chair) && ent is BaseChair)
		{
			return true;
		}
		return false;
	}

	private bool IsTargetInVision(BaseEntity target)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.Direction(((Component)target).transform.position, ((Component)owner).transform.position);
		return Vector3.Dot(((Object)(object)playerOwner != (Object)null) ? playerOwner.eyes.BodyForward() : ((Component)owner).transform.forward, val) >= visionCone;
	}

	public BaseEntity GetNearestPlayer(float rangeFraction)
	{
		return GetNearest(Memory.Players, rangeFraction);
	}

	public BaseEntity GetNearestThreat(float rangeFraction)
	{
		return GetNearest(Memory.Threats, rangeFraction);
	}

	public BaseEntity GetNearestTarget(float rangeFraction)
	{
		return GetNearest(Memory.Targets, rangeFraction);
	}

	private BaseEntity GetNearest(List<BaseEntity> entities, float rangeFraction)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (entities == null || entities.Count == 0)
		{
			return null;
		}
		float num = float.PositiveInfinity;
		BaseEntity result = null;
		foreach (BaseEntity entity in entities)
		{
			if (!((Object)(object)entity == (Object)null) && !(entity.Health() <= 0f) && Interface.CallHook("OnNpcTarget", (object)owner, (object)entity) == null)
			{
				float num2 = Vector3.Distance(((Component)entity).transform.position, ((Component)owner).transform.position);
				if (num2 <= rangeFraction * maxRange && num2 < num)
				{
					result = entity;
				}
			}
		}
		return result;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/AI Design")]
public class AIDesignSO : BaseScriptableObject
{
	public string Filename;
}


using System.Collections.Generic;
using ProtoBuf;

public class AIDesign
{
	public List<AIState> AvailableStates = new List<AIState>();

	public int DefaultStateContainerID;

	private Dictionary<int, AIStateContainer> stateContainers = new Dictionary<int, AIStateContainer>();

	public AIDesignScope Scope { get; private set; }

	public string Description { get; private set; }

	public void SetAvailableStates(List<AIState> states)
	{
		AvailableStates = new List<AIState>();
		AvailableStates.AddRange(states);
	}

	public void Load(AIDesign design, BaseEntity owner)
	{
		Scope = (AIDesignScope)design.scope;
		DefaultStateContainerID = design.defaultStateContainer;
		Description = design.description;
		InitStateContainers(design, owner);
	}

	private void InitStateContainers(AIDesign design, BaseEntity owner)
	{
		stateContainers = new Dictionary<int, AIStateContainer>();
		if (design.stateContainers == null)
		{
			return;
		}
		foreach (AIStateContainer stateContainer in design.stateContainers)
		{
			AIStateContainer aIStateContainer = new AIStateContainer();
			aIStateContainer.Init(stateContainer, owner);
			stateContainers.Add(aIStateContainer.ID, aIStateContainer);
		}
	}

	public AIStateContainer GetDefaultStateContainer()
	{
		return GetStateContainerByID(DefaultStateContainerID);
	}

	public AIStateContainer GetStateContainerByID(int id)
	{
		if (!stateContainers.ContainsKey(id))
		{
			return null;
		}
		return stateContainers[id];
	}

	public AIStateContainer GetFirstStateContainerOfType(AIState stateType)
	{
		foreach (AIStateContainer value in stateContainers.Values)
		{
			if (value.State == stateType)
			{
				return value;
			}
		}
		return null;
	}

	public AIDesign ToProto(int currentStateID)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		AIDesign val = new AIDesign();
		val.description = Description;
		val.scope = (int)Scope;
		val.defaultStateContainer = DefaultStateContainerID;
		val.availableStates = new List<int>();
		foreach (AIState availableState in AvailableStates)
		{
			val.availableStates.Add((int)availableState);
		}
		val.stateContainers = new List<AIStateContainer>();
		foreach (AIStateContainer value in stateContainers.Values)
		{
			val.stateContainers.Add(value.ToProto());
		}
		val.intialViewStateID = currentStateID;
		return val;
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public static class AIDesigns
{
	public const string DesignFolderPath = "cfg/ai/";

	private static Dictionary<string, AIDesign> designs = new Dictionary<string, AIDesign>();

	public static AIDesign GetByNameOrInstance(string designName, AIDesign entityDesign)
	{
		if (entityDesign != null)
		{
			return entityDesign;
		}
		AIDesign byName = GetByName(designName + "_custom");
		if (byName != null)
		{
			return byName;
		}
		return GetByName(designName);
	}

	public static void RefreshCache(string designName, AIDesign design)
	{
		if (designs.ContainsKey(designName))
		{
			designs[designName] = design;
		}
	}

	private static AIDesign GetByName(string designName)
	{
		designs.TryGetValue(designName, out var value);
		if (value != null)
		{
			return value;
		}
		string text = "cfg/ai/" + designName;
		if (!File.Exists(text))
		{
			return null;
		}
		try
		{
			using FileStream fileStream = File.Open(text, FileMode.Open);
			value = Pool.Get<AIDesign>();
			ProtoStreamExtensions.ReadFromStream((IProto)(object)value, (Stream)fileStream, false, 1048576);
			if (value == null)
			{
				return null;
			}
			designs.Add(designName, value);
			return value;
		}
		catch (Exception)
		{
			Debug.LogWarning((object)("Error trying to find AI design by name: " + text));
			return null;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class AIEvents
{
	public AIMemory Memory = new AIMemory();

	public List<BaseAIEvent> events = new List<BaseAIEvent>();

	private IAIEventListener eventListener;

	public AIBrainSenses senses;

	private int currentEventIndex;

	private bool inBlock;

	public int CurrentInputMemorySlot { get; private set; } = -1;

	public void Init(IAIEventListener listener, AIStateContainer stateContainer, BaseEntity owner, AIBrainSenses senses)
	{
		CurrentInputMemorySlot = stateContainer.InputMemorySlot;
		eventListener = listener;
		RemoveAll();
		AddStateEvents(stateContainer.Events, owner);
		Memory.Entity.Set(owner, 4);
		this.senses = senses;
	}

	public void RemoveAll()
	{
		events.Clear();
	}

	public void AddStateEvents(List<BaseAIEvent> events, BaseEntity owner)
	{
		foreach (BaseAIEvent @event in events)
		{
			Add(@event);
		}
	}

	public void Add(BaseAIEvent aiEvent)
	{
		if (events.Contains(aiEvent))
		{
			Debug.LogWarning((object)("Attempting to add duplicate AI event: " + aiEvent.EventType));
			return;
		}
		aiEvent.Reset();
		events.Add(aiEvent);
	}

	public void Tick(float deltaTime, StateStatus stateStatus)
	{
		foreach (BaseAIEvent @event in events)
		{
			@event.Tick(deltaTime, eventListener);
		}
		inBlock = false;
		currentEventIndex = 0;
		for (currentEventIndex = 0; currentEventIndex < events.Count; currentEventIndex++)
		{
			BaseAIEvent baseAIEvent = events[currentEventIndex];
			BaseAIEvent baseAIEvent2 = ((currentEventIndex < events.Count - 1) ? events[currentEventIndex + 1] : null);
			if (baseAIEvent2 != null && baseAIEvent2.EventType == AIEventType.And && !inBlock)
			{
				inBlock = true;
			}
			if (baseAIEvent.EventType != AIEventType.And)
			{
				if (baseAIEvent.ShouldExecute)
				{
					baseAIEvent.Execute(Memory, senses, stateStatus);
					baseAIEvent.PostExecute();
				}
				bool result = baseAIEvent.Result;
				if (inBlock)
				{
					if (result)
					{
						if ((baseAIEvent2 != null && baseAIEvent2.EventType != AIEventType.And) || baseAIEvent2 == null)
						{
							inBlock = false;
							if (baseAIEvent.HasValidTriggerState)
							{
								baseAIEvent.TriggerStateChange(eventListener, baseAIEvent.ID);
								break;
							}
						}
					}
					else
					{
						inBlock = false;
						currentEventIndex = FindNextEventBlock() - 1;
					}
				}
				else if (result && baseAIEvent.HasValidTriggerState)
				{
					baseAIEvent.TriggerStateChange(eventListener, baseAIEvent.ID);
					break;
				}
			}
		}
	}

	private int FindNextEventBlock()
	{
		for (int i = currentEventIndex; i < events.Count; i++)
		{
			BaseAIEvent baseAIEvent = events[i];
			BaseAIEvent baseAIEvent2 = ((i < events.Count - 1) ? events[i + 1] : null);
			if (baseAIEvent2 != null && baseAIEvent2.EventType != AIEventType.And && baseAIEvent.EventType != AIEventType.And)
			{
				return i + 1;
			}
		}
		return events.Count + 1;
	}
}


public enum AIEventType
{
	Timer,
	PlayerDetected,
	StateError,
	Attacked,
	StateFinished,
	InAttackRange,
	HealthBelow,
	InRange,
	PerformedAttack,
	TirednessAbove,
	HungerAbove,
	ThreatDetected,
	TargetDetected,
	AmmoBelow,
	BestTargetDetected,
	IsVisible,
	AttackTick,
	IsMounted,
	And,
	Chance,
	TargetLost,
	TimeSinceThreat,
	OnPositionMemorySet,
	AggressionTimer,
	Reloading,
	InRangeOfHome,
	IsBlinded
}


using UnityEngine;

public class AIMemory
{
	public AIMemoryBank<BaseEntity> Entity = new AIMemoryBank<BaseEntity>(MemoryBankType.Entity, 8);

	public AIMemoryBank<Vector3> Position = new AIMemoryBank<Vector3>(MemoryBankType.Position, 8);

	public AIMemoryBank<AIPoint> AIPoint = new AIMemoryBank<AIPoint>(MemoryBankType.AIPoint, 8);

	public void Clear()
	{
		Entity.Clear();
		Position.Clear();
		AIPoint.Clear();
	}
}


public enum MemoryBankType
{
	Entity,
	Position,
	AIPoint
}


public enum ReservedEntitySlots
{
	Self = 4,
	OwningPlayer,
	GroupLeader,
	SpecialEntity
}


public enum ReservedPositionSlots
{
	HomePoint = 4,
	GroupRoamPoint,
	RaycastTargetPoint,
	Vector3
}


public enum ReservedAIPointSlots
{
	CoverPoint = 4
}


using UnityEngine;

public class AIMemoryBank<T>
{
	private MemoryBankType type;

	private T[] slots;

	private float[] slotSetTimestamps;

	private int slotCount;

	public AIMemoryBank(MemoryBankType type, int slots)
	{
		Init(type, slots);
	}

	public void Init(MemoryBankType type, int slots)
	{
		this.type = type;
		slotCount = slots;
		this.slots = new T[slotCount];
		slotSetTimestamps = new float[slotCount];
	}

	public void Set(T item, int index)
	{
		if (index >= 0 && index < slotCount)
		{
			slots[index] = item;
			slotSetTimestamps[index] = Time.realtimeSinceStartup;
		}
	}

	public T Get(int index)
	{
		if (index < 0 || index >= slotCount)
		{
			return default(T);
		}
		return slots[index];
	}

	public float GetTimeSinceSet(int index)
	{
		if (index < 0 || index >= slotCount)
		{
			return 0f;
		}
		return Time.realtimeSinceStartup - slotSetTimestamps[index];
	}

	public void Remove(int index)
	{
		if (index >= 0 && index < slotCount)
		{
			slots[index] = default(T);
		}
	}

	public void Clear()
	{
		for (int i = 0; i < 4; i++)
		{
			Remove(i);
		}
	}
}


using ProtoBuf;

public class AmmoBelowAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public AmmoBelowAIEvent()
		: base(AIEventType.AmmoBelow)
	{
		base.Rate = ExecuteRate.Normal;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		AmmoBelowAIEventData ammoBelowData = data.ammoBelowData;
		Value = ammoBelowData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.ammoBelowData = new AmmoBelowAIEventData();
		obj.ammoBelowData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Owner is IAIAttack iAIAttack)
		{
			bool flag = iAIAttack.GetAmmoFraction() < Value;
			if (base.Inverted)
			{
				base.Result = !flag;
			}
			else
			{
				base.Result = flag;
			}
		}
	}
}


public class AndAIEvent : BaseAIEvent
{
	public AndAIEvent()
		: base(AIEventType.And)
	{
		base.Rate = ExecuteRate.Normal;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
	}
}


using UnityEngine;

public class AttackedAIEvent : BaseAIEvent
{
	protected float lastExecuteTime = float.NegativeInfinity;

	private BaseCombatEntity combatEntity;

	public AttackedAIEvent()
		: base(AIEventType.Attacked)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Reset()
	{
		base.Reset();
		lastExecuteTime = Time.time;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		combatEntity = memory.Entity.Get(base.InputEntityMemorySlot) as BaseCombatEntity;
		float num = lastExecuteTime;
		lastExecuteTime = Time.time;
		if ((Object)(object)combatEntity == (Object)null || !(combatEntity.lastAttackedTime >= num) || (Object)(object)combatEntity.lastAttacker == (Object)null || (Object)(object)combatEntity.lastAttacker == (Object)(object)combatEntity)
		{
			return;
		}
		BasePlayer basePlayer = combatEntity.lastAttacker as BasePlayer;
		if (!((Object)(object)basePlayer != (Object)null) || !((Object)(object)basePlayer == (Object)(object)memory.Entity.Get(5)) || !((Object)(object)basePlayer.lastDealtDamageTo == (Object)(object)base.Owner))
		{
			if (base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(combatEntity.lastAttacker, base.OutputEntityMemorySlot);
			}
			base.Result = !base.Inverted;
		}
	}
}


public class AttackTickAIEvent : BaseAIEvent
{
	public AttackTickAIEvent()
		: base(AIEventType.AttackTick)
	{
		base.Rate = ExecuteRate.VeryFast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Owner is IAIAttack iAIAttack)
		{
			BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
			iAIAttack.AttackTick(deltaTime, baseEntity, senses.Memory.IsLOS(baseEntity));
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class BaseAIEvent
{
	public enum ExecuteRate
	{
		Slow,
		Normal,
		Fast,
		VeryFast
	}

	private float executeTimer;

	protected float deltaTime;

	public AIEventType EventType { get; private set; }

	public int TriggerStateContainerID { get; private set; } = -1;

	public ExecuteRate Rate { get; protected set; } = ExecuteRate.Normal;

	public float ExecutionRate => Rate switch
	{
		ExecuteRate.Slow => 1f, 
		ExecuteRate.Normal => 0.5f, 
		ExecuteRate.Fast => 0.25f, 
		ExecuteRate.VeryFast => 0.1f, 
		_ => 0.5f, 
	};

	public bool ShouldExecute { get; protected set; }

	public bool Result { get; protected set; }

	public bool Inverted { get; private set; }

	public int OutputEntityMemorySlot { get; protected set; } = -1;

	public bool ShouldSetOutputEntityMemory => OutputEntityMemorySlot > -1;

	public int InputEntityMemorySlot { get; protected set; } = -1;

	public int ID { get; protected set; }

	public BaseEntity Owner { get; private set; }

	public bool HasValidTriggerState => TriggerStateContainerID != -1;

	public BaseAIEvent(AIEventType type)
	{
		EventType = type;
	}

	public virtual void Init(AIEventData data, BaseEntity owner)
	{
		Init(data.triggerStateContainer, data.id, owner, data.inputMemorySlot, data.outputMemorySlot, data.inverted);
	}

	public virtual void Init(int triggerStateContainer, int id, BaseEntity owner, int inputMemorySlot, int outputMemorySlot, bool inverted)
	{
		TriggerStateContainerID = triggerStateContainer;
		ID = id;
		Owner = owner;
		InputEntityMemorySlot = inputMemorySlot;
		OutputEntityMemorySlot = outputMemorySlot;
		Inverted = inverted;
	}

	public virtual AIEventData ToProto()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Expected O, but got Unknown
		return new AIEventData
		{
			id = ID,
			eventType = (int)EventType,
			triggerStateContainer = TriggerStateContainerID,
			outputMemorySlot = OutputEntityMemorySlot,
			inputMemorySlot = InputEntityMemorySlot,
			inverted = Inverted
		};
	}

	public virtual void Reset()
	{
		executeTimer = 0f;
		deltaTime = 0f;
		Result = false;
	}

	public void Tick(float deltaTime, IAIEventListener listener)
	{
		this.deltaTime += deltaTime;
		executeTimer += deltaTime;
		float executionRate = ExecutionRate;
		if (executeTimer >= executionRate)
		{
			executeTimer = 0f;
			ShouldExecute = true;
		}
		else
		{
			ShouldExecute = false;
		}
	}

	public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
	}

	public virtual void PostExecute()
	{
		deltaTime = 0f;
	}

	public void TriggerStateChange(IAIEventListener listener, int sourceEventID)
	{
		listener.EventTriggeredStateChange(TriggerStateContainerID, sourceEventID);
	}

	public static BaseAIEvent CreateEvent(AIEventType eventType)
	{
		switch (eventType)
		{
		case AIEventType.Timer:
			return new TimerAIEvent();
		case AIEventType.PlayerDetected:
			return new PlayerDetectedAIEvent();
		case AIEventType.StateError:
			return new StateErrorAIEvent();
		case AIEventType.Attacked:
			return new AttackedAIEvent();
		case AIEventType.StateFinished:
			return new StateFinishedAIEvent();
		case AIEventType.InAttackRange:
			return new InAttackRangeAIEvent();
		case AIEventType.HealthBelow:
			return new HealthBelowAIEvent();
		case AIEventType.InRange:
			return new InRangeAIEvent();
		case AIEventType.PerformedAttack:
			return new PerformedAttackAIEvent();
		case AIEventType.TirednessAbove:
			return new TirednessAboveAIEvent();
		case AIEventType.HungerAbove:
			return new HungerAboveAIEvent();
		case AIEventType.ThreatDetected:
			return new ThreatDetectedAIEvent();
		case AIEventType.TargetDetected:
			return new TargetDetectedAIEvent();
		case AIEventType.AmmoBelow:
			return new AmmoBelowAIEvent();
		case AIEventType.BestTargetDetected:
			return new BestTargetDetectedAIEvent();
		case AIEventType.IsVisible:
			return new IsVisibleAIEvent();
		case AIEventType.AttackTick:
			return new AttackTickAIEvent();
		case AIEventType.IsMounted:
			return new IsMountedAIEvent();
		case AIEventType.And:
			return new AndAIEvent();
		case AIEventType.Chance:
			return new ChanceAIEvent();
		case AIEventType.TargetLost:
			return new TargetLostAIEvent();
		case AIEventType.TimeSinceThreat:
			return new TimeSinceThreatAIEvent();
		case AIEventType.OnPositionMemorySet:
			return new OnPositionMemorySetAIEvent();
		case AIEventType.AggressionTimer:
			return new AggressionTimerAIEvent();
		case AIEventType.Reloading:
			return new ReloadingAIEvent();
		case AIEventType.InRangeOfHome:
			return new InRangeOfHomeAIEvent();
		case AIEventType.IsBlinded:
			return new IsBlindedAIEvent();
		default:
			Debug.LogWarning((object)("No case for " + eventType.ToString() + " event in BaseAIEvent.CreateEvent()!"));
			return null;
		}
	}
}


public enum ExecuteRate
{
	Slow,
	Normal,
	Fast,
	VeryFast
}


using ProtoBuf;
using UnityEngine;

public class BestTargetDetectedAIEvent : BaseAIEvent
{
	public BestTargetDetectedAIEvent()
		: base(AIEventType.BestTargetDetected)
	{
		base.Rate = ExecuteRate.Normal;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (!(base.Owner is IAIAttack iAIAttack))
		{
			return;
		}
		BaseEntity bestTarget = iAIAttack.GetBestTarget();
		if (base.Inverted)
		{
			if ((Object)(object)bestTarget == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)bestTarget == (Object)null;
		}
		else
		{
			if ((Object)(object)bestTarget != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(bestTarget, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)bestTarget != (Object)null;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class ChanceAIEvent : BaseAIEvent
{
	public float Chance { get; set; }

	public ChanceAIEvent()
		: base(AIEventType.Chance)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		Chance = data.chanceData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.chanceData = new ChanceAIEventData();
		obj.chanceData.value = Chance;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		bool flag = Random.Range(0f, 1f) <= Chance;
		if (base.Inverted)
		{
			base.Result = !flag;
		}
		else
		{
			base.Result = flag;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class HealthBelowAIEvent : BaseAIEvent
{
	private BaseCombatEntity combatEntity;

	public float HealthFraction { get; set; }

	public HealthBelowAIEvent()
		: base(AIEventType.HealthBelow)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		HealthBelowAIEventData healthBelowData = data.healthBelowData;
		HealthFraction = healthBelowData.healthFraction;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.healthBelowData = new HealthBelowAIEventData();
		obj.healthBelowData.healthFraction = HealthFraction;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		combatEntity = memory.Entity.Get(base.InputEntityMemorySlot) as BaseCombatEntity;
		if (!((Object)(object)combatEntity == (Object)null))
		{
			bool flag = combatEntity.healthFraction < HealthFraction;
			if (base.Inverted)
			{
				base.Result = !flag;
			}
			else
			{
				base.Result = flag;
			}
		}
	}
}


public interface IAIHungerAbove
{
	bool IsHungerAbove(float val);
}


using ProtoBuf;

public class HungerAboveAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public HungerAboveAIEvent()
		: base(AIEventType.HungerAbove)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		HungerAboveAIEventData hungerAboveData = data.hungerAboveData;
		Value = hungerAboveData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.hungerAboveData = new HungerAboveAIEventData();
		obj.hungerAboveData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		if (!(base.Owner is IAIHungerAbove iAIHungerAbove))
		{
			base.Result = false;
			return;
		}
		bool flag = iAIHungerAbove.IsHungerAbove(Value);
		if (base.Inverted)
		{
			base.Result = !flag;
		}
		else
		{
			base.Result = flag;
		}
	}
}


public interface IAIEventListener
{
	void EventTriggeredStateChange(int newStateContainerID, int sourceEventID);
}


using UnityEngine;

public class InAttackRangeAIEvent : BaseAIEvent
{
	public InAttackRangeAIEvent()
		: base(AIEventType.InAttackRange)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		base.Result = false;
		if (!((Object)(object)baseEntity == (Object)null) && base.Owner is IAIAttack iAIAttack)
		{
			float dist;
			bool flag = iAIAttack.IsTargetInRange(baseEntity, out dist);
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class InRangeAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public InRangeAIEvent()
		: base(AIEventType.InRange)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		InRangeAIEventData inRangeData = data.inRangeData;
		Range = inRangeData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.inRangeData = new InRangeAIEventData();
		obj.inRangeData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		base.Result = false;
		if (!((Object)(object)baseEntity == (Object)null))
		{
			bool flag = Vector3Ex.Distance2D(((Component)base.Owner).transform.position, ((Component)baseEntity).transform.position) <= Range;
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class InRangeOfHomeAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public InRangeOfHomeAIEvent()
		: base(AIEventType.InRangeOfHome)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		InRangeOfHomeAIEventData inRangeOfHomeData = data.inRangeOfHomeData;
		Range = inRangeOfHomeData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.inRangeOfHomeData = new InRangeOfHomeAIEventData();
		obj.inRangeOfHomeData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = memory.Position.Get(4);
		base.Result = false;
		bool flag = Vector3Ex.Distance2D(((Component)base.Owner).transform.position, val) <= Range;
		base.Result = (base.Inverted ? (!flag) : flag);
	}
}


public class IsBlindedAIEvent : BaseAIEvent
{
	public IsBlindedAIEvent()
		: base(AIEventType.IsBlinded)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		bool flag = senses.brain.Blinded();
		if (base.Inverted)
		{
			base.Result = !flag;
		}
		else
		{
			base.Result = flag;
		}
	}
}


using UnityEngine;

public class IsVisibleAIEvent : BaseAIEvent
{
	public IsVisibleAIEvent()
		: base(AIEventType.IsVisible)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		if (!((Object)(object)baseEntity == (Object)null) && base.Owner is IAIAttack)
		{
			bool flag = senses.Memory.IsLOS(baseEntity);
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


public class IsMountedAIEvent : BaseAIEvent
{
	public IsMountedAIEvent()
		: base(AIEventType.IsMounted)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		IAIMounted iAIMounted = memory.Entity.Get(base.InputEntityMemorySlot) as IAIMounted;
		base.Result = false;
		if (iAIMounted != null)
		{
			if (base.Inverted && !iAIMounted.IsMounted())
			{
				base.Result = true;
			}
			if (!base.Inverted && iAIMounted.IsMounted())
			{
				base.Result = true;
			}
			if (base.Result && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(memory.Entity.Get(base.InputEntityMemorySlot), base.OutputEntityMemorySlot);
			}
		}
	}
}


public class OnPositionMemorySetAIEvent : BaseAIEvent
{
	public OnPositionMemorySetAIEvent()
		: base(AIEventType.OnPositionMemorySet)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		if (memory.Position.GetTimeSinceSet(5) <= 0.5f)
		{
			base.Result = !base.Inverted;
		}
		else
		{
			base.Result = base.Inverted;
		}
	}
}


using UnityEngine;

public class PerformedAttackAIEvent : BaseAIEvent
{
	protected float lastExecuteTime = float.NegativeInfinity;

	private BaseCombatEntity combatEntity;

	public PerformedAttackAIEvent()
		: base(AIEventType.PerformedAttack)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Reset()
	{
		base.Reset();
		lastExecuteTime = Time.time;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		combatEntity = memory.Entity.Get(base.InputEntityMemorySlot) as BaseCombatEntity;
		float num = lastExecuteTime;
		lastExecuteTime = Time.time;
		if ((Object)(object)combatEntity == (Object)null)
		{
			return;
		}
		if (combatEntity.lastDealtDamageTime >= num)
		{
			if ((Object)(object)combatEntity.lastDealtDamageTo == (Object)null || (Object)(object)combatEntity.lastDealtDamageTo == (Object)(object)combatEntity)
			{
				return;
			}
			BasePlayer basePlayer = combatEntity as BasePlayer;
			if (!((Object)(object)basePlayer != (Object)null) || ((!((Object)(object)basePlayer == (Object)(object)memory.Entity.Get(5)) || !((Object)(object)basePlayer.lastDealtDamageTo == (Object)(object)base.Owner)) && (!((Object)(object)basePlayer == (Object)(object)memory.Entity.Get(5)) || (((Component)basePlayer.lastDealtDamageTo).gameObject.layer != 21 && ((Component)basePlayer.lastDealtDamageTo).gameObject.layer != 8))))
			{
				if (base.ShouldSetOutputEntityMemory)
				{
					memory.Entity.Set(combatEntity.lastDealtDamageTo, base.OutputEntityMemorySlot);
				}
				base.Result = !base.Inverted;
			}
		}
		else
		{
			base.Result = base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class PlayerDetectedAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public PlayerDetectedAIEvent()
		: base(AIEventType.PlayerDetected)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		PlayerDetectedAIEventData playerDetectedData = data.playerDetectedData;
		Range = playerDetectedData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.playerDetectedData = new PlayerDetectedAIEventData();
		obj.playerDetectedData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		BaseEntity nearestPlayer = senses.GetNearestPlayer(Range);
		if (base.Inverted)
		{
			if ((Object)(object)nearestPlayer == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestPlayer == (Object)null;
		}
		else
		{
			if ((Object)(object)nearestPlayer != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(nearestPlayer, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestPlayer != (Object)null;
		}
	}
}


using UnityEngine;

public class ReloadingAIEvent : BaseAIEvent
{
	public ReloadingAIEvent()
		: base(AIEventType.Reloading)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		base.Result = false;
		NPCPlayer nPCPlayer = baseEntity as NPCPlayer;
		if (!((Object)(object)nPCPlayer == (Object)null))
		{
			bool flag = nPCPlayer.IsReloading();
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


public class StateErrorAIEvent : BaseAIEvent
{
	public StateErrorAIEvent()
		: base(AIEventType.StateError)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		switch (stateStatus)
		{
		case StateStatus.Error:
			base.Result = !base.Inverted;
			break;
		case StateStatus.Running:
			base.Result = base.Inverted;
			break;
		}
	}
}


public class StateFinishedAIEvent : BaseAIEvent
{
	public StateFinishedAIEvent()
		: base(AIEventType.StateFinished)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (stateStatus == StateStatus.Finished)
		{
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class TargetDetectedAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public TargetDetectedAIEvent()
		: base(AIEventType.TargetDetected)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TargetDetectedAIEventData targetDetectedData = data.targetDetectedData;
		Range = targetDetectedData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.targetDetectedData = new TargetDetectedAIEventData();
		obj.targetDetectedData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		BaseEntity nearestTarget = senses.GetNearestTarget(Range);
		if (base.Inverted)
		{
			if ((Object)(object)nearestTarget == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestTarget == (Object)null;
		}
		else
		{
			if ((Object)(object)nearestTarget != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(nearestTarget, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestTarget != (Object)null;
		}
	}
}


using UnityEngine;

public class TargetLostAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public TargetLostAIEvent()
		: base(AIEventType.TargetLost)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		base.Result = base.Inverted;
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			base.Result = !base.Inverted;
			return;
		}
		if (Vector3.Distance(((Component)baseEntity).transform.position, ((Component)base.Owner).transform.position) > senses.TargetLostRange)
		{
			base.Result = !base.Inverted;
			return;
		}
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if (baseEntity.Health() <= 0f || ((Object)(object)basePlayer != (Object)null && basePlayer.IsDead()))
		{
			base.Result = !base.Inverted;
		}
		else if (senses.ignoreSafeZonePlayers && (Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
		{
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class ThreatDetectedAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public ThreatDetectedAIEvent()
		: base(AIEventType.ThreatDetected)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		ThreatDetectedAIEventData threatDetectedData = data.threatDetectedData;
		Range = threatDetectedData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.threatDetectedData = new ThreatDetectedAIEventData();
		obj.threatDetectedData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		BaseEntity nearestThreat = senses.GetNearestThreat(Range);
		if (base.Inverted)
		{
			if ((Object)(object)nearestThreat == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestThreat == (Object)null;
		}
		else
		{
			if ((Object)(object)nearestThreat != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(nearestThreat, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestThreat != (Object)null;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class TimerAIEvent : BaseAIEvent
{
	protected float currentDuration;

	protected float elapsedDuration;

	public float DurationMin { get; set; }

	public float DurationMax { get; set; }

	public TimerAIEvent()
		: base(AIEventType.Timer)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TimerAIEventData timerData = data.timerData;
		DurationMin = timerData.duration;
		DurationMax = timerData.durationMax;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.timerData = new TimerAIEventData();
		obj.timerData.duration = DurationMin;
		obj.timerData.durationMax = DurationMax;
		return obj;
	}

	public override void Reset()
	{
		base.Reset();
		currentDuration = Random.Range(DurationMin, DurationMax);
		elapsedDuration = 0f;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		elapsedDuration += deltaTime;
		if (elapsedDuration >= currentDuration)
		{
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;

public class TimeSinceThreatAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public TimeSinceThreatAIEvent()
		: base(AIEventType.TimeSinceThreat)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TimeSinceThreatAIEventData timeSinceThreatData = data.timeSinceThreatData;
		Value = timeSinceThreatData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.timeSinceThreatData = new TimeSinceThreatAIEventData();
		obj.timeSinceThreatData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Inverted)
		{
			base.Result = senses.TimeSinceThreat < Value;
		}
		else
		{
			base.Result = senses.TimeSinceThreat >= Value;
		}
	}
}


public interface IAITirednessAbove
{
	bool IsTirednessAbove(float val);
}


public interface IAISleep
{
	void StartSleeping();

	void StopSleeping();
}


public interface IAISenses
{
	bool IsThreat(BaseEntity entity);

	bool IsTarget(BaseEntity entity);

	bool IsFriendly(BaseEntity entity);
}


public interface IAIMounted
{
	bool IsMounted();
}


using ProtoBuf;

public class TirednessAboveAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public TirednessAboveAIEvent()
		: base(AIEventType.TirednessAbove)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TirednessAboveAIEventData tirednessAboveData = data.tirednessAboveData;
		Value = tirednessAboveData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.tirednessAboveData = new TirednessAboveAIEventData();
		obj.tirednessAboveData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Owner is IAITirednessAbove iAITirednessAbove)
		{
			bool flag = iAITirednessAbove.IsTirednessAbove(Value);
			if (base.Inverted)
			{
				base.Result = !flag;
			}
			else
			{
				base.Result = flag;
			}
		}
	}
}


using System.Collections.Generic;
using ProtoBuf;

public class AIStateContainer
{
	public List<BaseAIEvent> Events;

	public int ID { get; private set; }

	public AIState State { get; private set; }

	public int InputMemorySlot { get; private set; } = -1;

	public void Init(AIStateContainer container, BaseEntity owner)
	{
		ID = container.id;
		State = (AIState)container.state;
		InputMemorySlot = container.inputMemorySlot;
		Events = new List<BaseAIEvent>();
		if (container.events == null)
		{
			return;
		}
		foreach (AIEventData @event in container.events)
		{
			BaseAIEvent baseAIEvent = BaseAIEvent.CreateEvent((AIEventType)@event.eventType);
			baseAIEvent.Init(@event, owner);
			baseAIEvent.Reset();
			Events.Add(baseAIEvent);
		}
	}

	public AIStateContainer ToProto()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		AIStateContainer val = new AIStateContainer();
		val.id = ID;
		val.state = (int)State;
		val.events = new List<AIEventData>();
		val.inputMemorySlot = InputMemorySlot;
		foreach (BaseAIEvent @event in Events)
		{
			val.events.Add(@event.ToProto());
		}
		return val;
	}
}


public enum StateStatus
{
	Running,
	Finished,
	Error
}


public enum AIDesignScope
{
	Default,
	EntityServerWide,
	EntityInstance
}


using System;

[Flags]
public enum EntityType
{
	Player = 1,
	NPC = 2,
	WorldItem = 4,
	Corpse = 8,
	TimedExplosive = 0x10,
	Chair = 0x20,
	BasePlayerNPC = 0x40
}


internal interface IClientBrainStateListener
{
	void OnClientStateChanged(AIState state);
}


using ProtoBuf;

internal interface IAIDesign
{
	void LoadAIDesign(AIDesign design, BasePlayer player);

	void StopDesigning();

	bool CanPlayerDesignAI(BasePlayer player);
}


public interface IAISleepable
{
	bool AllowedToSleep();

	void SleepAI();

	void WakeAI();
}


using UnityEngine;

public interface IAIGroupable
{
	bool AddMember(IAIGroupable member);

	void RemoveMember(IAIGroupable member);

	void JoinGroup(IAIGroupable leader, BaseEntity leaderEntity);

	void SetGroupRoamRootPosition(Vector3 rootPos);

	bool InGroup();

	void LeaveGroup();

	void SetUngrouped();
}


public interface IAIAttack
{
	void AttackTick(float delta, BaseEntity target, bool targetIsLOS);

	BaseEntity GetBestTarget();

	bool CanAttack(BaseEntity entity);

	float EngagementRange();

	bool IsTargetInRange(BaseEntity entity, out float dist);

	bool CanSeeTarget(BaseEntity entity);

	float GetAmmoFraction();

	bool NeedsToReload();

	bool Reload();

	float CooldownDuration();

	bool IsOnCooldown();

	bool StartAttacking(BaseEntity entity);

	void StopAttacking();
}


public enum PetCommandType
{
	LoadDesign,
	SetState,
	Destroy
}


using UnityEngine;

public interface IPet
{
	bool IsPet();

	void SetPetOwner(BasePlayer player);

	bool IsOwnedBy(BasePlayer player);

	bool IssuePetCommand(PetCommandType cmd, int param, Ray? ray);
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PetCommandList : PrefabAttribute
{
	[Serializable]
	public struct PetCommandDesc
	{
		public PetCommandType CommandType;

		public Phrase Title;

		public Phrase Description;

		public Sprite Icon;

		public int CommandIndex;

		public bool Raycast;

		public int CommandWheelOrder;
	}

	public List<PetCommandDesc> Commands;

	protected override Type GetIndexedType()
	{
		return typeof(PetCommandList);
	}

	public List<PetCommandDesc> GetCommandDescriptions()
	{
		return Commands;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct PetCommandDesc
{
	public PetCommandType CommandType;

	public Phrase Title;

	public Phrase Description;

	public Sprite Icon;

	public int CommandIndex;

	public bool Raycast;

	public int CommandWheelOrder;
}


using UnityEngine;

public class ScentEmission : EntityComponent<BaseCombatEntity>, IClientComponent
{
	[SerializeField]
	private bool startSampling = true;

	[SerializeField]
	private bool generateFakeTrail = true;

	[SerializeField]
	private float sampleIntervalSeconds = 1f;

	[Space]
	[SerializeField]
	private int minInitialPoints = 5;

	[SerializeField]
	private Vector2 initialDistanceRange = new Vector2(50f, 100f);

	[SerializeField]
	private float startAngleDeviation = 45f;

	[SerializeField]
	private float wiggleIntensity = 1f;

	[Space]
	[SerializeField]
	private LineRenderer[] lineRenderers;

	[SerializeField]
	private float heightOffset = 0.5f;

	[SerializeField]
	private bool snapToTerrain = true;
}


using System;
using UnityEngine;

public class AudioVisualisationEntityLight : AudioVisualisationEntity
{
	[Serializable]
	public struct LightColourSet
	{
		[ColorUsage(true, true)]
		public Color LightColor;

		[ColorUsage(true, true)]
		public Color SecondaryLightColour;

		[ColorUsage(true, true)]
		public Color EmissionColour;
	}

	public Light TargetLight;

	public Light SecondaryLight;

	public MeshRenderer[] TargetRenderer;

	public LightColourSet RedColour;

	public LightColourSet GreenColour;

	public LightColourSet BlueColour;

	public LightColourSet YellowColour;

	public LightColourSet PinkColour;

	public float lightMinIntensity = 0.05f;

	public float lightMaxIntensity = 1f;
}


using System;
using UnityEngine;

[Serializable]
public struct LightColourSet
{
	[ColorUsage(true, true)]
	public Color LightColor;

	[ColorUsage(true, true)]
	public Color SecondaryLightColour;

	[ColorUsage(true, true)]
	public Color EmissionColour;
}


using System;
using System.Collections.Generic;
using System.IO;
using ConVar;
using Facepunch;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class BoomBox : EntityComponent<BaseEntity>, INotifyLOD
{
	public AudioSource SoundSource;

	public float ConditionLossRate = 0.25f;

	public ItemDefinition[] ValidCassettes;

	public SoundDefinition PlaySfx;

	public SoundDefinition StopSfx;

	public const BaseEntity.Flags HasCassette = BaseEntity.Flags.Reserved1;

	[ServerVar(Saved = true)]
	public static int BacktrackLength = 30;

	public Action<float> HurtCallback;

	public static Dictionary<string, string> ValidStations;

	public static Dictionary<string, string> ServerValidStations;

	[ReplicatedVar(Saved = true, Help = "A list of radio stations that are valid on this server. Format: NAME,URL,NAME,URL,etc", ShowInAdminUI = true)]
	public static string ServerUrlList = string.Empty;

	public static string lastParsedServerList;

	public ShoutcastStreamer ShoutcastStreamer;

	public GameObjectRef RadioIpDialog;

	public ulong AssignedRadioBy;

	public BaseEntity BaseEntity => base.baseEntity;

	private bool isClient
	{
		get
		{
			if ((Object)(object)base.baseEntity != (Object)null)
			{
				return base.baseEntity.isClient;
			}
			return false;
		}
	}

	public string CurrentRadioIp { get; set; } = "rustradio.facepunch.com";

	[ServerVar]
	public static void ClearRadioByUser(Arg arg)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		ulong uInt = arg.GetUInt64(0, 0uL);
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current is DeployableBoomBox deployableBoomBox)
				{
					if (deployableBoomBox.ClearRadioByUserId(uInt))
					{
						num++;
					}
				}
				else if (current is HeldBoomBox heldBoomBox && heldBoomBox.ClearRadioByUserId(uInt))
				{
					num++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Stopped and cleared saved URL of {num} boom boxes");
	}

	public void ServerTogglePlay(BaseEntity.RPCMessage msg, bool bypassPower = false)
	{
		if (IsPowered() || bypassPower)
		{
			bool flag = ((Stream)(object)msg.read).ReadByte() == 1;
			if (Interface.CallHook("OnBoomboxToggle", (object)this, (object)msg.player, (object)flag) == null)
			{
				ServerTogglePlay(flag);
			}
		}
	}

	public void DeductCondition()
	{
		HurtCallback?.Invoke(ConditionLossRate * ConVar.Decay.scale);
	}

	public void ServerTogglePlay(bool play)
	{
		if (!((Object)(object)base.baseEntity == (Object)null) && HasFlag(BaseEntity.Flags.On) != play)
		{
			SetFlag(BaseEntity.Flags.On, play);
			if (base.baseEntity is IOEntity iOEntity)
			{
				iOEntity.MarkDirtyForceUpdateOutputs();
			}
			if (play && !((FacepunchBehaviour)this).IsInvoking((Action)DeductCondition) && ConditionLossRate > 0f)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)DeductCondition, 1f, 1f);
			}
			else if (((FacepunchBehaviour)this).IsInvoking((Action)DeductCondition))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)DeductCondition);
			}
		}
	}

	public void OnCassetteInserted(Cassette c)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)base.baseEntity == (Object)null))
		{
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("Client_OnCassetteInserted"), c.net.ID);
			ServerTogglePlay(play: false);
			SetFlag(BaseEntity.Flags.Reserved1, state: true);
			base.baseEntity.SendNetworkUpdate();
		}
	}

	public void OnCassetteRemoved(Cassette c)
	{
		if (!((Object)(object)base.baseEntity == (Object)null))
		{
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("Client_OnCassetteRemoved"));
			ServerTogglePlay(play: false);
			SetFlag(BaseEntity.Flags.Reserved1, state: false);
		}
	}

	public bool IsPowered()
	{
		if ((Object)(object)base.baseEntity == (Object)null)
		{
			return false;
		}
		if (!base.baseEntity.HasFlag(BaseEntity.Flags.Reserved8))
		{
			return base.baseEntity is HeldBoomBox;
		}
		return true;
	}

	public bool IsOn()
	{
		if ((Object)(object)base.baseEntity == (Object)null)
		{
			return false;
		}
		return base.baseEntity.IsOn();
	}

	public bool HasFlag(BaseEntity.Flags f)
	{
		if ((Object)(object)base.baseEntity == (Object)null)
		{
			return false;
		}
		return base.baseEntity.HasFlag(f);
	}

	public void SetFlag(BaseEntity.Flags f, bool state)
	{
		if ((Object)(object)base.baseEntity != (Object)null)
		{
			base.baseEntity.SetFlag(f, state);
		}
	}

	public static void LoadStations()
	{
		if (ValidStations == null)
		{
			ValidStations = GetStationData() ?? new Dictionary<string, string>();
			ParseServerUrlList();
		}
	}

	public static Dictionary<string, string> GetStationData()
	{
		JObject obj = Application.Manifest?.Metadata;
		JToken obj2 = ((obj != null) ? obj["RadioStations"] : null);
		JArray val = (JArray)(object)((obj2 is JArray) ? obj2 : null);
		if (val != null && ((JContainer)val).Count > 0)
		{
			string[] array = new string[2];
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			{
				foreach (string item in ((JContainer)val).Values<string>())
				{
					array = item.Split(',');
					if (!dictionary.ContainsKey(array[0]) && !array[1].Contains("facepunch"))
					{
						dictionary.Add(array[0], array[1]);
					}
				}
				return dictionary;
			}
		}
		return null;
	}

	public static bool IsStationValid(string url)
	{
		ParseServerUrlList();
		object obj = Interface.CallHook("OnBoomboxStationValidate", (object)url);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ShoutcastStreamer.CheckBuiltInRadios();
		if (ValidStations == null || !ValidStations.ContainsValue(url))
		{
			if (ServerValidStations == null || !ServerValidStations.ContainsValue(url))
			{
				if (ShoutcastStreamer.ParsedLocalRadioList != null)
				{
					return ShoutcastStreamer.ParsedLocalRadioList.ContainsValue(url);
				}
				return false;
			}
			return true;
		}
		return true;
	}

	public static void ParseServerUrlList()
	{
		if (ServerValidStations == null)
		{
			ServerValidStations = new Dictionary<string, string>();
		}
		if (lastParsedServerList == ServerUrlList)
		{
			return;
		}
		ServerValidStations.Clear();
		if (!string.IsNullOrEmpty(ServerUrlList))
		{
			string[] array = ServerUrlList.Split(',');
			if (array.Length % 2 != 0)
			{
				Debug.Log((object)"Invalid number of stations in BoomBox.ServerUrlList, ensure you always have a name and a url");
				return;
			}
			for (int i = 0; i < array.Length; i += 2)
			{
				if (ServerValidStations.ContainsKey(array[i]))
				{
					Debug.Log((object)("Duplicate station name detected in BoomBox.ServerUrlList, all station names must be unique: " + array[i]));
				}
				else
				{
					ServerValidStations.Add(array[i], array[i + 1]);
				}
			}
		}
		lastParsedServerList = ServerUrlList;
	}

	public void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)
	{
		string text = msg.read.String(256, false);
		if (Interface.CallHook("OnBoomboxStationUpdate", (object)this, (object)text, (object)msg.player) == null && IsStationValid(text))
		{
			if ((Object)(object)msg.player != (Object)null)
			{
				ulong assignedRadioBy = msg.player.userID.Get();
				AssignedRadioBy = assignedRadioBy;
			}
			CurrentRadioIp = text;
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnRadioIPChanged"), CurrentRadioIp);
			Interface.CallHook("OnBoomboxStationUpdated", (object)this, (object)text, (object)msg.player);
			if (IsOn())
			{
				ServerTogglePlay(play: false);
			}
		}
	}

	public void Save(BaseNetworkable.SaveInfo info)
	{
		if (info.msg.boomBox == null)
		{
			info.msg.boomBox = Pool.Get<BoomBox>();
		}
		info.msg.boomBox.radioIp = CurrentRadioIp;
		info.msg.boomBox.assignedRadioBy = AssignedRadioBy;
	}

	public bool ClearRadioByUserId(ulong id)
	{
		if (AssignedRadioBy == id)
		{
			CurrentRadioIp = string.Empty;
			AssignedRadioBy = 0uL;
			if (HasFlag(BaseEntity.Flags.On))
			{
				ServerTogglePlay(play: false);
			}
			return true;
		}
		return false;
	}

	public void Load(BaseNetworkable.LoadInfo info)
	{
		if (info.msg.boomBox != null)
		{
			CurrentRadioIp = info.msg.boomBox.radioIp;
			AssignedRadioBy = info.msg.boomBox.assignedRadioBy;
		}
	}
}


public interface ICassettePlayer
{
	BaseEntity ToBaseEntity { get; }

	void OnCassetteInserted(Cassette c);

	void OnCassetteRemoved(Cassette c);
}


using UnityEngine;

public class DiscoFloor : AudioVisualisationEntity
{
	public float GradientDuration = 3f;

	public float VolumeSensitivityMultiplier = 3f;

	public float BaseSpeed;

	public Light[] LightSources;

	public DiscoFloorMesh FloorMesh;
}


using System;
using UnityEngine;

public class DiscoFloorColourLookups : PrefabAttribute, IClientComponent
{
	public float[] InOutLookup;

	public float[] RadialLookup;

	public float[] RippleLookup;

	public float[] CheckerLookup;

	public float[] BlockLookup;

	public Gradient[] ColourGradients;

	protected override Type GetIndexedType()
	{
		return typeof(DiscoFloorColourLookups);
	}
}


using UnityEngine;

public class DiscoFloorMesh : MonoBehaviour, IClientComponent
{
	public int GridRows = 5;

	public int GridColumns = 5;

	public float GridSize = 1f;

	[Range(0f, 10f)]
	public float TestOffset;

	public Color OffColor = Color.grey;

	public MeshRenderer Renderer;

	public bool DrawInEditor;

	public MeshFilter Filter;

	public AnimationCurve customCurveX = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve customCurveY = AnimationCurve.Linear(0f, 0f, 1f, 1f);
}


public interface IAudioConnectionSource
{
	IOEntity ToEntity();
}


public class ItemModAssociatedEntityMobile : ItemModAssociatedEntity<MobileInventoryEntity>
{
	protected override bool AllowNullParenting => true;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		base.ServerCommand(item, command, player);
		MobileInventoryEntity associatedEntity = ItemModAssociatedEntity<MobileInventoryEntity>.GetAssociatedEntity(item);
		if (command == "silenton")
		{
			associatedEntity.SetSilentMode(wantsSilent: true);
		}
		else if (command == "silentoff")
		{
			associatedEntity.SetSilentMode(wantsSilent: false);
		}
	}
}


public class ItemModCassette : ItemModAssociatedEntity<Cassette>
{
	public int noteSpriteIndex;

	public PreloadedCassetteContent PreloadedContent;

	protected override bool AllowNullParenting => true;

	protected override bool AllowHeldEntityParenting => true;

	protected override void OnAssociatedItemCreated(Cassette ent)
	{
		base.OnAssociatedItemCreated(ent);
		ent.AssignPreloadContent();
	}
}


using System;
using UnityEngine;

public class LaserLight : AudioVisualisationEntity
{
	[Serializable]
	public struct ColourSetting
	{
		public Material LaserMaterial;

		public Color PointLightColour;

		[ColorUsage(false, true)]
		public Color DotColour;

		public Color FlareColour;
	}

	public Animator LaserAnimator;

	public LineRenderer[] LineRenderers;

	public MeshRenderer[] DotRenderers;

	public MeshRenderer FlareRenderer;

	public Light[] LightSources;

	public ColourSetting RedSettings;

	public ColourSetting GreenSettings;

	public ColourSetting BlueSettings;

	public ColourSetting YellowSettings;

	public ColourSetting PinkSettings;

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ColourSetting
{
	public Material LaserMaterial;

	public Color PointLightColour;

	[ColorUsage(false, true)]
	public Color DotColour;

	public Color FlareColour;
}


public class MicrophoneStandIOEntity : IOEntity, IAudioConnectionSource
{
	public int PowerCost = 5;

	public TriggerBase InstrumentTrigger;

	public bool IsStatic;

	public override int ConsumptionAmount()
	{
		return PowerCost;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		return PowerCost;
	}

	public override int MaximalPowerOutput()
	{
		if (IsStatic)
		{
			return 100;
		}
		return base.MaximalPowerOutput();
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		if (IsStatic)
		{
			return 100;
		}
		return base.CalculateCurrentEnergy(inputAmount, inputSlot);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (IsStatic)
		{
			return 100;
		}
		return base.GetPassthroughAmount(outputSlot);
	}

	public override bool IsRootEntity()
	{
		if (IsStatic)
		{
			return true;
		}
		return base.IsRootEntity();
	}

	public IOEntity ToEntity()
	{
		return this;
	}
}


public class MobileInventoryEntity : BaseEntity
{
	public SoundDefinition ringingLoop;

	public SoundDefinition silentLoop;

	public const Flags Ringing = Flags.Reserved1;

	public static Flags Flag_Silent = Flags.Reserved2;

	public void ToggleRinging(bool state)
	{
		SetFlag(Flags.Reserved1, state);
	}

	public void SetSilentMode(bool wantsSilent)
	{
		SetFlag(Flag_Silent, wantsSilent);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class PhoneController : EntityComponent<BaseEntity>
{
	public int PhoneNumber;

	public string PhoneName;

	public bool CanModifyPhoneName = true;

	public bool CanSaveNumbers = true;

	public bool RequirePower = true;

	public bool RequireParent;

	public const float CallWaitingTime = 24f;

	public bool AppendGridToName;

	public bool IsMobile;

	public bool CanSaveVoicemail;

	public GameObjectRef PhoneDialog;

	public VoiceProcessor VProcessor;

	public PreloadedCassetteContent PreloadedContent;

	public SoundDefinition DialToneSfx;

	public SoundDefinition RingingSfx;

	public SoundDefinition ErrorSfx;

	public SoundDefinition CallIncomingWhileBusySfx;

	public SoundDefinition PickupHandsetSfx;

	public SoundDefinition PutDownHandsetSfx;

	public SoundDefinition FailedWrongNumber;

	public SoundDefinition FailedNoAnswer;

	public SoundDefinition FailedNetworkBusy;

	public SoundDefinition FailedEngaged;

	public SoundDefinition FailedRemoteHangUp;

	public SoundDefinition FailedSelfHangUp;

	public Light RingingLight;

	public float RingingLightFrequency = 0.4f;

	public AudioSource answeringMachineSound;

	public EntityRef currentPlayerRef;

	public List<VoicemailEntry> savedVoicemail;

	public PhoneController activeCallTo;

	public int MaxVoicemailSlots
	{
		get
		{
			if (!((Object)(object)cachedCassette != (Object)null))
			{
				return 0;
			}
			return cachedCassette.MaximumVoicemailSlots;
		}
	}

	public BasePlayer currentPlayer
	{
		get
		{
			if (currentPlayerRef.IsValid(isServer))
			{
				return currentPlayerRef.Get(isServer).ToPlayer();
			}
			return null;
		}
		set
		{
			currentPlayerRef.Set(value);
		}
	}

	private bool isServer
	{
		get
		{
			if ((Object)(object)base.baseEntity != (Object)null)
			{
				return base.baseEntity.isServer;
			}
			return false;
		}
	}

	public int lastDialedNumber { get; set; }

	public PhoneDirectory savedNumbers { get; set; }

	public BaseEntity ParentEntity => base.baseEntity;

	private Cassette cachedCassette
	{
		get
		{
			if (!((Object)(object)base.baseEntity != (Object)null) || !(base.baseEntity is Telephone telephone))
			{
				return null;
			}
			return telephone.cachedCassette;
		}
	}

	public Telephone.CallState serverState { get; set; }

	public uint AnsweringMessageId
	{
		get
		{
			if (!(base.baseEntity is Telephone telephone))
			{
				return 0u;
			}
			return telephone.AnsweringMessageId;
		}
	}

	public override void DestroyShared()
	{
		DestroyServer();
	}

	private bool IsPowered()
	{
		if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity is IOEntity iOEntity)
		{
			return iOEntity.IsPowered();
		}
		return false;
	}

	public bool IsSavedContactValid(string contactName, int contactNumber)
	{
		if (contactName.Length <= 0 || contactName.Length > 30)
		{
			return false;
		}
		if (contactNumber < 10000000 || contactNumber >= 100000000)
		{
			return false;
		}
		return true;
	}

	public void OnFlagsChanged(BaseEntity.Flags old, BaseEntity.Flags next)
	{
	}

	public void ServerInit()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (PhoneNumber == 0 && !Application.isLoadingSave)
		{
			PhoneNumber = TelephoneManager.GetUnusedTelephoneNumber();
			if (AppendGridToName & !string.IsNullOrEmpty(PhoneName))
			{
				PhoneName = PhoneName + " [" + MapHelper.PositionToString(((Component)this).transform.position) + "]";
			}
			TelephoneManager.RegisterTelephone(this);
		}
	}

	public void PostServerLoad()
	{
		currentPlayer = null;
		base.baseEntity.SetFlag(BaseEntity.Flags.Busy, b: false);
		TelephoneManager.RegisterTelephone(this);
	}

	public void DoServerDestroy()
	{
		TelephoneManager.DeregisterTelephone(this);
	}

	public void ClearCurrentUser(BaseEntity.RPCMessage msg)
	{
		ClearCurrentUser();
	}

	public void ClearCurrentUser()
	{
		if ((Object)(object)currentPlayer != (Object)null)
		{
			currentPlayer.SetActiveTelephone(null);
			currentPlayer = null;
		}
		base.baseEntity.SetFlag(BaseEntity.Flags.Busy, b: false);
	}

	public void SetCurrentUser(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)currentPlayer == (Object)(object)player))
		{
			UpdateServerPlayer(player);
			if (serverState == Telephone.CallState.Dialing || serverState == Telephone.CallState.Ringing || serverState == Telephone.CallState.InProcess)
			{
				ServerHangUp(default(BaseEntity.RPCMessage));
			}
		}
	}

	private void UpdateServerPlayer(BasePlayer newPlayer)
	{
		if (!((Object)(object)currentPlayer == (Object)(object)newPlayer))
		{
			if ((Object)(object)currentPlayer != (Object)null)
			{
				currentPlayer.SetActiveTelephone(null);
			}
			currentPlayer = newPlayer;
			base.baseEntity.SetFlag(BaseEntity.Flags.Busy, (Object)(object)currentPlayer != (Object)null);
			if ((Object)(object)currentPlayer != (Object)null)
			{
				currentPlayer.SetActiveTelephone(this);
			}
		}
	}

	public void InitiateCall(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)currentPlayer))
		{
			int number = msg.read.Int32();
			CallPhone(number);
		}
	}

	public void CallPhone(int number)
	{
		if (number == PhoneNumber)
		{
			OnDialFailed(Telephone.DialFailReason.CallSelf);
			return;
		}
		if (TelephoneManager.GetCurrentActiveCalls() + 1 > TelephoneManager.MaxConcurrentCalls)
		{
			OnDialFailed(Telephone.DialFailReason.NetworkBusy);
			return;
		}
		PhoneController telephone = TelephoneManager.GetTelephone(number);
		if ((Object)(object)telephone != (Object)null)
		{
			if (Interface.CallHook("OnPhoneDial", (object)this, (object)telephone, (object)currentPlayer) == null)
			{
				if (telephone.serverState == Telephone.CallState.Idle && telephone.CanReceiveCall())
				{
					SetPhoneState(Telephone.CallState.Dialing);
					lastDialedNumber = number;
					activeCallTo = telephone;
					activeCallTo.ReceiveCallFrom(this);
				}
				else
				{
					OnDialFailed(Telephone.DialFailReason.Engaged);
					telephone.OnIncomingCallWhileBusy();
				}
			}
		}
		else
		{
			OnDialFailed(Telephone.DialFailReason.WrongNumber);
		}
	}

	private bool CanReceiveCall()
	{
		object obj = Interface.CallHook("CanReceiveCall", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequirePower && !IsPowered())
		{
			return false;
		}
		if (RequireParent && !base.baseEntity.HasParent())
		{
			return false;
		}
		return true;
	}

	public void AnswerPhone(BaseEntity.RPCMessage msg)
	{
		if (((FacepunchBehaviour)this).IsInvoking((Action)TimeOutDialing))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TimeOutDialing);
		}
		if (!((Object)(object)activeCallTo == (Object)null))
		{
			BasePlayer player = msg.player;
			if (Interface.CallHook("OnPhoneAnswer", (object)this, (object)activeCallTo) == null)
			{
				UpdateServerPlayer(player);
				BeginCall();
				activeCallTo.BeginCall();
				Interface.CallHook("OnPhoneAnswered", (object)this, (object)activeCallTo);
			}
		}
	}

	public void ReceiveCallFrom(PhoneController t)
	{
		activeCallTo = t;
		SetPhoneState(Telephone.CallState.Ringing);
		((FacepunchBehaviour)this).Invoke((Action)TimeOutDialing, 24f);
	}

	private void TimeOutDialing()
	{
		if (Interface.CallHook("OnPhoneDialTimeout", (object)activeCallTo, (object)this, (object)activeCallTo.currentPlayer) == null)
		{
			if ((Object)(object)activeCallTo != (Object)null)
			{
				activeCallTo.ServerPlayAnsweringMessage(this);
			}
			SetPhoneState(Telephone.CallState.Idle);
			Interface.CallHook("OnPhoneDialTimedOut", (object)activeCallTo, (object)this, (object)activeCallTo.currentPlayer);
		}
	}

	public void OnDialFailed(Telephone.DialFailReason reason)
	{
		if (Interface.CallHook("OnPhoneDialFail", (object)this, (object)reason, (object)currentPlayer) == null)
		{
			SetPhoneState(Telephone.CallState.Idle);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientOnDialFailed"), (int)reason);
			activeCallTo = null;
			if (((FacepunchBehaviour)this).IsInvoking((Action)TimeOutCall))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)TimeOutCall);
			}
			if (((FacepunchBehaviour)this).IsInvoking((Action)TriggerTimeOut))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)TriggerTimeOut);
			}
			if (((FacepunchBehaviour)this).IsInvoking((Action)TimeOutDialing))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)TimeOutDialing);
			}
			Interface.CallHook("OnPhoneDialFailed", (object)this, (object)reason, (object)currentPlayer);
		}
	}

	public void ServerPlayAnsweringMessage(PhoneController fromPhone)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId arg = default(NetworkableId);
		uint num = 0u;
		uint arg2 = 0u;
		if ((Object)(object)activeCallTo != (Object)null && (Object)(object)activeCallTo.cachedCassette != (Object)null)
		{
			arg = activeCallTo.cachedCassette.net.ID;
			num = activeCallTo.cachedCassette.AudioId;
			if (num == 0)
			{
				arg2 = activeCallTo.cachedCassette.PreloadContent.GetSoundContentId(activeCallTo.cachedCassette.PreloadedAudio);
			}
		}
		if (((NetworkableId)(ref arg)).IsValid)
		{
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientPlayAnsweringMessage"), arg, num, arg2, fromPhone.HasVoicemailSlot() ? 1 : 0, activeCallTo.PhoneNumber);
			((FacepunchBehaviour)this).Invoke((Action)TriggerTimeOut, activeCallTo.cachedCassette.MaxCassetteLength);
		}
		else
		{
			OnDialFailed(Telephone.DialFailReason.TimedOut);
		}
	}

	private void TriggerTimeOut()
	{
		OnDialFailed(Telephone.DialFailReason.TimedOut);
	}

	public void SetPhoneStateWithPlayer(Telephone.CallState state)
	{
		serverState = state;
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("SetClientState"), (int)serverState, ((Object)(object)activeCallTo != (Object)null) ? activeCallTo.PhoneNumber : 0);
		if (base.baseEntity is MobilePhone mobilePhone)
		{
			mobilePhone.ToggleRinging(state == Telephone.CallState.Ringing);
		}
	}

	private void SetPhoneState(Telephone.CallState state)
	{
		if (state == Telephone.CallState.Idle && (Object)(object)currentPlayer == (Object)null)
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Busy, b: false);
		}
		serverState = state;
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("SetClientState"), (int)serverState, ((Object)(object)activeCallTo != (Object)null) ? activeCallTo.PhoneNumber : 0);
		if (base.baseEntity is Telephone telephone)
		{
			telephone.MarkDirtyForceUpdateOutputs();
		}
		if (base.baseEntity is MobilePhone mobilePhone)
		{
			mobilePhone.ToggleRinging(state == Telephone.CallState.Ringing);
		}
	}

	public void BeginCall()
	{
		if (Interface.CallHook("OnPhoneCallStart", (object)this, (object)activeCallTo, (object)currentPlayer) == null)
		{
			if (IsMobile && (Object)(object)activeCallTo != (Object)null && !activeCallTo.RequirePower)
			{
				_ = (Object)(object)currentPlayer != (Object)null;
			}
			SetPhoneStateWithPlayer(Telephone.CallState.InProcess);
			((FacepunchBehaviour)this).Invoke((Action)TimeOutCall, (float)TelephoneManager.MaxCallLength);
			Interface.CallHook("OnPhoneCallStarted", (object)this, (object)activeCallTo, (object)currentPlayer);
		}
	}

	public void ServerHangUp(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)currentPlayer))
		{
			ServerHangUp();
		}
	}

	public void ServerHangUp()
	{
		if ((Object)(object)activeCallTo != (Object)null)
		{
			activeCallTo.RemoteHangUp();
		}
		SelfHangUp();
	}

	private void SelfHangUp()
	{
		OnDialFailed(Telephone.DialFailReason.SelfHangUp);
	}

	private void RemoteHangUp()
	{
		OnDialFailed(Telephone.DialFailReason.RemoteHangUp);
	}

	private void TimeOutCall()
	{
		OnDialFailed(Telephone.DialFailReason.TimeOutDuringCall);
	}

	public void OnReceivedVoiceFromUser(byte[] data)
	{
		if ((Object)(object)activeCallTo != (Object)null)
		{
			activeCallTo.OnReceivedDataFromConnectedPhone(data);
		}
	}

	public void OnReceivedDataFromConnectedPhone(byte[] data)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity obj = base.baseEntity;
		SendInfo sendInfo = default(SendInfo);
		((SendInfo)(ref sendInfo))..ctor(BaseNetworkable.GetConnectionsWithin(((Component)this).transform.position, 15f));
		sendInfo.priority = (Priority)0;
		obj.ClientRPC(RpcTarget.SendInfo("OnReceivedVoice", sendInfo), data.Length, data);
	}

	public void OnIncomingCallWhileBusy()
	{
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnIncomingCallDuringCall"));
	}

	private void DestroyServer()
	{
		if (isServer && serverState != 0 && (Object)(object)activeCallTo != (Object)null)
		{
			activeCallTo.RemoteHangUp();
		}
	}

	public void UpdatePhoneName(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)currentPlayer))
		{
			string text = msg.read.String(256, false);
			if (text.Length > 30)
			{
				text = text.Substring(0, 30);
			}
			if (Interface.CallHook("OnPhoneNameUpdate", (object)this, (object)text, (object)msg.player) == null)
			{
				PhoneName = text;
				base.baseEntity.SendNetworkUpdate();
				Interface.CallHook("OnPhoneNameUpdated", (object)this, (object)PhoneName, (object)msg.player);
			}
		}
	}

	public void Server_RequestPhoneDirectory(BaseEntity.RPCMessage msg)
	{
		if ((Object)(object)msg.player != (Object)(object)currentPlayer)
		{
			return;
		}
		int page = msg.read.Int32();
		PhoneDirectory val = Pool.Get<PhoneDirectory>();
		try
		{
			TelephoneManager.GetPhoneDirectory(PhoneNumber, page, 12, val);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ReceivePhoneDirectory"), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Server_AddSavedNumber(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)currentPlayer))
		{
			if (savedNumbers == null)
			{
				savedNumbers = Pool.Get<PhoneDirectory>();
			}
			if (savedNumbers.entries == null)
			{
				savedNumbers.entries = Pool.Get<List<DirectoryEntry>>();
			}
			int num = msg.read.Int32();
			string text = msg.read.String(256, false);
			if (IsSavedContactValid(text, num) && savedNumbers.entries.Count < 10)
			{
				DirectoryEntry val = Pool.Get<DirectoryEntry>();
				val.phoneName = text;
				val.phoneNumber = num;
				val.ShouldPool = false;
				savedNumbers.ShouldPool = false;
				savedNumbers.entries.Add(val);
				base.baseEntity.SendNetworkUpdate();
			}
		}
	}

	public void Server_RemoveSavedNumber(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)currentPlayer))
		{
			uint number = msg.read.UInt32();
			if (savedNumbers.entries.RemoveAll((DirectoryEntry p) => p.phoneNumber == number) > 0)
			{
				base.baseEntity.SendNetworkUpdate();
			}
		}
	}

	public string GetDirectoryName()
	{
		return PhoneName;
	}

	public void WatchForDisconnects()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if ((Object)(object)currentPlayer != (Object)null)
		{
			if (currentPlayer.IsSleeping())
			{
				flag = true;
			}
			if (currentPlayer.IsDead())
			{
				flag = true;
			}
			if (Vector3.Distance(((Component)this).transform.position, ((Component)currentPlayer).transform.position) > 5f)
			{
				flag = true;
			}
		}
		else
		{
			flag = true;
		}
		if (flag)
		{
			ServerHangUp();
			ClearCurrentUser();
		}
	}

	public void OnParentChanged(BaseEntity newParent)
	{
		if ((Object)(object)newParent != (Object)null && newParent is BasePlayer)
		{
			TelephoneManager.RegisterTelephone(this, checkPhoneNumber: true);
		}
		else
		{
			TelephoneManager.DeregisterTelephone(this);
		}
	}

	private bool HasVoicemailSlot()
	{
		return MaxVoicemailSlots > 0;
	}

	public void ServerSendVoicemail(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player == (Object)null))
		{
			byte[] data = msg.read.BytesWithSize(10485760u, false);
			PhoneController telephone = TelephoneManager.GetTelephone(msg.read.Int32());
			if (!((Object)(object)telephone == (Object)null) && Cassette.IsOggValid(data, telephone.cachedCassette))
			{
				telephone.SaveVoicemail(data, msg.player.displayName);
			}
		}
	}

	public void SaveVoicemail(byte[] data, string playerName)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		uint audioId = FileStorage.server.Store(data, FileStorage.Type.ogg, base.baseEntity.net.ID);
		if (savedVoicemail == null)
		{
			savedVoicemail = Pool.Get<List<VoicemailEntry>>();
		}
		VoicemailEntry val = Pool.Get<VoicemailEntry>();
		val.audioId = audioId;
		val.timestamp = DateTime.Now.ToBinary();
		val.userName = playerName;
		val.ShouldPool = false;
		savedVoicemail.Add(val);
		while (savedVoicemail.Count > MaxVoicemailSlots)
		{
			FileStorage.server.Remove(savedVoicemail[0].audioId, FileStorage.Type.ogg, base.baseEntity.net.ID);
			savedVoicemail.RemoveAt(0);
		}
		base.baseEntity.SendNetworkUpdate();
	}

	public void ServerPlayVoicemail(BaseEntity.RPCMessage msg)
	{
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientToggleVoicemail"), 1, msg.read.UInt32());
	}

	public void ServerStopVoicemail(BaseEntity.RPCMessage msg)
	{
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientToggleVoicemail"), 0, 0);
	}

	public void ServerDeleteVoicemail(BaseEntity.RPCMessage msg)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		uint num = msg.read.UInt32();
		for (int i = 0; i < savedVoicemail.Count; i++)
		{
			if (savedVoicemail[i].audioId == num)
			{
				VoicemailEntry val = savedVoicemail[i];
				FileStorage.server.Remove(val.audioId, FileStorage.Type.ogg, base.baseEntity.net.ID);
				val.ShouldPool = true;
				Pool.Free<VoicemailEntry>(ref val);
				savedVoicemail.RemoveAt(i);
				base.baseEntity.SendNetworkUpdate();
				break;
			}
		}
	}

	public void DeleteAllVoicemail()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (savedVoicemail == null)
		{
			return;
		}
		foreach (VoicemailEntry item in savedVoicemail)
		{
			item.ShouldPool = true;
			FileStorage.server.Remove(item.audioId, FileStorage.Type.ogg, base.baseEntity.net.ID);
		}
		Pool.Free<VoicemailEntry>(ref savedVoicemail, false);
	}
}


using UnityEngine;

public class PreloadedCassetteContent : ScriptableObject
{
	public enum PreloadType
	{
		Short,
		Medium,
		Long
	}

	public SoundDefinition[] ShortTapeContent;

	public SoundDefinition[] MediumTapeContent;

	public SoundDefinition[] LongTapeContent;

	public SoundDefinition GetSoundContent(int index, PreloadType type)
	{
		return type switch
		{
			PreloadType.Short => GetDefinition(index, ShortTapeContent), 
			PreloadType.Medium => GetDefinition(index, MediumTapeContent), 
			PreloadType.Long => GetDefinition(index, LongTapeContent), 
			_ => null, 
		};
	}

	private SoundDefinition GetDefinition(int index, SoundDefinition[] array)
	{
		index = Mathf.Clamp(index, 0, array.Length);
		return array[index];
	}

	public uint GetSoundContentId(SoundDefinition def)
	{
		uint num = 0u;
		SoundDefinition[] shortTapeContent = ShortTapeContent;
		for (int i = 0; i < shortTapeContent.Length; i++)
		{
			if ((Object)(object)shortTapeContent[i] == (Object)(object)def)
			{
				return num;
			}
			num++;
		}
		shortTapeContent = MediumTapeContent;
		for (int i = 0; i < shortTapeContent.Length; i++)
		{
			if ((Object)(object)shortTapeContent[i] == (Object)(object)def)
			{
				return num;
			}
			num++;
		}
		shortTapeContent = LongTapeContent;
		for (int i = 0; i < shortTapeContent.Length; i++)
		{
			if ((Object)(object)shortTapeContent[i] == (Object)(object)def)
			{
				return num;
			}
			num++;
		}
		return num;
	}

	public SoundDefinition GetSoundContent(uint id)
	{
		int num = 0;
		SoundDefinition[] shortTapeContent = ShortTapeContent;
		foreach (SoundDefinition result in shortTapeContent)
		{
			if (num++ == id)
			{
				return result;
			}
		}
		shortTapeContent = MediumTapeContent;
		foreach (SoundDefinition result2 in shortTapeContent)
		{
			if (num++ == id)
			{
				return result2;
			}
		}
		shortTapeContent = LongTapeContent;
		foreach (SoundDefinition result3 in shortTapeContent)
		{
			if (num++ == id)
			{
				return result3;
			}
		}
		return null;
	}
}


public enum PreloadType
{
	Short,
	Medium,
	Long
}


using UnityEngine;

[CreateAssetMenu]
public class RadioPlaylist : BaseScriptableObject
{
	public string LocalName;

	public string Url;

	public AudioClip[] Playlist;

	public float PlaylistLength;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public static class TelephoneManager
{
	public const int MaxPhoneNumber = 99990000;

	public const int MinPhoneNumber = 10000000;

	[ServerVar]
	public static int MaxConcurrentCalls = 10;

	[ServerVar]
	public static int MaxCallLength = 120;

	public static Dictionary<int, PhoneController> allTelephones = new Dictionary<int, PhoneController>();

	public static int maxAssignedPhoneNumber = 99990000;

	public static int GetUnusedTelephoneNumber()
	{
		int num = Random.Range(10000000, 99990000);
		int num2 = 0;
		int num3 = 1000;
		while (allTelephones.ContainsKey(num) && num2 < num3)
		{
			num2++;
			num = Random.Range(10000000, 99990000);
		}
		if (num2 == num3)
		{
			num = maxAssignedPhoneNumber + 1;
		}
		maxAssignedPhoneNumber = Mathf.Max(maxAssignedPhoneNumber, num);
		return num;
	}

	public static void RegisterTelephone(PhoneController t, bool checkPhoneNumber = false)
	{
		if (checkPhoneNumber && allTelephones.ContainsKey(t.PhoneNumber) && (Object)(object)allTelephones[t.PhoneNumber] != (Object)(object)t)
		{
			t.PhoneNumber = GetUnusedTelephoneNumber();
		}
		if (!allTelephones.ContainsKey(t.PhoneNumber) && t.PhoneNumber != 0)
		{
			allTelephones.Add(t.PhoneNumber, t);
			maxAssignedPhoneNumber = Mathf.Max(maxAssignedPhoneNumber, t.PhoneNumber);
		}
	}

	public static void DeregisterTelephone(PhoneController t)
	{
		allTelephones.Remove(t.PhoneNumber);
	}

	public static PhoneController GetTelephone(int number)
	{
		return allTelephones.GetValueOrDefault(number);
	}

	public static PhoneController GetRandomTelephone(int ignoreNumber)
	{
		foreach (KeyValuePair<int, PhoneController> allTelephone in allTelephones)
		{
			if (allTelephone.Value.PhoneNumber != ignoreNumber)
			{
				return allTelephone.Value;
			}
		}
		return null;
	}

	public static int GetCurrentActiveCalls()
	{
		int num = 0;
		foreach (KeyValuePair<int, PhoneController> allTelephone in allTelephones)
		{
			if (allTelephone.Value.serverState != 0)
			{
				num++;
			}
		}
		if (num == 0)
		{
			return 0;
		}
		return num / 2;
	}

	public static void GetPhoneDirectory(int ignoreNumber, int page, int perPage, PhoneDirectory directory)
	{
		directory.entries = Pool.Get<List<DirectoryEntry>>();
		int startIndex = page * perPage;
		int count = 0;
		if (!AddPhonesToDirectory(playerOnly: true) && !AddPhonesToDirectory(playerOnly: false))
		{
			directory.atEnd = true;
		}
		bool AddPhonesToDirectory(bool playerOnly)
		{
			foreach (KeyValuePair<int, PhoneController> allTelephone in allTelephones)
			{
				if (allTelephone.Key != ignoreNumber && !string.IsNullOrEmpty(allTelephone.Value.PhoneName) && (!playerOnly || allTelephone.Value.CanModifyPhoneName) && (playerOnly || !allTelephone.Value.CanModifyPhoneName))
				{
					count++;
					if (count >= startIndex)
					{
						DirectoryEntry val = Pool.Get<DirectoryEntry>();
						val.phoneName = allTelephone.Value.GetDirectoryName();
						val.phoneNumber = allTelephone.Value.PhoneNumber;
						directory.entries.Add(val);
						if (directory.entries.Count >= perPage)
						{
							directory.atEnd = false;
							return true;
						}
					}
				}
			}
			return false;
		}
	}

	[ServerVar]
	public static void PrintAllPhones(Arg arg)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[3] { "Number", "Name", "Position" });
			foreach (KeyValuePair<int, PhoneController> allTelephone in allTelephones)
			{
				Vector3 position = ((Component)allTelephone.Value).transform.position;
				val.AddRow(new string[3]
				{
					allTelephone.Key.ToString(),
					allTelephone.Value.GetDirectoryName(),
					$"{position.x} {position.y} {position.z}"
				});
			}
			arg.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using UnityEngine;

public class AudioInterceptComponent : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class BaseCorpse : BaseCombatEntity, Hopper.IHopperTarget
{
	public GameObjectRef prefabRagdoll;

	public BaseEntity parentEnt;

	[NonSerialized]
	public ResourceDispenser resourceDispenser;

	public const float CORPSE_SLEEP_THRESHOLD = 0.05f;

	protected Rigidbody rigidBody;

	public bool blockDamageIfNotGather;

	public const Flags FLAG_HOPPERANIMATING = Flags.Reserved1;

	public const Flags FLAG_CORPSEBEINGCARRIED = Flags.Reserved3;

	[NonSerialized]
	public SpawnGroup spawnGroup;

	private const float RAGDOLL_PUSH_DIST = 0.5f;

	private const float RAGDOLL_PUSH_FORCE = 2.5f;

	public virtual bool CorpseIsRagdoll => false;

	public bool IsSleeping
	{
		get
		{
			if ((Object)(object)rigidBody != (Object)null)
			{
				return rigidBody.IsSleeping();
			}
			return false;
		}
	}

	public override TraitFlag Traits => base.Traits | TraitFlag.Food | TraitFlag.Meat;

	public BaseEntity ToEntity => this;

	public Rigidbody Rigidbody => rigidBody;

	public virtual int NumberOfItemsToTransfer
	{
		get
		{
			int num = 0;
			ResourceDispenser resourceDispenser = default(ResourceDispenser);
			if (((Component)this).TryGetComponent<ResourceDispenser>(ref resourceDispenser))
			{
				num += resourceDispenser.containedItems.Count;
			}
			return num;
		}
	}

	public float EndPositionToleranceMultiplier => 2f;

	public override void ResetState()
	{
		spawnGroup = null;
		base.ResetState();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		rigidBody = SetupRigidBody();
		ResetRemovalTime();
		resourceDispenser = ((Component)this).GetComponent<ResourceDispenser>();
		SingletonComponent<NpcFoodManager>.Instance.Add(this);
	}

	public virtual void ServerInitCorpse(BaseEntity pr, Vector3 posOnDeah, Quaternion rotOnDeath, BasePlayer.PlayerFlags playerFlagsOnDeath, ModelState modelState)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		parentEnt = pr;
		((Component)this).transform.SetPositionAndRotation(parentEnt.CenterPoint(), ((Component)parentEnt).transform.rotation);
		SpawnPointInstance component = ((Component)this).GetComponent<SpawnPointInstance>();
		if ((Object)(object)component != (Object)null)
		{
			spawnGroup = component.parentSpawnPointUser as SpawnGroup;
		}
	}

	public virtual bool CanRemove()
	{
		return true;
	}

	public void RemoveCorpse()
	{
		if (!CanRemove())
		{
			ResetRemovalTime();
		}
		else
		{
			Kill();
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer)
		{
			SingletonComponent<NpcFoodManager>.Instance.Remove(this);
		}
	}

	public void ResetRemovalTime(float dur)
	{
		TimeWarning val = TimeWarning.New("ResetRemovalTime", 0);
		try
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)RemoveCorpse))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)RemoveCorpse);
			}
			((FacepunchBehaviour)this).Invoke((Action)RemoveCorpse, dur);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual float GetRemovalTime()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null)
		{
			return activeGameMode.CorpseRemovalTime(this);
		}
		return Server.corpsedespawn;
	}

	public void ResetRemovalTime()
	{
		ResetRemovalTime(GetRemovalTime());
	}

	public override void Save(SaveInfo info)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.corpse = Pool.Get<Corpse>();
		if (parentEnt.IsValid())
		{
			info.msg.corpse.parentID = parentEnt.net.ID;
		}
	}

	public void TakeChildren(BaseEntity takeChildrenFrom)
	{
		if (takeChildrenFrom.children == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("Corpse.TakeChildren", 0);
		try
		{
			BaseEntity[] array = takeChildrenFrom.children.ToArray();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SwitchParent(this);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void ApplyInheritedVelocity(Vector3 velocity)
	{
	}

	private Rigidbody SetupRigidBody()
	{
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		if (!prefabRagdoll.isValid)
		{
			return ((Component)this).GetComponent<Rigidbody>();
		}
		if (base.isServer)
		{
			GameObject val = base.gameManager.FindPrefab(prefabRagdoll.resourcePath);
			if ((Object)(object)val == (Object)null)
			{
				return null;
			}
			Ragdoll component = val.GetComponent<Ragdoll>();
			if ((Object)(object)component == (Object)null)
			{
				return null;
			}
			if ((Object)(object)component.primaryBody == (Object)null)
			{
				Debug.LogError((object)("[BaseCorpse] ragdoll.primaryBody isn't set!" + ((Object)((Component)component).gameObject).name));
				return null;
			}
			if ((Object)(object)((Component)this).gameObject.GetComponent<Collider>() == (Object)null)
			{
				BoxCollider component2 = ((Component)component.primaryBody).GetComponent<BoxCollider>();
				if ((Object)(object)component2 == (Object)null)
				{
					Debug.LogError((object)"Ragdoll has unsupported primary collider (make it supported) ", (Object)(object)component);
					return null;
				}
				BoxCollider obj = ((Component)this).gameObject.AddComponent<BoxCollider>();
				obj.size = component2.size * 2f;
				obj.center = component2.center;
				((Collider)obj).sharedMaterial = ((Collider)component2).sharedMaterial;
			}
		}
		Rigidbody val2 = ((Component)this).GetComponent<Rigidbody>();
		if ((Object)(object)val2 == (Object)null)
		{
			val2 = ((Component)this).gameObject.AddComponent<Rigidbody>();
			val2.mass = 10f;
			val2.drag = 0.5f;
			val2.angularDrag = 0.5f;
		}
		val2.useGravity = true;
		val2.collisionDetectionMode = (CollisionDetectionMode)0;
		val2.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
		if (base.isServer)
		{
			Buoyancy component3 = ((Component)this).GetComponent<Buoyancy>();
			if ((Object)(object)component3 != (Object)null)
			{
				component3.rigidBody = val2;
			}
			Vector3 velocity = Vector3Ex.Range(-1f, 1f);
			velocity.y += 1f;
			val2.velocity = velocity;
			val2.collisionDetectionMode = (CollisionDetectionMode)3;
			val2.angularVelocity = Vector3Ex.Range(-10f, 10f);
		}
		return val2;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.corpse != null)
		{
			Load(info.msg.corpse);
		}
	}

	private void Load(Corpse corpse)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			parentEnt = BaseNetworkable.serverEntities.Find(corpse.parentID) as BaseEntity;
		}
		_ = base.isClient;
	}

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isServer)
		{
			return;
		}
		ResetRemovalTime();
		if (!blockDamageIfNotGather || !(info.Weapon is BaseMelee baseMelee) || baseMelee.GetGatherInfoFromIndex(ResourceDispenser.GatherType.Flesh).gatherDamage != 0f)
		{
			if (Object.op_Implicit((Object)(object)resourceDispenser))
			{
				resourceDispenser.DoGather(info, this);
			}
			if (!info.DidGather)
			{
				base.OnAttacked(info);
			}
			if (CorpseIsRagdoll)
			{
				PushRagdoll(info);
			}
		}
	}

	protected virtual void PushRagdoll(HitInfo info)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		List<Rigidbody> list = Pool.Get<List<Rigidbody>>();
		Vis.Components<Rigidbody>(info.HitPositionWorld, 0.5f, list, 512, (QueryTriggerInteraction)2);
		PushRigidbodies(list, info.HitPositionWorld, info.attackNormal);
		Pool.FreeUnmanaged<Rigidbody>(ref list);
	}

	protected void PushRigidbodies(List<Rigidbody> rbs, Vector3 hitPos, Vector3 hitNormal)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		foreach (Rigidbody rb in rbs)
		{
			float num = Vector3.Distance(hitPos, rb.position);
			float num2 = 1f - Mathf.InverseLerp(0f, 0.5f, num);
			if (!(num2 <= 0f))
			{
				if (num2 < 0.5f)
				{
					num2 = 0.5f;
				}
				rb.AddForceAtPosition(hitNormal * 2.5f * num2, hitPos, (ForceMode)1);
			}
		}
	}

	public override string Categorize()
	{
		return "corpse";
	}

	public override void Eat(BaseNpc baseNpc, float timeSpent)
	{
		ResetRemovalTime();
		Hurt(timeSpent * 5f);
		baseNpc.AddCalories(timeSpent * 2f);
	}

	public void PrepareForHopper()
	{
		SetFlag(Flags.Reserved1, b: true);
		Collider val = default(Collider);
		if (((Component)this).TryGetComponent<Collider>(ref val))
		{
			val.enabled = false;
		}
	}

	public void HopperCancelled()
	{
		SetFlag(Flags.Reserved1, b: false);
		Collider val = default(Collider);
		if (((Component)this).TryGetComponent<Collider>(ref val))
		{
			val.enabled = true;
		}
	}

	public virtual void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 fallbackWorldPos)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		ResourceDispenser resourceDispenser = default(ResourceDispenser);
		if (((Component)this).TryGetComponent<ResourceDispenser>(ref resourceDispenser))
		{
			foreach (ItemAmount containedItem in resourceDispenser.containedItems)
			{
				Item item = ItemManager.Create(containedItem.itemDef, (int)containedItem.amount, 0uL);
				resourceDispenser.OverrideOwnership(item, null);
				if (!item.MoveToContainer(itemContainer))
				{
					item.Drop(fallbackWorldPos, Vector3.zero, Quaternion.identity);
				}
			}
		}
		Kill();
	}

	public override bool ShouldInheritNetworkGroup()
	{
		return false;
	}
}


using UnityEngine;

public static class BaseEntityEx
{
	public static bool IsValidEntityReference<T>(this T obj) where T : class
	{
		return (Object)(object)(obj as BaseEntity) != (Object)null;
	}

	public static bool HasEntityInParents(this BaseEntity ent, BaseEntity toFind)
	{
		if ((Object)(object)ent == (Object)null || (Object)(object)toFind == (Object)null)
		{
			return false;
		}
		if ((Object)(object)ent == (Object)(object)toFind || ent.EqualNetID((BaseNetworkable)toFind))
		{
			return true;
		}
		BaseEntity parentEntity = ent.GetParentEntity();
		while ((Object)(object)parentEntity != (Object)null)
		{
			if ((Object)(object)parentEntity == (Object)(object)toFind || parentEntity.EqualNetID((BaseNetworkable)toFind))
			{
				return true;
			}
			parentEntity = parentEntity.GetParentEntity();
		}
		return false;
	}
}


public interface IServerFileReceiver
{
}


using ConVar;
using Oxide.Core;
using UnityEngine;

public class AttackEntity : HeldEntity
{
	[Header("Attack Entity")]
	public float deployDelay = 1f;

	public float repeatDelay = 0.5f;

	public float animationDelay;

	[Header("NPCUsage")]
	public float effectiveRange = 1f;

	public float npcDamageScale = 1f;

	public float attackLengthMin = -1f;

	public float attackLengthMax = -1f;

	public float attackSpacing;

	public float aiAimSwayOffset;

	public float aiAimCone;

	public bool aiOnlyInRange;

	public float CloseRangeAddition;

	public float MediumRangeAddition;

	public float LongRangeAddition;

	public bool CanUseAtMediumRange = true;

	public bool CanUseAtLongRange = true;

	public SoundDefinition[] reloadSounds;

	public SoundDefinition thirdPersonMeleeSound;

	[Header("Recoil Compensation")]
	public float recoilCompDelayOverride;

	public bool wantsRecoilComp;

	public bool showCrosshairOnTutorial;

	public bool noHeadshots;

	public EncryptedValue<float> nextAttackTime = float.NegativeInfinity;

	public float NextAttackTime => nextAttackTime;

	public virtual Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.zero;
	}

	public virtual float AmmoFraction()
	{
		return 0f;
	}

	public virtual bool CanReload()
	{
		return false;
	}

	public virtual bool ServerIsReloading()
	{
		return false;
	}

	public virtual void ServerReload()
	{
	}

	public virtual bool ServerTryReload(IAmmoContainer ammoSource)
	{
		return true;
	}

	public virtual void TopUpAmmo()
	{
	}

	public virtual Vector3 ModifyAIAim(Vector3 eulerInput, float swayModifier = 1f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return eulerInput;
	}

	public virtual void GetAttackStats(HitInfo info)
	{
	}

	public void StartAttackCooldownRaw(float cooldown)
	{
		nextAttackTime = Time.time + cooldown;
	}

	public void StartAttackCooldown(float cooldown)
	{
		nextAttackTime = CalculateCooldownTime(nextAttackTime, cooldown, catchup: true, unscaledTime: false);
	}

	public void ResetAttackCooldown()
	{
		nextAttackTime = float.NegativeInfinity;
	}

	public bool HasAttackCooldown()
	{
		return Time.time < (float)nextAttackTime;
	}

	protected float GetAttackCooldown()
	{
		return Mathf.Max((float)nextAttackTime - Time.time, 0f);
	}

	protected float GetAttackIdle()
	{
		return Mathf.Max(Time.time - (float)nextAttackTime, 0f);
	}

	protected float CalculateCooldownTime(float nextTime, float cooldown, bool catchup, bool unscaledTime)
	{
		float num = (unscaledTime ? Time.unscaledTime : Time.time);
		float num2 = 0f;
		if (base.isServer)
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			num2 += 0.1f;
			num2 += cooldown * 0.1f;
			num2 += (Object.op_Implicit((Object)(object)ownerPlayer) ? ownerPlayer.desyncTimeClamped : 0.1f);
			num2 += Mathf.Max(Time.deltaTime, Time.smoothDeltaTime);
		}
		nextTime = ((nextTime < 0f) ? Mathf.Max(0f, num + cooldown - num2) : ((!(num - nextTime <= num2)) ? Mathf.Max(nextTime + cooldown, num + cooldown - num2) : Mathf.Min(nextTime + cooldown, num + cooldown)));
		return nextTime;
	}

	protected bool VerifyClientRPC(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			Debug.LogWarning((object)"Received RPC from null player");
			return false;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Owner not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "owner_missing");
			return false;
		}
		if ((Object)(object)ownerPlayer != (Object)(object)player)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "player_mismatch");
			return false;
		}
		if (player.IsDead())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player dead (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "player_dead");
			return false;
		}
		if (player.IsWounded())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player down (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "player_down");
			return false;
		}
		if (player.IsSleeping())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player sleeping (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "player_sleeping");
			return false;
		}
		if (player.desyncTimeRaw > ConVar.AntiHack.maxdesync)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player stalled (" + base.ShortPrefabName + " with " + player.desyncTimeRaw + "s)");
			player.stats.combat.LogInvalid(player, this, "player_stalled");
			return false;
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Item not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "item_missing");
			return false;
		}
		if (ownerItem.isBroken)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Item broken (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "item_broken");
			return false;
		}
		return true;
	}

	protected virtual bool VerifyClientAttack(BasePlayer player)
	{
		if (!VerifyClientRPC(player))
		{
			return false;
		}
		if (HasAttackCooldown())
		{
			AntiHack.Log(player, AntiHackType.CooldownHack, "T-" + GetAttackCooldown() + "s (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "attack_cooldown");
			return false;
		}
		return true;
	}

	protected bool ValidateEyePos(BasePlayer player, Vector3 eyePos, bool checkLineOfSight = true)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0421: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0462: Unknown result type (might be due to invalid IL or missing references)
		//IL_0464: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnEyePosValidate", (object)this, (object)player, (object)eyePos, (object)checkLineOfSight);
		if (obj is bool)
		{
			return (bool)obj;
		}
		bool flag = true;
		if (Vector3Ex.IsNaNOrInfinity(eyePos))
		{
			string shortPrefabName = base.ShortPrefabName;
			AntiHack.Log(player, AntiHackType.EyeHack, "Contains NaN (" + shortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "eye_nan");
			flag = false;
		}
		if (ConVar.AntiHack.eye_protection > 0)
		{
			Vector3 val;
			if (ConVar.AntiHack.eye_protection >= 1)
			{
				val = player.GetParentVelocity();
				float magnitude = ((Vector3)(ref val)).magnitude;
				val = player.GetMountVelocity();
				float num = magnitude + ((Vector3)(ref val)).magnitude;
				float num2 = ((((player.HasParent() || player.isMounted) ? ConVar.AntiHack.eye_distance_parented_mounted_forgiveness : 0f) + player.estimatedSpeed > 0f) ? ConVar.AntiHack.eye_forgiveness : 0f);
				float num3 = num + num2;
				float num4 = player.tickHistory.Distance(player, eyePos);
				if (num4 > num3)
				{
					string shortPrefabName2 = base.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.EyeHack, "Distance (" + shortPrefabName2 + " on attack with " + num4 + "m > " + num3 + "m)");
					player.stats.combat.LogInvalid(player, this, "eye_distance");
					flag = false;
				}
			}
			if (ConVar.AntiHack.eye_protection >= 3)
			{
				float num5 = Mathf.Abs(player.GetMountVelocity().y + player.GetParentVelocity().y) + BasePlayer.GetJumpHeight();
				float num6 = Mathf.Abs(player.eyes.position.y - eyePos.y);
				if (num6 > num5)
				{
					string shortPrefabName3 = base.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.EyeHack, "Altitude (" + shortPrefabName3 + " on attack with " + num6 + "m > " + num5 + "m)");
					player.stats.combat.LogInvalid(player, this, "eye_altitude");
					flag = false;
				}
			}
			if (checkLineOfSight)
			{
				int num7 = 2162688;
				if (ConVar.AntiHack.eye_terraincheck)
				{
					num7 |= 0x800000;
				}
				if (ConVar.AntiHack.eye_vehiclecheck)
				{
					num7 |= 0x8000000;
				}
				if (ConVar.AntiHack.eye_protection >= 2)
				{
					Vector3 center = player.eyes.center;
					Vector3 position = player.eyes.position;
					if (!GamePhysics.LineOfSightRadius(center, position, num7, ConVar.AntiHack.eye_losradius) || !GamePhysics.LineOfSightRadius(position, eyePos, num7, ConVar.AntiHack.eye_losradius))
					{
						string shortPrefabName4 = base.ShortPrefabName;
						string[] obj2 = new string[8] { "Line of sight (", shortPrefabName4, " on attack) ", null, null, null, null, null };
						val = center;
						obj2[3] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						obj2[4] = " ";
						val = position;
						obj2[5] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						obj2[6] = " ";
						val = eyePos;
						obj2[7] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						AntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj2));
						player.stats.combat.LogInvalid(player, this, "eye_los");
						flag = false;
					}
				}
				if (ConVar.AntiHack.eye_protection >= 4 && !player.HasParent())
				{
					Vector3 position2 = player.eyes.position;
					float num8 = Vector3.Distance(position2, eyePos);
					Collider col;
					if (num8 > ConVar.AntiHack.eye_noclip_cutoff)
					{
						if (AntiHack.TestNoClipping(player, position2, eyePos, BasePlayer.NoClipRadius(ConVar.AntiHack.eye_noclip_margin), ConVar.AntiHack.eye_noclip_backtracking, out col, vehicleLayer: false, null, forceCast: true))
						{
							string shortPrefabName5 = base.ShortPrefabName;
							string[] obj3 = new string[6] { "NoClip (", shortPrefabName5, " on attack) ", null, null, null };
							val = position2;
							obj3[3] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
							obj3[4] = " ";
							val = eyePos;
							obj3[5] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
							AntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj3));
							player.stats.combat.LogInvalid(player, this, "eye_noclip");
							flag = false;
						}
					}
					else if (num8 > 0.01f && AntiHack.TestNoClipping(player, position2, eyePos, 0.1f, ConVar.AntiHack.eye_noclip_backtracking, out col, vehicleLayer: false, null, forceCast: true))
					{
						string shortPrefabName6 = base.ShortPrefabName;
						string[] obj4 = new string[6] { "NoClip (", shortPrefabName6, " on attack) ", null, null, null };
						val = position2;
						obj4[3] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						obj4[4] = " ";
						val = eyePos;
						obj4[5] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						AntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj4));
						player.stats.combat.LogInvalid(player, this, "eye_noclip");
						flag = false;
					}
				}
			}
			if (!flag)
			{
				AntiHack.AddViolation(player, AntiHackType.EyeHack, ConVar.AntiHack.eye_penalty);
			}
			else if (ConVar.AntiHack.eye_protection >= 5 && !player.HasParent() && !player.isMounted)
			{
				player.eyeHistory.PushBack(eyePos);
			}
		}
		return flag;
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		StartAttackCooldown(deployDelay * 0.9f);
	}
}


public static class FishStateExtensions
{
	public static bool Contains(this BaseFishingRod.FishState state, BaseFishingRod.FishState check)
	{
		return (state & check) == check;
	}

	public static BaseFishingRod.FishState FlipHorizontal(this BaseFishingRod.FishState state)
	{
		if (state.Contains(BaseFishingRod.FishState.PullingLeft))
		{
			state |= BaseFishingRod.FishState.PullingRight;
			state &= ~BaseFishingRod.FishState.PullingLeft;
		}
		else if (state.Contains(BaseFishingRod.FishState.PullingRight))
		{
			state |= BaseFishingRod.FishState.PullingLeft;
			state &= ~BaseFishingRod.FishState.PullingRight;
		}
		return state;
	}
}


public class Binocular : AttackEntity
{
	public float[] fovs;

	public GameObjectRef fovChangeEffect;

	public float smoothSpeed = 0.05f;
}


public class BlowPipeWeapon : BaseProjectile
{
	public override bool ForceSendMagazine(SaveInfo saveInfo)
	{
		return true;
	}

	public override void DidAttackServerside()
	{
		SendNetworkUpdateImmediate();
	}
}


public static class ArrowItemDefinitions
{
	private static ItemDefinition _woodenArrowItemDef;

	private static ItemDefinition _boneArrowItemDef;

	private static ItemDefinition _fireArrowItemDef;

	private static ItemDefinition _hvArrowItemDef;

	private static ItemDefinition _poisonArrowItemDef;

	private static ItemDefinition _stoneArrowItemDef;

	public static ItemDefinition WoodenArrowItemDef => _woodenArrowItemDef ?? (_woodenArrowItemDef = ItemManager.FindItemDefinition("ammo_arrow"));

	public static ItemDefinition BoneArrowItemDef => _boneArrowItemDef ?? (_boneArrowItemDef = ItemManager.FindItemDefinition("arrow.bone"));

	public static ItemDefinition FireArrowItemDef => _fireArrowItemDef ?? (_fireArrowItemDef = ItemManager.FindItemDefinition("arrow.fire"));

	public static ItemDefinition HvArrowItemDef => _hvArrowItemDef ?? (_hvArrowItemDef = ItemManager.FindItemDefinition("arrow.hv"));

	public static ItemDefinition PoisonArrowItemDef => _poisonArrowItemDef ?? (_poisonArrowItemDef = ItemManager.FindItemDefinition("ammo_arrow_poison"));

	public static ItemDefinition StoneArrowItemDef => _stoneArrowItemDef ?? (_stoneArrowItemDef = ItemManager.FindItemDefinition("ammo_arrow_stone"));
}


using UnityEngine;

public class Compass : HeldEntity
{
	private const string WORLDMODEL_NEEDLE_PATH = "w_compass_rig/weapon_parent/weapon_root/needle";

	private const string ADMIRE_ANIMEVENT_TAP1 = "AdmireTap1";

	private const string ADMIRE_ANIMEVENT_TAP2 = "AdmireTap2";

	[Tooltip("Change this if it does not feel like the needle direction is accurate.")]
	[SerializeField]
	[Header("Compass")]
	private float needleYawAngleOffset;

	[Min(0f)]
	[SerializeField]
	private float needleStiffness = 50f;

	[Range(0f, 1f)]
	[SerializeField]
	private float needleDamping = 0.5f;

	[Min(0f)]
	[SerializeField]
	private float maxAcceleration = 1500f;

	[SerializeField]
	[Min(0f)]
	private float maxSpeed = 360f;

	[SerializeField]
	[MinMax(0f, 180f)]
	[Tooltip("Random variance in how far off the needle will be from target when first deployed.")]
	private MinMax startingAngleDelta;

	[SerializeField]
	private float wiggleAmplitude = 0.5f;

	[SerializeField]
	private float wiggleFrequency = 1.5f;

	[SerializeField]
	[Min(0f)]
	[Tooltip("Velocity change when the admire animation taps the needle")]
	private float admireTapNeedleVelocity = 300f;
}


public class CrossbowWeapon : BaseProjectile
{
	public override bool ForceSendMagazine(SaveInfo saveInfo)
	{
		return true;
	}

	public override void DidAttackServerside()
	{
		SendNetworkUpdateImmediate();
	}
}


using UnityEngine;

public class FlintStrikeWeapon : BaseProjectile
{
	public float successFraction = 0.5f;

	[Tooltip("By how much do we increase the chance of firing after each failed strike")]
	public float successIncrease = 0.075f;

	public RecoilProperties strikeRecoil;

	public override RecoilProperties GetRecoil()
	{
		return strikeRecoil;
	}
}


using UnityEngine;

public class GeigerCounter : AttackEntity
{
	public Transform geigerRod;

	public Transform leftHand;

	public string attachmentBone;

	public string leftHandBone;
}


public class GrenadeWeapon : ThrownWeapon
{
}


using System;
using Oxide.Core;
using UnityEngine;

public class Hammer : BaseMelee
{
	public override bool CanHit(HitTest info)
	{
		if ((Object)(object)info.HitEntity == (Object)null)
		{
			return false;
		}
		if (info.HitEntity is BasePlayer)
		{
			return false;
		}
		return info.HitEntity is BaseCombatEntity;
	}

	public override void DoAttackShared(HitInfo info)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		BaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity != (Object)null && (Object)(object)ownerPlayer != (Object)null && base.isServer)
		{
			if (Interface.CallHook("OnHammerHit", (object)ownerPlayer, (object)info) != null)
			{
				return;
			}
			TimeWarning val = TimeWarning.New("DoRepair", 50);
			try
			{
				baseCombatEntity.DoRepair(ownerPlayer);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		info.DoDecals = false;
		if (base.isServer)
		{
			Effect.server.ImpactEffect(info);
		}
		else
		{
			Effect.client.ImpactEffect(info);
		}
		StartAttackCooldown(repeatDelay);
	}
}


using UnityEngine;

public class InstrumentToolGuitar : InstrumentTool
{
	public Transform InUseAligner;

	public Transform DeployAligner;

	public string DeployBone;
}


public interface ITurretNotify
{
	void WarmupTick(bool wantsShoot);

	bool CanShoot();

	void OnAddedRemovedToTurret(bool added);
}


using UnityEngine;

public class Keycard : AttackEntity
{
	public int accessLevel
	{
		get
		{
			Item item = GetItem();
			if (item == null)
			{
				return 0;
			}
			ItemModKeycard component = ((Component)item.info).GetComponent<ItemModKeycard>();
			if ((Object)(object)component == (Object)null)
			{
				return 0;
			}
			return component.accessLevel;
		}
	}
}


using UnityEngine;

public class LiquidWeaponEffects : MonoBehaviour
{
	public ParticleSystem RootPS;

	public ParticleSystem EmissionPS;

	public ParticleSystem InnerEmissionPS;

	public LiquidWobble Liquid;

	[Header("Main Stream")]
	public float MinPressureSpeed = 1f;

	public float MaxPressureSpeed = 20f;

	public AnimationCurve PressureSpeedCurve;

	public Vector2 StreamSize = new Vector2(0.04f, 0.08f);

	public AnimationCurve PressureSizeMultiplierCurve;

	[Header("Inner Stream")]
	public float MinPressureInnerSpeed = 1f;

	public float MaxPressureInnerSpeed = 20f;

	public AnimationCurve InnerPressureSpeedCurve;

	public Vector2 InnerStreamSize = new Vector2(0.02f, 0.02f);

	public AnimationCurve InnerPressureSizeMultiplierCurve;

	[Header("Misc")]
	public bool UseImpactSplashEffect;

	public GameObjectRef ImpactSplashEffect;

	public float ImpactSplashEffectInterval = 0.1f;

	public float FillSpeed = 1f;

	[Header("Audio")]
	public bool firstPersonSounds;

	public SoundDefinition shootStartSoundDef;

	public SoundDefinition shootLoopSoundDef;

	public SoundDefinition shootLowPressureLoopSoundDef;

	public SoundDefinition impactStartSoundDef;

	public SoundDefinition impactLoopSoundDef;
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class LockOnLauncher : BaseLauncher
{
	[SerializeField]
	public float lockRange = 250f;

	[SerializeField]
	public float lockConeDot = 0.8f;

	[SerializeField]
	public float timeToLock = 2f;

	[SerializeField]
	private float currentLockTime;

	[SerializeField]
	public float timeToLoseLock = 1f;

	[SerializeField]
	private GameObjectRef camUIDialogPrefab;

	private SeekerTarget currentLockTarget;

	private SeekingServerProjectile projectile;

	private float lockTickRate = 0.1f;

	private float lastSentLockTime;

	private bool HasProjectile => (Object)(object)projectile != (Object)null;

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		currentLockTarget = null;
		currentLockTime = 0f;
		if (IsDisabled())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateLockedEntity);
			SetFlag(Flags.Reserved9, b: false);
			SetFlag(Flags.Reserved10, b: false);
			LetExistingProjectileGo();
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateLockedEntity, 0f, lockTickRate);
		}
	}

	public virtual bool CanLock()
	{
		if (!Object.op_Implicit((Object)(object)GetOwnerPlayer()))
		{
			return false;
		}
		if (!HasProjectile)
		{
			if (CanAttack())
			{
				return primaryMagazine.contents > 0;
			}
			return false;
		}
		return true;
	}

	public void UpdateLockedEntity()
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null && (ownerPlayer.IsSleeping() || ownerPlayer.IsDead()))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateLockedEntity);
			SetFlag(Flags.Reserved9, b: false);
			SetFlag(Flags.Reserved10, b: false);
		}
		else
		{
			if ((Object)(object)ownerPlayer == (Object)null || ownerPlayer.IsSleeping() || ownerPlayer.IsDead() || ownerPlayer.IsWounded())
			{
				return;
			}
			SeekerTarget seekerTarget = null;
			if (CanLock())
			{
				seekerTarget = SeekerTarget.GetBestForPoint(ownerPlayer.eyes.position, ownerPlayer.eyes.BodyForward(), lockConeDot, lockRange);
			}
			else
			{
				currentLockTime = 0f;
			}
			if (seekerTarget == null)
			{
				float num = timeToLock / timeToLoseLock;
				currentLockTime -= lockTickRate * num;
				if (currentLockTime == 0f)
				{
					currentLockTarget = null;
				}
			}
			if (seekerTarget != null && currentLockTarget != null && seekerTarget != currentLockTarget)
			{
				currentLockTime = 0f;
			}
			currentLockTarget = seekerTarget;
			if (currentLockTarget != null)
			{
				currentLockTime += lockTickRate;
				currentLockTarget.SendOwnerMessage(this, "RadarWarning");
			}
			currentLockTime = Mathf.Clamp(currentLockTime, 0f, timeToLock);
			if (currentLockTime != lastSentLockTime)
			{
				SendNetworkUpdate();
			}
			SetFlag(Flags.Reserved9, currentLockTarget != null);
			SetFlag(Flags.Reserved10, currentLockTime >= timeToLock);
			if (HasProjectile)
			{
				projectile.lockedTarget = ((currentLockTarget != null && HasLock()) ? currentLockTarget : null);
			}
			SetFlag(Flags.Busy, HasProjectile);
		}
	}

	public bool HasTarget()
	{
		return HasFlag(Flags.Reserved9);
	}

	protected override void OnReloadStarted()
	{
		LetExistingProjectileGo();
	}

	public override void ProjectileLaunched_Server(ServerProjectile justLaunched)
	{
		base.ProjectileLaunched_Server(justLaunched);
		SeekingServerProjectile component = ((Component)justLaunched).GetComponent<SeekingServerProjectile>();
		component.lockedTarget = currentLockTarget;
		LetExistingProjectileGo();
		projectile = component;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.ioEntity = Pool.Get<IOEntity>();
			info.msg.ioEntity.genericFloat1 = currentLockTime;
			lastSentLockTime = currentLockTime;
		}
	}

	private void LetExistingProjectileGo()
	{
		if (HasProjectile)
		{
			projectile.NotifyOrphaned();
			projectile = null;
		}
	}

	public bool HasLock()
	{
		return HasFlag(Flags.Reserved10);
	}
}


public class MolotovCocktail : GrenadeWeapon
{
}


public class Paddle : BaseMelee
{
	public float animPaddleCooldown = 0.5f;

	public GameObjectRef kayakSeat;

	public float animationLerpSpeed = 6f;
}


using UnityEngine;

public class Speargun : CrossbowWeapon
{
	public GameObject worldAmmoModel;

	public override bool ForceSendMagazine(SaveInfo saveInfo)
	{
		return true;
	}

	protected override bool VerifyClientAttack(BasePlayer player)
	{
		if (player.WaterFactor() < 1f)
		{
			return false;
		}
		return base.VerifyClientAttack(player);
	}

	public override bool CanBeUsedInWater()
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SpinUpWeaponSounds : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class GunshotLayer
	{
		public SoundDefinition startDef;

		public SoundDefinition loopDef;

		public SoundDefinition stopDef;
	}

	public SoundDefinition spinStartDef;

	public SoundDefinition spinReleaseDef;

	public SoundDefinition spinStopDef;

	public SoundDefinition spinLoopUnpitchedDef;

	public SoundDefinition spinLoopPitchedDef;

	public AnimationCurve spinUnpitchedGainCurve;

	public AnimationCurve spinPitchedGainCurve;

	public AnimationCurve spinPitchCurve;

	public AnimationCurve spinPitchedGainCurveDown;

	public AnimationCurve spinPitchCurveDown;

	public List<GunshotLayer> gunshotLayers = new List<GunshotLayer>();
}


using System;

[Serializable]
public class GunshotLayer
{
	public SoundDefinition startDef;

	public SoundDefinition loopDef;

	public SoundDefinition stopDef;
}


using System.Collections.Generic;
using Facepunch;
using Network;

public struct RpcTarget
{
	public string Function;

	public SendInfo Connections;

	public bool ToNetworkGroup;

	public bool UsingPooledConnections;

	public static RpcTarget NetworkGroup(string funcName)
	{
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.ToNetworkGroup = true;
		return result;
	}

	public static RpcTarget NetworkGroup(string funcName, BaseNetworkable entity)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.Connections = new SendInfo(entity.net.group.subscribers);
		return result;
	}

	public static RpcTarget NetworkGroup(string funcName, BaseNetworkable entity, SendMethod method, Priority priority)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		SendInfo connections = default(SendInfo);
		((SendInfo)(ref connections))..ctor(entity.net.group.subscribers);
		connections.method = method;
		connections.priority = priority;
		result.Connections = connections;
		return result;
	}

	public static RpcTarget Player(string funcName, BasePlayer target)
	{
		return Player(funcName, target.IsValid() ? target.net.connection : null);
	}

	public static RpcTarget Player(string funcName, Connection connection)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.Connections = new SendInfo(connection);
		return result;
	}

	public static RpcTarget Players(string funcName, List<Connection> connections)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.Connections = new SendInfo(connections);
		return result;
	}

	public static RpcTarget Players(string funcName, List<Connection> connections, SendMethod method, Priority priority)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		SendInfo connections2 = default(SendInfo);
		((SendInfo)(ref connections2))..ctor(connections);
		connections2.method = method;
		connections2.priority = priority;
		result.Connections = connections2;
		return result;
	}

	public static RpcTarget SendInfo(string funcName, SendInfo sendInfo)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.Connections = sendInfo;
		return result;
	}

	public static RpcTarget PlayerAndSpectators(string funcName, BasePlayer player)
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		List<Connection> list = Pool.Get<List<Connection>>();
		if (player.IsValid())
		{
			if (player.net.connection != null)
			{
				list.Add(player.net.connection);
			}
			if (player.IsBeingSpectated && player.children != null)
			{
				foreach (BaseEntity child in player.children)
				{
					if (child is BasePlayer basePlayer)
					{
						list.Add(basePlayer.net.connection);
					}
				}
			}
		}
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.Connections = new SendInfo(list);
		result.UsingPooledConnections = true;
		return result;
	}
}


using System;
using Rust;
using Rust.Registry;
using UnityEngine;

public class BaseEntityChild : MonoBehaviour
{
	public static void Setup(GameObject obj, BaseEntity parent)
	{
		TimeWarning val = TimeWarning.New("Registry.Entity.Register", 0);
		try
		{
			Entity.Register(obj, (IEntity)(object)parent);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnDestroy()
	{
		if (Application.isQuitting)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("Registry.Entity.Unregister", 0);
		try
		{
			Entity.Unregister(((Component)this).gameObject);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Network;
using Network.Visibility;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Registry;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;
using UnityEngine.Assertions;

public abstract class BaseNetworkable : BaseMonoBehaviour, IEntity, NetworkHandler, IPrefabPostProcess
{
	public struct SaveInfo
	{
		public Entity msg;

		public bool forDisk;

		public bool forTransfer;

		public Connection forConnection;

		internal bool SendingTo(Connection ownerConnection)
		{
			if (ownerConnection == null)
			{
				return false;
			}
			if (forConnection == null)
			{
				return false;
			}
			return forConnection == ownerConnection;
		}
	}

	public struct LoadInfo
	{
		public Entity msg;

		public bool fromDisk;

		public bool fromCopy;

		public bool fromTransfer;
	}

	public class EntityRealmServer : EntityRealm
	{
		protected override Manager visibilityManager
		{
			get
			{
				if (Net.sv == null)
				{
					return null;
				}
				return Net.sv.visibility;
			}
		}
	}

	public abstract class EntityRealm : IEnumerable<BaseNetworkable>, IEnumerable
	{
		public HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>> entityList = new HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>>(new ListDictionary<NetworkableId, BaseNetworkable>());

		public int Count => entityList.Get().Count;

		protected abstract Manager visibilityManager { get; }

		public bool Contains(NetworkableId uid)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return entityList.Get().Contains(uid);
		}

		public BaseNetworkable Find(NetworkableId uid)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			BaseNetworkable result = null;
			if (!entityList.Get().TryGetValue(uid, ref result))
			{
				return null;
			}
			return result;
		}

		public void RegisterID(BaseNetworkable ent)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			if (ent.net != null)
			{
				ListDictionary<NetworkableId, BaseNetworkable> val = entityList.Get();
				if (val.Contains(ent.net.ID))
				{
					val[ent.net.ID] = ent;
				}
				else
				{
					val.Add(ent.net.ID, ent);
				}
			}
		}

		public void UnregisterID(BaseNetworkable ent)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if (ent.net != null)
			{
				entityList.Get().Remove(ent.net.ID);
			}
		}

		public Group FindGroup(uint uid)
		{
			Manager val = visibilityManager;
			if (val == null)
			{
				return null;
			}
			return val.Get(uid);
		}

		public Group TryFindGroup(uint uid)
		{
			Manager val = visibilityManager;
			if (val == null)
			{
				return null;
			}
			return val.TryGet(uid);
		}

		public void FindInGroup(uint uid, List<BaseNetworkable> list)
		{
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			Group val = TryFindGroup(uid);
			if (val == null)
			{
				return;
			}
			int count = val.networkables.Values.Count;
			Networkable[] buffer = val.networkables.Values.Buffer;
			for (int i = 0; i < count; i++)
			{
				Networkable val2 = buffer[i];
				BaseNetworkable baseNetworkable = Find(val2.ID);
				if (!((Object)(object)baseNetworkable == (Object)null) && baseNetworkable.net != null && baseNetworkable.net.group != null)
				{
					if (baseNetworkable.net.group.ID != uid)
					{
						Debug.LogWarning((object)("Group ID mismatch: " + ((object)baseNetworkable).ToString()));
					}
					else
					{
						list.Add(baseNetworkable);
					}
				}
			}
		}

		public Enumerator<BaseNetworkable> GetEnumerator()
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			return entityList.Get().Values.GetEnumerator();
		}

		IEnumerator<BaseNetworkable> IEnumerable<BaseNetworkable>.GetEnumerator()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return (IEnumerator<BaseNetworkable>)(object)GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return (IEnumerator)(object)GetEnumerator();
		}

		public void Clear()
		{
			entityList.Get().Clear();
		}
	}

	public enum DestroyMode : byte
	{
		None,
		Gib
	}

	[Header("BaseNetworkable")]
	[ReadOnly]
	public uint prefabID;

	[Tooltip("If enabled the entity will send to everyone on the server - regardless of position")]
	public bool globalBroadcast;

	[Tooltip("Global broadcast a cut down version of the entity to show buildings across the map")]
	public bool globalBuildingBlock;

	[NonSerialized]
	public Networkable net;

	private string _prefabName;

	private string _prefabNameWithoutExtension;

	public static EntityRealm serverEntities = new EntityRealmServer();

	private const bool isServersideEntity = true;

	public static List<Connection> connectionsInSphereList = new List<Connection>();

	public List<Component> postNetworkUpdateComponents = new List<Component>();

	public bool _limitedNetworking;

	[NonSerialized]
	public EntityRef parentEntity;

	[NonSerialized]
	public readonly List<BaseEntity> children = new List<BaseEntity>();

	[NonSerialized]
	public bool canTriggerParent = true;

	public int creationFrame;

	public bool isSpawned;

	public ListHashSet<BaseNetworkable> occludees;

	private int lastDemoIndex = -1;

	public MemoryStream _NetworkCache;

	public static Queue<MemoryStream> EntityMemoryStreamPool = new Queue<MemoryStream>();

	private MemoryStream _SaveCache;

	public bool IsDestroyed { get; private set; }

	public string PrefabName
	{
		get
		{
			if (_prefabName == null)
			{
				_prefabName = StringPool.Get(prefabID);
			}
			return _prefabName;
		}
	}

	public string ShortPrefabName
	{
		get
		{
			if (_prefabNameWithoutExtension == null)
			{
				_prefabNameWithoutExtension = Path.GetFileNameWithoutExtension(PrefabName);
			}
			return _prefabNameWithoutExtension;
		}
	}

	public bool isServer => true;

	public bool isClient => false;

	public bool limitNetworking
	{
		get
		{
			return _limitedNetworking;
		}
		set
		{
			if (value != _limitedNetworking)
			{
				_limitedNetworking = value;
				if (_limitedNetworking)
				{
					OnNetworkLimitStart();
				}
				else
				{
					OnNetworkLimitEnd();
				}
				UpdateNetworkGroup();
			}
		}
	}

	public GameManager gameManager
	{
		get
		{
			if (isServer)
			{
				return GameManager.server;
			}
			throw new NotImplementedException("Missing gameManager path");
		}
	}

	public PrefabAttribute.Library prefabAttribute
	{
		get
		{
			if (isServer)
			{
				return PrefabAttribute.server;
			}
			throw new NotImplementedException("Missing prefabAttribute path");
		}
	}

	public static Group GlobalNetworkGroup => Net.sv.visibility.Get(0u);

	public static Group LimboNetworkGroup => Net.sv.visibility.Get(1u);

	public bool HasNetworkCache => _NetworkCache != null;

	public virtual Vector3 GetNetworkPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.localPosition;
	}

	public virtual Quaternion GetNetworkRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.localRotation;
	}

	public string InvokeString()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		List<InvokeAction> list = Pool.Get<List<InvokeAction>>();
		InvokeHandler.FindInvokes((Behaviour)(object)this, list);
		foreach (InvokeAction item in list)
		{
			if (stringBuilder.Length > 0)
			{
				stringBuilder.Append(", ");
			}
			stringBuilder.Append(item.action.Method.Name);
		}
		Pool.FreeUnmanaged<InvokeAction>(ref list);
		return stringBuilder.ToString();
	}

	public BaseEntity LookupPrefab()
	{
		return gameManager.FindPrefab(PrefabName).ToBaseEntity();
	}

	public bool EqualNetID(BaseNetworkable other)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!other.IsRealNull() && other.net != null && net != null)
		{
			return other.net.ID == net.ID;
		}
		return false;
	}

	public bool EqualNetID(NetworkableId otherID)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (net != null)
		{
			return otherID == net.ID;
		}
		return false;
	}

	public virtual void ResetState()
	{
		if (children.Count > 0)
		{
			children.Clear();
		}
		if (this is ILootableEntity lootableEntity)
		{
			lootableEntity.LastLootedBy = 0uL;
		}
	}

	public virtual void InitShared()
	{
	}

	public virtual void PreInitShared()
	{
	}

	public virtual void PostInitShared()
	{
	}

	public virtual void DestroyShared()
	{
	}

	public virtual void OnNetworkGroupEnter(Group group)
	{
		Interface.CallHook("OnNetworkGroupEntered", (object)this, (object)group);
	}

	public virtual void OnNetworkGroupLeave(Group group)
	{
		Interface.CallHook("OnNetworkGroupLeft", (object)this, (object)group);
	}

	public void OnNetworkGroupChange()
	{
		if (children != null && net.group != null)
		{
			foreach (BaseEntity child in children)
			{
				if (child.IsRealNull())
				{
					Debug.LogError((object)"Child is null when switching groups", (Object)(object)this);
				}
				else if (child.net != null)
				{
					if (child.ShouldInheritNetworkGroup())
					{
						child.net.SwitchGroup(net.group);
					}
					else if (isServer)
					{
						child.UpdateNetworkGroup();
					}
				}
			}
		}
		if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion())
		{
			ListHashSet<BaseNetworkable> value;
			if (net.group == null)
			{
				occludees = null;
			}
			else if (ServerOcclusion.Occludees.TryGetValue(net.group, out value))
			{
				occludees = value;
			}
			else
			{
				occludees = null;
			}
		}
	}

	public void OnNetworkSubscribersEnter(List<Connection> connections)
	{
		if (!((BaseNetwork)Net.sv).IsConnected())
		{
			return;
		}
		foreach (Connection connection in connections)
		{
			BasePlayer basePlayer = connection.player as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null))
			{
				basePlayer.QueueUpdate(BasePlayer.NetworkQueue.Update, this as BaseEntity);
			}
		}
	}

	public void OnNetworkSubscribersLeave(List<Connection> connections)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && (!(this is BasePlayer basePlayer) || !basePlayer.IsSpectating()))
		{
			LogEntry(RustLog.EntryType.Network, 2, "LeaveVisibility");
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)6);
			obj.EntityID(net.ID);
			obj.UInt8((byte)0);
			obj.Send(new SendInfo(connections));
		}
	}

	public void EntityDestroy()
	{
		if (Object.op_Implicit((Object)(object)((Component)this).gameObject))
		{
			ResetState();
			gameManager.Retire(((Component)this).gameObject);
		}
	}

	private void DoEntityDestroy()
	{
		if (IsDestroyed)
		{
			return;
		}
		IsDestroyed = true;
		if (Application.isQuitting)
		{
			return;
		}
		DestroyShared();
		if (isServer)
		{
			DoServerDestroy();
		}
		TimeWarning val = TimeWarning.New("Registry.Entity.Unregister", 0);
		try
		{
			Entity.Unregister(((Component)this).gameObject);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SpawnShared()
	{
		IsDestroyed = false;
		TimeWarning val = TimeWarning.New("Registry.Entity.Register", 0);
		try
		{
			Entity.Register(((Component)this).gameObject, (IEntity)(object)this);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void Save(SaveInfo info)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (prefabID == 0)
		{
			Debug.LogError((object)("PrefabID is 0! " + ((Component)this).transform.GetRecursiveName()), (Object)(object)((Component)this).gameObject);
		}
		info.msg.baseNetworkable = Pool.Get<BaseNetworkable>();
		info.msg.baseNetworkable.uid = net.ID;
		info.msg.baseNetworkable.prefabID = prefabID;
		if (net.group != null)
		{
			info.msg.baseNetworkable.group = net.group.ID;
		}
		if (!info.forDisk)
		{
			info.msg.createdThisFrame = creationFrame == Time.frameCount;
		}
	}

	public virtual void PostSave(SaveInfo info)
	{
	}

	public void InitLoad(NetworkableId entityID)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		net = Net.sv.CreateNetworkable(entityID);
		serverEntities.RegisterID(this);
	}

	public virtual void PreServerLoad()
	{
	}

	public virtual void Load(LoadInfo info)
	{
		if (info.msg.baseNetworkable != null)
		{
			LoadInfo loadInfo = info;
			Interface.CallHook("OnEntityLoaded", (object)this, (object)info);
			BaseNetworkable baseNetworkable = loadInfo.msg.baseNetworkable;
			if (prefabID != baseNetworkable.prefabID)
			{
				Debug.LogError((object)("Prefab IDs don't match! " + prefabID + "/" + baseNetworkable.prefabID + " -> " + (object)((Component)this).gameObject), (Object)(object)((Component)this).gameObject);
			}
		}
	}

	public virtual void PostServerLoad()
	{
		((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
	}

	public T ToServer<T>() where T : BaseNetworkable
	{
		if (isServer)
		{
			return this as T;
		}
		return null;
	}

	public virtual bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		return false;
	}

	protected virtual bool OnSyncVar(byte syncVar, NetRead reader, bool fromAutoSave = false)
	{
		return false;
	}

	protected virtual bool WriteSyncVar(byte id, NetWrite writer)
	{
		return false;
	}

	protected virtual bool AutoSaveSyncVars(SaveInfo save)
	{
		return false;
	}

	protected virtual bool AutoLoadSyncVars(LoadInfo load)
	{
		return false;
	}

	protected virtual void ResetSyncVars()
	{
	}

	protected virtual bool ShouldInvalidateCache(byte id)
	{
		return false;
	}

	protected virtual bool IsSyncVarEqual<T>(T oldValue, T newValue)
	{
		return EqualityComparer<T>.Default.Equals(oldValue, newValue);
	}

	public static List<Connection> GetConnectionsWithin(Vector3 position, float distance, bool addSecondaryConnections = false, bool useRcEntityPosition = true)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		connectionsInSphereList.Clear();
		PooledList<BasePlayer> val = Pool.Get<PooledList<BasePlayer>>();
		try
		{
			BaseEntity.Query.Server.GetPlayersInSphere(position, distance, (List<BasePlayer>)(object)val);
			float sqrDistance = distance * distance;
			foreach (BasePlayer item in (List<BasePlayer>)(object)val)
			{
				if ((Object)(object)item == (Object)null || item.isClient || item.Connection == null)
				{
					continue;
				}
				if (addSecondaryConnections)
				{
					if (useRcEntityPosition)
					{
						if (item.RcEntityPosition.HasValue)
						{
							AddSecondaryConnectionsWithin(item.RcEntityPosition.Value, sqrDistance, item);
						}
					}
					else
					{
						AddSecondaryConnectionsWithin(position, sqrDistance, item);
					}
				}
				connectionsInSphereList.Add(item.Connection);
			}
			return connectionsInSphereList;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void AddSecondaryConnectionsWithin(Vector3 position, float sqrDistance, BasePlayer player)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (position == Vector3.zero || player.net.secondaryGroup == null)
		{
			return;
		}
		foreach (Connection subscriber in player.net.secondaryGroup.subscribers)
		{
			BasePlayer basePlayer = subscriber.player as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > sqrDistance))
			{
				connectionsInSphereList.Add(player.Connection);
			}
		}
	}

	public static void GetCloseConnections(Vector3 position, float distance, List<Connection> foundConnections)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null || Net.sv.visibility == null)
		{
			return;
		}
		float num = distance * distance;
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active)
			{
				BasePlayer basePlayer = val.player as BasePlayer;
				if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > num))
				{
					foundConnections.Add(basePlayer.Connection);
				}
			}
		}
	}

	public static void GetCloseConnections(Vector3 position, float distance, List<BasePlayer> players)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null || Net.sv.visibility == null)
		{
			return;
		}
		float num = distance * distance;
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active)
			{
				BasePlayer basePlayer = val.player as BasePlayer;
				if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > num))
				{
					players.Add(basePlayer);
				}
			}
		}
	}

	public static bool HasCloseConnections(Vector3 position, float distance)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null)
		{
			return false;
		}
		if (Net.sv.visibility == null)
		{
			return false;
		}
		float num = distance * distance;
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return false;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active)
			{
				BasePlayer basePlayer = val.player as BasePlayer;
				if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > num))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool HasConnections(Vector3 position)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null)
		{
			return false;
		}
		if (Net.sv.visibility == null)
		{
			return false;
		}
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return false;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active && !((Object)(object)(val.player as BasePlayer) == (Object)null))
			{
				return true;
			}
		}
		return false;
	}

	public void BroadcastOnPostNetworkUpdate(BaseEntity entity)
	{
		foreach (Component postNetworkUpdateComponent in postNetworkUpdateComponents)
		{
			(postNetworkUpdateComponent as IOnPostNetworkUpdate)?.OnPostNetworkUpdate(entity);
		}
		foreach (BaseEntity child in children)
		{
			child.BroadcastOnPostNetworkUpdate(entity);
		}
	}

	public virtual void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!serverside)
		{
			postNetworkUpdateComponents = ((Component)this).GetComponentsInChildren<IOnPostNetworkUpdate>(true).Cast<Component>().ToList();
		}
	}

	private void OnNetworkLimitStart()
	{
		LogEntry(RustLog.EntryType.Network, 2, "OnNetworkLimitStart");
		List<Connection> subscribers = GetSubscribers();
		if (subscribers == null)
		{
			return;
		}
		subscribers = subscribers.ToList();
		subscribers.RemoveAll((Connection x) => ShouldNetworkTo(x.player as BasePlayer));
		OnNetworkSubscribersLeave(subscribers);
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			child.OnNetworkLimitStart();
		}
	}

	private void OnNetworkLimitEnd()
	{
		LogEntry(RustLog.EntryType.Network, 2, "OnNetworkLimitEnd");
		List<Connection> subscribers = GetSubscribers();
		if (subscribers == null)
		{
			return;
		}
		OnNetworkSubscribersEnter(subscribers);
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			child.OnNetworkLimitEnd();
		}
	}

	public BaseEntity GetParentEntity()
	{
		return parentEntity.Get(isServer);
	}

	public bool HasParent()
	{
		return parentEntity.IsValid(isServer);
	}

	public void AddChild(BaseEntity child)
	{
		if (!children.Contains(child))
		{
			children.Add(child);
			OnChildAdded(child);
		}
	}

	protected virtual void OnChildAdded(BaseEntity child)
	{
	}

	public void RemoveChild(BaseEntity child)
	{
		children.Remove(child);
		OnChildRemoved(child);
	}

	protected virtual void OnChildRemoved(BaseEntity child)
	{
	}

	public virtual float GetNetworkTime()
	{
		return Time.time;
	}

	public virtual void Spawn()
	{
		EntityProfiler.spawned++;
		if (EntityProfiler.mode >= 2)
		{
			EntityProfiler.OnSpawned(this);
		}
		SpawnShared();
		if (net == null)
		{
			net = Net.sv.CreateNetworkable();
		}
		creationFrame = Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		ServerInitPostNetworkGroupAssign();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", (object)this);
		SendNetworkUpdateImmediate();
		((FacepunchBehaviour)this).Invoke((Action)SendGlobalNetworkUpdate, 0f);
		if (Application.isLoading && !Application.isLoadingSave)
		{
			((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

	private void SendGlobalNetworkUpdate()
	{
		GlobalNetworkHandler.server?.TrySendNetworkUpdate(this);
	}

	public bool IsFullySpawned()
	{
		return isSpawned;
	}

	public virtual void ServerInit()
	{
		serverEntities.RegisterID(this);
		if (net != null)
		{
			net.handler = (NetworkHandler)(object)this;
		}
		lastDemoIndex = -1;
	}

	public virtual void ServerInitPostNetworkGroupAssign()
	{
	}

	public List<Connection> GetSubscribers()
	{
		if (net == null)
		{
			return null;
		}
		if (net.group == null)
		{
			return null;
		}
		return net.group.subscribers;
	}

	protected ListHashSet<BaseNetworkable> GetOccludees()
	{
		return occludees;
	}

	public void KillMessage()
	{
		Kill();
	}

	public virtual void AdminKill()
	{
		Kill(DestroyMode.Gib);
	}

	public virtual void OnKilled()
	{
	}

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning((object)("Calling kill - but already IsDestroyed!? " + (object)this));
		}
		else if (Interface.CallHook("OnEntityKill", (object)this) == null)
		{
			EntityProfiler.killed++;
			if (EntityProfiler.mode >= 2)
			{
				EntityProfiler.OnKilled(this);
			}
			((Component)this).gameObject.BroadcastOnParentDestroying();
			OnKilled();
			DoEntityDestroy();
			TerminateOnClient(mode);
			TerminateOnServer();
			EntityDestroy();
		}
	}

	public void KillAsMapEntity()
	{
		if (IsFullySpawned())
		{
			Kill();
			return;
		}
		IsDestroyed = true;
		Object.Destroy((Object)(object)((Component)this).gameObject);
	}

	public void TerminateOnClient(DestroyMode mode)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (net != null && net.group != null && ((BaseNetwork)Net.sv).IsConnected())
		{
			LogEntry(RustLog.EntryType.Network, 2, "Term {0}", mode);
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)6);
			obj.EntityID(net.ID);
			obj.UInt8((byte)mode);
			obj.Send(new SendInfo(net.group.subscribers));
			GlobalNetworkHandler.server?.OnEntityKilled(this);
		}
	}

	public void TerminateOnServer()
	{
		if (net != null)
		{
			InvalidateNetworkCache();
			serverEntities.UnregisterID(this);
			Net.sv.DestroyNetworkable(ref net);
			((MonoBehaviour)this).StopAllCoroutines();
			((Component)this).gameObject.SetActive(false);
		}
	}

	internal virtual void DoServerDestroy()
	{
		isSpawned = false;
		Analytics.Azure.OnEntityDestroyed(this);
	}

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", (object)this, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (net.group == null)
		{
			return true;
		}
		return player.net.subscriber.IsSubscribed(net.group);
	}

	public void SendNetworkGroupChange()
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (isSpawned && ((BaseNetwork)Net.sv).IsConnected() && (!(this is BasePlayer basePlayer) || !basePlayer.IsSpectating()))
		{
			if (net.group == null)
			{
				Debug.LogWarning((object)(((object)this).ToString() + " changed its network group to null"));
				return;
			}
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)7);
			obj.EntityID(net.ID);
			obj.GroupID(net.group.ID);
			obj.Send(new SendInfo(net.group.subscribers));
		}
	}

	public void SendAsSnapshot(Connection connection, bool ordered = true)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnEntitySnapshot", (object)this, (object)connection) == null)
		{
			NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
			uint num = (ordered ? (++connection.validate.entityUpdates) : uint.MaxValue);
			SaveInfo saveInfo = default(SaveInfo);
			saveInfo.forConnection = connection;
			saveInfo.forDisk = false;
			SaveInfo saveInfo2 = saveInfo;
			val.PacketID((Type)5);
			val.UInt32(num);
			ToStreamForNetwork((Stream)(object)val, saveInfo2);
			val.Send(new SendInfo(connection));
			if (DemoConVars.ServerDemosEnabled)
			{
				lastDemoIndex = ((BaseNetwork)Net.sv).serverDemos.DemoCount;
			}
		}
	}

	public void SendAsSnapshotWithChildren(BasePlayer player, bool ordered = true)
	{
		Connection connection = player.net.connection;
		SendAsSnapshot(connection, ordered);
		SendChildren(children, player, ordered);
		static void SendChildren(List<BaseEntity> children, BasePlayer player, bool ordered)
		{
			Connection connection2 = player.net.connection;
			foreach (BaseEntity child in children)
			{
				if (child.ShouldNetworkTo(player))
				{
					child.SendAsSnapshot(connection2, ordered);
					SendChildren(child.children, player, ordered);
				}
			}
		}
	}

	public void SendDemoTransientEntity()
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		if (!DemoConVars.ServerDemosEnabled)
		{
			return;
		}
		BaseEntity baseEntity = this as BaseEntity;
		if (!baseEntity.enableSaving && lastDemoIndex != ((BaseNetwork)Net.sv).serverDemos.DemoCount)
		{
			lastDemoIndex = ((BaseNetwork)Net.sv).serverDemos.DemoCount;
			NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
			val.PacketID((Type)51);
			SaveInfo saveInfo = default(SaveInfo);
			saveInfo.forDisk = true;
			SaveInfo saveInfo2 = saveInfo;
			bool flag = true;
			try
			{
				ToStream((Stream)(object)val, saveInfo2);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)$"ServerDemo: Failed to take a snapshot of transient ${baseEntity.ShortPrefabName}[${net.ID}]", (Object)(object)baseEntity);
				Debug.LogException(ex, (Object)(object)this);
				flag = false;
			}
			if (flag)
			{
				Server sv = Net.sv;
				DemoQueueItem val2 = default(DemoQueueItem);
				((DemoQueueItem)(ref val2))..ctor(val);
				val2.IgnoreNoConnections = true;
				((BaseNetwork)sv).EnqueueToDemoThread(val2);
			}
			val.RemoveReference();
		}
	}

	public void SendNetworkUpdate(BasePlayer.NetworkQueue queue = BasePlayer.NetworkQueue.Update)
	{
		if (Application.isLoading || Application.isLoadingSave || IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("SendNetworkUpdate", 0);
		try
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdate");
			InvalidateNetworkCache();
			List<Connection> subscribers = GetSubscribers();
			if (subscribers != null && subscribers.Count > 0)
			{
				for (int i = 0; i < subscribers.Count; i++)
				{
					BasePlayer basePlayer = subscribers[i].player as BasePlayer;
					if (!((Object)(object)basePlayer == (Object)null) && ShouldNetworkTo(basePlayer))
					{
						basePlayer.QueueUpdate(queue, this);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
	}

	public void SendNetworkUpdateImmediate()
	{
		if (Application.isLoading || Application.isLoadingSave || IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("SendNetworkUpdateImmediate", 0);
		try
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdateImmediate");
			InvalidateNetworkCache();
			List<Connection> subscribers = GetSubscribers();
			if (subscribers != null && subscribers.Count > 0)
			{
				for (int i = 0; i < subscribers.Count; i++)
				{
					Connection val2 = subscribers[i];
					BasePlayer basePlayer = val2.player as BasePlayer;
					if (!((Object)(object)basePlayer == (Object)null) && ShouldNetworkTo(basePlayer))
					{
						SendAsSnapshot(val2);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
	}

	public void SendNetworkUpdate_Position()
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || Application.isLoadingSave || IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("SendNetworkUpdate_Position", 0);
		try
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdate_Position");
			List<Connection> list = GetSubscribers();
			if (list == null || list.Count <= 0)
			{
				return;
			}
			if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion())
			{
				List<Connection> list2 = Pool.Get<List<Connection>>();
				foreach (Connection item in list)
				{
					BasePlayer basePlayer = item.player as BasePlayer;
					if (!((Object)(object)basePlayer == (Object)null) && ShouldNetworkTo(basePlayer))
					{
						list2.Add(item);
					}
				}
				list = list2;
			}
			if (list.Count > 0)
			{
				SendDemoTransientEntity();
				NetWrite val2 = ((BaseNetwork)Net.sv).StartWrite();
				val2.PacketID((Type)10);
				val2.EntityID(net.ID);
				Vector3 networkPosition = GetNetworkPosition();
				val2.Vector3(ref networkPosition);
				Quaternion networkRotation = GetNetworkRotation();
				networkPosition = ((Quaternion)(ref networkRotation)).eulerAngles;
				val2.Vector3(ref networkPosition);
				val2.Float(GetNetworkTime());
				NetworkableId uid = parentEntity.uid;
				if (((NetworkableId)(ref uid)).IsValid)
				{
					val2.EntityID(uid);
				}
				SendInfo val3 = new SendInfo(list);
				val3.method = (SendMethod)1;
				val3.priority = (Priority)0;
				SendInfo val4 = val3;
				val2.Send(val4);
			}
			if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion())
			{
				Pool.FreeUnmanaged<Connection>(ref list);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ToStream(Stream stream, SaveInfo saveInfo)
	{
		Entity val = (saveInfo.msg = Pool.Get<Entity>());
		try
		{
			Save(saveInfo);
			if (saveInfo.msg.baseEntity == null)
			{
				Debug.LogError((object)(((object)this)?.ToString() + ": ToStream - no BaseEntity!?"));
			}
			if (saveInfo.msg.baseNetworkable == null)
			{
				Debug.LogError((object)(((object)this)?.ToString() + ": ToStream - no baseNetworkable!?"));
			}
			Interface.CallHook("IOnEntitySaved", (object)this, (object)saveInfo);
			ProtoStreamExtensions.WriteToStream((IProto)(object)saveInfo.msg, stream, false, 2097152);
			PostSave(saveInfo);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual bool CanUseNetworkCache(Connection connection)
	{
		return ConVar.Server.netcache;
	}

	public void ToStreamForNetwork(Stream stream, SaveInfo saveInfo)
	{
		if (!CanUseNetworkCache(saveInfo.forConnection))
		{
			ToStream(stream, saveInfo);
			return;
		}
		if (_NetworkCache == null)
		{
			_NetworkCache = ((EntityMemoryStreamPool.Count > 0) ? (_NetworkCache = EntityMemoryStreamPool.Dequeue()) : new MemoryStream(8));
			ToStream(_NetworkCache, saveInfo);
			ConVar.Server.netcachesize += (int)_NetworkCache.Length;
		}
		_NetworkCache.WriteTo(stream);
	}

	public void InvalidateNetworkCache()
	{
		TimeWarning val = TimeWarning.New("InvalidateNetworkCache", 0);
		try
		{
			if (_SaveCache != null)
			{
				ConVar.Server.savecachesize -= (int)_SaveCache.Length;
				_SaveCache.SetLength(0L);
				_SaveCache.Position = 0L;
				EntityMemoryStreamPool.Enqueue(_SaveCache);
				_SaveCache = null;
			}
			if (_NetworkCache != null)
			{
				ConVar.Server.netcachesize -= (int)_NetworkCache.Length;
				_NetworkCache.SetLength(0L);
				_NetworkCache.Position = 0L;
				EntityMemoryStreamPool.Enqueue(_NetworkCache);
				_NetworkCache = null;
			}
			LogEntry(RustLog.EntryType.Network, 3, "InvalidateNetworkCache");
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public MemoryStream GetSaveCache()
	{
		if (_SaveCache == null)
		{
			if (EntityMemoryStreamPool.Count > 0)
			{
				_SaveCache = EntityMemoryStreamPool.Dequeue();
			}
			else
			{
				_SaveCache = new MemoryStream(8);
			}
			SaveInfo saveInfo = default(SaveInfo);
			saveInfo.forDisk = true;
			SaveInfo saveInfo2 = saveInfo;
			ToStream(_SaveCache, saveInfo2);
			ConVar.Server.savecachesize += (int)_SaveCache.Length;
		}
		return _SaveCache;
	}

	public virtual void UpdateNetworkGroup()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(isServer, "UpdateNetworkGroup called on clientside entity!");
		if (net == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("UpdateGroups", 0);
		try
		{
			if (net.UpdateGroups(((Component)this).transform.position))
			{
				SendNetworkGroupChange();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual bool SupportsServerOcclusion()
	{
		return false;
	}
}


using Network;
using ProtoBuf;

public struct SaveInfo
{
	public Entity msg;

	public bool forDisk;

	public bool forTransfer;

	public Connection forConnection;

	internal bool SendingTo(Connection ownerConnection)
	{
		if (ownerConnection == null)
		{
			return false;
		}
		if (forConnection == null)
		{
			return false;
		}
		return forConnection == ownerConnection;
	}
}


using ProtoBuf;

public struct LoadInfo
{
	public Entity msg;

	public bool fromDisk;

	public bool fromCopy;

	public bool fromTransfer;
}


using Network;
using Network.Visibility;

public class EntityRealmServer : EntityRealm
{
	protected override Manager visibilityManager
	{
		get
		{
			if (Net.sv == null)
			{
				return null;
			}
			return Net.sv.visibility;
		}
	}
}


using System.Collections;
using System.Collections.Generic;
using Network;
using Network.Visibility;
using UnityEngine;

public abstract class EntityRealm : IEnumerable<BaseNetworkable>, IEnumerable
{
	public HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>> entityList = new HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>>(new ListDictionary<NetworkableId, BaseNetworkable>());

	public int Count => entityList.Get().Count;

	protected abstract Manager visibilityManager { get; }

	public bool Contains(NetworkableId uid)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return entityList.Get().Contains(uid);
	}

	public BaseNetworkable Find(NetworkableId uid)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		BaseNetworkable result = null;
		if (!entityList.Get().TryGetValue(uid, ref result))
		{
			return null;
		}
		return result;
	}

	public void RegisterID(BaseNetworkable ent)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (ent.net != null)
		{
			ListDictionary<NetworkableId, BaseNetworkable> val = entityList.Get();
			if (val.Contains(ent.net.ID))
			{
				val[ent.net.ID] = ent;
			}
			else
			{
				val.Add(ent.net.ID, ent);
			}
		}
	}

	public void UnregisterID(BaseNetworkable ent)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (ent.net != null)
		{
			entityList.Get().Remove(ent.net.ID);
		}
	}

	public Group FindGroup(uint uid)
	{
		Manager val = visibilityManager;
		if (val == null)
		{
			return null;
		}
		return val.Get(uid);
	}

	public Group TryFindGroup(uint uid)
	{
		Manager val = visibilityManager;
		if (val == null)
		{
			return null;
		}
		return val.TryGet(uid);
	}

	public void FindInGroup(uint uid, List<BaseNetworkable> list)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Group val = TryFindGroup(uid);
		if (val == null)
		{
			return;
		}
		int count = val.networkables.Values.Count;
		Networkable[] buffer = val.networkables.Values.Buffer;
		for (int i = 0; i < count; i++)
		{
			Networkable val2 = buffer[i];
			BaseNetworkable baseNetworkable = Find(val2.ID);
			if (!((Object)(object)baseNetworkable == (Object)null) && baseNetworkable.net != null && baseNetworkable.net.group != null)
			{
				if (baseNetworkable.net.group.ID != uid)
				{
					Debug.LogWarning((object)("Group ID mismatch: " + ((object)baseNetworkable).ToString()));
				}
				else
				{
					list.Add(baseNetworkable);
				}
			}
		}
	}

	public Enumerator<BaseNetworkable> GetEnumerator()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return entityList.Get().Values.GetEnumerator();
	}

	IEnumerator<BaseNetworkable> IEnumerable<BaseNetworkable>.GetEnumerator()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return (IEnumerator<BaseNetworkable>)(object)GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return (IEnumerator)(object)GetEnumerator();
	}

	public void Clear()
	{
		entityList.Get().Clear();
	}
}


public enum DestroyMode : byte
{
	None,
	Gib
}


using UnityEngine;

public static class BaseNetworkableEx
{
	public static bool IsValid(this BaseNetworkable ent)
	{
		if ((Object)(object)ent == (Object)null)
		{
			return false;
		}
		if (ent.net == null)
		{
			return false;
		}
		return true;
	}

	public static bool Is<T>(this Object ent, out T entAsT) where T : Object
	{
		entAsT = default(T);
		if (ent == (Object)null)
		{
			return false;
		}
		entAsT = (T)(object)((ent is T) ? ent : null);
		if ((Object)(object)entAsT == (Object)null)
		{
			return false;
		}
		return true;
	}

	public static bool IsRealNull(this BaseNetworkable ent)
	{
		return ent == null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class BaseRagdoll : BaseMountable
{
	[Header("Ragdolling")]
	[SerializeField]
	private Ragdoll Ragdoll;

	[SerializeField]
	private PlayerBonePosData BonePosData;

	[SerializeField]
	private List<DamageTypeEntry> impactDamage;

	[SerializeField]
	private List<Rigidbody> flailBodies;

	private EntityRef<BasePlayer> parentPlayer;

	private BaseEntity initiator;

	private bool dieOnImpact;

	private float lastMovingTime;

	private float largestNegYVelocityOnCollision;

	private bool inTheAir;

	private bool flailInAir;

	private float spinDampening;

	private Vector3 ragdollSpinDirection;

	private bool matchPlayerGravity;

	private int clippedFrameCount;

	private Vector3 lastTransformPos;

	private Vector3 lastEyePos;

	private Vector3 lastPelvisPoint;

	private List<(Vector3, Quaternion)> lastRagdollRbPosRot;

	public GameObjectRef fleshImpact;

	[ClientVar]
	public static bool debug_vis;

	protected override bool BypassClothingMountBlocks => true;

	public override bool DirectlyMountable()
	{
		return false;
	}

	public override void Save(SaveInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		if (parentPlayer.IsValid(base.isServer))
		{
			info.msg.temporaryRagdoll.parentID = parentPlayer.uid;
			info.msg.temporaryRagdoll.mountPose = (int)mountPose;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.temporaryRagdoll != null)
		{
			Load(info.msg.temporaryRagdoll);
		}
	}

	private void Load(TemporaryRagdoll tempRagdoll)
	{
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		base.OnPlayerDismounted(player);
		player.SetPlayerFlag(BasePlayer.PlayerFlags.Ragdolling, b: false);
		PlayerEyes eyes = player.eyes;
		Quaternion rotation = player.eyes.rotation;
		eyes.rotation = Quaternion.Euler(Vector3Ex.WithX(((Quaternion)(ref rotation)).eulerAngles, 0f));
		if (dieOnImpact)
		{
			KillPlayerImpact(player, doRadiusDamage: true);
		}
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
		if ((Object)(object)val == (Object)null)
		{
			val = ((Component)this).gameObject.AddComponent<Rigidbody>();
			val.mass = 10f;
			val.drag = 0f;
			val.angularDrag = 0f;
		}
		val.useGravity = true;
		val.collisionDetectionMode = (CollisionDetectionMode)3;
		val.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
		lastMovingTime = Time.time;
	}

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		GameObjectExtensions.SetIgnoreCollisions(((Component)this).gameObject, ((Component)GetMounted()).gameObject, true);
		((FacepunchBehaviour)this).Invoke((Action)StopRagdolling, 10f);
	}

	public override void VehicleFixedUpdate()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseRagdoll.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			BasePlayer mounted = GetMounted();
			if ((Object)(object)mounted == (Object)null)
			{
				Kill();
				return;
			}
			AdjustForClipping();
			Vector3 val2 = rigidBody.velocity;
			if (!(((Vector3)(ref val2)).magnitude > 2f))
			{
				val2 = rigidBody.angularVelocity;
				if (!(((Vector3)(ref val2)).magnitude > 2f))
				{
					goto IL_0073;
				}
			}
			lastMovingTime = Time.time;
			goto IL_0073;
			IL_0073:
			if (matchPlayerGravity)
			{
				Vector3 val3 = 2.5f * Physics.gravity - Physics.gravity;
				foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
				{
					rigidbody.AddForce(val3, (ForceMode)5);
				}
			}
			if (inTheAir && flailInAir)
			{
				foreach (Rigidbody flailBody in flailBodies)
				{
					Vector3 val4 = new Vector3(Random.Range(-0.5f, 0.5f), Random.Range(-0.5f, 0.5f), Random.Range(-0.5f, 0.5f)) * (Random.Range(5f, 10f) * spinDampening);
					flailBody.AddForce(val4 * 15f, (ForceMode)5);
				}
				rigidBody.AddTorque(ragdollSpinDirection * spinDampening, (ForceMode)5);
				spinDampening *= 0.98f;
			}
			if (largestNegYVelocityOnCollision < 0f)
			{
				if (Object.op_Implicit((Object)(object)mounted))
				{
					mounted.ApplyFallDamageFromVelocity(largestNegYVelocityOnCollision);
				}
				largestNegYVelocityOnCollision = 0f;
			}
			if (Time.time > lastMovingTime + 1.25f)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)StopRagdolling);
				StopRagdolling();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void AdjustForClipping()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AdjustForClipping", 0);
		try
		{
			Vector3 position = lastTransformPos;
			lastTransformPos = ((Component)this).transform.position;
			Vector3 start = lastEyePos;
			Vector3 end = (lastEyePos = GetMounted().eyes.position);
			Vector3 start2 = lastPelvisPoint;
			Vector3 end2 = (lastPelvisPoint = Ragdoll.primaryBody.position);
			BasePlayer basePlayer = parentPlayer.Get(serverside: true);
			Vector3 velocity = rigidBody.velocity;
			bool flag = ((Vector3)(ref velocity)).sqrMagnitude > 3f;
			bool flag2 = false;
			bool flag3 = false;
			List<RaycastHit> hits = Pool.Get<List<RaycastHit>>();
			bool flag4 = flag && ClippedOnPath(start, end, 0.3f, in hits, basePlayer);
			bool flag5 = ClippedOnPath(start, end, 0f, in hits, basePlayer);
			flag2 = flag2 || flag4 || flag5;
			flag3 = flag3 || flag5;
			bool flag6 = flag && ClippedOnPath(start2, end2, 0.3f, in hits, basePlayer);
			bool flag7 = ClippedOnPath(start2, end2, 0f, in hits, basePlayer);
			flag2 = flag2 || flag6 || flag7;
			flag3 = flag3 || flag7;
			Pool.FreeUnmanaged<RaycastHit>(ref hits);
			if (!flag2)
			{
				for (int i = 0; i < Ragdoll.rigidbodies.Count; i++)
				{
					Rigidbody val2 = Ragdoll.rigidbodies[i];
					lastRagdollRbPosRot[i] = (val2.position, val2.rotation);
				}
				return;
			}
			if (flag3 && ++clippedFrameCount >= 3)
			{
				basePlayer.Hurt(new HitInfo(initiator, basePlayer, DamageType.Blunt, 1000f));
				StopRagdolling();
				return;
			}
			for (int j = 0; j < Ragdoll.rigidbodies.Count; j++)
			{
				Rigidbody val3 = Ragdoll.rigidbodies[j];
				if (!((Object)(object)val3 == (Object)null))
				{
					var (position2, rotation) = lastRagdollRbPosRot[j];
					val3.position = position2;
					val3.rotation = rotation;
					val3.velocity = Vector3.zero;
					val3.angularVelocity = Vector3.zero;
				}
			}
			((Component)this).transform.position = position;
			lastTransformPos = position;
			lastEyePos = start;
			lastPelvisPoint = start2;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool ClippedOnPath(Vector3 start, Vector3 end, float radius, in List<RaycastHit> hits, BasePlayer ignorePlayer)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		Vector3 val = end - start;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (magnitude < Mathf.Epsilon)
		{
			return false;
		}
		val /= magnitude;
		Ray ray = new Ray(start, val);
		hits.Clear();
		GamePhysics.TraceAllUnordered(ray, radius, hits, magnitude, -910884607, (QueryTriggerInteraction)1);
		foreach (RaycastHit hit in hits)
		{
			BaseEntity entity = hit.GetEntity();
			if (!GamePhysics.CompareEntity(entity, this) && !GamePhysics.CompareEntity(entity, ignorePlayer))
			{
				result = true;
				break;
			}
		}
		return result;
	}

	public void InitFromPlayer(BasePlayer bp, Vector3 velocityOverride = default(Vector3), bool matchPlayerGravity = true, bool flailInAir = false, bool dieOnImpact = false, BaseEntity initiator = null)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		parentPlayer.Set(bp);
		lastEyePos = bp.eyes.position;
		if (bp.isMounted)
		{
			mountPose = bp.GetMounted().mountPose;
		}
		PlayerBonePosData.BonePosData bonePositionData = BonePosData.GetBonePositionData(bp.playerFlags, bp.modelState);
		if (bonePositionData != null)
		{
			model.skeleton.CopyFrom(bonePositionData.bonePositions, bonePositionData.boneRotations, true);
			Transform transform = model.skeleton.Bones[0].transform;
			transform.localEulerAngles += bonePositionData.rootRotationOffset;
		}
		float x = ((Component)bp).transform.eulerAngles.x;
		Quaternion bodyRotation = bp.eyes.bodyRotation;
		Quaternion val = Quaternion.Euler(x, ((Quaternion)(ref bodyRotation)).eulerAngles.y, ((Component)bp).transform.eulerAngles.z);
		((Component)this).transform.SetPositionAndRotation(((Component)bp).transform.position, val);
		lastTransformPos = ((Component)this).transform.position;
		Ragdoll.ServerInit();
		rigidBody.drag = 0f;
		rigidBody.angularDrag = 0f;
		inTheAir = true;
		Vector3 val2 = ((velocityOverride != Vector3.zero) ? velocityOverride : (bp.isMounted ? bp.GetMountVelocity() : bp.estimatedVelocity));
		rigidBody.AddForce(val2, (ForceMode)1);
		lastRagdollRbPosRot = new List<(Vector3, Quaternion)>(Ragdoll.rigidbodies.Count);
		foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
		{
			rigidbody.drag = 0f;
			rigidbody.angularDrag = 0f;
			rigidbody.AddForceAtPosition(val2, ((Component)rigidbody).transform.position, (ForceMode)2);
			rigidbody.collisionDetectionMode = (CollisionDetectionMode)3;
			lastRagdollRbPosRot.Add((rigidbody.position, rigidbody.rotation));
		}
		lastPelvisPoint = Ragdoll.primaryBody.position;
		this.flailInAir = flailInAir;
		if (flailInAir)
		{
			spinDampening = 1f;
			Vector3 zero = Vector3.zero;
			((Vector3)(ref zero))[Random.Range(0, 3)] = 1f;
			ragdollSpinDirection = zero * 0.8f;
		}
		if (Object.op_Implicit((Object)(object)initiator))
		{
			GameObjectExtensions.SetIgnoreCollisions(((Component)this).gameObject, ((Component)initiator).gameObject, true);
		}
		this.matchPlayerGravity = matchPlayerGravity;
		this.initiator = initiator;
		this.dieOnImpact = dieOnImpact;
	}

	public override bool GetDismountPosition(BasePlayer player, out Vector3 res, bool silent = false)
	{
		List<Collider> list = Pool.Get<List<Collider>>();
		((Component)this).GetComponentsInChildren<Collider>(list);
		foreach (Collider item in list)
		{
			item.enabled = false;
		}
		bool dismountPosition = base.GetDismountPosition(player, out res, silent);
		foreach (Collider item2 in list)
		{
			item2.enabled = true;
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return dismountPosition;
	}

	private void StopRagdolling()
	{
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			mounted.SetPlayerFlag(BasePlayer.PlayerFlags.Ragdolling, b: false);
		}
		DismountAllPlayers();
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override bool AllowPlayerInstigatedDismount(BasePlayer player)
	{
		object obj = Interface.CallHook("CanRagdollDismount", (object)this, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

	protected void ProcessCollision(Collision collision, BaseEntity hitEntity, Rigidbody ourRigidbody)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || collision == null || (Object)(object)collision.gameObject == (Object)null || (Object)(object)collision.gameObject == (Object)null)
		{
			return;
		}
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted == (Object)null)
		{
			return;
		}
		if (dieOnImpact)
		{
			KillPlayerImpact(mounted, doRadiusDamage: true);
		}
		else
		{
			largestNegYVelocityOnCollision = Mathf.Min(largestNegYVelocityOnCollision, 0f - collision.relativeVelocity.y);
		}
		if (!inTheAir)
		{
			return;
		}
		inTheAir = false;
		if (!flailInAir)
		{
			return;
		}
		rigidBody.drag = 1f;
		rigidBody.angularDrag = 1f;
		foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
		{
			rigidbody.drag = 1f;
			rigidbody.angularDrag = 1f;
		}
	}

	private void KillPlayerImpact(BasePlayer mounted, bool doRadiusDamage)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(mounted.fallDamageEffect.resourcePath, ((Component)this).transform.position, Vector3.zero);
		Effect.server.Run(fleshImpact.resourcePath, ((Component)this).transform.position, Vector3.zero);
		if (doRadiusDamage)
		{
			DamageUtil.RadiusDamage(mounted, initiator, ((Component)mounted).transform.position, 1f, 3.5f, impactDamage, 133120, useLineOfSight: true);
		}
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			StopRagdolling();
			mounted.Hurt(new HitInfo(initiator, mounted, DamageType.Blunt, 1000f));
		}, 1f);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (base.isServer)
		{
			ProcessCollision(collision, hitEntity, rigidBody);
		}
	}
}


using Rust;
using UnityEngine;

public class AnimatedBuildingBlock : StabilityEntity
{
	private bool animatorNeedsInitializing = true;

	private bool animatorIsOpen = true;

	[HideInInspector]
	public bool isAnimating;

	[HideInInspector]
	public float lastAnimationStateChange;

	private static readonly int Open = Animator.StringToHash("open");

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			UpdateAnimationParameters(init: true);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		UpdateAnimationParameters(init: true);
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		if (!isAnimating)
		{
			return Time.time - lastAnimationStateChange <= 10f;
		}
		return true;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		UpdateAnimationParameters(init: false);
	}

	protected virtual void ApplySubAnimationParameters(bool init, Animator toAnimator)
	{
	}

	protected void UpdateAnimationParameters(bool init)
	{
		if (!Object.op_Implicit((Object)(object)model) || !Object.op_Implicit((Object)(object)model.animator) || !model.animator.isInitialized)
		{
			return;
		}
		bool num = animatorNeedsInitializing || animatorIsOpen != IsOpen() || (init && isAnimating);
		bool flag = animatorNeedsInitializing || init;
		lastAnimationStateChange = GetNetworkTime();
		if (num)
		{
			isAnimating = true;
			((Behaviour)model.animator).enabled = true;
			model.animator.SetBool(Open, animatorIsOpen = IsOpen());
			ApplySubAnimationParameters(init, model.animator);
			if (flag)
			{
				model.animator.fireEvents = false;
				if (((Behaviour)model.animator).isActiveAndEnabled)
				{
					model.animator.Update(0f);
					model.animator.Update(20f);
				}
				PutAnimatorToSleep();
				isAnimating = false;
			}
			else
			{
				model.animator.fireEvents = base.isClient;
				if (base.isServer)
				{
					SetFlag(Flags.Busy, b: true);
				}
			}
		}
		else if (flag)
		{
			PutAnimatorToSleep();
		}
		animatorNeedsInitializing = false;
	}

	protected virtual void OnAnimatorFinished()
	{
		if (!isAnimating)
		{
			PutAnimatorToSleep();
		}
		isAnimating = false;
	}

	private void PutAnimatorToSleep()
	{
		if (!Object.op_Implicit((Object)(object)model) || !Object.op_Implicit((Object)(object)model.animator))
		{
			Debug.LogWarning((object)(((Component)this).transform.GetRecursiveName() + " has missing model/animator"), (Object)(object)((Component)this).gameObject);
			return;
		}
		((Behaviour)model.animator).enabled = false;
		if (base.isServer)
		{
			SetFlag(Flags.Busy, b: false);
		}
		OnAnimatorDisabled();
	}

	protected virtual void OnAnimatorDisabled()
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class BuildingPrivilegeRetro : BuildingPrivlidge
{
	[Serializable]
	public struct ToolSetting
	{
		public ItemDefinition item;

		public Transform[] parents;
	}

	[Serializable]
	public struct ToolModel
	{
		public ItemDefinition item;

		public GameObjectRef model;
	}

	public BuildingPrivilegeRetroScreen screens;

	public GameObjectRef[] boxPrefabs;

	public GameObjectRef[] doubleBoxPrefabs;

	public int boxesAmount = 12;

	public Transform boxesParent;

	public Vector3 boxSpacing = new Vector3(0.33f, 0.3f, 0.3f);

	public ToolSetting[] toolSettings;

	public ToolModel[] toolCustomModels;

	public Material hammerOriginalMaterial;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.buildingPrivilegeRetro = Pool.Get<BuildingPrivilegeRetro>();
		if (info.forDisk || !((Object)(object)info.forConnection?.player != (Object)null) || !IsAuthed(info.forConnection.player as BasePlayer))
		{
			return;
		}
		List<float> list = Pool.Get<List<float>>();
		list.Add(GetResourceProportion(-151838493));
		list.Add(GetResourceProportion(-2099697608));
		list.Add(GetResourceProportion(69511070));
		list.Add(GetResourceProportion(317398316));
		info.msg.buildingPrivilegeRetro.resources = list;
		info.msg.buildingPrivilegeRetro.tools = Pool.Get<List<BuildingPrivilegeRetroTool>>();
		for (int i = 24; i <= 28; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			BuildingPrivilegeRetroTool val = Pool.Get<BuildingPrivilegeRetroTool>();
			if (slot != null)
			{
				foreach (ItemDefinition allowedConstructionItem in allowedConstructionItems)
				{
					if (slot.info.itemid == allowedConstructionItem.itemid)
					{
						val.itemID = allowedConstructionItem.itemid;
						val.skinid = slot.skin;
					}
				}
			}
			info.msg.buildingPrivilegeRetro.tools.Add(val);
		}
	}

	private float GetResourceProportion(int id)
	{
		int amount = base.inventory.GetAmount(id, onlyUsableAmounts: false);
		float num = ItemManager.FindItemDefinition(id).stackable;
		return (float)amount / ((float)(base.inventory.capacity - 5) * num);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.buildingPrivilegeRetro;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ToolSetting
{
	public ItemDefinition item;

	public Transform[] parents;
}


using System;

[Serializable]
public struct ToolModel
{
	public ItemDefinition item;

	public GameObjectRef model;
}


using System;
using Rust.UI;
using UnityEngine;

public class BuildingPrivilegeRetroScreen : FacepunchBehaviour, INotifyLOD, IClientComponent
{
	[Serializable]
	public struct Screen
	{
		public CanvasGroup group;

		public CanvasGroup onGroup;

		public CanvasGroup offGroup;

		public void TurnOnOff(bool on)
		{
			((Component)onGroup).gameObject.SetActive(on);
			onGroup.alpha = (on ? 1 : 0);
			((Component)offGroup).gameObject.SetActive(!on);
			offGroup.alpha = ((!on) ? 1 : 0);
		}
	}

	[SerializeField]
	private CanvasGroup screenCanvas;

	[Header("PROTECTED TIME")]
	[Space]
	public RustText protectedTimeText;

	public int decayWarningThreshold = 130;

	public GameObject decayWarningGroup;

	public GameObject decayingGroup;

	[Space]
	[Header("UPKEEP")]
	public VirtualItemIcon[] costIcons;

	public RustText[] paginationTexts;

	[Space]
	[Header("BLOCKS")]
	public GameObject[] blocksType;

	public RustText blockCountText;

	public RustText doorCountText;

	[Space]
	public Renderer screenRenderer;

	[ColorUsage(true, true)]
	public Color fromScreenEmissionColor;

	[ColorUsage(true, true)]
	public Color screenEmissionColor;

	public AnimationCurve tweenCurve;

	public float animDuration = 0.7f;

	public Animation screensAnim;

	public Screen[] screens;
}


using System;
using UnityEngine;

[Serializable]
public struct Screen
{
	public CanvasGroup group;

	public CanvasGroup onGroup;

	public CanvasGroup offGroup;

	public void TurnOnOff(bool on)
	{
		((Component)onGroup).gameObject.SetActive(on);
		onGroup.alpha = (on ? 1 : 0);
		((Component)offGroup).gameObject.SetActive(!on);
		offGroup.alpha = ((!on) ? 1 : 0);
	}
}


using UnityEngine;

public class DoorWithLock : Door
{
	[Header("Lock Settings")]
	[ItemSelector]
	public GameObjectRef lockObject;
}


public class Gate : Door, INotifyTrigger, ISimpleUpgradable
{
}


using UnityEngine;

public class OBBComponent : MonoBehaviour
{
	public Bounds Bounds;

	public OBB GetObb()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(((Component)this).transform, Bounds);
	}
}


using UnityEngine;

public class ProceduralLiftCabin : MonoBehaviour
{
}


using UnityEngine;

public class ProceduralLiftStop : MonoBehaviour
{
}


using System;

public class SimpleBuildingBlockModelVariant : PrefabAttribute
{
	public GameObjectRef prefab;

	public BaseEntity.Flags Flag;

	protected override Type GetIndexedType()
	{
		return typeof(SimpleBuildingBlockModelVariant);
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class SimplePrivilege : BaseEntity
{
	public List<PlayerNameID> authorizedPlayers = new List<PlayerNameID>();

	public const Flags Flag_MaxAuths = Flags.Reserved5;

	public override void ResetState()
	{
		base.ResetState();
		authorizedPlayers.Clear();
	}

	public bool IsAuthed(BasePlayer player)
	{
		return authorizedPlayers.Any((PlayerNameID x) => x.userid == (ulong)player.userID);
	}

	public bool IsAuthed(ulong userID)
	{
		return authorizedPlayers.Any((PlayerNameID x) => x.userid == userID);
	}

	public bool AnyAuthed()
	{
		return authorizedPlayers.Count > 0;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.buildingPrivilege = Pool.Get<BuildingPrivilege>();
		info.msg.buildingPrivilege.users = authorizedPlayers;
	}

	public override void PostSave(SaveInfo info)
	{
		info.msg.buildingPrivilege.users = null;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		authorizedPlayers.Clear();
		if (info.msg.buildingPrivilege != null && info.msg.buildingPrivilege.users != null)
		{
			authorizedPlayers = info.msg.buildingPrivilege.users;
			info.msg.buildingPrivilege.users = null;
		}
	}

	public bool AtMaxAuthCapacity()
	{
		return HasFlag(Flags.Reserved5);
	}

	public void UpdateMaxAuthCapacity()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode) && activeGameMode.limitTeamAuths)
		{
			SetFlag(Flags.Reserved5, authorizedPlayers.Count >= activeGameMode.GetMaxRelationshipTeamSize());
		}
	}
}


using System.Collections.Generic;

public interface ISimpleUpgradable
{
	bool UpgradingEnabled();

	bool CanUpgrade(BasePlayer player, ItemDefinition upgradeItem);

	bool CostIsItem();

	void DoUpgrade(BasePlayer player, ItemDefinition upgradeItem);

	List<ItemDefinition> GetUpgradeItems();
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

internal static class SimpleUpgrade
{
	public static bool CanUpgrade(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if ((Object)(object)upgradeItem == (Object)null)
		{
			return false;
		}
		if (!player.CanInteract())
		{
			return false;
		}
		if (player.IsBuildingBlocked(((Component)entity).transform.position, ((Component)entity).transform.rotation, entity.bounds))
		{
			return false;
		}
		if ((Object)(object)((Component)upgradeItem).GetComponent<ItemModDeployable>() == (Object)null)
		{
			return false;
		}
		if (IsUpgradeBlocked(entity, upgradeItem, player))
		{
			return false;
		}
		if (!CanAffordUpgrade(entity, upgradeItem, player))
		{
			return false;
		}
		return true;
	}

	public static bool CanAffordUpgrade(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		ISimpleUpgradable simpleUpgradable = entity as ISimpleUpgradable;
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if (simpleUpgradable.CostIsItem())
		{
			return player.inventory.GetAmount(upgradeItem) > 0;
		}
		if ((Object)(object)upgradeItem.Blueprint == (Object)null)
		{
			return false;
		}
		if (!ItemModStudyBlueprint.IsBlueprintUnlocked(upgradeItem, player))
		{
			return false;
		}
		foreach (ItemAmount ingredient in upgradeItem.Blueprint.GetIngredients())
		{
			if ((float)player.inventory.GetAmount(ingredient.itemid) < ingredient.amount)
			{
				return false;
			}
		}
		return true;
	}

	public static void PayForUpgrade(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		if ((Object)(object)player == (Object)null || (player.IsInCreativeMode && Creative.freeBuild) || !(entity is ISimpleUpgradable simpleUpgradable))
		{
			return;
		}
		List<Item> list = new List<Item>();
		if (simpleUpgradable.CostIsItem())
		{
			player.inventory.Take(list, upgradeItem.itemid, 1);
			player.Command("note.inv " + upgradeItem.itemid + " " + -1);
		}
		else
		{
			foreach (ItemAmount ingredient in upgradeItem.Blueprint.GetIngredients())
			{
				player.inventory.Take(list, ingredient.itemid, (int)ingredient.amount);
				player.Command("note.inv " + ingredient.itemid + " " + ingredient.amount * -1f);
			}
		}
		foreach (Item item in list)
		{
			item.Remove();
		}
	}

	public static void DoUpgrade(BaseEntity entity, BasePlayer player, ItemDefinition upgradeItem)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		if (!(entity is ISimpleUpgradable simpleUpgradable) || !simpleUpgradable.CanUpgrade(player, upgradeItem))
		{
			return;
		}
		PayForUpgrade(entity, upgradeItem, player);
		EntityRef[] slots = entity.GetSlots();
		BaseEntity parentEntity = entity.GetParentEntity();
		bool flag = entity is DecayEntity decayEntity && decayEntity.HasFlag(BaseEntity.Flags.Reserved2);
		ItemModDeployable component = ((Component)upgradeItem).GetComponent<ItemModDeployable>();
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.entityPrefab.resourcePath, ((Component)entity).transform.position, ((Component)entity).transform.rotation);
		baseEntity.SetParent(parentEntity);
		baseEntity.OwnerID = player.userID;
		Deployable component2 = component.entityPrefab.Get().GetComponent<Deployable>();
		if (component2 != null && component2.placeEffect.isValid)
		{
			Effect.server.Run(component2.placeEffect.resourcePath, ((Component)entity).transform.position, Vector3.up);
		}
		DecayEntity decayEntity2 = baseEntity as DecayEntity;
		if ((Object)(object)decayEntity2 != (Object)null)
		{
			decayEntity2.timePlaced = entity.GetNetworkTime();
		}
		List<SprayCan.ChildPreserveInfo> list = Pool.Get<List<SprayCan.ChildPreserveInfo>>();
		foreach (BaseEntity child in entity.children)
		{
			list.Add(new SprayCan.ChildPreserveInfo
			{
				TargetEntity = child,
				TargetBone = child.parentBone,
				LocalPosition = ((Component)child).transform.localPosition,
				LocalRotation = ((Component)child).transform.localRotation
			});
		}
		foreach (SprayCan.ChildPreserveInfo item in list)
		{
			item.TargetEntity.SetParent(null, worldPositionStays: true);
		}
		entity.Kill();
		if (baseEntity is DecayEntity decayEntity3)
		{
			decayEntity3.AttachToBuilding(null);
		}
		baseEntity.Spawn();
		foreach (SprayCan.ChildPreserveInfo item2 in list)
		{
			item2.TargetEntity.SetParent(baseEntity, item2.TargetBone, worldPositionStays: true);
			((Component)item2.TargetEntity).transform.localPosition = item2.LocalPosition;
			((Component)item2.TargetEntity).transform.localRotation = item2.LocalRotation;
			item2.TargetEntity.SendNetworkUpdate();
		}
		baseEntity.SetSlots(slots);
		if (!flag && baseEntity is DecayEntity decayEntity4)
		{
			decayEntity4.StopBeingDemolishable();
		}
		Pool.FreeUnmanaged<SprayCan.ChildPreserveInfo>(ref list);
	}

	public static bool IsUpgradeBlocked(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)upgradeItem == (Object)null)
		{
			return true;
		}
		if ((Object)(object)entity == (Object)null)
		{
			return true;
		}
		if (entity is DecorDeployable)
		{
			return false;
		}
		if (entity is BaseLock)
		{
			return false;
		}
		ItemModDeployable component = ((Component)upgradeItem).GetComponent<ItemModDeployable>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(component.entityPrefab.resourceID);
		if (DeployVolume.Check(((Component)entity).transform.position, ((Component)entity).transform.rotation, volumes, ~((1 << ((Component)entity).gameObject.layer) | 0x20000000)))
		{
			return true;
		}
		Socket_Base[] array = PrefabAttribute.server.FindAll<Socket_Base>(component.entityPrefab.resourceID);
		bool flag = false;
		Construction.Target target = new Construction.Target
		{
			position = ((Component)entity).transform.position,
			rotation = ((Component)entity).transform.eulerAngles,
			normal = ((Component)entity).transform.up,
			ray = player.eyes.HeadRay()
		};
		Socket_Base[] array2 = array;
		foreach (Socket_Base obj in array2)
		{
			Construction.Placement place = obj.DoPlacement(target);
			bool flag2 = true;
			SocketMod[] socketMods = obj.socketMods;
			for (int j = 0; j < socketMods.Length; j++)
			{
				if (!socketMods[j].DoCheck(place))
				{
					flag2 = false;
					break;
				}
			}
			if (flag2)
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return true;
		}
		return false;
	}
}


using UnityEngine;

public class WallpaperModelRenderer : MonoBehaviour, ICustomMaterialReplacer, IClientComponent
{
	public Renderer rend;

	public Material[] defaultMaterials;

	public Material baseMaterial;

	public bool autoLoad;

	public Material targetMaterial;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Wallpaper/Wallpaper Settings")]
public class WallpaperSettings : BaseScriptableObject
{
	public enum Category
	{
		Wall = 1,
		Floor = 2,
		Ceiling = 3,
		Last = 3
	}

	[Flags]
	public enum Side
	{
		Soft = 1,
		Hard = 2
	}

	[Serializable]
	public struct WallpaperSetting
	{
		public GameObjectRef WallpaperPrefab;

		public BuildingBlock BuildingBlock;

		public Side side;
	}

	public WallpaperSetting[] Wallpapers;

	public WallpaperSetting[] Floorings;

	public WallpaperSetting[] Ceilings;

	public ItemAmount PlacementPrice;

	private static ItemDefinition _wallpaperItem;

	private static ItemDefinition _flooringItem;

	private static ItemDefinition _ceilingItem;

	public static ItemDefinition WallpaperItemDef
	{
		get
		{
			if ((Object)(object)_wallpaperItem == (Object)null)
			{
				_wallpaperItem = ItemManager.FindItemDefinition("wallpaper.wall");
			}
			return _wallpaperItem;
		}
	}

	public static ItemDefinition FlooringItemDef
	{
		get
		{
			if ((Object)(object)_flooringItem == (Object)null)
			{
				_flooringItem = ItemManager.FindItemDefinition("wallpaper.flooring");
			}
			return _flooringItem;
		}
	}

	public static ItemDefinition CeilingItemDef
	{
		get
		{
			if ((Object)(object)_ceilingItem == (Object)null)
			{
				_ceilingItem = ItemManager.FindItemDefinition("wallpaper.ceiling");
			}
			return _ceilingItem;
		}
	}

	private (WallpaperSetting setting, Category category)? GetMatchingSetting(BuildingBlock buildingBlock, int side)
	{
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return null;
		}
		Side side2 = (Side)(side + 1);
		WallpaperSetting[] wallpapers = Wallpapers;
		for (int i = 0; i < wallpapers.Length; i++)
		{
			WallpaperSetting item = wallpapers[i];
			if ((Object)(object)item.BuildingBlock != (Object)null && item.BuildingBlock.prefabID == buildingBlock.prefabID && (item.side & side2) != 0)
			{
				return (item, Category.Wall);
			}
		}
		wallpapers = Ceilings;
		for (int i = 0; i < wallpapers.Length; i++)
		{
			WallpaperSetting item2 = wallpapers[i];
			if ((Object)(object)item2.BuildingBlock != (Object)null && item2.BuildingBlock.prefabID == buildingBlock.prefabID && (item2.side & side2) != 0)
			{
				return (item2, Category.Ceiling);
			}
		}
		wallpapers = Floorings;
		for (int i = 0; i < wallpapers.Length; i++)
		{
			WallpaperSetting item3 = wallpapers[i];
			if ((Object)(object)item3.BuildingBlock != (Object)null && item3.BuildingBlock.prefabID == buildingBlock.prefabID && (item3.side & side2) != 0)
			{
				return (item3, Category.Floor);
			}
		}
		return null;
	}

	public Category GetCategory(BuildingBlock buildingBlock, int side)
	{
		(WallpaperSetting, Category)? matchingSetting = GetMatchingSetting(buildingBlock, side);
		if (!matchingSetting.HasValue)
		{
			return (Category)0;
		}
		return matchingSetting.Value.Item2;
	}

	public GameObjectRef GetWallpaperPrefab(BuildingBlock buildingBlock, int side)
	{
		(WallpaperSetting, Category)? matchingSetting = GetMatchingSetting(buildingBlock, side);
		if (!matchingSetting.HasValue)
		{
			return null;
		}
		return matchingSetting.Value.Item1.WallpaperPrefab;
	}

	public Construction GetConstruction(BuildingBlock buildingBlock, int side)
	{
		GameObjectRef wallpaperPrefab = GetWallpaperPrefab(buildingBlock, side);
		if (wallpaperPrefab == null)
		{
			return null;
		}
		if (buildingBlock.isServer)
		{
			return PrefabAttribute.server.Find<Construction>(wallpaperPrefab.resourceID);
		}
		return null;
	}

	public Deployable GetDeployable(BuildingBlock buildingBlock)
	{
		GameObjectRef wallpaperPrefab = GetWallpaperPrefab(buildingBlock, 0);
		if (wallpaperPrefab == null)
		{
			return null;
		}
		if (buildingBlock.isServer)
		{
			return PrefabAttribute.server.Find<Deployable>(wallpaperPrefab.resourceID);
		}
		return null;
	}

	public bool CanUseWallpaper(BuildingBlock buildingBlock)
	{
		if (GetWallpaperPrefab(buildingBlock, 0) == null)
		{
			return GetWallpaperPrefab(buildingBlock, 1) != null;
		}
		return true;
	}

	public static ItemDefinition GetItemDefForCategory(Category category)
	{
		return category switch
		{
			Category.Wall => WallpaperItemDef, 
			Category.Floor => FlooringItemDef, 
			Category.Ceiling => CeilingItemDef, 
			_ => null, 
		};
	}

	public ItemDefinition GetWallpaperItem(BuildingBlock buildingBlock, int side)
	{
		(WallpaperSetting, Category)? matchingSetting = GetMatchingSetting(buildingBlock, side);
		if (!matchingSetting.HasValue)
		{
			return null;
		}
		return GetItemDefForCategory(matchingSetting.Value.Item2);
	}

	public int GetSideThatMustBeInside(BuildingBlock buildingBlock)
	{
		string prefabName = buildingBlock.PrefabName;
		if (prefabName.Contains("floor"))
		{
			return 1;
		}
		if (prefabName.Contains("wall"))
		{
			return 1;
		}
		return -1;
	}
}


public enum Category
{
	Wall = 1,
	Floor = 2,
	Ceiling = 3,
	Last = 3
}


using System;

[Flags]
public enum Side
{
	Soft = 1,
	Hard = 2
}


using System;

[Serializable]
public struct WallpaperSetting
{
	public GameObjectRef WallpaperPrefab;

	public BuildingBlock BuildingBlock;

	public Side side;
}


using UnityEngine;

public class WallpaperViewModel : MonoBehaviour
{
	public GameObject[] models;

	public void ToggleModels(WallpaperSettings.Category mode)
	{
		for (int i = 0; i < models.Length; i++)
		{
			models[i].SetActive(mode - 1 == (WallpaperSettings.Category)i);
		}
	}
}


using UnityEngine;

public class DeployableToSlot : MonoBehaviour
{
	public BaseEntity.Slot slot;
}


using UnityEngine;

public class EntityCollisionMessage : EntityComponent<BaseEntity>
{
	private void OnCollisionEnter(Collision collision)
	{
		if ((Object)(object)base.baseEntity == (Object)null || base.baseEntity.IsDestroyed)
		{
			return;
		}
		BaseEntity baseEntity = collision.GetEntity();
		if ((Object)(object)baseEntity == (Object)(object)base.baseEntity)
		{
			return;
		}
		if ((Object)(object)baseEntity != (Object)null)
		{
			if (baseEntity.IsDestroyed)
			{
				return;
			}
			if (base.baseEntity.isServer)
			{
				baseEntity = baseEntity.ToServer<BaseEntity>();
			}
		}
		base.baseEntity.OnCollision(collision, baseEntity);
	}
}


using System;
using UnityEngine;

public class EntityComponent<T> : EntityComponentBase where T : BaseEntity
{
	[NonSerialized]
	public T _baseEntity;

	public T baseEntity
	{
		get
		{
			if ((Object)(object)_baseEntity == (Object)null)
			{
				UpdateBaseEntity();
			}
			return _baseEntity;
		}
	}

	protected void UpdateBaseEntity()
	{
		if (Object.op_Implicit((Object)(object)this) && Object.op_Implicit((Object)(object)((Component)this).gameObject))
		{
			_baseEntity = ((Component)this).gameObject.ToBaseEntity() as T;
		}
	}

	public override BaseEntity GetBaseEntity()
	{
		return baseEntity;
	}

	public T GetCastedEntity()
	{
		return baseEntity;
	}
}


using Network;

public class EntityComponentBase : BaseMonoBehaviour
{
	public virtual BaseEntity GetBaseEntity()
	{
		return null;
	}

	public virtual void InitShared()
	{
	}

	public virtual void ResetState()
	{
	}

	public virtual void DestroyShared()
	{
	}

	public virtual void SaveComponent(BaseNetworkable.SaveInfo info)
	{
	}

	public virtual void LoadComponent(BaseNetworkable.LoadInfo info)
	{
	}

	public virtual void Hurt(HitInfo hitInfo)
	{
	}

	public virtual bool OnDied(HitInfo info)
	{
		return true;
	}

	public virtual bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		return false;
	}
}


using System.Diagnostics;
using UnityEngine;

public class EntityDebug : EntityComponent<BaseEntity>
{
	internal Stopwatch stopwatch = Stopwatch.StartNew();

	private void Update()
	{
		if (!base.baseEntity.IsValid() || !base.baseEntity.IsDebugging())
		{
			((Behaviour)this).enabled = false;
		}
		else if (!(stopwatch.Elapsed.TotalSeconds < 0.5))
		{
			_ = base.baseEntity.isClient;
			if (base.baseEntity.isServer)
			{
				base.baseEntity.DebugServer(1, (float)stopwatch.Elapsed.TotalSeconds);
			}
			stopwatch.Reset();
			stopwatch.Start();
		}
	}
}


using UnityEngine;

public class EntityFlag_Animator : EntityFlag_Toggle
{
	public enum AnimatorMode
	{
		Bool,
		Float,
		Trigger,
		Integer
	}

	public Animator TargetAnimator;

	public string ParamName = string.Empty;

	public AnimatorMode AnimationMode;

	public float FloatOnState;

	public float FloatOffState;

	public int IntegerOnState;

	public int IntegerOffState;
}


public enum AnimatorMode
{
	Bool,
	Float,
	Trigger,
	Integer
}


using System;
using UnityEngine;

public class EntityFlag_TOD : EntityComponent<BaseEntity>
{
	public BaseEntity.Flags desiredFlag;

	public bool onAtNight = true;

	public void Start()
	{
		((FacepunchBehaviour)this).Invoke((Action)Initialize, 1f);
	}

	public void Initialize()
	{
		if (!((Object)(object)base.baseEntity == (Object)null) && !base.baseEntity.isClient)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)DoTimeCheck, 0f, 5f, 1f);
		}
	}

	public bool WantsOn()
	{
		if ((Object)(object)TOD_Sky.Instance == (Object)null)
		{
			return false;
		}
		bool isNight = TOD_Sky.Instance.IsNight;
		if (onAtNight == isNight)
		{
			return true;
		}
		return false;
	}

	private void DoTimeCheck()
	{
		bool num = base.baseEntity.HasFlag(desiredFlag);
		bool flag = WantsOn();
		if (num != flag)
		{
			base.baseEntity.SetFlag(desiredFlag, flag);
		}
	}
}


using UnityEngine;
using UnityEngine.Events;

public class EntityFlag_Toggle : EntityComponent<BaseEntity>, IOnPostNetworkUpdate, IOnSendNetworkUpdate, IPrefabPreProcess
{
	private enum FlagCheck
	{
		All,
		Any
	}

	public bool runClientside = true;

	[Tooltip("Server-side only works if the EntityFlag_Toggle is on the same GameObject as the Entity")]
	public bool runServerside = true;

	public BaseEntity.Flags flag;

	[Tooltip("If multiple flags are defined in 'flag', should they all be set, or any?")]
	[SerializeField]
	private FlagCheck flagCheck;

	[SerializeField]
	[Tooltip("Specify any flags that must NOT be on for this toggle to be on")]
	private BaseEntity.Flags notFlag;

	[SerializeField]
	private UnityEvent onFlagEnabled = new UnityEvent();

	[SerializeField]
	private UnityEvent onFlagDisabled = new UnityEvent();

	internal bool hasRunOnce;

	internal bool lastToggleOn;

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	protected void OnDisable()
	{
		hasRunOnce = false;
		lastToggleOn = false;
	}

	public void DoUpdate(BaseEntity entity)
	{
		bool flag = ((flagCheck == FlagCheck.All) ? entity.HasFlag(this.flag) : entity.HasAny(this.flag));
		if (entity.HasAny(notFlag))
		{
			flag = false;
		}
		if (!hasRunOnce || flag != lastToggleOn)
		{
			hasRunOnce = true;
			lastToggleOn = flag;
			if (flag)
			{
				onFlagEnabled.Invoke();
			}
			else
			{
				onFlagDisabled.Invoke();
			}
			OnStateToggled(flag);
		}
	}

	protected virtual void OnStateToggled(bool state)
	{
	}

	public void OnPostNetworkUpdate(BaseEntity entity)
	{
		if (!((Object)(object)base.baseEntity != (Object)(object)entity) && runClientside)
		{
			DoUpdate(entity);
		}
	}

	public void OnSendNetworkUpdate(BaseEntity entity)
	{
		if (runServerside)
		{
			DoUpdate(entity);
		}
	}

	public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if ((!clientside || !runClientside) && (!serverside || !runServerside))
		{
			process.RemoveComponent((Component)(object)this);
		}
	}
}


private enum FlagCheck
{
	All,
	Any
}


using UnityEngine;

public class EntityFlag_ToggleNotify : EntityFlag_Toggle
{
	public bool UseEntityParent;

	protected override void OnStateToggled(bool state)
	{
		base.OnStateToggled(state);
		if (!UseEntityParent && (Object)(object)base.baseEntity != (Object)null && base.baseEntity is IFlagNotify flagNotify)
		{
			flagNotify.OnFlagToggled(state);
		}
		if (UseEntityParent && (Object)(object)base.baseEntity != (Object)null && (Object)(object)base.baseEntity.GetParentEntity() != (Object)null && base.baseEntity.GetParentEntity() is IFlagNotify flagNotify2)
		{
			flagNotify2.OnFlagToggled(state);
		}
	}
}


public interface IFlagNotify
{
	void OnFlagToggled(bool state);
}


using System;
using UnityEngine;

public class EntityItem_RotateWhenOn : EntityComponent<BaseEntity>
{
	[Serializable]
	public class State
	{
		public Vector3 rotation;

		public float initialDelay;

		public float timeToTake = 2f;

		public AnimationCurve animationCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		});

		public string effectOnStart = "";

		public string effectOnFinish = "";

		public SoundDefinition movementLoop;

		public float movementLoopFadeOutTime = 0.1f;

		public SoundDefinition startSound;

		public SoundDefinition stopSound;
	}

	public State on;

	public State off;

	internal bool currentlyOn;

	internal bool stateInitialized;

	public BaseEntity.Flags targetFlag = BaseEntity.Flags.On;
}


using System;
using UnityEngine;

[Serializable]
public class State
{
	public Vector3 rotation;

	public float initialDelay;

	public float timeToTake = 2f;

	public AnimationCurve animationCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 0f),
		new Keyframe(1f, 1f)
	});

	public string effectOnStart = "";

	public string effectOnFinish = "";

	public SoundDefinition movementLoop;

	public float movementLoopFadeOutTime = 0.1f;

	public SoundDefinition startSound;

	public SoundDefinition stopSound;
}


using System;
using UnityEngine;

public class EntityTimedDestroy : EntityComponent<BaseEntity>
{
	public float secondsTillDestroy = 1f;

	private void OnEnable()
	{
		((FacepunchBehaviour)this).Invoke((Action)TimedDestroy, secondsTillDestroy);
	}

	private void TimedDestroy()
	{
		if ((Object)(object)base.baseEntity != (Object)null)
		{
			base.baseEntity.Kill();
		}
		else
		{
			Debug.LogWarning((object)"EntityTimedDestroy failed, baseEntity was already null!");
		}
	}
}


using UnityEngine;

public class HeadDispenser : EntityComponent<BaseEntity>
{
	public ItemDefinition HeadDef;

	public GameObjectRef SourceEntity;

	private bool hasDispensed;

	public BaseEntity overrideEntity { get; set; }

	public void DispenseHead(HitInfo info, BaseCorpse corpse)
	{
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		if (hasDispensed || !(info.Weapon is BaseMelee baseMelee) || !baseMelee.gathering.ProduceHeadItem)
		{
			return;
		}
		if ((Object)(object)info.InitiatorPlayer != (Object)null)
		{
			Item item = ItemManager.CreateByItemID(HeadDef.itemid, 1, 0uL);
			item.SetItemOwnership(info.InitiatorPlayer, ItemOwnershipPhrases.Beheaded);
			HeadEntity associatedEntity = ItemModAssociatedEntity<HeadEntity>.GetAssociatedEntity(item);
			BaseEntity baseEntity = (((Object)(object)overrideEntity != (Object)null) ? overrideEntity : SourceEntity.GetEntity());
			overrideEntity = null;
			if ((Object)(object)associatedEntity != (Object)null && (Object)(object)baseEntity != (Object)null)
			{
				associatedEntity.SetupSourceId(baseEntity.prefabID);
				if (corpse is PlayerCorpse playerCorpse)
				{
					associatedEntity.SetupPlayerId(playerCorpse.playerName, playerCorpse.playerSteamID);
					associatedEntity.AssignClothing(playerCorpse.containers[1]);
				}
				else if (corpse is HorseCorpse horseCorpse)
				{
					associatedEntity.AssignHorseBreed(horseCorpse.breedIndex);
				}
			}
			if (info.InitiatorPlayer.inventory.GiveItem(item))
			{
				info.InitiatorPlayer.Command("note.inv", HeadDef.itemid, 1);
			}
			else
			{
				item.DropAndTossUpwards(info.HitPositionWorld);
			}
		}
		hasDispensed = true;
	}
}


using UnityEngine;

public class HideIfOwnerFirstPerson : EntityComponent<BaseEntity>, IClientComponent, IViewModeChanged
{
	public GameObject[] disableGameObjects;

	public bool worldModelEffect;
}


using UnityEngine;

public class HumanBodyResourceDispenser : ResourceDispenser
{
	public override bool OverrideOwnership(Item item, AttackEntity weapon)
	{
		if (item.info.shortname == "skull.human")
		{
			PlayerCorpse component = ((Component)this).GetComponent<PlayerCorpse>();
			if (Object.op_Implicit((Object)(object)component))
			{
				item.name = CreateSkullName(component.playerName);
				item.streamerName = CreateSkullName(component.streamerName);
				return true;
			}
		}
		return false;
	}

	public static string CreateSkullName(string playerName)
	{
		return "Skull of \"" + playerName + "\"";
	}
}


using UnityEngine;

public class LerpBetweenPointsBool : MonoBehaviour, IClientComponent
{
	public Vector3 offsetPosLocal;

	public float speed;

	public bool UseAsOffset;

	public void SetAtOffset(bool should)
	{
	}
}


using UnityEngine;

public class LootDistanceOverride : MonoBehaviour
{
	public float amount = 2.1f;
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

public class ResourceDispenser : EntityComponent<BaseEntity>, IServerComponent
{
	public enum GatherType
	{
		Tree,
		Ore,
		Flesh,
		UNSET,
		LAST
	}

	[Serializable]
	public class GatherPropertyEntry
	{
		public float gatherDamage;

		public float destroyFraction;

		public float conditionLost;
	}

	[Serializable]
	public class GatherProperties
	{
		public GatherPropertyEntry Tree;

		public GatherPropertyEntry Ore;

		public GatherPropertyEntry Flesh;

		public bool ProduceHeadItem;

		public float GetProficiency()
		{
			float num = 0f;
			for (int i = 0; i < 3; i++)
			{
				GatherPropertyEntry fromIndex = GetFromIndex(i);
				float num2 = fromIndex.gatherDamage * fromIndex.destroyFraction;
				if (num2 > 0f)
				{
					num += fromIndex.gatherDamage / num2;
				}
			}
			return num;
		}

		public bool Any()
		{
			for (int i = 0; i < 3; i++)
			{
				GatherPropertyEntry fromIndex = GetFromIndex(i);
				if (fromIndex.gatherDamage > 0f || fromIndex.conditionLost > 0f)
				{
					return true;
				}
			}
			return false;
		}

		public GatherPropertyEntry GetFromIndex(int index)
		{
			return GetFromIndex((GatherType)index);
		}

		public GatherPropertyEntry GetFromIndex(GatherType index)
		{
			return index switch
			{
				GatherType.Tree => Tree, 
				GatherType.Ore => Ore, 
				GatherType.Flesh => Flesh, 
				_ => null, 
			};
		}
	}

	public Phrase OwnershipPhrase;

	public GatherType gatherType = GatherType.UNSET;

	public List<ItemAmount> containedItems;

	public float maxDestroyFractionForFinishBonus = 0.2f;

	public List<ItemAmount> finishBonus;

	public bool forceFullFinishBonus;

	public float fractionRemaining = 1f;

	private float categoriesRemaining;

	private float startingItemCounts;

	private static Dictionary<GatherType, HashSet<int>> cachedResourceItemTypes;

	public void Start()
	{
		Initialize();
	}

	public void Initialize()
	{
		CacheResourceTypeItems();
		UpdateFraction();
		UpdateRemainingCategories();
		CountAllItems();
	}

	private void CacheResourceTypeItems()
	{
		if (cachedResourceItemTypes == null)
		{
			cachedResourceItemTypes = new Dictionary<GatherType, HashSet<int>>();
			HashSet<int> hashSet = new HashSet<int>();
			hashSet.Add(ItemManager.FindItemDefinition("wood").itemid);
			cachedResourceItemTypes.Add(GatherType.Tree, hashSet);
			HashSet<int> hashSet2 = new HashSet<int>();
			hashSet2.Add(ItemManager.FindItemDefinition("stones").itemid);
			hashSet2.Add(ItemManager.FindItemDefinition("sulfur.ore").itemid);
			hashSet2.Add(ItemManager.FindItemDefinition("metal.ore").itemid);
			hashSet2.Add(ItemManager.FindItemDefinition("hq.metal.ore").itemid);
			cachedResourceItemTypes.Add(GatherType.Ore, hashSet2);
		}
	}

	public void DoGather(HitInfo info, BaseCorpse corpse = null)
	{
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		if (!base.baseEntity.isServer || !info.CanGather || info.DidGather)
		{
			return;
		}
		if (gatherType == GatherType.UNSET)
		{
			Debug.LogWarning((object)("Object :" + ((Object)((Component)this).gameObject).name + ": has unset gathertype!"));
			return;
		}
		float num = 0f;
		float num2 = 0f;
		float num3 = (((Object)(object)info.InitiatorPlayer != (Object)null && info.InitiatorPlayer.HasPlayerFlag(BasePlayer.PlayerFlags.IsInTutorial)) ? 3f : 1f);
		BaseMelee baseMelee = (((Object)(object)info.Weapon == (Object)null) ? null : (info.Weapon as BaseMelee));
		if ((Object)(object)baseMelee != (Object)null)
		{
			GatherPropertyEntry gatherInfoFromIndex = baseMelee.GetGatherInfoFromIndex(gatherType);
			num = gatherInfoFromIndex.gatherDamage * info.gatherScale * num3;
			num2 = gatherInfoFromIndex.destroyFraction;
			if (num == 0f)
			{
				return;
			}
			baseMelee.SendPunch(new Vector3(Random.Range(0.5f, 1f), Random.Range(-0.25f, -0.5f), 0f) * -30f * (gatherInfoFromIndex.conditionLost / 6f), 0.05f);
			baseMelee.LoseCondition(gatherInfoFromIndex.conditionLost);
			if (!baseMelee.IsValid() || baseMelee.IsBroken())
			{
				return;
			}
			info.DidGather = true;
		}
		else
		{
			num = info.damageTypes.Total();
			num2 = 0.5f;
		}
		float num4 = fractionRemaining;
		GiveResources(info.InitiatorPlayer, num, num2, info.Weapon);
		UpdateFraction();
		float num5 = 0f;
		if (fractionRemaining <= 0f)
		{
			num5 = base.baseEntity.MaxHealth();
			if (info.DidGather && num2 < maxDestroyFractionForFinishBonus)
			{
				AssignFinishBonus(info.InitiatorPlayer, 1f - num2, info.Weapon);
			}
			HeadDispenser headDispenser = default(HeadDispenser);
			if (((Component)this).gameObject.TryGetComponent<HeadDispenser>(ref headDispenser))
			{
				headDispenser.DispenseHead(info, corpse);
			}
		}
		else
		{
			num5 = (num4 - fractionRemaining) * base.baseEntity.MaxHealth();
		}
		HitInfo hitInfo = new HitInfo(info.Initiator, base.baseEntity, DamageType.Generic, num5, ((Component)this).transform.position);
		hitInfo.gatherScale = 0f;
		hitInfo.PointStart = info.PointStart;
		hitInfo.PointEnd = info.PointEnd;
		hitInfo.WeaponPrefab = info.WeaponPrefab;
		hitInfo.Weapon = info.Weapon;
		base.baseEntity.OnAttacked(hitInfo);
	}

	public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)
	{
		if (forceFullFinishBonus)
		{
			fraction = 1f;
		}
		((Component)this).SendMessage("FinishBonusAssigned", (SendMessageOptions)1);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			int num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));
			int num2 = CalculateGatherBonus(player, finishBonu, num);
			Item item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", (object)this, (object)player, (object)item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				ApplyItemOwnership(player, item);
				Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);
				Interface.CallHook("OnDispenserBonusReceived", (object)this, (object)player, (object)item);
				while (item.amount > item.MaxStackable())
				{
					Item item2 = item.SplitItem(item.MaxStackable());
					player.GiveItem(item2, BaseEntity.GiveItemReason.ResourceHarvested);
				}
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

	public void OnAttacked(HitInfo info)
	{
		DoGather(info);
	}

	private void GiveResources(BasePlayer entity, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		if (!entity.IsValid() || gatherDamage <= 0f)
		{
			return;
		}
		ItemAmount itemAmount = null;
		int num = containedItems.Count;
		int num2 = Random.Range(0, containedItems.Count);
		while (num > 0)
		{
			if (num2 >= containedItems.Count)
			{
				num2 = 0;
			}
			if (containedItems[num2].amount > 0f)
			{
				itemAmount = containedItems[num2];
				break;
			}
			num2++;
			num--;
		}
		if (itemAmount == null)
		{
			return;
		}
		GiveResourceFromItem(entity, itemAmount, gatherDamage, destroyFraction, attackWeapon);
		UpdateVars();
		if (Object.op_Implicit((Object)(object)entity))
		{
			Debug.Assert(attackWeapon.GetItem() != null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " has no Item");
			Debug.Assert(((ItemId)(ref attackWeapon.ownerItemUID)).IsValid, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerItemUID is 0");
			Debug.Assert((Object)(object)attackWeapon.GetParentEntity() != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is null");
			Debug.Assert(attackWeapon.GetParentEntity().IsValid(), "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is not valid");
			Debug.Assert((Object)(object)attackWeapon.GetParentEntity().ToPlayer() != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is not a player");
			Debug.Assert(!attackWeapon.GetParentEntity().ToPlayer().IsDead(), "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is not valid");
			BasePlayer ownerPlayer = attackWeapon.GetOwnerPlayer();
			Debug.Assert((Object)(object)ownerPlayer != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerPlayer is null");
			Debug.Assert((Object)(object)ownerPlayer == (Object)(object)entity, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerPlayer is not player");
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				Debug.Assert((Object)(object)ownerPlayer.inventory != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerPlayer inventory is null");
				Debug.Assert(ownerPlayer.inventory.FindItemByUID(attackWeapon.ownerItemUID) != null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " FindItemByUID is null");
			}
		}
	}

	public void DestroyFraction(float fraction)
	{
		foreach (ItemAmount containedItem in containedItems)
		{
			if (containedItem.amount > 0f)
			{
				containedItem.amount -= fraction / categoriesRemaining;
			}
		}
		UpdateVars();
	}

	private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float num3 = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		num3 = Mathf.Round(num3);
		float num4 = num3 * destroyFraction * 2f;
		if (itemAmt.amount <= num3 + num4)
		{
			float num5 = (num3 + num4) / itemAmt.amount;
			num3 /= num5;
			num4 /= num5;
		}
		itemAmt.amount -= Mathf.Floor(num3);
		itemAmt.amount -= Mathf.Floor(num4);
		if (num3 < 1f)
		{
			num3 = ((Random.Range(0f, 1f) <= num3) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (!(num3 >= 1f))
		{
			return;
		}
		int num6 = CalculateGatherBonus(entity, itemAmt, num3);
		int iAmount = Mathf.FloorToInt(num3) + num6;
		Item item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);
		if (Interface.CallHook("OnDispenserGather", (object)this, (object)entity, (object)item) == null && item != null)
		{
			ApplyItemOwnership(entity, item);
			OverrideOwnership(item, attackWeapon);
			Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);
			Interface.CallHook("OnDispenserGathered", (object)this, (object)entity, (object)item);
			while (item.amount > item.MaxStackable())
			{
				Item item2 = item.SplitItem(item.MaxStackable());
				entity.GiveItem(item2, BaseEntity.GiveItemReason.ResourceHarvested);
			}
			entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
		}
	}

	private void ApplyItemOwnership(BasePlayer player, Item item)
	{
		if (OwnershipPhrase != null && !string.IsNullOrEmpty(OwnershipPhrase.token))
		{
			item.SetItemOwnership(player, OwnershipPhrase.token);
		}
		else
		{
			item.SetItemOwnership(player, ItemOwnershipPhrases.GatheredPhrase);
		}
	}

	private int CalculateGatherBonus(BaseEntity entity, ItemAmount item, float amountToGive)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return 0;
		}
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return 0;
		}
		if ((Object)(object)basePlayer.modifiers == (Object)null)
		{
			return 0;
		}
		amountToGive = Mathf.FloorToInt(amountToGive);
		float num = 1f;
		Modifier.ModifierType type;
		switch (gatherType)
		{
		case GatherType.Tree:
			type = Modifier.ModifierType.Wood_Yield;
			break;
		case GatherType.Ore:
			type = Modifier.ModifierType.Ore_Yield;
			break;
		case GatherType.Flesh:
			type = Modifier.ModifierType.Harvesting;
			break;
		default:
			return 0;
		}
		if (!IsProducedItemOfGatherType(item))
		{
			return 0;
		}
		num += basePlayer.modifiers.GetValue(type);
		float variableValue = basePlayer.modifiers.GetVariableValue(type, 0f);
		float num2 = ((num > 1f) ? Mathf.Max(amountToGive * num - amountToGive, 0f) : 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(type, variableValue);
		return num3;
	}

	private bool IsProducedItemOfGatherType(ItemAmount item)
	{
		if (gatherType == GatherType.Tree)
		{
			return cachedResourceItemTypes[GatherType.Tree].Contains(item.itemid);
		}
		if (gatherType == GatherType.Ore)
		{
			return cachedResourceItemTypes[GatherType.Ore].Contains(item.itemid);
		}
		if (gatherType == GatherType.Flesh)
		{
			return item.startAmount > 1f;
		}
		return false;
	}

	public virtual bool OverrideOwnership(Item item, AttackEntity weapon)
	{
		return false;
	}

	private void UpdateVars()
	{
		UpdateFraction();
		UpdateRemainingCategories();
	}

	public void UpdateRemainingCategories()
	{
		int num = 0;
		foreach (ItemAmount containedItem in containedItems)
		{
			if (containedItem.amount > 0f)
			{
				num++;
			}
		}
		categoriesRemaining = num;
	}

	public void CountAllItems()
	{
		startingItemCounts = containedItems.Sum((ItemAmount x) => x.startAmount);
	}

	private void UpdateFraction()
	{
		float num = containedItems.Sum((ItemAmount x) => x.startAmount);
		float num2 = containedItems.Sum((ItemAmount x) => x.amount);
		if (num == 0f)
		{
			fractionRemaining = 0f;
		}
		else
		{
			fractionRemaining = num2 / num;
		}
	}

	public bool HasItemToDispense(ItemDefinition def)
	{
		if ((Object)(object)def == (Object)null)
		{
			return false;
		}
		foreach (ItemAmount containedItem in containedItems)
		{
			if ((Object)(object)containedItem.itemDef == (Object)(object)def && containedItem.amount > 0f)
			{
				return true;
			}
		}
		return false;
	}
}


public enum GatherType
{
	Tree,
	Ore,
	Flesh,
	UNSET,
	LAST
}


using System;

[Serializable]
public class GatherPropertyEntry
{
	public float gatherDamage;

	public float destroyFraction;

	public float conditionLost;
}


using System;

[Serializable]
public class GatherProperties
{
	public GatherPropertyEntry Tree;

	public GatherPropertyEntry Ore;

	public GatherPropertyEntry Flesh;

	public bool ProduceHeadItem;

	public float GetProficiency()
	{
		float num = 0f;
		for (int i = 0; i < 3; i++)
		{
			GatherPropertyEntry fromIndex = GetFromIndex(i);
			float num2 = fromIndex.gatherDamage * fromIndex.destroyFraction;
			if (num2 > 0f)
			{
				num += fromIndex.gatherDamage / num2;
			}
		}
		return num;
	}

	public bool Any()
	{
		for (int i = 0; i < 3; i++)
		{
			GatherPropertyEntry fromIndex = GetFromIndex(i);
			if (fromIndex.gatherDamage > 0f || fromIndex.conditionLost > 0f)
			{
				return true;
			}
		}
		return false;
	}

	public GatherPropertyEntry GetFromIndex(int index)
	{
		return GetFromIndex((GatherType)index);
	}

	public GatherPropertyEntry GetFromIndex(GatherType index)
	{
		return index switch
		{
			GatherType.Tree => Tree, 
			GatherType.Ore => Ore, 
			GatherType.Flesh => Flesh, 
			_ => null, 
		};
	}
}


using System;
using Rust;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class Barricade : DecayEntity
{
	public float reflectDamage = 5f;

	public GameObjectRef reflectEffect;

	public bool canNpcSmash = true;

	public NavMeshModifierVolume NavMeshVolumeAnimals;

	public NavMeshModifierVolume NavMeshVolumeHumanoids;

	[NonSerialized]
	public NPCBarricadeTriggerBox NpcTriggerBox;

	private static int nonWalkableArea = -1;

	private static int animalAgentTypeId = -1;

	private static int humanoidAgentTypeId = -1;

	public override void ServerInit()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (nonWalkableArea < 0)
		{
			nonWalkableArea = NavMesh.GetAreaFromName("Not Walkable");
		}
		NavMeshBuildSettings settingsByIndex;
		if (animalAgentTypeId < 0)
		{
			settingsByIndex = NavMesh.GetSettingsByIndex(1);
			animalAgentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		}
		if ((Object)(object)NavMeshVolumeAnimals == (Object)null)
		{
			NavMeshVolumeAnimals = ((Component)this).gameObject.AddComponent<NavMeshModifierVolume>();
			NavMeshVolumeAnimals.area = nonWalkableArea;
			NavMeshVolumeAnimals.AddAgentType(animalAgentTypeId);
			NavMeshVolumeAnimals.center = Vector3.zero;
			NavMeshVolumeAnimals.size = Vector3.one;
		}
		if (!canNpcSmash)
		{
			if (humanoidAgentTypeId < 0)
			{
				settingsByIndex = NavMesh.GetSettingsByIndex(0);
				humanoidAgentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
			}
			if ((Object)(object)NavMeshVolumeHumanoids == (Object)null)
			{
				NavMeshVolumeHumanoids = ((Component)this).gameObject.AddComponent<NavMeshModifierVolume>();
				NavMeshVolumeHumanoids.area = nonWalkableArea;
				NavMeshVolumeHumanoids.AddAgentType(humanoidAgentTypeId);
				NavMeshVolumeHumanoids.center = Vector3.zero;
				NavMeshVolumeHumanoids.size = Vector3.one;
			}
		}
		else if ((Object)(object)NpcTriggerBox == (Object)null)
		{
			NpcTriggerBox = new GameObject("NpcTriggerBox").AddComponent<NPCBarricadeTriggerBox>();
			NpcTriggerBox.Setup(this);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && info.WeaponPrefab is BaseMelee && !info.IsProjectile())
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			if (Object.op_Implicit((Object)(object)basePlayer) && reflectDamage > 0f)
			{
				basePlayer.Hurt(reflectDamage * Random.Range(0.75f, 1.25f), DamageType.Stab, this);
				if (reflectEffect.isValid)
				{
					Effect.server.Run(reflectEffect.resourcePath, basePlayer, StringPool.closest, ((Component)this).transform.position, Vector3.up);
				}
			}
		}
		base.OnAttacked(info);
	}
}


public class BaseFuelLightSource : BaseOven
{
}


public class BaseLadder : BaseCombatEntity
{
	public override bool ShouldBlockProjectiles()
	{
		return false;
	}
}


using UnityEngine;

public class BoxStorage : StorageContainer
{
	public Hopper.MountType HopperMountType;

	public override Vector3 GetDropPosition()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return ClosestPoint(base.GetDropPosition() + base.LastAttackedDir * 10f);
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (children.Count != 0)
		{
			pickupErrorToFormat = (format: PickupErrors.ItemHasAttachment, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}
}


using System;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class ElectricOven : BaseOven
{
	public GameObjectRef IoEntity;

	public Transform IoEntityAnchor;

	public EntityRef<IOEntity> spawnedIo;

	public override bool CanRunWithNoFuel
	{
		get
		{
			if (spawnedIo.IsValid(serverside: true))
			{
				return spawnedIo.Get(serverside: true).IsPowered();
			}
			return false;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SpawnIOEnt();
		}
	}

	public void SpawnIOEnt()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (IoEntity.isValid && (Object)(object)IoEntityAnchor != (Object)null)
		{
			IOEntity iOEntity = GameManager.server.CreateEntity(IoEntity.resourcePath, IoEntityAnchor.position, IoEntityAnchor.rotation) as IOEntity;
			iOEntity.SetParent(this, worldPositionStays: true);
			spawnedIo.Set(iOEntity);
			iOEntity.Spawn();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.simpleUID == null)
		{
			info.msg.simpleUID = Pool.Get<SimpleUID>();
		}
		info.msg.simpleUID.uid = spawnedIo.uid;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.simpleUID != null)
		{
			spawnedIo.uid = info.msg.simpleUID.uid;
		}
	}

	public override void OvenFull()
	{
		((FacepunchBehaviour)this).Invoke((Action)PauseCooking, 0f);
	}

	private void PauseCooking()
	{
		UpdateAttachmentTemperature();
		if (base.inventory != null)
		{
			base.inventory.temperature = 15f;
			foreach (Item item in base.inventory.itemList)
			{
				if (item.HasFlag(Item.Flag.OnFire))
				{
					item.SetFlag(Item.Flag.OnFire, b: false);
					item.MarkDirty();
				}
				if (item.HasFlag(Item.Flag.Cooking))
				{
					item.SetFlag(Item.Flag.Cooking, b: false);
					item.MarkDirty();
				}
			}
		}
		SetFlag(Flags.Reserved8, b: true);
	}

	public override void OnItemAddedOrRemoved(Item item, bool bAdded)
	{
		base.OnItemAddedOrRemoved(item, bAdded);
		if (item != null && !bAdded && HasFlag(Flags.Reserved8))
		{
			SetFlag(Flags.Reserved8, b: false);
		}
	}

	protected override bool CanPickupOven()
	{
		return children.Count == 1;
	}
}


public interface IImageReceiver
{
}


using UnityEngine;

public class ItemModSculpture : ItemModAssociatedEntity<AssociatedSculptureStorage>
{
	protected override bool AllowNullParenting => true;

	protected override bool ShouldAutoCreateEntity => false;

	public void OnSculpturePickUp(NetworkableId id, uint crc, Item item)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		AssociatedSculptureStorage associatedSculptureStorage = CreateAssociatedEntity(item);
		if ((Object)(object)associatedSculptureStorage != (Object)null)
		{
			associatedSculptureStorage.InitFromSculpture(crc, id);
		}
	}
}


using UnityEngine;

public class ItemModSign : ItemModAssociatedEntity<SignContent>
{
	protected override bool AllowNullParenting => true;

	protected override bool ShouldAutoCreateEntity => false;

	public void OnSignPickedUp(ISignage s, IUGCBrowserEntity ugc, Item toItem)
	{
		SignContent signContent = CreateAssociatedEntity(toItem);
		if ((Object)(object)signContent != (Object)null)
		{
			signContent.CopyInfoFromSign(s, ugc);
		}
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class PercentFullStorageContainer : StorageContainer
{
	private float prevPercentFull = -1f;

	public bool IsFull()
	{
		return GetPercentFull() == 1f;
	}

	public bool IsEmpty()
	{
		return GetPercentFull() == 0f;
	}

	protected virtual void OnPercentFullChanged(float newPercentFull)
	{
	}

	public float GetPercentFull()
	{
		if (base.isServer)
		{
			float num = 0f;
			if (base.inventory != null)
			{
				foreach (Item item in base.inventory.itemList)
				{
					num += (float)item.amount / (float)item.MaxStackable();
				}
				num /= (float)base.inventory.capacity;
			}
			return num;
		}
		return 0f;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.simpleInt;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.simpleInt = Pool.Get<SimpleInt>();
		info.msg.simpleInt.value = Mathf.CeilToInt(GetPercentFull() * 100f);
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		float percentFull = GetPercentFull();
		if (percentFull != prevPercentFull)
		{
			OnPercentFullChanged(percentFull);
			SendNetworkUpdate();
			prevPercentFull = percentFull;
		}
	}
}


using System;
using UnityEngine;

public class PoweredWaterPurifier : WaterPurifier
{
	public float ConvertInterval = 5f;

	public int PowerDrain = 5;

	public Material PoweredMaterial;

	public Material UnpoweredMaterial;

	public MeshRenderer TargetRenderer;

	public override void ResetState()
	{
		base.ResetState();
	}

	protected override void SpawnStorageEnt(bool load)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		if (load)
		{
			foreach (BaseEntity child in children)
			{
				if (child is LiquidContainer liquidContainer)
				{
					purifiedWaterStorage = liquidContainer;
				}
			}
		}
		if ((Object)(object)purifiedWaterStorage != (Object)null)
		{
			purifiedWaterStorage.SetConnectedTo(this);
			return;
		}
		purifiedWaterStorage = GameManager.server.CreateEntity(storagePrefab.resourcePath, storagePrefabAnchor.position, storagePrefabAnchor.rotation) as LiquidContainer;
		purifiedWaterStorage.SetParent(this, worldPositionStays: true);
		purifiedWaterStorage.Spawn();
		purifiedWaterStorage.SetConnectedTo(this);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (HasLiquidItem())
		{
			if (HasFlag(Flags.Reserved8) && !((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)ConvertWater, ConvertInterval, ConvertInterval, ConvertInterval * 0.1f);
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ConvertWater);
		}
	}

	private void ConvertWater()
	{
		if (HasDirtyWater())
		{
			ConvertWater(ConvertInterval);
			dirtyWaterProcssed = 0f;
		}
	}

	public override int ConsumptionAmount()
	{
		return PowerDrain;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer)
		{
			return;
		}
		if (old.HasFlag(Flags.Reserved8) != next.HasFlag(Flags.Reserved8))
		{
			if (next.HasFlag(Flags.Reserved8))
			{
				if (!((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
				{
					((FacepunchBehaviour)this).InvokeRandomized((Action)ConvertWater, ConvertInterval, ConvertInterval, ConvertInterval * 0.1f);
				}
			}
			else if (((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ConvertWater);
			}
		}
		if ((Object)(object)purifiedWaterStorage != (Object)null)
		{
			purifiedWaterStorage.SetFlag(Flags.Reserved8, HasFlag(Flags.Reserved8));
		}
	}
}


using UnityEngine;

public interface ISignage
{
	Vector2i TextureSize { get; }

	int TextureCount { get; }

	NetworkableId NetworkID { get; }

	FileStorage.Type FileType { get; }

	bool CanUpdateSign(BasePlayer player);

	float Distance(Vector3 position);

	uint[] GetTextureCRCs();

	void SetTextureCRCs(uint[] crcs);
}


using System.Collections.Generic;

public interface IUGCBrowserEntity
{
	uint[] GetContentCRCs { get; }

	UGCType ContentType { get; }

	List<ulong> EditingHistory { get; }

	BaseNetworkable UgcEntity { get; }

	string ContentString { get; }

	void ClearContent();
}


public enum UGCType
{
	ImageJpg,
	ImagePng,
	AudioOgg,
	Sculpt,
	PatternBoomer,
	VendingMachine
}


using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;

public class SignContent : ImageStorageEntity, IUGCBrowserEntity
{
	public uint[] textureIDs = new uint[1];

	private List<ulong> editHistory = new List<ulong>();

	protected override uint CrcToLoad => textureIDs[0];

	protected override FileStorage.Type StorageType => FileStorage.Type.png;

	public UGCType ContentType => UGCType.ImagePng;

	public uint[] GetContentCRCs => textureIDs;

	public FileStorage.Type FileType => StorageType;

	public List<ulong> EditingHistory => editHistory;

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public void CopyInfoFromSign(ISignage s, IUGCBrowserEntity b)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		uint[] textureCRCs = s.GetTextureCRCs();
		textureIDs = new uint[textureCRCs.Length];
		textureCRCs.CopyTo(textureIDs, 0);
		editHistory.Clear();
		foreach (ulong item in b.EditingHistory)
		{
			editHistory.Add(item);
		}
		FileStorage.server.ReassignEntityId(s.NetworkID, net.ID);
	}

	public void CopyInfoToSign(ISignage s, IUGCBrowserEntity b)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		FileStorage.server.ReassignEntityId(net.ID, s.NetworkID);
		s.SetTextureCRCs(textureIDs);
		b.EditingHistory.Clear();
		foreach (ulong item in editHistory)
		{
			b.EditingHistory.Add(item);
		}
		Interface.CallHook("OnSignContentCopied", (object)this, (object)s, (object)b);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.paintableSign == null)
		{
			info.msg.paintableSign = Pool.Get<PaintableSign>();
		}
		info.msg.paintableSign.crcs = Pool.Get<List<uint>>();
		uint[] array = textureIDs;
		foreach (uint item in array)
		{
			info.msg.paintableSign.crcs.Add(item);
		}
	}

	internal override void DoServerDestroy()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		FileStorage.server.RemoveAllByEntity(net.ID);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.paintableSign != null)
		{
			textureIDs = new uint[info.msg.paintableSign.crcs.Count];
			for (int i = 0; i < info.msg.paintableSign.crcs.Count; i++)
			{
				textureIDs[i] = info.msg.paintableSign.crcs[i];
			}
		}
	}

	public void ClearContent()
	{
		Kill();
	}
}


using UnityEngine;

public class VisualFoodModel : MonoBehaviour, IClientComponent
{
	public MeshRenderer[] meshRenderers;

	public Animator animator;

	public bool stopEffectOnEnd;

	public ParticleSystemContainer particleContainer;

	public bool lerpScale;

	public Vector3 startScale;

	public Vector3 endScale;

	public AnimationCurve riseCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve colorCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public SoundDefinition cookingSound;
}


using System;
using UnityEngine;

public class VisualFoodSettings : PrefabAttribute, IClientComponent
{
	[Serializable]
	public class VisualFoodSetting
	{
		public GameObjectRef model;

		public GameObjectRef effectPrefab;

		public ItemDefinition[] items;

		public Transform[] parents;

		public Transform[] effects;

		[HideInInspector]
		public Vector3[] parentPositions;

		[HideInInspector]
		public Quaternion[] parentRotations;

		[HideInInspector]
		public Vector3[] parentScales;

		[HideInInspector]
		public Vector3[] effectParentPositions;

		[HideInInspector]
		public Quaternion[] effectParentRotations;

		[HideInInspector]
		public Vector3[] effectParentScales;

		public void ProcessSpawnPos(Transform rootTransform)
		{
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0168: Unknown result type (might be due to invalid IL or missing references)
			if (parents != null && parents.Length != 0)
			{
				parentPositions = (Vector3[])(object)new Vector3[parents.Length];
				parentRotations = (Quaternion[])(object)new Quaternion[parents.Length];
				parentScales = (Vector3[])(object)new Vector3[parents.Length];
				for (int i = 0; i < parents.Length; i++)
				{
					if ((Object)(object)parents[i] != (Object)null)
					{
						parentPositions[i] = parents[i].position;
						parentRotations[i] = parents[i].rotation;
						parentScales[i] = parents[i].localScale;
					}
				}
			}
			if (effects == null || effects.Length == 0)
			{
				return;
			}
			effectParentPositions = (Vector3[])(object)new Vector3[effects.Length];
			effectParentRotations = (Quaternion[])(object)new Quaternion[effects.Length];
			effectParentScales = (Vector3[])(object)new Vector3[effects.Length];
			for (int j = 0; j < effects.Length; j++)
			{
				if ((Object)(object)effects[j] != (Object)null)
				{
					effectParentPositions[j] = effects[j].position;
					effectParentRotations[j] = effects[j].rotation;
					effectParentScales[j] = effects[j].localScale;
				}
			}
		}
	}

	public Transform strippedParent;

	public VisualFoodSetting[] settings;

	protected override Type GetIndexedType()
	{
		return typeof(VisualFoodSettings);
	}
}


using System;
using UnityEngine;

[Serializable]
public class VisualFoodSetting
{
	public GameObjectRef model;

	public GameObjectRef effectPrefab;

	public ItemDefinition[] items;

	public Transform[] parents;

	public Transform[] effects;

	[HideInInspector]
	public Vector3[] parentPositions;

	[HideInInspector]
	public Quaternion[] parentRotations;

	[HideInInspector]
	public Vector3[] parentScales;

	[HideInInspector]
	public Vector3[] effectParentPositions;

	[HideInInspector]
	public Quaternion[] effectParentRotations;

	[HideInInspector]
	public Vector3[] effectParentScales;

	public void ProcessSpawnPos(Transform rootTransform)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		if (parents != null && parents.Length != 0)
		{
			parentPositions = (Vector3[])(object)new Vector3[parents.Length];
			parentRotations = (Quaternion[])(object)new Quaternion[parents.Length];
			parentScales = (Vector3[])(object)new Vector3[parents.Length];
			for (int i = 0; i < parents.Length; i++)
			{
				if ((Object)(object)parents[i] != (Object)null)
				{
					parentPositions[i] = parents[i].position;
					parentRotations[i] = parents[i].rotation;
					parentScales[i] = parents[i].localScale;
				}
			}
		}
		if (effects == null || effects.Length == 0)
		{
			return;
		}
		effectParentPositions = (Vector3[])(object)new Vector3[effects.Length];
		effectParentRotations = (Quaternion[])(object)new Quaternion[effects.Length];
		effectParentScales = (Vector3[])(object)new Vector3[effects.Length];
		for (int j = 0; j < effects.Length; j++)
		{
			if ((Object)(object)effects[j] != (Object)null)
			{
				effectParentPositions[j] = effects[j].position;
				effectParentRotations[j] = effects[j].rotation;
				effectParentScales[j] = effects[j].localScale;
			}
		}
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class WaterCatcher : LiquidContainer
{
	[Header("Water Catcher")]
	public ItemDefinition itemToCreate;

	public WaterCatcherCollectRate collectionRates;

	public float maxItemToCreate = 10f;

	[Header("Outside Test")]
	public Vector3 rainTestPosition = new Vector3(0f, 1f, 0f);

	public float rainTestSize = 1f;

	public const float collectInterval = 60f;

	public override void ServerInit()
	{
		base.ServerInit();
		AddResource(1);
		((FacepunchBehaviour)this).InvokeRandomized((Action)CollectWater, 60f, 60f, 6f);
	}

	public void CollectWater()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (!IsFull() && Interface.CallHook("OnWaterCollect", (object)this) == null)
		{
			float baseRate = collectionRates.baseRate;
			baseRate += Climate.GetFog(((Component)this).transform.position) * collectionRates.fogRate;
			if (TestIsOutside(((Component)this).transform, rainTestPosition, rainTestSize, 256f))
			{
				baseRate += Climate.GetRain(((Component)this).transform.position) * collectionRates.rainRate;
				baseRate += Climate.GetSnow(((Component)this).transform.position) * collectionRates.snowRate;
			}
			AddResource(Mathf.CeilToInt(maxItemToCreate * baseRate));
		}
	}

	public bool IsFull()
	{
		if (base.inventory.itemList.Count == 0)
		{
			return false;
		}
		if (base.inventory.itemList[0].amount < base.inventory.maxStackSize)
		{
			return false;
		}
		return true;
	}

	public static bool TestIsOutside(Transform t, Vector3 testPositionOffset, float testSize, float testDistance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = t.localToWorldMatrix;
		return !Physics.SphereCast(new Ray(((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(testPositionOffset), Vector3.up), testSize, testDistance, 161546513);
	}

	public void AddResource(int iAmount)
	{
		if (outputs.Length != 0)
		{
			IOEntity iOEntity = CheckPushLiquid(outputs[0].connectedTo.Get(), iAmount, this, IOEntity.backtracking * 2);
			if ((Object)(object)iOEntity != (Object)null && iOEntity is LiquidContainer liquidContainer)
			{
				liquidContainer.inventory.AddItem(itemToCreate, iAmount, 0uL);
				return;
			}
		}
		base.inventory.AddItem(itemToCreate, iAmount, 0uL);
		UpdateOnFlag();
	}

	private IOEntity CheckPushLiquid(IOEntity connected, int amount, IOEntity fromSource, int depth)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		if (depth <= 0 || (Object)(object)itemToCreate == (Object)null)
		{
			return null;
		}
		if ((Object)(object)connected == (Object)null)
		{
			return null;
		}
		Vector3 worldHandlePosition = Vector3.zero;
		IOEntity iOEntity = connected.FindGravitySource(ref worldHandlePosition, IOEntity.backtracking, ignoreSelf: true);
		if ((Object)(object)iOEntity != (Object)null && !connected.AllowLiquidPassthrough(iOEntity, worldHandlePosition))
		{
			return null;
		}
		if ((Object)(object)connected == (Object)(object)this || ConsiderConnectedTo(connected))
		{
			return null;
		}
		if (connected.prefabID == 2150367216u)
		{
			return null;
		}
		IOSlot[] array = connected.outputs;
		foreach (IOSlot iOSlot in array)
		{
			IOEntity iOEntity2 = iOSlot.connectedTo.Get();
			Vector3 sourceWorldPosition = ((Component)connected).transform.TransformPoint(iOSlot.handlePosition);
			if ((Object)(object)iOEntity2 != (Object)null && (Object)(object)iOEntity2 != (Object)(object)fromSource && iOEntity2.AllowLiquidPassthrough(connected, sourceWorldPosition))
			{
				IOEntity iOEntity3 = CheckPushLiquid(iOEntity2, amount, fromSource, depth - 1);
				if ((Object)(object)iOEntity3 != (Object)null)
				{
					return iOEntity3;
				}
			}
		}
		if (connected is LiquidContainer liquidContainer && liquidContainer.inventory.GetAmount(itemToCreate.itemid, onlyUsableAmounts: false) + amount < liquidContainer.maxStackSize)
		{
			return connected;
		}
		return null;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/Water Catcher Rates", fileName = "Water Catcher Collection Rates.asset")]
public class WaterCatcherCollectRate : ScriptableObject
{
	[Tooltip("Base collection rate that happens at all times")]
	public float baseRate = 0.25f;

	[Tooltip("Additional rate during rain")]
	public float rainRate = 1f;

	[Tooltip("Additional rate during snow")]
	public float snowRate = 0.5f;

	[Tooltip("Additional rate during fog. Fog water is also collected indoors")]
	public float fogRate = 2f;
}


using System;
using Oxide.Core;
using UnityEngine;

public class WaterPump : LiquidContainer
{
	public Transform WaterResourceLocation;

	public float PumpInterval = 20f;

	public int AmountPerPump = 30;

	public int PowerConsumption = 5;

	public override bool IsGravitySource => true;

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public void CreateWater()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (!IsFull())
		{
			ItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(WaterResourceLocation.position);
			if ((Object)(object)itemDefinition != (Object)null && Interface.CallHook("OnWaterCollect", (object)this, (object)itemDefinition) == null)
			{
				base.inventory.AddItem(itemDefinition, AmountPerPump, 0uL);
				UpdateOnFlag();
			}
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool flag = next.HasFlag(Flags.Reserved8);
		if (!base.isServer || old.HasFlag(Flags.Reserved8) == flag)
		{
			return;
		}
		if (flag)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)CreateWater))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)CreateWater, PumpInterval, PumpInterval, PumpInterval * 0.1f);
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)CreateWater))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)CreateWater);
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return Mathf.Clamp(GetLiquidCount(), 0, maxOutputFlow);
	}

	public bool IsFull()
	{
		if (base.inventory.itemList.Count == 0)
		{
			return false;
		}
		if (base.inventory.itemList[0].amount < base.inventory.maxStackSize)
		{
			return false;
		}
		return true;
	}
}


using System;
using Oxide.Core;
using Rust;
using UnityEngine;

public class WaterPurifier : LiquidContainer
{
	public static class WaterPurifierFlags
	{
		public const Flags Boiling = Flags.Reserved1;
	}

	public GameObjectRef storagePrefab;

	public Transform storagePrefabAnchor;

	public ItemDefinition freshWater;

	public int waterToProcessPerMinute = 120;

	public int freshWaterRatio = 4;

	public bool stopWhenOutputFull;

	public LiquidContainer purifiedWaterStorage;

	public float dirtyWaterProcssed;

	public float pendingFreshWater;

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SpawnStorageEnt(load: false);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SpawnStorageEnt(load: true);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if ((Object)(object)purifiedWaterStorage != (Object)null)
		{
			purifiedWaterStorage.Kill();
		}
	}

	protected virtual void SpawnStorageEnt(bool load)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		if (load)
		{
			BaseEntity baseEntity = GetParentEntity();
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				foreach (BaseEntity child in baseEntity.children)
				{
					if ((Object)(object)child != (Object)(object)this && child is LiquidContainer liquidContainer)
					{
						purifiedWaterStorage = liquidContainer;
						break;
					}
				}
			}
		}
		if ((Object)(object)purifiedWaterStorage != (Object)null)
		{
			purifiedWaterStorage.SetConnectedTo(this);
			return;
		}
		purifiedWaterStorage = GameManager.server.CreateEntity(storagePrefab.resourcePath, storagePrefabAnchor.localPosition, storagePrefabAnchor.localRotation) as LiquidContainer;
		purifiedWaterStorage.SetParent(GetParentEntity());
		purifiedWaterStorage.Spawn();
		purifiedWaterStorage.SetConnectedTo(this);
	}

	internal override void OnParentRemoved()
	{
		Kill(DestroyMode.Gib);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if (!purifiedWaterStorage.IsDestroyed)
		{
			purifiedWaterStorage.Kill();
		}
	}

	public void ParentTemperatureUpdate(float temp)
	{
	}

	public void CheckCoolDown()
	{
		if (!Object.op_Implicit((Object)(object)GetParentEntity()) || !GetParentEntity().IsOn() || !HasDirtyWater())
		{
			SetFlag(Flags.Reserved1, b: false);
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckCoolDown);
		}
	}

	public bool HasDirtyWater()
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot != null && slot.info.itemType == ItemContainer.ContentsType.Liquid)
		{
			return slot.amount > 0;
		}
		return false;
	}

	public bool HasPurifiedWater()
	{
		if ((Object)(object)purifiedWaterStorage == (Object)null || purifiedWaterStorage.inventory == null)
		{
			return false;
		}
		Item slot = purifiedWaterStorage.inventory.GetSlot(0);
		if (slot != null && slot.info.itemType == ItemContainer.ContentsType.Liquid)
		{
			return slot.amount > 0;
		}
		return false;
	}

	public void Cook(float timeCooked)
	{
		if (!((Object)(object)purifiedWaterStorage == (Object)null))
		{
			bool flag = HasDirtyWater();
			if (!IsBoiling() && flag)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CheckCoolDown, 2f, 2f);
				SetFlag(Flags.Reserved1, b: true);
			}
			if (IsBoiling() && flag)
			{
				ConvertWater(timeCooked);
			}
		}
	}

	protected void ConvertWater(float timeCooked)
	{
		Item slot = purifiedWaterStorage.inventory.GetSlot(0);
		if ((stopWhenOutputFull && slot != null && slot.amount >= slot.MaxStackable()) || Interface.CallHook("OnWaterPurify", (object)this, (object)timeCooked) != null)
		{
			return;
		}
		float num = timeCooked * ((float)waterToProcessPerMinute / 60f);
		if (slot != null)
		{
			float num2 = Mathf.Max(slot.MaxStackable() - slot.amount, 0);
			num = Mathf.Min(num, num2 * (float)freshWaterRatio);
		}
		dirtyWaterProcssed += num;
		if (dirtyWaterProcssed >= 1f)
		{
			Item slot2 = base.inventory.GetSlot(0);
			int num3 = Mathf.Min(Mathf.FloorToInt(dirtyWaterProcssed), slot2.amount);
			num = num3;
			slot2.UseItem(num3);
			dirtyWaterProcssed -= num3;
			SendNetworkUpdate();
		}
		pendingFreshWater += num / (float)freshWaterRatio;
		if (!(pendingFreshWater >= 1f))
		{
			return;
		}
		int num4 = Mathf.FloorToInt(pendingFreshWater);
		pendingFreshWater -= num4;
		Item slot3 = purifiedWaterStorage.inventory.GetSlot(0);
		if (slot3 != null && (Object)(object)slot3.info != (Object)(object)freshWater)
		{
			slot3.RemoveFromContainer();
			slot3.Remove();
		}
		if (slot3 == null)
		{
			Item item = ItemManager.Create(freshWater, num4, 0uL);
			if (!item.MoveToContainer(purifiedWaterStorage.inventory))
			{
				item.Remove();
			}
		}
		else
		{
			slot3.amount += num4;
			slot3.amount = Mathf.Clamp(slot3.amount, 0, purifiedWaterStorage.maxStackSize);
			purifiedWaterStorage.inventory.MarkDirty();
		}
		Interface.CallHook("OnWaterPurified", (object)this, (object)timeCooked);
		purifiedWaterStorage.SendNetworkUpdate();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			SetFlag(Flags.On, b: false);
		}
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (HasDirtyWater() || HasPurifiedWater())
		{
			pickupErrorToFormat = (format: PickupErrors.ItemInventoryMustBeEmpty, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public bool IsBoiling()
	{
		return HasFlag(Flags.Reserved1);
	}
}


public static class WaterPurifierFlags
{
	public const Flags Boiling = Flags.Reserved1;
}


using System;
using ConVar;

public class DebrisEntity : BaseCombatEntity
{
	public float DebrisDespawnOverride;

	public override void ServerInit()
	{
		ResetRemovalTime();
		base.ServerInit();
	}

	public void RemoveCorpse()
	{
		Kill();
	}

	public void ResetRemovalTime(float dur)
	{
		TimeWarning val = TimeWarning.New("ResetRemovalTime", 0);
		try
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)RemoveCorpse))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)RemoveCorpse);
			}
			((FacepunchBehaviour)this).Invoke((Action)RemoveCorpse, dur);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float GetRemovalTime()
	{
		if (!(DebrisDespawnOverride > 0f))
		{
			return Server.debrisdespawn;
		}
		return DebrisDespawnOverride;
	}

	public void ResetRemovalTime()
	{
		ResetRemovalTime(GetRemovalTime());
	}

	public override string Categorize()
	{
		return "debris";
	}
}


using ConVar;
using UnityEngine;

public class BuildingBlockDecay : Decay
{
	private bool isFoundation;

	public override float GetDecayDelay(BaseEntity entity)
	{
		BuildingBlock buildingBlock = entity as BuildingBlock;
		BuildingGrade.Enum grade = (Object.op_Implicit((Object)(object)buildingBlock) ? buildingBlock.grade : BuildingGrade.Enum.Twigs);
		return GetDecayDelay(grade);
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		BuildingBlock buildingBlock = entity as BuildingBlock;
		BuildingGrade.Enum grade = (Object.op_Implicit((Object)(object)buildingBlock) ? buildingBlock.grade : BuildingGrade.Enum.Twigs);
		return GetDecayDuration(grade);
	}

	public override bool ShouldDecay(BaseEntity entity)
	{
		if (entity.net.group != null && entity.net.group.restricted)
		{
			return false;
		}
		if (ConVar.Decay.upkeep)
		{
			return true;
		}
		if (isFoundation)
		{
			return true;
		}
		BuildingBlock buildingBlock = entity as BuildingBlock;
		return !Object.op_Implicit((Object)(object)buildingBlock) || buildingBlock.grade == BuildingGrade.Enum.Twigs;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		isFoundation = name.Contains("foundation");
	}
}


using ConVar;

public class BuildingGradeDecay : Decay
{
	public BuildingGrade.Enum decayGrade;

	public override float GetDecayDelay(BaseEntity entity)
	{
		return GetDecayDelay(decayGrade);
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		return GetDecayDuration(decayGrade);
	}

	public override bool ShouldDecay(BaseEntity entity)
	{
		if (ConVar.Decay.upkeep)
		{
			return true;
		}
		return entity.IsOutside();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public abstract class Decay : PrefabAttribute, IServerComponent
{
	private const float hours = 3600f;

	protected float GetDecayDelay(BuildingGrade.Enum grade)
	{
		if (ConVar.Decay.upkeep)
		{
			if (ConVar.Decay.delay_override > 0f)
			{
				return ConVar.Decay.delay_override;
			}
			return grade switch
			{
				BuildingGrade.Enum.Wood => ConVar.Decay.delay_wood * 3600f, 
				BuildingGrade.Enum.Stone => ConVar.Decay.delay_stone * 3600f, 
				BuildingGrade.Enum.Metal => ConVar.Decay.delay_metal * 3600f, 
				BuildingGrade.Enum.TopTier => ConVar.Decay.delay_toptier * 3600f, 
				_ => ConVar.Decay.delay_twig * 3600f, 
			};
		}
		return grade switch
		{
			BuildingGrade.Enum.Wood => 64800f, 
			BuildingGrade.Enum.Stone => 64800f, 
			BuildingGrade.Enum.Metal => 64800f, 
			BuildingGrade.Enum.TopTier => 86400f, 
			_ => 3600f, 
		};
	}

	protected float GetDecayDuration(BuildingGrade.Enum grade)
	{
		if (ConVar.Decay.upkeep)
		{
			if (ConVar.Decay.duration_override > 0f)
			{
				return ConVar.Decay.duration_override;
			}
			return grade switch
			{
				BuildingGrade.Enum.Wood => ConVar.Decay.duration_wood * 3600f, 
				BuildingGrade.Enum.Stone => ConVar.Decay.duration_stone * 3600f, 
				BuildingGrade.Enum.Metal => ConVar.Decay.duration_metal * 3600f, 
				BuildingGrade.Enum.TopTier => ConVar.Decay.duration_toptier * 3600f, 
				_ => ConVar.Decay.duration_twig * 3600f, 
			};
		}
		return grade switch
		{
			BuildingGrade.Enum.Wood => 86400f, 
			BuildingGrade.Enum.Stone => 172800f, 
			BuildingGrade.Enum.Metal => 259200f, 
			BuildingGrade.Enum.TopTier => 432000f, 
			_ => 3600f, 
		};
	}

	public static void BuildingDecayTouch(BuildingBlock buildingBlock)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.Decay.upkeep)
		{
			return;
		}
		List<DecayEntity> list = Pool.Get<List<DecayEntity>>();
		Vis.Entities(((Component)buildingBlock).transform.position, 40f, list, 2097408, (QueryTriggerInteraction)2);
		for (int i = 0; i < list.Count; i++)
		{
			DecayEntity decayEntity = list[i];
			BuildingBlock buildingBlock2 = decayEntity as BuildingBlock;
			if (!Object.op_Implicit((Object)(object)buildingBlock2) || buildingBlock2.buildingID == buildingBlock.buildingID)
			{
				decayEntity.DecayTouch();
			}
		}
		Pool.FreeUnmanaged<DecayEntity>(ref list);
	}

	public static void EntityLinkDecayTouch(BaseEntity ent)
	{
		if (!ConVar.Decay.upkeep)
		{
			ent.EntityLinkBroadcast(delegate(DecayEntity decayEnt)
			{
				decayEnt.DecayTouch();
			});
		}
	}

	public static void RadialDecayTouch(Vector3 pos, float radius, int mask)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!ConVar.Decay.upkeep)
		{
			List<DecayEntity> list = Pool.Get<List<DecayEntity>>();
			Vis.Entities(pos, radius, list, mask, (QueryTriggerInteraction)2);
			for (int i = 0; i < list.Count; i++)
			{
				list[i].DecayTouch();
			}
			Pool.FreeUnmanaged<DecayEntity>(ref list);
		}
	}

	public virtual bool ShouldDecay(BaseEntity entity)
	{
		return true;
	}

	public abstract float GetDecayDelay(BaseEntity entity);

	public abstract float GetDecayDuration(BaseEntity entity);

	public virtual float GetDecayTickOverride()
	{
		return 0f;
	}

	public virtual float GetHealScale(BaseEntity entity)
	{
		return ConVar.Decay.upkeep_heal_scale;
	}

	public virtual float GetHealDelay(DecayEntity decayEntity)
	{
		return 600f;
	}

	protected override Type GetIndexedType()
	{
		return typeof(Decay);
	}
}


using ConVar;

public class DeployableDecay : Decay
{
	public float decayDelay = 8f;

	public float decayDuration = 8f;

	public bool overrideHealRate;

	public float decayTickOverride;

	public bool decayIndoors;

	public float healRate = 1f;

	public override float GetDecayDelay(BaseEntity entity)
	{
		return decayDelay * 60f * 60f;
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		return decayDuration * 60f * 60f;
	}

	public override float GetHealScale(BaseEntity entity)
	{
		if (!overrideHealRate)
		{
			return base.GetHealScale(entity);
		}
		return healRate;
	}

	public override float GetDecayTickOverride()
	{
		return decayTickOverride;
	}

	public override bool ShouldDecay(BaseEntity entity)
	{
		if (ConVar.Decay.upkeep || decayIndoors)
		{
			return true;
		}
		return entity.IsOutside();
	}
}


using ConVar;
using UnityEngine;

public class SprayDecay : Decay
{
	public override bool ShouldDecay(BaseEntity entity)
	{
		return true;
	}

	public override float GetDecayDelay(BaseEntity entity)
	{
		return 0f;
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		return Mathf.Max(Global.SprayDuration, 1f);
	}
}


using System;

public class Upkeep : PrefabAttribute
{
	public float upkeepMultiplier = 1f;

	protected override Type GetIndexedType()
	{
		return typeof(Upkeep);
	}
}


using System;
using UnityEngine;

public class DestroyOutsideMonument : FacepunchBehaviour
{
	[SerializeField]
	private BaseCombatEntity baseCombatEntity;

	[SerializeField]
	private float checkEvery = 10f;

	private MonumentInfo ourMonument;

	private Vector3 OurPos => ((Component)baseCombatEntity).transform.position;

	protected void OnEnable()
	{
		if ((Object)(object)ourMonument == (Object)null)
		{
			ourMonument = GetOurMonument();
		}
		if ((Object)(object)ourMonument == (Object)null)
		{
			DoOutsideMonument();
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)CheckPosition, checkEvery, checkEvery, checkEvery * 0.1f);
		}
	}

	protected void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CheckPosition);
	}

	private MonumentInfo GetOurMonument()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			if (monument.IsInBounds(OurPos))
			{
				return monument;
			}
		}
		return null;
	}

	private void CheckPosition()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ourMonument == (Object)null)
		{
			DoOutsideMonument();
		}
		if (!ourMonument.IsInBounds(OurPos))
		{
			DoOutsideMonument();
		}
	}

	private void DoOutsideMonument()
	{
		baseCombatEntity.Kill(BaseNetworkable.DestroyMode.Gib);
	}
}


using UnityEngine;

public class DisableSave : MonoBehaviour
{
	private void OnValidate()
	{
		BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
		if ((Object)(object)component != (Object)null)
		{
			Debug.LogWarning((object)"DisableSave is attached to a GameObject but can't find entity");
		}
		else if (component.enableSaving)
		{
			Debug.LogError((object)"BaseEntity.enableSaving must be disabled for the DisableSave component to work");
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class EntityLink : IPooled
{
	public BaseEntity owner;

	public Socket_Base socket;

	public List<EntityLink> connections = new List<EntityLink>(8);

	public int capacity = int.MaxValue;

	public string name => socket.socketName;

	public void Setup(BaseEntity owner, Socket_Base socket)
	{
		this.owner = owner;
		this.socket = socket;
		if (socket.monogamous)
		{
			capacity = 1;
		}
	}

	public void EnterPool()
	{
		owner = null;
		socket = null;
		capacity = int.MaxValue;
	}

	public void LeavePool()
	{
	}

	public bool Contains(EntityLink entity)
	{
		return connections.Contains(entity);
	}

	public void Add(EntityLink entity)
	{
		connections.Add(entity);
	}

	public void Remove(EntityLink entity)
	{
		connections.Remove(entity);
	}

	public void Clear()
	{
		for (int i = 0; i < connections.Count; i++)
		{
			connections[i].Remove(this);
		}
		connections.Clear();
	}

	public bool IsEmpty()
	{
		return connections.Count == 0;
	}

	public bool IsOccupied()
	{
		return connections.Count >= capacity;
	}

	public bool IsMale()
	{
		return socket.male;
	}

	public bool IsFemale()
	{
		return socket.female;
	}

	public bool CanConnect(EntityLink link)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (IsOccupied())
		{
			return false;
		}
		if (link == null)
		{
			return false;
		}
		if (link.IsOccupied())
		{
			return false;
		}
		return socket.CanConnect(((Component)owner).transform.position, ((Component)owner).transform.rotation, link.socket, ((Component)link.owner).transform.position, ((Component)link.owner).transform.rotation);
	}
}


using System.Collections.Generic;
using Facepunch;

public static class EntityLinkEx
{
	public static void FreeLinks(this List<EntityLink> links)
	{
		for (int i = 0; i < links.Count; i++)
		{
			EntityLink entityLink = links[i];
			entityLink.Clear();
			Pool.Free<EntityLink>(ref entityLink);
		}
		links.Clear();
	}

	public static void ClearLinks(this List<EntityLink> links)
	{
		for (int i = 0; i < links.Count; i++)
		{
			links[i].Clear();
		}
	}

	public static void AddLinks(this List<EntityLink> links, BaseEntity entity, Socket_Base[] sockets)
	{
		foreach (Socket_Base socket in sockets)
		{
			EntityLink entityLink = Pool.Get<EntityLink>();
			entityLink.Setup(entity, socket);
			links.Add(entityLink);
		}
	}
}


using UnityEngine;

public struct EntityRef
{
	internal BaseEntity ent_cached;

	internal NetworkableId id_cached;

	public NetworkableId uid
	{
		get
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			if (ent_cached.IsValid())
			{
				id_cached = ent_cached.net.ID;
			}
			return id_cached;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			id_cached = value;
			if (!((NetworkableId)(ref id_cached)).IsValid)
			{
				ent_cached = null;
			}
			else if (!ent_cached.IsValid() || !(ent_cached.net.ID == id_cached))
			{
				ent_cached = null;
			}
		}
	}

	public bool IsSet()
	{
		return ((NetworkableId)(ref id_cached)).IsValid;
	}

	public bool IsValid(bool serverside)
	{
		return Get(serverside).IsValid();
	}

	public void Set(BaseEntity ent)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		ent_cached = ent;
		id_cached = default(NetworkableId);
		if (ent_cached.IsValid())
		{
			id_cached = ent_cached.net.ID;
		}
	}

	public BaseEntity Get(bool serverside)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent_cached == (Object)null && ((NetworkableId)(ref id_cached)).IsValid)
		{
			if (serverside)
			{
				ent_cached = BaseNetworkable.serverEntities.Find(id_cached) as BaseEntity;
			}
			else
			{
				Debug.LogWarning((object)"EntityRef: Looking for clientside entities on pure server!");
			}
		}
		if (!ent_cached.IsValid())
		{
			ent_cached = null;
		}
		return ent_cached;
	}
}


public struct EntityRef<T> where T : BaseEntity
{
	private EntityRef entityRef;

	public bool IsSet => entityRef.IsSet();

	public NetworkableId uid
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return entityRef.uid;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			entityRef.uid = value;
		}
	}

	public EntityRef(NetworkableId uid)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		entityRef = new EntityRef
		{
			uid = uid
		};
	}

	public bool IsValid(bool serverside)
	{
		return Get(serverside).IsValid();
	}

	public void Set(T entity)
	{
		entityRef.Set(entity);
	}

	public T Get(bool serverside)
	{
		BaseEntity baseEntity = entityRef.Get(serverside);
		if (baseEntity == null)
		{
			return null;
		}
		if (!(baseEntity is T result))
		{
			Set(null);
			return null;
		}
		return result;
	}

	public bool TryGet(bool serverside, out T entity)
	{
		entity = Get(serverside);
		return entity != null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

public class FireBall : BaseEntity, ISplashable
{
	private const Flags StationaryFlag = Flags.Reserved1;

	public float lifeTimeMin = 20f;

	public float lifeTimeMax = 40f;

	public ParticleSystem[] movementSystems;

	public ParticleSystem[] restingSystems;

	[NonSerialized]
	public float generation;

	public GameObjectRef spreadSubEntity;

	public float tickRate = 0.5f;

	public float damagePerSecond = 2f;

	public float radius = 0.5f;

	public int waterToExtinguish = 200;

	public bool canMerge;

	public LayerMask AttackLayers = LayerMask.op_Implicit(1220225809);

	public bool ignoreNPC;

	private Vector3 lastPos = Vector3.zero;

	private float deathTime;

	private int wetness;

	private float spawnTime;

	private Vector3 delayedVelocity;

	private bool IsStationary => HasFlag(Flags.Reserved1);

	public void SetDelayedVelocity(Vector3 delayed)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!(delayedVelocity != Vector3.zero))
		{
			delayedVelocity = delayed;
			((FacepunchBehaviour)this).Invoke((Action)ApplyDelayedVelocity, 0.1f);
		}
	}

	private void ApplyDelayedVelocity()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		SetVelocity(delayedVelocity);
		delayedVelocity = Vector3.zero;
	}

	public override void ServerInit()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)Think, Random.Range(0f, 1f), tickRate);
		float num = Random.Range(lifeTimeMin, lifeTimeMax);
		float num2 = num * Random.Range(0.9f, 1.1f);
		((FacepunchBehaviour)this).Invoke((Action)Extinguish, num2);
		((FacepunchBehaviour)this).Invoke((Action)TryToSpread, num * Random.Range(0.3f, 0.5f));
		deathTime = Time.realtimeSinceStartup + num2;
		spawnTime = Time.realtimeSinceStartup;
		((Component)this).transform.rotation = Quaternion.identity;
		SetFlag(Flags.OnFire, b: true);
	}

	public float GetDeathTime()
	{
		return deathTime;
	}

	public void AddLife(float amountToAdd)
	{
		float num = Mathf.Clamp(GetDeathTime() + amountToAdd, 0f, MaxLifeTime());
		((FacepunchBehaviour)this).Invoke((Action)Extinguish, num);
		deathTime = num;
	}

	public float MaxLifeTime()
	{
		return lifeTimeMax * 2.5f;
	}

	public float TimeLeft()
	{
		float num = deathTime - Time.realtimeSinceStartup;
		if (num < 0f)
		{
			num = 0f;
		}
		return num;
	}

	public void TryToSpread()
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.9f - generation * 0.1f;
		if (Random.Range(0f, 1f) < num && spreadSubEntity.isValid)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).transform.position = ((Component)this).transform.position + Vector3.up * 0.25f;
				baseEntity.Spawn();
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);
				baseEntity.creatorEntity = (((Object)(object)creatorEntity == (Object)null) ? baseEntity : creatorEntity);
				Interface.CallHook("OnFireBallSpread", (object)this, (object)baseEntity);
				baseEntity.SetVelocity(modifiedAimConeDirection * Random.Range(5f, 8f));
				((Component)baseEntity).SendMessage("SetGeneration", (object)(generation + 1f));
			}
		}
	}

	public void SetGeneration(int gen)
	{
		generation = gen;
	}

	public void Think()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			Vector3 val = (((Component)this).transform.localPosition - lastPos) / Time.deltaTime;
			UpdateIsStationary(((Vector3)(ref val)).magnitude < 0.05f);
			lastPos = ((Component)this).transform.localPosition;
			if (IsStationary)
			{
				DoRadialDamage();
			}
			if (WaterFactor() > 0.5f)
			{
				Extinguish();
			}
			if (wetness > waterToExtinguish)
			{
				Extinguish();
			}
		}
	}

	public void DoRadialDamage()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		List<BaseCombatEntity> list = Pool.Get<List<BaseCombatEntity>>();
		Vector3 position = ((Component)this).transform.position + new Vector3(0f, radius * 0.75f, 0f);
		Vis.Entities(position, radius, list, LayerMask.op_Implicit(AttackLayers), (QueryTriggerInteraction)1);
		HitInfo hitInfo = new HitInfo();
		hitInfo.DoHitEffects = true;
		hitInfo.DidHit = true;
		hitInfo.HitBone = 0u;
		hitInfo.Initiator = (((Object)(object)creatorEntity == (Object)null) ? ((Component)this).gameObject.ToBaseEntity() : creatorEntity);
		hitInfo.PointStart = ((Component)this).transform.position;
		foreach (BaseCombatEntity item in list)
		{
			if (!((Object)(object)item == (Object)null) && item.isServer && item.IsAlive() && (!ignoreNPC || !item.IsNpc) && item.IsVisible(position))
			{
				if (item is BasePlayer)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", item, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
				}
				hitInfo.PointEnd = ((Component)item).transform.position;
				hitInfo.HitPositionWorld = ((Component)item).transform.position;
				hitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);
				Interface.CallHook("OnFireBallDamage", (object)this, (object)item, (object)hitInfo);
				item.OnAttacked(hitInfo);
			}
		}
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list);
	}

	public bool CanMerge()
	{
		if (canMerge)
		{
			return TimeLeft() < MaxLifeTime() * 0.8f;
		}
		return false;
	}

	public float TimeAlive()
	{
		return Time.realtimeSinceStartup - spawnTime;
	}

	public void UpdateIsStationary(bool shouldBeStationary)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (shouldBeStationary != IsStationary && shouldBeStationary && CanMerge())
		{
			List<Collider> list = Pool.Get<List<Collider>>();
			Vis.Colliders<Collider>(((Component)this).transform.position, 0.5f, list, 512, (QueryTriggerInteraction)2);
			foreach (Collider item in list)
			{
				BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					FireBall fireBall = baseEntity.ToServer<FireBall>();
					if (Object.op_Implicit((Object)(object)fireBall) && fireBall.CanMerge() && (Object)(object)fireBall != (Object)(object)this)
					{
						((FacepunchBehaviour)fireBall).Invoke((Action)Extinguish, 1f);
						fireBall.canMerge = false;
						AddLife(fireBall.TimeLeft() * 0.25f);
					}
				}
			}
			Pool.FreeUnmanaged<Collider>(ref list);
		}
		SetFlag(Flags.Reserved1, shouldBeStationary);
	}

	public void Extinguish()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Extinguish);
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return !base.IsDestroyed;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		wetness += amount;
		return amount;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using UnityEngine;

public class FireSpot : BaseEntity
{
	public GameObject flameEffect;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using Oxide.Core;
using UnityEngine;

public class FlameExplosive : TimedExplosive
{
	public GameObjectRef createOnExplode;

	public bool blockCreateUnderwater;

	public float numToCreate = 10f;

	public float minVelocity = 2f;

	public float maxVelocity = 5f;

	public float spreadAngle = 90f;

	public bool forceUpForExplosion;

	public AnimationCurve velocityCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	public AnimationCurve spreadCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	public override void Explode()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		FlameExplode(forceUpForExplosion ? Vector3.up : (-((Component)this).transform.forward));
	}

	public void FlameExplode(Vector3 surfaceNormal)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		if (blockCreateUnderwater && WaterLevel.Test(position, waves: true, volumes: false))
		{
			base.Explode();
			return;
		}
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.enabled = false;
		}
		for (int i = 0; (float)i < numToCreate; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, position);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				float num = (float)i / numToCreate;
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle * spreadCurve.Evaluate(num), surfaceNormal);
				float num2 = Random.Range(0f, 360f);
				Quaternion val = Quaternion.Euler(0f, num2, 0f);
				((Component)baseEntity).transform.SetPositionAndRotation(position, val);
				baseEntity.creatorEntity = (((Object)(object)creatorEntity == (Object)null) ? baseEntity : creatorEntity);
				baseEntity.Spawn();
				Interface.CallHook("OnFlameExplosion", (object)this, (object)component);
				Vector3 val2 = ((Vector3)(ref modifiedAimConeDirection)).normalized * Random.Range(minVelocity, maxVelocity) * velocityCurve.Evaluate(num * Random.Range(1f, 1.1f));
				FireBall component2 = ((Component)baseEntity).GetComponent<FireBall>();
				if ((Object)(object)component2 != (Object)null)
				{
					component2.SetDelayedVelocity(val2);
				}
				else
				{
					baseEntity.SetVelocity(val2);
				}
			}
		}
		base.Explode();
	}

	public override void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		hitNormal = ((RaycastHit)(ref info)).normal;
		FlameExplode(((RaycastHit)(ref info)).normal);
	}
}


public class GrowableGene
{
	public GrowableGenetics.GeneType Type { get; private set; }

	public GrowableGenetics.GeneType PreviousType { get; private set; }

	public void Set(GrowableGenetics.GeneType geneType, bool firstSet = false)
	{
		if (firstSet)
		{
			SetPrevious(geneType);
		}
		else
		{
			SetPrevious(Type);
		}
		Type = geneType;
	}

	public void SetPrevious(GrowableGenetics.GeneType type)
	{
		PreviousType = type;
	}

	public string GetDisplayCharacter()
	{
		return GetDisplayCharacter(Type);
	}

	public static string GetDisplayCharacter(GrowableGenetics.GeneType type)
	{
		return type switch
		{
			GrowableGenetics.GeneType.Empty => "X", 
			GrowableGenetics.GeneType.GrowthSpeed => "G", 
			GrowableGenetics.GeneType.Hardiness => "H", 
			GrowableGenetics.GeneType.WaterRequirement => "W", 
			GrowableGenetics.GeneType.Yield => "Y", 
			_ => "U", 
		};
	}

	public string GetColourCodedDisplayCharacter()
	{
		return GetColourCodedDisplayCharacter(Type);
	}

	public static string GetColourCodedDisplayCharacter(GrowableGenetics.GeneType type)
	{
		return "<color=" + (IsPositive(type) ? "#60891B>" : "#AA4734>") + GetDisplayCharacter(type) + "</color>";
	}

	public static bool IsPositive(GrowableGenetics.GeneType type)
	{
		return type switch
		{
			GrowableGenetics.GeneType.Empty => false, 
			GrowableGenetics.GeneType.GrowthSpeed => true, 
			GrowableGenetics.GeneType.Hardiness => true, 
			GrowableGenetics.GeneType.WaterRequirement => false, 
			GrowableGenetics.GeneType.Yield => true, 
			_ => false, 
		};
	}

	public bool IsPositive()
	{
		return IsPositive(Type);
	}
}


using System.Text;
using ProtoBuf;
using UnityEngine;

public static class GrowableGeneEncoding
{
	public static void EncodeGenesToItem(GrowableEntity sourceGrowable, Item targetItem)
	{
		if (!((Object)(object)sourceGrowable == (Object)null) && sourceGrowable.Genes != null)
		{
			EncodeGenesToItem(EncodeGenesToInt(sourceGrowable.Genes), targetItem);
		}
	}

	public static void EncodeGenesToItem(int genes, Item targetItem)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		if (targetItem != null)
		{
			targetItem.instanceData = new InstanceData
			{
				ShouldPool = false,
				dataInt = genes
			};
		}
	}

	public static int EncodeGenesToInt(GrowableGenes genes)
	{
		int num = 0;
		for (int i = 0; i < genes.Genes.Length; i++)
		{
			num = Set(num, i, (int)genes.Genes[i].Type);
		}
		return num;
	}

	public static int EncodePreviousGenesToInt(GrowableGenes genes)
	{
		int num = 0;
		for (int i = 0; i < genes.Genes.Length; i++)
		{
			num = Set(num, i, (int)genes.Genes[i].PreviousType);
		}
		return num;
	}

	public static void DecodeIntToGenes(int data, GrowableGenes genes)
	{
		for (int i = 0; i < 6; i++)
		{
			genes.Genes[i].Set((GrowableGenetics.GeneType)Get(data, i));
		}
	}

	public static void DecodeIntToPreviousGenes(int data, GrowableGenes genes)
	{
		for (int i = 0; i < 6; i++)
		{
			genes.Genes[i].SetPrevious((GrowableGenetics.GeneType)Get(data, i));
		}
	}

	public static string DecodeIntToGeneString(int data)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < 6; i++)
		{
			stringBuilder.Append(GrowableGene.GetColourCodedDisplayCharacter((GrowableGenetics.GeneType)Get(data, i)));
		}
		return stringBuilder.ToString();
	}

	private static int Set(int storage, int slot, int value)
	{
		int num = slot * 5;
		int num2 = 31 << num;
		return (storage & ~num2) | (value << num);
	}

	private static int Get(int storage, int slot)
	{
		int num = slot * 5;
		int num2 = 31 << num;
		return (storage & num2) >> num;
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Growable Gene Properties")]
public class GrowableGeneProperties : ScriptableObject
{
	[Serializable]
	public struct GeneWeight
	{
		public float BaseWeight;

		public float[] SlotWeights;

		public float CrossBreedingWeight;
	}

	[ArrayIndexIsEnum(enumType = typeof(GrowableGenetics.GeneType))]
	public GeneWeight[] Weights = new GeneWeight[5];
}


using System;

[Serializable]
public struct GeneWeight
{
	public float BaseWeight;

	public float[] SlotWeights;

	public float CrossBreedingWeight;
}


using System;
using System.Text;
using Facepunch;
using UnityEngine;

public class GrowableGenes
{
	public GrowableGene[] Genes;

	private static GrowableGenetics.GeneWeighting[] baseWeights = new GrowableGenetics.GeneWeighting[6];

	private static GrowableGenetics.GeneWeighting[] slotWeights = new GrowableGenetics.GeneWeighting[6];

	public GrowableGenes()
	{
		Clear();
	}

	private void Clear()
	{
		Genes = new GrowableGene[6];
		for (int i = 0; i < 6; i++)
		{
			Genes[i] = new GrowableGene();
		}
	}

	public void GenerateFavourableGenes(GrowableEntity growable, float geneChance = -1f)
	{
		if (!((Object)(object)growable == (Object)null) && !((Object)(object)growable.Properties.Genes == (Object)null))
		{
			CalculateBaseWeights(growable.Properties.Genes);
			for (int i = 0; i < 6; i++)
			{
				CalculateSlotWeights(growable.Properties.Genes, i);
				Genes[i].Set(PickFavourableGeneType(geneChance), firstSet: true);
			}
		}
	}

	public void GenerateRandom(GrowableEntity growable)
	{
		if (!((Object)(object)growable == (Object)null) && !((Object)(object)growable.Properties.Genes == (Object)null))
		{
			CalculateBaseWeights(growable.Properties.Genes);
			for (int i = 0; i < 6; i++)
			{
				CalculateSlotWeights(growable.Properties.Genes, i);
				Genes[i].Set(PickWeightedGeneType(), firstSet: true);
			}
		}
	}

	private void CalculateBaseWeights(GrowableGeneProperties properties)
	{
		int num = 0;
		GrowableGeneProperties.GeneWeight[] weights = properties.Weights;
		for (int i = 0; i < weights.Length; i++)
		{
			GrowableGeneProperties.GeneWeight geneWeight = weights[i];
			baseWeights[num].GeneType = (slotWeights[num].GeneType = (GrowableGenetics.GeneType)num);
			baseWeights[num].Weighting = geneWeight.BaseWeight;
			num++;
		}
	}

	private void CalculateSlotWeights(GrowableGeneProperties properties, int slot)
	{
		int num = 0;
		GrowableGeneProperties.GeneWeight[] weights = properties.Weights;
		for (int i = 0; i < weights.Length; i++)
		{
			GrowableGeneProperties.GeneWeight geneWeight = weights[i];
			slotWeights[num].Weighting = baseWeights[num].Weighting + geneWeight.SlotWeights[slot];
			num++;
		}
	}

	private GrowableGenetics.GeneType PickWeightedGeneType()
	{
		float num = 0f;
		GrowableGenetics.GeneWeighting[] array = slotWeights;
		for (int i = 0; i < array.Length; i++)
		{
			GrowableGenetics.GeneWeighting geneWeighting = array[i];
			num += geneWeighting.Weighting;
		}
		GrowableGenetics.GeneType result = GrowableGenetics.GeneType.Empty;
		float num2 = Random.Range(0f, num);
		float num3 = 0f;
		array = slotWeights;
		for (int i = 0; i < array.Length; i++)
		{
			GrowableGenetics.GeneWeighting geneWeighting2 = array[i];
			num3 += geneWeighting2.Weighting;
			if (num2 < num3)
			{
				result = geneWeighting2.GeneType;
				break;
			}
		}
		return result;
	}

	private GrowableGenetics.GeneType PickFavourableGeneType(float favourableGeneChance = -1f)
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		if (favourableGeneChance < 0f)
		{
			favourableGeneChance = PlanterBoxStatic.FavourableGeneChance;
		}
		BufferList<GrowableGenetics.GeneWeighting> val = Pool.Get<BufferList<GrowableGenetics.GeneWeighting>>();
		BufferList<GrowableGenetics.GeneWeighting> val2 = Pool.Get<BufferList<GrowableGenetics.GeneWeighting>>();
		float num = 0f;
		float num2 = 0f;
		GrowableGenetics.GeneWeighting[] array = slotWeights;
		for (int i = 0; i < array.Length; i++)
		{
			GrowableGenetics.GeneWeighting geneWeighting = array[i];
			if (GrowableGene.IsPositive(geneWeighting.GeneType))
			{
				val.Add(geneWeighting);
				num += geneWeighting.Weighting;
			}
			else
			{
				val2.Add(geneWeighting);
				num2 += geneWeighting.Weighting;
			}
		}
		float num3 = Mathx.RemapValClamped(Mathf.Clamp(favourableGeneChance, 0f, 1f), 0f, 1f, 1f, 0f);
		float num4 = num + num2 * num3;
		float num5 = Random.Range(0f, num4);
		float num6 = 0f;
		Enumerator<GrowableGenetics.GeneWeighting> enumerator = val.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				GrowableGenetics.GeneWeighting current = enumerator.Current;
				num6 += current.Weighting;
				if (num5 < num6)
				{
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val);
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val2);
					return current.GeneType;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = val2.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				GrowableGenetics.GeneWeighting current2 = enumerator.Current;
				num6 += current2.Weighting * num3;
				if (num5 < num6)
				{
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val);
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val2);
					return current2.GeneType;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val);
		Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val2);
		return GrowableGenetics.GeneType.Empty;
	}

	public int GetGeneTypeCount(GrowableGenetics.GeneType geneType)
	{
		int num = 0;
		GrowableGene[] genes = Genes;
		for (int i = 0; i < genes.Length; i++)
		{
			if (genes[i].Type == geneType)
			{
				num++;
			}
		}
		return num;
	}

	public int GetPositiveGeneCount()
	{
		int num = 0;
		GrowableGene[] genes = Genes;
		for (int i = 0; i < genes.Length; i++)
		{
			if (genes[i].IsPositive())
			{
				num++;
			}
		}
		return num;
	}

	public int GetNegativeGeneCount()
	{
		int num = 0;
		GrowableGene[] genes = Genes;
		for (int i = 0; i < genes.Length; i++)
		{
			if (!genes[i].IsPositive())
			{
				num++;
			}
		}
		return num;
	}

	public void Save(BaseNetworkable.SaveInfo info)
	{
		info.msg.growableEntity.genes = GrowableGeneEncoding.EncodeGenesToInt(this);
		info.msg.growableEntity.previousGenes = GrowableGeneEncoding.EncodePreviousGenesToInt(this);
	}

	public void Load(BaseNetworkable.LoadInfo info)
	{
		if (info.msg.growableEntity != null)
		{
			GrowableGeneEncoding.DecodeIntToGenes(info.msg.growableEntity.genes, this);
			GrowableGeneEncoding.DecodeIntToPreviousGenes(info.msg.growableEntity.previousGenes, this);
		}
	}

	public void DebugPrint()
	{
		Debug.Log((object)GetDisplayString(previousGenes: false));
	}

	private string GetDisplayString(bool previousGenes)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < 6; i++)
		{
			stringBuilder.Append(GrowableGene.GetDisplayCharacter(previousGenes ? Genes[i].PreviousType : Genes[i].Type));
		}
		return stringBuilder.ToString();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class GrowableGenetics
{
	public enum GeneType
	{
		Empty,
		WaterRequirement,
		GrowthSpeed,
		Yield,
		Hardiness
	}

	public struct GeneWeighting
	{
		public float Weighting;

		public GeneType GeneType;
	}

	public const int GeneSlotCount = 6;

	public const float CrossBreedingRadius = 1.5f;

	private static GeneWeighting[] neighbourWeights = new GeneWeighting[Enum.GetValues(typeof(GeneType)).Length];

	private static GeneWeighting dominant = default(GeneWeighting);

	public static void CrossBreed(GrowableEntity growable)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
		Vis.Entities(((Component)growable).transform.position, 1.5f, list, 524288, (QueryTriggerInteraction)2);
		bool flag = false;
		for (int i = 0; i < 6; i++)
		{
			GrowableGene growableGene = growable.Genes.Genes[i];
			GeneWeighting dominantGeneWeighting = GetDominantGeneWeighting(growable, list, i);
			if (dominantGeneWeighting.Weighting > growable.Properties.Genes.Weights[(int)growableGene.Type].CrossBreedingWeight)
			{
				flag = true;
				growableGene.Set(dominantGeneWeighting.GeneType);
			}
		}
		if (flag)
		{
			growable.SendNetworkUpdate();
		}
	}

	private static GeneWeighting GetDominantGeneWeighting(GrowableEntity crossBreedingGrowable, List<GrowableEntity> neighbours, int slot)
	{
		PlanterBox planter = crossBreedingGrowable.GetPlanter();
		if ((Object)(object)planter == (Object)null)
		{
			dominant.Weighting = -1f;
			return dominant;
		}
		for (int i = 0; i < neighbourWeights.Length; i++)
		{
			neighbourWeights[i].Weighting = 0f;
			neighbourWeights[i].GeneType = (GeneType)i;
		}
		dominant.Weighting = 0f;
		foreach (GrowableEntity neighbour in neighbours)
		{
			if (!neighbour.isServer)
			{
				continue;
			}
			PlanterBox planter2 = neighbour.GetPlanter();
			if (!((Object)(object)planter2 == (Object)null) && !((Object)(object)planter2 != (Object)(object)planter) && !((Object)(object)neighbour == (Object)(object)crossBreedingGrowable) && neighbour.prefabID == crossBreedingGrowable.prefabID && !neighbour.IsDead())
			{
				GeneType type = neighbour.Genes.Genes[slot].Type;
				float crossBreedingWeight = neighbour.Properties.Genes.Weights[(int)type].CrossBreedingWeight;
				float num = (neighbourWeights[(int)type].Weighting += crossBreedingWeight);
				if (num > dominant.Weighting)
				{
					dominant.Weighting = num;
					dominant.GeneType = type;
				}
			}
		}
		return dominant;
	}
}


public enum GeneType
{
	Empty,
	WaterRequirement,
	GrowthSpeed,
	Yield,
	Hardiness
}


public struct GeneWeighting
{
	public float Weighting;

	public GeneType GeneType;
}


using UnityEngine;

public interface IItemContainerEntity : IIdealSlotEntity, ILootableEntity, IInventoryProvider
{
	ItemContainer inventory { get; }

	Transform Transform { get; }

	bool DropsLoot { get; }

	float DestroyLootPercent { get; }

	bool DropFloats { get; }

	void DropItems(BaseEntity initiator = null);

	bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true);

	bool ShouldDropItemsIndividually();

	void DropBonusItems(BaseEntity initiator, ItemContainer container);

	Vector3 GetDropPosition();
}


using System.Collections.Generic;

public interface IInventoryProvider
{
	void GetAllInventories(List<ItemContainer> list);
}


public interface IIdealSlotEntity
{
	int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);

	ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifiers);
}


public interface ILootableEntity
{
	ulong LastLootedBy { get; set; }

	BasePlayer LastLootedByPlayer { get; set; }
}


using Rust.Instruments;
using UnityEngine;

public class InstrumentDebugInput : MonoBehaviour
{
	public InstrumentKeyController KeyController;

	public InstrumentKeyController.KeySet Note = new InstrumentKeyController.KeySet
	{
		Note = Notes.A,
		NoteType = InstrumentKeyController.NoteType.Regular,
		OctaveShift = 3
	};

	public float Frequency = 0.75f;

	public float StopAfter = 0.1f;

	public SoundDefinition OverrideDefinition;
}


using UnityEngine;

public class InstrumentIKController : MonoBehaviour
{
	public Vector3 HitRotationVector = Vector3.forward;

	public Transform[] LeftHandIkTargets = (Transform[])(object)new Transform[0];

	public Transform[] LeftHandIKTargetHitRotations = (Transform[])(object)new Transform[0];

	public Transform[] RightHandIkTargets = (Transform[])(object)new Transform[0];

	public Transform[] RightHandIKTargetHitRotations = (Transform[])(object)new Transform[0];

	public Transform[] RightFootIkTargets = (Transform[])(object)new Transform[0];

	public AnimationCurve HandHeightCurve = AnimationCurve.Constant(0f, 1f, 0f);

	public float HandHeightMultiplier = 1f;

	public float HandMoveLerpSpeed = 50f;

	public bool DebugHitRotation;

	public AnimationCurve HandHitCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float NoteHitTime = 0.5f;

	[Header("Look IK")]
	public float BodyLookWeight;

	public float HeadLookWeight;

	public float LookWeightLimit;

	public bool HoldHandsAtPlay;
}


using UnityEngine;

public class InstrumentIKTargetAttribute : PropertyAttribute
{
}


using System;
using System.Runtime.InteropServices;
using Rust.Instruments;
using UnityEngine;

public class InstrumentKeyController : MonoBehaviour
{
	public enum IKType
	{
		LeftHand,
		RightHand,
		RightFoot
	}

	public enum NoteType
	{
		Regular,
		Sharp
	}

	public enum InstrumentType
	{
		Note,
		Hold
	}

	public enum AnimationSlot
	{
		None,
		One,
		Two,
		Three,
		Four,
		Five,
		Six,
		Seven
	}

	[Serializable]
	public struct KeySet
	{
		public Notes Note;

		public NoteType NoteType;

		public int OctaveShift;

		public override string ToString()
		{
			return string.Format("{0}{1}{2}", Note, (NoteType == NoteType.Sharp) ? "#" : string.Empty, OctaveShift);
		}
	}

	public struct NoteOverride
	{
		public bool Override;

		public KeySet Note;
	}

	[Serializable]
	public struct IKNoteTarget
	{
		public IKType TargetType;

		public int IkIndex;
	}

	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct NoteBinding
	{
	}

	public const float DEFAULT_NOTE_VELOCITY = 1f;

	public NoteBindingCollection Bindings;

	public NoteBinding[] NoteBindings = new NoteBinding[0];

	public Transform[] NoteSoundPositions;

	public InstrumentIKController IKController;

	public Transform LeftHandProp;

	public Transform RightHandProp;

	public Animator InstrumentAnimator;

	public BaseEntity RPCHandler;

	public uint overrideAchievementId;

	private const string ALL_NOTES_STATNAME = "played_notes";

	public bool PlayedNoteThisFrame { get; private set; }

	public void ProcessServerPlayedNote(BasePlayer forPlayer)
	{
		if (!((Object)(object)forPlayer == (Object)null))
		{
			forPlayer.stats.Add(Bindings.NotePlayedStatName, 1, (Stats)5);
			forPlayer.stats.Add("played_notes", 1, (Stats)5);
		}
	}
}


public enum IKType
{
	LeftHand,
	RightHand,
	RightFoot
}


public enum NoteType
{
	Regular,
	Sharp
}


public enum InstrumentType
{
	Note,
	Hold
}


public enum AnimationSlot
{
	None,
	One,
	Two,
	Three,
	Four,
	Five,
	Six,
	Seven
}


using System;
using Rust.Instruments;

[Serializable]
public struct KeySet
{
	public Notes Note;

	public NoteType NoteType;

	public int OctaveShift;

	public override string ToString()
	{
		return string.Format("{0}{1}{2}", Note, (NoteType == NoteType.Sharp) ? "#" : string.Empty, OctaveShift);
	}
}


public struct NoteOverride
{
	public bool Override;

	public KeySet Note;
}


using System;

[Serializable]
public struct IKNoteTarget
{
	public IKType TargetType;

	public int IkIndex;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct NoteBinding
{
}


using System;
using Rust.Instruments;
using UnityEngine;

[CreateAssetMenu]
public class NoteBindingCollection : ScriptableObject
{
	[Serializable]
	public struct NoteData
	{
		public SoundDefinition NoteSound;

		public SoundDefinition NoteStartSound;

		public Notes Note;

		public InstrumentKeyController.NoteType Type;

		public int MidiNoteNumber;

		public int NoteOctave;

		[InstrumentIKTarget]
		public InstrumentKeyController.IKNoteTarget NoteIKTarget;

		public InstrumentKeyController.AnimationSlot AnimationSlot;

		public int NoteSoundPositionTarget;

		public int[] AdditionalMidiTargets;

		public float PitchOffset;

		public bool MatchMidiCode(int code)
		{
			if (MidiNoteNumber == code)
			{
				return true;
			}
			if (AdditionalMidiTargets != null)
			{
				int[] additionalMidiTargets = AdditionalMidiTargets;
				for (int i = 0; i < additionalMidiTargets.Length; i++)
				{
					if (additionalMidiTargets[i] == code)
					{
						return true;
					}
				}
			}
			return false;
		}

		public string ToNoteString()
		{
			return string.Format("{0}{1}{2}", Note, (Type == InstrumentKeyController.NoteType.Sharp) ? "#" : string.Empty, NoteOctave);
		}
	}

	public NoteData[] BaseBindings;

	public float MinimumNoteTime;

	public float MaximumNoteLength;

	public bool AllowAutoplay = true;

	public float AutoplayLoopDelay = 0.25f;

	public string NotePlayedStatName;

	public string KeyMidiMapShortname = "";

	public bool AllowSustain;

	public bool AllowFullKeyboardInput = true;

	public string InstrumentShortName = "";

	public InstrumentKeyController.InstrumentType NotePlayType;

	public int MaxConcurrentNotes = 3;

	public bool LoopSounds;

	public float SoundFadeInTime;

	public float minimumSoundFadeOutTime = 0.1f;

	public InstrumentKeyController.KeySet PrimaryClickNote;

	public InstrumentKeyController.KeySet SecondaryClickNote = new InstrumentKeyController.KeySet
	{
		Note = Notes.B
	};

	public bool RunInstrumentAnimationController;

	public bool PlayRepeatAnimations = true;

	public float AnimationDeadTime = 1f;

	public float AnimationResetDelay;

	public float RecentlyPlayedThreshold = 1f;

	[Range(0f, 1f)]
	public float CrossfadeNormalizedAnimationTarget;

	public float AnimationCrossfadeDuration = 0.15f;

	public float CrossfadePlayerSpeedMulti = 1f;

	public int DefaultOctave;

	public int ShiftedOctave = 1;

	public bool UseClosestMidiNote = true;

	private const float MidiNoteUpOctaveShift = 2f;

	private const float MidiNoteDownOctaveShift = 0.1f;

	public bool FindNoteData(Notes note, int octave, InstrumentKeyController.NoteType type, out NoteData data, out int noteIndex)
	{
		for (int i = 0; i < BaseBindings.Length; i++)
		{
			NoteData noteData = BaseBindings[i];
			if (noteData.Note == note && noteData.Type == type && noteData.NoteOctave == octave)
			{
				data = noteData;
				noteIndex = i;
				return true;
			}
		}
		data = default(NoteData);
		noteIndex = -1;
		return false;
	}

	public bool FindNoteDataIndex(Notes note, int octave, InstrumentKeyController.NoteType type, out int noteIndex)
	{
		for (int i = 0; i < BaseBindings.Length; i++)
		{
			NoteData noteData = BaseBindings[i];
			if (noteData.Note == note && noteData.Type == type && noteData.NoteOctave == octave)
			{
				noteIndex = i;
				return true;
			}
		}
		noteIndex = -1;
		return false;
	}

	public NoteData CreateMidiBinding(NoteData basedOn, int octave, int midiCode)
	{
		NoteData result = basedOn;
		result.NoteOctave = octave;
		result.MidiNoteNumber = midiCode;
		int num = octave - basedOn.NoteOctave;
		if (octave > basedOn.NoteOctave)
		{
			result.PitchOffset = (float)num * 2f;
		}
		else
		{
			result.PitchOffset = 1f - Mathf.Abs((float)num * 0.1f);
		}
		return result;
	}
}


using System;
using Rust.Instruments;

[Serializable]
public struct NoteData
{
	public SoundDefinition NoteSound;

	public SoundDefinition NoteStartSound;

	public Notes Note;

	public InstrumentKeyController.NoteType Type;

	public int MidiNoteNumber;

	public int NoteOctave;

	[InstrumentIKTarget]
	public InstrumentKeyController.IKNoteTarget NoteIKTarget;

	public InstrumentKeyController.AnimationSlot AnimationSlot;

	public int NoteSoundPositionTarget;

	public int[] AdditionalMidiTargets;

	public float PitchOffset;

	public bool MatchMidiCode(int code)
	{
		if (MidiNoteNumber == code)
		{
			return true;
		}
		if (AdditionalMidiTargets != null)
		{
			int[] additionalMidiTargets = AdditionalMidiTargets;
			for (int i = 0; i < additionalMidiTargets.Length; i++)
			{
				if (additionalMidiTargets[i] == code)
				{
					return true;
				}
			}
		}
		return false;
	}

	public string ToNoteString()
	{
		return string.Format("{0}{1}{2}", Note, (Type == InstrumentKeyController.NoteType.Sharp) ? "#" : string.Empty, NoteOctave);
	}
}


using System;
using UnityEngine;

[Serializable]
public class LODGroupRenderers
{
	public LODGroup lodGroup;

	public Renderer[] renderers;

	public void SetRenderersEnabled(bool enabled)
	{
		Renderer[] array = renderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = enabled;
		}
	}
}


public static class BaseMetabolism
{
	public const float targetHeartRate = 0.05f;
}


using System;
using ConVar;
using Rust;
using UnityEngine;

public abstract class BaseMetabolism<T> : EntityComponent<T> where T : BaseCombatEntity
{
	protected T owner;

	public MetabolismAttribute calories = new MetabolismAttribute();

	public MetabolismAttribute hydration = new MetabolismAttribute();

	public MetabolismAttribute heartrate = new MetabolismAttribute();

	protected float timeSinceLastMetabolism;

	public virtual void Reset()
	{
		calories.Reset();
		hydration.Reset();
		heartrate.Reset();
	}

	protected virtual void OnDisable()
	{
		if (!Application.isQuitting)
		{
			owner = null;
		}
	}

	public virtual void ServerInit(T owner)
	{
		Reset();
		this.owner = owner;
	}

	public virtual void ServerUpdate(BaseCombatEntity ownerEntity, float delta)
	{
		timeSinceLastMetabolism += delta;
		if (!(timeSinceLastMetabolism <= ConVar.Server.metabolismtick))
		{
			if (Object.op_Implicit((Object)(object)owner) && !owner.IsDead())
			{
				RunMetabolism(ownerEntity, timeSinceLastMetabolism);
				DoMetabolismDamage(ownerEntity, timeSinceLastMetabolism);
			}
			timeSinceLastMetabolism = 0f;
		}
	}

	protected virtual void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta)
	{
		if (calories.value <= 20f)
		{
			TimeWarning val = TimeWarning.New("Calories Hurt", 0);
			try
			{
				ownerEntity.Hurt(Mathf.InverseLerp(20f, 0f, calories.value) * delta * (1f / 12f), DamageType.Hunger);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (hydration.value <= 20f)
		{
			TimeWarning val = TimeWarning.New("Hyration Hurt", 0);
			try
			{
				ownerEntity.Hurt(Mathf.InverseLerp(20f, 0f, hydration.value) * delta * (2f / 15f), DamageType.Thirst);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	protected virtual void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
	{
		if (calories.value > 200f)
		{
			ownerEntity.Heal(Mathf.InverseLerp(200f, 1000f, calories.value) * delta * (1f / 60f));
		}
		if (hydration.value > 200f)
		{
			ownerEntity.Heal(Mathf.InverseLerp(200f, 1000f, hydration.value) * delta * (1f / 60f));
		}
		hydration.MoveTowards(0f, delta * (1f / 120f));
		calories.MoveTowards(0f, delta * (1f / 60f));
		heartrate.MoveTowards(0.05f, delta * (1f / 60f));
	}

	public virtual void ApplyChange(MetabolismAttribute.Type type, float amount, float time)
	{
		FindAttribute(type)?.Add(amount);
	}

	public bool ShouldDie()
	{
		if (Object.op_Implicit((Object)(object)owner))
		{
			return owner.Health() <= 0f;
		}
		return false;
	}

	public virtual MetabolismAttribute FindAttribute(MetabolismAttribute.Type type)
	{
		return type switch
		{
			MetabolismAttribute.Type.Calories => calories, 
			MetabolismAttribute.Type.Hydration => hydration, 
			MetabolismAttribute.Type.Heartrate => heartrate, 
			_ => null, 
		};
	}
}


using System;
using UnityEngine;

[Serializable]
public class MetabolismAttribute
{
	public enum Type
	{
		Calories,
		Hydration,
		Heartrate,
		Poison,
		Radiation,
		Bleeding,
		Health,
		HealthOverTime
	}

	public float startMin;

	public float startMax;

	public float min;

	public float max;

	public float value;

	public float lastValue;

	internal float lastGreatFraction;

	private const float greatInterval = 0.1f;

	public float greatFraction => Mathf.Floor(Fraction() / 0.1f) / 10f;

	public void Reset()
	{
		value = Mathf.Clamp(Random.Range(startMin, startMax), min, max);
	}

	public float Fraction()
	{
		return Mathf.InverseLerp(min, max, value);
	}

	public float InverseFraction()
	{
		return 1f - Fraction();
	}

	public void Add(float val)
	{
		value = Mathf.Clamp(value + val, min, max);
	}

	public void Subtract(float val)
	{
		value = Mathf.Clamp(value - val, min, max);
	}

	public void Set(float val)
	{
		value = Mathf.Clamp(val, min, max);
	}

	public void Increase(float fTarget)
	{
		fTarget = Mathf.Clamp(fTarget, min, max);
		if (!(fTarget <= value))
		{
			value = fTarget;
		}
	}

	public void MoveTowards(float fTarget, float fRate)
	{
		if (fRate != 0f)
		{
			value = Mathf.Clamp(Mathf.MoveTowards(value, fTarget, fRate), min, max);
		}
	}

	public bool HasChanged()
	{
		bool result = lastValue != value;
		lastValue = value;
		return result;
	}

	public bool HasGreatlyChanged()
	{
		float num = greatFraction;
		bool result = lastGreatFraction != num;
		lastGreatFraction = num;
		return result;
	}

	public void SetValue(float newValue)
	{
		value = newValue;
	}
}


public enum Type
{
	Calories,
	Hydration,
	Heartrate,
	Poison,
	Radiation,
	Bleeding,
	Health,
	HealthOverTime
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BaseResourceExtractor : BaseCombatEntity
{
	public bool canExtractLiquid;

	public bool canExtractSolid = true;

	public override void ServerInit()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (base.isClient)
		{
			return;
		}
		List<SurveyCrater> list = Pool.Get<List<SurveyCrater>>();
		Vis.Entities(((Component)this).transform.position, 3f, list, 1, (QueryTriggerInteraction)2);
		foreach (SurveyCrater item in list)
		{
			if (item.isServer)
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<SurveyCrater>(ref list);
	}
}


using System;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class MiningQuarry : BaseResourceExtractor
{
	[Serializable]
	public enum QuarryType
	{
		None,
		Basic,
		Sulfur,
		HQM
	}

	[Serializable]
	public class ChildPrefab
	{
		public GameObjectRef prefabToSpawn;

		public GameObject origin;

		public BaseEntity instance;

		public void DoSpawn(MiningQuarry owner)
		{
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			if (prefabToSpawn.isValid)
			{
				instance = GameManager.server.CreateEntity(prefabToSpawn.resourcePath, origin.transform.localPosition, origin.transform.localRotation);
				instance.SetParent(owner);
				instance.Spawn();
			}
		}
	}

	public Animator beltAnimator;

	public Renderer beltScrollRenderer;

	public int scrollMatIndex = 3;

	public float animatorSpeedChange = 1f;

	public float beltScrollSpeedMultiplier = 1f;

	public SoundPlayer[] onSounds;

	public float processRate = 5f;

	public float workToAdd = 15f;

	public float workPerFuel = 1000f;

	public float pendingWork;

	public GameObjectRef bucketDropEffect;

	public GameObject bucketDropTransform;

	public ChildPrefab engineSwitchPrefab;

	public ChildPrefab hopperPrefab;

	public ChildPrefab fuelStoragePrefab;

	public QuarryType staticType;

	public bool isStatic;

	public ResourceDepositManager.ResourceDeposit _linkedDeposit;

	public bool IsEngineOn()
	{
		return HasFlag(Flags.On);
	}

	public void SetOn(bool isOn)
	{
		SetFlag(Flags.On, isOn);
		engineSwitchPrefab.instance.SetFlag(Flags.On, isOn);
		SendNetworkUpdate();
		engineSwitchPrefab.instance.SendNetworkUpdate();
		if (isOn)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessResources, processRate, processRate);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ProcessResources);
		}
	}

	public void EngineSwitch(bool isOn)
	{
		if (isOn && FuelCheck())
		{
			SetOn(isOn: true);
		}
		else
		{
			SetOn(isOn: false);
		}
	}

	public override void ServerInit()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (isStatic)
		{
			UpdateStaticDeposit();
		}
		else
		{
			ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(((Component)this).transform.position);
			_linkedDeposit = orCreate;
		}
		SpawnChildEntities();
		engineSwitchPrefab.instance.SetFlag(Flags.On, HasFlag(Flags.On));
		if (base.isServer)
		{
			ItemContainer inventory = ((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory;
			inventory.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(inventory.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
		}
	}

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		return item.info.shortname == "diesel_barrel";
	}

	public void UpdateStaticDeposit()
	{
		if (isStatic)
		{
			if (_linkedDeposit == null)
			{
				_linkedDeposit = new ResourceDepositManager.ResourceDeposit();
			}
			else
			{
				_linkedDeposit._resources.Clear();
			}
			if (staticType == QuarryType.None)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 1000, 0.3f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, 1000, 5f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, 1000, 7.5f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, 1000, 75f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			else if (staticType == QuarryType.Basic)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, 1000, 1f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 1000, 0.2f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			else if (staticType == QuarryType.Sulfur)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, 1000, 1f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			else if (staticType == QuarryType.HQM)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, 1000, 20f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			_linkedDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, 1000, 16.666666f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, liquid: true);
			_linkedDeposit.Add(ItemManager.FindItemDefinition("lowgradefuel"), 1f, 1000, 5.882353f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, liquid: true);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		EngineSwitch(HasFlag(Flags.On));
		UpdateStaticDeposit();
	}

	public void SpawnChildEntities()
	{
		engineSwitchPrefab.DoSpawn(this);
		hopperPrefab.DoSpawn(this);
		fuelStoragePrefab.DoSpawn(this);
	}

	public void ProcessResources()
	{
		if (_linkedDeposit == null || (Object)(object)hopperPrefab.instance == (Object)null)
		{
			return;
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
		float num = Mathf.Min(workToAdd, pendingWork);
		pendingWork -= num;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			float workNeeded = resource.workNeeded;
			int num2 = Mathf.FloorToInt(resource.workDone / workNeeded);
			resource.workDone += num;
			int num3 = Mathf.FloorToInt(resource.workDone / workNeeded);
			if (resource.workDone > workNeeded)
			{
				resource.workDone %= workNeeded;
			}
			if (num2 != num3)
			{
				int iAmount = num3 - num2;
				Item item = ItemManager.Create(resource.type, iAmount, 0uL);
				Analytics.Azure.OnQuarryItem(Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);
				if (Interface.CallHook("OnQuarryGather", (object)this, (object)item) != null)
				{
					item.Remove();
				}
				else if (!item.MoveToContainer(((Component)hopperPrefab.instance).GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
	}

	public bool FuelCheck()
	{
		if (pendingWork > 0f)
		{
			return true;
		}
		Item item = ((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory.FindItemByItemName("diesel_barrel");
		object obj = Interface.CallHook("OnQuarryConsumeFuel", (object)this, (object)item);
		if (obj is Item)
		{
			item = (Item)obj;
		}
		if (item != null && item.amount >= 1)
		{
			pendingWork += workPerFuel;
			Analytics.Azure.OnQuarryItem(Analytics.Azure.ResourceMode.Consumed, item.info.shortname, 1, this);
			item.UseItem();
			return true;
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if ((Object)(object)fuelStoragePrefab.instance == (Object)null || (Object)(object)hopperPrefab.instance == (Object)null)
			{
				Debug.Log((object)"Cannot save mining quary because children were null");
				return;
			}
			info.msg.miningQuarry = Pool.Get<MiningQuarry>();
			info.msg.miningQuarry.extractor = Pool.Get<ResourceExtractor>();
			info.msg.miningQuarry.extractor.fuelContents = ((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory.Save();
			info.msg.miningQuarry.extractor.outputContents = ((Component)hopperPrefab.instance).GetComponent<StorageContainer>().inventory.Save();
			info.msg.miningQuarry.staticType = (int)staticType;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && info.msg.miningQuarry != null)
		{
			if ((Object)(object)fuelStoragePrefab.instance == (Object)null || (Object)(object)hopperPrefab.instance == (Object)null)
			{
				Debug.Log((object)"Cannot load mining quary because children were null");
				return;
			}
			((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory.Load(info.msg.miningQuarry.extractor.fuelContents);
			((Component)hopperPrefab.instance).GetComponent<StorageContainer>().inventory.Load(info.msg.miningQuarry.extractor.outputContents);
			staticType = (QuarryType)info.msg.miningQuarry.staticType;
		}
	}
}


using System;

[Serializable]
public enum QuarryType
{
	None,
	Basic,
	Sulfur,
	HQM
}


using System;
using UnityEngine;

[Serializable]
public class ChildPrefab
{
	public GameObjectRef prefabToSpawn;

	public GameObject origin;

	public BaseEntity instance;

	public void DoSpawn(MiningQuarry owner)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (prefabToSpawn.isValid)
		{
			instance = GameManager.server.CreateEntity(prefabToSpawn.resourcePath, origin.transform.localPosition, origin.transform.localRotation);
			instance.SetParent(owner);
			instance.Spawn();
		}
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class ResourceDepositManager : BaseEntity
{
	[Serializable]
	public class ResourceDeposit
	{
		[Serializable]
		public enum surveySpawnType
		{
			ITEM,
			OIL,
			WATER
		}

		[Serializable]
		public class ResourceDepositEntry
		{
			public ItemDefinition type;

			public float efficiency = 1f;

			public int amount;

			public int startAmount;

			public float workNeeded = 1f;

			public float workDone;

			public surveySpawnType spawnType;

			public bool isLiquid;

			public void Subtract(int subamount)
			{
				if (subamount > 0)
				{
					amount -= subamount;
					if (amount < 0)
					{
						amount = 0;
					}
				}
			}
		}

		public float lastSurveyTime = float.NegativeInfinity;

		public Vector3 origin;

		public List<ResourceDepositEntry> _resources;

		public ResourceDeposit()
		{
			_resources = new List<ResourceDepositEntry>();
		}

		public void Add(ItemDefinition type, float efficiency, int amount, float workNeeded, surveySpawnType spawnType, bool liquid = false)
		{
			ResourceDepositEntry resourceDepositEntry = new ResourceDepositEntry();
			resourceDepositEntry.type = type;
			resourceDepositEntry.efficiency = efficiency;
			resourceDepositEntry.startAmount = (resourceDepositEntry.amount = amount);
			resourceDepositEntry.spawnType = spawnType;
			resourceDepositEntry.workNeeded = workNeeded;
			resourceDepositEntry.isLiquid = liquid;
			_resources.Add(resourceDepositEntry);
		}
	}

	public static ResourceDepositManager _manager;

	private const int resolution = 20;

	public Dictionary<Vector2i, ResourceDeposit> _deposits;

	public static Vector2i GetIndexFrom(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i((int)pos.x / 20, (int)pos.z / 20);
	}

	public static ResourceDepositManager Get()
	{
		return _manager;
	}

	public ResourceDepositManager()
	{
		_manager = this;
		_deposits = new Dictionary<Vector2i, ResourceDeposit>();
	}

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		Vector2i indexFrom = GetIndexFrom(pos);
		State state = Random.state;
		Random.InitState((int)SeedEx.Seed(new Vector2((float)indexFrom.x, (float)indexFrom.y), World.Seed + World.Salt));
		ResourceDeposit resourceDeposit = new ResourceDeposit
		{
			origin = new Vector3((float)(indexFrom.x * 20), 0f, (float)(indexFrom.y * 20))
		};
		if (Random.Range(0f, 1f) < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else
		{
			bool flag = false;
			float num = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f)
				{
					num += 0.25f;
				}
			}
			else
			{
				num += 0.15f;
			}
			if (Random.Range(0f, 1f) >= 1f - num)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, Random.Range(5000, 10000), Random.Range(8f, 10f), ResourceDeposit.surveySpawnType.ITEM, liquid: true);
				flag = true;
			}
			if (!flag)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, Random.Range(30000, 100000), Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
				float num2 = 0f;
				num2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f) ? 1f : 0f) * 0.25f));
				if (Random.Range(0f, 1f) >= 1f - num2)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, Random.Range(10000, 100000), Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num3 = 0f;
				num3 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f) ? 1f : 0f) * (0.25f + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));
				if (Random.Range(0f, 1f) >= 1f - num3)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, Random.Range(10000, 100000), Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num4 = 0f;
				if (World.Procedural)
				{
					if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
					{
						num4 += 0.25f;
					}
				}
				else
				{
					num4 += 0.15f;
				}
				if (Random.Range(0f, 1f) >= 1f - num4)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, Random.Range(5000, 10000), Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
				}
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", (object)resourceDeposit);
		Random.state = state;
		return resourceDeposit;
	}

	public ResourceDeposit GetFromPosition(Vector3 pos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		ResourceDeposit value = null;
		if (_deposits.TryGetValue(GetIndexFrom(pos), out value))
		{
			return value;
		}
		return null;
	}

	public static ResourceDeposit GetOrCreate(Vector3 pos)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		ResourceDeposit fromPosition = Get().GetFromPosition(pos);
		if (fromPosition != null)
		{
			return fromPosition;
		}
		return Get().CreateFromPosition(pos);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class ResourceDeposit
{
	[Serializable]
	public enum surveySpawnType
	{
		ITEM,
		OIL,
		WATER
	}

	[Serializable]
	public class ResourceDepositEntry
	{
		public ItemDefinition type;

		public float efficiency = 1f;

		public int amount;

		public int startAmount;

		public float workNeeded = 1f;

		public float workDone;

		public surveySpawnType spawnType;

		public bool isLiquid;

		public void Subtract(int subamount)
		{
			if (subamount > 0)
			{
				amount -= subamount;
				if (amount < 0)
				{
					amount = 0;
				}
			}
		}
	}

	public float lastSurveyTime = float.NegativeInfinity;

	public Vector3 origin;

	public List<ResourceDepositEntry> _resources;

	public ResourceDeposit()
	{
		_resources = new List<ResourceDepositEntry>();
	}

	public void Add(ItemDefinition type, float efficiency, int amount, float workNeeded, surveySpawnType spawnType, bool liquid = false)
	{
		ResourceDepositEntry resourceDepositEntry = new ResourceDepositEntry();
		resourceDepositEntry.type = type;
		resourceDepositEntry.efficiency = efficiency;
		resourceDepositEntry.startAmount = (resourceDepositEntry.amount = amount);
		resourceDepositEntry.spawnType = spawnType;
		resourceDepositEntry.workNeeded = workNeeded;
		resourceDepositEntry.isLiquid = liquid;
		_resources.Add(resourceDepositEntry);
	}
}


using System;

[Serializable]
public enum surveySpawnType
{
	ITEM,
	OIL,
	WATER
}


using System;

[Serializable]
public class ResourceDepositEntry
{
	public ItemDefinition type;

	public float efficiency = 1f;

	public int amount;

	public int startAmount;

	public float workNeeded = 1f;

	public float workDone;

	public surveySpawnType spawnType;

	public bool isLiquid;

	public void Subtract(int subamount)
	{
		if (subamount > 0)
		{
			amount -= subamount;
			if (amount < 0)
			{
				amount = 0;
			}
		}
	}
}


public class ResourceExtractorFuelStorage : StorageContainer
{
}


using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using UnityEngine;

public class SurveyCharge : TimedExplosive
{
	public GameObjectRef craterPrefab;

	public GameObjectRef craterPrefab_Oil;

	public override void Explode()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		base.Explode();
		if (WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: true, this))
		{
			return;
		}
		ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(((Component)this).transform.position);
		if (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)
		{
			return;
		}
		orCreate.lastSurveyTime = Time.realtimeSinceStartup;
		if (!TransformUtil.GetGroundInfo(((Component)this).transform.position, out var hitOut, 0.3f, LayerMask.op_Implicit(8388608)))
		{
			return;
		}
		Vector3 point = ((RaycastHit)(ref hitOut)).point;
		_ = ((RaycastHit)(ref hitOut)).normal;
		List<SurveyCrater> list = Pool.Get<List<SurveyCrater>>();
		Vis.Entities(((Component)this).transform.position, 10f, list, 1, (QueryTriggerInteraction)2);
		bool num = list.Count > 0;
		Pool.FreeUnmanaged<SurveyCrater>(ref list);
		if (num)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)
		{
			if (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)
			{
				int num2 = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);
				int iAmount = 1;
				flag = true;
				if (resource.isLiquid)
				{
					flag2 = true;
				}
				for (int i = 0; i < num2; i++)
				{
					Item item = ItemManager.Create(resource.type, iAmount, 0uL);
					Interface.CallHook("OnSurveyGather", (object)this, (object)item);
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up);
					BaseEntity baseEntity = item.Drop(((Component)this).transform.position + Vector3.up * 1f, GetInheritedDropVelocity() + modifiedAimConeDirection * Random.Range(5f, 10f), Random.rotation);
					Quaternion rotation = Random.rotation;
					baseEntity.SetAngularVelocity(((Quaternion)(ref rotation)).eulerAngles * 5f);
				}
			}
		}
		if (flag)
		{
			string strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);
			if (Object.op_Implicit((Object)(object)baseEntity2))
			{
				baseEntity2.Spawn();
			}
		}
	}
}


using UnityEngine;

public class NPCAutoTurret : AutoTurret
{
	public Transform centerMuzzle;

	public Transform muzzleLeft;

	public Transform muzzleRight;

	public bool useSleeperHostile = true;

	private bool useLeftMuzzle;

	[ReplicatedVar(Help = "How many seconds until a sleeping player is considered hostile")]
	public static float sleeperhostiledelay = 1200f;

	private Matrix4x4 toCenterMuzzleFromPitch;

	public override void ServerInit()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		SetOnline();
		SetPeacekeepermode(isOn: true);
		toCenterMuzzleFromPitch = gun_pitch.worldToLocalMatrix * centerMuzzle.localToWorldMatrix;
	}

	public virtual bool HasAmmo()
	{
		return true;
	}

	public override bool CheckPeekers()
	{
		return false;
	}

	public override float TargetScanRate()
	{
		return 1.25f;
	}

	public override bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		return true;
	}

	public override float GetMaxAngleForEngagement()
	{
		return 15f;
	}

	public override bool HasFallbackWeapon()
	{
		return true;
	}

	public override Matrix4x4 GetCenterMuzzle()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			return base.GetCenterMuzzle() * toCenterMuzzleFromPitch;
		}
		return centerMuzzle.localToWorldMatrix;
	}

	public override void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse = null, BaseCombatEntity target = null)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		muzzleToUse = muzzleRight;
		base.FireGun(targetPos, aimCone, muzzleToUse, target);
	}

	public override bool Ignore(BasePlayer player)
	{
		if (!(player is ScientistNPC))
		{
			return player is BanditGuard;
		}
		return true;
	}

	public override bool IsEntityHostile(BaseCombatEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsNpc)
			{
				if (basePlayer is ScientistNPC || basePlayer is BanditGuard)
				{
					return false;
				}
				if (basePlayer is NPCShopKeeper)
				{
					return false;
				}
				if (basePlayer is BasePet)
				{
					return base.IsEntityHostile(basePlayer);
				}
				return true;
			}
			if (basePlayer.IsSleeping() && useSleeperHostile && basePlayer.secondsSleeping >= sleeperhostiledelay)
			{
				return true;
			}
		}
		return base.IsEntityHostile(ent);
	}
}


using UnityEngine;

public class TargetTrigger : TriggerBase
{
	[Tooltip("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
	public Transform losEyes;

	public override GameObject InterestedInObject(GameObject obj)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if ((Object)(object)losEyes != (Object)null && !baseEntity.IsVisible(((Component)losEyes).transform.position, baseEntity.CenterPoint()))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;

public class BirthdayBalloonHandler : MonoBehaviour, IClientComponent
{
	public float checkOffset = 1f;

	public float checkRadius = 0.5f;
}


using Facepunch.CardGames;
using UnityEngine;

public class BlackjackMachine : BaseCardGameEntity
{
	[Header("Blackjack Machine")]
	[SerializeField]
	private GameObjectRef mainScreenPrefab;

	[SerializeField]
	private GameObjectRef smallScreenPrefab;

	[SerializeField]
	private Transform mainScreenParent;

	[SerializeField]
	private Transform[] smallScreenParents;

	private static int _maxbet = 500;

	private BlackjackController controller;

	private BlackjackMainScreenUI mainScreenUI;

	private BlackjackSmallScreenUI[] smallScreenUIs = new BlackjackSmallScreenUI[3];

	[ServerVar(Help = "Maximum initial bet per round")]
	public static int maxbet
	{
		get
		{
			return _maxbet;
		}
		set
		{
			_maxbet = Mathf.Clamp(value, 25, 1000000);
		}
	}

	protected override float MaxStorageInteractionDist => 1f;

	public override void InitShared()
	{
		base.InitShared();
		controller = (BlackjackController)base.GameController;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	public override void PlayerStorageChanged()
	{
		base.PlayerStorageChanged();
		SendNetworkUpdate();
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CardGamePlayerStorage : StorageContainer
{
	private EntityRef cardTableRef;

	public BaseCardGameEntity GetCardGameEntity()
	{
		BaseEntity baseEntity = cardTableRef.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as BaseCardGameEntity;
		}
		return null;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.simpleUID != null)
		{
			cardTableRef.uid = info.msg.simpleUID.uid;
		}
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		BaseCardGameEntity cardGameEntity = GetCardGameEntity();
		if ((Object)(object)cardGameEntity != (Object)null)
		{
			cardGameEntity.PlayerStorageChanged();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.simpleUID = Pool.Get<SimpleUID>();
		info.msg.simpleUID.uid = cardTableRef.uid;
	}

	public void SetCardTable(BaseCardGameEntity cardGameEntity)
	{
		cardTableRef.Set(cardGameEntity);
	}
}


using System;
using UnityEngine;

public class CardGameSounds : PrefabAttribute
{
	public enum SoundType
	{
		Chips,
		Draw,
		Play,
		Shuffle,
		Win,
		YourTurn,
		Check,
		Hit,
		Stand,
		Bet,
		IncreaseBet,
		DecreaseBet,
		AllIn,
		UIInteract,
		DealerCool,
		DealerHappy,
		DealerLove,
		DealerSad,
		DealerShocked
	}

	public SoundDefinition ChipsSfx;

	public SoundDefinition DrawSfx;

	public SoundDefinition PlaySfx;

	public SoundDefinition ShuffleSfx;

	public SoundDefinition WinSfx;

	public SoundDefinition LoseSfx;

	public SoundDefinition YourTurnSfx;

	public SoundDefinition CheckSfx;

	public SoundDefinition HitSfx;

	public SoundDefinition StandSfx;

	public SoundDefinition BetSfx;

	public SoundDefinition IncreaseBetSfx;

	public SoundDefinition DecreaseBetSfx;

	public SoundDefinition AllInSfx;

	public SoundDefinition UIInteractSfx;

	[Header("Dealer Reactions")]
	public SoundDefinition DealerCoolSfx;

	public SoundDefinition DealerHappySfx;

	public SoundDefinition DealerLoveSfx;

	public SoundDefinition DealerSadSfx;

	public SoundDefinition DealerShockedSfx;

	protected override Type GetIndexedType()
	{
		return typeof(CardGameSounds);
	}

	public void PlaySound(SoundType sound, GameObject forGameObject)
	{
		switch (sound)
		{
		case SoundType.Chips:
			ChipsSfx.Play(forGameObject);
			break;
		case SoundType.Draw:
			DrawSfx.Play(forGameObject);
			break;
		case SoundType.Play:
			PlaySfx.Play(forGameObject);
			break;
		case SoundType.Shuffle:
			ShuffleSfx.Play(forGameObject);
			break;
		case SoundType.Win:
			WinSfx.Play(forGameObject);
			break;
		case SoundType.YourTurn:
			YourTurnSfx.Play(forGameObject);
			break;
		case SoundType.Check:
			CheckSfx.Play(forGameObject);
			break;
		case SoundType.Hit:
			HitSfx.Play(forGameObject);
			break;
		case SoundType.Stand:
			StandSfx.Play(forGameObject);
			break;
		case SoundType.Bet:
			BetSfx.Play(forGameObject);
			break;
		case SoundType.IncreaseBet:
			IncreaseBetSfx.Play(forGameObject);
			break;
		case SoundType.DecreaseBet:
			DecreaseBetSfx.Play(forGameObject);
			break;
		case SoundType.AllIn:
			AllInSfx.Play(forGameObject);
			break;
		case SoundType.UIInteract:
			UIInteractSfx.Play(forGameObject);
			break;
		case SoundType.DealerCool:
			DealerCoolSfx.Play(forGameObject);
			break;
		case SoundType.DealerHappy:
			DealerHappySfx.Play(forGameObject);
			break;
		case SoundType.DealerLove:
			DealerLoveSfx.Play(forGameObject);
			break;
		case SoundType.DealerSad:
			DealerSadSfx.Play(forGameObject);
			break;
		case SoundType.DealerShocked:
			DealerShockedSfx.Play(forGameObject);
			break;
		default:
			throw new ArgumentOutOfRangeException("sound", sound, null);
		}
	}
}


public enum SoundType
{
	Chips,
	Draw,
	Play,
	Shuffle,
	Win,
	YourTurn,
	Check,
	Hit,
	Stand,
	Bet,
	IncreaseBet,
	DecreaseBet,
	AllIn,
	UIInteract,
	DealerCool,
	DealerHappy,
	DealerLove,
	DealerSad,
	DealerShocked
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class CardTable : BaseCardGameEntity
{
	[Serializable]
	public class ChipStack : IComparable<ChipStack>
	{
		public int chipValue;

		public GameObject[] chips;

		public int CompareTo(ChipStack other)
		{
			if (other == null)
			{
				return 1;
			}
			return chipValue.CompareTo(other.chipValue);
		}
	}

	[Header("Card Table")]
	[SerializeField]
	private ViewModel viewModel;

	[SerializeField]
	private CardGameUI.PlayingCardImage[] tableCards;

	[SerializeField]
	private Renderer[] tableCardBackings;

	[SerializeField]
	private Canvas cardUICanvas;

	[SerializeField]
	private Image[] tableCardImages;

	[SerializeField]
	private Sprite blankCard;

	[SerializeField]
	private ChipStack[] chipStacks;

	[SerializeField]
	private ChipStack[] fillerStacks;

	protected override float MaxStorageInteractionDist => 1f;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ChipStack : IComparable<ChipStack>
{
	public int chipValue;

	public GameObject[] chips;

	public int CompareTo(ChipStack other)
	{
		if (other == null)
		{
			return 1;
		}
		return chipValue.CompareTo(other.chipValue);
	}
}


using UnityEngine;

public class CardTableSeat : BaseChair
{
	public Transform CardsMesh;
}


using UnityEngine;
using UnityEngine.UI;

public class PlayingCardsViewmodel : MonoBehaviour
{
	[SerializeField]
	private Canvas cardUICanvas;

	[SerializeField]
	private Image cardA;

	[SerializeField]
	private Image cardB;

	[SerializeField]
	private Sprite blankCard;
}


public class DecorDeployable : DecayEntity
{
}


using ConVar;
using Oxide.Core;
using UnityEngine;

public class DropUtil
{
	public static void DropItems(ItemContainer container, Vector3 position)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", (object)container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			float num2 = Random.Range(0f, 2f);
			item.RemoveFromContainer();
			BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(Random.Range(0f - num, num), 1f, Random.Range(0f - num, num)));
			if ((Object)(object)baseEntity == (Object)null)
			{
				item.Remove();
				continue;
			}
			if (baseEntity is DroppedItem droppedItem && container.entityOwner is LootContainer)
			{
				droppedItem.DropReason = DroppedItem.DropReasonEnum.Loot;
			}
			if (num2 > 0f)
			{
				baseEntity.SetVelocity(new Vector3(Random.Range(-1f, 1f), Random.Range(0f, 1f), Random.Range(-1f, 1f)) * num2);
				baseEntity.SetAngularVelocity(new Vector3(Random.Range(-10f, 10f), Random.Range(-10f, 10f), Random.Range(-10f, 10f)) * num2);
			}
		}
	}
}


public class DynamicPreventBuilding : BaseEntity
{
}


using System;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class EnvSync : PointEntity
{
	private const float syncInterval = 5f;

	private const float syncIntervalInv = 0.2f;

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateNetwork, 5f, 5f);
	}

	private void UpdateNetwork()
	{
		if (NexusServer.Started && NexusServer.LastReset.HasValue && (Object)(object)TOD_Sky.Instance != (Object)null)
		{
			TOD_Time time = TOD_Sky.Instance.Components.Time;
			DateTimeOffset dateTimeOffset = DateTimeOffset.FromUnixTimeSeconds(NexusServer.LastReset.Value);
			double totalMinutes = (DateTimeOffset.UtcNow - dateTimeOffset).TotalMinutes;
			double num = (double)(Nexus.timeOffset / 24f) + totalMinutes / (double)time.DayLengthInMinutes;
			if (time.UseTimeCurve)
			{
				double num2 = Math.Truncate(num);
				double num3 = (num - num2) * 24.0;
				float num4 = time.EvaulateTimeCurve((float)num3);
				num = num2 + (double)(num4 / 24f);
			}
			double value = num * 24.0;
			DateTime dateTime = dateTimeOffset.Date.AddHours(value);
			TOD_Sky.Instance.Cycle.DateTime = dateTime;
		}
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.environment = Pool.Get<Environment>();
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			info.msg.environment.dateTime = TOD_Sky.Instance.Cycle.DateTime.ToBinary();
		}
		info.msg.environment.engineTime = Time.realtimeSinceStartup;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.environment != null && Object.op_Implicit((Object)(object)TOD_Sky.Instance) && base.isServer)
		{
			TOD_Sky.Instance.Cycle.DateTime = DateTime.FromBinary(info.msg.environment.dateTime);
		}
	}
}


using System;
using UnityEngine;

public class F15 : BaseCombatEntity
{
	public float speed = 150f;

	public float defaultAltitude = 150f;

	public float altitude = 250f;

	public float altitudeLerpSpeed = 30f;

	public float turnRate = 1f;

	public float flybySoundLengthUntilMax = 4.5f;

	public SoundPlayer flybySound;

	public GameObject body;

	public float rollSpeed = 1f;

	public Vector3 movePosition;

	public GameObjectRef missilePrefab;

	private float nextMissileTime;

	private float blockTurningFor;

	private bool isRetiring;

	private CH47PathFinder pathFinder = new CH47PathFinder();

	private float turnSeconds;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public float GetDesiredAltitude()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + ((Component)this).transform.forward * 200f;
		return (TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position) + TerrainMeta.HeightMap.GetHeight(val) + TerrainMeta.HeightMap.GetHeight(val + Vector3.right * 50f) + TerrainMeta.HeightMap.GetHeight(val - Vector3.right * 50f) + TerrainMeta.HeightMap.GetHeight(val + Vector3.forward * 50f) + TerrainMeta.HeightMap.GetHeight(val - Vector3.forward * 50f)) / 6f + defaultAltitude;
	}

	public override void ServerInit()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)RetireToSunset, 600f);
		movePosition = ((Component)this).transform.position;
		movePosition.y = defaultAltitude;
		((Component)this).transform.position = movePosition;
	}

	public void RetireToSunset()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		isRetiring = true;
		movePosition = new Vector3(10000f, defaultAltitude, 10000f);
	}

	public void PickNewPatrolPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		movePosition = pathFinder.GetRandomPatrolPoint();
		float num = 0f;
		if ((Object)(object)TerrainMeta.HeightMap != (Object)null)
		{
			num = TerrainMeta.HeightMap.GetHeight(movePosition);
		}
		movePosition.y = num + defaultAltitude;
	}

	private void FixedUpdate()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		if (isRetiring && Vector3.Distance(((Component)this).transform.position, Vector3.zero) > 4900f)
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, 0f);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)DelayedDestroy))
		{
			altitude = Mathf.Lerp(altitude, GetDesiredAltitude(), Time.fixedDeltaTime * 0.25f);
			if (Vector3Ex.Distance2D(movePosition, ((Component)this).transform.position) < 10f)
			{
				PickNewPatrolPoint();
				blockTurningFor = 6f;
			}
			blockTurningFor -= Time.fixedDeltaTime;
			bool num = blockTurningFor > 0f;
			movePosition.y = altitude;
			Vector3 val = Vector3Ex.Direction(movePosition, ((Component)this).transform.position);
			if (num)
			{
				Vector3 position = ((Component)this).transform.position;
				position.y = altitude;
				Vector3 val2 = QuaternionEx.LookRotationForcedUp(((Component)this).transform.forward, Vector3.up) * Vector3.forward;
				val = Vector3Ex.Direction(position + val2 * 2000f, ((Component)this).transform.position);
			}
			Vector3 forward = Vector3.Lerp(((Component)this).transform.forward, val, Time.fixedDeltaTime * turnRate);
			((Component)this).transform.forward = forward;
			bool flag = Vector3.Dot(((Component)this).transform.right, val) > 0.55f;
			bool flag2 = Vector3.Dot(-((Component)this).transform.right, val) > 0.55f;
			SetFlag(Flags.Reserved1, flag);
			SetFlag(Flags.Reserved2, flag2);
			if (flag2 || flag)
			{
				turnSeconds += Time.fixedDeltaTime;
			}
			else
			{
				turnSeconds = 0f;
			}
			if (turnSeconds > 10f)
			{
				turnSeconds = 0f;
				blockTurningFor = 8f;
			}
			Transform transform = ((Component)this).transform;
			transform.position += ((Component)this).transform.forward * speed * Time.fixedDeltaTime;
			nextMissileTime = Time.realtimeSinceStartup + 10f;
		}
	}

	public void DelayedDestroy()
	{
		Kill();
	}
}


public interface IAlwaysOn
{
	void SetAlwaysOn(bool flag);

	bool IsAlwaysOn()
	{
		return false;
	}

	void AlwaysOnToggled(bool flag);
}


using UnityEngine;

public interface IIgniteable
{
	void Ignite(Vector3 fromPos);

	bool CanIgnite();
}


public interface IReceivePlayerTickListener
{
	void OnReceivePlayerTick(BasePlayer player, PlayerTick msg);

	bool ShouldRemoveOnPlayerDeath();
}


public interface ISplashable
{
	bool WantsSplash(ItemDefinition splashType, int amount);

	int DoSplash(ItemDefinition splashType, int amount);
}


using System;
using ConVar;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

public class LootContainer : StorageContainer
{
	public enum spawnType
	{
		GENERIC,
		PLAYER,
		TOWN,
		AIRDROP,
		CRASHSITE,
		ROADSIDE
	}

	[Serializable]
	public struct LootSpawnSlot
	{
		public LootSpawn definition;

		public int numberToSpawn;

		public float probability;

		public string onlyWithLoadoutNamed;

		public Era[] eras;
	}

	public bool destroyOnEmpty = true;

	public LootSpawn lootDefinition;

	public int maxDefinitionsToSpawn;

	public float minSecondsBetweenRefresh = 3600f;

	public float maxSecondsBetweenRefresh = 7200f;

	public bool initialLootSpawn = true;

	public float xpLootedScale = 1f;

	public float xpDestroyedScale = 1f;

	public bool BlockPlayerItemInput;

	public int scrapAmount;

	public string deathStat = "";

	public LootSpawnSlot[] LootSpawnSlots;

	public spawnType SpawnType;

	public ClanScoreEventType clanScoreEventForFirstLooter = (ClanScoreEventType)(-1);

	[NonSerialized]
	public bool HasBeenLooted;

	[NonSerialized]
	public ulong FirstLooterId;

	private static ItemDefinition scrapDef;

	public bool shouldRefreshContents
	{
		get
		{
			if (minSecondsBetweenRefresh > 0f)
			{
				return maxSecondsBetweenRefresh > 0f;
			}
			return false;
		}
	}

	public override void ResetState()
	{
		FirstLooterId = 0uL;
		base.ResetState();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (initialLootSpawn)
		{
			SpawnLoot();
		}
		if (BlockPlayerItemInput && !Application.isLoadingSave && base.inventory != null)
		{
			base.inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
		}
		SetFlag(Flags.Reserved6, PlayerInventory.IsBirthday());
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (!added)
		{
			HasBeenLooted = true;
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (BlockPlayerItemInput && base.inventory != null)
		{
			base.inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
		}
	}

	public virtual void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log((object)"CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!");
			return;
		}
		base.inventory.Clear();
		ItemManager.DoRemoves();
		if (Interface.CallHook("OnLootSpawn", (object)this) == null)
		{
			PopulateLoot();
			if (shouldRefreshContents)
			{
				((FacepunchBehaviour)this).Invoke((Action)SpawnLoot, Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));
			}
		}
	}

	public int ScoreForRarity(Rarity rarity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Expected I4, but got Unknown
		return (rarity - 1) switch
		{
			0 => 1, 
			1 => 2, 
			2 => 3, 
			3 => 4, 
			_ => 5000, 
		};
	}

	public virtual void PopulateLoot()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (LootSpawnSlots.Length != 0)
		{
			LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
			for (int i = 0; i < lootSpawnSlots.Length; i++)
			{
				LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
				if (lootSpawnSlot.eras != null && lootSpawnSlot.eras.Length != 0 && Array.IndexOf(lootSpawnSlot.eras, ConVar.Server.Era) == -1)
				{
					continue;
				}
				for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
				{
					if (Random.Range(0f, 1f) <= lootSpawnSlot.probability)
					{
						lootSpawnSlot.definition.SpawnIntoContainer(base.inventory);
					}
				}
			}
		}
		else if ((Object)(object)lootDefinition != (Object)null)
		{
			for (int k = 0; k < maxDefinitionsToSpawn; k++)
			{
				lootDefinition.SpawnIntoContainer(base.inventory);
			}
		}
		if (SpawnType == spawnType.ROADSIDE || SpawnType == spawnType.TOWN)
		{
			foreach (Item item in base.inventory.itemList)
			{
				if (item.hasCondition)
				{
					item.condition = Random.Range(item.info.condition.foundCondition.fractionMin, item.info.condition.foundCondition.fractionMax) * item.info.condition.max;
				}
			}
		}
		GenerateScrap();
		HasBeenLooted = false;
	}

	public void GenerateScrap()
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (scrapAmount <= 0)
		{
			return;
		}
		if ((Object)(object)scrapDef == (Object)null)
		{
			scrapDef = ItemManager.FindItemDefinition("scrap");
		}
		int num = scrapAmount;
		if (num > 0)
		{
			Item item = ItemManager.Create(scrapDef, num, 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Drop(((Component)this).transform.position, GetInheritedDropVelocity());
			}
		}
	}

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		base.DropBonusItems(initiator, container);
		if ((Object)(object)initiator == (Object)null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null || scrapAmount <= 0 || !((Object)(object)scrapDef != (Object)null))
		{
			return;
		}
		float num = (((Object)(object)basePlayer.modifiers != (Object)null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", (object)item, (object)basePlayer, (object)container) == null)
			{
				(item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;
				Interface.CallHook("OnBonusItemDropped", (object)item, (object)basePlayer, (object)container);
			}
		}
	}

	public override bool OnStartBeingLooted(BasePlayer player)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Invalid comparison between Unknown and I4
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (FirstLooterId == 0L && !player.isInvisible)
		{
			FirstLooterId = player.userID;
			Analytics.Azure.OnFirstLooted(this, player);
			if ((int)clanScoreEventForFirstLooter != -1)
			{
				player.AddClanScore(clanScoreEventForFirstLooter);
			}
			if (base.inventory != null && base.inventory.itemList != null)
			{
				foreach (Item item in base.inventory.itemList)
				{
					item?.SetItemOwnership(player, ItemOwnershipPhrases.LootedPhrase);
				}
			}
		}
		return base.OnStartBeingLooted(player);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		if (destroyOnEmpty && (base.inventory == null || base.inventory.itemList == null || base.inventory.itemList.Count == 0))
		{
			Kill(DestroyMode.Gib);
		}
	}

	public void RemoveMe()
	{
		Kill(DestroyMode.Gib);
	}

	public override bool ShouldDropItemsIndividually()
	{
		return true;
	}

	public override void DropItems(BaseEntity initiator = null)
	{
		if (initiator is BasePlayer player)
		{
			foreach (Item item in base.inventory.itemList)
			{
				item?.SetItemOwnership(player, ItemOwnershipPhrases.LootedPhrase);
			}
		}
		base.DropItems(initiator);
	}

	public override void OnDied(HitInfo info)
	{
		if (info != null)
		{
			Analytics.Azure.OnLootContainerDestroyed(this, info.InitiatorPlayer, info.Weapon);
		}
		base.OnDied(info);
		if (info != null && (Object)(object)info.InitiatorPlayer != (Object)null && !string.IsNullOrEmpty(deathStat))
		{
			info.InitiatorPlayer.stats.Add(deathStat, 1, Stats.Life);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
	}

	public override void InitShared()
	{
		base.InitShared();
	}
}


public enum spawnType
{
	GENERIC,
	PLAYER,
	TOWN,
	AIRDROP,
	CRASHSITE,
	ROADSIDE
}


using System;
using Rust;

[Serializable]
public struct LootSpawnSlot
{
	public LootSpawn definition;

	public int numberToSpawn;

	public float probability;

	public string onlyWithLoadoutNamed;

	public Era[] eras;
}


public class LootContainerAchievement : LootContainer
{
	public string AchievementName = string.Empty;

	public bool AllowDuringTutorial;

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		if (!string.IsNullOrEmpty(AchievementName))
		{
			baseEntity.GiveAchievement(AchievementName, AllowDuringTutorial);
		}
		return base.OnStartBeingLooted(baseEntity);
	}
}


using System;
using UnityEngine;

public class m2bradleyAnimator : MonoBehaviour
{
	public Animator m2Animator;

	public Material treadLeftMaterial;

	public Material treadRightMaterial;

	private Rigidbody mainRigidbody;

	[Header("GunBones")]
	public Transform turret;

	public Transform mainCannon;

	public Transform coaxGun;

	public Transform rocketsPitch;

	public Transform spotLightYaw;

	public Transform spotLightPitch;

	public Transform sideMG;

	public Transform[] sideguns;

	[Header("WheelBones")]
	public Transform[] ShocksBones;

	public Transform[] ShockTraceLineBegin;

	public Vector3[] vecShocksOffsetPosition;

	[Header("Targeting")]
	public Transform targetTurret;

	public Transform targetSpotLight;

	public Transform[] targetSideguns;

	private Vector3 vecTurret = new Vector3(0f, 0f, 0f);

	private Vector3 vecMainCannon = new Vector3(0f, 0f, 0f);

	private Vector3 vecCoaxGun = new Vector3(0f, 0f, 0f);

	private Vector3 vecRocketsPitch = new Vector3(0f, 0f, 0f);

	private Vector3 vecSpotLightBase = new Vector3(0f, 0f, 0f);

	private Vector3 vecSpotLight = new Vector3(0f, 0f, 0f);

	private float sideMGPitchValue;

	[Header("MuzzleFlash locations")]
	public GameObject muzzleflashCannon;

	public GameObject muzzleflashCoaxGun;

	public GameObject muzzleflashSideMG;

	public GameObject[] muzzleflashRockets;

	public GameObject spotLightHaloSawnpoint;

	public GameObject[] muzzleflashSideguns;

	[Header("MuzzleFlash Particle Systems")]
	public GameObjectRef machineGunMuzzleFlashFX;

	public GameObjectRef mainCannonFireFX;

	public GameObjectRef rocketLaunchFX;

	[Header("Misc")]
	public bool rocketsOpen;

	public Vector3[] vecSideGunRotation;

	public float treadConstant = 0.14f;

	public float wheelSpinConstant = 80f;

	[Header("Gun Movement speeds")]
	public float sidegunsTurnSpeed = 30f;

	public float turretTurnSpeed = 6f;

	public float cannonPitchSpeed = 10f;

	public float rocketPitchSpeed = 20f;

	public float spotLightTurnSpeed = 60f;

	public float machineGunSpeed = 20f;

	private float wheelAngle;

	private void Start()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		mainRigidbody = ((Component)this).GetComponent<Rigidbody>();
		for (int i = 0; i < ShocksBones.Length; i++)
		{
			vecShocksOffsetPosition[i] = ShocksBones[i].localPosition;
		}
	}

	private void Update()
	{
		TrackTurret();
		TrackSpotLight();
		TrackSideGuns();
		AnimateWheelsTreads();
		AdjustShocksHeight();
		m2Animator.SetBool("rocketpods", rocketsOpen);
	}

	private void AnimateWheelsTreads()
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		if ((Object)(object)mainRigidbody != (Object)null)
		{
			num = Vector3.Dot(mainRigidbody.velocity, ((Component)this).transform.forward);
		}
		float num2 = Time.time * -1f * num * treadConstant % 1f;
		treadLeftMaterial.SetTextureOffset("_MainTex", new Vector2(num2, 0f));
		treadLeftMaterial.SetTextureOffset("_BumpMap", new Vector2(num2, 0f));
		treadLeftMaterial.SetTextureOffset("_SpecGlossMap", new Vector2(num2, 0f));
		treadRightMaterial.SetTextureOffset("_MainTex", new Vector2(num2, 0f));
		treadRightMaterial.SetTextureOffset("_BumpMap", new Vector2(num2, 0f));
		treadRightMaterial.SetTextureOffset("_SpecGlossMap", new Vector2(num2, 0f));
		if (num >= 0f)
		{
			wheelAngle = (wheelAngle + Time.deltaTime * num * wheelSpinConstant) % 360f;
		}
		else
		{
			wheelAngle += Time.deltaTime * num * wheelSpinConstant;
			if (wheelAngle <= 0f)
			{
				wheelAngle = 360f;
			}
		}
		m2Animator.SetFloat("wheel_spin", wheelAngle);
		m2Animator.SetFloat("speed", num);
	}

	private void AdjustShocksHeight()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		Ray val = default(Ray);
		int mask = LayerMask.GetMask(new string[3] { "Terrain", "World", "Construction" });
		int num = ShocksBones.Length;
		float num2 = 0.55f;
		float num3 = 0.79f;
		float num4 = 0.26f;
		RaycastHit val2 = default(RaycastHit);
		for (int i = 0; i < num; i++)
		{
			((Ray)(ref val)).origin = ShockTraceLineBegin[i].position;
			((Ray)(ref val)).direction = ((Component)this).transform.up * -1f;
			num4 = ((!Physics.SphereCast(val, 0.15f, ref val2, num3, mask)) ? 0.26f : (((RaycastHit)(ref val2)).distance - num2));
			vecShocksOffsetPosition[i].y = Mathf.Lerp(vecShocksOffsetPosition[i].y, Mathf.Clamp(num4 * -1f, -0.26f, 0f), Time.deltaTime * 5f);
			ShocksBones[i].localPosition = vecShocksOffsetPosition[i];
		}
	}

	private void TrackTurret()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)targetTurret != (Object)null))
		{
			return;
		}
		Vector3 val = targetTurret.position - turret.position;
		_ = ((Vector3)(ref val)).normalized;
		CalculateYawPitchOffset(turret, turret.position, targetTurret.position, out var yaw, out var pitch);
		yaw = NormalizeYaw(yaw);
		float num = Time.deltaTime * turretTurnSpeed;
		if (yaw < -0.5f)
		{
			vecTurret.y = (vecTurret.y - num) % 360f;
		}
		else if (yaw > 0.5f)
		{
			vecTurret.y = (vecTurret.y + num) % 360f;
		}
		turret.localEulerAngles = vecTurret;
		float num2 = Time.deltaTime * cannonPitchSpeed;
		CalculateYawPitchOffset(mainCannon, mainCannon.position, targetTurret.position, out yaw, out pitch);
		if (pitch < -0.5f)
		{
			vecMainCannon.x -= num2;
		}
		else if (pitch > 0.5f)
		{
			vecMainCannon.x += num2;
		}
		vecMainCannon.x = Mathf.Clamp(vecMainCannon.x, -55f, 5f);
		mainCannon.localEulerAngles = vecMainCannon;
		if (pitch < -0.5f)
		{
			vecCoaxGun.x -= num2;
		}
		else if (pitch > 0.5f)
		{
			vecCoaxGun.x += num2;
		}
		vecCoaxGun.x = Mathf.Clamp(vecCoaxGun.x, -65f, 15f);
		coaxGun.localEulerAngles = vecCoaxGun;
		if (rocketsOpen)
		{
			num2 = Time.deltaTime * rocketPitchSpeed;
			CalculateYawPitchOffset(rocketsPitch, rocketsPitch.position, targetTurret.position, out yaw, out pitch);
			if (pitch < -0.5f)
			{
				vecRocketsPitch.x -= num2;
			}
			else if (pitch > 0.5f)
			{
				vecRocketsPitch.x += num2;
			}
			vecRocketsPitch.x = Mathf.Clamp(vecRocketsPitch.x, -45f, 45f);
		}
		else
		{
			vecRocketsPitch.x = Mathf.Lerp(vecRocketsPitch.x, 0f, Time.deltaTime * 1.7f);
		}
		rocketsPitch.localEulerAngles = vecRocketsPitch;
	}

	private void TrackSpotLight()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetSpotLight != (Object)null)
		{
			Vector3 val = targetSpotLight.position - spotLightYaw.position;
			_ = ((Vector3)(ref val)).normalized;
			CalculateYawPitchOffset(spotLightYaw, spotLightYaw.position, targetSpotLight.position, out var yaw, out var pitch);
			yaw = NormalizeYaw(yaw);
			float num = Time.deltaTime * spotLightTurnSpeed;
			if (yaw < -0.5f)
			{
				vecSpotLightBase.y = (vecSpotLightBase.y - num) % 360f;
			}
			else if (yaw > 0.5f)
			{
				vecSpotLightBase.y = (vecSpotLightBase.y + num) % 360f;
			}
			spotLightYaw.localEulerAngles = vecSpotLightBase;
			CalculateYawPitchOffset(spotLightPitch, spotLightPitch.position, targetSpotLight.position, out yaw, out pitch);
			if (pitch < -0.5f)
			{
				vecSpotLight.x -= num;
			}
			else if (pitch > 0.5f)
			{
				vecSpotLight.x += num;
			}
			vecSpotLight.x = Mathf.Clamp(vecSpotLight.x, -50f, 50f);
			spotLightPitch.localEulerAngles = vecSpotLight;
			m2Animator.SetFloat("sideMG_pitch", vecSpotLight.x, 0.5f, Time.deltaTime);
		}
	}

	private void TrackSideGuns()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < sideguns.Length; i++)
		{
			if (!((Object)(object)targetSideguns[i] == (Object)null))
			{
				Vector3 val = targetSideguns[i].position - sideguns[i].position;
				_ = ((Vector3)(ref val)).normalized;
				CalculateYawPitchOffset(sideguns[i], sideguns[i].position, targetSideguns[i].position, out var yaw, out var pitch);
				yaw = NormalizeYaw(yaw);
				float num = Time.deltaTime * sidegunsTurnSpeed;
				if (yaw < -0.5f)
				{
					vecSideGunRotation[i].y -= num;
				}
				else if (yaw > 0.5f)
				{
					vecSideGunRotation[i].y += num;
				}
				if (pitch < -0.5f)
				{
					vecSideGunRotation[i].x -= num;
				}
				else if (pitch > 0.5f)
				{
					vecSideGunRotation[i].x += num;
				}
				vecSideGunRotation[i].x = Mathf.Clamp(vecSideGunRotation[i].x, -45f, 45f);
				vecSideGunRotation[i].y = Mathf.Clamp(vecSideGunRotation[i].y, -45f, 45f);
				sideguns[i].localEulerAngles = vecSideGunRotation[i];
			}
		}
	}

	public void CalculateYawPitchOffset(Transform objectTransform, Vector3 vecStart, Vector3 vecEnd, out float yaw, out float pitch)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = objectTransform.InverseTransformDirection(vecEnd - vecStart);
		float num = Mathf.Sqrt(val.x * val.x + val.z * val.z);
		pitch = (0f - Mathf.Atan2(val.y, num)) * (180f / MathF.PI);
		Vector3 val2 = vecEnd - vecStart;
		val = ((Vector3)(ref val2)).normalized;
		Vector3 forward = objectTransform.forward;
		forward.y = 0f;
		((Vector3)(ref forward)).Normalize();
		float num2 = Vector3.Dot(val, forward);
		float num3 = Vector3.Dot(val, objectTransform.right);
		float num4 = 360f * num3;
		float num5 = 360f * (0f - num2);
		yaw = (Mathf.Atan2(num4, num5) + MathF.PI) * (180f / MathF.PI);
	}

	public float NormalizeYaw(float flYaw)
	{
		if (flYaw > 180f)
		{
			return 360f - flYaw;
		}
		return flYaw * -1f;
	}
}


using UnityEngine;

public class M2BradleyPhysics : MonoBehaviour
{
	private m2bradleyAnimator m2Animator;

	public WheelCollider[] Wheels;

	public WheelCollider[] TurningWheels;

	public Rigidbody mainRigidbody;

	public Transform[] waypoints;

	private Vector3 currentWaypoint;

	private Vector3 nextWaypoint;
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class MapMarker : BaseEntity
{
	public enum ClusterType
	{
		None,
		Vending
	}

	public AppMarkerType appType;

	public GameObjectRef markerObj;

	public static readonly List<MapMarker> serverMapMarkers = new List<MapMarker>();

	public override void InitShared()
	{
		if (base.isServer && !serverMapMarkers.Contains(this))
		{
			serverMapMarkers.Add(this);
		}
		base.InitShared();
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			serverMapMarkers.Remove(this);
		}
		base.DestroyShared();
	}

	public virtual AppMarker GetAppMarkerData()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		AppMarker obj = Pool.Get<AppMarker>();
		Vector2 val = CompanionServer.Util.WorldToMap(((Component)this).transform.position);
		obj.id = net.ID;
		obj.type = appType;
		obj.x = val.x;
		obj.y = val.y;
		return obj;
	}
}


public enum ClusterType
{
	None,
	Vending
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public class MapMarkerMissionProvider : MapMarker
{
	private List<BaseMission> missionsProvided = new List<BaseMission>();

	private string providerToken = string.Empty;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.missionMapMarker == null)
		{
			return;
		}
		if (info.msg.missionMapMarker.missionIds != null)
		{
			missionsProvided.Clear();
			foreach (uint missionId in info.msg.missionMapMarker.missionIds)
			{
				BaseMission fromID = MissionManifest.GetFromID(missionId);
				if (fromID != null)
				{
					missionsProvided.Add(fromID);
				}
			}
		}
		providerToken = info.msg.missionMapMarker.providerToken;
	}

	public void AssignMissions(List<BaseMission> missions, string token)
	{
		missionsProvided.Clear();
		foreach (BaseMission mission in missions)
		{
			missionsProvided.Add(mission);
		}
		providerToken = token;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.missionMapMarker = Pool.Get<MissionMapMarker>();
		info.msg.missionMapMarker.missionIds = Pool.Get<List<uint>>();
		foreach (BaseMission item in missionsProvided)
		{
			info.msg.missionMapMarker.missionIds.Add(item.id);
		}
		info.msg.missionMapMarker.providerToken = providerToken;
	}
}


using UnityEngine;

public class PaintableItem : MonoBehaviour
{
	public MeshPaintableSource PaintableSource;
}


using UnityEngine;

public class AIHelicopterAnimation : MonoBehaviour
{
	public PatrolHelicopterAI _ai;

	public float swayAmount = 1f;

	public float impactSwayAmount = 1f;

	public float lastStrafeScalar;

	public float lastForwardBackScalar;

	public float degreeMax = 90f;

	public Vector3 lastPosition = Vector3.zero;

	public float oldMoveSpeed;

	public float smoothRateOfChange;

	public float flareAmount;

	public float swaySmoothingFactor = 0.1f;

	private float smoothedTime;

	private void Awake()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		lastPosition = ((Component)this).transform.position;
	}

	public void UpdateAnimation()
	{
		UpdateForwardBackTilting();
		UpdateStrafeTilting();
		ModifyHelicopterAngles();
		smoothedTime = Mathf.Lerp(smoothedTime, Time.time, swaySmoothingFactor * Time.deltaTime);
	}

	public void UpdateLastPosition()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		lastPosition = ((Component)this).transform.position;
	}

	private void UpdateForwardBackTilting()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Vector3 currentMoveDirection = GetCurrentMoveDirection();
		float num = Vector3.Angle(currentMoveDirection, ((Component)this).transform.forward);
		float num2 = Vector3.Angle(currentMoveDirection, -((Component)this).transform.forward);
		float num3 = 1f - Mathf.Clamp01(num / degreeMax);
		float num4 = 1f - Mathf.Clamp01(num2 / degreeMax);
		float num5 = num3 - num4;
		lastForwardBackScalar = Mathf.Lerp(lastForwardBackScalar, num5, Time.deltaTime * 2f);
	}

	private void UpdateStrafeTilting()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Vector3 currentMoveDirection = GetCurrentMoveDirection();
		float num = Vector3.Angle(currentMoveDirection, ((Component)this).transform.right);
		float num2 = Vector3.Angle(currentMoveDirection, -((Component)this).transform.right);
		float num3 = 1f - Mathf.Clamp01(num / degreeMax);
		float num4 = 1f - Mathf.Clamp01(num2 / degreeMax);
		float num5 = num3 - num4;
		lastStrafeScalar = Mathf.Lerp(lastStrafeScalar, num5, Time.deltaTime * 2f);
	}

	private void ModifyHelicopterAngles()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		zero.x += lastForwardBackScalar * impactSwayAmount;
		zero.z -= lastStrafeScalar * impactSwayAmount;
		zero.x += Mathf.Sin(smoothedTime) * swayAmount;
		zero.z -= Mathf.Cos(smoothedTime) * swayAmount / 2f;
		Quaternion localRotation = Quaternion.Euler(zero.x, zero.y, zero.z);
		_ai.helicopterBase.rotorPivot.transform.localRotation = localRotation;
	}

	private Vector3 GetCurrentMoveDirection()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - lastPosition;
		return ((Vector3)(ref val)).normalized;
	}
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class HelicopterDebris : ServerGib
{
	public ItemDefinition metalFragments;

	public ItemDefinition hqMetal;

	public ItemDefinition charcoal;

	[Tooltip("Divide mass by this amount to produce a scalar of resources, default = 5")]
	public float massReductionScalar = 5f;

	private ResourceDispenser resourceDispenser;

	public float tooHotUntil;

	public override void ServerInit()
	{
		base.ServerInit();
		tooHotUntil = Time.realtimeSinceStartup + 480f;
	}

	public override void PhysicsInit(Mesh mesh)
	{
		base.PhysicsInit(mesh);
		if (!base.isServer)
		{
			return;
		}
		resourceDispenser = ((Component)this).GetComponent<ResourceDispenser>();
		float num = Mathf.Clamp01(((Component)this).GetComponent<Rigidbody>().mass / massReductionScalar);
		resourceDispenser.containedItems = new List<ItemAmount>();
		if (num > 0.75f && (Object)(object)hqMetal != (Object)null)
		{
			resourceDispenser.containedItems.Add(new ItemAmount(hqMetal, Mathf.CeilToInt(7f * num)));
		}
		if (num > 0f)
		{
			if ((Object)(object)metalFragments != (Object)null)
			{
				resourceDispenser.containedItems.Add(new ItemAmount(metalFragments, Mathf.CeilToInt(150f * num)));
			}
			if ((Object)(object)charcoal != (Object)null)
			{
				resourceDispenser.containedItems.Add(new ItemAmount(charcoal, Mathf.CeilToInt(80f * num)));
			}
		}
		resourceDispenser.Initialize();
	}

	public bool IsTooHot()
	{
		return tooHotUntil > Time.realtimeSinceStartup;
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (IsTooHot() && info.WeaponPrefab is BaseMelee)
		{
			if (info.Initiator is BasePlayer)
			{
				HitInfo hitInfo = new HitInfo();
				hitInfo.damageTypes.Add(DamageType.Heat, 5f);
				hitInfo.DoHitEffects = true;
				hitInfo.DidHit = true;
				hitInfo.HitBone = 0u;
				hitInfo.Initiator = this;
				hitInfo.PointStart = ((Component)this).transform.position;
				Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", info.Initiator, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)resourceDispenser))
			{
				resourceDispenser.OnAttacked(info);
			}
			base.OnAttacked(info);
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using UnityEngine;

public class HelicopterTurret : MonoBehaviour
{
	public PatrolHelicopterAI _heliAI;

	public float fireRate = 0.125f;

	public float burstLength = 3f;

	public float timeBetweenBursts = 3f;

	public float maxTargetRange = 300f;

	public float loseTargetAfter = 5f;

	public Transform gun_yaw;

	public Transform gun_pitch;

	public Transform muzzleTransform;

	public bool left;

	public BaseCombatEntity _target;

	private float lastBurstTime = float.NegativeInfinity;

	private float lastFireTime = float.NegativeInfinity;

	private float lastSeenTargetTime = float.NegativeInfinity;

	private bool targetVisible;

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", (object)this, (object)newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

	public bool NeedsNewTarget()
	{
		if (HasTarget())
		{
			if (!targetVisible)
			{
				return TimeSinceTargetLastSeen() > loseTargetAfter;
			}
			return false;
		}
		return true;
	}

	public bool UpdateTargetFromList(List<PatrolHelicopterAI.targetinfo> newTargetList)
	{
		int num = Random.Range(0, newTargetList.Count);
		int num2 = newTargetList.Count;
		while (num2 >= 0)
		{
			num2--;
			PatrolHelicopterAI.targetinfo targetinfo = newTargetList[num];
			if (targetinfo != null && (Object)(object)targetinfo.ent != (Object)null && targetinfo.IsVisible() && InFiringArc(targetinfo.ply))
			{
				SetTarget(targetinfo.ply);
				return true;
			}
			num++;
			if (num >= newTargetList.Count)
			{
				num = 0;
			}
		}
		return false;
	}

	public bool TargetVisible()
	{
		UpdateTargetVisibility();
		return targetVisible;
	}

	public float TimeSinceTargetLastSeen()
	{
		return Time.realtimeSinceStartup - lastSeenTargetTime;
	}

	public bool HasTarget()
	{
		return (Object)(object)_target != (Object)null;
	}

	public void ClearTarget()
	{
		_target = null;
		targetVisible = false;
	}

	public void TurretThink()
	{
		if (HasTarget() && TimeSinceTargetLastSeen() > loseTargetAfter * 2f)
		{
			ClearTarget();
		}
		if (HasTarget())
		{
			if (Time.time - lastBurstTime > burstLength + timeBetweenBursts && TargetVisible())
			{
				lastBurstTime = Time.time;
			}
			if (Time.time < lastBurstTime + burstLength && Time.time - lastFireTime >= fireRate && InFiringArc(_target))
			{
				lastFireTime = Time.time;
				FireGun();
			}
		}
	}

	public void FireGun()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		_heliAI.FireGun(((Component)_target).transform.position + new Vector3(0f, 0.25f, 0f), ConVar.PatrolHelicopter.bulletAccuracy, left);
	}

	public Vector3 GetPositionForEntity(BaseCombatEntity potentialtarget)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)potentialtarget).transform.position;
	}

	public float AngleToTarget(BaseCombatEntity potentialtarget)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		Vector3 positionForEntity = GetPositionForEntity(potentialtarget);
		Vector3 position = muzzleTransform.position;
		Vector3 val = positionForEntity - position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return Vector3.Angle(left ? (-((Component)_heliAI).transform.right) : ((Component)_heliAI).transform.right, normalized);
	}

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", (object)potentialtarget, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

	public void UpdateTargetVisibility()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (HasTarget())
		{
			Vector3 position = ((Component)_target).transform.position;
			BasePlayer basePlayer = _target as BasePlayer;
			if (Object.op_Implicit((Object)(object)basePlayer))
			{
				position = basePlayer.eyes.position;
			}
			bool flag = false;
			float num = Vector3.Distance(position, muzzleTransform.position);
			Vector3 val = position - muzzleTransform.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			if (num < maxTargetRange && InFiringArc(_target) && GamePhysics.Trace(new Ray(muzzleTransform.position + normalized * 6f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417, (QueryTriggerInteraction)0) && (Object)(object)((Component)((RaycastHit)(ref hitInfo)).collider).gameObject.ToBaseEntity() == (Object)(object)_target)
			{
				flag = true;
			}
			if (flag)
			{
				lastSeenTargetTime = Time.realtimeSinceStartup;
			}
			targetVisible = flag;
		}
	}
}


using System;
using UnityEngine;

public class LockedByEntCrate : LootContainer
{
	public GameObject lockingEnt;

	public void SetLockingEnt(GameObject ent)
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Think);
		SetLocked(isLocked: false);
		lockingEnt = ent;
		if ((Object)(object)lockingEnt != (Object)null)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)Think, Random.Range(0f, 1f), 1f);
			SetLocked(isLocked: true);
		}
	}

	public void SetLocked(bool isLocked)
	{
		SetFlag(Flags.OnFire, isLocked);
		SetFlag(Flags.Locked, isLocked);
	}

	public void Think()
	{
		if ((Object)(object)lockingEnt == (Object)null && IsLocked())
		{
			SetLockingEnt(null);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Oxide.Core;
using Rust;
using Rust.Ai;
using UnityEngine;

public class PatrolHelicopterAI : BaseMonoBehaviour
{
	public class targetinfo
	{
		public BasePlayer ply;

		public BaseEntity ent;

		public float lastSeenTime = float.PositiveInfinity;

		public float visibleFor;

		public float nextLOSCheck;

		public targetinfo(BaseEntity initEnt, BasePlayer initPly = null)
		{
			ply = initPly;
			ent = initEnt;
			lastSeenTime = float.PositiveInfinity;
			nextLOSCheck = Time.realtimeSinceStartup + 1.5f;
		}

		public bool IsVisible()
		{
			return TimeSinceSeen() < 1.5f;
		}

		public float TimeSinceSeen()
		{
			return Time.realtimeSinceStartup - lastSeenTime;
		}
	}

	public class DangerZone
	{
		public float Radius;

		public bool IsInMonument;

		private float score;

		private float lastActiveTime = Time.realtimeSinceStartup;

		private const float isStaleTime = 5f;

		private Vector3 centre;

		private BaseEntity parent;

		public Vector3 Centre
		{
			get
			{
				//IL_0021: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				if ((Object)(object)parent == (Object)null)
				{
					return centre;
				}
				return ((Component)parent).transform.TransformPoint(centre);
			}
		}

		public float Score
		{
			get
			{
				return score;
			}
			set
			{
				score = value;
				lastActiveTime = Time.realtimeSinceStartup;
			}
		}

		public float LastActiveTime => lastActiveTime;

		public DangerZone(Vector3 centre, float radius = 20f, BaseEntity parent = null)
		{
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)parent == (Object)null)
			{
				this.centre = centre;
			}
			else
			{
				this.centre = ((Component)parent).transform.InverseTransformPoint(centre);
			}
			this.parent = parent;
			Radius = radius;
			IsInMonument = IsInsideMonument(this.centre);
		}

		public bool IsPointInside(Vector3 point)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			return Vector3.Distance(point, Centre) <= Radius;
		}

		public bool IsStale()
		{
			return Time.realtimeSinceStartup - lastActiveTime > 5f;
		}

		public Vector3 GetNearestEdge(Vector3 point)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = point - Centre;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			normalized.y = 0f;
			return Centre + normalized * Radius;
		}
	}

	public enum aiState
	{
		IDLE,
		MOVE,
		ORBIT,
		STRAFE,
		PATROL,
		ORBITSTRAFE,
		GUARD,
		FLEE,
		DEATH
	}

	public Vector3 interestZoneOrigin;

	public Vector3 destination;

	public bool hasInterestZone;

	public float moveSpeed;

	public float maxSpeed = 25f;

	public float courseAdjustLerpTime = 2f;

	public Quaternion targetRotation;

	public Vector3 windVec;

	public Vector3 targetWindVec;

	public float windForce = 5f;

	public float windFrequency = 1f;

	public float targetThrottleSpeed;

	public float throttleSpeed;

	public float maxRotationSpeed = 90f;

	public float rotationSpeed;

	public float terrainPushForce = 100f;

	public float obstaclePushForce = 100f;

	public HelicopterTurret leftGun;

	public HelicopterTurret rightGun;

	public static PatrolHelicopterAI heliInstance;

	public PatrolHelicopter helicopterBase;

	public aiState _currentState;

	public float oceanDepthTargetCutoff = 3f;

	public AIHelicopterAnimation anim;

	private Vector3 _aimTarget;

	private bool movementLockingAiming;

	private bool hasAimTarget;

	private bool aimDoorSide;

	private Vector3 pushVec = Vector3.zero;

	private Vector3 _lastPos;

	private Vector3 _lastMoveDir;

	public bool isDead;

	public bool isRetiring;

	public float spawnTime;

	public float lastDamageTime;

	private bool forceTerrainPushback;

	private bool restrictedPatrolSize;

	private TimeSince timeSinceRestrictedPatrolSize;

	[ServerVar]
	public static float flee_damage_percentage = 0.35f;

	[ServerVar]
	public static bool use_danger_zones = true;

	[ServerVar]
	public static bool monument_crash = true;

	private bool shouldDebug;

	public List<targetinfo> _targetList = new List<targetinfo>();

	private HashSet<BasePlayer> _targetSet = new HashSet<BasePlayer>();

	public List<DangerZone> dangerZones = new List<DangerZone>();

	public List<DangerZone> noGoZones = new List<DangerZone>();

	private const int max_zones = 20;

	private const float no_go_zone_size = 250f;

	private const float danger_zone_size = 20f;

	private DangerZone leastActiveZone;

	private float deathTimeout;

	private bool didImpact;

	private Collider[] collisions;

	private bool reachedSpinoutLocation;

	private const float FleeDistance = 130f;

	private float destination_min_dist = 2f;

	private float currentOrbitDistance;

	private float currentOrbitTime;

	private bool hasEnteredOrbit;

	private float orbitStartTime;

	public float maxOrbitDuration = 30f;

	private bool breakingOrbit;

	private int orbitPointsReached;

	private float timeBetweenRocketsOrbit = 0.5f;

	private bool didGetToDesination;

	public List<MonumentInfo> _visitedMonuments;

	public float arrivalTime;

	public GameObjectRef rocketProjectile;

	public GameObjectRef rocketProjectile_Napalm;

	public bool leftTubeFiredLast;

	public float lastRocketTime;

	public float timeBetweenRockets = 0.2f;

	public int numRocketsLeft = 12;

	public const int maxRockets = 12;

	public Vector3 strafe_target_position;

	[NonSerialized]
	public BasePlayer strafe_target;

	public bool puttingDistance;

	public const float strafe_approach_range = 175f;

	public const float strafe_firing_range = 150f;

	private float get_out_of_strafe_distance = 15f;

	private bool passNapalm;

	private Vector3 cached_strafe_pos;

	private TimeSince timeSinceRefreshed;

	private bool useNapalm;

	[NonSerialized]
	public float lastNapalmTime = float.NegativeInfinity;

	[NonSerialized]
	public float lastStrafeTime = float.NegativeInfinity;

	private float _lastThinkTime;

	public bool IsDead => isDead;

	[ServerVar]
	private void dumpstate()
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("[State] " + _currentState);
		stringBuilder.AppendLine($"[Has Interest Zone] {hasInterestZone}");
		stringBuilder.AppendLine($"[Interest Zone] {interestZoneOrigin}");
		stringBuilder.AppendLine($"[Target Count] {_targetList.Count}");
		stringBuilder.AppendLine($"[Retiring] {isRetiring}");
		stringBuilder.AppendLine($"[Has Entered Orbit] {hasEnteredOrbit}");
		stringBuilder.AppendLine($"[Breaking Orbit] {breakingOrbit}");
		stringBuilder.AppendLine($"[Orbit Distance] {currentOrbitDistance}");
		Debug.Log((object)stringBuilder.ToString());
	}

	public void Awake()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.PatrolHelicopter.lifetimeMinutes == 0f)
		{
			((FacepunchBehaviour)this).Invoke((Action)DestroyMe, 1f);
			return;
		}
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateWind, 0f, 1f / windFrequency);
		_lastPos = ((Component)this).transform.position;
		spawnTime = Time.realtimeSinceStartup;
		InitializeAI();
	}

	public void SetInitialDestination(Vector3 dest, float mapScaleDistance = 0.25f)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		hasInterestZone = true;
		interestZoneOrigin = dest;
		float x = TerrainMeta.Size.x;
		float y = dest.y + 45f;
		Vector3 val = Vector3Ex.Range(-1f, 1f);
		val.y = 0f;
		((Vector3)(ref val)).Normalize();
		val *= x * mapScaleDistance;
		val.y = y;
		if (mapScaleDistance == 0f)
		{
			val = interestZoneOrigin + new Vector3(0f, 10f, 0f);
		}
		((Component)this).transform.position = val;
		ExitCurrentState();
		dest.y = y;
		State_Move_Enter(dest);
	}

	public void Retire()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (!isRetiring && Interface.CallHook("OnHelicopterRetire", (object)this) == null)
		{
			((FacepunchBehaviour)this).Invoke((Action)DestroyMe, 240f);
			float x = TerrainMeta.Size.x;
			float y = 200f;
			Vector3 val = Vector3Ex.Range(-1f, 1f);
			val.y = 0f;
			((Vector3)(ref val)).Normalize();
			val *= x * 20f;
			val.y = y;
			ExitCurrentState();
			isRetiring = true;
			State_Move_Enter(val);
		}
	}

	public void SetIdealRotation(Quaternion newTargetRot, float rotationSpeedOverride = -1f)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		float num = ((rotationSpeedOverride == -1f) ? Mathf.Clamp01(moveSpeed / (maxSpeed * 0.5f)) : rotationSpeedOverride);
		rotationSpeed = num * maxRotationSpeed;
		targetRotation = newTargetRot;
	}

	public Quaternion GetYawRotationTo(Vector3 targetDest)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = targetDest;
		val.y = 0f;
		Vector3 position = ((Component)this).transform.position;
		position.y = 0f;
		Vector3 val2 = val - position;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		if (!(normalized != Vector3.zero))
		{
			return Quaternion.identity;
		}
		return Quaternion.LookRotation(normalized);
	}

	public void SetTargetDestination(Vector3 targetDest, float minDist = 5f, float minDistForFacingRotation = 30f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		destination = targetDest;
		destination_min_dist = minDist;
		float num = Vector3.Distance(targetDest, ((Component)this).transform.position);
		if (num > minDistForFacingRotation && !IsTargeting())
		{
			SetIdealRotation(GetYawRotationTo(destination));
		}
		targetThrottleSpeed = GetThrottleForDistance(num);
	}

	public bool AtDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(((Component)this).transform.position, destination) < destination_min_dist;
	}

	public bool AtRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Angle(((Component)this).transform.rotation, targetRotation) <= 8f;
	}

	private void NoGoZoneAdded(DangerZone zone)
	{
		if (use_danger_zones && Interface.CallHook("OnNoGoZoneAdded", (object)this, (object)zone) == null && !zone.IsInMonument)
		{
			ClearTargets();
			ExitCurrentState();
			State_Flee_Enter();
		}
	}

	public float GetRandomYHeight()
	{
		return Random.Range(35f, 45f);
	}

	public void MoveToDestination()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lastMoveDir = _lastMoveDir;
		Vector3 val = destination - ((Component)this).transform.position;
		Vector3 val2 = (_lastMoveDir = Vector3.Lerp(lastMoveDir, ((Vector3)(ref val)).normalized, Time.deltaTime / courseAdjustLerpTime));
		throttleSpeed = Mathf.Lerp(throttleSpeed, targetThrottleSpeed, Time.deltaTime / 3f);
		float num = throttleSpeed * maxSpeed;
		TerrainPushback();
		Vector3 val3 = windVec * windForce * Time.deltaTime;
		Vector3 val4 = val2 * num * Time.deltaTime;
		Transform transform = ((Component)this).transform;
		transform.position += val4 + val3;
		moveSpeed = Mathf.Lerp(moveSpeed, Vector3.Distance(_lastPos, ((Component)this).transform.position) / Time.deltaTime, Time.deltaTime * 2f);
		_lastPos = ((Component)this).transform.position;
	}

	public void TerrainPushback()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		if (_currentState != aiState.DEATH || forceTerrainPushback)
		{
			int mask = LayerMask.GetMask(new string[3] { "Terrain", "World", "Construction" });
			Vector3 val = ((Component)this).transform.position + new Vector3(0f, 2f, 0f);
			Vector3 val2 = destination - val;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			float num = Vector3.Distance(destination, ((Component)this).transform.position);
			Ray val3 = new Ray(val, normalized);
			float num2 = 5f;
			float num3 = Mathf.Min(100f, num);
			Vector3 val4 = Vector3.zero;
			RaycastHit val5 = default(RaycastHit);
			if (Physics.SphereCast(val3, num2, ref val5, num3 - num2 * 0.5f, mask))
			{
				float num4 = 1f - ((RaycastHit)(ref val5)).distance / num3;
				float num5 = terrainPushForce * num4;
				val4 = Vector3.up * num5;
			}
			Ray val6 = new Ray(val, _lastMoveDir);
			float num6 = Mathf.Min(10f, num);
			RaycastHit val7 = default(RaycastHit);
			if (Physics.SphereCast(val6, num2, ref val7, num6 - num2 * 0.5f, mask))
			{
				float num7 = 1f - ((RaycastHit)(ref val7)).distance / num6;
				float num8 = obstaclePushForce * num7;
				val4 += _lastMoveDir * num8 * -1f;
				val4 += Vector3.up * num8;
			}
			int mask2 = LayerMask.GetMask(new string[1] { "Water" });
			Ray ray = new Ray(val, Vector3.down);
			float num9 = 10f;
			if (GamePhysics.Trace(ray, num2, out var hitInfo, num9 - num2 * 0.5f, mask2, (QueryTriggerInteraction)0))
			{
				float num10 = 1f - ((RaycastHit)(ref hitInfo)).distance / num9;
				float num11 = obstaclePushForce * num10;
				val4 += Vector3.up * num11;
			}
			pushVec = Vector3.Lerp(pushVec, val4, Time.deltaTime);
			Transform transform = ((Component)this).transform;
			transform.position += pushVec * Time.deltaTime;
		}
	}

	public void UpdateRotation()
	{
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (hasAimTarget)
		{
			Vector3 position = ((Component)this).transform.position;
			position.y = 0f;
			Vector3 aimTarget = _aimTarget;
			aimTarget.y = 0f;
			Vector3 val = aimTarget - position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			Vector3 val2 = Vector3.Cross(normalized, Vector3.up);
			float num = Vector3.Angle(normalized, ((Component)this).transform.right);
			float num2 = Vector3.Angle(normalized, -((Component)this).transform.right);
			if (aimDoorSide)
			{
				if (num < num2)
				{
					targetRotation = Quaternion.LookRotation(val2);
				}
				else
				{
					targetRotation = Quaternion.LookRotation(-val2);
				}
			}
			else
			{
				targetRotation = Quaternion.LookRotation(normalized);
			}
		}
		rotationSpeed = Mathf.Lerp(rotationSpeed, maxRotationSpeed, Time.deltaTime / 2f);
		((Component)this).transform.rotation = Quaternion.Lerp(((Component)this).transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);
	}

	public void UpdateSpotlight()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (hasInterestZone)
		{
			helicopterBase.spotlightTarget = new Vector3(interestZoneOrigin.x, TerrainMeta.HeightMap.GetHeight(interestZoneOrigin), interestZoneOrigin.z);
		}
		else
		{
			helicopterBase.spotlightTarget = Vector3.zero;
		}
	}

	public void Update()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		if (helicopterBase.isClient)
		{
			return;
		}
		heliInstance = this;
		UpdateTargetList();
		MoveToDestination();
		UpdateRotation();
		UpdateSpotlight();
		anim.UpdateAnimation();
		anim.UpdateLastPosition();
		AIThink();
		DoMachineGuns();
		if (TimeSince.op_Implicit(timeSinceRestrictedPatrolSize) > 240f && restrictedPatrolSize)
		{
			restrictedPatrolSize = false;
			timeSinceRestrictedPatrolSize = TimeSince.op_Implicit(0f);
		}
		if (!isRetiring && !isDead)
		{
			float num = Mathf.Max(spawnTime + ConVar.PatrolHelicopter.lifetimeMinutes * 60f, lastDamageTime + 180f);
			if (Time.realtimeSinceStartup > num)
			{
				Retire();
			}
		}
	}

	public void FixedUpdate()
	{
		if (_currentState == aiState.DEATH)
		{
			PhysicsDeathCheck();
		}
	}

	public void OtherDamaged(HitInfo info)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = info.Initiator as BasePlayer;
		if (!((Object)(object)basePlayer == (Object)null) && use_danger_zones)
		{
			UpdateDangerZones(((Component)basePlayer).transform.position, info.damageTypes.Total(), basePlayer);
		}
	}

	public void WeakspotDamaged(PatrolHelicopter.weakspot weak, HitInfo info)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = info.Initiator as BasePlayer;
		if (!((Object)(object)basePlayer == (Object)null))
		{
			if (use_danger_zones)
			{
				UpdateDangerZones(((Component)basePlayer).transform.position, info.damageTypes.Total(), basePlayer, weak);
			}
			else
			{
				TryStrafePlayer(info, 5f);
			}
		}
	}

	public void TryStrafePlayer(HitInfo info, float timeSinceDamagedThreshold)
	{
		if (!isRetiring && IsAlive() && _currentState != aiState.FLEE)
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			bool num = ValidRocketTarget(basePlayer);
			bool flag = num && CanStrafe();
			bool flag2 = !num && CanUseNapalm();
			float num2 = Time.realtimeSinceStartup - lastDamageTime;
			lastDamageTime = Time.realtimeSinceStartup;
			if (num2 < timeSinceDamagedThreshold && (Object)(object)basePlayer != (Object)null && (flag || flag2))
			{
				ExitCurrentState();
				State_Strafe_Enter(basePlayer, flag2);
			}
		}
	}

	public void CriticalDamage()
	{
		isDead = true;
		ExitCurrentState();
		State_Death_Enter();
	}

	public void DoMachineGuns()
	{
		if (_targetList.Count > 0)
		{
			if (leftGun.NeedsNewTarget())
			{
				leftGun.UpdateTargetFromList(_targetList);
			}
			if (rightGun.NeedsNewTarget())
			{
				rightGun.UpdateTargetFromList(_targetList);
			}
		}
		leftGun.TurretThink();
		rightGun.TurretThink();
	}

	public void FireGun(Vector3 targetPos, float aimCone, bool left)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.PatrolHelicopter.guns == 0)
		{
			return;
		}
		Vector3 position = (left ? helicopterBase.left_gun_muzzle.transform : helicopterBase.right_gun_muzzle.transform).position;
		Vector3 val = targetPos - position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		position += normalized * 2f;
		Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, normalized);
		if (GamePhysics.Trace(new Ray(position, modifiedAimConeDirection), 0f, out var hitInfo, 300f, 1220225809, (QueryTriggerInteraction)0))
		{
			targetPos = ((RaycastHit)(ref hitInfo)).point;
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref hitInfo)).collider))
			{
				BaseEntity entity = hitInfo.GetEntity();
				if (Object.op_Implicit((Object)(object)entity) && (Object)(object)entity != (Object)(object)helicopterBase)
				{
					BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
					HitInfo info = new HitInfo(helicopterBase, entity, DamageType.Bullet, helicopterBase.bulletDamage * ConVar.PatrolHelicopter.bulletDamageScale, ((RaycastHit)(ref hitInfo)).point);
					if (Object.op_Implicit((Object)(object)baseCombatEntity))
					{
						baseCombatEntity.OnAttacked(info);
						if (baseCombatEntity is BasePlayer)
						{
							Effect.server.ImpactEffect(new HitInfo
							{
								HitPositionWorld = ((RaycastHit)(ref hitInfo)).point - modifiedAimConeDirection * 0.25f,
								HitNormalWorld = -modifiedAimConeDirection,
								HitMaterial = StringPool.Get("Flesh")
							});
						}
					}
					else
					{
						entity.OnAttacked(info);
					}
				}
			}
		}
		else
		{
			targetPos = position + modifiedAimConeDirection * 300f;
		}
		helicopterBase.ClientRPC(RpcTarget.NetworkGroup("FireGun"), left, targetPos);
	}

	public bool CanInterruptState()
	{
		aiState currentState = _currentState;
		return currentState == aiState.IDLE || currentState == aiState.MOVE || currentState == aiState.PATROL;
	}

	public bool IsAlive()
	{
		if (!isDead)
		{
			return _currentState != aiState.DEATH;
		}
		return false;
	}

	public void DestroyMe()
	{
		if (dangerZones != null)
		{
			helicopterBase.Kill();
		}
	}

	public Vector3 GetLastMoveDir()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _lastMoveDir;
	}

	public Vector3 GetMoveDirection()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = destination - ((Component)this).transform.position;
		return ((Vector3)(ref val)).normalized;
	}

	public float GetMoveSpeed()
	{
		return moveSpeed;
	}

	public float GetMaxRotationSpeed()
	{
		return maxRotationSpeed;
	}

	public bool IsTargeting()
	{
		return hasAimTarget;
	}

	public void UpdateWind()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		targetWindVec = Random.onUnitSphere;
	}

	public void SetAimTarget(Vector3 aimTarg, bool isDoorSide)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (!movementLockingAiming)
		{
			hasAimTarget = true;
			_aimTarget = aimTarg;
			aimDoorSide = isDoorSide;
		}
	}

	public void ClearAimTarget()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		hasAimTarget = false;
		_aimTarget = Vector3.zero;
	}

	public void UpdateTargetList()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer strafeTarget = null;
		bool flag = false;
		bool shouldUseNapalm = false;
		float num = 0f;
		targetinfo targetinfo = null;
		for (int num2 = _targetList.Count - 1; num2 >= 0; num2--)
		{
			targetinfo targetinfo2 = _targetList[num2];
			if (targetinfo2 == null || !targetinfo2.ent.IsValid())
			{
				RemoveTargetAt(num2);
			}
			else if (use_danger_zones && IsInNoGoZone(((Component)targetinfo2.ply).transform.position))
			{
				RemoveTargetAt(num2);
			}
			else if (AI.ignoreplayers || SimpleAIMemory.PlayerIgnoreList.Contains(targetinfo2.ply))
			{
				RemoveTargetAt(num2);
			}
			else
			{
				UpdateTargetLineOfSightTime(targetinfo2);
				bool flag2 = (Object.op_Implicit((Object)(object)targetinfo2.ply) ? targetinfo2.ply.IsDead() : (targetinfo2.ent.Health() <= 0f));
				if (targetinfo2.TimeSinceSeen() >= 6f || flag2)
				{
					bool flag3 = Random.Range(0f, 1f) >= 0f;
					if ((CanStrafe() || CanUseNapalm()) && IsAlive() && !flag && !flag2 && ((Object)(object)targetinfo2.ply == (Object)(object)leftGun._target || (Object)(object)targetinfo2.ply == (Object)(object)rightGun._target) && flag3)
					{
						shouldUseNapalm = !ValidRocketTarget(targetinfo2.ply) || Random.Range(0f, 1f) > 0.75f;
						flag = true;
						strafeTarget = targetinfo2.ply;
					}
					RemoveTargetAt(num2);
					if ((Object)(object)leftGun._target == (Object)(object)targetinfo2.ply)
					{
						leftGun._target = null;
					}
					if ((Object)(object)rightGun._target == (Object)(object)targetinfo2.ply)
					{
						rightGun._target = null;
					}
				}
				if (use_danger_zones && !flag && (CanStrafe() || CanUseNapalm()) && IsAlive() && (Time.realtimeSinceStartup - lastNapalmTime > 20f || Time.realtimeSinceStartup - lastStrafeTime > 15f) && IsInDangerZone(((Component)targetinfo2.ply).transform.position, out var dangerZone) && dangerZone != null && dangerZone.Score > num)
				{
					num = dangerZone.Score;
					targetinfo = targetinfo2;
				}
			}
		}
		if (use_danger_zones && !flag && targetinfo != null)
		{
			shouldUseNapalm = !ValidRocketTarget(targetinfo.ply) || Random.Range(0f, 1f) > 0.75f;
			flag = true;
			strafeTarget = targetinfo.ply;
			targetinfo = null;
		}
		AddNewTargetsToList();
		if (flag && !isRetiring && !isDead)
		{
			ExitCurrentState();
			State_Strafe_Enter(strafeTarget, shouldUseNapalm);
		}
	}

	private void UpdateTargetLineOfSightTime(targetinfo targ)
	{
		if (Time.realtimeSinceStartup > targ.nextLOSCheck)
		{
			targ.nextLOSCheck = Time.realtimeSinceStartup + 1f;
			if (PlayerVisible(targ.ply))
			{
				targ.lastSeenTime = Time.realtimeSinceStartup;
				targ.visibleFor += 1f;
			}
			else
			{
				targ.visibleFor = 0f;
			}
		}
	}

	private void AddNewTargetsToList()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("PatrolHelicoperAI.AddNewTargetsToList", 0);
		try
		{
			if (AI.ignoreplayers)
			{
				return;
			}
			PooledList<BasePlayer> val2 = Pool.Get<PooledList<BasePlayer>>();
			try
			{
				BaseEntity.Query.Server.GetPlayersInSphere(((Component)this).transform.position, 150f, (List<BasePlayer>)(object)val2, BaseEntity.Query.DistanceCheckType.None);
				foreach (BasePlayer item in (List<BasePlayer>)(object)val2)
				{
					if ((Object)(object)item == (Object)null || SimpleAIMemory.PlayerIgnoreList.Contains(item))
					{
						continue;
					}
					TimeWarning val3 = TimeWarning.New("PatrolHelicoperAI.SafeZone", 0);
					try
					{
						if (item.InSafeZone())
						{
							continue;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					if (item.IsInTutorial)
					{
						continue;
					}
					TimeWarning val4 = TimeWarning.New("PatrolHelicoperAI.NoGoZone", 0);
					try
					{
						if (use_danger_zones && IsInNoGoZone(((Component)item).transform.position))
						{
							continue;
						}
					}
					finally
					{
						((IDisposable)val4)?.Dispose();
					}
					if (!IsAlreadyInTargets(item) && item.GetThreatLevel() > 0.5f && PlayerVisible(item))
					{
						TryAddTarget(item);
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool TryAddTarget(BasePlayer ply)
	{
		if (IsAlreadyInTargets(ply))
		{
			return false;
		}
		_targetList.Add(new targetinfo(ply, ply));
		_targetSet.Add(ply);
		return true;
	}

	private void RemoveTargetAt(int i)
	{
		BasePlayer ply = _targetList[i].ply;
		_targetSet.Remove(ply);
		_targetList.RemoveAt(i);
	}

	private void ClearTargets()
	{
		_targetList.Clear();
		_targetSet.Clear();
	}

	private bool IsAlreadyInTargets(BasePlayer ply)
	{
		return _targetSet.Contains(ply);
	}

	private Vector3? FindTargetWithZones(bool withOffset = true)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		float num2 = 0f;
		for (int i = 0; i < _targetList.Count; i++)
		{
			if (use_danger_zones)
			{
				Vector3 position = ((Component)_targetList[i].ply).transform.position;
				if (!IsInNoGoZone(position) && IsInDangerZone(position, out var dangerZone) && dangerZone != null && dangerZone.Score > num2)
				{
					num2 = dangerZone.Score;
					num = i;
				}
			}
		}
		if (num == -1)
		{
			return null;
		}
		Vector3 val = Vector3.zero;
		if (withOffset)
		{
			val = GetTargetOffset();
		}
		return ((Component)_targetList[num].ply).transform.position + val;
	}

	private Vector3 FindDefaultTarget(bool withOffset = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		if (withOffset)
		{
			val = GetTargetOffset();
		}
		return ((Component)_targetList[0].ply).transform.position + val;
	}

	private Vector3 GetTargetOffset()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(0f, 20f, 0f);
	}

	public bool PlayerVisible(BasePlayer ply)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanHelicopterTarget", (object)this, (object)ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		TimeWarning val = TimeWarning.New("PatrolHelicoperAI.PlayerVisible", 0);
		try
		{
			Vector3 position = ply.eyes.position;
			if (ply.eyes.position.y < WaterSystem.OceanLevel && Mathf.Abs(WaterSystem.OceanLevel - ply.eyes.position.y) > oceanDepthTargetCutoff)
			{
				return false;
			}
			if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
			{
				return false;
			}
			Vector3 val2 = ((Component)this).transform.position - Vector3.up * 6f;
			float num = Vector3.Distance(position, val2);
			Vector3 val3 = position - val2;
			Vector3 normalized = ((Vector3)(ref val3)).normalized;
			if (GamePhysics.Trace(new Ray(val2 + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417, (QueryTriggerInteraction)0) && (Object)(object)((Component)((RaycastHit)(ref hitInfo)).collider).gameObject.ToBaseEntity() == (Object)(object)ply)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void WasAttacked(HitInfo info)
	{
		BasePlayer basePlayer = info.Initiator as BasePlayer;
		if (!(basePlayer is ScientistNPC) && basePlayer.IsValid())
		{
			TryAddTarget(basePlayer);
		}
	}

	public void UpdateDangerZones(Vector3 position, float damage, BasePlayer ply, PatrolHelicopter.weakspot weak = null)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		if (!use_danger_zones)
		{
			return;
		}
		if (IsInNoGoZone(position))
		{
			if (shouldDebug)
			{
				Debug.Log((object)"Inside no go zone - ignoring damage");
			}
			return;
		}
		float num = damage;
		if (weak != null)
		{
			if (shouldDebug)
			{
				Debug.Log((object)("Hit weakspot: " + num));
			}
			num = weak.body.MaxHealth() * weak.healthFractionOnDestroyed * (damage / weak.maxHealth);
			if (shouldDebug)
			{
				Debug.Log((object)("Potential Damage: " + num));
			}
		}
		if (dangerZones.Count == 0)
		{
			MakeZone(position, num, ply.GetParentEntity());
			return;
		}
		DangerZone dangerZone = null;
		bool flag = false;
		for (int num2 = dangerZones.Count - 1; num2 >= 0; num2--)
		{
			dangerZone = dangerZones[num2];
			if (dangerZone.IsStale())
			{
				if (shouldDebug)
				{
					Debug.Log((object)"zone is stale");
				}
				dangerZones.RemoveAt(num2);
			}
			else if (dangerZone.IsPointInside(position))
			{
				if (shouldDebug)
				{
					Debug.Log((object)("zone has " + dangerZone.Score + " score"));
				}
				if (leastActiveZone == null || dangerZone.LastActiveTime < leastActiveZone.LastActiveTime)
				{
					leastActiveZone = dangerZone;
				}
				dangerZone.Score += num;
				flag = true;
				UpdateNoGoZones(dangerZone);
				break;
			}
		}
		if (flag && shouldDebug)
		{
			Debug.Log((object)"We found a zone");
		}
		if (flag)
		{
			return;
		}
		if (shouldDebug)
		{
			Debug.Log((object)"making a new zone ");
		}
		if (dangerZones.Count + 1 > 20)
		{
			if (leastActiveZone != null && dangerZones.Contains(leastActiveZone))
			{
				dangerZones.Remove(leastActiveZone);
			}
			else
			{
				dangerZones.RemoveAt(0);
			}
		}
		MakeZone(position, num, ply.GetParentEntity());
	}

	public void MakeZone(Vector3 position, float damage, BaseEntity parent = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		DangerZone dangerZone = new DangerZone(position, 20f, parent);
		dangerZone.Score += damage;
		dangerZones.Add(dangerZone);
	}

	private void UpdateNoGoZones(DangerZone zone)
	{
		if (!zone.IsInMonument && zone.Score >= helicopterBase.startHealth * flee_damage_percentage)
		{
			dangerZones.Remove(zone);
			zone.Radius = 250f;
			noGoZones.Add(zone);
			NoGoZoneAdded(zone);
		}
	}

	public void ClearStaleZones()
	{
		for (int num = dangerZones.Count - 1; num >= 0; num--)
		{
			if (dangerZones[num].IsStale())
			{
				dangerZones.RemoveAt(num);
			}
		}
	}

	private void RemoveLeastSignificantZone()
	{
		dangerZones.Sort((DangerZone a, DangerZone b) => a.Score.CompareTo(b.Score));
		dangerZones.RemoveAt(0);
	}

	public bool IsInNoGoZone(Vector3 position)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("PatrolHelicoperAI.IsInNoGoZone", 0);
		try
		{
			bool result = false;
			foreach (DangerZone noGoZone in noGoZones)
			{
				if (noGoZone.IsPointInside(position))
				{
					result = true;
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsInDangerZone(Vector3 position, out DangerZone dangerZone)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		dangerZone = null;
		foreach (DangerZone dangerZone2 in dangerZones)
		{
			if (dangerZone2.IsPointInside(position))
			{
				dangerZone = dangerZone2;
				result = true;
			}
		}
		return result;
	}

	public void State_Death_Think(float timePassed)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!reachedSpinoutLocation)
		{
			if (AtDestination())
			{
				reachedSpinoutLocation = true;
				StartSpinout();
			}
			return;
		}
		float num = Time.realtimeSinceStartup * 0.25f;
		float num2 = Mathf.Sin(MathF.PI * 2f * num) * 10f;
		float num3 = Mathf.Cos(MathF.PI * 2f * num) * 10f;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(num2, 0f, num3);
		SetAimTarget(((Component)this).transform.position + val, isDoorSide: true);
		if (((Component)this).transform.position.y - WaterSystem.OceanLevel <= 0f)
		{
			didImpact = true;
		}
		if (didImpact || Time.realtimeSinceStartup > deathTimeout)
		{
			KillOfNaturalCauses();
		}
	}

	public void State_Death_Enter()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.DEATH;
		if (collisions == null)
		{
			collisions = (Collider[])(object)new Collider[10];
		}
		MonumentInfo monumentInfo = null;
		if (monument_crash)
		{
			monumentInfo = GetCloseMonument(1200f);
		}
		if ((Object)(object)monumentInfo == (Object)null || IsInsideMonument(((Component)this).transform.position))
		{
			reachedSpinoutLocation = true;
			StartSpinout();
			return;
		}
		forceTerrainPushback = true;
		Vector3 position = ((Component)monumentInfo).transform.position;
		position.y = TerrainMeta.HeightMap.GetHeight(position) + 200f;
		if (TransformUtil.GetGroundInfo(position, out var hitOut, 300f, LayerMask.op_Implicit(1235288065)))
		{
			position.y = ((RaycastHit)(ref hitOut)).point.y;
		}
		position.y += GetPlaneHeight();
		SetTargetDestination(position, 25f);
	}

	public void State_Death_Leave()
	{
	}

	private MonumentInfo GetCloseMonument(float maxDistance)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return GetCloseMonument(maxDistance, ((Component)this).transform.position);
	}

	private static MonumentInfo GetCloseMonument(float maxDistance, Vector3 position)
	{
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		MonumentInfo result = null;
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
		{
			float num = float.MaxValue;
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				if (monument.IsSafeZone)
				{
					continue;
				}
				MonumentType type = monument.Type;
				if (type != MonumentType.Mountain && type != MonumentType.Lighthouse && type != MonumentType.Lake && type != MonumentType.WaterWell && type != 0 && type != MonumentType.Building && monument.Tier != 0 && !(((Component)monument).transform.position.y < WaterSystem.OceanLevel) && monument.AllowPatrolHeliCrash)
				{
					float num2 = Vector3Ex.Distance2D(position, ((Component)monument).transform.position);
					float num3 = monument.GetWidest2DBound() * 0.5f;
					float num4 = Mathf.Max(0f, num2 - num3);
					if (num4 < num && num4 <= maxDistance)
					{
						num = num4;
						result = monument;
					}
				}
			}
		}
		return result;
	}

	private static bool IsInsideMonument(Vector3 position)
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
		{
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				if (monument.IsSafeZone)
				{
					continue;
				}
				MonumentType type = monument.Type;
				if (type != MonumentType.Mountain && type != MonumentType.Lighthouse && type != MonumentType.Lake && type != MonumentType.WaterWell && type != 0 && type != MonumentType.Building && monument.Tier != 0 && !(((Component)monument).transform.position.y < WaterSystem.OceanLevel) && monument.AllowPatrolHeliCrash)
				{
					float num = Vector3Ex.Distance2D(position, ((Component)monument).transform.position);
					float widest2DBound = monument.GetWidest2DBound();
					widest2DBound += widest2DBound * 0.1f;
					if (num <= widest2DBound)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private void PhysicsDeathCheck()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!reachedSpinoutLocation)
		{
			return;
		}
		int mask = LayerMask.GetMask(new string[4] { "Terrain", "World", "Construction", "Water" });
		didImpact = false;
		Physics.OverlapSphereNonAlloc(((Component)this).transform.position, 5f, collisions, mask);
		Collider[] array = collisions;
		foreach (Collider val in array)
		{
			if (!((Object)(object)val == (Object)null) && !((Object)(object)((Component)val).gameObject == (Object)(object)((Component)this).gameObject))
			{
				didImpact = true;
				break;
			}
		}
	}

	private void KillOfNaturalCauses()
	{
		helicopterBase.Hurt(helicopterBase.health * 2f, DamageType.Generic, null, useProtection: false);
	}

	private void StartSpinout()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		forceTerrainPushback = false;
		maxRotationSpeed *= 8f;
		Vector3 randomOffset = GetRandomOffset(((Component)this).transform.position, 20f, 60f, 0f, 0f);
		int num = 1237003025;
		TransformUtil.GetGroundInfo(randomOffset - Vector3.up * 2f, out var pos, out var _, 500f, LayerMask.op_Implicit(num));
		SetTargetDestination(pos);
		targetThrottleSpeed = 0.5f;
		deathTimeout = Time.realtimeSinceStartup + 10f;
	}

	public void State_Flee_Think(float timePassed)
	{
		UpdateMove(timePassed);
	}

	public void State_Flee_Enter()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.FLEE;
		if ((Object)(object)helicopterBase != (Object)null)
		{
			helicopterBase.DoFlare();
		}
		restrictedPatrolSize = true;
		timeSinceRestrictedPatrolSize = TimeSince.op_Implicit(0f);
		MonumentInfo closeMonument = GetCloseMonument(float.PositiveInfinity);
		Vector3 val;
		Vector3 normalized;
		if ((Object)(object)closeMonument != (Object)null)
		{
			val = ((Component)closeMonument).transform.position - ((Component)this).transform.position;
			normalized = ((Vector3)(ref val)).normalized;
			normalized.y = 0f;
		}
		else
		{
			Vector2 insideUnitCircle = Random.insideUnitCircle;
			val = new Vector3(insideUnitCircle.x, 0f, insideUnitCircle.y);
			normalized = ((Vector3)(ref val)).normalized;
		}
		Vector3 val2 = ((Component)this).transform.position + normalized * 130f;
		val2.y = GetPlaneHeight();
		TryMove(val2);
		if ((Object)(object)helicopterBase != (Object)null)
		{
			helicopterBase.CreateFleeMarker(val2);
		}
	}

	public void State_Flee_Leave()
	{
		if ((Object)(object)helicopterBase != (Object)null)
		{
			helicopterBase.DestroyFleeMarker();
		}
	}

	public void State_Idle_Think(float timePassed)
	{
		ExitCurrentState();
		State_Patrol_Enter();
	}

	public void State_Idle_Enter()
	{
		_currentState = aiState.IDLE;
	}

	public void State_Idle_Leave()
	{
	}

	public void State_Move_Think(float timePassed)
	{
		UpdateMove(timePassed);
	}

	public void State_Move_Enter(Vector3 newPos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.MOVE;
		TryMove(newPos);
	}

	public void State_Move_Leave()
	{
	}

	private void TryMove(Vector3 newPos)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		destination_min_dist = 10f;
		SetTargetDestination(newPos);
		float distToTarget = Vector3.Distance(((Component)this).transform.position, destination);
		targetThrottleSpeed = GetThrottleForDistance(distToTarget);
	}

	private void UpdateMove(float timePassed)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float distToTarget = Vector3.Distance(((Component)this).transform.position, destination);
		targetThrottleSpeed = GetThrottleForDistance(distToTarget);
		if (AtDestination())
		{
			ExitCurrentState();
			State_Idle_Enter();
		}
	}

	public void State_Orbit_Think(float timePassed)
	{
		OrbitUpdate(timePassed);
	}

	public Vector3 GetOrbitPosition(float rate)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Sin(rate) * currentOrbitDistance;
		float num2 = Mathf.Cos(rate) * currentOrbitDistance;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(num, 0f, num2);
		Vector3 result = interestZoneOrigin + val;
		float y = Mathf.Max(interestZoneOrigin.y, GetPlaneHeight());
		result.y = y;
		return result;
	}

	public void State_Orbit_Enter(float orbitDistance)
	{
		_currentState = aiState.ORBIT;
		OrbitInit(orbitDistance);
	}

	public void State_Orbit_Leave()
	{
		breakingOrbit = false;
		hasEnteredOrbit = false;
		currentOrbitTime = 0f;
		ClearAimTarget();
	}

	private void OrbitInit(float orbitDistance, float minDistForFacingRotation = 0f)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		orbitPointsReached = 0;
		breakingOrbit = false;
		hasEnteredOrbit = false;
		orbitStartTime = Time.realtimeSinceStartup;
		Vector3 val = ((Component)this).transform.position - interestZoneOrigin;
		currentOrbitTime = Mathf.Atan2(val.x, val.z);
		currentOrbitDistance = orbitDistance;
		ClearAimTarget();
		float num = Vector3Ex.Distance2D(((Component)this).transform.position, interestZoneOrigin);
		if (num > orbitDistance && num < 120f)
		{
			currentOrbitDistance = num;
		}
		SetTargetDestination(GetOrbitPosition(currentOrbitTime), 20f, minDistForFacingRotation);
		if (shouldDebug)
		{
			DebugOrbit();
		}
	}

	private void OrbitUpdate(float timePassed, float minDistForFacingRotation = 1f, bool canBreak = true)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		if (breakingOrbit)
		{
			if (AtDestination())
			{
				ExitCurrentState();
				State_Idle_Enter();
			}
		}
		else
		{
			if (Vector3Ex.Distance2D(((Component)this).transform.position, destination) > 15f)
			{
				return;
			}
			orbitPointsReached++;
			if (!hasEnteredOrbit)
			{
				hasEnteredOrbit = true;
				orbitStartTime = Time.realtimeSinceStartup;
			}
			if (_targetList.Count == 0 && !isRetiring && canBreak && orbitPointsReached > 15)
			{
				StartBreakOrbit();
				return;
			}
			float num = MathF.PI * 2f * currentOrbitDistance;
			float num2 = 0.5f * maxSpeed;
			float num3 = num / num2;
			currentOrbitTime += timePassed / num3;
			float rate = currentOrbitTime * 30f;
			Vector3 orbitPosition = GetOrbitPosition(rate);
			ClearAimTarget();
			SetTargetDestination(orbitPosition, 2f, minDistForFacingRotation);
			targetThrottleSpeed = 0.5f;
		}
		if (Time.realtimeSinceStartup - orbitStartTime > maxOrbitDuration && !breakingOrbit && canBreak)
		{
			StartBreakOrbit();
		}
	}

	private void StartBreakOrbit()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		breakingOrbit = true;
		Vector3 appropriatePosition = GetAppropriatePosition(((Component)this).transform.position + ((Component)this).transform.forward * 75f);
		SetTargetDestination(appropriatePosition, 15f, 0f);
	}

	private void DebugOrbit()
	{
	}

	public void State_OrbitStrafe_Enter()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.ORBITSTRAFE;
		if ((Object)(object)strafe_target == (Object)null)
		{
			ExitCurrentState();
			State_Patrol_Enter();
			return;
		}
		if ((Object)(object)strafe_target.GetParentEntity() != (Object)null)
		{
			ExitCurrentState();
			State_Patrol_Enter();
			return;
		}
		interestZoneOrigin = strafe_target_position;
		puttingDistance = true;
		didGetToDesination = false;
		Vector3 targetDest = interestZoneOrigin + ((Component)this).transform.forward * 95f;
		targetDest.y = ((Component)this).transform.position.y;
		SetTargetDestination(targetDest);
		if (strafe_target.IsNearEnemyBase() || Random.Range(0f, 1f) > 0.75f)
		{
			useNapalm = true;
			lastNapalmTime = Time.realtimeSinceStartup;
		}
		numRocketsLeft = 12 + Random.Range(-3, 16);
		lastRocketTime = 0f;
	}

	public void State_OrbitStrafe_Think(float timePassed)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		if (puttingDistance)
		{
			if (AtDestination())
			{
				didGetToDesination = true;
			}
			if (didGetToDesination)
			{
				SetIdealRotation(Quaternion.LookRotation(interestZoneOrigin - ((Component)this).transform.position), 0.8f);
				if (AtRotation())
				{
					puttingDistance = false;
					float num = Vector3Ex.Distance2D(((Component)this).transform.position, interestZoneOrigin);
					num = Mathf.Max(70f, num);
					OrbitInit(num, 1000f);
				}
			}
			return;
		}
		OrbitUpdate(timePassed, 1000f, canBreak: false);
		if (hasEnteredOrbit && !breakingOrbit)
		{
			SetIdealRotation(Quaternion.LookRotation(interestZoneOrigin - ((Component)this).transform.position), 3.5f);
			if (ClipRocketsLeft() > 0 && Time.realtimeSinceStartup - lastRocketTime > timeBetweenRocketsOrbit && CanSeeForStrafe(interestZoneOrigin))
			{
				FireRocket(interestZoneOrigin);
			}
		}
		if (ClipRocketsLeft() <= 0)
		{
			ExitCurrentState();
			State_Move_Enter(GetAppropriatePosition(strafe_target_position + ((Component)this).transform.forward * 120f));
		}
	}

	public void State_OrbitStrafe_Leave()
	{
		breakingOrbit = false;
		hasEnteredOrbit = false;
		currentOrbitTime = 0f;
		ClearAimTarget();
		lastStrafeTime = Time.realtimeSinceStartup;
		strafe_target = null;
	}

	public Vector3 GetRandomPatrolDestination()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = FindValidDestination();
		if (restrictedPatrolSize)
		{
			Vector3 val2 = val - ((Component)this).transform.position;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			normalized.y = 0f;
			Vector3 result = ((Component)this).transform.position + normalized * Random.Range(65f, 130f);
			result.y = GetPlaneHeight();
			return result;
		}
		return val;
	}

	private Vector3 FindValidDestination(int maxAttempts = 5)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (use_danger_zones)
		{
			for (int i = 0; i < maxAttempts; i++)
			{
				Vector3 val = GenerateRandomDestination();
				if (!IsInNoGoZone(val))
				{
					return val;
				}
			}
			Vector3 val2 = GenerateRandomDestination(forceMonument: true);
			if (IsInNoGoZone(val2))
			{
				noGoZones?.Clear();
			}
			return val2;
		}
		return GenerateRandomDestination();
	}

	public Vector3 GenerateRandomDestination(bool forceMonument = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		bool flag = Random.Range(0f, 1f) >= 0.6f;
		if (forceMonument)
		{
			flag = true;
		}
		if (flag)
		{
			if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
			{
				MonumentInfo monumentInfo = null;
				if (_visitedMonuments.Count > 0)
				{
					foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
					{
						if (monument.IsSafeZone)
						{
							continue;
						}
						bool flag2 = false;
						foreach (MonumentInfo visitedMonument in _visitedMonuments)
						{
							if ((Object)(object)monument == (Object)(object)visitedMonument)
							{
								flag2 = true;
							}
						}
						if (!flag2)
						{
							monumentInfo = monument;
							break;
						}
					}
				}
				if ((Object)(object)monumentInfo == (Object)null)
				{
					_visitedMonuments.Clear();
					for (int i = 0; i < 5; i++)
					{
						monumentInfo = TerrainMeta.Path.Monuments[Random.Range(0, TerrainMeta.Path.Monuments.Count)];
						if (!monumentInfo.IsSafeZone)
						{
							break;
						}
					}
				}
				if (Object.op_Implicit((Object)(object)monumentInfo))
				{
					val = ((Component)monumentInfo).transform.position;
					_visitedMonuments.Add(monumentInfo);
					val.y = TerrainMeta.HeightMap.GetHeight(val) + 200f;
					if (TransformUtil.GetGroundInfo(val, out var hitOut, 300f, LayerMask.op_Implicit(1235288065)))
					{
						val.y = ((RaycastHit)(ref hitOut)).point.y;
					}
					val.y += 45f;
				}
			}
			else
			{
				val = GetRandomMapPosition();
			}
		}
		else
		{
			val = GetRandomMapPosition();
		}
		return val;
	}

	public void State_Patrol_Think(float timePassed)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3Ex.Distance2D(((Component)this).transform.position, destination);
		if (num <= 25f)
		{
			targetThrottleSpeed = GetThrottleForDistance(num);
		}
		else
		{
			targetThrottleSpeed = 0.5f;
		}
		if (AtDestination() && arrivalTime == 0f)
		{
			arrivalTime = Time.realtimeSinceStartup;
			ExitCurrentState();
			maxOrbitDuration = 20f;
			State_Orbit_Enter(75f);
		}
		if (_targetList.Count > 0)
		{
			if (use_danger_zones)
			{
				Vector3? val = FindTargetWithZones();
				if (val.HasValue)
				{
					interestZoneOrigin = val.Value;
					OrbitInterestZone();
				}
			}
			else
			{
				interestZoneOrigin = FindDefaultTarget();
				OrbitInterestZone();
			}
		}
		else
		{
			interestZoneOrigin = ((Component)this).transform.position;
		}
	}

	private void OrbitInterestZone()
	{
		ExitCurrentState();
		maxOrbitDuration = 10f;
		State_Orbit_Enter(80f);
	}

	public void State_Patrol_Enter()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.PATROL;
		Vector3 randomPatrolDestination = GetRandomPatrolDestination();
		SetTargetDestination(randomPatrolDestination, 10f);
		interestZoneOrigin = randomPatrolDestination;
		arrivalTime = 0f;
	}

	public void State_Patrol_Leave()
	{
	}

	public float GetPlaneHeight()
	{
		return 50f;
	}

	private Vector3 GetRandomMapPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float planeHeight = GetPlaneHeight();
		Vector3 val = Vector3Ex.Range(-0.7f, 0.7f);
		val.y = 0f;
		((Vector3)(ref val)).Normalize();
		val *= x * Random.Range(0f, 0.75f);
		val.y = planeHeight;
		return val;
	}

	public int ClipRocketsLeft()
	{
		return numRocketsLeft;
	}

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (Time.realtimeSinceStartup - lastStrafeTime >= Random.Range(15f, 25f))
		{
			return CanInterruptState();
		}
		return false;
	}

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return Time.realtimeSinceStartup - lastNapalmTime >= Random.Range(25f, 35f);
	}

	public void State_Strafe_Enter(BasePlayer strafeTarget, bool shouldUseNapalm = false)
	{
		StartStrafe(strafeTarget, shouldUseNapalm);
	}

	public void State_Strafe_Think(float timePassed)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (puttingDistance)
		{
			if (AtDestination())
			{
				RefreshTargetPosition();
				SetIdealRotation(GetYawRotationTo(strafe_target_position), 1.2f);
				if (AtRotation())
				{
					puttingDistance = false;
					cached_strafe_pos = strafe_target_position;
					SetTargetDestination(strafe_target_position + new Vector3(0f, 40f, 0f), 10f);
				}
			}
			return;
		}
		RefreshTargetPosition();
		SetIdealRotation(GetYawRotationTo(strafe_target_position));
		float num = Vector3Ex.Distance2D(cached_strafe_pos, ((Component)this).transform.position);
		if (num <= 150f && ClipRocketsLeft() > 0 && Time.realtimeSinceStartup - lastRocketTime > timeBetweenRockets && CanSeeForStrafe(strafe_target_position))
		{
			FireRocket(strafe_target_position);
		}
		if (num <= get_out_of_strafe_distance || ClipRocketsLeft() <= 0)
		{
			if (Random.value > 0.6f && (Object)(object)strafe_target != (Object)null)
			{
				ExitCurrentState();
				State_OrbitStrafe_Enter();
			}
			else
			{
				ExitCurrentState();
				State_Move_Enter(GetAppropriatePosition(strafe_target_position + ((Component)this).transform.forward * 120f));
			}
		}
	}

	private Vector3 GetPredictedPosition()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = strafe_target_position;
		float num = TimeSince.op_Implicit(timeSinceRefreshed);
		RefreshTargetPosition();
		Vector3 val2 = strafe_target_position;
		return val2 + (val2 - val) * (num / Time.deltaTime);
	}

	private bool CanSeeForStrafe(Vector3 targetPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(targetPos, ((Component)this).transform.position) - 10f;
		if (num < 0f)
		{
			num = 0f;
		}
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = targetPos - ((Component)this).transform.position;
		return !Physics.Raycast(position, ((Vector3)(ref val)).normalized, num, LayerMask.GetMask(new string[2] { "Terrain", "World" }));
	}

	public bool ValidRocketTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", (object)this, (object)ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)ply == (Object)null)
		{
			return false;
		}
		return !ply.IsNearEnemyBase();
	}

	public void State_Strafe_Leave()
	{
		lastStrafeTime = Time.realtimeSinceStartup;
		if (useNapalm)
		{
			lastNapalmTime = Time.realtimeSinceStartup;
		}
		useNapalm = false;
		movementLockingAiming = false;
	}

	private void StartStrafe(BasePlayer strafeTarget, bool shouldUseNapalm = false)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnHelicopterStrafeEnter", (object)this, (object)((Component)strafeTarget).transform.position, (object)strafeTarget) == null)
		{
			strafe_target = strafeTarget;
			get_out_of_strafe_distance = Random.Range(13f, 17f);
			if (CanUseNapalm() && shouldUseNapalm)
			{
				passNapalm = shouldUseNapalm;
				useNapalm = true;
				lastNapalmTime = Time.realtimeSinceStartup;
			}
			lastStrafeTime = Time.realtimeSinceStartup;
			_currentState = aiState.STRAFE;
			RefreshTargetPosition();
			numRocketsLeft = 12 + Random.Range(-1, 1);
			lastRocketTime = 0f;
			movementLockingAiming = true;
			Vector3 randomOffset = GetRandomOffset(strafe_target_position, 175f, 192.5f);
			SetTargetDestination(randomOffset, 10f);
			SetIdealRotation(GetYawRotationTo(randomOffset));
			puttingDistance = true;
		}
	}

	public void FireRocket(Vector3 targetPos)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		numRocketsLeft--;
		lastRocketTime = Time.realtimeSinceStartup;
		float num = Random.Range(3.9f, 4.1f);
		bool flag = leftTubeFiredLast;
		leftTubeFiredLast = !leftTubeFiredLast;
		Transform val = (flag ? helicopterBase.rocket_tube_left.transform : helicopterBase.rocket_tube_right.transform);
		Vector3 val2 = val.position + val.forward * 1f;
		Vector3 val3 = targetPos - val2;
		Vector3 val4 = ((Vector3)(ref val3)).normalized;
		if (num > 0f)
		{
			val4 = AimConeUtil.GetModifiedAimConeDirection(num, val4);
		}
		Effect.server.Run(helicopterBase.rocket_fire_effect.resourcePath, helicopterBase, StringPool.Get(flag ? "rocket_tube_left" : "rocket_tube_right"), Vector3.zero, Vector3.forward, null, broadcast: true);
		BaseEntity baseEntity = GameManager.server.CreateEntity(useNapalm ? rocketProjectile_Napalm.resourcePath : rocketProjectile.resourcePath, val2);
		if (!((Object)(object)baseEntity == (Object)null))
		{
			ServerProjectile component = ((Component)baseEntity).GetComponent<ServerProjectile>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.InitializeVelocity(val4 * component.speed);
			}
			baseEntity.Spawn();
		}
	}

	private void RefreshTargetPosition()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)strafe_target == (Object)null))
		{
			timeSinceRefreshed = TimeSince.op_Implicit(0f);
			int mask = LayerMask.GetMask(new string[5] { "Terrain", "World", "Construction", "Water", "Vehicle Large" });
			if (TransformUtil.GetGroundInfo(((Component)strafe_target).transform.position, out var pos, out var _, 100f, LayerMask.op_Implicit(mask), ((Component)this).transform))
			{
				strafe_target_position = pos;
			}
			else
			{
				strafe_target_position = ((Component)strafe_target).transform.position;
			}
		}
	}

	public void InitializeAI()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		_lastThinkTime = Time.realtimeSinceStartup;
		timeSinceRestrictedPatrolSize = TimeSince.op_Implicit(0f);
	}

	public void OnCurrentStateExit()
	{
		switch (_currentState)
		{
		default:
			State_Idle_Leave();
			break;
		case aiState.MOVE:
			State_Move_Leave();
			break;
		case aiState.STRAFE:
			State_Strafe_Leave();
			break;
		case aiState.ORBIT:
			State_Orbit_Leave();
			break;
		case aiState.ORBITSTRAFE:
			State_OrbitStrafe_Leave();
			break;
		case aiState.FLEE:
			State_Flee_Leave();
			break;
		case aiState.PATROL:
			State_Patrol_Leave();
			break;
		}
	}

	public void ExitCurrentState()
	{
		if (isRetiring || isDead)
		{
			if (shouldDebug)
			{
				Debug.Log((object)"Patrol Helicopter attempting to exit state whilst retiring/dying.");
			}
		}
		else
		{
			OnCurrentStateExit();
			_currentState = aiState.IDLE;
		}
	}

	public float GetTime()
	{
		return Time.realtimeSinceStartup;
	}

	public void AIThink()
	{
		float time = GetTime();
		float timePassed = time - _lastThinkTime;
		_lastThinkTime = time;
		switch (_currentState)
		{
		default:
			State_Idle_Think(timePassed);
			break;
		case aiState.MOVE:
			State_Move_Think(timePassed);
			break;
		case aiState.STRAFE:
			State_Strafe_Think(timePassed);
			break;
		case aiState.ORBIT:
			State_Orbit_Think(timePassed);
			break;
		case aiState.PATROL:
			State_Patrol_Think(timePassed);
			break;
		case aiState.ORBITSTRAFE:
			State_OrbitStrafe_Think(timePassed);
			break;
		case aiState.FLEE:
			State_Flee_Think(timePassed);
			break;
		case aiState.DEATH:
			State_Death_Think(timePassed);
			break;
		}
	}

	public Vector3 GetRandomOffset(Vector3 origin, float minRange, float maxRange = 0f, float minHeight = 50f, float maxHeight = 60f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 onUnitSphere = Random.onUnitSphere;
		onUnitSphere.y = 0f;
		((Vector3)(ref onUnitSphere)).Normalize();
		maxRange = Mathf.Max(minRange, maxRange);
		Vector3 origin2 = origin + onUnitSphere * Random.Range(minRange, maxRange);
		return GetAppropriatePosition(origin2, minHeight, maxHeight);
	}

	public Vector3 GetAppropriatePosition(Vector3 origin, float minHeight = 50f, float maxHeight = 60f)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		float num = 100f;
		Ray val = default(Ray);
		((Ray)(ref val))..ctor(origin + new Vector3(0f, num, 0f), Vector3.down);
		float num2 = 5f;
		int mask = LayerMask.GetMask(new string[4] { "Terrain", "World", "Construction", "Water" });
		RaycastHit val2 = default(RaycastHit);
		if (Physics.SphereCast(val, num2, ref val2, num * 2f - num2, mask))
		{
			origin = ((RaycastHit)(ref val2)).point;
		}
		origin.y += Random.Range(minHeight, maxHeight);
		return origin;
	}

	public float GetThrottleForDistance(float distToTarget)
	{
		float num = 0f;
		if (distToTarget >= 75f)
		{
			return 1f;
		}
		if (distToTarget >= 50f)
		{
			return 0.75f;
		}
		if (distToTarget >= 25f)
		{
			return 0.33f;
		}
		if (distToTarget >= 5f)
		{
			return 0.05f;
		}
		return 0.05f * (1f - distToTarget / 5f);
	}
}


using UnityEngine;

public class targetinfo
{
	public BasePlayer ply;

	public BaseEntity ent;

	public float lastSeenTime = float.PositiveInfinity;

	public float visibleFor;

	public float nextLOSCheck;

	public targetinfo(BaseEntity initEnt, BasePlayer initPly = null)
	{
		ply = initPly;
		ent = initEnt;
		lastSeenTime = float.PositiveInfinity;
		nextLOSCheck = Time.realtimeSinceStartup + 1.5f;
	}

	public bool IsVisible()
	{
		return TimeSinceSeen() < 1.5f;
	}

	public float TimeSinceSeen()
	{
		return Time.realtimeSinceStartup - lastSeenTime;
	}
}


using UnityEngine;

public class DangerZone
{
	public float Radius;

	public bool IsInMonument;

	private float score;

	private float lastActiveTime = Time.realtimeSinceStartup;

	private const float isStaleTime = 5f;

	private Vector3 centre;

	private BaseEntity parent;

	public Vector3 Centre
	{
		get
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)parent == (Object)null)
			{
				return centre;
			}
			return ((Component)parent).transform.TransformPoint(centre);
		}
	}

	public float Score
	{
		get
		{
			return score;
		}
		set
		{
			score = value;
			lastActiveTime = Time.realtimeSinceStartup;
		}
	}

	public float LastActiveTime => lastActiveTime;

	public DangerZone(Vector3 centre, float radius = 20f, BaseEntity parent = null)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)parent == (Object)null)
		{
			this.centre = centre;
		}
		else
		{
			this.centre = ((Component)parent).transform.InverseTransformPoint(centre);
		}
		this.parent = parent;
		Radius = radius;
		IsInMonument = IsInsideMonument(this.centre);
	}

	public bool IsPointInside(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Distance(point, Centre) <= Radius;
	}

	public bool IsStale()
	{
		return Time.realtimeSinceStartup - lastActiveTime > 5f;
	}

	public Vector3 GetNearestEdge(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = point - Centre;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		normalized.y = 0f;
		return Centre + normalized * Radius;
	}
}


public enum aiState
{
	IDLE,
	MOVE,
	ORBIT,
	STRAFE,
	PATROL,
	ORBITSTRAFE,
	GUARD,
	FLEE,
	DEATH
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class ServerGib : BaseCombatEntity
{
	public GameObject _gibSource;

	public string _gibName;

	public PhysicMaterial physicsMaterial;

	public bool useContinuousCollision;

	private MeshCollider meshCollider;

	private Rigidbody rigidBody;

	public override float BoundsPadding()
	{
		return 3f;
	}

	public static List<ServerGib> CreateGibs(string entityToCreatePath, GameObject creator, GameObject gibSource, Vector3 inheritVelocity, float spreadVelocity)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		List<ServerGib> list = new List<ServerGib>();
		MeshRenderer[] componentsInChildren = gibSource.GetComponentsInChildren<MeshRenderer>(true);
		foreach (MeshRenderer val in componentsInChildren)
		{
			MeshFilter component = ((Component)val).GetComponent<MeshFilter>();
			Vector3 val2 = ((Component)val).transform.localPosition;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			Matrix4x4 localToWorldMatrix = creator.transform.localToWorldMatrix;
			Vector3 val3 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint(((Component)val).transform.localPosition) + normalized * 0.5f;
			Quaternion val4 = creator.transform.rotation * ((Component)val).transform.localRotation;
			BaseEntity baseEntity = GameManager.server.CreateEntity(entityToCreatePath, val3, val4);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				ServerGib component2 = ((Component)baseEntity).GetComponent<ServerGib>();
				((Component)component2).transform.SetPositionAndRotation(val3, val4);
				component2._gibName = ((Object)val).name;
				MeshCollider component3 = ((Component)val).GetComponent<MeshCollider>();
				Mesh physicsMesh = (((Object)(object)component3 != (Object)null) ? component3.sharedMesh : component.sharedMesh);
				component2.PhysicsInit(physicsMesh);
				val2 = ((Component)val).transform.localPosition;
				Vector3 val5 = ((Vector3)(ref val2)).normalized * spreadVelocity;
				component2.rigidBody.velocity = inheritVelocity + val5;
				Rigidbody obj = component2.rigidBody;
				val2 = Vector3Ex.Range(-1f, 1f);
				obj.angularVelocity = ((Vector3)(ref val2)).normalized * 1f;
				component2.rigidBody.WakeUp();
				component2.Spawn();
				list.Add(component2);
			}
		}
		foreach (ServerGib item in list)
		{
			foreach (ServerGib item2 in list)
			{
				if (!((Object)(object)item == (Object)(object)item2))
				{
					Physics.IgnoreCollision((Collider)(object)item2.GetCollider(), (Collider)(object)item.GetCollider(), true);
				}
			}
		}
		Interface.CallHook("OnGibsSpawned", (object)list, (object)creator);
		return list;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk && _gibName != "")
		{
			info.msg.servergib = Pool.Get<ServerGib>();
			info.msg.servergib.gibName = _gibName;
		}
	}

	public MeshCollider GetCollider()
	{
		if ((Object)(object)meshCollider == (Object)null)
		{
			meshCollider = ((Component)this).GetComponent<MeshCollider>();
		}
		if ((Object)(object)meshCollider == (Object)null)
		{
			meshCollider = ((Component)this).GetComponentInChildren<MeshCollider>();
		}
		return meshCollider;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 1800f);
	}

	public void RemoveMe()
	{
		Kill();
	}

	public virtual void PhysicsInit(Mesh physicsMesh)
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		Mesh sharedMesh = null;
		MeshFilter component = ((Component)this).gameObject.GetComponent<MeshFilter>();
		if ((Object)(object)component != (Object)null)
		{
			sharedMesh = component.sharedMesh;
			component.sharedMesh = physicsMesh;
		}
		meshCollider = ((Component)this).gameObject.AddComponent<MeshCollider>();
		meshCollider.sharedMesh = physicsMesh;
		meshCollider.convex = true;
		((Collider)meshCollider).material = physicsMaterial;
		if ((Object)(object)component != (Object)null)
		{
			component.sharedMesh = sharedMesh;
		}
		Rigidbody val = ((Component)this).gameObject.AddComponent<Rigidbody>();
		val.useGravity = true;
		Bounds val2 = ((Collider)meshCollider).bounds;
		Vector3 size = ((Bounds)(ref val2)).size;
		float magnitude = ((Vector3)(ref size)).magnitude;
		val2 = ((Collider)meshCollider).bounds;
		size = ((Bounds)(ref val2)).size;
		val.mass = Mathf.Clamp(magnitude * ((Vector3)(ref size)).magnitude * 20f, 10f, 2000f);
		val.interpolation = (RigidbodyInterpolation)1;
		val.collisionDetectionMode = (CollisionDetectionMode)(useContinuousCollision ? 2 : 0);
		if (base.isServer)
		{
			val.drag = 0.1f;
			val.angularDrag = 0.1f;
		}
		rigidBody = val;
		((Component)this).gameObject.layer = LayerMask.NameToLayer("Default");
		if (base.isClient)
		{
			val.isKinematic = true;
		}
	}
}


using System;

public class TimedUnlootableCrate : LootContainer
{
	public bool unlootableOnSpawn = true;

	public float unlootableDuration = 300f;

	public override void ServerInit()
	{
		base.ServerInit();
		if (unlootableOnSpawn)
		{
			SetUnlootableFor(unlootableDuration);
		}
	}

	public void SetUnlootableFor(float duration)
	{
		SetFlag(Flags.OnFire, b: true);
		SetFlag(Flags.Locked, b: true);
		unlootableDuration = duration;
		((FacepunchBehaviour)this).Invoke((Action)MakeLootable, duration);
	}

	public void MakeLootable()
	{
		SetFlag(Flags.OnFire, b: false);
		SetFlag(Flags.Locked, b: false);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PlanterBoxStatic : PlanterBox
{
	[ServerVar(Help = "Chance of a favourable gene being picked [0-1]. Setting this to 0 does not ensure no favourable genes are picked up, but it greatly reduces the chances.")]
	public static float FavourableGeneChance = 0.5f;

	public List<GameObjectRef> staticPlantsSpawnlist;

	public bool randomPerSlot;

	public float respawnCheckTimer = 30f;

	public override void SetupTimeCaches()
	{
	}

	public override void RefreshGrowables(GrowableEntity ignoreEntity = null)
	{
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)CreateStaticPlants, 1f, respawnCheckTimer);
	}

	public void CreateStaticPlants()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		soilSaturation = soilSaturationMax;
		GameObjectRef randomStaticPlant = GetRandomStaticPlant();
		Socket_Base[] array = PrefabAttribute.server.FindAll<Socket_Base>(prefabID);
		foreach (Socket_Base socket_Base in array)
		{
			if (socket_Base is Socket_Specific_Female && IsSpawnPointFreeSearch(socket_Base.localPosition))
			{
				if (randomPerSlot)
				{
					randomStaticPlant = GetRandomStaticPlant();
				}
				Vector3 pos = ((Component)this).transform.TransformPoint(socket_Base.localPosition);
				BaseEntity baseEntity = GameManager.server.CreateEntity(randomStaticPlant.resourcePath, pos, Quaternion.identity);
				baseEntity.SetParent(this, worldPositionStays: true);
				baseEntity.Spawn();
				GrowableEntity growableEntity = baseEntity as GrowableEntity;
				if ((Object)(object)growableEntity != (Object)null)
				{
					growableEntity.Fertilize();
					growableEntity.SetGodQuality(qual: true);
					growableEntity.SetMaxGrowingConditions();
					growableEntity.Genes.GenerateFavourableGenes(growableEntity);
					growableEntity.SendNetworkUpdate();
					OnPlantInserted(growableEntity, null);
				}
			}
		}
	}

	private GameObjectRef GetRandomStaticPlant()
	{
		if (staticPlantsSpawnlist == null || staticPlantsSpawnlist.Count == 0)
		{
			return null;
		}
		int index = Random.Range(0, staticPlantsSpawnlist.Count);
		return staticPlantsSpawnlist[index];
	}

	private bool IsSpawnPointFreeSearch(Vector3 localPos)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		foreach (BaseEntity child in children)
		{
			if (child is GrowableEntity && Vector3.Distance(((Component)child).transform.localPosition, localPos) < 0.05f)
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SeekerTarget
{
	public enum SeekerStrength
	{
		OFF = 0,
		LOW = 100,
		MEDIUM = 200,
		HIGH = 1000,
		HIGHEST = 1000
	}

	public interface ISeekerTargetOwner
	{
		Vector3 CenterPoint();

		bool InSafeZone();

		bool IsValidHomingTarget();

		bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

		void OnEntityMessage(BaseEntity from, string msg);
	}

	[NonSerialized]
	public SeekerStrength strength;

	public ISeekerTargetOwner owner;

	private static Dictionary<ISeekerTargetOwner, SeekerTarget> seekerTargets = new Dictionary<ISeekerTargetOwner, SeekerTarget>();

	public bool IsValidTarget()
	{
		if (owner.IsUnityNull())
		{
			return false;
		}
		if (!owner.InSafeZone())
		{
			return owner.IsValidHomingTarget();
		}
		return false;
	}

	public bool TryGetPosition(out Vector3 result)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (owner.IsUnityNull())
		{
			result = Vector3.zero;
			return false;
		}
		result = owner.CenterPoint();
		return true;
	}

	public void SendOwnerMessage(BaseEntity from, string message)
	{
		if (!owner.IsUnityNull())
		{
			owner.OnEntityMessage(from, message);
		}
	}

	public static SeekerTarget GetBestForPoint(Vector3 from, Vector3 forward, float maxCone, float maxDist, SeekerStrength minStrength = SeekerStrength.LOW)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		SeekerTarget result = null;
		float num = 0f;
		foreach (KeyValuePair<ISeekerTargetOwner, SeekerTarget> seekerTarget in seekerTargets)
		{
			ISeekerTargetOwner key = seekerTarget.Key;
			SeekerTarget value = seekerTarget.Value;
			if (value.strength < minStrength || !value.IsValidTarget() || !value.TryGetPosition(out var result2))
			{
				continue;
			}
			Vector3 val = Vector3Ex.Direction(result2, from);
			float num2 = Vector3.Dot(forward, val);
			float num3 = Vector3.Distance(result2, from);
			if (num3 < maxDist && num2 > maxCone)
			{
				float num4 = 1f - num3 / maxDist * 0.3f;
				float num5 = num2 / maxCone * 1f;
				float num6 = (float)value.strength / 1000f * 0.5f;
				float num7 = num4 + num5 + num6;
				if (num7 > num && key.IsVisible(from, maxDist))
				{
					result = value;
					num = num7;
				}
			}
		}
		return result;
	}

	public static void SetSeekerTarget(ISeekerTargetOwner toAdd, SeekerStrength strength)
	{
		if (strength == SeekerStrength.OFF)
		{
			if (seekerTargets.ContainsKey(toAdd))
			{
				seekerTargets.Remove(toAdd);
			}
		}
		else if (!seekerTargets.ContainsKey(toAdd))
		{
			SeekerTarget value = new SeekerTarget
			{
				strength = strength,
				owner = toAdd
			};
			seekerTargets.Add(toAdd, value);
		}
	}
}


public enum SeekerStrength
{
	OFF = 0,
	LOW = 100,
	MEDIUM = 200,
	HIGH = 1000,
	HIGHEST = 1000
}


using UnityEngine;

public interface ISeekerTargetOwner
{
	Vector3 CenterPoint();

	bool InSafeZone();

	bool IsValidHomingTarget();

	bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

	void OnEntityMessage(BaseEntity from, string msg);
}


using System;
using UnityEngine;

public class SeekingServerProjectile : ServerProjectile
{
	public float courseAdjustRate = 1f;

	public float maxTrackDistance = 500f;

	public float minLockDot;

	public float flareLockDot = 0.6f;

	public bool autoSeek;

	public float swimAfter = 6f;

	public float launchingDuration = 0.15f;

	public float armingDuration = 0.75f;

	public float velocityRampUpTime = 6f;

	public Vector3 armingFinalDir;

	public AnimationCurve airmingDirCurve;

	public AnimationCurve armingVelocityCurve;

	public float armingVelocity;

	public AnimationCurve velocityCurve;

	public float orphanedVectorChangeRate = 30f;

	public SeekerTarget lockedTarget;

	private float nextTargetUpdateTime = float.NegativeInfinity;

	private Vector3 seekingDestination;

	private float launchTime;

	private Vector3 initialDir = Vector3.forward;

	private bool orphanedProjectile;

	private Vector3 orphanedTargetVector;

	private Vector3 orphanedRotationAxis;

	public float totalArmingPhaseDuration => launchingDuration + armingDuration;

	public void NotifyOrphaned()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		orphanedProjectile = true;
		orphanedTargetVector = Random.onUnitSphere;
	}

	public virtual void UpdateTarget()
	{
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		if (orphanedProjectile)
		{
			lockedTarget = null;
			return;
		}
		if (Time.realtimeSinceStartup >= nextTargetUpdateTime)
		{
			if (autoSeek)
			{
				lockedTarget = SeekerTarget.GetBestForPoint(((Component)this).transform.position, ((Component)this).transform.forward, minLockDot, maxTrackDistance);
			}
			else
			{
				SeekerTarget bestForPoint = SeekerTarget.GetBestForPoint(((Component)this).transform.position, ((Component)this).transform.forward, flareLockDot, maxTrackDistance, SeekerTarget.SeekerStrength.HIGH);
				if (bestForPoint != null)
				{
					lockedTarget = bestForPoint;
				}
			}
			nextTargetUpdateTime = Time.realtimeSinceStartup + 0.1f;
		}
		if (lockedTarget != null && lockedTarget.TryGetPosition(out var result))
		{
			seekingDestination = result;
		}
		else
		{
			seekingDestination = ((Component)this).transform.position + ((Component)this).transform.forward * 1000f;
		}
		if (lockedTarget != null)
		{
			lockedTarget.SendOwnerMessage(base.baseEntity, "RadarLock");
		}
	}

	public Vector3 GetSeekingDestination()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return seekingDestination;
	}

	public override bool DoMovement()
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		float num = TimeSinceLaunch();
		if (!(num < launchingDuration))
		{
			if (num < totalArmingPhaseDuration)
			{
				float num2 = num - launchingDuration;
				Vector3 val = Vector3.Lerp(initialDir, armingFinalDir, Mathf.Clamp01(num2 / armingDuration));
				base.CurrentVelocity = val * armingVelocity * armingVelocityCurve.Evaluate(num);
			}
			else
			{
				UpdateTarget();
				Vector3 val2 = base.CurrentVelocity;
				Vector3 normalized = ((Vector3)(ref val2)).normalized;
				Vector3 normalized2;
				if (orphanedProjectile)
				{
					normalized2 = orphanedTargetVector;
					orphanedTargetVector = Quaternion.AngleAxis(orphanedVectorChangeRate * Time.deltaTime, orphanedRotationAxis) * orphanedTargetVector;
					if (Random.value < 0.02f)
					{
						PickNewRotationAxis();
					}
				}
				else
				{
					val2 = GetSeekingDestination() - ((Component)this).transform.position;
					normalized2 = ((Vector3)(ref val2)).normalized;
				}
				Vector3 val3 = Vector3.MoveTowards(normalized, normalized2, Time.fixedDeltaTime * courseAdjustRate);
				((Vector3)(ref val3)).Normalize();
				float num3 = armingVelocity + velocityCurve.Evaluate(TimeSinceArmed() / velocityRampUpTime) * speed;
				base.CurrentVelocity = val3 * num3;
			}
		}
		return base.DoMovement();
	}

	public float TimeSinceArmed()
	{
		return TimeSinceLaunch() - totalArmingPhaseDuration;
	}

	public float TimeSinceLaunch()
	{
		return Mathf.Max(Time.time - launchTime, 0f);
	}

	public void EnableBoosters()
	{
		base.baseEntity.SetFlag(BaseEntity.Flags.On, b: true);
		((FacepunchBehaviour)this).Invoke((Action)DisableBoosters, 1f);
	}

	public void DisableBoosters()
	{
		base.baseEntity.SetFlag(BaseEntity.Flags.On, b: false);
	}

	public override void InitializeVelocity(Vector3 overrideVel)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normalized = ((Vector3)(ref overrideVel)).normalized;
		launchTime = Time.time;
		initialDir = normalized;
		((FacepunchBehaviour)this).Invoke((Action)EnableBoosters, 0.5f);
		base.InitializeVelocity(overrideVel);
	}

	private void PickNewRotationAxis()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(orphanedTargetVector, Random.onUnitSphere);
		orphanedRotationAxis = ((Vector3)(ref val)).normalized;
	}
}


using System;
using System.Linq;
using Rust.Workshop;
using UnityEngine;

public static class SkinHelpers
{
	public static void SetSkin(GameObject itemModel, ItemDefinition itemDef, ulong skinID)
	{
		if ((Object)(object)itemDef == (Object)null)
		{
			return;
		}
		ItemSkinDirectory.Skin skin = itemDef.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == skinID);
		if ((ulong)skin.id == skinID)
		{
			ItemSkin itemSkin = skin.invItem as ItemSkin;
			if ((Object)(object)itemSkin != (Object)null)
			{
				itemSkin.ApplySkin(itemModel);
			}
		}
		else if (skinID != 0L)
		{
			WorkshopSkin.Apply(itemModel, skinID, (Action<Skin>)null, (Action)null);
		}
	}
}


public class SmokeBomb : TimedExplosive
{
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SmokeGrenade : TimedExplosive
{
	public float smokeDuration = 45f;

	public GameObjectRef smokeEffectPrefab;

	public GameObjectRef igniteSound;

	public SoundPlayer soundLoop;

	private GameObject smokeEffectInstance;

	public static List<SmokeGrenade> activeGrenades = new List<SmokeGrenade>();

	public float fieldMin = 5f;

	public float fieldMax = 8f;

	protected bool killing;

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckForWater, 1f, 1f);
	}

	public override void Explode()
	{
		if (WaterFactor() >= 0.5f)
		{
			FinishUp();
		}
		else if (!IsOn())
		{
			((FacepunchBehaviour)this).Invoke((Action)FinishUp, smokeDuration);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Open, b: true);
			InvalidateNetworkCache();
			SendNetworkUpdateImmediate();
			activeGrenades.Add(this);
			SingletonComponent<SmokeGrenadeManager>.Instance.Add(this);
		}
	}

	public void CheckForWater()
	{
		if (WaterFactor() >= 0.5f)
		{
			FinishUp();
		}
	}

	public void FinishUp()
	{
		if (!killing)
		{
			Kill();
			killing = true;
		}
	}

	public override void DestroyShared()
	{
		SingletonComponent<SmokeGrenadeManager>.Instance.Remove(this);
		activeGrenades.Remove(this);
		base.DestroyShared();
	}
}


using System;
using System.Collections.Generic;
using Spatial;
using UnityEngine;

public class SmokeGrenadeManager : SingletonComponent<SmokeGrenadeManager>
{
	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private Grid<BaseEntity> smokeGrid = new Grid<BaseEntity>(32, 8096f);

	public void Add(BaseEntity smoke)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (IsSmokeGrenade(smoke))
		{
			smokeGrid.Add(smoke, ((Component)smoke).transform.position.x, ((Component)smoke).transform.position.z);
		}
	}

	public void Move(BaseEntity smoke)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SmokeGrenadeManager.Move", 0);
		try
		{
			if (IsSmokeGrenade(smoke))
			{
				Vector3 position = ((Component)smoke).transform.position;
				smokeGrid.Move(smoke, position.x, position.z);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Remove(BaseEntity smoke)
	{
		if (IsSmokeGrenade(smoke))
		{
			smokeGrid.Remove(smoke);
		}
	}

	public void GetSmokeAround(Vector3 position, float range, List<BaseEntity> results)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SmokeGrenadeManager.GetSmokeAround", 0);
		try
		{
			if (smokeGrid != null)
			{
				smokeGrid.Query<BaseEntity>(position.x, position.z, range, results);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsSmokeGrenade(BaseEntity entity)
	{
		if (entity is SmokeGrenade)
		{
			return true;
		}
		return false;
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class SphereEntity : BaseEntity
{
	public float currentRadius = 1f;

	public float lerpRadius = 1f;

	public float lerpSpeed = 1f;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.sphereEntity = Pool.Get<SphereEntity>();
		info.msg.sphereEntity.radius = currentRadius;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer)
		{
			if (info.msg.sphereEntity != null)
			{
				currentRadius = (lerpRadius = info.msg.sphereEntity.radius);
			}
			UpdateScale();
		}
	}

	public void LerpRadiusTo(float radius, float speed)
	{
		lerpRadius = radius;
		lerpSpeed = speed;
	}

	public void UpdateScale()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = new Vector3(currentRadius, currentRadius, currentRadius);
	}

	public void Update()
	{
		if (currentRadius != lerpRadius && base.isServer)
		{
			currentRadius = Mathf.MoveTowards(currentRadius, lerpRadius, Time.deltaTime * lerpSpeed);
			UpdateScale();
			SendNetworkUpdate();
		}
	}
}


