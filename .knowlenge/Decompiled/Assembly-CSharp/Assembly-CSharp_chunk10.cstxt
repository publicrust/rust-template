using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch.Extend;
using Facepunch.Utility;
using Ionic.Zlib;
using UnityEngine;

public static class ProfileExporter
{
	private struct MainThreadInfo
	{
		public List<uint> SyncIndices;

		public List<uint> FrameStarts;

		public uint Frames;
	}

	public static class JSON
	{
		private struct ThreadMetadata
		{
			internal int ThreadId;

			internal int AllocationThreadId;

			internal void Emit(StringStream builder)
			{
				bool isMainThread = ThreadId == ServerProfiler.GetMainThreadId();
				EmitThreadName(isMainThread, isAllocThread: false, ThreadId, ThreadId, builder);
				builder.Append(',');
				EmitThreadName(isMainThread, isAllocThread: true, AllocationThreadId, ThreadId, builder);
			}

			private static void EmitThreadName(bool isMainThread, bool isAllocThread, int id, int origId, StringStream builder)
			{
				builder.Append("{\"name\":\"thread_name\",\"ph\":\"M\",\"pid\":0,\"tid\":");
				builder.Append(id);
				builder.Append(",\"args\":{\"name\":\"");
				if (isMainThread)
				{
					builder.Append("Main Thread");
				}
				else
				{
					builder.Append("Thread");
				}
				if (isAllocThread)
				{
					if (!isMainThread)
					{
						builder.Append(' ');
						builder.Append(origId);
					}
					builder.Append(" Allocations");
				}
				builder.Append("\"}}");
			}
		}

		public class StringStream : MemoryStream
		{
			private GZipStream outputStream;

			public StringStream(int capacity, GZipStream outputStream)
				: base(capacity)
			{
				this.outputStream = outputStream;
			}

			public override void Write(byte[] buffer, int offset, int count)
			{
				if (base.Position + count < base.Capacity)
				{
					base.Write(buffer, offset, count);
					return;
				}
				int num = base.Capacity - (int)base.Position;
				if (num > 0)
				{
					base.Write(buffer, offset, num);
				}
				Flush();
				if (count - num > 0)
				{
					base.Write(buffer, offset + num, count - num);
				}
			}

			public override void Write(ReadOnlySpan<byte> source)
			{
				throw new NotSupportedException("Write(ReadOnlySpan<byte>) not implemented!");
			}

			public override void WriteByte(byte value)
			{
				if (base.Position + 1 < base.Capacity)
				{
					base.WriteByte(value);
					return;
				}
				Flush();
				base.WriteByte(value);
			}

			public void Append(char c)
			{
				WriteByte((byte)c);
			}

			public void Append(string text)
			{
				foreach (char c in text)
				{
					Append(c);
				}
			}

			public void Append(int num)
			{
				Span<char> destination = stackalloc char[32];
				num.TryFormat(destination, out var charsWritten);
				Append(destination.Slice(0, charsWritten));
			}

			public void Append(long num)
			{
				Span<char> destination = stackalloc char[32];
				num.TryFormat(destination, out var charsWritten);
				Append(destination.Slice(0, charsWritten));
			}

			public void Append(ulong num)
			{
				Span<char> destination = stackalloc char[32];
				num.TryFormat(destination, out var charsWritten);
				Append(destination.Slice(0, charsWritten));
			}

			public void Append(ReadOnlySpan<char> chars)
			{
				ReadOnlySpan<char> readOnlySpan = chars;
				for (int i = 0; i < readOnlySpan.Length; i++)
				{
					char c = readOnlySpan[i];
					Append(c);
				}
			}

			public override void Flush()
			{
				long position = Position;
				if (position > 0)
				{
					byte[] buffer = GetBuffer();
					((Stream)(object)outputStream).Write(buffer, 0, (int)position);
					Position = 0L;
				}
			}
		}

		public static bool Export(string filename, IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
		{
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Expected O, but got Unknown
			try
			{
				Debug.Log((object)"Starting JSON snapshot generation...");
				Preprocess(profiles, out var mainInfo, out var _);
				string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
				if (!Directory.Exists(text))
				{
					Directory.CreateDirectory(text);
				}
				using (FileStream fileStream = new FileStream(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".json.gz")), FileMode.Create, FileAccess.Write, FileShare.None, 20480))
				{
					GZipStream val = new GZipStream((Stream)fileStream, (CompressionMode)0);
					try
					{
						val.FlushMode = (FlushType)2;
						using StringStream stringStream = new StringStream(16384, val);
						stringStream.Append('[');
						int num = 0;
						foreach (ServerProfiler.Profile profile2 in profiles)
						{
							num = Math.Max(num, profile2.ThreadId);
						}
						List<ThreadMetadata> list = new List<ThreadMetadata>();
						for (int i = 0; i < profiles.Count; i++)
						{
							ServerProfiler.Profile profile = profiles[i];
							ThreadMetadata item = default(ThreadMetadata);
							item.ThreadId = profile.ThreadId;
							num = (item.AllocationThreadId = num + 1);
							if (i != 0)
							{
								stringStream.Append(',');
							}
							item.Emit(stringStream);
							list.Add(item);
						}
						long firstMarkTimestamp = 0L;
						for (int j = 0; j < profiles.Count; j++)
						{
							ServerProfiler.Profile mainProfile = profiles[j];
							if (mainProfile.ThreadId == ServerProfiler.GetMainThreadId())
							{
								if (ProcessMainProfile(in mainProfile, in mainInfo, list[j], stringStream, out firstMarkTimestamp))
								{
									break;
								}
								return false;
							}
						}
						for (int k = 0; k < profiles.Count; k++)
						{
							ServerProfiler.Profile workerProfile = profiles[k];
							if (workerProfile.ThreadId != ServerProfiler.GetMainThreadId() && !ProcessWorkerProfile(in workerProfile, list[k], firstMarkTimestamp, stringStream))
							{
								return false;
							}
						}
						ProcessMemoryState(in memState, firstMarkTimestamp, stringStream);
						stringStream.Append("]");
						stringStream.Flush();
						Debug.Log((object)"Generation done, flushing...");
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
				}
				Debug.Log((object)"Snapshot json export done!");
				return true;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				return false;
			}
		}

		private unsafe static bool ProcessMainProfile(in ServerProfiler.Profile mainProfile, in MainThreadInfo info, in ThreadMetadata metadata, StringStream builder, out long firstMarkTimestamp)
		{
			if (info.FrameStarts == null || info.Frames == 0)
			{
				Debug.LogError((object)"ServerProfiler: Didn't find any main frame info!");
				firstMarkTimestamp = 0L;
				return false;
			}
			int num = 0;
			byte* data = mainProfile.Data;
			uint num2 = info.FrameStarts[0];
			firstMarkTimestamp = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num2).Timestamp;
			long num3 = 0L;
			for (int i = 0; i < info.Frames; i++)
			{
				uint num4 = info.FrameStarts[i];
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num4);
				uint num5 = mainProfile.WriteEnd;
				if (i < info.Frames - 1)
				{
					num5 = info.FrameStarts[i + 1];
				}
				ServerProfiler.Mark mark2 = default(ServerProfiler.Mark);
				mark2.Event = ServerProfiler.Mark.Type.Enter;
				mark2.Timestamp = mark.Timestamp;
				AddMark(mark2, $"UnityFrame{i}", mainProfile.ThreadId, firstMarkTimestamp, builder);
				uint totalMem = 0u;
				long offset = ServerProfiler.TimestampToMicros(mark.Timestamp - firstMarkTimestamp);
				EmitCounter("Main Thread", offset, "Total(B)", totalMem, builder);
				uint readInd = num4;
				while (readInd < num5)
				{
					ServerProfiler.Mark mark3 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + readInd);
					num3 = mark3.Timestamp;
					num += AdjustCallstackDepth(in mark3);
					if (num < 0)
					{
						Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {num}, offset: {readInd}, frame: {i}");
						return false;
					}
					AddMark(in mainProfile, in metadata, readInd, ref totalMem, firstMarkTimestamp, builder);
					if (!AdvanceReadInd(in mark3, data, ref readInd))
					{
						return false;
					}
				}
				long timestamp = ((i < info.Frames - 1) ? Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num5).Timestamp : num3);
				mark2 = default(ServerProfiler.Mark);
				mark2.Event = ServerProfiler.Mark.Type.Exit;
				mark2.Timestamp = timestamp;
				AddMark(mark2, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
			}
			while (num > 0)
			{
				ServerProfiler.Mark mark4 = default(ServerProfiler.Mark);
				mark4.Event = ServerProfiler.Mark.Type.Exit;
				mark4.Timestamp = num3;
				AddMark(mark4, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
				num--;
			}
			return true;
		}

		private unsafe static bool ProcessWorkerProfile(in ServerProfiler.Profile workerProfile, in ThreadMetadata metadata, long firstMarkTimestamp, StringStream builder)
		{
			uint readInd = 0u;
			int num = 0;
			while (readInd < workerProfile.WriteEnd)
			{
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd);
				if (mark.Timestamp >= firstMarkTimestamp)
				{
					break;
				}
				if (mark.Event == ServerProfiler.Mark.Type.Sync)
				{
					Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
					return false;
				}
				num += AdjustCallstackDepth(in mark);
				if (!AdvanceReadInd(in mark, workerProfile.Data, ref readInd))
				{
					return false;
				}
			}
			if (readInd >= workerProfile.WriteEnd)
			{
				return true;
			}
			bool flag = false;
			uint readInd2 = readInd;
			while (readInd2 < workerProfile.WriteEnd)
			{
				ServerProfiler.Mark mark2 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd2);
				if (mark2.Event == ServerProfiler.Mark.Type.Sync)
				{
					Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
					return false;
				}
				if (mark2.Event != ServerProfiler.Mark.Type.Alloc)
				{
					flag = true;
					break;
				}
				if (!AdvanceReadInd(in mark2, workerProfile.Data, ref readInd2))
				{
					return false;
				}
			}
			if (!flag)
			{
				return true;
			}
			if (!FindStartingDepth(in workerProfile, 0u, workerProfile.WriteEnd, out var minDepth))
			{
				return false;
			}
			minDepth = num - minDepth;
			for (int num2 = minDepth; num2 > 0; num2--)
			{
				ServerProfiler.Mark mark3 = default(ServerProfiler.Mark);
				mark3.Event = ServerProfiler.Mark.Type.Enter;
				mark3.Timestamp = firstMarkTimestamp;
				AddMark(mark3, "Unknown", workerProfile.ThreadId, firstMarkTimestamp, builder);
			}
			uint totalMem = 0u;
			long timestamp = 0L;
			uint readInd3 = readInd;
			while (readInd3 < workerProfile.WriteEnd)
			{
				ServerProfiler.Mark mark4 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd3);
				timestamp = mark4.Timestamp;
				minDepth += AdjustCallstackDepth(in mark4);
				if (minDepth < 0)
				{
					Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {minDepth}, offset: {readInd3}, thread: {workerProfile.ThreadId}");
					return false;
				}
				if (mark4.Event == ServerProfiler.Mark.Type.Alloc || (mark4.Event == ServerProfiler.Mark.Type.AllocWithStack && totalMem == 0))
				{
					EmitCounter("Thread", metadata.ThreadId, 0L, "Total(B)", 0uL, builder);
				}
				AddMark(in workerProfile, in metadata, readInd3, ref totalMem, firstMarkTimestamp, builder);
				if (!AdvanceReadInd(in mark4, workerProfile.Data, ref readInd3))
				{
					return false;
				}
			}
			while (minDepth > 0)
			{
				ServerProfiler.Mark mark5 = default(ServerProfiler.Mark);
				mark5.Event = ServerProfiler.Mark.Type.Exit;
				mark5.Timestamp = timestamp;
				AddMark(mark5, null, workerProfile.ThreadId, firstMarkTimestamp, builder);
				minDepth--;
			}
			return true;
		}

		private unsafe static void ProcessMemoryState(in ServerProfiler.MemoryState memState, long firstMarkTimestamp, StringStream builder)
		{
			ulong num = 0uL;
			ulong num2 = 0uL;
			for (uint num3 = 0u; num3 < memState.Created; num3++)
			{
				ServerProfiler.MemoryReading memoryReading = memState.Readings[num3];
				long timestamp = memoryReading.Timestamp;
				if (timestamp >= firstMarkTimestamp)
				{
					ulong num4 = memoryReading.WorkingSet / 1024;
					if (num4 != num)
					{
						long offset = ((num == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
						EmitCounter("ws", offset, "WorkingSet(KB)", num4, builder);
						num = num4;
					}
					ulong num5 = memoryReading.VirtualSet / 1024;
					if (num5 != num2)
					{
						long offset2 = ((num2 == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
						EmitCounter("vs", offset2, "VirtualSet(KB)", num5, builder);
						num2 = num5;
					}
				}
			}
		}

		private unsafe static void AddMark(in ServerProfiler.Profile threadProfile, in ThreadMetadata metadata, uint markInd, ref uint totalMem, long startTimestamp, StringStream builder)
		{
			byte* ptr = threadProfile.Data + markInd;
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
			ptr += sizeof(ServerProfiler.Mark);
			switch (mark.Event)
			{
			case ServerProfiler.Mark.Type.Enter:
				builder.Append(",{\"name\":\"");
				ServerProfiler.AppendNameTo(*(ServerProfiler.Native.MonoMethod**)ptr, builder);
				builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append("}");
				break;
			case ServerProfiler.Mark.Type.Exit:
			case ServerProfiler.Mark.Type.Exception:
			case ServerProfiler.Mark.Type.GCEnd:
				builder.Append(",{\"ph\":\"E\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append("}");
				break;
			case ServerProfiler.Mark.Type.Alloc:
			{
				ServerProfiler.Alloc alloc2 = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
				long num2 = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
				builder.Append(",{\"name\":\"");
				builder.Append("Alloc ");
				builder.Append(alloc2.AlignedSize);
				builder.Append("b\",\"ph\":\"i\",\"ts\":");
				builder.Append(num2);
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
				builder.Append(alloc2.AlignedSize);
				builder.Append(",\"type\":\"");
				ServerProfiler.AppendNameTo(alloc2, builder);
				builder.Append("\",\"lastMethod\":\"");
				if (alloc2.LastMethod != null)
				{
					ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
				}
				else
				{
					builder.Append("<mono-native-runtime>");
				}
				builder.Append("\"}}");
				builder.Append(",{\"name\":\"");
				builder.Append("Alloc ");
				builder.Append(alloc2.AlignedSize);
				builder.Append("b\",\"ph\":\"i\",\"ts\":");
				builder.Append(num2);
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(metadata.AllocationThreadId);
				builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
				builder.Append(alloc2.AlignedSize);
				builder.Append(",\"type\":\"");
				ServerProfiler.AppendNameTo(alloc2, builder);
				builder.Append("\",\"lastMethod\":\"");
				if (alloc2.LastMethod != null)
				{
					ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
				}
				else
				{
					builder.Append("<mono-native-runtime>");
				}
				builder.Append("\"}}");
				totalMem += alloc2.AlignedSize;
				if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
				{
					EmitCounter("Main Thread", num2, "Total(B)", totalMem, builder);
				}
				else
				{
					EmitCounter("Thread", metadata.ThreadId, num2, "Total(B)", totalMem, builder);
				}
				break;
			}
			case ServerProfiler.Mark.Type.AllocWithStack:
			{
				ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
				ptr += sizeof(ServerProfiler.Alloc);
				long num = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
				builder.Append(",{\"name\":\"");
				builder.Append("Alloc ");
				builder.Append(alloc.AlignedSize);
				builder.Append("b\",\"ph\":\"i\",\"ts\":");
				builder.Append(num);
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(metadata.ThreadId);
				builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
				builder.Append(alloc.AlignedSize);
				builder.Append(",\"type\":\"");
				ServerProfiler.AppendNameTo(alloc, builder);
				builder.Append("\",\"lastMethod\":\"");
				if (alloc.LastMethod != null)
				{
					ServerProfiler.AppendNameTo(alloc.LastMethod, builder);
				}
				else
				{
					builder.Append("<mono-native-runtime>");
				}
				builder.Append('"');
				byte b = *ptr;
				ptr++;
				if (b > 0)
				{
					builder.Append(",\"callstack\":{");
					ServerProfiler.Native.MonoMethod** ptr2 = (ServerProfiler.Native.MonoMethod**)ptr;
					for (byte b2 = 0; b2 < b; b2++)
					{
						ServerProfiler.Native.MonoMethod* method = ptr2[(int)b2];
						builder.Append('"');
						char c = (char)(b2 + 32);
						if (c >= '"')
						{
							c = (char)(c + 1);
						}
						if (c >= '.')
						{
							c = (char)(c + 1);
						}
						if (c >= '\\')
						{
							c = (char)(c + 1);
						}
						if (c < '\u007f')
						{
							builder.Append(c);
						}
						else
						{
							builder.Append(b2);
						}
						builder.Append("\":\"");
						ServerProfiler.AppendNameTo(method, builder);
						builder.Append('"');
						if (b2 != b - 1)
						{
							builder.Append(',');
						}
					}
					builder.Append('}');
				}
				builder.Append("}}");
				totalMem += alloc.AlignedSize;
				if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
				{
					EmitCounter("Main Thread", num, "Total(B)", totalMem, builder);
				}
				else
				{
					EmitCounter("Thread", metadata.ThreadId, num, "Total(B)", totalMem, builder);
				}
				break;
			}
			case ServerProfiler.Mark.Type.GCBegin:
				builder.Append(",{\"name\":\"");
				builder.Append("GC.Collect");
				builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append("}");
				break;
			}
		}

		private static void AddMark(ServerProfiler.Mark mark, string name, int threadId, long startTimestamp, StringStream builder)
		{
			switch (mark.Event)
			{
			case ServerProfiler.Mark.Type.Enter:
				builder.Append(",{\"name\":\"");
				builder.Append(name);
				builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadId);
				builder.Append("}");
				break;
			case ServerProfiler.Mark.Type.Exit:
			case ServerProfiler.Mark.Type.Exception:
				builder.Append(",{\"ph\":\"E\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadId);
				builder.Append("}");
				break;
			}
		}

		private static void EmitCounter(string markName, long offset, string counterName, ulong value, StringStream builder)
		{
			builder.Append(",{\"name\":\"");
			builder.Append(markName);
			builder.Append("\",\"ph\":\"C\",\"ts\":");
			builder.Append(offset);
			builder.Append(",\"args\":{\"");
			builder.Append(counterName);
			builder.Append("\":");
			builder.Append(value);
			builder.Append("}}");
		}

		private static void EmitCounter(string markName, int threadId, long offset, string counterName, ulong value, StringStream builder)
		{
			builder.Append(",{\"name\":\"");
			builder.Append(markName);
			builder.Append(" ");
			builder.Append(threadId);
			builder.Append("\",\"ph\":\"C\",\"ts\":");
			builder.Append(offset);
			builder.Append(",\"args\":{\"");
			builder.Append(counterName);
			builder.Append("\":");
			builder.Append(value);
			builder.Append("}}");
		}

		private unsafe static bool FindStartingDepth(in ServerProfiler.Profile threadProfile, uint start, uint end, out int minDepth)
		{
			int num = 0;
			minDepth = 0;
			uint readInd = start;
			while (readInd < end)
			{
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(threadProfile.Data + readInd);
				num += AdjustCallstackDepth(in mark);
				if (mark.Event == ServerProfiler.Mark.Type.Exit || mark.Event == ServerProfiler.Mark.Type.Exception)
				{
					minDepth = Math.Min(num, minDepth);
				}
				if (!AdvanceReadInd(in mark, threadProfile.Data, ref readInd))
				{
					return false;
				}
			}
			return true;
		}

		private static int AdjustCallstackDepth(in ServerProfiler.Mark mark)
		{
			switch (mark.Event)
			{
			case ServerProfiler.Mark.Type.Enter:
				return 1;
			case ServerProfiler.Mark.Type.Exit:
			case ServerProfiler.Mark.Type.Exception:
				return -1;
			default:
				return 0;
			}
		}
	}

	public static class Binary
	{
		private enum Section : byte
		{
			Info,
			Thread,
			Marks
		}

		private struct SectionBlock : IDisposable
		{
			private MemoryStream stream;

			private long startPos;

			public static SectionBlock New(Section section, MemoryStream stream)
			{
				SectionBlock result = default(SectionBlock);
				result.stream = stream;
				result.startPos = stream.Position;
				result.Begin(section);
				return result;
			}

			private void Begin(Section section)
			{
				Write(4276993775u);
				Write((byte)section);
				Write(ulong.MaxValue);
			}

			private void End()
			{
				long num = startPos + 5;
				long num2 = stream.Position - num - 8;
				byte[] buffer = stream.GetBuffer();
				for (byte b = 0; b < 8; b++)
				{
					buffer[num + b] = (byte)(num2 >> 56 - b * 8);
				}
				Write(3735928559u);
			}

			public void Write(string text)
			{
				Write((ushort)text.Length);
				for (int i = 0; i < text.Length; i++)
				{
					stream.WriteByte((byte)text[i]);
				}
			}

			public void Write(ulong value)
			{
				for (byte b = 0; b < 8; b++)
				{
					stream.WriteByte((byte)(value >> 56 - b * 8));
				}
			}

			public void Write(uint value)
			{
				for (byte b = 0; b < 4; b++)
				{
					stream.WriteByte((byte)(value >> 24 - b * 8));
				}
			}

			public void Write(ushort value)
			{
				stream.WriteByte((byte)(value >> 8));
				stream.WriteByte((byte)value);
			}

			public void Write(byte value)
			{
				stream.WriteByte(value);
			}

			void IDisposable.Dispose()
			{
				End();
			}
		}

		public unsafe static void Export(string filename, IList<ServerProfiler.Profile> profiles)
		{
			Debug.Log((object)"Starting BIN snapshot generation...");
			MemoryStream memoryStream = new MemoryStream(134217728);
			using (SectionBlock sectionBlock = SectionBlock.New(Section.Info, memoryStream))
			{
				sectionBlock.Write("Nothing");
			}
			foreach (ServerProfiler.Profile profile in profiles)
			{
				using SectionBlock sectionBlock2 = SectionBlock.New(Section.Thread, memoryStream);
				sectionBlock2.Write((uint)profile.ThreadId);
				using SectionBlock sectionBlock3 = SectionBlock.New(Section.Marks, memoryStream);
				uint readInd = 0u;
				while (readInd < profile.WriteEnd)
				{
					byte* ptr = profile.Data + readInd;
					ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
					sectionBlock3.Write((byte)mark.Event);
					sectionBlock3.Write((ulong)mark.Timestamp);
					switch (mark.Event)
					{
					case ServerProfiler.Mark.Type.Enter:
						ServerProfiler.SerializeNameTo(*(ServerProfiler.Native.MonoMethod**)(ptr + sizeof(ServerProfiler.Mark)), memoryStream);
						break;
					case ServerProfiler.Mark.Type.Alloc:
					{
						ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr + sizeof(ServerProfiler.Mark));
						ServerProfiler.SerializeNameTo(alloc, memoryStream);
						sectionBlock3.Write(alloc.AlignedSize);
						break;
					}
					}
					AdvanceReadInd(in mark, profile.Data, ref readInd);
				}
			}
			Debug.Log((object)"Generation done, compressing...");
			byte[] array = new byte[memoryStream.Position];
			Buffer.BlockCopy(memoryStream.GetBuffer(), 0, array, 0, (int)memoryStream.Position);
			string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
			if (!Directory.Exists(text))
			{
				Directory.CreateDirectory(text);
			}
			File.WriteAllBytes(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".bin.gz")), Compression.Compress(array));
			Debug.Log((object)"Snapshot bin export done!");
		}
	}

	private const string OutputDir = "profiler";

	private unsafe static void Preprocess(IList<ServerProfiler.Profile> profiles, out MainThreadInfo mainInfo, out uint totalBytes)
	{
		mainInfo = default(MainThreadInfo);
		totalBytes = 0u;
		uint num = 0u;
		foreach (ServerProfiler.Profile profile in profiles)
		{
			if (profile.ThreadId == ServerProfiler.GetMainThreadId())
			{
				mainInfo.SyncIndices = new List<uint>(10);
				mainInfo.FrameStarts = new List<uint>(10);
				sbyte b = 0;
				sbyte b2 = 0;
				uint num2 = 0u;
				uint num3 = 0u;
				uint readInd = 0u;
				while (readInd < profile.WriteEnd)
				{
					ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(profile.Data + readInd);
					switch (mark.Event)
					{
					case ServerProfiler.Mark.Type.Enter:
						b++;
						if (num3 <= num2)
						{
							num3 = readInd;
						}
						break;
					case ServerProfiler.Mark.Type.Exit:
					case ServerProfiler.Mark.Type.Exception:
						b--;
						if (b < b2)
						{
							b2 = b;
							num2 = readInd;
						}
						break;
					case ServerProfiler.Mark.Type.Sync:
						mainInfo.SyncIndices.Add(readInd);
						mainInfo.FrameStarts.Add(num3);
						mainInfo.Frames++;
						b = 0;
						b2 = 0;
						break;
					}
					AdvanceReadInd(in mark, profile.Data, ref readInd);
				}
				uint num4 = 0u;
				long num5 = profile.Timestamp;
				for (int i = 0; i < mainInfo.Frames; i++)
				{
					uint num6 = mainInfo.SyncIndices[i];
					long timestamp = Unsafe.ReadUnaligned<ServerProfiler.Mark>(profile.Data + num6).Timestamp;
					_ = ServerProfiler.TimestampToTimespan(timestamp - num5).TotalMilliseconds;
					uint num7 = num6 - num4;
					num += num7;
					num5 = timestamp;
					num4 = num6;
				}
				totalBytes += num;
			}
			else
			{
				totalBytes += profile.WriteEnd;
			}
		}
		Debug.Log((object)("Total data: " + NumberExtensions.FormatBytes<uint>(totalBytes, false) + " (main: " + NumberExtensions.FormatBytes<uint>(num, false) + ", workers: " + NumberExtensions.FormatBytes<uint>(totalBytes - num, false) + ")"));
	}

	public unsafe static bool AdvanceReadInd(in ServerProfiler.Mark mark, byte* data, ref uint readInd)
	{
		readInd += (uint)sizeof(ServerProfiler.Mark);
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			readInd += (uint)sizeof(ServerProfiler.Native.MonoMethod*);
			break;
		case ServerProfiler.Mark.Type.Alloc:
			readInd += (uint)sizeof(ServerProfiler.Alloc);
			break;
		case ServerProfiler.Mark.Type.AllocWithStack:
		{
			readInd += (uint)sizeof(ServerProfiler.Alloc);
			byte b = data[readInd];
			readInd++;
			readInd += (uint)(b * sizeof(ServerProfiler.Native.MonoMethod*));
			break;
		}
		default:
			Debug.LogError((object)"Unhandled ServerProfiler.Mark.Type!");
			return false;
		case ServerProfiler.Mark.Type.Sync:
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
		case ServerProfiler.Mark.Type.GCBegin:
		case ServerProfiler.Mark.Type.GCEnd:
			break;
		}
		return true;
	}
}


using System.Collections.Generic;

private struct MainThreadInfo
{
	public List<uint> SyncIndices;

	public List<uint> FrameStarts;

	public uint Frames;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Ionic.Zlib;
using UnityEngine;

public static class JSON
{
	private struct ThreadMetadata
	{
		internal int ThreadId;

		internal int AllocationThreadId;

		internal void Emit(StringStream builder)
		{
			bool isMainThread = ThreadId == ServerProfiler.GetMainThreadId();
			EmitThreadName(isMainThread, isAllocThread: false, ThreadId, ThreadId, builder);
			builder.Append(',');
			EmitThreadName(isMainThread, isAllocThread: true, AllocationThreadId, ThreadId, builder);
		}

		private static void EmitThreadName(bool isMainThread, bool isAllocThread, int id, int origId, StringStream builder)
		{
			builder.Append("{\"name\":\"thread_name\",\"ph\":\"M\",\"pid\":0,\"tid\":");
			builder.Append(id);
			builder.Append(",\"args\":{\"name\":\"");
			if (isMainThread)
			{
				builder.Append("Main Thread");
			}
			else
			{
				builder.Append("Thread");
			}
			if (isAllocThread)
			{
				if (!isMainThread)
				{
					builder.Append(' ');
					builder.Append(origId);
				}
				builder.Append(" Allocations");
			}
			builder.Append("\"}}");
		}
	}

	public class StringStream : MemoryStream
	{
		private GZipStream outputStream;

		public StringStream(int capacity, GZipStream outputStream)
			: base(capacity)
		{
			this.outputStream = outputStream;
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (base.Position + count < base.Capacity)
			{
				base.Write(buffer, offset, count);
				return;
			}
			int num = base.Capacity - (int)base.Position;
			if (num > 0)
			{
				base.Write(buffer, offset, num);
			}
			Flush();
			if (count - num > 0)
			{
				base.Write(buffer, offset + num, count - num);
			}
		}

		public override void Write(ReadOnlySpan<byte> source)
		{
			throw new NotSupportedException("Write(ReadOnlySpan<byte>) not implemented!");
		}

		public override void WriteByte(byte value)
		{
			if (base.Position + 1 < base.Capacity)
			{
				base.WriteByte(value);
				return;
			}
			Flush();
			base.WriteByte(value);
		}

		public void Append(char c)
		{
			WriteByte((byte)c);
		}

		public void Append(string text)
		{
			foreach (char c in text)
			{
				Append(c);
			}
		}

		public void Append(int num)
		{
			Span<char> destination = stackalloc char[32];
			num.TryFormat(destination, out var charsWritten);
			Append(destination.Slice(0, charsWritten));
		}

		public void Append(long num)
		{
			Span<char> destination = stackalloc char[32];
			num.TryFormat(destination, out var charsWritten);
			Append(destination.Slice(0, charsWritten));
		}

		public void Append(ulong num)
		{
			Span<char> destination = stackalloc char[32];
			num.TryFormat(destination, out var charsWritten);
			Append(destination.Slice(0, charsWritten));
		}

		public void Append(ReadOnlySpan<char> chars)
		{
			ReadOnlySpan<char> readOnlySpan = chars;
			for (int i = 0; i < readOnlySpan.Length; i++)
			{
				char c = readOnlySpan[i];
				Append(c);
			}
		}

		public override void Flush()
		{
			long position = Position;
			if (position > 0)
			{
				byte[] buffer = GetBuffer();
				((Stream)(object)outputStream).Write(buffer, 0, (int)position);
				Position = 0L;
			}
		}
	}

	public static bool Export(string filename, IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Expected O, but got Unknown
		try
		{
			Debug.Log((object)"Starting JSON snapshot generation...");
			Preprocess(profiles, out var mainInfo, out var _);
			string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
			if (!Directory.Exists(text))
			{
				Directory.CreateDirectory(text);
			}
			using (FileStream fileStream = new FileStream(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".json.gz")), FileMode.Create, FileAccess.Write, FileShare.None, 20480))
			{
				GZipStream val = new GZipStream((Stream)fileStream, (CompressionMode)0);
				try
				{
					val.FlushMode = (FlushType)2;
					using StringStream stringStream = new StringStream(16384, val);
					stringStream.Append('[');
					int num = 0;
					foreach (ServerProfiler.Profile profile2 in profiles)
					{
						num = Math.Max(num, profile2.ThreadId);
					}
					List<ThreadMetadata> list = new List<ThreadMetadata>();
					for (int i = 0; i < profiles.Count; i++)
					{
						ServerProfiler.Profile profile = profiles[i];
						ThreadMetadata item = default(ThreadMetadata);
						item.ThreadId = profile.ThreadId;
						num = (item.AllocationThreadId = num + 1);
						if (i != 0)
						{
							stringStream.Append(',');
						}
						item.Emit(stringStream);
						list.Add(item);
					}
					long firstMarkTimestamp = 0L;
					for (int j = 0; j < profiles.Count; j++)
					{
						ServerProfiler.Profile mainProfile = profiles[j];
						if (mainProfile.ThreadId == ServerProfiler.GetMainThreadId())
						{
							if (ProcessMainProfile(in mainProfile, in mainInfo, list[j], stringStream, out firstMarkTimestamp))
							{
								break;
							}
							return false;
						}
					}
					for (int k = 0; k < profiles.Count; k++)
					{
						ServerProfiler.Profile workerProfile = profiles[k];
						if (workerProfile.ThreadId != ServerProfiler.GetMainThreadId() && !ProcessWorkerProfile(in workerProfile, list[k], firstMarkTimestamp, stringStream))
						{
							return false;
						}
					}
					ProcessMemoryState(in memState, firstMarkTimestamp, stringStream);
					stringStream.Append("]");
					stringStream.Flush();
					Debug.Log((object)"Generation done, flushing...");
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			Debug.Log((object)"Snapshot json export done!");
			return true;
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			return false;
		}
	}

	private unsafe static bool ProcessMainProfile(in ServerProfiler.Profile mainProfile, in MainThreadInfo info, in ThreadMetadata metadata, StringStream builder, out long firstMarkTimestamp)
	{
		if (info.FrameStarts == null || info.Frames == 0)
		{
			Debug.LogError((object)"ServerProfiler: Didn't find any main frame info!");
			firstMarkTimestamp = 0L;
			return false;
		}
		int num = 0;
		byte* data = mainProfile.Data;
		uint num2 = info.FrameStarts[0];
		firstMarkTimestamp = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num2).Timestamp;
		long num3 = 0L;
		for (int i = 0; i < info.Frames; i++)
		{
			uint num4 = info.FrameStarts[i];
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num4);
			uint num5 = mainProfile.WriteEnd;
			if (i < info.Frames - 1)
			{
				num5 = info.FrameStarts[i + 1];
			}
			ServerProfiler.Mark mark2 = default(ServerProfiler.Mark);
			mark2.Event = ServerProfiler.Mark.Type.Enter;
			mark2.Timestamp = mark.Timestamp;
			AddMark(mark2, $"UnityFrame{i}", mainProfile.ThreadId, firstMarkTimestamp, builder);
			uint totalMem = 0u;
			long offset = ServerProfiler.TimestampToMicros(mark.Timestamp - firstMarkTimestamp);
			EmitCounter("Main Thread", offset, "Total(B)", totalMem, builder);
			uint readInd = num4;
			while (readInd < num5)
			{
				ServerProfiler.Mark mark3 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + readInd);
				num3 = mark3.Timestamp;
				num += AdjustCallstackDepth(in mark3);
				if (num < 0)
				{
					Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {num}, offset: {readInd}, frame: {i}");
					return false;
				}
				AddMark(in mainProfile, in metadata, readInd, ref totalMem, firstMarkTimestamp, builder);
				if (!AdvanceReadInd(in mark3, data, ref readInd))
				{
					return false;
				}
			}
			long timestamp = ((i < info.Frames - 1) ? Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num5).Timestamp : num3);
			mark2 = default(ServerProfiler.Mark);
			mark2.Event = ServerProfiler.Mark.Type.Exit;
			mark2.Timestamp = timestamp;
			AddMark(mark2, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
		}
		while (num > 0)
		{
			ServerProfiler.Mark mark4 = default(ServerProfiler.Mark);
			mark4.Event = ServerProfiler.Mark.Type.Exit;
			mark4.Timestamp = num3;
			AddMark(mark4, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
			num--;
		}
		return true;
	}

	private unsafe static bool ProcessWorkerProfile(in ServerProfiler.Profile workerProfile, in ThreadMetadata metadata, long firstMarkTimestamp, StringStream builder)
	{
		uint readInd = 0u;
		int num = 0;
		while (readInd < workerProfile.WriteEnd)
		{
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd);
			if (mark.Timestamp >= firstMarkTimestamp)
			{
				break;
			}
			if (mark.Event == ServerProfiler.Mark.Type.Sync)
			{
				Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
				return false;
			}
			num += AdjustCallstackDepth(in mark);
			if (!AdvanceReadInd(in mark, workerProfile.Data, ref readInd))
			{
				return false;
			}
		}
		if (readInd >= workerProfile.WriteEnd)
		{
			return true;
		}
		bool flag = false;
		uint readInd2 = readInd;
		while (readInd2 < workerProfile.WriteEnd)
		{
			ServerProfiler.Mark mark2 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd2);
			if (mark2.Event == ServerProfiler.Mark.Type.Sync)
			{
				Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
				return false;
			}
			if (mark2.Event != ServerProfiler.Mark.Type.Alloc)
			{
				flag = true;
				break;
			}
			if (!AdvanceReadInd(in mark2, workerProfile.Data, ref readInd2))
			{
				return false;
			}
		}
		if (!flag)
		{
			return true;
		}
		if (!FindStartingDepth(in workerProfile, 0u, workerProfile.WriteEnd, out var minDepth))
		{
			return false;
		}
		minDepth = num - minDepth;
		for (int num2 = minDepth; num2 > 0; num2--)
		{
			ServerProfiler.Mark mark3 = default(ServerProfiler.Mark);
			mark3.Event = ServerProfiler.Mark.Type.Enter;
			mark3.Timestamp = firstMarkTimestamp;
			AddMark(mark3, "Unknown", workerProfile.ThreadId, firstMarkTimestamp, builder);
		}
		uint totalMem = 0u;
		long timestamp = 0L;
		uint readInd3 = readInd;
		while (readInd3 < workerProfile.WriteEnd)
		{
			ServerProfiler.Mark mark4 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd3);
			timestamp = mark4.Timestamp;
			minDepth += AdjustCallstackDepth(in mark4);
			if (minDepth < 0)
			{
				Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {minDepth}, offset: {readInd3}, thread: {workerProfile.ThreadId}");
				return false;
			}
			if (mark4.Event == ServerProfiler.Mark.Type.Alloc || (mark4.Event == ServerProfiler.Mark.Type.AllocWithStack && totalMem == 0))
			{
				EmitCounter("Thread", metadata.ThreadId, 0L, "Total(B)", 0uL, builder);
			}
			AddMark(in workerProfile, in metadata, readInd3, ref totalMem, firstMarkTimestamp, builder);
			if (!AdvanceReadInd(in mark4, workerProfile.Data, ref readInd3))
			{
				return false;
			}
		}
		while (minDepth > 0)
		{
			ServerProfiler.Mark mark5 = default(ServerProfiler.Mark);
			mark5.Event = ServerProfiler.Mark.Type.Exit;
			mark5.Timestamp = timestamp;
			AddMark(mark5, null, workerProfile.ThreadId, firstMarkTimestamp, builder);
			minDepth--;
		}
		return true;
	}

	private unsafe static void ProcessMemoryState(in ServerProfiler.MemoryState memState, long firstMarkTimestamp, StringStream builder)
	{
		ulong num = 0uL;
		ulong num2 = 0uL;
		for (uint num3 = 0u; num3 < memState.Created; num3++)
		{
			ServerProfiler.MemoryReading memoryReading = memState.Readings[num3];
			long timestamp = memoryReading.Timestamp;
			if (timestamp >= firstMarkTimestamp)
			{
				ulong num4 = memoryReading.WorkingSet / 1024;
				if (num4 != num)
				{
					long offset = ((num == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
					EmitCounter("ws", offset, "WorkingSet(KB)", num4, builder);
					num = num4;
				}
				ulong num5 = memoryReading.VirtualSet / 1024;
				if (num5 != num2)
				{
					long offset2 = ((num2 == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
					EmitCounter("vs", offset2, "VirtualSet(KB)", num5, builder);
					num2 = num5;
				}
			}
		}
	}

	private unsafe static void AddMark(in ServerProfiler.Profile threadProfile, in ThreadMetadata metadata, uint markInd, ref uint totalMem, long startTimestamp, StringStream builder)
	{
		byte* ptr = threadProfile.Data + markInd;
		ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
		ptr += sizeof(ServerProfiler.Mark);
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			builder.Append(",{\"name\":\"");
			ServerProfiler.AppendNameTo(*(ServerProfiler.Native.MonoMethod**)ptr, builder);
			builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append("}");
			break;
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
		case ServerProfiler.Mark.Type.GCEnd:
			builder.Append(",{\"ph\":\"E\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append("}");
			break;
		case ServerProfiler.Mark.Type.Alloc:
		{
			ServerProfiler.Alloc alloc2 = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
			long num2 = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
			builder.Append(",{\"name\":\"");
			builder.Append("Alloc ");
			builder.Append(alloc2.AlignedSize);
			builder.Append("b\",\"ph\":\"i\",\"ts\":");
			builder.Append(num2);
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
			builder.Append(alloc2.AlignedSize);
			builder.Append(",\"type\":\"");
			ServerProfiler.AppendNameTo(alloc2, builder);
			builder.Append("\",\"lastMethod\":\"");
			if (alloc2.LastMethod != null)
			{
				ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
			}
			else
			{
				builder.Append("<mono-native-runtime>");
			}
			builder.Append("\"}}");
			builder.Append(",{\"name\":\"");
			builder.Append("Alloc ");
			builder.Append(alloc2.AlignedSize);
			builder.Append("b\",\"ph\":\"i\",\"ts\":");
			builder.Append(num2);
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(metadata.AllocationThreadId);
			builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
			builder.Append(alloc2.AlignedSize);
			builder.Append(",\"type\":\"");
			ServerProfiler.AppendNameTo(alloc2, builder);
			builder.Append("\",\"lastMethod\":\"");
			if (alloc2.LastMethod != null)
			{
				ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
			}
			else
			{
				builder.Append("<mono-native-runtime>");
			}
			builder.Append("\"}}");
			totalMem += alloc2.AlignedSize;
			if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
			{
				EmitCounter("Main Thread", num2, "Total(B)", totalMem, builder);
			}
			else
			{
				EmitCounter("Thread", metadata.ThreadId, num2, "Total(B)", totalMem, builder);
			}
			break;
		}
		case ServerProfiler.Mark.Type.AllocWithStack:
		{
			ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
			ptr += sizeof(ServerProfiler.Alloc);
			long num = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
			builder.Append(",{\"name\":\"");
			builder.Append("Alloc ");
			builder.Append(alloc.AlignedSize);
			builder.Append("b\",\"ph\":\"i\",\"ts\":");
			builder.Append(num);
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(metadata.ThreadId);
			builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
			builder.Append(alloc.AlignedSize);
			builder.Append(",\"type\":\"");
			ServerProfiler.AppendNameTo(alloc, builder);
			builder.Append("\",\"lastMethod\":\"");
			if (alloc.LastMethod != null)
			{
				ServerProfiler.AppendNameTo(alloc.LastMethod, builder);
			}
			else
			{
				builder.Append("<mono-native-runtime>");
			}
			builder.Append('"');
			byte b = *ptr;
			ptr++;
			if (b > 0)
			{
				builder.Append(",\"callstack\":{");
				ServerProfiler.Native.MonoMethod** ptr2 = (ServerProfiler.Native.MonoMethod**)ptr;
				for (byte b2 = 0; b2 < b; b2++)
				{
					ServerProfiler.Native.MonoMethod* method = ptr2[(int)b2];
					builder.Append('"');
					char c = (char)(b2 + 32);
					if (c >= '"')
					{
						c = (char)(c + 1);
					}
					if (c >= '.')
					{
						c = (char)(c + 1);
					}
					if (c >= '\\')
					{
						c = (char)(c + 1);
					}
					if (c < '\u007f')
					{
						builder.Append(c);
					}
					else
					{
						builder.Append(b2);
					}
					builder.Append("\":\"");
					ServerProfiler.AppendNameTo(method, builder);
					builder.Append('"');
					if (b2 != b - 1)
					{
						builder.Append(',');
					}
				}
				builder.Append('}');
			}
			builder.Append("}}");
			totalMem += alloc.AlignedSize;
			if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
			{
				EmitCounter("Main Thread", num, "Total(B)", totalMem, builder);
			}
			else
			{
				EmitCounter("Thread", metadata.ThreadId, num, "Total(B)", totalMem, builder);
			}
			break;
		}
		case ServerProfiler.Mark.Type.GCBegin:
			builder.Append(",{\"name\":\"");
			builder.Append("GC.Collect");
			builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append("}");
			break;
		}
	}

	private static void AddMark(ServerProfiler.Mark mark, string name, int threadId, long startTimestamp, StringStream builder)
	{
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			builder.Append(",{\"name\":\"");
			builder.Append(name);
			builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadId);
			builder.Append("}");
			break;
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
			builder.Append(",{\"ph\":\"E\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadId);
			builder.Append("}");
			break;
		}
	}

	private static void EmitCounter(string markName, long offset, string counterName, ulong value, StringStream builder)
	{
		builder.Append(",{\"name\":\"");
		builder.Append(markName);
		builder.Append("\",\"ph\":\"C\",\"ts\":");
		builder.Append(offset);
		builder.Append(",\"args\":{\"");
		builder.Append(counterName);
		builder.Append("\":");
		builder.Append(value);
		builder.Append("}}");
	}

	private static void EmitCounter(string markName, int threadId, long offset, string counterName, ulong value, StringStream builder)
	{
		builder.Append(",{\"name\":\"");
		builder.Append(markName);
		builder.Append(" ");
		builder.Append(threadId);
		builder.Append("\",\"ph\":\"C\",\"ts\":");
		builder.Append(offset);
		builder.Append(",\"args\":{\"");
		builder.Append(counterName);
		builder.Append("\":");
		builder.Append(value);
		builder.Append("}}");
	}

	private unsafe static bool FindStartingDepth(in ServerProfiler.Profile threadProfile, uint start, uint end, out int minDepth)
	{
		int num = 0;
		minDepth = 0;
		uint readInd = start;
		while (readInd < end)
		{
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(threadProfile.Data + readInd);
			num += AdjustCallstackDepth(in mark);
			if (mark.Event == ServerProfiler.Mark.Type.Exit || mark.Event == ServerProfiler.Mark.Type.Exception)
			{
				minDepth = Math.Min(num, minDepth);
			}
			if (!AdvanceReadInd(in mark, threadProfile.Data, ref readInd))
			{
				return false;
			}
		}
		return true;
	}

	private static int AdjustCallstackDepth(in ServerProfiler.Mark mark)
	{
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			return 1;
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
			return -1;
		default:
			return 0;
		}
	}
}


private struct ThreadMetadata
{
	internal int ThreadId;

	internal int AllocationThreadId;

	internal void Emit(StringStream builder)
	{
		bool isMainThread = ThreadId == ServerProfiler.GetMainThreadId();
		EmitThreadName(isMainThread, isAllocThread: false, ThreadId, ThreadId, builder);
		builder.Append(',');
		EmitThreadName(isMainThread, isAllocThread: true, AllocationThreadId, ThreadId, builder);
	}

	private static void EmitThreadName(bool isMainThread, bool isAllocThread, int id, int origId, StringStream builder)
	{
		builder.Append("{\"name\":\"thread_name\",\"ph\":\"M\",\"pid\":0,\"tid\":");
		builder.Append(id);
		builder.Append(",\"args\":{\"name\":\"");
		if (isMainThread)
		{
			builder.Append("Main Thread");
		}
		else
		{
			builder.Append("Thread");
		}
		if (isAllocThread)
		{
			if (!isMainThread)
			{
				builder.Append(' ');
				builder.Append(origId);
			}
			builder.Append(" Allocations");
		}
		builder.Append("\"}}");
	}
}


using System;
using System.IO;
using Ionic.Zlib;

public class StringStream : MemoryStream
{
	private GZipStream outputStream;

	public StringStream(int capacity, GZipStream outputStream)
		: base(capacity)
	{
		this.outputStream = outputStream;
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		if (base.Position + count < base.Capacity)
		{
			base.Write(buffer, offset, count);
			return;
		}
		int num = base.Capacity - (int)base.Position;
		if (num > 0)
		{
			base.Write(buffer, offset, num);
		}
		Flush();
		if (count - num > 0)
		{
			base.Write(buffer, offset + num, count - num);
		}
	}

	public override void Write(ReadOnlySpan<byte> source)
	{
		throw new NotSupportedException("Write(ReadOnlySpan<byte>) not implemented!");
	}

	public override void WriteByte(byte value)
	{
		if (base.Position + 1 < base.Capacity)
		{
			base.WriteByte(value);
			return;
		}
		Flush();
		base.WriteByte(value);
	}

	public void Append(char c)
	{
		WriteByte((byte)c);
	}

	public void Append(string text)
	{
		foreach (char c in text)
		{
			Append(c);
		}
	}

	public void Append(int num)
	{
		Span<char> destination = stackalloc char[32];
		num.TryFormat(destination, out var charsWritten);
		Append(destination.Slice(0, charsWritten));
	}

	public void Append(long num)
	{
		Span<char> destination = stackalloc char[32];
		num.TryFormat(destination, out var charsWritten);
		Append(destination.Slice(0, charsWritten));
	}

	public void Append(ulong num)
	{
		Span<char> destination = stackalloc char[32];
		num.TryFormat(destination, out var charsWritten);
		Append(destination.Slice(0, charsWritten));
	}

	public void Append(ReadOnlySpan<char> chars)
	{
		ReadOnlySpan<char> readOnlySpan = chars;
		for (int i = 0; i < readOnlySpan.Length; i++)
		{
			char c = readOnlySpan[i];
			Append(c);
		}
	}

	public override void Flush()
	{
		long position = Position;
		if (position > 0)
		{
			byte[] buffer = GetBuffer();
			((Stream)(object)outputStream).Write(buffer, 0, (int)position);
			Position = 0L;
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch.Utility;
using UnityEngine;

public static class Binary
{
	private enum Section : byte
	{
		Info,
		Thread,
		Marks
	}

	private struct SectionBlock : IDisposable
	{
		private MemoryStream stream;

		private long startPos;

		public static SectionBlock New(Section section, MemoryStream stream)
		{
			SectionBlock result = default(SectionBlock);
			result.stream = stream;
			result.startPos = stream.Position;
			result.Begin(section);
			return result;
		}

		private void Begin(Section section)
		{
			Write(4276993775u);
			Write((byte)section);
			Write(ulong.MaxValue);
		}

		private void End()
		{
			long num = startPos + 5;
			long num2 = stream.Position - num - 8;
			byte[] buffer = stream.GetBuffer();
			for (byte b = 0; b < 8; b++)
			{
				buffer[num + b] = (byte)(num2 >> 56 - b * 8);
			}
			Write(3735928559u);
		}

		public void Write(string text)
		{
			Write((ushort)text.Length);
			for (int i = 0; i < text.Length; i++)
			{
				stream.WriteByte((byte)text[i]);
			}
		}

		public void Write(ulong value)
		{
			for (byte b = 0; b < 8; b++)
			{
				stream.WriteByte((byte)(value >> 56 - b * 8));
			}
		}

		public void Write(uint value)
		{
			for (byte b = 0; b < 4; b++)
			{
				stream.WriteByte((byte)(value >> 24 - b * 8));
			}
		}

		public void Write(ushort value)
		{
			stream.WriteByte((byte)(value >> 8));
			stream.WriteByte((byte)value);
		}

		public void Write(byte value)
		{
			stream.WriteByte(value);
		}

		void IDisposable.Dispose()
		{
			End();
		}
	}

	public unsafe static void Export(string filename, IList<ServerProfiler.Profile> profiles)
	{
		Debug.Log((object)"Starting BIN snapshot generation...");
		MemoryStream memoryStream = new MemoryStream(134217728);
		using (SectionBlock sectionBlock = SectionBlock.New(Section.Info, memoryStream))
		{
			sectionBlock.Write("Nothing");
		}
		foreach (ServerProfiler.Profile profile in profiles)
		{
			using SectionBlock sectionBlock2 = SectionBlock.New(Section.Thread, memoryStream);
			sectionBlock2.Write((uint)profile.ThreadId);
			using SectionBlock sectionBlock3 = SectionBlock.New(Section.Marks, memoryStream);
			uint readInd = 0u;
			while (readInd < profile.WriteEnd)
			{
				byte* ptr = profile.Data + readInd;
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
				sectionBlock3.Write((byte)mark.Event);
				sectionBlock3.Write((ulong)mark.Timestamp);
				switch (mark.Event)
				{
				case ServerProfiler.Mark.Type.Enter:
					ServerProfiler.SerializeNameTo(*(ServerProfiler.Native.MonoMethod**)(ptr + sizeof(ServerProfiler.Mark)), memoryStream);
					break;
				case ServerProfiler.Mark.Type.Alloc:
				{
					ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr + sizeof(ServerProfiler.Mark));
					ServerProfiler.SerializeNameTo(alloc, memoryStream);
					sectionBlock3.Write(alloc.AlignedSize);
					break;
				}
				}
				AdvanceReadInd(in mark, profile.Data, ref readInd);
			}
		}
		Debug.Log((object)"Generation done, compressing...");
		byte[] array = new byte[memoryStream.Position];
		Buffer.BlockCopy(memoryStream.GetBuffer(), 0, array, 0, (int)memoryStream.Position);
		string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
		if (!Directory.Exists(text))
		{
			Directory.CreateDirectory(text);
		}
		File.WriteAllBytes(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".bin.gz")), Compression.Compress(array));
		Debug.Log((object)"Snapshot bin export done!");
	}
}


private enum Section : byte
{
	Info,
	Thread,
	Marks
}


using System;
using System.IO;

private struct SectionBlock : IDisposable
{
	private MemoryStream stream;

	private long startPos;

	public static SectionBlock New(Section section, MemoryStream stream)
	{
		SectionBlock result = default(SectionBlock);
		result.stream = stream;
		result.startPos = stream.Position;
		result.Begin(section);
		return result;
	}

	private void Begin(Section section)
	{
		Write(4276993775u);
		Write((byte)section);
		Write(ulong.MaxValue);
	}

	private void End()
	{
		long num = startPos + 5;
		long num2 = stream.Position - num - 8;
		byte[] buffer = stream.GetBuffer();
		for (byte b = 0; b < 8; b++)
		{
			buffer[num + b] = (byte)(num2 >> 56 - b * 8);
		}
		Write(3735928559u);
	}

	public void Write(string text)
	{
		Write((ushort)text.Length);
		for (int i = 0; i < text.Length; i++)
		{
			stream.WriteByte((byte)text[i]);
		}
	}

	public void Write(ulong value)
	{
		for (byte b = 0; b < 8; b++)
		{
			stream.WriteByte((byte)(value >> 56 - b * 8));
		}
	}

	public void Write(uint value)
	{
		for (byte b = 0; b < 4; b++)
		{
			stream.WriteByte((byte)(value >> 24 - b * 8));
		}
	}

	public void Write(ushort value)
	{
		stream.WriteByte((byte)(value >> 8));
		stream.WriteByte((byte)value);
	}

	public void Write(byte value)
	{
		stream.WriteByte(value);
	}

	void IDisposable.Dispose()
	{
		End();
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using UnityEngine;

[SuppressUnmanagedCodeSecurity]
public static class ServerProfiler
{
	[StructLayout(LayoutKind.Sequential, Pack = 1, Size = 9)]
	public struct Mark
	{
		public enum Type : byte
		{
			Sync,
			Enter,
			Exit,
			Exception,
			Alloc,
			GCBegin,
			GCEnd,
			AllocWithStack
		}

		public long Timestamp;

		public Type Event;
	}

	public struct Alloc
	{
		public unsafe Native.MonoClass* Class;

		public unsafe Native.MonoMethod* LastMethod;

		public uint AlignedSize;

		public uint FlatArraySize;
	}

	public struct Profile
	{
		public unsafe byte* Data;

		private uint WriteInd;

		public uint Capacity;

		public uint WriteEnd;

		public int ThreadId;

		public long Timestamp;
	}

	[StructLayout(LayoutKind.Sequential, Size = 64)]
	public struct MemoryReading
	{
		public long Timestamp;

		public ulong WorkingSet;

		public ulong VirtualSet;
	}

	public struct MemoryState
	{
		public unsafe MemoryReading* Readings;

		public uint Created;

		public uint Capacity;
	}

	public enum NotifyMetric : byte
	{
		TotalAllocCount,
		TotalMem,
		MainAllocCount,
		MainMem,
		WorkerAllocCount,
		WorkerMem,
		Count
	}

	public static class Native
	{
		[StructLayout(LayoutKind.Explicit)]
		public struct MonoImage
		{
			[FieldOffset(48)]
			public unsafe byte* AssemblyName;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoClass
		{
			private const int ImageOffset = 56;

			[FieldOffset(56)]
			public unsafe MonoImage* Image;

			[FieldOffset(64)]
			public unsafe byte* Name;

			[FieldOffset(72)]
			public unsafe byte* Namespace;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoMethod
		{
			[FieldOffset(8)]
			public unsafe MonoClass* Class;

			[FieldOffset(24)]
			public unsafe byte* Name;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoVTable
		{
			[FieldOffset(0)]
			public unsafe MonoClass* Class;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoObject
		{
			[FieldOffset(0)]
			public unsafe MonoVTable* VTable;
		}

		public enum StorageType : byte
		{
			FrameLimited,
			FixedBuffer
		}

		[DllImport("ServerProfiler.Core")]
		public static extern void Install();

		[DllImport("ServerProfiler.Core")]
		public static extern void SetStorageType(byte aStorageType);

		[DllImport("ServerProfiler.Core")]
		public static extern bool SetFramesToRecord(byte aFrameCount);

		[DllImport("ServerProfiler.Core")]
		public static extern bool SetFixedBufferCap(uint aMainThreadCap, uint aWorkerThreadCap);

		[DllImport("ServerProfiler.Core")]
		public static extern void TakeSnapshot();

		[DllImport("ServerProfiler.Core")]
		public static extern void StartContinuousProfiling(byte aMaxStackDepth);

		[DllImport("ServerProfiler.Core")]
		public static extern void StopContinuousProfiling();

		[DllImport("ServerProfiler.Core")]
		public static extern void ResumeContinuousProfiling();

		[DllImport("ServerProfiler.Core")]
		public static extern void SetContinuousProfilerNotifySettings(NotifyMetric aSetting, uint aValue);

		[DllImport("ServerProfiler.Core")]
		public static extern bool OnFrameEnd();

		[DllImport("ServerProfiler.Core")]
		public unsafe static extern void GetData(out Profile** profiles, out byte count);

		[DllImport("ServerProfiler.Core")]
		public unsafe static extern void GetMemoryUsage(out MemoryState* state);

		[DllImport("ServerProfiler.Core")]
		public static extern bool ReleaseResources();
	}

	public const byte MaxFrames = 10;

	private static bool canBeActivated;

	private static Action<IList<Profile>, MemoryState> onDoneCallback;

	private static bool isContinuous;

	private static int mainThreadId;

	public static bool IsRunning => onDoneCallback != null;

	[RuntimeInitializeOnLoadMethod(/*Could not decode attribute arguments.*/)]
	public static void Init()
	{
		if (!Environment.CommandLine.Contains("-enableProfiler"))
		{
			Debug.Log((object)"Profiler Disabled!");
			return;
		}
		mainThreadId = Environment.CurrentManagedThreadId;
		Native.Install();
		canBeActivated = true;
		Debug.Log((object)"Profiler Initialized!");
		PostUpdateHook.EndOfFrame = (Action)Delegate.Combine(PostUpdateHook.EndOfFrame, new Action(OnFrameEnd));
	}

	public static void RecordNextFrames(int frames, Action<IList<Profile>, MemoryState> onDone)
	{
		if (onDone != null && IsEnabled())
		{
			onDoneCallback = onDone;
			Native.SetStorageType(0);
			Native.SetFramesToRecord((byte)Math.Clamp(frames, 1, 10));
			Native.TakeSnapshot();
			isContinuous = false;
		}
	}

	public static void RecordIntoBuffer(uint mainThreadCap, uint workerThreadCap, Action<IList<Profile>, MemoryState> onDone)
	{
		if (onDone != null && IsEnabled())
		{
			onDoneCallback = onDone;
			Native.SetStorageType(1);
			Native.SetFixedBufferCap(mainThreadCap, workerThreadCap);
			Native.TakeSnapshot();
			isContinuous = false;
		}
	}

	public static void StartContinuousRecording(byte maxStackDepth, Action<IList<Profile>, MemoryState> onDone)
	{
		if (onDone != null && IsEnabled())
		{
			onDoneCallback = onDone;
			Native.SetStorageType(1);
			Native.SetFixedBufferCap(33554432u, 8388608u);
			Native.StartContinuousProfiling(maxStackDepth);
			isContinuous = true;
		}
	}

	public static void StopContinuousRecording()
	{
		Native.StopContinuousProfiling();
		onDoneCallback = null;
	}

	public static void ResumeContinuousRecording()
	{
		Native.ResumeContinuousProfiling();
	}

	public static void ReleaseResources()
	{
		Native.ReleaseResources();
	}

	public static bool IsEnabled()
	{
		return canBeActivated;
	}

	private unsafe static void OnFrameEnd()
	{
		if (!Native.OnFrameEnd())
		{
			return;
		}
		List<Profile> list = null;
		Native.GetData(out var profiles, out var count);
		list = new List<Profile>(count);
		for (byte b = 0; b < count; b++)
		{
			if (profiles[(int)b]->WriteEnd != 0)
			{
				list.Add(*profiles[(int)b]);
			}
		}
		Native.GetMemoryUsage(out var state);
		MemoryState arg = *state;
		onDoneCallback(list, arg);
		if (!isContinuous)
		{
			onDoneCallback = null;
		}
	}

	public static TimeSpan TimestampToTimespan(long stamp)
	{
		return TimeSpan.FromMilliseconds((double)stamp / 1000000.0);
	}

	public static long TimestampToMicros(long stamp)
	{
		return stamp / 1000;
	}

	public unsafe static void AppendNameTo(Native.MonoMethod* method, StringBuilder builder)
	{
		for (byte* ptr = method->Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = method->Class->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append("::");
		for (byte* ptr = method->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
	}

	public unsafe static void AppendNameTo(Native.MonoMethod* method, ProfileExporter.JSON.StringStream builder)
	{
		for (byte* ptr = method->Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = method->Class->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append("::");
		for (byte* ptr = method->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
	}

	public unsafe static void SerializeNameTo(Native.MonoMethod* method, MemoryStream stream)
	{
		long position = stream.Position;
		ushort num = 0;
		stream.WriteByte(0);
		stream.WriteByte(0);
		byte* ptr = method->Class->Image->AssemblyName;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		stream.WriteByte(33);
		num++;
		ptr = method->Class->Name;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		stream.WriteByte(58);
		stream.WriteByte(58);
		num += 2;
		ptr = method->Name;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		byte[] buffer = stream.GetBuffer();
		buffer[position] = (byte)(num >> 8);
		buffer[position + 1] = (byte)num;
	}

	public unsafe static void AppendNameTo(Alloc alloc, StringBuilder builder)
	{
		for (byte* ptr = alloc.Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = alloc.Class->Name; *ptr != 0; ptr++)
		{
			char c = (char)(*ptr);
			builder.Append(c);
			if (alloc.FlatArraySize != 0 && c == '[')
			{
				builder.Append(alloc.FlatArraySize);
			}
		}
	}

	public unsafe static void AppendNameTo(Alloc alloc, ProfileExporter.JSON.StringStream builder)
	{
		for (byte* ptr = alloc.Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = alloc.Class->Name; *ptr != 0; ptr++)
		{
			char c = (char)(*ptr);
			builder.Append(c);
			if (alloc.FlatArraySize != 0 && c == '[')
			{
				builder.Append(alloc.FlatArraySize);
			}
		}
	}

	public unsafe static void SerializeNameTo(Alloc alloc, MemoryStream stream)
	{
		long position = stream.Position;
		ushort num = 0;
		stream.WriteByte(0);
		stream.WriteByte(0);
		byte* ptr = alloc.Class->Image->AssemblyName;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		stream.WriteByte(33);
		num++;
		ptr = alloc.Class->Name;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		byte[] buffer = stream.GetBuffer();
		buffer[position] = (byte)(num >> 8);
		buffer[position + 1] = (byte)num;
	}

	public static int GetMainThreadId()
	{
		return mainThreadId;
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 1, Size = 9)]
public struct Mark
{
	public enum Type : byte
	{
		Sync,
		Enter,
		Exit,
		Exception,
		Alloc,
		GCBegin,
		GCEnd,
		AllocWithStack
	}

	public long Timestamp;

	public Type Event;
}


public enum Type : byte
{
	Sync,
	Enter,
	Exit,
	Exception,
	Alloc,
	GCBegin,
	GCEnd,
	AllocWithStack
}


public struct Alloc
{
	public unsafe Native.MonoClass* Class;

	public unsafe Native.MonoMethod* LastMethod;

	public uint AlignedSize;

	public uint FlatArraySize;
}


public struct Profile
{
	public unsafe byte* Data;

	private uint WriteInd;

	public uint Capacity;

	public uint WriteEnd;

	public int ThreadId;

	public long Timestamp;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 64)]
public struct MemoryReading
{
	public long Timestamp;

	public ulong WorkingSet;

	public ulong VirtualSet;
}


public struct MemoryState
{
	public unsafe MemoryReading* Readings;

	public uint Created;

	public uint Capacity;
}


public enum NotifyMetric : byte
{
	TotalAllocCount,
	TotalMem,
	MainAllocCount,
	MainMem,
	WorkerAllocCount,
	WorkerMem,
	Count
}


using System.Runtime.InteropServices;

public static class Native
{
	[StructLayout(LayoutKind.Explicit)]
	public struct MonoImage
	{
		[FieldOffset(48)]
		public unsafe byte* AssemblyName;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoClass
	{
		private const int ImageOffset = 56;

		[FieldOffset(56)]
		public unsafe MonoImage* Image;

		[FieldOffset(64)]
		public unsafe byte* Name;

		[FieldOffset(72)]
		public unsafe byte* Namespace;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoMethod
	{
		[FieldOffset(8)]
		public unsafe MonoClass* Class;

		[FieldOffset(24)]
		public unsafe byte* Name;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoVTable
	{
		[FieldOffset(0)]
		public unsafe MonoClass* Class;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoObject
	{
		[FieldOffset(0)]
		public unsafe MonoVTable* VTable;
	}

	public enum StorageType : byte
	{
		FrameLimited,
		FixedBuffer
	}

	[DllImport("ServerProfiler.Core")]
	public static extern void Install();

	[DllImport("ServerProfiler.Core")]
	public static extern void SetStorageType(byte aStorageType);

	[DllImport("ServerProfiler.Core")]
	public static extern bool SetFramesToRecord(byte aFrameCount);

	[DllImport("ServerProfiler.Core")]
	public static extern bool SetFixedBufferCap(uint aMainThreadCap, uint aWorkerThreadCap);

	[DllImport("ServerProfiler.Core")]
	public static extern void TakeSnapshot();

	[DllImport("ServerProfiler.Core")]
	public static extern void StartContinuousProfiling(byte aMaxStackDepth);

	[DllImport("ServerProfiler.Core")]
	public static extern void StopContinuousProfiling();

	[DllImport("ServerProfiler.Core")]
	public static extern void ResumeContinuousProfiling();

	[DllImport("ServerProfiler.Core")]
	public static extern void SetContinuousProfilerNotifySettings(NotifyMetric aSetting, uint aValue);

	[DllImport("ServerProfiler.Core")]
	public static extern bool OnFrameEnd();

	[DllImport("ServerProfiler.Core")]
	public unsafe static extern void GetData(out Profile** profiles, out byte count);

	[DllImport("ServerProfiler.Core")]
	public unsafe static extern void GetMemoryUsage(out MemoryState* state);

	[DllImport("ServerProfiler.Core")]
	public static extern bool ReleaseResources();
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoImage
{
	[FieldOffset(48)]
	public unsafe byte* AssemblyName;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoClass
{
	private const int ImageOffset = 56;

	[FieldOffset(56)]
	public unsafe MonoImage* Image;

	[FieldOffset(64)]
	public unsafe byte* Name;

	[FieldOffset(72)]
	public unsafe byte* Namespace;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoMethod
{
	[FieldOffset(8)]
	public unsafe MonoClass* Class;

	[FieldOffset(24)]
	public unsafe byte* Name;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoVTable
{
	[FieldOffset(0)]
	public unsafe MonoClass* Class;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoObject
{
	[FieldOffset(0)]
	public unsafe MonoVTable* VTable;
}


public enum StorageType : byte
{
	FrameLimited,
	FixedBuffer
}


using ProtoBuf;

public class AggressionTimerAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public AggressionTimerAIEvent()
		: base(AIEventType.AggressionTimer)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		AggressionTimerAIEventData aggressionTimerData = data.aggressionTimerData;
		Value = aggressionTimerData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.aggressionTimerData = new AggressionTimerAIEventData();
		obj.aggressionTimerData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Inverted)
		{
			base.Result = senses.TimeInAgressiveState < Value;
		}
		else
		{
			base.Result = senses.TimeInAgressiveState >= Value;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using Rust.Ai;
using UnityEngine;

public class AIBrainSenses
{
	[ServerVar]
	public static float UpdateInterval = 0.5f;

	[ServerVar]
	public static float HumanKnownPlayersLOSUpdateInterval = 0.2f;

	[ServerVar]
	public static float KnownPlayersLOSUpdateInterval = 0.5f;

	public float knownPlayersLOSUpdateInterval = 0.2f;

	[NonSerialized]
	public float MemoryDuration = 10f;

	[NonSerialized]
	public float LastThreatTimestamp;

	[NonSerialized]
	public float TimeInAgressiveState;

	public static BaseEntity[] queryResults = new BaseEntity[64];

	public static BasePlayer[] playerQueryResults = new BasePlayer[64];

	public float nextUpdateTime;

	public float nextKnownPlayersLOSUpdateTime;

	public BaseEntity owner;

	public BasePlayer playerOwner;

	public IAISenses ownerSenses;

	public float maxRange;

	public float targetLostRange;

	public float visionCone;

	public bool checkVision;

	public bool checkLOS;

	public bool ignoreNonVisionSneakers;

	public float listenRange;

	public bool hostileTargetsOnly;

	public bool senseFriendlies;

	public bool refreshKnownLOS;

	[NonSerialized]
	public bool ignoreTutorialPlayers;

	public EntityType senseTypes;

	public IAIAttack ownerAttack;

	[NonSerialized]
	public BaseAIBrain brain;

	private Func<BaseEntity, bool> aiCaresAbout;

	public float TimeSinceThreat => Time.realtimeSinceStartup - LastThreatTimestamp;

	public SimpleAIMemory Memory { get; set; } = new SimpleAIMemory();

	public float TargetLostRange => targetLostRange;

	public bool ignoreSafeZonePlayers { get; set; }

	public List<BaseEntity> Players => Memory.Players;

	public void Init(BaseEntity owner, BaseAIBrain brain, float memoryDuration, float range, float targetLostRange, float visionCone, bool checkVision, bool checkLOS, bool ignoreNonVisionSneakers, float listenRange, bool hostileTargetsOnly, bool senseFriendlies, bool ignoreSafeZonePlayers, EntityType senseTypes, bool refreshKnownLOS)
	{
		aiCaresAbout = AiCaresAbout;
		this.owner = owner;
		this.brain = brain;
		MemoryDuration = memoryDuration;
		ownerAttack = owner as IAIAttack;
		playerOwner = owner as BasePlayer;
		maxRange = range;
		this.targetLostRange = targetLostRange;
		this.visionCone = visionCone;
		this.checkVision = checkVision;
		this.checkLOS = checkLOS;
		this.ignoreNonVisionSneakers = ignoreNonVisionSneakers;
		this.listenRange = listenRange;
		this.hostileTargetsOnly = hostileTargetsOnly;
		this.senseFriendlies = senseFriendlies;
		this.ignoreSafeZonePlayers = ignoreSafeZonePlayers;
		this.senseTypes = senseTypes;
		LastThreatTimestamp = Time.realtimeSinceStartup;
		this.refreshKnownLOS = refreshKnownLOS;
		ownerSenses = owner as IAISenses;
		knownPlayersLOSUpdateInterval = ((owner is HumanNPC) ? HumanKnownPlayersLOSUpdateInterval : KnownPlayersLOSUpdateInterval);
	}

	public void DelaySenseUpdate(float delay)
	{
		nextUpdateTime = Time.time + delay;
	}

	public void Update()
	{
		if (!((Object)(object)owner == (Object)null))
		{
			UpdateSenses();
			UpdateKnownPlayersLOS();
		}
	}

	private void UpdateSenses()
	{
		if (Time.time < nextUpdateTime)
		{
			return;
		}
		nextUpdateTime = Time.time + UpdateInterval;
		if (senseTypes != 0)
		{
			if (senseTypes == EntityType.Player)
			{
				SensePlayers();
			}
			else
			{
				SenseBrains();
				if (senseTypes.HasFlag(EntityType.Player))
				{
					SensePlayers();
				}
			}
		}
		Memory.Forget(MemoryDuration);
	}

	public void UpdateKnownPlayersLOS()
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time < nextKnownPlayersLOSUpdateTime)
		{
			return;
		}
		nextKnownPlayersLOSUpdateTime = Time.time + knownPlayersLOSUpdateInterval;
		foreach (BaseEntity player in Memory.Players)
		{
			if (!((Object)(object)player == (Object)null) && !player.IsNpc)
			{
				bool flag = ownerAttack.CanSeeTarget(player);
				Memory.SetLOS(player, flag);
				if (refreshKnownLOS && (Object)(object)owner != (Object)null && flag && Vector3.Distance(((Component)player).transform.position, ((Component)owner).transform.position) <= TargetLostRange)
				{
					Memory.SetKnown(player, owner, this);
				}
			}
		}
	}

	private void SensePlayers()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int playersInSphereFast = BaseEntity.Query.Server.GetPlayersInSphereFast(((Component)owner).transform.position, maxRange, playerQueryResults, aiCaresAbout);
		for (int i = 0; i < playersInSphereFast; i++)
		{
			BasePlayer ent = playerQueryResults[i];
			Memory.SetKnown(ent, owner, this);
		}
	}

	private void SenseBrains()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int brainsInSphereFast = BaseEntity.Query.Server.GetBrainsInSphereFast(((Component)owner).transform.position, maxRange, queryResults, aiCaresAbout);
		for (int i = 0; i < brainsInSphereFast; i++)
		{
			BaseEntity ent = queryResults[i];
			Memory.SetKnown(ent, owner, this);
		}
	}

	private bool AiCaresAbout(BaseEntity entity)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (!entity.isServer)
		{
			return false;
		}
		if (entity.EqualNetID((BaseNetworkable)owner))
		{
			return false;
		}
		if (entity.Health() <= 0f)
		{
			return false;
		}
		if (entity.IsTransferProtected())
		{
			return false;
		}
		if (!IsValidSenseType(entity))
		{
			return false;
		}
		BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsDead())
			{
				return false;
			}
			if (ignoreTutorialPlayers && basePlayer.IsInTutorial)
			{
				return false;
			}
		}
		if (ignoreSafeZonePlayers && (Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
		{
			return false;
		}
		if (listenRange > 0f && (Object)(object)baseCombatEntity != (Object)null && baseCombatEntity.TimeSinceLastNoise <= 1f && baseCombatEntity.CanLastNoiseBeHeard(((Component)owner).transform.position, listenRange))
		{
			return true;
		}
		if (senseFriendlies && ownerSenses != null && ownerSenses.IsFriendly(entity))
		{
			return true;
		}
		float num = float.PositiveInfinity;
		if ((Object)(object)baseCombatEntity != (Object)null && AI.accuratevisiondistance)
		{
			num = Vector3.Distance(((Component)owner).transform.position, ((Component)baseCombatEntity).transform.position);
			if (num > maxRange)
			{
				return false;
			}
		}
		if (checkVision && !IsTargetInVision(entity))
		{
			if (!ignoreNonVisionSneakers)
			{
				return false;
			}
			if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsNpc)
			{
				if (!AI.accuratevisiondistance)
				{
					num = Vector3.Distance(((Component)owner).transform.position, ((Component)basePlayer).transform.position);
				}
				if ((basePlayer.IsDucked() && num >= brain.IgnoreSneakersMaxDistance) || num >= brain.IgnoreNonVisionMaxDistance)
				{
					return false;
				}
			}
		}
		if (hostileTargetsOnly && (Object)(object)baseCombatEntity != (Object)null && !baseCombatEntity.IsHostile() && !(baseCombatEntity is ScarecrowNPC))
		{
			return false;
		}
		if (checkLOS && ownerAttack != null)
		{
			bool flag = ownerAttack.CanSeeTarget(entity);
			Memory.SetLOS(entity, flag);
			if (!flag)
			{
				return false;
			}
		}
		return true;
	}

	private bool IsValidSenseType(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsNpc)
			{
				if (ent is BasePet)
				{
					return true;
				}
				if (ent is ScarecrowNPC)
				{
					return true;
				}
				if (senseTypes.HasFlag(EntityType.BasePlayerNPC))
				{
					return true;
				}
			}
			else if (senseTypes.HasFlag(EntityType.Player))
			{
				return true;
			}
		}
		if (senseTypes.HasFlag(EntityType.NPC) && ent is BaseNpc)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.WorldItem) && ent is WorldItem)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.Corpse) && ent is BaseCorpse)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.TimedExplosive) && ent is TimedExplosive)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.Chair) && ent is BaseChair)
		{
			return true;
		}
		return false;
	}

	private bool IsTargetInVision(BaseEntity target)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.Direction(((Component)target).transform.position, ((Component)owner).transform.position);
		return Vector3.Dot(((Object)(object)playerOwner != (Object)null) ? playerOwner.eyes.BodyForward() : ((Component)owner).transform.forward, val) >= visionCone;
	}

	public BaseEntity GetNearestPlayer(float rangeFraction)
	{
		return GetNearest(Memory.Players, rangeFraction);
	}

	public BaseEntity GetNearestThreat(float rangeFraction)
	{
		return GetNearest(Memory.Threats, rangeFraction);
	}

	public BaseEntity GetNearestTarget(float rangeFraction)
	{
		return GetNearest(Memory.Targets, rangeFraction);
	}

	private BaseEntity GetNearest(List<BaseEntity> entities, float rangeFraction)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (entities == null || entities.Count == 0)
		{
			return null;
		}
		float num = float.PositiveInfinity;
		BaseEntity result = null;
		foreach (BaseEntity entity in entities)
		{
			if (!((Object)(object)entity == (Object)null) && !(entity.Health() <= 0f) && Interface.CallHook("OnNpcTarget", (object)owner, (object)entity) == null)
			{
				float num2 = Vector3.Distance(((Component)entity).transform.position, ((Component)owner).transform.position);
				if (num2 <= rangeFraction * maxRange && num2 < num)
				{
					result = entity;
				}
			}
		}
		return result;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/AI Design")]
public class AIDesignSO : BaseScriptableObject
{
	public string Filename;
}


using System.Collections.Generic;
using ProtoBuf;

public class AIDesign
{
	public List<AIState> AvailableStates = new List<AIState>();

	public int DefaultStateContainerID;

	private Dictionary<int, AIStateContainer> stateContainers = new Dictionary<int, AIStateContainer>();

	public AIDesignScope Scope { get; private set; }

	public string Description { get; private set; }

	public void SetAvailableStates(List<AIState> states)
	{
		AvailableStates = new List<AIState>();
		AvailableStates.AddRange(states);
	}

	public void Load(AIDesign design, BaseEntity owner)
	{
		Scope = (AIDesignScope)design.scope;
		DefaultStateContainerID = design.defaultStateContainer;
		Description = design.description;
		InitStateContainers(design, owner);
	}

	private void InitStateContainers(AIDesign design, BaseEntity owner)
	{
		stateContainers = new Dictionary<int, AIStateContainer>();
		if (design.stateContainers == null)
		{
			return;
		}
		foreach (AIStateContainer stateContainer in design.stateContainers)
		{
			AIStateContainer aIStateContainer = new AIStateContainer();
			aIStateContainer.Init(stateContainer, owner);
			stateContainers.Add(aIStateContainer.ID, aIStateContainer);
		}
	}

	public AIStateContainer GetDefaultStateContainer()
	{
		return GetStateContainerByID(DefaultStateContainerID);
	}

	public AIStateContainer GetStateContainerByID(int id)
	{
		if (!stateContainers.ContainsKey(id))
		{
			return null;
		}
		return stateContainers[id];
	}

	public AIStateContainer GetFirstStateContainerOfType(AIState stateType)
	{
		foreach (AIStateContainer value in stateContainers.Values)
		{
			if (value.State == stateType)
			{
				return value;
			}
		}
		return null;
	}

	public AIDesign ToProto(int currentStateID)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		AIDesign val = new AIDesign();
		val.description = Description;
		val.scope = (int)Scope;
		val.defaultStateContainer = DefaultStateContainerID;
		val.availableStates = new List<int>();
		foreach (AIState availableState in AvailableStates)
		{
			val.availableStates.Add((int)availableState);
		}
		val.stateContainers = new List<AIStateContainer>();
		foreach (AIStateContainer value in stateContainers.Values)
		{
			val.stateContainers.Add(value.ToProto());
		}
		val.intialViewStateID = currentStateID;
		return val;
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public static class AIDesigns
{
	public const string DesignFolderPath = "cfg/ai/";

	private static Dictionary<string, AIDesign> designs = new Dictionary<string, AIDesign>();

	public static AIDesign GetByNameOrInstance(string designName, AIDesign entityDesign)
	{
		if (entityDesign != null)
		{
			return entityDesign;
		}
		AIDesign byName = GetByName(designName + "_custom");
		if (byName != null)
		{
			return byName;
		}
		return GetByName(designName);
	}

	public static void RefreshCache(string designName, AIDesign design)
	{
		if (designs.ContainsKey(designName))
		{
			designs[designName] = design;
		}
	}

	private static AIDesign GetByName(string designName)
	{
		designs.TryGetValue(designName, out var value);
		if (value != null)
		{
			return value;
		}
		string text = "cfg/ai/" + designName;
		if (!File.Exists(text))
		{
			return null;
		}
		try
		{
			using FileStream fileStream = File.Open(text, FileMode.Open);
			value = Pool.Get<AIDesign>();
			ProtoStreamExtensions.ReadFromStream((IProto)(object)value, (Stream)fileStream, false, 1048576);
			if (value == null)
			{
				return null;
			}
			designs.Add(designName, value);
			return value;
		}
		catch (Exception)
		{
			Debug.LogWarning((object)("Error trying to find AI design by name: " + text));
			return null;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class AIEvents
{
	public AIMemory Memory = new AIMemory();

	public List<BaseAIEvent> events = new List<BaseAIEvent>();

	private IAIEventListener eventListener;

	public AIBrainSenses senses;

	private int currentEventIndex;

	private bool inBlock;

	public int CurrentInputMemorySlot { get; private set; } = -1;

	public void Init(IAIEventListener listener, AIStateContainer stateContainer, BaseEntity owner, AIBrainSenses senses)
	{
		CurrentInputMemorySlot = stateContainer.InputMemorySlot;
		eventListener = listener;
		RemoveAll();
		AddStateEvents(stateContainer.Events, owner);
		Memory.Entity.Set(owner, 4);
		this.senses = senses;
	}

	public void RemoveAll()
	{
		events.Clear();
	}

	public void AddStateEvents(List<BaseAIEvent> events, BaseEntity owner)
	{
		foreach (BaseAIEvent @event in events)
		{
			Add(@event);
		}
	}

	public void Add(BaseAIEvent aiEvent)
	{
		if (events.Contains(aiEvent))
		{
			Debug.LogWarning((object)("Attempting to add duplicate AI event: " + aiEvent.EventType));
			return;
		}
		aiEvent.Reset();
		events.Add(aiEvent);
	}

	public void Tick(float deltaTime, StateStatus stateStatus)
	{
		foreach (BaseAIEvent @event in events)
		{
			@event.Tick(deltaTime, eventListener);
		}
		inBlock = false;
		currentEventIndex = 0;
		for (currentEventIndex = 0; currentEventIndex < events.Count; currentEventIndex++)
		{
			BaseAIEvent baseAIEvent = events[currentEventIndex];
			BaseAIEvent baseAIEvent2 = ((currentEventIndex < events.Count - 1) ? events[currentEventIndex + 1] : null);
			if (baseAIEvent2 != null && baseAIEvent2.EventType == AIEventType.And && !inBlock)
			{
				inBlock = true;
			}
			if (baseAIEvent.EventType != AIEventType.And)
			{
				if (baseAIEvent.ShouldExecute)
				{
					baseAIEvent.Execute(Memory, senses, stateStatus);
					baseAIEvent.PostExecute();
				}
				bool result = baseAIEvent.Result;
				if (inBlock)
				{
					if (result)
					{
						if ((baseAIEvent2 != null && baseAIEvent2.EventType != AIEventType.And) || baseAIEvent2 == null)
						{
							inBlock = false;
							if (baseAIEvent.HasValidTriggerState)
							{
								baseAIEvent.TriggerStateChange(eventListener, baseAIEvent.ID);
								break;
							}
						}
					}
					else
					{
						inBlock = false;
						currentEventIndex = FindNextEventBlock() - 1;
					}
				}
				else if (result && baseAIEvent.HasValidTriggerState)
				{
					baseAIEvent.TriggerStateChange(eventListener, baseAIEvent.ID);
					break;
				}
			}
		}
	}

	private int FindNextEventBlock()
	{
		for (int i = currentEventIndex; i < events.Count; i++)
		{
			BaseAIEvent baseAIEvent = events[i];
			BaseAIEvent baseAIEvent2 = ((i < events.Count - 1) ? events[i + 1] : null);
			if (baseAIEvent2 != null && baseAIEvent2.EventType != AIEventType.And && baseAIEvent.EventType != AIEventType.And)
			{
				return i + 1;
			}
		}
		return events.Count + 1;
	}
}


public enum AIEventType
{
	Timer,
	PlayerDetected,
	StateError,
	Attacked,
	StateFinished,
	InAttackRange,
	HealthBelow,
	InRange,
	PerformedAttack,
	TirednessAbove,
	HungerAbove,
	ThreatDetected,
	TargetDetected,
	AmmoBelow,
	BestTargetDetected,
	IsVisible,
	AttackTick,
	IsMounted,
	And,
	Chance,
	TargetLost,
	TimeSinceThreat,
	OnPositionMemorySet,
	AggressionTimer,
	Reloading,
	InRangeOfHome,
	IsBlinded
}


using UnityEngine;

public class AIMemory
{
	public AIMemoryBank<BaseEntity> Entity = new AIMemoryBank<BaseEntity>(MemoryBankType.Entity, 8);

	public AIMemoryBank<Vector3> Position = new AIMemoryBank<Vector3>(MemoryBankType.Position, 8);

	public AIMemoryBank<AIPoint> AIPoint = new AIMemoryBank<AIPoint>(MemoryBankType.AIPoint, 8);

	public void Clear()
	{
		Entity.Clear();
		Position.Clear();
		AIPoint.Clear();
	}
}


public enum MemoryBankType
{
	Entity,
	Position,
	AIPoint
}


public enum ReservedEntitySlots
{
	Self = 4,
	OwningPlayer,
	GroupLeader,
	SpecialEntity
}


public enum ReservedPositionSlots
{
	HomePoint = 4,
	GroupRoamPoint,
	RaycastTargetPoint,
	Vector3
}


public enum ReservedAIPointSlots
{
	CoverPoint = 4
}


using UnityEngine;

public class AIMemoryBank<T>
{
	private MemoryBankType type;

	private T[] slots;

	private float[] slotSetTimestamps;

	private int slotCount;

	public AIMemoryBank(MemoryBankType type, int slots)
	{
		Init(type, slots);
	}

	public void Init(MemoryBankType type, int slots)
	{
		this.type = type;
		slotCount = slots;
		this.slots = new T[slotCount];
		slotSetTimestamps = new float[slotCount];
	}

	public void Set(T item, int index)
	{
		if (index >= 0 && index < slotCount)
		{
			slots[index] = item;
			slotSetTimestamps[index] = Time.realtimeSinceStartup;
		}
	}

	public T Get(int index)
	{
		if (index < 0 || index >= slotCount)
		{
			return default(T);
		}
		return slots[index];
	}

	public float GetTimeSinceSet(int index)
	{
		if (index < 0 || index >= slotCount)
		{
			return 0f;
		}
		return Time.realtimeSinceStartup - slotSetTimestamps[index];
	}

	public void Remove(int index)
	{
		if (index >= 0 && index < slotCount)
		{
			slots[index] = default(T);
		}
	}

	public void Clear()
	{
		for (int i = 0; i < 4; i++)
		{
			Remove(i);
		}
	}
}


using ProtoBuf;

public class AmmoBelowAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public AmmoBelowAIEvent()
		: base(AIEventType.AmmoBelow)
	{
		base.Rate = ExecuteRate.Normal;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		AmmoBelowAIEventData ammoBelowData = data.ammoBelowData;
		Value = ammoBelowData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.ammoBelowData = new AmmoBelowAIEventData();
		obj.ammoBelowData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Owner is IAIAttack iAIAttack)
		{
			bool flag = iAIAttack.GetAmmoFraction() < Value;
			if (base.Inverted)
			{
				base.Result = !flag;
			}
			else
			{
				base.Result = flag;
			}
		}
	}
}


public class AndAIEvent : BaseAIEvent
{
	public AndAIEvent()
		: base(AIEventType.And)
	{
		base.Rate = ExecuteRate.Normal;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
	}
}


using UnityEngine;

public class AttackedAIEvent : BaseAIEvent
{
	protected float lastExecuteTime = float.NegativeInfinity;

	private BaseCombatEntity combatEntity;

	public AttackedAIEvent()
		: base(AIEventType.Attacked)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Reset()
	{
		base.Reset();
		lastExecuteTime = Time.time;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		combatEntity = memory.Entity.Get(base.InputEntityMemorySlot) as BaseCombatEntity;
		float num = lastExecuteTime;
		lastExecuteTime = Time.time;
		if ((Object)(object)combatEntity == (Object)null || !(combatEntity.lastAttackedTime >= num) || (Object)(object)combatEntity.lastAttacker == (Object)null || (Object)(object)combatEntity.lastAttacker == (Object)(object)combatEntity)
		{
			return;
		}
		BasePlayer basePlayer = combatEntity.lastAttacker as BasePlayer;
		if (!((Object)(object)basePlayer != (Object)null) || !((Object)(object)basePlayer == (Object)(object)memory.Entity.Get(5)) || !((Object)(object)basePlayer.lastDealtDamageTo == (Object)(object)base.Owner))
		{
			if (base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(combatEntity.lastAttacker, base.OutputEntityMemorySlot);
			}
			base.Result = !base.Inverted;
		}
	}
}


public class AttackTickAIEvent : BaseAIEvent
{
	public AttackTickAIEvent()
		: base(AIEventType.AttackTick)
	{
		base.Rate = ExecuteRate.VeryFast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Owner is IAIAttack iAIAttack)
		{
			BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
			iAIAttack.AttackTick(deltaTime, baseEntity, senses.Memory.IsLOS(baseEntity));
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class BaseAIEvent
{
	public enum ExecuteRate
	{
		Slow,
		Normal,
		Fast,
		VeryFast
	}

	private float executeTimer;

	protected float deltaTime;

	public AIEventType EventType { get; private set; }

	public int TriggerStateContainerID { get; private set; } = -1;

	public ExecuteRate Rate { get; protected set; } = ExecuteRate.Normal;

	public float ExecutionRate => Rate switch
	{
		ExecuteRate.Slow => 1f, 
		ExecuteRate.Normal => 0.5f, 
		ExecuteRate.Fast => 0.25f, 
		ExecuteRate.VeryFast => 0.1f, 
		_ => 0.5f, 
	};

	public bool ShouldExecute { get; protected set; }

	public bool Result { get; protected set; }

	public bool Inverted { get; private set; }

	public int OutputEntityMemorySlot { get; protected set; } = -1;

	public bool ShouldSetOutputEntityMemory => OutputEntityMemorySlot > -1;

	public int InputEntityMemorySlot { get; protected set; } = -1;

	public int ID { get; protected set; }

	public BaseEntity Owner { get; private set; }

	public bool HasValidTriggerState => TriggerStateContainerID != -1;

	public BaseAIEvent(AIEventType type)
	{
		EventType = type;
	}

	public virtual void Init(AIEventData data, BaseEntity owner)
	{
		Init(data.triggerStateContainer, data.id, owner, data.inputMemorySlot, data.outputMemorySlot, data.inverted);
	}

	public virtual void Init(int triggerStateContainer, int id, BaseEntity owner, int inputMemorySlot, int outputMemorySlot, bool inverted)
	{
		TriggerStateContainerID = triggerStateContainer;
		ID = id;
		Owner = owner;
		InputEntityMemorySlot = inputMemorySlot;
		OutputEntityMemorySlot = outputMemorySlot;
		Inverted = inverted;
	}

	public virtual AIEventData ToProto()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Expected O, but got Unknown
		return new AIEventData
		{
			id = ID,
			eventType = (int)EventType,
			triggerStateContainer = TriggerStateContainerID,
			outputMemorySlot = OutputEntityMemorySlot,
			inputMemorySlot = InputEntityMemorySlot,
			inverted = Inverted
		};
	}

	public virtual void Reset()
	{
		executeTimer = 0f;
		deltaTime = 0f;
		Result = false;
	}

	public void Tick(float deltaTime, IAIEventListener listener)
	{
		this.deltaTime += deltaTime;
		executeTimer += deltaTime;
		float executionRate = ExecutionRate;
		if (executeTimer >= executionRate)
		{
			executeTimer = 0f;
			ShouldExecute = true;
		}
		else
		{
			ShouldExecute = false;
		}
	}

	public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
	}

	public virtual void PostExecute()
	{
		deltaTime = 0f;
	}

	public void TriggerStateChange(IAIEventListener listener, int sourceEventID)
	{
		listener.EventTriggeredStateChange(TriggerStateContainerID, sourceEventID);
	}

	public static BaseAIEvent CreateEvent(AIEventType eventType)
	{
		switch (eventType)
		{
		case AIEventType.Timer:
			return new TimerAIEvent();
		case AIEventType.PlayerDetected:
			return new PlayerDetectedAIEvent();
		case AIEventType.StateError:
			return new StateErrorAIEvent();
		case AIEventType.Attacked:
			return new AttackedAIEvent();
		case AIEventType.StateFinished:
			return new StateFinishedAIEvent();
		case AIEventType.InAttackRange:
			return new InAttackRangeAIEvent();
		case AIEventType.HealthBelow:
			return new HealthBelowAIEvent();
		case AIEventType.InRange:
			return new InRangeAIEvent();
		case AIEventType.PerformedAttack:
			return new PerformedAttackAIEvent();
		case AIEventType.TirednessAbove:
			return new TirednessAboveAIEvent();
		case AIEventType.HungerAbove:
			return new HungerAboveAIEvent();
		case AIEventType.ThreatDetected:
			return new ThreatDetectedAIEvent();
		case AIEventType.TargetDetected:
			return new TargetDetectedAIEvent();
		case AIEventType.AmmoBelow:
			return new AmmoBelowAIEvent();
		case AIEventType.BestTargetDetected:
			return new BestTargetDetectedAIEvent();
		case AIEventType.IsVisible:
			return new IsVisibleAIEvent();
		case AIEventType.AttackTick:
			return new AttackTickAIEvent();
		case AIEventType.IsMounted:
			return new IsMountedAIEvent();
		case AIEventType.And:
			return new AndAIEvent();
		case AIEventType.Chance:
			return new ChanceAIEvent();
		case AIEventType.TargetLost:
			return new TargetLostAIEvent();
		case AIEventType.TimeSinceThreat:
			return new TimeSinceThreatAIEvent();
		case AIEventType.OnPositionMemorySet:
			return new OnPositionMemorySetAIEvent();
		case AIEventType.AggressionTimer:
			return new AggressionTimerAIEvent();
		case AIEventType.Reloading:
			return new ReloadingAIEvent();
		case AIEventType.InRangeOfHome:
			return new InRangeOfHomeAIEvent();
		case AIEventType.IsBlinded:
			return new IsBlindedAIEvent();
		default:
			Debug.LogWarning((object)("No case for " + eventType.ToString() + " event in BaseAIEvent.CreateEvent()!"));
			return null;
		}
	}
}


public enum ExecuteRate
{
	Slow,
	Normal,
	Fast,
	VeryFast
}


using ProtoBuf;
using UnityEngine;

public class BestTargetDetectedAIEvent : BaseAIEvent
{
	public BestTargetDetectedAIEvent()
		: base(AIEventType.BestTargetDetected)
	{
		base.Rate = ExecuteRate.Normal;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (!(base.Owner is IAIAttack iAIAttack))
		{
			return;
		}
		BaseEntity bestTarget = iAIAttack.GetBestTarget();
		if (base.Inverted)
		{
			if ((Object)(object)bestTarget == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)bestTarget == (Object)null;
		}
		else
		{
			if ((Object)(object)bestTarget != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(bestTarget, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)bestTarget != (Object)null;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class ChanceAIEvent : BaseAIEvent
{
	public float Chance { get; set; }

	public ChanceAIEvent()
		: base(AIEventType.Chance)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		Chance = data.chanceData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.chanceData = new ChanceAIEventData();
		obj.chanceData.value = Chance;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		bool flag = Random.Range(0f, 1f) <= Chance;
		if (base.Inverted)
		{
			base.Result = !flag;
		}
		else
		{
			base.Result = flag;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class HealthBelowAIEvent : BaseAIEvent
{
	private BaseCombatEntity combatEntity;

	public float HealthFraction { get; set; }

	public HealthBelowAIEvent()
		: base(AIEventType.HealthBelow)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		HealthBelowAIEventData healthBelowData = data.healthBelowData;
		HealthFraction = healthBelowData.healthFraction;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.healthBelowData = new HealthBelowAIEventData();
		obj.healthBelowData.healthFraction = HealthFraction;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		combatEntity = memory.Entity.Get(base.InputEntityMemorySlot) as BaseCombatEntity;
		if (!((Object)(object)combatEntity == (Object)null))
		{
			bool flag = combatEntity.healthFraction < HealthFraction;
			if (base.Inverted)
			{
				base.Result = !flag;
			}
			else
			{
				base.Result = flag;
			}
		}
	}
}


public interface IAIHungerAbove
{
	bool IsHungerAbove(float val);
}


using ProtoBuf;

public class HungerAboveAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public HungerAboveAIEvent()
		: base(AIEventType.HungerAbove)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		HungerAboveAIEventData hungerAboveData = data.hungerAboveData;
		Value = hungerAboveData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.hungerAboveData = new HungerAboveAIEventData();
		obj.hungerAboveData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		if (!(base.Owner is IAIHungerAbove iAIHungerAbove))
		{
			base.Result = false;
			return;
		}
		bool flag = iAIHungerAbove.IsHungerAbove(Value);
		if (base.Inverted)
		{
			base.Result = !flag;
		}
		else
		{
			base.Result = flag;
		}
	}
}


public interface IAIEventListener
{
	void EventTriggeredStateChange(int newStateContainerID, int sourceEventID);
}


using UnityEngine;

public class InAttackRangeAIEvent : BaseAIEvent
{
	public InAttackRangeAIEvent()
		: base(AIEventType.InAttackRange)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		base.Result = false;
		if (!((Object)(object)baseEntity == (Object)null) && base.Owner is IAIAttack iAIAttack)
		{
			float dist;
			bool flag = iAIAttack.IsTargetInRange(baseEntity, out dist);
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class InRangeAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public InRangeAIEvent()
		: base(AIEventType.InRange)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		InRangeAIEventData inRangeData = data.inRangeData;
		Range = inRangeData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.inRangeData = new InRangeAIEventData();
		obj.inRangeData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		base.Result = false;
		if (!((Object)(object)baseEntity == (Object)null))
		{
			bool flag = Vector3Ex.Distance2D(((Component)base.Owner).transform.position, ((Component)baseEntity).transform.position) <= Range;
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class InRangeOfHomeAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public InRangeOfHomeAIEvent()
		: base(AIEventType.InRangeOfHome)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		InRangeOfHomeAIEventData inRangeOfHomeData = data.inRangeOfHomeData;
		Range = inRangeOfHomeData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.inRangeOfHomeData = new InRangeOfHomeAIEventData();
		obj.inRangeOfHomeData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = memory.Position.Get(4);
		base.Result = false;
		bool flag = Vector3Ex.Distance2D(((Component)base.Owner).transform.position, val) <= Range;
		base.Result = (base.Inverted ? (!flag) : flag);
	}
}


public class IsBlindedAIEvent : BaseAIEvent
{
	public IsBlindedAIEvent()
		: base(AIEventType.IsBlinded)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		bool flag = senses.brain.Blinded();
		if (base.Inverted)
		{
			base.Result = !flag;
		}
		else
		{
			base.Result = flag;
		}
	}
}


using UnityEngine;

public class IsVisibleAIEvent : BaseAIEvent
{
	public IsVisibleAIEvent()
		: base(AIEventType.IsVisible)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		if (!((Object)(object)baseEntity == (Object)null) && base.Owner is IAIAttack)
		{
			bool flag = senses.Memory.IsLOS(baseEntity);
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


public class IsMountedAIEvent : BaseAIEvent
{
	public IsMountedAIEvent()
		: base(AIEventType.IsMounted)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		IAIMounted iAIMounted = memory.Entity.Get(base.InputEntityMemorySlot) as IAIMounted;
		base.Result = false;
		if (iAIMounted != null)
		{
			if (base.Inverted && !iAIMounted.IsMounted())
			{
				base.Result = true;
			}
			if (!base.Inverted && iAIMounted.IsMounted())
			{
				base.Result = true;
			}
			if (base.Result && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(memory.Entity.Get(base.InputEntityMemorySlot), base.OutputEntityMemorySlot);
			}
		}
	}
}


public class OnPositionMemorySetAIEvent : BaseAIEvent
{
	public OnPositionMemorySetAIEvent()
		: base(AIEventType.OnPositionMemorySet)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		if (memory.Position.GetTimeSinceSet(5) <= 0.5f)
		{
			base.Result = !base.Inverted;
		}
		else
		{
			base.Result = base.Inverted;
		}
	}
}


using UnityEngine;

public class PerformedAttackAIEvent : BaseAIEvent
{
	protected float lastExecuteTime = float.NegativeInfinity;

	private BaseCombatEntity combatEntity;

	public PerformedAttackAIEvent()
		: base(AIEventType.PerformedAttack)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Reset()
	{
		base.Reset();
		lastExecuteTime = Time.time;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		combatEntity = memory.Entity.Get(base.InputEntityMemorySlot) as BaseCombatEntity;
		float num = lastExecuteTime;
		lastExecuteTime = Time.time;
		if ((Object)(object)combatEntity == (Object)null)
		{
			return;
		}
		if (combatEntity.lastDealtDamageTime >= num)
		{
			if ((Object)(object)combatEntity.lastDealtDamageTo == (Object)null || (Object)(object)combatEntity.lastDealtDamageTo == (Object)(object)combatEntity)
			{
				return;
			}
			BasePlayer basePlayer = combatEntity as BasePlayer;
			if (!((Object)(object)basePlayer != (Object)null) || ((!((Object)(object)basePlayer == (Object)(object)memory.Entity.Get(5)) || !((Object)(object)basePlayer.lastDealtDamageTo == (Object)(object)base.Owner)) && (!((Object)(object)basePlayer == (Object)(object)memory.Entity.Get(5)) || (((Component)basePlayer.lastDealtDamageTo).gameObject.layer != 21 && ((Component)basePlayer.lastDealtDamageTo).gameObject.layer != 8))))
			{
				if (base.ShouldSetOutputEntityMemory)
				{
					memory.Entity.Set(combatEntity.lastDealtDamageTo, base.OutputEntityMemorySlot);
				}
				base.Result = !base.Inverted;
			}
		}
		else
		{
			base.Result = base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class PlayerDetectedAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public PlayerDetectedAIEvent()
		: base(AIEventType.PlayerDetected)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		PlayerDetectedAIEventData playerDetectedData = data.playerDetectedData;
		Range = playerDetectedData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.playerDetectedData = new PlayerDetectedAIEventData();
		obj.playerDetectedData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		BaseEntity nearestPlayer = senses.GetNearestPlayer(Range);
		if (base.Inverted)
		{
			if ((Object)(object)nearestPlayer == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestPlayer == (Object)null;
		}
		else
		{
			if ((Object)(object)nearestPlayer != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(nearestPlayer, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestPlayer != (Object)null;
		}
	}
}


using UnityEngine;

public class ReloadingAIEvent : BaseAIEvent
{
	public ReloadingAIEvent()
		: base(AIEventType.Reloading)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		base.Result = false;
		NPCPlayer nPCPlayer = baseEntity as NPCPlayer;
		if (!((Object)(object)nPCPlayer == (Object)null))
		{
			bool flag = nPCPlayer.IsReloading();
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


public class StateErrorAIEvent : BaseAIEvent
{
	public StateErrorAIEvent()
		: base(AIEventType.StateError)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		switch (stateStatus)
		{
		case StateStatus.Error:
			base.Result = !base.Inverted;
			break;
		case StateStatus.Running:
			base.Result = base.Inverted;
			break;
		}
	}
}


public class StateFinishedAIEvent : BaseAIEvent
{
	public StateFinishedAIEvent()
		: base(AIEventType.StateFinished)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (stateStatus == StateStatus.Finished)
		{
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class TargetDetectedAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public TargetDetectedAIEvent()
		: base(AIEventType.TargetDetected)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TargetDetectedAIEventData targetDetectedData = data.targetDetectedData;
		Range = targetDetectedData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.targetDetectedData = new TargetDetectedAIEventData();
		obj.targetDetectedData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		BaseEntity nearestTarget = senses.GetNearestTarget(Range);
		if (base.Inverted)
		{
			if ((Object)(object)nearestTarget == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestTarget == (Object)null;
		}
		else
		{
			if ((Object)(object)nearestTarget != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(nearestTarget, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestTarget != (Object)null;
		}
	}
}


using UnityEngine;

public class TargetLostAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public TargetLostAIEvent()
		: base(AIEventType.TargetLost)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		base.Result = base.Inverted;
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			base.Result = !base.Inverted;
			return;
		}
		if (Vector3.Distance(((Component)baseEntity).transform.position, ((Component)base.Owner).transform.position) > senses.TargetLostRange)
		{
			base.Result = !base.Inverted;
			return;
		}
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if (baseEntity.Health() <= 0f || ((Object)(object)basePlayer != (Object)null && basePlayer.IsDead()))
		{
			base.Result = !base.Inverted;
		}
		else if (senses.ignoreSafeZonePlayers && (Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
		{
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class ThreatDetectedAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public ThreatDetectedAIEvent()
		: base(AIEventType.ThreatDetected)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		ThreatDetectedAIEventData threatDetectedData = data.threatDetectedData;
		Range = threatDetectedData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.threatDetectedData = new ThreatDetectedAIEventData();
		obj.threatDetectedData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		BaseEntity nearestThreat = senses.GetNearestThreat(Range);
		if (base.Inverted)
		{
			if ((Object)(object)nearestThreat == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestThreat == (Object)null;
		}
		else
		{
			if ((Object)(object)nearestThreat != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(nearestThreat, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestThreat != (Object)null;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class TimerAIEvent : BaseAIEvent
{
	protected float currentDuration;

	protected float elapsedDuration;

	public float DurationMin { get; set; }

	public float DurationMax { get; set; }

	public TimerAIEvent()
		: base(AIEventType.Timer)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TimerAIEventData timerData = data.timerData;
		DurationMin = timerData.duration;
		DurationMax = timerData.durationMax;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.timerData = new TimerAIEventData();
		obj.timerData.duration = DurationMin;
		obj.timerData.durationMax = DurationMax;
		return obj;
	}

	public override void Reset()
	{
		base.Reset();
		currentDuration = Random.Range(DurationMin, DurationMax);
		elapsedDuration = 0f;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		elapsedDuration += deltaTime;
		if (elapsedDuration >= currentDuration)
		{
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;

public class TimeSinceThreatAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public TimeSinceThreatAIEvent()
		: base(AIEventType.TimeSinceThreat)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TimeSinceThreatAIEventData timeSinceThreatData = data.timeSinceThreatData;
		Value = timeSinceThreatData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.timeSinceThreatData = new TimeSinceThreatAIEventData();
		obj.timeSinceThreatData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Inverted)
		{
			base.Result = senses.TimeSinceThreat < Value;
		}
		else
		{
			base.Result = senses.TimeSinceThreat >= Value;
		}
	}
}


public interface IAITirednessAbove
{
	bool IsTirednessAbove(float val);
}


public interface IAISleep
{
	void StartSleeping();

	void StopSleeping();
}


public interface IAISenses
{
	bool IsThreat(BaseEntity entity);

	bool IsTarget(BaseEntity entity);

	bool IsFriendly(BaseEntity entity);
}


public interface IAIMounted
{
	bool IsMounted();
}


using ProtoBuf;

public class TirednessAboveAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public TirednessAboveAIEvent()
		: base(AIEventType.TirednessAbove)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TirednessAboveAIEventData tirednessAboveData = data.tirednessAboveData;
		Value = tirednessAboveData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.tirednessAboveData = new TirednessAboveAIEventData();
		obj.tirednessAboveData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Owner is IAITirednessAbove iAITirednessAbove)
		{
			bool flag = iAITirednessAbove.IsTirednessAbove(Value);
			if (base.Inverted)
			{
				base.Result = !flag;
			}
			else
			{
				base.Result = flag;
			}
		}
	}
}


using System.Collections.Generic;
using ProtoBuf;

public class AIStateContainer
{
	public List<BaseAIEvent> Events;

	public int ID { get; private set; }

	public AIState State { get; private set; }

	public int InputMemorySlot { get; private set; } = -1;

	public void Init(AIStateContainer container, BaseEntity owner)
	{
		ID = container.id;
		State = (AIState)container.state;
		InputMemorySlot = container.inputMemorySlot;
		Events = new List<BaseAIEvent>();
		if (container.events == null)
		{
			return;
		}
		foreach (AIEventData @event in container.events)
		{
			BaseAIEvent baseAIEvent = BaseAIEvent.CreateEvent((AIEventType)@event.eventType);
			baseAIEvent.Init(@event, owner);
			baseAIEvent.Reset();
			Events.Add(baseAIEvent);
		}
	}

	public AIStateContainer ToProto()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		AIStateContainer val = new AIStateContainer();
		val.id = ID;
		val.state = (int)State;
		val.events = new List<AIEventData>();
		val.inputMemorySlot = InputMemorySlot;
		foreach (BaseAIEvent @event in Events)
		{
			val.events.Add(@event.ToProto());
		}
		return val;
	}
}


public enum StateStatus
{
	Running,
	Finished,
	Error
}


public enum AIDesignScope
{
	Default,
	EntityServerWide,
	EntityInstance
}


using System;

[Flags]
public enum EntityType
{
	Player = 1,
	NPC = 2,
	WorldItem = 4,
	Corpse = 8,
	TimedExplosive = 0x10,
	Chair = 0x20,
	BasePlayerNPC = 0x40
}


internal interface IClientBrainStateListener
{
	void OnClientStateChanged(AIState state);
}


using ProtoBuf;

internal interface IAIDesign
{
	void LoadAIDesign(AIDesign design, BasePlayer player);

	void StopDesigning();

	bool CanPlayerDesignAI(BasePlayer player);
}


public interface IAISleepable
{
	bool AllowedToSleep();

	void SleepAI();

	void WakeAI();
}


using UnityEngine;

public interface IAIGroupable
{
	bool AddMember(IAIGroupable member);

	void RemoveMember(IAIGroupable member);

	void JoinGroup(IAIGroupable leader, BaseEntity leaderEntity);

	void SetGroupRoamRootPosition(Vector3 rootPos);

	bool InGroup();

	void LeaveGroup();

	void SetUngrouped();
}


public interface IAIAttack
{
	void AttackTick(float delta, BaseEntity target, bool targetIsLOS);

	BaseEntity GetBestTarget();

	bool CanAttack(BaseEntity entity);

	float EngagementRange();

	bool IsTargetInRange(BaseEntity entity, out float dist);

	bool CanSeeTarget(BaseEntity entity);

	float GetAmmoFraction();

	bool NeedsToReload();

	bool Reload();

	float CooldownDuration();

	bool IsOnCooldown();

	bool StartAttacking(BaseEntity entity);

	void StopAttacking();
}


public enum PetCommandType
{
	LoadDesign,
	SetState,
	Destroy
}


using UnityEngine;

public interface IPet
{
	bool IsPet();

	void SetPetOwner(BasePlayer player);

	bool IsOwnedBy(BasePlayer player);

	bool IssuePetCommand(PetCommandType cmd, int param, Ray? ray);
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PetCommandList : PrefabAttribute
{
	[Serializable]
	public struct PetCommandDesc
	{
		public PetCommandType CommandType;

		public Phrase Title;

		public Phrase Description;

		public Sprite Icon;

		public int CommandIndex;

		public bool Raycast;

		public int CommandWheelOrder;
	}

	public List<PetCommandDesc> Commands;

	protected override Type GetIndexedType()
	{
		return typeof(PetCommandList);
	}

	public List<PetCommandDesc> GetCommandDescriptions()
	{
		return Commands;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct PetCommandDesc
{
	public PetCommandType CommandType;

	public Phrase Title;

	public Phrase Description;

	public Sprite Icon;

	public int CommandIndex;

	public bool Raycast;

	public int CommandWheelOrder;
}


using UnityEngine;

public class ScentEmission : EntityComponent<BaseCombatEntity>, IClientComponent
{
	[SerializeField]
	private bool startSampling = true;

	[SerializeField]
	private bool generateFakeTrail = true;

	[SerializeField]
	private float sampleIntervalSeconds = 1f;

	[SerializeField]
	[Space]
	private int minInitialPoints = 5;

	[SerializeField]
	private Vector2 initialDistanceRange = new Vector2(50f, 100f);

	[SerializeField]
	private float startAngleDeviation = 45f;

	[SerializeField]
	private float wiggleIntensity = 1f;

	[SerializeField]
	[Space]
	private LineRenderer[] lineRenderers;

	[SerializeField]
	private float heightOffset = 0.5f;

	[SerializeField]
	private bool snapToTerrain = true;
}


using System;
using UnityEngine;

public class AudioVisualisationEntityLight : AudioVisualisationEntity
{
	[Serializable]
	public struct LightColourSet
	{
		[ColorUsage(true, true)]
		public Color LightColor;

		[ColorUsage(true, true)]
		public Color SecondaryLightColour;

		[ColorUsage(true, true)]
		public Color EmissionColour;
	}

	public Light TargetLight;

	public Light SecondaryLight;

	public MeshRenderer[] TargetRenderer;

	public LightColourSet RedColour;

	public LightColourSet GreenColour;

	public LightColourSet BlueColour;

	public LightColourSet YellowColour;

	public LightColourSet PinkColour;

	public float lightMinIntensity = 0.05f;

	public float lightMaxIntensity = 1f;
}


using System;
using UnityEngine;

[Serializable]
public struct LightColourSet
{
	[ColorUsage(true, true)]
	public Color LightColor;

	[ColorUsage(true, true)]
	public Color SecondaryLightColour;

	[ColorUsage(true, true)]
	public Color EmissionColour;
}


using System;
using System.Collections.Generic;
using System.IO;
using ConVar;
using Facepunch;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class BoomBox : EntityComponent<BaseEntity>, INotifyLOD
{
	public AudioSource SoundSource;

	public float ConditionLossRate = 0.25f;

	public ItemDefinition[] ValidCassettes;

	public SoundDefinition PlaySfx;

	public SoundDefinition StopSfx;

	public const BaseEntity.Flags HasCassette = BaseEntity.Flags.Reserved1;

	[ServerVar(Saved = true)]
	public static int BacktrackLength = 30;

	public Action<float> HurtCallback;

	public static Dictionary<string, string> ValidStations;

	public static Dictionary<string, string> ServerValidStations;

	[ReplicatedVar(Saved = true, Help = "A list of radio stations that are valid on this server. Format: NAME,URL,NAME,URL,etc", ShowInAdminUI = true)]
	public static string ServerUrlList = string.Empty;

	public static string lastParsedServerList;

	public ShoutcastStreamer ShoutcastStreamer;

	public GameObjectRef RadioIpDialog;

	public ulong AssignedRadioBy;

	public BaseEntity BaseEntity => base.baseEntity;

	private bool isClient
	{
		get
		{
			if ((Object)(object)base.baseEntity != (Object)null)
			{
				return base.baseEntity.isClient;
			}
			return false;
		}
	}

	public string CurrentRadioIp { get; set; } = "rustradio.facepunch.com";

	[ServerVar]
	public static void ClearRadioByUser(Arg arg)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		ulong uInt = arg.GetUInt64(0, 0uL);
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current is DeployableBoomBox deployableBoomBox)
				{
					if (deployableBoomBox.ClearRadioByUserId(uInt))
					{
						num++;
					}
				}
				else if (current is HeldBoomBox heldBoomBox && heldBoomBox.ClearRadioByUserId(uInt))
				{
					num++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Stopped and cleared saved URL of {num} boom boxes");
	}

	public void ServerTogglePlay(BaseEntity.RPCMessage msg, bool bypassPower = false)
	{
		if (IsPowered() || bypassPower)
		{
			bool flag = ((Stream)(object)msg.read).ReadByte() == 1;
			if (Interface.CallHook("OnBoomboxToggle", (object)this, (object)msg.player, (object)flag) == null)
			{
				ServerTogglePlay(flag);
			}
		}
	}

	public void DeductCondition()
	{
		HurtCallback?.Invoke(ConditionLossRate * ConVar.Decay.scale);
	}

	public void ServerTogglePlay(bool play)
	{
		if (!((Object)(object)base.baseEntity == (Object)null) && HasFlag(BaseEntity.Flags.On) != play)
		{
			SetFlag(BaseEntity.Flags.On, play);
			if (base.baseEntity is IOEntity iOEntity)
			{
				iOEntity.MarkDirtyForceUpdateOutputs();
			}
			if (play && !((FacepunchBehaviour)this).IsInvoking((Action)DeductCondition) && ConditionLossRate > 0f)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)DeductCondition, 1f, 1f);
			}
			else if (((FacepunchBehaviour)this).IsInvoking((Action)DeductCondition))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)DeductCondition);
			}
		}
	}

	public void OnCassetteInserted(Cassette c)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)base.baseEntity == (Object)null))
		{
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("Client_OnCassetteInserted"), c.net.ID);
			ServerTogglePlay(play: false);
			SetFlag(BaseEntity.Flags.Reserved1, state: true);
			base.baseEntity.SendNetworkUpdate();
		}
	}

	public void OnCassetteRemoved(Cassette c)
	{
		if (!((Object)(object)base.baseEntity == (Object)null))
		{
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("Client_OnCassetteRemoved"));
			ServerTogglePlay(play: false);
			SetFlag(BaseEntity.Flags.Reserved1, state: false);
		}
	}

	public bool IsPowered()
	{
		if ((Object)(object)base.baseEntity == (Object)null)
		{
			return false;
		}
		if (!base.baseEntity.HasFlag(BaseEntity.Flags.Reserved8))
		{
			return base.baseEntity is HeldBoomBox;
		}
		return true;
	}

	public bool IsOn()
	{
		if ((Object)(object)base.baseEntity == (Object)null)
		{
			return false;
		}
		return base.baseEntity.IsOn();
	}

	public bool HasFlag(BaseEntity.Flags f)
	{
		if ((Object)(object)base.baseEntity == (Object)null)
		{
			return false;
		}
		return base.baseEntity.HasFlag(f);
	}

	public void SetFlag(BaseEntity.Flags f, bool state)
	{
		if ((Object)(object)base.baseEntity != (Object)null)
		{
			base.baseEntity.SetFlag(f, state);
		}
	}

	public static void LoadStations()
	{
		if (ValidStations == null)
		{
			ValidStations = GetStationData() ?? new Dictionary<string, string>();
			ParseServerUrlList();
		}
	}

	public static Dictionary<string, string> GetStationData()
	{
		JObject obj = Application.Manifest?.Metadata;
		JToken obj2 = ((obj != null) ? obj["RadioStations"] : null);
		JArray val = (JArray)(object)((obj2 is JArray) ? obj2 : null);
		if (val != null && ((JContainer)val).Count > 0)
		{
			string[] array = new string[2];
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			{
				foreach (string item in ((JContainer)val).Values<string>())
				{
					array = item.Split(',');
					if (!dictionary.ContainsKey(array[0]) && !array[1].Contains("facepunch"))
					{
						dictionary.Add(array[0], array[1]);
					}
				}
				return dictionary;
			}
		}
		return null;
	}

	public static bool IsStationValid(string url)
	{
		ParseServerUrlList();
		object obj = Interface.CallHook("OnBoomboxStationValidate", (object)url);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ShoutcastStreamer.CheckBuiltInRadios();
		if (ValidStations == null || !ValidStations.ContainsValue(url))
		{
			if (ServerValidStations == null || !ServerValidStations.ContainsValue(url))
			{
				if (ShoutcastStreamer.ParsedLocalRadioList != null)
				{
					return ShoutcastStreamer.ParsedLocalRadioList.ContainsValue(url);
				}
				return false;
			}
			return true;
		}
		return true;
	}

	public static void ParseServerUrlList()
	{
		if (ServerValidStations == null)
		{
			ServerValidStations = new Dictionary<string, string>();
		}
		if (lastParsedServerList == ServerUrlList)
		{
			return;
		}
		ServerValidStations.Clear();
		if (!string.IsNullOrEmpty(ServerUrlList))
		{
			string[] array = ServerUrlList.Split(',');
			if (array.Length % 2 != 0)
			{
				Debug.Log((object)"Invalid number of stations in BoomBox.ServerUrlList, ensure you always have a name and a url");
				return;
			}
			for (int i = 0; i < array.Length; i += 2)
			{
				if (ServerValidStations.ContainsKey(array[i]))
				{
					Debug.Log((object)("Duplicate station name detected in BoomBox.ServerUrlList, all station names must be unique: " + array[i]));
				}
				else
				{
					ServerValidStations.Add(array[i], array[i + 1]);
				}
			}
		}
		lastParsedServerList = ServerUrlList;
	}

	public void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)
	{
		string text = msg.read.String(256, false);
		if (Interface.CallHook("OnBoomboxStationUpdate", (object)this, (object)text, (object)msg.player) == null && IsStationValid(text))
		{
			if ((Object)(object)msg.player != (Object)null)
			{
				ulong assignedRadioBy = msg.player.userID.Get();
				AssignedRadioBy = assignedRadioBy;
			}
			CurrentRadioIp = text;
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnRadioIPChanged"), CurrentRadioIp);
			Interface.CallHook("OnBoomboxStationUpdated", (object)this, (object)text, (object)msg.player);
			if (IsOn())
			{
				ServerTogglePlay(play: false);
			}
		}
	}

	public void Save(BaseNetworkable.SaveInfo info)
	{
		if (info.msg.boomBox == null)
		{
			info.msg.boomBox = Pool.Get<BoomBox>();
		}
		info.msg.boomBox.radioIp = CurrentRadioIp;
		info.msg.boomBox.assignedRadioBy = AssignedRadioBy;
	}

	public bool ClearRadioByUserId(ulong id)
	{
		if (AssignedRadioBy == id)
		{
			CurrentRadioIp = string.Empty;
			AssignedRadioBy = 0uL;
			if (HasFlag(BaseEntity.Flags.On))
			{
				ServerTogglePlay(play: false);
			}
			return true;
		}
		return false;
	}

	public void Load(BaseNetworkable.LoadInfo info)
	{
		if (info.msg.boomBox != null)
		{
			CurrentRadioIp = info.msg.boomBox.radioIp;
			AssignedRadioBy = info.msg.boomBox.assignedRadioBy;
		}
	}
}


public interface ICassettePlayer
{
	BaseEntity ToBaseEntity { get; }

	void OnCassetteInserted(Cassette c);

	void OnCassetteRemoved(Cassette c);
}


using UnityEngine;

public class DiscoFloor : AudioVisualisationEntity
{
	public float GradientDuration = 3f;

	public float VolumeSensitivityMultiplier = 3f;

	public float BaseSpeed;

	public Light[] LightSources;

	public DiscoFloorMesh FloorMesh;
}


using System;
using UnityEngine;

public class DiscoFloorColourLookups : PrefabAttribute, IClientComponent
{
	public float[] InOutLookup;

	public float[] RadialLookup;

	public float[] RippleLookup;

	public float[] CheckerLookup;

	public float[] BlockLookup;

	public Gradient[] ColourGradients;

	protected override Type GetIndexedType()
	{
		return typeof(DiscoFloorColourLookups);
	}
}


using UnityEngine;

public class DiscoFloorMesh : MonoBehaviour, IClientComponent
{
	public int GridRows = 5;

	public int GridColumns = 5;

	public float GridSize = 1f;

	[Range(0f, 10f)]
	public float TestOffset;

	public Color OffColor = Color.grey;

	public MeshRenderer Renderer;

	public bool DrawInEditor;

	public MeshFilter Filter;

	public AnimationCurve customCurveX = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve customCurveY = AnimationCurve.Linear(0f, 0f, 1f, 1f);
}


public interface IAudioConnectionSource
{
	IOEntity ToEntity();
}


public class ItemModAssociatedEntityMobile : ItemModAssociatedEntity<MobileInventoryEntity>
{
	protected override bool AllowNullParenting => true;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		base.ServerCommand(item, command, player);
		MobileInventoryEntity associatedEntity = ItemModAssociatedEntity<MobileInventoryEntity>.GetAssociatedEntity(item);
		if (command == "silenton")
		{
			associatedEntity.SetSilentMode(wantsSilent: true);
		}
		else if (command == "silentoff")
		{
			associatedEntity.SetSilentMode(wantsSilent: false);
		}
	}
}


public class ItemModCassette : ItemModAssociatedEntity<Cassette>
{
	public int noteSpriteIndex;

	public PreloadedCassetteContent PreloadedContent;

	protected override bool AllowNullParenting => true;

	protected override bool AllowHeldEntityParenting => true;

	protected override void OnAssociatedItemCreated(Cassette ent)
	{
		base.OnAssociatedItemCreated(ent);
		ent.AssignPreloadContent();
	}
}


using System;
using UnityEngine;

public class LaserLight : AudioVisualisationEntity
{
	[Serializable]
	public struct ColourSetting
	{
		public Color PointLightColour;

		public Material LaserMaterial;

		public Color DotColour;

		public Color FlareColour;
	}

	public Animator LaserAnimator;

	public LineRenderer[] LineRenderers;

	public MeshRenderer[] DotRenderers;

	public MeshRenderer FlareRenderer;

	public Light[] LightSources;

	public ColourSetting RedSettings;

	public ColourSetting GreenSettings;

	public ColourSetting BlueSettings;

	public ColourSetting YellowSettings;

	public ColourSetting PinkSettings;

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ColourSetting
{
	public Color PointLightColour;

	public Material LaserMaterial;

	public Color DotColour;

	public Color FlareColour;
}


public class MicrophoneStandIOEntity : IOEntity, IAudioConnectionSource
{
	public int PowerCost = 5;

	public TriggerBase InstrumentTrigger;

	public bool IsStatic;

	public override int ConsumptionAmount()
	{
		return PowerCost;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		return PowerCost;
	}

	public override int MaximalPowerOutput()
	{
		if (IsStatic)
		{
			return 100;
		}
		return base.MaximalPowerOutput();
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		if (IsStatic)
		{
			return 100;
		}
		return base.CalculateCurrentEnergy(inputAmount, inputSlot);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (IsStatic)
		{
			return 100;
		}
		return base.GetPassthroughAmount(outputSlot);
	}

	public override bool IsRootEntity()
	{
		if (IsStatic)
		{
			return true;
		}
		return base.IsRootEntity();
	}

	public IOEntity ToEntity()
	{
		return this;
	}
}


public class MobileInventoryEntity : BaseEntity
{
	public SoundDefinition ringingLoop;

	public SoundDefinition silentLoop;

	public const Flags Ringing = Flags.Reserved1;

	public static Flags Flag_Silent = Flags.Reserved2;

	public void ToggleRinging(bool state)
	{
		SetFlag(Flags.Reserved1, state);
	}

	public void SetSilentMode(bool wantsSilent)
	{
		SetFlag(Flag_Silent, wantsSilent);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class PhoneController : EntityComponent<BaseEntity>
{
	public int PhoneNumber;

	public string PhoneName;

	public bool CanModifyPhoneName = true;

	public bool CanSaveNumbers = true;

	public bool RequirePower = true;

	public bool RequireParent;

	public const float CallWaitingTime = 24f;

	public bool AppendGridToName;

	public bool IsMobile;

	public bool CanSaveVoicemail;

	public GameObjectRef PhoneDialog;

	public VoiceProcessor VProcessor;

	public PreloadedCassetteContent PreloadedContent;

	public SoundDefinition DialToneSfx;

	public SoundDefinition RingingSfx;

	public SoundDefinition ErrorSfx;

	public SoundDefinition CallIncomingWhileBusySfx;

	public SoundDefinition PickupHandsetSfx;

	public SoundDefinition PutDownHandsetSfx;

	public SoundDefinition FailedWrongNumber;

	public SoundDefinition FailedNoAnswer;

	public SoundDefinition FailedNetworkBusy;

	public SoundDefinition FailedEngaged;

	public SoundDefinition FailedRemoteHangUp;

	public SoundDefinition FailedSelfHangUp;

	public Light RingingLight;

	public float RingingLightFrequency = 0.4f;

	public AudioSource answeringMachineSound;

	public EntityRef currentPlayerRef;

	public List<VoicemailEntry> savedVoicemail;

	public PhoneController activeCallTo;

	public int MaxVoicemailSlots
	{
		get
		{
			if (!((Object)(object)cachedCassette != (Object)null))
			{
				return 0;
			}
			return cachedCassette.MaximumVoicemailSlots;
		}
	}

	public BasePlayer currentPlayer
	{
		get
		{
			if (currentPlayerRef.IsValid(isServer))
			{
				return currentPlayerRef.Get(isServer).ToPlayer();
			}
			return null;
		}
		set
		{
			currentPlayerRef.Set(value);
		}
	}

	private bool isServer
	{
		get
		{
			if ((Object)(object)base.baseEntity != (Object)null)
			{
				return base.baseEntity.isServer;
			}
			return false;
		}
	}

	public int lastDialedNumber { get; set; }

	public PhoneDirectory savedNumbers { get; set; }

	public BaseEntity ParentEntity => base.baseEntity;

	private Cassette cachedCassette
	{
		get
		{
			if (!((Object)(object)base.baseEntity != (Object)null) || !(base.baseEntity is Telephone telephone))
			{
				return null;
			}
			return telephone.cachedCassette;
		}
	}

	public Telephone.CallState serverState { get; set; }

	public uint AnsweringMessageId
	{
		get
		{
			if (!(base.baseEntity is Telephone telephone))
			{
				return 0u;
			}
			return telephone.AnsweringMessageId;
		}
	}

	public override void DestroyShared()
	{
		DestroyServer();
	}

	private bool IsPowered()
	{
		if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity is IOEntity iOEntity)
		{
			return iOEntity.IsPowered();
		}
		return false;
	}

	public bool IsSavedContactValid(string contactName, int contactNumber)
	{
		if (contactName.Length <= 0 || contactName.Length > 30)
		{
			return false;
		}
		if (contactNumber < 10000000 || contactNumber >= 100000000)
		{
			return false;
		}
		return true;
	}

	public void OnFlagsChanged(BaseEntity.Flags old, BaseEntity.Flags next)
	{
	}

	public void ServerInit()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (PhoneNumber == 0 && !Application.isLoadingSave)
		{
			PhoneNumber = TelephoneManager.GetUnusedTelephoneNumber();
			if (AppendGridToName & !string.IsNullOrEmpty(PhoneName))
			{
				PhoneName = PhoneName + " [" + MapHelper.PositionToString(((Component)this).transform.position) + "]";
			}
			TelephoneManager.RegisterTelephone(this);
		}
	}

	public void PostServerLoad()
	{
		currentPlayer = null;
		base.baseEntity.SetFlag(BaseEntity.Flags.Busy, b: false);
		TelephoneManager.RegisterTelephone(this);
	}

	public void DoServerDestroy()
	{
		TelephoneManager.DeregisterTelephone(this);
	}

	public void ClearCurrentUser(BaseEntity.RPCMessage msg)
	{
		ClearCurrentUser();
	}

	public void ClearCurrentUser()
	{
		if ((Object)(object)currentPlayer != (Object)null)
		{
			currentPlayer.SetActiveTelephone(null);
			currentPlayer = null;
		}
		base.baseEntity.SetFlag(BaseEntity.Flags.Busy, b: false);
	}

	public void SetCurrentUser(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)currentPlayer == (Object)(object)player))
		{
			UpdateServerPlayer(player);
			if (serverState == Telephone.CallState.Dialing || serverState == Telephone.CallState.Ringing || serverState == Telephone.CallState.InProcess)
			{
				ServerHangUp(default(BaseEntity.RPCMessage));
			}
		}
	}

	private void UpdateServerPlayer(BasePlayer newPlayer)
	{
		if (!((Object)(object)currentPlayer == (Object)(object)newPlayer))
		{
			if ((Object)(object)currentPlayer != (Object)null)
			{
				currentPlayer.SetActiveTelephone(null);
			}
			currentPlayer = newPlayer;
			base.baseEntity.SetFlag(BaseEntity.Flags.Busy, (Object)(object)currentPlayer != (Object)null);
			if ((Object)(object)currentPlayer != (Object)null)
			{
				currentPlayer.SetActiveTelephone(this);
			}
		}
	}

	public void InitiateCall(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)currentPlayer))
		{
			int number = msg.read.Int32();
			CallPhone(number);
		}
	}

	public void CallPhone(int number)
	{
		if (number == PhoneNumber)
		{
			OnDialFailed(Telephone.DialFailReason.CallSelf);
			return;
		}
		if (TelephoneManager.GetCurrentActiveCalls() + 1 > TelephoneManager.MaxConcurrentCalls)
		{
			OnDialFailed(Telephone.DialFailReason.NetworkBusy);
			return;
		}
		PhoneController telephone = TelephoneManager.GetTelephone(number);
		if ((Object)(object)telephone != (Object)null)
		{
			if (Interface.CallHook("OnPhoneDial", (object)this, (object)telephone, (object)currentPlayer) == null)
			{
				if (telephone.serverState == Telephone.CallState.Idle && telephone.CanReceiveCall())
				{
					SetPhoneState(Telephone.CallState.Dialing);
					lastDialedNumber = number;
					activeCallTo = telephone;
					activeCallTo.ReceiveCallFrom(this);
				}
				else
				{
					OnDialFailed(Telephone.DialFailReason.Engaged);
					telephone.OnIncomingCallWhileBusy();
				}
			}
		}
		else
		{
			OnDialFailed(Telephone.DialFailReason.WrongNumber);
		}
	}

	private bool CanReceiveCall()
	{
		object obj = Interface.CallHook("CanReceiveCall", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequirePower && !IsPowered())
		{
			return false;
		}
		if (RequireParent && !base.baseEntity.HasParent())
		{
			return false;
		}
		return true;
	}

	public void AnswerPhone(BaseEntity.RPCMessage msg)
	{
		if (((FacepunchBehaviour)this).IsInvoking((Action)TimeOutDialing))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TimeOutDialing);
		}
		if (!((Object)(object)activeCallTo == (Object)null))
		{
			BasePlayer player = msg.player;
			if (Interface.CallHook("OnPhoneAnswer", (object)this, (object)activeCallTo) == null)
			{
				UpdateServerPlayer(player);
				BeginCall();
				activeCallTo.BeginCall();
				Interface.CallHook("OnPhoneAnswered", (object)this, (object)activeCallTo);
			}
		}
	}

	public void ReceiveCallFrom(PhoneController t)
	{
		activeCallTo = t;
		SetPhoneState(Telephone.CallState.Ringing);
		((FacepunchBehaviour)this).Invoke((Action)TimeOutDialing, 24f);
	}

	private void TimeOutDialing()
	{
		if (Interface.CallHook("OnPhoneDialTimeout", (object)activeCallTo, (object)this, (object)activeCallTo.currentPlayer) == null)
		{
			if ((Object)(object)activeCallTo != (Object)null)
			{
				activeCallTo.ServerPlayAnsweringMessage(this);
			}
			SetPhoneState(Telephone.CallState.Idle);
			Interface.CallHook("OnPhoneDialTimedOut", (object)activeCallTo, (object)this, (object)activeCallTo.currentPlayer);
		}
	}

	public void OnDialFailed(Telephone.DialFailReason reason)
	{
		if (Interface.CallHook("OnPhoneDialFail", (object)this, (object)reason, (object)currentPlayer) == null)
		{
			SetPhoneState(Telephone.CallState.Idle);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientOnDialFailed"), (int)reason);
			activeCallTo = null;
			if (((FacepunchBehaviour)this).IsInvoking((Action)TimeOutCall))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)TimeOutCall);
			}
			if (((FacepunchBehaviour)this).IsInvoking((Action)TriggerTimeOut))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)TriggerTimeOut);
			}
			if (((FacepunchBehaviour)this).IsInvoking((Action)TimeOutDialing))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)TimeOutDialing);
			}
			Interface.CallHook("OnPhoneDialFailed", (object)this, (object)reason, (object)currentPlayer);
		}
	}

	public void ServerPlayAnsweringMessage(PhoneController fromPhone)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId arg = default(NetworkableId);
		uint num = 0u;
		uint arg2 = 0u;
		if ((Object)(object)activeCallTo != (Object)null && (Object)(object)activeCallTo.cachedCassette != (Object)null)
		{
			arg = activeCallTo.cachedCassette.net.ID;
			num = activeCallTo.cachedCassette.AudioId;
			if (num == 0)
			{
				arg2 = activeCallTo.cachedCassette.PreloadContent.GetSoundContentId(activeCallTo.cachedCassette.PreloadedAudio);
			}
		}
		if (((NetworkableId)(ref arg)).IsValid)
		{
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientPlayAnsweringMessage"), arg, num, arg2, fromPhone.HasVoicemailSlot() ? 1 : 0, activeCallTo.PhoneNumber);
			((FacepunchBehaviour)this).Invoke((Action)TriggerTimeOut, activeCallTo.cachedCassette.MaxCassetteLength);
		}
		else
		{
			OnDialFailed(Telephone.DialFailReason.TimedOut);
		}
	}

	private void TriggerTimeOut()
	{
		OnDialFailed(Telephone.DialFailReason.TimedOut);
	}

	public void SetPhoneStateWithPlayer(Telephone.CallState state)
	{
		serverState = state;
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("SetClientState"), (int)serverState, ((Object)(object)activeCallTo != (Object)null) ? activeCallTo.PhoneNumber : 0);
		if (base.baseEntity is MobilePhone mobilePhone)
		{
			mobilePhone.ToggleRinging(state == Telephone.CallState.Ringing);
		}
	}

	private void SetPhoneState(Telephone.CallState state)
	{
		if (state == Telephone.CallState.Idle && (Object)(object)currentPlayer == (Object)null)
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Busy, b: false);
		}
		serverState = state;
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("SetClientState"), (int)serverState, ((Object)(object)activeCallTo != (Object)null) ? activeCallTo.PhoneNumber : 0);
		if (base.baseEntity is Telephone telephone)
		{
			telephone.MarkDirtyForceUpdateOutputs();
		}
		if (base.baseEntity is MobilePhone mobilePhone)
		{
			mobilePhone.ToggleRinging(state == Telephone.CallState.Ringing);
		}
	}

	public void BeginCall()
	{
		if (Interface.CallHook("OnPhoneCallStart", (object)this, (object)activeCallTo, (object)currentPlayer) == null)
		{
			if (IsMobile && (Object)(object)activeCallTo != (Object)null && !activeCallTo.RequirePower)
			{
				_ = (Object)(object)currentPlayer != (Object)null;
			}
			SetPhoneStateWithPlayer(Telephone.CallState.InProcess);
			((FacepunchBehaviour)this).Invoke((Action)TimeOutCall, (float)TelephoneManager.MaxCallLength);
			Interface.CallHook("OnPhoneCallStarted", (object)this, (object)activeCallTo, (object)currentPlayer);
		}
	}

	public void ServerHangUp(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)currentPlayer))
		{
			ServerHangUp();
		}
	}

	public void ServerHangUp()
	{
		if ((Object)(object)activeCallTo != (Object)null)
		{
			activeCallTo.RemoteHangUp();
		}
		SelfHangUp();
	}

	private void SelfHangUp()
	{
		OnDialFailed(Telephone.DialFailReason.SelfHangUp);
	}

	private void RemoteHangUp()
	{
		OnDialFailed(Telephone.DialFailReason.RemoteHangUp);
	}

	private void TimeOutCall()
	{
		OnDialFailed(Telephone.DialFailReason.TimeOutDuringCall);
	}

	public void OnReceivedVoiceFromUser(byte[] data)
	{
		if ((Object)(object)activeCallTo != (Object)null)
		{
			activeCallTo.OnReceivedDataFromConnectedPhone(data);
		}
	}

	public void OnReceivedDataFromConnectedPhone(byte[] data)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity obj = base.baseEntity;
		SendInfo sendInfo = default(SendInfo);
		((SendInfo)(ref sendInfo))..ctor(BaseNetworkable.GetConnectionsWithin(((Component)this).transform.position, 15f));
		sendInfo.priority = (Priority)0;
		obj.ClientRPC(RpcTarget.SendInfo("OnReceivedVoice", sendInfo), data.Length, data);
	}

	public void OnIncomingCallWhileBusy()
	{
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnIncomingCallDuringCall"));
	}

	private void DestroyServer()
	{
		if (isServer && serverState != 0 && (Object)(object)activeCallTo != (Object)null)
		{
			activeCallTo.RemoteHangUp();
		}
	}

	public void UpdatePhoneName(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)currentPlayer))
		{
			string text = msg.read.String(256, false);
			if (text.Length > 30)
			{
				text = text.Substring(0, 30);
			}
			if (Interface.CallHook("OnPhoneNameUpdate", (object)this, (object)text, (object)msg.player) == null)
			{
				PhoneName = text;
				base.baseEntity.SendNetworkUpdate();
				Interface.CallHook("OnPhoneNameUpdated", (object)this, (object)PhoneName, (object)msg.player);
			}
		}
	}

	public void Server_RequestPhoneDirectory(BaseEntity.RPCMessage msg)
	{
		if ((Object)(object)msg.player != (Object)(object)currentPlayer)
		{
			return;
		}
		int page = msg.read.Int32();
		PhoneDirectory val = Pool.Get<PhoneDirectory>();
		try
		{
			TelephoneManager.GetPhoneDirectory(PhoneNumber, page, 12, val);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ReceivePhoneDirectory"), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Server_AddSavedNumber(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)currentPlayer))
		{
			if (savedNumbers == null)
			{
				savedNumbers = Pool.Get<PhoneDirectory>();
			}
			if (savedNumbers.entries == null)
			{
				savedNumbers.entries = Pool.Get<List<DirectoryEntry>>();
			}
			int num = msg.read.Int32();
			string text = msg.read.String(256, false);
			if (IsSavedContactValid(text, num) && savedNumbers.entries.Count < 10)
			{
				DirectoryEntry val = Pool.Get<DirectoryEntry>();
				val.phoneName = text;
				val.phoneNumber = num;
				val.ShouldPool = false;
				savedNumbers.ShouldPool = false;
				savedNumbers.entries.Add(val);
				base.baseEntity.SendNetworkUpdate();
			}
		}
	}

	public void Server_RemoveSavedNumber(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)currentPlayer))
		{
			uint number = msg.read.UInt32();
			if (savedNumbers.entries.RemoveAll((DirectoryEntry p) => p.phoneNumber == number) > 0)
			{
				base.baseEntity.SendNetworkUpdate();
			}
		}
	}

	public string GetDirectoryName()
	{
		return PhoneName;
	}

	public void WatchForDisconnects()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if ((Object)(object)currentPlayer != (Object)null)
		{
			if (currentPlayer.IsSleeping())
			{
				flag = true;
			}
			if (currentPlayer.IsDead())
			{
				flag = true;
			}
			if (Vector3.Distance(((Component)this).transform.position, ((Component)currentPlayer).transform.position) > 5f)
			{
				flag = true;
			}
		}
		else
		{
			flag = true;
		}
		if (flag)
		{
			ServerHangUp();
			ClearCurrentUser();
		}
	}

	public void OnParentChanged(BaseEntity newParent)
	{
		if ((Object)(object)newParent != (Object)null && newParent is BasePlayer)
		{
			TelephoneManager.RegisterTelephone(this, checkPhoneNumber: true);
		}
		else
		{
			TelephoneManager.DeregisterTelephone(this);
		}
	}

	private bool HasVoicemailSlot()
	{
		return MaxVoicemailSlots > 0;
	}

	public void ServerSendVoicemail(BaseEntity.RPCMessage msg)
	{
		if (!((Object)(object)msg.player == (Object)null))
		{
			byte[] data = msg.read.BytesWithSize(10485760u, false);
			PhoneController telephone = TelephoneManager.GetTelephone(msg.read.Int32());
			if (!((Object)(object)telephone == (Object)null) && Cassette.IsOggValid(data, telephone.cachedCassette))
			{
				telephone.SaveVoicemail(data, msg.player.displayName);
			}
		}
	}

	public void SaveVoicemail(byte[] data, string playerName)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		uint audioId = FileStorage.server.Store(data, FileStorage.Type.ogg, base.baseEntity.net.ID);
		if (savedVoicemail == null)
		{
			savedVoicemail = Pool.Get<List<VoicemailEntry>>();
		}
		VoicemailEntry val = Pool.Get<VoicemailEntry>();
		val.audioId = audioId;
		val.timestamp = DateTime.Now.ToBinary();
		val.userName = playerName;
		val.ShouldPool = false;
		savedVoicemail.Add(val);
		while (savedVoicemail.Count > MaxVoicemailSlots)
		{
			FileStorage.server.Remove(savedVoicemail[0].audioId, FileStorage.Type.ogg, base.baseEntity.net.ID);
			savedVoicemail.RemoveAt(0);
		}
		base.baseEntity.SendNetworkUpdate();
	}

	public void ServerPlayVoicemail(BaseEntity.RPCMessage msg)
	{
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientToggleVoicemail"), 1, msg.read.UInt32());
	}

	public void ServerStopVoicemail(BaseEntity.RPCMessage msg)
	{
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientToggleVoicemail"), 0, 0);
	}

	public void ServerDeleteVoicemail(BaseEntity.RPCMessage msg)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		uint num = msg.read.UInt32();
		for (int i = 0; i < savedVoicemail.Count; i++)
		{
			if (savedVoicemail[i].audioId == num)
			{
				VoicemailEntry val = savedVoicemail[i];
				FileStorage.server.Remove(val.audioId, FileStorage.Type.ogg, base.baseEntity.net.ID);
				val.ShouldPool = true;
				Pool.Free<VoicemailEntry>(ref val);
				savedVoicemail.RemoveAt(i);
				base.baseEntity.SendNetworkUpdate();
				break;
			}
		}
	}

	public void DeleteAllVoicemail()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (savedVoicemail == null)
		{
			return;
		}
		foreach (VoicemailEntry item in savedVoicemail)
		{
			item.ShouldPool = true;
			FileStorage.server.Remove(item.audioId, FileStorage.Type.ogg, base.baseEntity.net.ID);
		}
		Pool.Free<VoicemailEntry>(ref savedVoicemail, false);
	}
}


using UnityEngine;

public class PreloadedCassetteContent : ScriptableObject
{
	public enum PreloadType
	{
		Short,
		Medium,
		Long
	}

	public SoundDefinition[] ShortTapeContent;

	public SoundDefinition[] MediumTapeContent;

	public SoundDefinition[] LongTapeContent;

	public SoundDefinition GetSoundContent(int index, PreloadType type)
	{
		return type switch
		{
			PreloadType.Short => GetDefinition(index, ShortTapeContent), 
			PreloadType.Medium => GetDefinition(index, MediumTapeContent), 
			PreloadType.Long => GetDefinition(index, LongTapeContent), 
			_ => null, 
		};
	}

	private SoundDefinition GetDefinition(int index, SoundDefinition[] array)
	{
		index = Mathf.Clamp(index, 0, array.Length);
		return array[index];
	}

	public uint GetSoundContentId(SoundDefinition def)
	{
		uint num = 0u;
		SoundDefinition[] shortTapeContent = ShortTapeContent;
		for (int i = 0; i < shortTapeContent.Length; i++)
		{
			if ((Object)(object)shortTapeContent[i] == (Object)(object)def)
			{
				return num;
			}
			num++;
		}
		shortTapeContent = MediumTapeContent;
		for (int i = 0; i < shortTapeContent.Length; i++)
		{
			if ((Object)(object)shortTapeContent[i] == (Object)(object)def)
			{
				return num;
			}
			num++;
		}
		shortTapeContent = LongTapeContent;
		for (int i = 0; i < shortTapeContent.Length; i++)
		{
			if ((Object)(object)shortTapeContent[i] == (Object)(object)def)
			{
				return num;
			}
			num++;
		}
		return num;
	}

	public SoundDefinition GetSoundContent(uint id)
	{
		int num = 0;
		SoundDefinition[] shortTapeContent = ShortTapeContent;
		foreach (SoundDefinition result in shortTapeContent)
		{
			if (num++ == id)
			{
				return result;
			}
		}
		shortTapeContent = MediumTapeContent;
		foreach (SoundDefinition result2 in shortTapeContent)
		{
			if (num++ == id)
			{
				return result2;
			}
		}
		shortTapeContent = LongTapeContent;
		foreach (SoundDefinition result3 in shortTapeContent)
		{
			if (num++ == id)
			{
				return result3;
			}
		}
		return null;
	}
}


public enum PreloadType
{
	Short,
	Medium,
	Long
}


using UnityEngine;

[CreateAssetMenu]
public class RadioPlaylist : BaseScriptableObject
{
	public string LocalName;

	public string Url;

	public AudioClip[] Playlist;

	public float PlaylistLength;
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public static class TelephoneManager
{
	public const int MaxPhoneNumber = 99990000;

	public const int MinPhoneNumber = 10000000;

	[ServerVar]
	public static int MaxConcurrentCalls = 10;

	[ServerVar]
	public static int MaxCallLength = 120;

	public static Dictionary<int, PhoneController> allTelephones = new Dictionary<int, PhoneController>();

	public static int maxAssignedPhoneNumber = 99990000;

	public static int GetUnusedTelephoneNumber()
	{
		int num = Random.Range(10000000, 99990000);
		int num2 = 0;
		int num3 = 1000;
		while (allTelephones.ContainsKey(num) && num2 < num3)
		{
			num2++;
			num = Random.Range(10000000, 99990000);
		}
		if (num2 == num3)
		{
			num = maxAssignedPhoneNumber + 1;
		}
		maxAssignedPhoneNumber = Mathf.Max(maxAssignedPhoneNumber, num);
		return num;
	}

	public static void RegisterTelephone(PhoneController t, bool checkPhoneNumber = false)
	{
		if (checkPhoneNumber && allTelephones.ContainsKey(t.PhoneNumber) && (Object)(object)allTelephones[t.PhoneNumber] != (Object)(object)t)
		{
			t.PhoneNumber = GetUnusedTelephoneNumber();
		}
		if (!allTelephones.ContainsKey(t.PhoneNumber) && t.PhoneNumber != 0)
		{
			allTelephones.Add(t.PhoneNumber, t);
			maxAssignedPhoneNumber = Mathf.Max(maxAssignedPhoneNumber, t.PhoneNumber);
		}
	}

	public static void DeregisterTelephone(PhoneController t)
	{
		allTelephones.Remove(t.PhoneNumber);
	}

	public static PhoneController GetTelephone(int number)
	{
		return allTelephones.GetValueOrDefault(number);
	}

	public static PhoneController GetRandomTelephone(int ignoreNumber)
	{
		foreach (KeyValuePair<int, PhoneController> allTelephone in allTelephones)
		{
			if (allTelephone.Value.PhoneNumber != ignoreNumber)
			{
				return allTelephone.Value;
			}
		}
		return null;
	}

	public static int GetCurrentActiveCalls()
	{
		int num = 0;
		foreach (KeyValuePair<int, PhoneController> allTelephone in allTelephones)
		{
			if (allTelephone.Value.serverState != 0)
			{
				num++;
			}
		}
		if (num == 0)
		{
			return 0;
		}
		return num / 2;
	}

	public static void GetPhoneDirectory(int ignoreNumber, int page, int perPage, PhoneDirectory directory)
	{
		directory.entries = Pool.Get<List<DirectoryEntry>>();
		int startIndex = page * perPage;
		int count = 0;
		if (!AddPhonesToDirectory(playerOnly: true) && !AddPhonesToDirectory(playerOnly: false))
		{
			directory.atEnd = true;
		}
		bool AddPhonesToDirectory(bool playerOnly)
		{
			foreach (KeyValuePair<int, PhoneController> allTelephone in allTelephones)
			{
				if (allTelephone.Key != ignoreNumber && !string.IsNullOrEmpty(allTelephone.Value.PhoneName) && (!playerOnly || allTelephone.Value.CanModifyPhoneName) && (playerOnly || !allTelephone.Value.CanModifyPhoneName))
				{
					count++;
					if (count >= startIndex)
					{
						DirectoryEntry val = Pool.Get<DirectoryEntry>();
						val.phoneName = allTelephone.Value.GetDirectoryName();
						val.phoneNumber = allTelephone.Value.PhoneNumber;
						directory.entries.Add(val);
						if (directory.entries.Count >= perPage)
						{
							directory.atEnd = false;
							return true;
						}
					}
				}
			}
			return false;
		}
	}

	[ServerVar]
	public static void PrintAllPhones(Arg arg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		TextTable val = new TextTable();
		val.AddColumns(new string[3] { "Number", "Name", "Position" });
		foreach (KeyValuePair<int, PhoneController> allTelephone in allTelephones)
		{
			Vector3 position = ((Component)allTelephone.Value).transform.position;
			val.AddRow(new string[3]
			{
				allTelephone.Key.ToString(),
				allTelephone.Value.GetDirectoryName(),
				$"{position.x} {position.y} {position.z}"
			});
		}
		arg.ReplyWith(((object)val).ToString());
	}
}


using UnityEngine;

public class AudioInterceptComponent : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class BaseCorpse : BaseCombatEntity, Hopper.IHopperTarget
{
	public GameObjectRef prefabRagdoll;

	public BaseEntity parentEnt;

	[NonSerialized]
	public ResourceDispenser resourceDispenser;

	public const float CORPSE_SLEEP_THRESHOLD = 0.05f;

	protected Rigidbody rigidBody;

	public bool blockDamageIfNotGather;

	public const Flags FLAG_HOPPERANIMATING = Flags.Reserved1;

	public const Flags FLAG_CORPSEBEINGCARRIED = Flags.Reserved3;

	[NonSerialized]
	public SpawnGroup spawnGroup;

	private const float RAGDOLL_PUSH_DIST = 0.5f;

	private const float RAGDOLL_PUSH_FORCE = 2.5f;

	public virtual bool CorpseIsRagdoll => false;

	public bool IsSleeping
	{
		get
		{
			if ((Object)(object)rigidBody != (Object)null)
			{
				return rigidBody.IsSleeping();
			}
			return false;
		}
	}

	public override TraitFlag Traits => base.Traits | TraitFlag.Food | TraitFlag.Meat;

	public BaseEntity ToEntity => this;

	public Rigidbody Rigidbody => rigidBody;

	public virtual int NumberOfItemsToTransfer
	{
		get
		{
			int num = 0;
			ResourceDispenser resourceDispenser = default(ResourceDispenser);
			if (((Component)this).TryGetComponent<ResourceDispenser>(ref resourceDispenser))
			{
				num += resourceDispenser.containedItems.Count;
			}
			return num;
		}
	}

	public float EndPositionToleranceMultiplier => 2f;

	public override void ResetState()
	{
		spawnGroup = null;
		base.ResetState();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		rigidBody = SetupRigidBody();
		ResetRemovalTime();
		resourceDispenser = ((Component)this).GetComponent<ResourceDispenser>();
		SingletonComponent<NpcFoodManager>.Instance.Add(this);
	}

	public virtual void ServerInitCorpse(BaseEntity pr, Vector3 posOnDeah, Quaternion rotOnDeath, BasePlayer.PlayerFlags playerFlagsOnDeath, ModelState modelState)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		parentEnt = pr;
		((Component)this).transform.SetPositionAndRotation(parentEnt.CenterPoint(), ((Component)parentEnt).transform.rotation);
		SpawnPointInstance component = ((Component)this).GetComponent<SpawnPointInstance>();
		if ((Object)(object)component != (Object)null)
		{
			spawnGroup = component.parentSpawnPointUser as SpawnGroup;
		}
	}

	public virtual bool CanRemove()
	{
		return true;
	}

	public void RemoveCorpse()
	{
		if (!CanRemove())
		{
			ResetRemovalTime();
		}
		else
		{
			Kill();
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer)
		{
			SingletonComponent<NpcFoodManager>.Instance.Remove(this);
		}
	}

	public void ResetRemovalTime(float dur)
	{
		TimeWarning val = TimeWarning.New("ResetRemovalTime", 0);
		try
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)RemoveCorpse))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)RemoveCorpse);
			}
			((FacepunchBehaviour)this).Invoke((Action)RemoveCorpse, dur);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual float GetRemovalTime()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null)
		{
			return activeGameMode.CorpseRemovalTime(this);
		}
		return Server.corpsedespawn;
	}

	public void ResetRemovalTime()
	{
		ResetRemovalTime(GetRemovalTime());
	}

	public override void Save(SaveInfo info)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.corpse = Pool.Get<Corpse>();
		if (parentEnt.IsValid())
		{
			info.msg.corpse.parentID = parentEnt.net.ID;
		}
	}

	public void TakeChildren(BaseEntity takeChildrenFrom)
	{
		if (takeChildrenFrom.children == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("Corpse.TakeChildren", 0);
		try
		{
			BaseEntity[] array = takeChildrenFrom.children.ToArray();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SwitchParent(this);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void ApplyInheritedVelocity(Vector3 velocity)
	{
	}

	private Rigidbody SetupRigidBody()
	{
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		if (!prefabRagdoll.isValid)
		{
			return ((Component)this).GetComponent<Rigidbody>();
		}
		if (base.isServer)
		{
			GameObject val = base.gameManager.FindPrefab(prefabRagdoll.resourcePath);
			if ((Object)(object)val == (Object)null)
			{
				return null;
			}
			Ragdoll component = val.GetComponent<Ragdoll>();
			if ((Object)(object)component == (Object)null)
			{
				return null;
			}
			if ((Object)(object)component.primaryBody == (Object)null)
			{
				Debug.LogError((object)("[BaseCorpse] ragdoll.primaryBody isn't set!" + ((Object)((Component)component).gameObject).name));
				return null;
			}
			if ((Object)(object)((Component)this).gameObject.GetComponent<Collider>() == (Object)null)
			{
				BoxCollider component2 = ((Component)component.primaryBody).GetComponent<BoxCollider>();
				if ((Object)(object)component2 == (Object)null)
				{
					Debug.LogError((object)"Ragdoll has unsupported primary collider (make it supported) ", (Object)(object)component);
					return null;
				}
				BoxCollider obj = ((Component)this).gameObject.AddComponent<BoxCollider>();
				obj.size = component2.size * 2f;
				obj.center = component2.center;
				((Collider)obj).sharedMaterial = ((Collider)component2).sharedMaterial;
			}
		}
		Rigidbody val2 = ((Component)this).GetComponent<Rigidbody>();
		if ((Object)(object)val2 == (Object)null)
		{
			val2 = ((Component)this).gameObject.AddComponent<Rigidbody>();
			val2.mass = 10f;
			val2.drag = 0.5f;
			val2.angularDrag = 0.5f;
		}
		val2.useGravity = true;
		val2.collisionDetectionMode = (CollisionDetectionMode)0;
		val2.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
		if (base.isServer)
		{
			Buoyancy component3 = ((Component)this).GetComponent<Buoyancy>();
			if ((Object)(object)component3 != (Object)null)
			{
				component3.rigidBody = val2;
			}
			Vector3 velocity = Vector3Ex.Range(-1f, 1f);
			velocity.y += 1f;
			val2.velocity = velocity;
			val2.collisionDetectionMode = (CollisionDetectionMode)3;
			val2.angularVelocity = Vector3Ex.Range(-10f, 10f);
		}
		return val2;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.corpse != null)
		{
			Load(info.msg.corpse);
		}
	}

	private void Load(Corpse corpse)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			parentEnt = BaseNetworkable.serverEntities.Find(corpse.parentID) as BaseEntity;
		}
		_ = base.isClient;
	}

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isServer)
		{
			return;
		}
		ResetRemovalTime();
		if (!blockDamageIfNotGather || !(info.Weapon is BaseMelee baseMelee) || baseMelee.GetGatherInfoFromIndex(ResourceDispenser.GatherType.Flesh).gatherDamage != 0f)
		{
			if (Object.op_Implicit((Object)(object)resourceDispenser))
			{
				resourceDispenser.DoGather(info, this);
			}
			if (!info.DidGather)
			{
				base.OnAttacked(info);
			}
			if (CorpseIsRagdoll)
			{
				PushRagdoll(info);
			}
		}
	}

	protected virtual void PushRagdoll(HitInfo info)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		List<Rigidbody> list = Pool.Get<List<Rigidbody>>();
		Vis.Components<Rigidbody>(info.HitPositionWorld, 0.5f, list, 512, (QueryTriggerInteraction)2);
		PushRigidbodies(list, info.HitPositionWorld, info.attackNormal);
		Pool.FreeUnmanaged<Rigidbody>(ref list);
	}

	protected void PushRigidbodies(List<Rigidbody> rbs, Vector3 hitPos, Vector3 hitNormal)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		foreach (Rigidbody rb in rbs)
		{
			float num = Vector3.Distance(hitPos, rb.position);
			float num2 = 1f - Mathf.InverseLerp(0f, 0.5f, num);
			if (!(num2 <= 0f))
			{
				if (num2 < 0.5f)
				{
					num2 = 0.5f;
				}
				rb.AddForceAtPosition(hitNormal * 2.5f * num2, hitPos, (ForceMode)1);
			}
		}
	}

	public override string Categorize()
	{
		return "corpse";
	}

	public override void Eat(BaseNpc baseNpc, float timeSpent)
	{
		ResetRemovalTime();
		Hurt(timeSpent * 5f);
		baseNpc.AddCalories(timeSpent * 2f);
	}

	public void PrepareForHopper()
	{
		SetFlag(Flags.Reserved1, b: true);
		Collider val = default(Collider);
		if (((Component)this).TryGetComponent<Collider>(ref val))
		{
			val.enabled = false;
		}
	}

	public void HopperCancelled()
	{
		SetFlag(Flags.Reserved1, b: false);
		Collider val = default(Collider);
		if (((Component)this).TryGetComponent<Collider>(ref val))
		{
			val.enabled = true;
		}
	}

	public virtual void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 fallbackWorldPos)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		ResourceDispenser resourceDispenser = default(ResourceDispenser);
		if (((Component)this).TryGetComponent<ResourceDispenser>(ref resourceDispenser))
		{
			foreach (ItemAmount containedItem in resourceDispenser.containedItems)
			{
				if (containedItem.amount >= 1f)
				{
					Item item = ItemManager.Create(containedItem.itemDef, (int)containedItem.amount, 0uL);
					resourceDispenser.OverrideOwnership(item, null);
					if (!item.MoveToContainer(itemContainer))
					{
						item.Drop(fallbackWorldPos, Vector3.zero, Quaternion.identity);
					}
				}
			}
		}
		Kill();
	}

	public override bool ShouldInheritNetworkGroup()
	{
		return false;
	}
}


using UnityEngine;

public static class BaseEntityEx
{
	public static bool IsValidEntityReference<T>(this T obj) where T : class
	{
		return (Object)(object)(obj as BaseEntity) != (Object)null;
	}

	public static bool HasEntityInParents(this BaseEntity ent, BaseEntity toFind)
	{
		if ((Object)(object)ent == (Object)null || (Object)(object)toFind == (Object)null)
		{
			return false;
		}
		if ((Object)(object)ent == (Object)(object)toFind || ent.EqualNetID((BaseNetworkable)toFind))
		{
			return true;
		}
		BaseEntity parentEntity = ent.GetParentEntity();
		while ((Object)(object)parentEntity != (Object)null)
		{
			if ((Object)(object)parentEntity == (Object)(object)toFind || parentEntity.EqualNetID((BaseNetworkable)toFind))
			{
				return true;
			}
			parentEntity = parentEntity.GetParentEntity();
		}
		return false;
	}
}


public interface IServerFileReceiver
{
}


using ConVar;
using Oxide.Core;
using UnityEngine;

public class AttackEntity : HeldEntity
{
	[Header("Attack Entity")]
	public float deployDelay = 1f;

	public float repeatDelay = 0.5f;

	public float animationDelay;

	[Header("NPCUsage")]
	public float effectiveRange = 1f;

	public float npcDamageScale = 1f;

	public float attackLengthMin = -1f;

	public float attackLengthMax = -1f;

	public float attackSpacing;

	public float aiAimSwayOffset;

	public float aiAimCone;

	public bool aiOnlyInRange;

	public float CloseRangeAddition;

	public float MediumRangeAddition;

	public float LongRangeAddition;

	public bool CanUseAtMediumRange = true;

	public bool CanUseAtLongRange = true;

	public SoundDefinition[] reloadSounds;

	public SoundDefinition thirdPersonMeleeSound;

	[Header("Recoil Compensation")]
	public float recoilCompDelayOverride;

	public bool wantsRecoilComp;

	public bool showCrosshairOnTutorial;

	public bool noHeadshots;

	public EncryptedValue<float> nextAttackTime = float.NegativeInfinity;

	public float NextAttackTime => nextAttackTime;

	public virtual Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.zero;
	}

	public virtual float AmmoFraction()
	{
		return 0f;
	}

	public virtual bool CanReload()
	{
		return false;
	}

	public virtual bool ServerIsReloading()
	{
		return false;
	}

	public virtual void ServerReload()
	{
	}

	public virtual bool ServerTryReload(IAmmoContainer ammoSource)
	{
		return true;
	}

	public virtual void TopUpAmmo()
	{
	}

	public virtual Vector3 ModifyAIAim(Vector3 eulerInput, float swayModifier = 1f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return eulerInput;
	}

	public virtual void GetAttackStats(HitInfo info)
	{
	}

	public void StartAttackCooldownRaw(float cooldown)
	{
		nextAttackTime = Time.time + cooldown;
	}

	public void StartAttackCooldown(float cooldown)
	{
		nextAttackTime = CalculateCooldownTime(nextAttackTime, cooldown, catchup: true, unscaledTime: false);
	}

	public void ResetAttackCooldown()
	{
		nextAttackTime = float.NegativeInfinity;
	}

	public bool HasAttackCooldown()
	{
		return Time.time < (float)nextAttackTime;
	}

	protected float GetAttackCooldown()
	{
		return Mathf.Max((float)nextAttackTime - Time.time, 0f);
	}

	protected float GetAttackIdle()
	{
		return Mathf.Max(Time.time - (float)nextAttackTime, 0f);
	}

	protected float CalculateCooldownTime(float nextTime, float cooldown, bool catchup, bool unscaledTime)
	{
		float num = (unscaledTime ? Time.unscaledTime : Time.time);
		float num2 = 0f;
		if (base.isServer)
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			num2 += 0.1f;
			num2 += cooldown * 0.1f;
			num2 += (Object.op_Implicit((Object)(object)ownerPlayer) ? ownerPlayer.desyncTimeClamped : 0.1f);
			num2 += Mathf.Max(Time.deltaTime, Time.smoothDeltaTime);
		}
		nextTime = ((nextTime < 0f) ? Mathf.Max(0f, num + cooldown - num2) : ((!(num - nextTime <= num2)) ? Mathf.Max(nextTime + cooldown, num + cooldown - num2) : Mathf.Min(nextTime + cooldown, num + cooldown)));
		return nextTime;
	}

	protected bool VerifyClientRPC(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			Debug.LogWarning((object)"Received RPC from null player");
			return false;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Owner not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "owner_missing");
			return false;
		}
		if ((Object)(object)ownerPlayer != (Object)(object)player)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "player_mismatch");
			return false;
		}
		if (player.IsDead())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player dead (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "player_dead");
			return false;
		}
		if (player.IsWounded())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player down (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "player_down");
			return false;
		}
		if (player.IsSleeping())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player sleeping (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "player_sleeping");
			return false;
		}
		if (player.desyncTimeRaw > ConVar.AntiHack.maxdesync)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player stalled (" + base.ShortPrefabName + " with " + player.desyncTimeRaw + "s)");
			player.stats.combat.LogInvalid(player, this, "player_stalled");
			return false;
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Item not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "item_missing");
			return false;
		}
		if (ownerItem.isBroken)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Item broken (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "item_broken");
			return false;
		}
		return true;
	}

	protected virtual bool VerifyClientAttack(BasePlayer player)
	{
		if (!VerifyClientRPC(player))
		{
			return false;
		}
		if (HasAttackCooldown())
		{
			AntiHack.Log(player, AntiHackType.CooldownHack, "T-" + GetAttackCooldown() + "s (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "attack_cooldown");
			return false;
		}
		return true;
	}

	protected bool ValidateEyePos(BasePlayer player, Vector3 eyePos, bool checkLineOfSight = true)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0421: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0462: Unknown result type (might be due to invalid IL or missing references)
		//IL_0464: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnEyePosValidate", (object)this, (object)player, (object)eyePos, (object)checkLineOfSight);
		if (obj is bool)
		{
			return (bool)obj;
		}
		bool flag = true;
		if (Vector3Ex.IsNaNOrInfinity(eyePos))
		{
			string shortPrefabName = base.ShortPrefabName;
			AntiHack.Log(player, AntiHackType.EyeHack, "Contains NaN (" + shortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "eye_nan");
			flag = false;
		}
		if (ConVar.AntiHack.eye_protection > 0)
		{
			Vector3 val;
			if (ConVar.AntiHack.eye_protection >= 1)
			{
				val = player.GetParentVelocity();
				float magnitude = ((Vector3)(ref val)).magnitude;
				val = player.GetMountVelocity();
				float num = magnitude + ((Vector3)(ref val)).magnitude;
				float num2 = ((((player.HasParent() || player.isMounted) ? ConVar.AntiHack.eye_distance_parented_mounted_forgiveness : 0f) + player.estimatedSpeed > 0f) ? ConVar.AntiHack.eye_forgiveness : 0f);
				float num3 = num + num2;
				float num4 = player.tickHistory.Distance(player, eyePos);
				if (num4 > num3)
				{
					string shortPrefabName2 = base.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.EyeHack, "Distance (" + shortPrefabName2 + " on attack with " + num4 + "m > " + num3 + "m)");
					player.stats.combat.LogInvalid(player, this, "eye_distance");
					flag = false;
				}
			}
			if (ConVar.AntiHack.eye_protection >= 3)
			{
				float num5 = Mathf.Abs(player.GetMountVelocity().y + player.GetParentVelocity().y) + BasePlayer.GetJumpHeight();
				float num6 = Mathf.Abs(player.eyes.position.y - eyePos.y);
				if (num6 > num5)
				{
					string shortPrefabName3 = base.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.EyeHack, "Altitude (" + shortPrefabName3 + " on attack with " + num6 + "m > " + num5 + "m)");
					player.stats.combat.LogInvalid(player, this, "eye_altitude");
					flag = false;
				}
			}
			if (checkLineOfSight)
			{
				int num7 = 2162688;
				if (ConVar.AntiHack.eye_terraincheck)
				{
					num7 |= 0x800000;
				}
				if (ConVar.AntiHack.eye_vehiclecheck)
				{
					num7 |= 0x8000000;
				}
				if (ConVar.AntiHack.eye_protection >= 2)
				{
					Vector3 center = player.eyes.center;
					Vector3 position = player.eyes.position;
					if (!GamePhysics.LineOfSightRadius(center, position, num7, ConVar.AntiHack.eye_losradius) || !GamePhysics.LineOfSightRadius(position, eyePos, num7, ConVar.AntiHack.eye_losradius))
					{
						string shortPrefabName4 = base.ShortPrefabName;
						string[] obj2 = new string[8] { "Line of sight (", shortPrefabName4, " on attack) ", null, null, null, null, null };
						val = center;
						obj2[3] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						obj2[4] = " ";
						val = position;
						obj2[5] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						obj2[6] = " ";
						val = eyePos;
						obj2[7] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						AntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj2));
						player.stats.combat.LogInvalid(player, this, "eye_los");
						flag = false;
					}
				}
				if (ConVar.AntiHack.eye_protection >= 4 && !player.HasParent())
				{
					Vector3 position2 = player.eyes.position;
					float num8 = Vector3.Distance(position2, eyePos);
					Collider col;
					if (num8 > ConVar.AntiHack.eye_noclip_cutoff)
					{
						if (AntiHack.TestNoClipping(player, position2, eyePos, BasePlayer.NoClipRadius(ConVar.AntiHack.eye_noclip_margin), ConVar.AntiHack.eye_noclip_backtracking, out col, vehicleLayer: false, null, forceCast: true))
						{
							string shortPrefabName5 = base.ShortPrefabName;
							string[] obj3 = new string[6] { "NoClip (", shortPrefabName5, " on attack) ", null, null, null };
							val = position2;
							obj3[3] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
							obj3[4] = " ";
							val = eyePos;
							obj3[5] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
							AntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj3));
							player.stats.combat.LogInvalid(player, this, "eye_noclip");
							flag = false;
						}
					}
					else if (num8 > 0.01f && AntiHack.TestNoClipping(player, position2, eyePos, 0.1f, ConVar.AntiHack.eye_noclip_backtracking, out col, vehicleLayer: false, null, forceCast: true))
					{
						string shortPrefabName6 = base.ShortPrefabName;
						string[] obj4 = new string[6] { "NoClip (", shortPrefabName6, " on attack) ", null, null, null };
						val = position2;
						obj4[3] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						obj4[4] = " ";
						val = eyePos;
						obj4[5] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						AntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj4));
						player.stats.combat.LogInvalid(player, this, "eye_noclip");
						flag = false;
					}
				}
			}
			if (!flag)
			{
				AntiHack.AddViolation(player, AntiHackType.EyeHack, ConVar.AntiHack.eye_penalty);
			}
			else if (ConVar.AntiHack.eye_protection >= 5 && !player.HasParent() && !player.isMounted)
			{
				player.eyeHistory.PushBack(eyePos);
			}
		}
		return flag;
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		StartAttackCooldown(deployDelay * 0.9f);
	}
}


public static class FishStateExtensions
{
	public static bool Contains(this BaseFishingRod.FishState state, BaseFishingRod.FishState check)
	{
		return (state & check) == check;
	}

	public static BaseFishingRod.FishState FlipHorizontal(this BaseFishingRod.FishState state)
	{
		if (state.Contains(BaseFishingRod.FishState.PullingLeft))
		{
			state |= BaseFishingRod.FishState.PullingRight;
			state &= ~BaseFishingRod.FishState.PullingLeft;
		}
		else if (state.Contains(BaseFishingRod.FishState.PullingRight))
		{
			state |= BaseFishingRod.FishState.PullingLeft;
			state &= ~BaseFishingRod.FishState.PullingRight;
		}
		return state;
	}
}


public class Binocular : AttackEntity
{
	public float[] fovs;

	public GameObjectRef fovChangeEffect;

	public float smoothSpeed = 0.05f;
}


public class BlowPipeWeapon : BaseProjectile
{
	public override bool ForceSendMagazine(SaveInfo saveInfo)
	{
		return true;
	}

	public override void DidAttackServerside()
	{
		SendNetworkUpdateImmediate();
	}
}


public static class ArrowItemDefinitions
{
	private static ItemDefinition _woodenArrowItemDef;

	private static ItemDefinition _boneArrowItemDef;

	private static ItemDefinition _fireArrowItemDef;

	private static ItemDefinition _hvArrowItemDef;

	private static ItemDefinition _poisonArrowItemDef;

	private static ItemDefinition _stoneArrowItemDef;

	public static ItemDefinition WoodenArrowItemDef => _woodenArrowItemDef ?? (_woodenArrowItemDef = ItemManager.FindItemDefinition("ammo_arrow"));

	public static ItemDefinition BoneArrowItemDef => _boneArrowItemDef ?? (_boneArrowItemDef = ItemManager.FindItemDefinition("arrow.bone"));

	public static ItemDefinition FireArrowItemDef => _fireArrowItemDef ?? (_fireArrowItemDef = ItemManager.FindItemDefinition("arrow.fire"));

	public static ItemDefinition HvArrowItemDef => _hvArrowItemDef ?? (_hvArrowItemDef = ItemManager.FindItemDefinition("arrow.hv"));

	public static ItemDefinition PoisonArrowItemDef => _poisonArrowItemDef ?? (_poisonArrowItemDef = ItemManager.FindItemDefinition("ammo_arrow_poison"));

	public static ItemDefinition StoneArrowItemDef => _stoneArrowItemDef ?? (_stoneArrowItemDef = ItemManager.FindItemDefinition("ammo_arrow_stone"));
}


using UnityEngine;

public class Compass : HeldEntity
{
	private const string WORLDMODEL_NEEDLE_PATH = "w_compass_rig/weapon_parent/weapon_root/needle";

	private const string ADMIRE_ANIMEVENT_TAP1 = "AdmireTap1";

	private const string ADMIRE_ANIMEVENT_TAP2 = "AdmireTap2";

	[Tooltip("Change this if it does not feel like the needle direction is accurate.")]
	[SerializeField]
	[Header("Compass")]
	private float needleYawAngleOffset;

	[Min(0f)]
	[SerializeField]
	private float needleStiffness = 50f;

	[Range(0f, 1f)]
	[SerializeField]
	private float needleDamping = 0.5f;

	[Min(0f)]
	[SerializeField]
	private float maxAcceleration = 1500f;

	[Min(0f)]
	[SerializeField]
	private float maxSpeed = 360f;

	[Tooltip("Random variance in how far off the needle will be from target when first deployed.")]
	[SerializeField]
	[MinMax(0f, 180f)]
	private MinMax startingAngleDelta;

	[SerializeField]
	private float wiggleAmplitude = 0.5f;

	[SerializeField]
	private float wiggleFrequency = 1.5f;

	[SerializeField]
	[Min(0f)]
	[Tooltip("Velocity change when the admire animation taps the needle")]
	private float admireTapNeedleVelocity = 300f;
}


public class CrossbowWeapon : BaseProjectile
{
	public override bool ForceSendMagazine(SaveInfo saveInfo)
	{
		return true;
	}

	public override void DidAttackServerside()
	{
		SendNetworkUpdateImmediate();
	}
}


using UnityEngine;

public class FlintStrikeWeapon : BaseProjectile
{
	public float successFraction = 0.5f;

	[Tooltip("By how much do we increase the chance of firing after each failed strike")]
	public float successIncrease = 0.075f;

	public RecoilProperties strikeRecoil;

	public override RecoilProperties GetRecoil()
	{
		return strikeRecoil;
	}
}


using UnityEngine;

public class GeigerCounter : AttackEntity
{
	public Transform geigerRod;

	public Transform leftHand;

	public string attachmentBone;

	public string leftHandBone;
}


public class GrenadeWeapon : ThrownWeapon
{
}


using System;
using Oxide.Core;
using UnityEngine;

public class Hammer : BaseMelee
{
	public override bool CanHit(HitTest info)
	{
		if ((Object)(object)info.HitEntity == (Object)null)
		{
			return false;
		}
		if (info.HitEntity is BasePlayer)
		{
			return false;
		}
		return info.HitEntity is BaseCombatEntity;
	}

	public override void DoAttackShared(HitInfo info)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		BaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity != (Object)null && (Object)(object)ownerPlayer != (Object)null && base.isServer)
		{
			if (Interface.CallHook("OnHammerHit", (object)ownerPlayer, (object)info) != null)
			{
				return;
			}
			TimeWarning val = TimeWarning.New("DoRepair", 50);
			try
			{
				baseCombatEntity.DoRepair(ownerPlayer);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		info.DoDecals = false;
		if (base.isServer)
		{
			Effect.server.ImpactEffect(info);
		}
		else
		{
			Effect.client.ImpactEffect(info);
		}
		StartAttackCooldown(repeatDelay);
	}
}


using UnityEngine;

public class InstrumentToolGuitar : InstrumentTool
{
	public Transform InUseAligner;

	public Transform DeployAligner;

	public string DeployBone;
}


public interface ITurretNotify
{
	void WarmupTick(bool wantsShoot);

	bool CanShoot();

	void OnAddedRemovedToTurret(bool added);
}


using UnityEngine;

public class Keycard : AttackEntity
{
	public int accessLevel
	{
		get
		{
			Item item = GetItem();
			if (item == null)
			{
				return 0;
			}
			ItemModKeycard component = ((Component)item.info).GetComponent<ItemModKeycard>();
			if ((Object)(object)component == (Object)null)
			{
				return 0;
			}
			return component.accessLevel;
		}
	}
}


using UnityEngine;

public class LiquidWeaponEffects : MonoBehaviour
{
	public ParticleSystem RootPS;

	public ParticleSystem EmissionPS;

	public ParticleSystem InnerEmissionPS;

	public LiquidWobble Liquid;

	[Header("Main Stream")]
	public float MinPressureSpeed = 1f;

	public float MaxPressureSpeed = 20f;

	public AnimationCurve PressureSpeedCurve;

	public Vector2 StreamSize = new Vector2(0.04f, 0.08f);

	public AnimationCurve PressureSizeMultiplierCurve;

	[Header("Inner Stream")]
	public float MinPressureInnerSpeed = 1f;

	public float MaxPressureInnerSpeed = 20f;

	public AnimationCurve InnerPressureSpeedCurve;

	public Vector2 InnerStreamSize = new Vector2(0.02f, 0.02f);

	public AnimationCurve InnerPressureSizeMultiplierCurve;

	[Header("Misc")]
	public bool UseImpactSplashEffect;

	public GameObjectRef ImpactSplashEffect;

	public float ImpactSplashEffectInterval = 0.1f;

	public float FillSpeed = 1f;

	[Header("Audio")]
	public bool firstPersonSounds;

	public SoundDefinition shootStartSoundDef;

	public SoundDefinition shootLoopSoundDef;

	public SoundDefinition shootLowPressureLoopSoundDef;

	public SoundDefinition impactStartSoundDef;

	public SoundDefinition impactLoopSoundDef;
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class LockOnLauncher : BaseLauncher
{
	[SerializeField]
	public float lockRange = 250f;

	[SerializeField]
	public float lockConeDot = 0.8f;

	[SerializeField]
	public float timeToLock = 2f;

	[SerializeField]
	private float currentLockTime;

	[SerializeField]
	public float timeToLoseLock = 1f;

	[SerializeField]
	private GameObjectRef camUIDialogPrefab;

	private SeekerTarget currentLockTarget;

	private SeekingServerProjectile projectile;

	private float lockTickRate = 0.1f;

	private float lastSentLockTime;

	private bool HasProjectile => (Object)(object)projectile != (Object)null;

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		currentLockTarget = null;
		currentLockTime = 0f;
		if (IsDisabled())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateLockedEntity);
			SetFlag(Flags.Reserved9, b: false);
			SetFlag(Flags.Reserved10, b: false);
			LetExistingProjectileGo();
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateLockedEntity, 0f, lockTickRate);
		}
	}

	public virtual bool CanLock()
	{
		if (!Object.op_Implicit((Object)(object)GetOwnerPlayer()))
		{
			return false;
		}
		if (!HasProjectile)
		{
			if (CanAttack())
			{
				return primaryMagazine.contents > 0;
			}
			return false;
		}
		return true;
	}

	public void UpdateLockedEntity()
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null && (ownerPlayer.IsSleeping() || ownerPlayer.IsDead()))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateLockedEntity);
			SetFlag(Flags.Reserved9, b: false);
			SetFlag(Flags.Reserved10, b: false);
		}
		else
		{
			if ((Object)(object)ownerPlayer == (Object)null || ownerPlayer.IsSleeping() || ownerPlayer.IsDead() || ownerPlayer.IsWounded())
			{
				return;
			}
			SeekerTarget seekerTarget = null;
			if (CanLock())
			{
				seekerTarget = SeekerTarget.GetBestForPoint(ownerPlayer.eyes.position, ownerPlayer.eyes.BodyForward(), lockConeDot, lockRange);
			}
			else
			{
				currentLockTime = 0f;
			}
			if (seekerTarget == null)
			{
				float num = timeToLock / timeToLoseLock;
				currentLockTime -= lockTickRate * num;
				if (currentLockTime == 0f)
				{
					currentLockTarget = null;
				}
			}
			if (seekerTarget != null && currentLockTarget != null && seekerTarget != currentLockTarget)
			{
				currentLockTime = 0f;
			}
			currentLockTarget = seekerTarget;
			if (currentLockTarget != null)
			{
				currentLockTime += lockTickRate;
				currentLockTarget.SendOwnerMessage(this, "RadarWarning");
			}
			currentLockTime = Mathf.Clamp(currentLockTime, 0f, timeToLock);
			if (currentLockTime != lastSentLockTime)
			{
				SendNetworkUpdate();
			}
			SetFlag(Flags.Reserved9, currentLockTarget != null);
			SetFlag(Flags.Reserved10, currentLockTime >= timeToLock);
			if (HasProjectile)
			{
				projectile.lockedTarget = ((currentLockTarget != null && HasLock()) ? currentLockTarget : null);
			}
			SetFlag(Flags.Busy, HasProjectile);
		}
	}

	public bool HasTarget()
	{
		return HasFlag(Flags.Reserved9);
	}

	protected override void OnReloadStarted()
	{
		LetExistingProjectileGo();
	}

	public override void ProjectileLaunched_Server(ServerProjectile justLaunched)
	{
		base.ProjectileLaunched_Server(justLaunched);
		SeekingServerProjectile component = ((Component)justLaunched).GetComponent<SeekingServerProjectile>();
		component.lockedTarget = currentLockTarget;
		LetExistingProjectileGo();
		projectile = component;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.ioEntity = Pool.Get<IOEntity>();
			info.msg.ioEntity.genericFloat1 = currentLockTime;
			lastSentLockTime = currentLockTime;
		}
	}

	private void LetExistingProjectileGo()
	{
		if (HasProjectile)
		{
			projectile.NotifyOrphaned();
			projectile = null;
		}
	}

	public bool HasLock()
	{
		return HasFlag(Flags.Reserved10);
	}
}


public class MolotovCocktail : GrenadeWeapon
{
}


public class Paddle : BaseMelee
{
	public float animPaddleCooldown = 0.5f;

	public GameObjectRef kayakSeat;

	public float animationLerpSpeed = 6f;
}


using UnityEngine;

public class Speargun : CrossbowWeapon
{
	public GameObject worldAmmoModel;

	public override bool ForceSendMagazine(SaveInfo saveInfo)
	{
		return true;
	}

	protected override bool VerifyClientAttack(BasePlayer player)
	{
		if (player.WaterFactor() < 1f)
		{
			return false;
		}
		return base.VerifyClientAttack(player);
	}

	public override bool CanBeUsedInWater()
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SpinUpWeaponSounds : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class GunshotLayer
	{
		public SoundDefinition startDef;

		public SoundDefinition loopDef;

		public SoundDefinition stopDef;
	}

	public SoundDefinition spinStartDef;

	public SoundDefinition spinReleaseDef;

	public SoundDefinition spinStopDef;

	public SoundDefinition spinLoopUnpitchedDef;

	public SoundDefinition spinLoopPitchedDef;

	public AnimationCurve spinUnpitchedGainCurve;

	public AnimationCurve spinPitchedGainCurve;

	public AnimationCurve spinPitchCurve;

	public AnimationCurve spinPitchedGainCurveDown;

	public AnimationCurve spinPitchCurveDown;

	public List<GunshotLayer> gunshotLayers = new List<GunshotLayer>();
}


using System;

[Serializable]
public class GunshotLayer
{
	public SoundDefinition startDef;

	public SoundDefinition loopDef;

	public SoundDefinition stopDef;
}


using System.Collections.Generic;
using Facepunch;
using Network;

public struct RpcTarget
{
	public string Function;

	public SendInfo Connections;

	public bool ToNetworkGroup;

	public bool UsingPooledConnections;

	public static RpcTarget NetworkGroup(string funcName)
	{
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.ToNetworkGroup = true;
		return result;
	}

	public static RpcTarget NetworkGroup(string funcName, BaseNetworkable entity)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.Connections = new SendInfo(entity.net.group.subscribers);
		return result;
	}

	public static RpcTarget NetworkGroup(string funcName, BaseNetworkable entity, SendMethod method, Priority priority)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		SendInfo connections = default(SendInfo);
		((SendInfo)(ref connections))..ctor(entity.net.group.subscribers);
		connections.method = method;
		connections.priority = priority;
		result.Connections = connections;
		return result;
	}

	public static RpcTarget Player(string funcName, BasePlayer target)
	{
		return Player(funcName, target.IsValid() ? target.net.connection : null);
	}

	public static RpcTarget Player(string funcName, Connection connection)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.Connections = new SendInfo(connection);
		return result;
	}

	public static RpcTarget Players(string funcName, List<Connection> connections)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.Connections = new SendInfo(connections);
		return result;
	}

	public static RpcTarget Players(string funcName, List<Connection> connections, SendMethod method, Priority priority)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		SendInfo connections2 = default(SendInfo);
		((SendInfo)(ref connections2))..ctor(connections);
		connections2.method = method;
		connections2.priority = priority;
		result.Connections = connections2;
		return result;
	}

	public static RpcTarget SendInfo(string funcName, SendInfo sendInfo)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.Connections = sendInfo;
		return result;
	}

	public static RpcTarget PlayerAndSpectators(string funcName, BasePlayer player)
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		List<Connection> list = Pool.Get<List<Connection>>();
		if (player.IsValid())
		{
			if (player.net.connection != null)
			{
				list.Add(player.net.connection);
			}
			if (player.IsBeingSpectated && player.children != null)
			{
				foreach (BaseEntity child in player.children)
				{
					if (child is BasePlayer basePlayer)
					{
						list.Add(basePlayer.net.connection);
					}
				}
			}
		}
		RpcTarget result = default(RpcTarget);
		result.Function = funcName;
		result.Connections = new SendInfo(list);
		result.UsingPooledConnections = true;
		return result;
	}
}


using System;
using Rust;
using Rust.Registry;
using UnityEngine;

public class BaseEntityChild : MonoBehaviour
{
	public static void Setup(GameObject obj, BaseEntity parent)
	{
		TimeWarning val = TimeWarning.New("Registry.Entity.Register", 0);
		try
		{
			Entity.Register(obj, (IEntity)(object)parent);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnDestroy()
	{
		if (Application.isQuitting)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("Registry.Entity.Unregister", 0);
		try
		{
			Entity.Unregister(((Component)this).gameObject);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Network;
using Network.Visibility;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Registry;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;
using UnityEngine.Assertions;

public abstract class BaseNetworkable : BaseMonoBehaviour, IEntity, NetworkHandler, IPrefabPostProcess
{
	public struct SaveInfo
	{
		public Entity msg;

		public bool forDisk;

		public bool forTransfer;

		public Connection forConnection;

		internal bool SendingTo(Connection ownerConnection)
		{
			if (ownerConnection == null)
			{
				return false;
			}
			if (forConnection == null)
			{
				return false;
			}
			return forConnection == ownerConnection;
		}
	}

	public struct LoadInfo
	{
		public Entity msg;

		public bool fromDisk;

		public bool fromCopy;

		public bool fromTransfer;
	}

	public class EntityRealmServer : EntityRealm
	{
		protected override Manager visibilityManager
		{
			get
			{
				if (Net.sv == null)
				{
					return null;
				}
				return Net.sv.visibility;
			}
		}
	}

	public abstract class EntityRealm : IEnumerable<BaseNetworkable>, IEnumerable
	{
		public HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>> entityList = new HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>>(new ListDictionary<NetworkableId, BaseNetworkable>());

		public int Count => entityList.Get().Count;

		protected abstract Manager visibilityManager { get; }

		public bool Contains(NetworkableId uid)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return entityList.Get().Contains(uid);
		}

		public BaseNetworkable Find(NetworkableId uid)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			BaseNetworkable result = null;
			if (!entityList.Get().TryGetValue(uid, ref result))
			{
				return null;
			}
			return result;
		}

		public void RegisterID(BaseNetworkable ent)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			if (ent.net != null)
			{
				ListDictionary<NetworkableId, BaseNetworkable> val = entityList.Get();
				if (val.Contains(ent.net.ID))
				{
					val[ent.net.ID] = ent;
				}
				else
				{
					val.Add(ent.net.ID, ent);
				}
			}
		}

		public void UnregisterID(BaseNetworkable ent)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if (ent.net != null)
			{
				entityList.Get().Remove(ent.net.ID);
			}
		}

		public Group FindGroup(uint uid)
		{
			Manager val = visibilityManager;
			if (val == null)
			{
				return null;
			}
			return val.Get(uid);
		}

		public Group TryFindGroup(uint uid)
		{
			Manager val = visibilityManager;
			if (val == null)
			{
				return null;
			}
			return val.TryGet(uid);
		}

		public void FindInGroup(uint uid, List<BaseNetworkable> list)
		{
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			Group val = TryFindGroup(uid);
			if (val == null)
			{
				return;
			}
			int count = val.networkables.Values.Count;
			Networkable[] buffer = val.networkables.Values.Buffer;
			for (int i = 0; i < count; i++)
			{
				Networkable val2 = buffer[i];
				BaseNetworkable baseNetworkable = Find(val2.ID);
				if (!((Object)(object)baseNetworkable == (Object)null) && baseNetworkable.net != null && baseNetworkable.net.group != null)
				{
					if (baseNetworkable.net.group.ID != uid)
					{
						Debug.LogWarning((object)("Group ID mismatch: " + ((object)baseNetworkable).ToString()));
					}
					else
					{
						list.Add(baseNetworkable);
					}
				}
			}
		}

		public Enumerator<BaseNetworkable> GetEnumerator()
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			return entityList.Get().Values.GetEnumerator();
		}

		IEnumerator<BaseNetworkable> IEnumerable<BaseNetworkable>.GetEnumerator()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return (IEnumerator<BaseNetworkable>)(object)GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return (IEnumerator)(object)GetEnumerator();
		}

		public void Clear()
		{
			entityList.Get().Clear();
		}
	}

	public enum DestroyMode : byte
	{
		None,
		Gib
	}

	[Header("BaseNetworkable")]
	[ReadOnly]
	public uint prefabID;

	[Tooltip("If enabled the entity will send to everyone on the server - regardless of position")]
	public bool globalBroadcast;

	[Tooltip("Global broadcast a cut down version of the entity to show buildings across the map")]
	public bool globalBuildingBlock;

	[NonSerialized]
	public Networkable net;

	private string _prefabName;

	private string _prefabNameWithoutExtension;

	public static EntityRealm serverEntities = new EntityRealmServer();

	private const bool isServersideEntity = true;

	public static List<Connection> connectionsInSphereList = new List<Connection>();

	public List<Component> postNetworkUpdateComponents = new List<Component>();

	public bool _limitedNetworking;

	[NonSerialized]
	public EntityRef parentEntity;

	[NonSerialized]
	public readonly List<BaseEntity> children = new List<BaseEntity>();

	[NonSerialized]
	public bool canTriggerParent = true;

	public int creationFrame;

	public bool isSpawned;

	public ListHashSet<BaseNetworkable> occludees;

	private int lastDemoIndex = -1;

	public MemoryStream _NetworkCache;

	public static Queue<MemoryStream> EntityMemoryStreamPool = new Queue<MemoryStream>();

	private MemoryStream _SaveCache;

	public bool IsDestroyed { get; private set; }

	public string PrefabName
	{
		get
		{
			if (_prefabName == null)
			{
				_prefabName = StringPool.Get(prefabID);
			}
			return _prefabName;
		}
	}

	public string ShortPrefabName
	{
		get
		{
			if (_prefabNameWithoutExtension == null)
			{
				_prefabNameWithoutExtension = Path.GetFileNameWithoutExtension(PrefabName);
			}
			return _prefabNameWithoutExtension;
		}
	}

	public bool isServer => true;

	public bool isClient => false;

	public bool limitNetworking
	{
		get
		{
			return _limitedNetworking;
		}
		set
		{
			if (value != _limitedNetworking)
			{
				_limitedNetworking = value;
				if (_limitedNetworking)
				{
					OnNetworkLimitStart();
				}
				else
				{
					OnNetworkLimitEnd();
				}
				UpdateNetworkGroup();
			}
		}
	}

	public GameManager gameManager
	{
		get
		{
			if (isServer)
			{
				return GameManager.server;
			}
			throw new NotImplementedException("Missing gameManager path");
		}
	}

	public PrefabAttribute.Library prefabAttribute
	{
		get
		{
			if (isServer)
			{
				return PrefabAttribute.server;
			}
			throw new NotImplementedException("Missing prefabAttribute path");
		}
	}

	public static Group GlobalNetworkGroup => Net.sv.visibility.Get(0u);

	public static Group LimboNetworkGroup => Net.sv.visibility.Get(1u);

	public virtual Vector3 GetNetworkPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.localPosition;
	}

	public virtual Quaternion GetNetworkRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.localRotation;
	}

	public string InvokeString()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		List<InvokeAction> list = Pool.Get<List<InvokeAction>>();
		InvokeHandler.FindInvokes((Behaviour)(object)this, list);
		foreach (InvokeAction item in list)
		{
			if (stringBuilder.Length > 0)
			{
				stringBuilder.Append(", ");
			}
			stringBuilder.Append(item.action.Method.Name);
		}
		Pool.FreeUnmanaged<InvokeAction>(ref list);
		return stringBuilder.ToString();
	}

	public BaseEntity LookupPrefab()
	{
		return gameManager.FindPrefab(PrefabName).ToBaseEntity();
	}

	public bool EqualNetID(BaseNetworkable other)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!other.IsRealNull() && other.net != null && net != null)
		{
			return other.net.ID == net.ID;
		}
		return false;
	}

	public bool EqualNetID(NetworkableId otherID)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (net != null)
		{
			return otherID == net.ID;
		}
		return false;
	}

	public virtual void ResetState()
	{
		if (children.Count > 0)
		{
			children.Clear();
		}
		if (this is ILootableEntity lootableEntity)
		{
			lootableEntity.LastLootedBy = 0uL;
		}
	}

	public virtual void InitShared()
	{
	}

	public virtual void PreInitShared()
	{
	}

	public virtual void PostInitShared()
	{
	}

	public virtual void DestroyShared()
	{
	}

	public virtual void OnNetworkGroupEnter(Group group)
	{
		Interface.CallHook("OnNetworkGroupEntered", (object)this, (object)group);
	}

	public virtual void OnNetworkGroupLeave(Group group)
	{
		Interface.CallHook("OnNetworkGroupLeft", (object)this, (object)group);
	}

	public void OnNetworkGroupChange()
	{
		if (children != null && net.group != null)
		{
			foreach (BaseEntity child in children)
			{
				if (child.IsRealNull())
				{
					Debug.LogError((object)"Child is null when switching groups", (Object)(object)this);
				}
				else if (child.net != null)
				{
					if (child.ShouldInheritNetworkGroup())
					{
						child.net.SwitchGroup(net.group);
					}
					else if (isServer)
					{
						child.UpdateNetworkGroup();
					}
				}
			}
		}
		if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion())
		{
			ListHashSet<BaseNetworkable> value;
			if (net.group == null)
			{
				occludees = null;
			}
			else if (ServerOcclusion.Occludees.TryGetValue(net.group, out value))
			{
				occludees = value;
			}
			else
			{
				occludees = null;
			}
		}
	}

	public void OnNetworkSubscribersEnter(List<Connection> connections)
	{
		if (!((BaseNetwork)Net.sv).IsConnected())
		{
			return;
		}
		foreach (Connection connection in connections)
		{
			BasePlayer basePlayer = connection.player as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null))
			{
				basePlayer.QueueUpdate(BasePlayer.NetworkQueue.Update, this as BaseEntity);
			}
		}
	}

	public void OnNetworkSubscribersLeave(List<Connection> connections)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && (!(this is BasePlayer basePlayer) || !basePlayer.IsSpectating()))
		{
			LogEntry(RustLog.EntryType.Network, 2, "LeaveVisibility");
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)6);
			obj.EntityID(net.ID);
			obj.UInt8((byte)0);
			obj.Send(new SendInfo(connections));
		}
	}

	public void EntityDestroy()
	{
		if (Object.op_Implicit((Object)(object)((Component)this).gameObject))
		{
			ResetState();
			gameManager.Retire(((Component)this).gameObject);
		}
	}

	private void DoEntityDestroy()
	{
		if (IsDestroyed)
		{
			return;
		}
		IsDestroyed = true;
		if (Application.isQuitting)
		{
			return;
		}
		DestroyShared();
		if (isServer)
		{
			DoServerDestroy();
		}
		TimeWarning val = TimeWarning.New("Registry.Entity.Unregister", 0);
		try
		{
			Entity.Unregister(((Component)this).gameObject);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SpawnShared()
	{
		IsDestroyed = false;
		TimeWarning val = TimeWarning.New("Registry.Entity.Register", 0);
		try
		{
			Entity.Register(((Component)this).gameObject, (IEntity)(object)this);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void Save(SaveInfo info)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (prefabID == 0)
		{
			Debug.LogError((object)("PrefabID is 0! " + ((Component)this).transform.GetRecursiveName()), (Object)(object)((Component)this).gameObject);
		}
		info.msg.baseNetworkable = Pool.Get<BaseNetworkable>();
		info.msg.baseNetworkable.uid = net.ID;
		info.msg.baseNetworkable.prefabID = prefabID;
		if (net.group != null)
		{
			info.msg.baseNetworkable.group = net.group.ID;
		}
		if (!info.forDisk)
		{
			info.msg.createdThisFrame = creationFrame == Time.frameCount;
		}
	}

	public virtual void PostSave(SaveInfo info)
	{
	}

	public void InitLoad(NetworkableId entityID)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		net = Net.sv.CreateNetworkable(entityID);
		serverEntities.RegisterID(this);
	}

	public virtual void PreServerLoad()
	{
	}

	public virtual void Load(LoadInfo info)
	{
		if (info.msg.baseNetworkable != null)
		{
			LoadInfo loadInfo = info;
			Interface.CallHook("OnEntityLoaded", (object)this, (object)info);
			BaseNetworkable baseNetworkable = loadInfo.msg.baseNetworkable;
			if (prefabID != baseNetworkable.prefabID)
			{
				Debug.LogError((object)("Prefab IDs don't match! " + prefabID + "/" + baseNetworkable.prefabID + " -> " + (object)((Component)this).gameObject), (Object)(object)((Component)this).gameObject);
			}
		}
	}

	public virtual void PostServerLoad()
	{
		((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
	}

	public T ToServer<T>() where T : BaseNetworkable
	{
		if (isServer)
		{
			return this as T;
		}
		return null;
	}

	public virtual bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		return false;
	}

	protected virtual bool OnSyncVar(byte syncVar, NetRead reader, bool fromAutoSave = false)
	{
		return false;
	}

	protected virtual bool WriteSyncVar(byte id, NetWrite writer)
	{
		return false;
	}

	protected virtual bool AutoSaveSyncVars(SaveInfo save)
	{
		return false;
	}

	protected virtual bool AutoLoadSyncVars(LoadInfo load)
	{
		return false;
	}

	protected virtual void ResetSyncVars()
	{
	}

	protected virtual bool IsSyncVarEqual<T>(T oldValue, T newValue)
	{
		return EqualityComparer<T>.Default.Equals(oldValue, newValue);
	}

	public static List<Connection> GetConnectionsWithin(Vector3 position, float distance, bool addSecondaryConnections = false, bool useRcEntityPosition = true)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		connectionsInSphereList.Clear();
		float num = distance * distance;
		List<Connection> subscribers = GlobalNetworkGroup.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (!val.active)
			{
				continue;
			}
			BasePlayer basePlayer = val.player as BasePlayer;
			if ((Object)(object)basePlayer == (Object)null)
			{
				continue;
			}
			if (addSecondaryConnections)
			{
				if (useRcEntityPosition)
				{
					if (basePlayer.RcEntityPosition.HasValue)
					{
						AddSecondaryConnectionsWithin(basePlayer.RcEntityPosition.Value, num, basePlayer);
					}
				}
				else
				{
					AddSecondaryConnectionsWithin(position, num, basePlayer);
				}
			}
			if (!(basePlayer.SqrDistance(position) > num))
			{
				connectionsInSphereList.Add(val);
			}
		}
		return connectionsInSphereList;
	}

	private static void AddSecondaryConnectionsWithin(Vector3 position, float sqrDistance, BasePlayer player)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (position == Vector3.zero || player.net.secondaryGroup == null)
		{
			return;
		}
		foreach (Connection subscriber in player.net.secondaryGroup.subscribers)
		{
			BasePlayer basePlayer = subscriber.player as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > sqrDistance))
			{
				connectionsInSphereList.Add(player.Connection);
			}
		}
	}

	public static void GetCloseConnections(Vector3 position, float distance, List<Connection> foundConnections)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null || Net.sv.visibility == null)
		{
			return;
		}
		float num = distance * distance;
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active)
			{
				BasePlayer basePlayer = val.player as BasePlayer;
				if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > num))
				{
					foundConnections.Add(basePlayer.Connection);
				}
			}
		}
	}

	public static void GetCloseConnections(Vector3 position, float distance, List<BasePlayer> players)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null || Net.sv.visibility == null)
		{
			return;
		}
		float num = distance * distance;
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active)
			{
				BasePlayer basePlayer = val.player as BasePlayer;
				if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > num))
				{
					players.Add(basePlayer);
				}
			}
		}
	}

	public static bool HasCloseConnections(Vector3 position, float distance)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null)
		{
			return false;
		}
		if (Net.sv.visibility == null)
		{
			return false;
		}
		float num = distance * distance;
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return false;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active)
			{
				BasePlayer basePlayer = val.player as BasePlayer;
				if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > num))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool HasConnections(Vector3 position)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null)
		{
			return false;
		}
		if (Net.sv.visibility == null)
		{
			return false;
		}
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return false;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active && !((Object)(object)(val.player as BasePlayer) == (Object)null))
			{
				return true;
			}
		}
		return false;
	}

	public void BroadcastOnPostNetworkUpdate(BaseEntity entity)
	{
		foreach (Component postNetworkUpdateComponent in postNetworkUpdateComponents)
		{
			(postNetworkUpdateComponent as IOnPostNetworkUpdate)?.OnPostNetworkUpdate(entity);
		}
		foreach (BaseEntity child in children)
		{
			child.BroadcastOnPostNetworkUpdate(entity);
		}
	}

	public virtual void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!serverside)
		{
			postNetworkUpdateComponents = ((Component)this).GetComponentsInChildren<IOnPostNetworkUpdate>(true).Cast<Component>().ToList();
		}
	}

	private void OnNetworkLimitStart()
	{
		LogEntry(RustLog.EntryType.Network, 2, "OnNetworkLimitStart");
		List<Connection> subscribers = GetSubscribers();
		if (subscribers == null)
		{
			return;
		}
		subscribers = subscribers.ToList();
		subscribers.RemoveAll((Connection x) => ShouldNetworkTo(x.player as BasePlayer));
		OnNetworkSubscribersLeave(subscribers);
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			child.OnNetworkLimitStart();
		}
	}

	private void OnNetworkLimitEnd()
	{
		LogEntry(RustLog.EntryType.Network, 2, "OnNetworkLimitEnd");
		List<Connection> subscribers = GetSubscribers();
		if (subscribers == null)
		{
			return;
		}
		OnNetworkSubscribersEnter(subscribers);
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			child.OnNetworkLimitEnd();
		}
	}

	public BaseEntity GetParentEntity()
	{
		return parentEntity.Get(isServer);
	}

	public bool HasParent()
	{
		return parentEntity.IsValid(isServer);
	}

	public void AddChild(BaseEntity child)
	{
		if (!children.Contains(child))
		{
			children.Add(child);
			OnChildAdded(child);
		}
	}

	protected virtual void OnChildAdded(BaseEntity child)
	{
	}

	public void RemoveChild(BaseEntity child)
	{
		children.Remove(child);
		OnChildRemoved(child);
	}

	protected virtual void OnChildRemoved(BaseEntity child)
	{
	}

	public virtual float GetNetworkTime()
	{
		return Time.time;
	}

	public virtual void Spawn()
	{
		EntityProfiler.spawned++;
		if (EntityProfiler.mode >= 2)
		{
			EntityProfiler.OnSpawned(this);
		}
		SpawnShared();
		if (net == null)
		{
			net = Net.sv.CreateNetworkable();
		}
		creationFrame = Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		ServerInitPostNetworkGroupAssign();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", (object)this);
		SendNetworkUpdateImmediate(justCreated: true);
		((FacepunchBehaviour)this).Invoke((Action)SendGlobalNetworkUpdate, 0f);
		if (Application.isLoading && !Application.isLoadingSave)
		{
			((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

	private void SendGlobalNetworkUpdate()
	{
		GlobalNetworkHandler.server?.TrySendNetworkUpdate(this);
	}

	public bool IsFullySpawned()
	{
		return isSpawned;
	}

	public virtual void ServerInit()
	{
		serverEntities.RegisterID(this);
		if (net != null)
		{
			net.handler = (NetworkHandler)(object)this;
		}
		lastDemoIndex = -1;
	}

	public virtual void ServerInitPostNetworkGroupAssign()
	{
	}

	public List<Connection> GetSubscribers()
	{
		if (net == null)
		{
			return null;
		}
		if (net.group == null)
		{
			return null;
		}
		return net.group.subscribers;
	}

	protected ListHashSet<BaseNetworkable> GetOccludees()
	{
		return occludees;
	}

	public void KillMessage()
	{
		Kill();
	}

	public virtual void AdminKill()
	{
		Kill(DestroyMode.Gib);
	}

	public virtual void OnKilled()
	{
	}

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning((object)("Calling kill - but already IsDestroyed!? " + (object)this));
		}
		else if (Interface.CallHook("OnEntityKill", (object)this) == null)
		{
			EntityProfiler.killed++;
			if (EntityProfiler.mode >= 2)
			{
				EntityProfiler.OnKilled(this);
			}
			((Component)this).gameObject.BroadcastOnParentDestroying();
			OnKilled();
			DoEntityDestroy();
			TerminateOnClient(mode);
			TerminateOnServer();
			EntityDestroy();
		}
	}

	public void KillAsMapEntity()
	{
		if (IsFullySpawned())
		{
			Kill();
			return;
		}
		IsDestroyed = true;
		Object.Destroy((Object)(object)((Component)this).gameObject);
	}

	public void TerminateOnClient(DestroyMode mode)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (net != null && net.group != null && ((BaseNetwork)Net.sv).IsConnected())
		{
			LogEntry(RustLog.EntryType.Network, 2, "Term {0}", mode);
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)6);
			obj.EntityID(net.ID);
			obj.UInt8((byte)mode);
			obj.Send(new SendInfo(net.group.subscribers));
			GlobalNetworkHandler.server?.OnEntityKilled(this);
		}
	}

	public void TerminateOnServer()
	{
		if (net != null)
		{
			InvalidateNetworkCache();
			serverEntities.UnregisterID(this);
			Net.sv.DestroyNetworkable(ref net);
			((MonoBehaviour)this).StopAllCoroutines();
			((Component)this).gameObject.SetActive(false);
		}
	}

	internal virtual void DoServerDestroy()
	{
		isSpawned = false;
		Analytics.Azure.OnEntityDestroyed(this);
	}

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", (object)this, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (net.group == null)
		{
			return true;
		}
		return player.net.subscriber.IsSubscribed(net.group);
	}

	public void SendNetworkGroupChange()
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (isSpawned && ((BaseNetwork)Net.sv).IsConnected() && (!(this is BasePlayer basePlayer) || !basePlayer.IsSpectating()))
		{
			if (net.group == null)
			{
				Debug.LogWarning((object)(((object)this).ToString() + " changed its network group to null"));
				return;
			}
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)7);
			obj.EntityID(net.ID);
			obj.GroupID(net.group.ID);
			obj.Send(new SendInfo(net.group.subscribers));
		}
	}

	public void SendAsSnapshot(Connection connection, bool justCreated = false)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnEntitySnapshot", (object)this, (object)connection) == null)
		{
			NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
			connection.validate.entityUpdates++;
			SaveInfo saveInfo = default(SaveInfo);
			saveInfo.forConnection = connection;
			saveInfo.forDisk = false;
			SaveInfo saveInfo2 = saveInfo;
			val.PacketID((Type)5);
			val.UInt32(connection.validate.entityUpdates);
			ToStreamForNetwork((Stream)(object)val, saveInfo2);
			val.Send(new SendInfo(connection));
			if (DemoConVars.ServerDemosEnabled)
			{
				lastDemoIndex = ((BaseNetwork)Net.sv).serverDemos.DemoCount;
			}
		}
	}

	public void SendAsSnapshotWithChildren(BasePlayer player, bool includeChildrensChildren = false)
	{
		Connection connection = player.net.connection;
		SendAsSnapshot(connection);
		SendChildren(children);
		void SendChildren(List<BaseEntity> children)
		{
			foreach (BaseEntity child in children)
			{
				if (child.ShouldNetworkTo(player))
				{
					child.SendAsSnapshot(connection);
					if (includeChildrensChildren && child.children != null)
					{
						SendChildren(child.children);
					}
				}
			}
		}
	}

	public void SendDemoTransientEntity()
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		if (!DemoConVars.ServerDemosEnabled)
		{
			return;
		}
		BaseEntity baseEntity = this as BaseEntity;
		if (!baseEntity.enableSaving && lastDemoIndex != ((BaseNetwork)Net.sv).serverDemos.DemoCount)
		{
			lastDemoIndex = ((BaseNetwork)Net.sv).serverDemos.DemoCount;
			NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
			val.PacketID((Type)51);
			SaveInfo saveInfo = default(SaveInfo);
			saveInfo.forDisk = true;
			SaveInfo saveInfo2 = saveInfo;
			bool flag = true;
			try
			{
				ToStream((Stream)(object)val, saveInfo2);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)$"ServerDemo: Failed to take a snapshot of transient ${baseEntity.ShortPrefabName}[${net.ID}]", (Object)(object)baseEntity);
				Debug.LogException(ex, (Object)(object)this);
				flag = false;
			}
			if (flag)
			{
				Server sv = Net.sv;
				DemoQueueItem val2 = default(DemoQueueItem);
				((DemoQueueItem)(ref val2))..ctor(val);
				val2.IgnoreNoConnections = true;
				((BaseNetwork)sv).EnqueueToDemoThread(val2);
			}
			val.RemoveReference();
		}
	}

	public void SendNetworkUpdate(BasePlayer.NetworkQueue queue = BasePlayer.NetworkQueue.Update)
	{
		if (Application.isLoading || Application.isLoadingSave || IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("SendNetworkUpdate", 0);
		try
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdate");
			InvalidateNetworkCache();
			List<Connection> subscribers = GetSubscribers();
			if (subscribers != null && subscribers.Count > 0)
			{
				for (int i = 0; i < subscribers.Count; i++)
				{
					BasePlayer basePlayer = subscribers[i].player as BasePlayer;
					if (!((Object)(object)basePlayer == (Object)null) && ShouldNetworkTo(basePlayer))
					{
						basePlayer.QueueUpdate(queue, this);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
	}

	public void SendNetworkUpdateImmediate(bool justCreated = false)
	{
		if (Application.isLoading || Application.isLoadingSave || IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("SendNetworkUpdateImmediate", 0);
		try
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdateImmediate");
			InvalidateNetworkCache();
			List<Connection> subscribers = GetSubscribers();
			if (subscribers != null && subscribers.Count > 0)
			{
				for (int i = 0; i < subscribers.Count; i++)
				{
					Connection val2 = subscribers[i];
					BasePlayer basePlayer = val2.player as BasePlayer;
					if (!((Object)(object)basePlayer == (Object)null) && ShouldNetworkTo(basePlayer))
					{
						SendAsSnapshot(val2, justCreated);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
	}

	public void SendNetworkUpdate_Position()
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || Application.isLoadingSave || IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("SendNetworkUpdate_Position", 0);
		try
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdate_Position");
			List<Connection> list = GetSubscribers();
			if (list == null || list.Count <= 0)
			{
				return;
			}
			if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion())
			{
				List<Connection> list2 = Pool.Get<List<Connection>>();
				foreach (Connection item in list)
				{
					BasePlayer basePlayer = item.player as BasePlayer;
					if (!((Object)(object)basePlayer == (Object)null) && ShouldNetworkTo(basePlayer))
					{
						list2.Add(item);
					}
				}
				list = list2;
			}
			if (list.Count > 0)
			{
				SendDemoTransientEntity();
				NetWrite val2 = ((BaseNetwork)Net.sv).StartWrite();
				val2.PacketID((Type)10);
				val2.EntityID(net.ID);
				Vector3 networkPosition = GetNetworkPosition();
				val2.Vector3(ref networkPosition);
				Quaternion networkRotation = GetNetworkRotation();
				networkPosition = ((Quaternion)(ref networkRotation)).eulerAngles;
				val2.Vector3(ref networkPosition);
				val2.Float(GetNetworkTime());
				NetworkableId uid = parentEntity.uid;
				if (((NetworkableId)(ref uid)).IsValid)
				{
					val2.EntityID(uid);
				}
				SendInfo val3 = new SendInfo(list);
				val3.method = (SendMethod)1;
				val3.priority = (Priority)0;
				SendInfo val4 = val3;
				val2.Send(val4);
			}
			if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion())
			{
				Pool.FreeUnmanaged<Connection>(ref list);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ToStream(Stream stream, SaveInfo saveInfo)
	{
		Entity val = (saveInfo.msg = Pool.Get<Entity>());
		try
		{
			Save(saveInfo);
			if (saveInfo.msg.baseEntity == null)
			{
				Debug.LogError((object)(((object)this)?.ToString() + ": ToStream - no BaseEntity!?"));
			}
			if (saveInfo.msg.baseNetworkable == null)
			{
				Debug.LogError((object)(((object)this)?.ToString() + ": ToStream - no baseNetworkable!?"));
			}
			Interface.CallHook("IOnEntitySaved", (object)this, (object)saveInfo);
			ProtoStreamExtensions.WriteToStream((IProto)(object)saveInfo.msg, stream, false, 2097152);
			PostSave(saveInfo);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual bool CanUseNetworkCache(Connection connection)
	{
		return ConVar.Server.netcache;
	}

	public void ToStreamForNetwork(Stream stream, SaveInfo saveInfo)
	{
		if (!CanUseNetworkCache(saveInfo.forConnection))
		{
			ToStream(stream, saveInfo);
			return;
		}
		if (_NetworkCache == null)
		{
			_NetworkCache = ((EntityMemoryStreamPool.Count > 0) ? (_NetworkCache = EntityMemoryStreamPool.Dequeue()) : new MemoryStream(8));
			ToStream(_NetworkCache, saveInfo);
			ConVar.Server.netcachesize += (int)_NetworkCache.Length;
		}
		_NetworkCache.WriteTo(stream);
	}

	public void InvalidateNetworkCache()
	{
		TimeWarning val = TimeWarning.New("InvalidateNetworkCache", 0);
		try
		{
			if (_SaveCache != null)
			{
				ConVar.Server.savecachesize -= (int)_SaveCache.Length;
				_SaveCache.SetLength(0L);
				_SaveCache.Position = 0L;
				EntityMemoryStreamPool.Enqueue(_SaveCache);
				_SaveCache = null;
			}
			if (_NetworkCache != null)
			{
				ConVar.Server.netcachesize -= (int)_NetworkCache.Length;
				_NetworkCache.SetLength(0L);
				_NetworkCache.Position = 0L;
				EntityMemoryStreamPool.Enqueue(_NetworkCache);
				_NetworkCache = null;
			}
			LogEntry(RustLog.EntryType.Network, 3, "InvalidateNetworkCache");
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public MemoryStream GetSaveCache()
	{
		if (_SaveCache == null)
		{
			if (EntityMemoryStreamPool.Count > 0)
			{
				_SaveCache = EntityMemoryStreamPool.Dequeue();
			}
			else
			{
				_SaveCache = new MemoryStream(8);
			}
			SaveInfo saveInfo = default(SaveInfo);
			saveInfo.forDisk = true;
			SaveInfo saveInfo2 = saveInfo;
			ToStream(_SaveCache, saveInfo2);
			ConVar.Server.savecachesize += (int)_SaveCache.Length;
		}
		return _SaveCache;
	}

	public virtual void UpdateNetworkGroup()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(isServer, "UpdateNetworkGroup called on clientside entity!");
		if (net == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("UpdateGroups", 0);
		try
		{
			if (net.UpdateGroups(((Component)this).transform.position))
			{
				SendNetworkGroupChange();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual bool SupportsServerOcclusion()
	{
		return false;
	}
}


using Network;
using ProtoBuf;

public struct SaveInfo
{
	public Entity msg;

	public bool forDisk;

	public bool forTransfer;

	public Connection forConnection;

	internal bool SendingTo(Connection ownerConnection)
	{
		if (ownerConnection == null)
		{
			return false;
		}
		if (forConnection == null)
		{
			return false;
		}
		return forConnection == ownerConnection;
	}
}


using ProtoBuf;

public struct LoadInfo
{
	public Entity msg;

	public bool fromDisk;

	public bool fromCopy;

	public bool fromTransfer;
}


using Network;
using Network.Visibility;

public class EntityRealmServer : EntityRealm
{
	protected override Manager visibilityManager
	{
		get
		{
			if (Net.sv == null)
			{
				return null;
			}
			return Net.sv.visibility;
		}
	}
}


using System.Collections;
using System.Collections.Generic;
using Network;
using Network.Visibility;
using UnityEngine;

public abstract class EntityRealm : IEnumerable<BaseNetworkable>, IEnumerable
{
	public HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>> entityList = new HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>>(new ListDictionary<NetworkableId, BaseNetworkable>());

	public int Count => entityList.Get().Count;

	protected abstract Manager visibilityManager { get; }

	public bool Contains(NetworkableId uid)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return entityList.Get().Contains(uid);
	}

	public BaseNetworkable Find(NetworkableId uid)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		BaseNetworkable result = null;
		if (!entityList.Get().TryGetValue(uid, ref result))
		{
			return null;
		}
		return result;
	}

	public void RegisterID(BaseNetworkable ent)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (ent.net != null)
		{
			ListDictionary<NetworkableId, BaseNetworkable> val = entityList.Get();
			if (val.Contains(ent.net.ID))
			{
				val[ent.net.ID] = ent;
			}
			else
			{
				val.Add(ent.net.ID, ent);
			}
		}
	}

	public void UnregisterID(BaseNetworkable ent)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (ent.net != null)
		{
			entityList.Get().Remove(ent.net.ID);
		}
	}

	public Group FindGroup(uint uid)
	{
		Manager val = visibilityManager;
		if (val == null)
		{
			return null;
		}
		return val.Get(uid);
	}

	public Group TryFindGroup(uint uid)
	{
		Manager val = visibilityManager;
		if (val == null)
		{
			return null;
		}
		return val.TryGet(uid);
	}

	public void FindInGroup(uint uid, List<BaseNetworkable> list)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Group val = TryFindGroup(uid);
		if (val == null)
		{
			return;
		}
		int count = val.networkables.Values.Count;
		Networkable[] buffer = val.networkables.Values.Buffer;
		for (int i = 0; i < count; i++)
		{
			Networkable val2 = buffer[i];
			BaseNetworkable baseNetworkable = Find(val2.ID);
			if (!((Object)(object)baseNetworkable == (Object)null) && baseNetworkable.net != null && baseNetworkable.net.group != null)
			{
				if (baseNetworkable.net.group.ID != uid)
				{
					Debug.LogWarning((object)("Group ID mismatch: " + ((object)baseNetworkable).ToString()));
				}
				else
				{
					list.Add(baseNetworkable);
				}
			}
		}
	}

	public Enumerator<BaseNetworkable> GetEnumerator()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return entityList.Get().Values.GetEnumerator();
	}

	IEnumerator<BaseNetworkable> IEnumerable<BaseNetworkable>.GetEnumerator()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return (IEnumerator<BaseNetworkable>)(object)GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return (IEnumerator)(object)GetEnumerator();
	}

	public void Clear()
	{
		entityList.Get().Clear();
	}
}


public enum DestroyMode : byte
{
	None,
	Gib
}


using UnityEngine;

public static class BaseNetworkableEx
{
	public static bool IsValid(this BaseNetworkable ent)
	{
		if ((Object)(object)ent == (Object)null)
		{
			return false;
		}
		if (ent.net == null)
		{
			return false;
		}
		return true;
	}

	public static bool Is<T>(this Object ent, out T entAsT) where T : Object
	{
		entAsT = default(T);
		if (ent == (Object)null)
		{
			return false;
		}
		entAsT = (T)(object)((ent is T) ? ent : null);
		if ((Object)(object)entAsT == (Object)null)
		{
			return false;
		}
		return true;
	}

	public static bool IsRealNull(this BaseNetworkable ent)
	{
		return ent == null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class BaseRagdoll : BaseMountable
{
	[SerializeField]
	[Header("Ragdolling")]
	private Ragdoll Ragdoll;

	[SerializeField]
	private PlayerBonePosData BonePosData;

	[SerializeField]
	private List<DamageTypeEntry> impactDamage;

	[SerializeField]
	private List<Rigidbody> flailBodies;

	private EntityRef<BasePlayer> parentPlayer;

	private BaseEntity initiator;

	private bool dieOnImpact;

	private float lastMovingTime;

	private float largestNegYVelocityOnCollision;

	private bool inTheAir;

	private bool flailInAir;

	private float spinDampening;

	private Vector3 ragdollSpinDirection;

	private bool matchPlayerGravity;

	private int clippedFrameCount;

	private Vector3 lastTransformPos;

	private Vector3 lastEyePos;

	private Vector3 lastPelvisPoint;

	private List<(Vector3, Quaternion)> lastRagdollRbPosRot;

	public GameObjectRef fleshImpact;

	[ClientVar]
	public static bool debug_vis;

	protected override bool BypassClothingMountBlocks => true;

	public override bool DirectlyMountable()
	{
		return false;
	}

	public override void Save(SaveInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		if (parentPlayer.IsValid(base.isServer))
		{
			info.msg.temporaryRagdoll.parentID = parentPlayer.uid;
			info.msg.temporaryRagdoll.mountPose = (int)mountPose;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.temporaryRagdoll != null)
		{
			Load(info.msg.temporaryRagdoll);
		}
	}

	private void Load(TemporaryRagdoll tempRagdoll)
	{
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		base.OnPlayerDismounted(player);
		player.SetPlayerFlag(BasePlayer.PlayerFlags.Ragdolling, b: false);
		PlayerEyes eyes = player.eyes;
		Quaternion rotation = player.eyes.rotation;
		eyes.rotation = Quaternion.Euler(Vector3Ex.WithX(((Quaternion)(ref rotation)).eulerAngles, 0f));
		if (dieOnImpact)
		{
			KillPlayerImpact(player, doRadiusDamage: true);
		}
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
		if ((Object)(object)val == (Object)null)
		{
			val = ((Component)this).gameObject.AddComponent<Rigidbody>();
			val.mass = 10f;
			val.drag = 0f;
			val.angularDrag = 0f;
		}
		val.useGravity = true;
		val.collisionDetectionMode = (CollisionDetectionMode)3;
		val.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
		lastMovingTime = Time.time;
	}

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		GameObjectExtensions.SetIgnoreCollisions(((Component)this).gameObject, ((Component)GetMounted()).gameObject, true);
		((FacepunchBehaviour)this).Invoke((Action)StopRagdolling, 10f);
	}

	public override void VehicleFixedUpdate()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseRagdoll.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			BasePlayer mounted = GetMounted();
			if ((Object)(object)mounted == (Object)null)
			{
				Kill();
				return;
			}
			AdjustForClipping();
			Vector3 val2 = rigidBody.velocity;
			if (!(((Vector3)(ref val2)).magnitude > 2f))
			{
				val2 = rigidBody.angularVelocity;
				if (!(((Vector3)(ref val2)).magnitude > 2f))
				{
					goto IL_0073;
				}
			}
			lastMovingTime = Time.time;
			goto IL_0073;
			IL_0073:
			if (matchPlayerGravity)
			{
				Vector3 val3 = 2.5f * Physics.gravity - Physics.gravity;
				foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
				{
					rigidbody.AddForce(val3, (ForceMode)5);
				}
			}
			if (inTheAir && flailInAir)
			{
				foreach (Rigidbody flailBody in flailBodies)
				{
					Vector3 val4 = new Vector3(Random.Range(-0.5f, 0.5f), Random.Range(-0.5f, 0.5f), Random.Range(-0.5f, 0.5f)) * (Random.Range(5f, 10f) * spinDampening);
					flailBody.AddForce(val4 * 15f, (ForceMode)5);
				}
				rigidBody.AddTorque(ragdollSpinDirection * spinDampening, (ForceMode)5);
				spinDampening *= 0.98f;
			}
			if (largestNegYVelocityOnCollision < 0f)
			{
				if (Object.op_Implicit((Object)(object)mounted))
				{
					mounted.ApplyFallDamageFromVelocity(largestNegYVelocityOnCollision);
				}
				largestNegYVelocityOnCollision = 0f;
			}
			if (Time.time > lastMovingTime + 1.25f)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)StopRagdolling);
				StopRagdolling();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void AdjustForClipping()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AdjustForClipping", 0);
		try
		{
			Vector3 position = lastTransformPos;
			lastTransformPos = ((Component)this).transform.position;
			Vector3 start = lastEyePos;
			Vector3 end = (lastEyePos = GetMounted().eyes.position);
			Vector3 start2 = lastPelvisPoint;
			Vector3 end2 = (lastPelvisPoint = Ragdoll.primaryBody.position);
			BasePlayer basePlayer = parentPlayer.Get(serverside: true);
			Vector3 velocity = rigidBody.velocity;
			bool flag = ((Vector3)(ref velocity)).sqrMagnitude > 3f;
			bool flag2 = false;
			bool flag3 = false;
			List<RaycastHit> hits = Pool.Get<List<RaycastHit>>();
			bool flag4 = flag && ClippedOnPath(start, end, 0.3f, in hits, basePlayer);
			bool flag5 = ClippedOnPath(start, end, 0f, in hits, basePlayer);
			flag2 = flag2 || flag4 || flag5;
			flag3 = flag3 || flag5;
			bool flag6 = flag && ClippedOnPath(start2, end2, 0.3f, in hits, basePlayer);
			bool flag7 = ClippedOnPath(start2, end2, 0f, in hits, basePlayer);
			flag2 = flag2 || flag6 || flag7;
			flag3 = flag3 || flag7;
			Pool.FreeUnmanaged<RaycastHit>(ref hits);
			if (!flag2)
			{
				for (int i = 0; i < Ragdoll.rigidbodies.Count; i++)
				{
					Rigidbody val2 = Ragdoll.rigidbodies[i];
					lastRagdollRbPosRot[i] = (val2.position, val2.rotation);
				}
				return;
			}
			if (flag3 && ++clippedFrameCount >= 3)
			{
				basePlayer.Hurt(new HitInfo(initiator, basePlayer, DamageType.Blunt, 1000f));
				StopRagdolling();
				return;
			}
			for (int j = 0; j < Ragdoll.rigidbodies.Count; j++)
			{
				Rigidbody val3 = Ragdoll.rigidbodies[j];
				if (!((Object)(object)val3 == (Object)null))
				{
					var (position2, rotation) = lastRagdollRbPosRot[j];
					val3.position = position2;
					val3.rotation = rotation;
					val3.velocity = Vector3.zero;
					val3.angularVelocity = Vector3.zero;
				}
			}
			((Component)this).transform.position = position;
			lastTransformPos = position;
			lastEyePos = start;
			lastPelvisPoint = start2;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool ClippedOnPath(Vector3 start, Vector3 end, float radius, in List<RaycastHit> hits, BasePlayer ignorePlayer)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		Vector3 val = end - start;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (magnitude < Mathf.Epsilon)
		{
			return false;
		}
		val /= magnitude;
		Ray ray = new Ray(start, val);
		hits.Clear();
		GamePhysics.TraceAllUnordered(ray, radius, hits, magnitude, -910884607, (QueryTriggerInteraction)1);
		foreach (RaycastHit hit in hits)
		{
			BaseEntity entity = hit.GetEntity();
			if (!GamePhysics.CompareEntity(entity, this) && !GamePhysics.CompareEntity(entity, ignorePlayer))
			{
				result = true;
				break;
			}
		}
		return result;
	}

	public void InitFromPlayer(BasePlayer bp, Vector3 velocityOverride = default(Vector3), bool matchPlayerGravity = true, bool flailInAir = false, bool dieOnImpact = false, BaseEntity initiator = null)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		parentPlayer.Set(bp);
		lastEyePos = bp.eyes.position;
		if (bp.isMounted)
		{
			mountPose = bp.GetMounted().mountPose;
		}
		PlayerBonePosData.BonePosData bonePositionData = BonePosData.GetBonePositionData(bp.playerFlags, bp.modelState);
		if (bonePositionData != null)
		{
			model.skeleton.CopyFrom(bonePositionData.bonePositions, bonePositionData.boneRotations, true);
			Transform transform = model.skeleton.Bones[0].transform;
			transform.localEulerAngles += bonePositionData.rootRotationOffset;
		}
		float x = ((Component)bp).transform.eulerAngles.x;
		Quaternion bodyRotation = bp.eyes.bodyRotation;
		Quaternion val = Quaternion.Euler(x, ((Quaternion)(ref bodyRotation)).eulerAngles.y, ((Component)bp).transform.eulerAngles.z);
		((Component)this).transform.SetPositionAndRotation(((Component)bp).transform.position, val);
		lastTransformPos = ((Component)this).transform.position;
		Ragdoll.ServerInit();
		rigidBody.drag = 0f;
		rigidBody.angularDrag = 0f;
		inTheAir = true;
		Vector3 val2 = ((velocityOverride != Vector3.zero) ? velocityOverride : (bp.isMounted ? bp.GetMountVelocity() : bp.estimatedVelocity));
		rigidBody.AddForce(val2, (ForceMode)1);
		lastRagdollRbPosRot = new List<(Vector3, Quaternion)>(Ragdoll.rigidbodies.Count);
		foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
		{
			rigidbody.drag = 0f;
			rigidbody.angularDrag = 0f;
			rigidbody.AddForceAtPosition(val2, ((Component)rigidbody).transform.position, (ForceMode)2);
			rigidbody.collisionDetectionMode = (CollisionDetectionMode)3;
			lastRagdollRbPosRot.Add((rigidbody.position, rigidbody.rotation));
		}
		lastPelvisPoint = Ragdoll.primaryBody.position;
		this.flailInAir = flailInAir;
		if (flailInAir)
		{
			spinDampening = 1f;
			Vector3 zero = Vector3.zero;
			((Vector3)(ref zero))[Random.Range(0, 3)] = 1f;
			ragdollSpinDirection = zero * 0.8f;
		}
		if (Object.op_Implicit((Object)(object)initiator))
		{
			GameObjectExtensions.SetIgnoreCollisions(((Component)this).gameObject, ((Component)initiator).gameObject, true);
		}
		this.matchPlayerGravity = matchPlayerGravity;
		this.initiator = initiator;
		this.dieOnImpact = dieOnImpact;
	}

	public override bool GetDismountPosition(BasePlayer player, out Vector3 res, bool silent = false)
	{
		List<Collider> list = Pool.Get<List<Collider>>();
		((Component)this).GetComponentsInChildren<Collider>(list);
		foreach (Collider item in list)
		{
			item.enabled = false;
		}
		bool dismountPosition = base.GetDismountPosition(player, out res, silent);
		foreach (Collider item2 in list)
		{
			item2.enabled = true;
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return dismountPosition;
	}

	private void StopRagdolling()
	{
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			mounted.SetPlayerFlag(BasePlayer.PlayerFlags.Ragdolling, b: false);
		}
		DismountAllPlayers();
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override bool AllowPlayerInstigatedDismount(BasePlayer player)
	{
		object obj = Interface.CallHook("CanRagdollDismount", (object)this, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

	protected void ProcessCollision(Collision collision, BaseEntity hitEntity, Rigidbody ourRigidbody)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || collision == null || (Object)(object)collision.gameObject == (Object)null || (Object)(object)collision.gameObject == (Object)null)
		{
			return;
		}
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted == (Object)null)
		{
			return;
		}
		if (dieOnImpact)
		{
			KillPlayerImpact(mounted, doRadiusDamage: true);
		}
		else
		{
			largestNegYVelocityOnCollision = Mathf.Min(largestNegYVelocityOnCollision, 0f - collision.relativeVelocity.y);
		}
		if (!inTheAir)
		{
			return;
		}
		inTheAir = false;
		if (!flailInAir)
		{
			return;
		}
		rigidBody.drag = 1f;
		rigidBody.angularDrag = 1f;
		foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
		{
			rigidbody.drag = 1f;
			rigidbody.angularDrag = 1f;
		}
	}

	private void KillPlayerImpact(BasePlayer mounted, bool doRadiusDamage)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(mounted.fallDamageEffect.resourcePath, ((Component)this).transform.position, Vector3.zero);
		Effect.server.Run(fleshImpact.resourcePath, ((Component)this).transform.position, Vector3.zero);
		if (doRadiusDamage)
		{
			DamageUtil.RadiusDamage(mounted, initiator, ((Component)mounted).transform.position, 1f, 3.5f, impactDamage, 133120, useLineOfSight: true);
		}
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			StopRagdolling();
			mounted.Hurt(new HitInfo(initiator, mounted, DamageType.Blunt, 1000f));
		}, 1f);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (base.isServer)
		{
			ProcessCollision(collision, hitEntity, rigidBody);
		}
	}
}


using Rust;
using UnityEngine;

public class AnimatedBuildingBlock : StabilityEntity
{
	private bool animatorNeedsInitializing = true;

	private bool animatorIsOpen = true;

	[HideInInspector]
	public bool isAnimating;

	[HideInInspector]
	public float lastAnimationStateChange;

	private static readonly int Open = Animator.StringToHash("open");

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			UpdateAnimationParameters(init: true);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		UpdateAnimationParameters(init: true);
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		if (!isAnimating)
		{
			return Time.time - lastAnimationStateChange <= 10f;
		}
		return true;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		UpdateAnimationParameters(init: false);
	}

	protected virtual void ApplySubAnimationParameters(bool init, Animator toAnimator)
	{
	}

	protected void UpdateAnimationParameters(bool init)
	{
		if (!Object.op_Implicit((Object)(object)model) || !Object.op_Implicit((Object)(object)model.animator) || !model.animator.isInitialized)
		{
			return;
		}
		bool num = animatorNeedsInitializing || animatorIsOpen != IsOpen() || (init && isAnimating);
		bool flag = animatorNeedsInitializing || init;
		lastAnimationStateChange = GetNetworkTime();
		if (num)
		{
			isAnimating = true;
			((Behaviour)model.animator).enabled = true;
			model.animator.SetBool(Open, animatorIsOpen = IsOpen());
			ApplySubAnimationParameters(init, model.animator);
			if (flag)
			{
				model.animator.fireEvents = false;
				if (((Behaviour)model.animator).isActiveAndEnabled)
				{
					model.animator.Update(0f);
					model.animator.Update(20f);
				}
				PutAnimatorToSleep();
				isAnimating = false;
			}
			else
			{
				model.animator.fireEvents = base.isClient;
				if (base.isServer)
				{
					SetFlag(Flags.Busy, b: true);
				}
			}
		}
		else if (flag)
		{
			PutAnimatorToSleep();
		}
		animatorNeedsInitializing = false;
	}

	protected virtual void OnAnimatorFinished()
	{
		if (!isAnimating)
		{
			PutAnimatorToSleep();
		}
		isAnimating = false;
	}

	private void PutAnimatorToSleep()
	{
		if (!Object.op_Implicit((Object)(object)model) || !Object.op_Implicit((Object)(object)model.animator))
		{
			Debug.LogWarning((object)(((Component)this).transform.GetRecursiveName() + " has missing model/animator"), (Object)(object)((Component)this).gameObject);
			return;
		}
		((Behaviour)model.animator).enabled = false;
		if (base.isServer)
		{
			SetFlag(Flags.Busy, b: false);
		}
		OnAnimatorDisabled();
	}

	protected virtual void OnAnimatorDisabled()
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class BuildingPrivilegeRetro : BuildingPrivlidge
{
	[Serializable]
	public struct ToolSetting
	{
		public ItemDefinition item;

		public Transform[] parents;
	}

	[Serializable]
	public struct ToolModel
	{
		public ItemDefinition item;

		public GameObjectRef model;
	}

	public BuildingPrivilegeRetroScreen screens;

	public GameObjectRef[] boxPrefabs;

	public GameObjectRef[] doubleBoxPrefabs;

	public int boxesAmount = 12;

	public Transform boxesParent;

	public Vector3 boxSpacing = new Vector3(0.33f, 0.3f, 0.3f);

	public ToolSetting[] toolSettings;

	public ToolModel[] toolCustomModels;

	public Material hammerOriginalMaterial;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.buildingPrivilegeRetro = Pool.Get<BuildingPrivilegeRetro>();
		if (info.forDisk || !((Object)(object)info.forConnection?.player != (Object)null) || !IsAuthed(info.forConnection.player as BasePlayer))
		{
			return;
		}
		List<float> list = Pool.Get<List<float>>();
		list.Add(GetResourceProportion(-151838493));
		list.Add(GetResourceProportion(-2099697608));
		list.Add(GetResourceProportion(69511070));
		list.Add(GetResourceProportion(317398316));
		info.msg.buildingPrivilegeRetro.resources = list;
		info.msg.buildingPrivilegeRetro.tools = Pool.Get<List<BuildingPrivilegeRetroTool>>();
		for (int i = 24; i <= 28; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			BuildingPrivilegeRetroTool val = Pool.Get<BuildingPrivilegeRetroTool>();
			if (slot != null)
			{
				foreach (ItemDefinition allowedConstructionItem in allowedConstructionItems)
				{
					if (slot.info.itemid == allowedConstructionItem.itemid)
					{
						val.itemID = allowedConstructionItem.itemid;
						val.skinid = slot.skin;
					}
				}
			}
			info.msg.buildingPrivilegeRetro.tools.Add(val);
		}
	}

	private float GetResourceProportion(int id)
	{
		int amount = base.inventory.GetAmount(id, onlyUsableAmounts: false);
		float num = ItemManager.FindItemDefinition(id).stackable;
		return (float)amount / ((float)(base.inventory.capacity - 5) * num);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.buildingPrivilegeRetro;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ToolSetting
{
	public ItemDefinition item;

	public Transform[] parents;
}


using System;

[Serializable]
public struct ToolModel
{
	public ItemDefinition item;

	public GameObjectRef model;
}


using System;
using Rust.UI;
using UnityEngine;

public class BuildingPrivilegeRetroScreen : FacepunchBehaviour, INotifyLOD, IClientComponent
{
	[Serializable]
	public struct Screen
	{
		public CanvasGroup group;

		public CanvasGroup onGroup;

		public CanvasGroup offGroup;

		public void TurnOnOff(bool on)
		{
			((Component)onGroup).gameObject.SetActive(on);
			onGroup.alpha = (on ? 1 : 0);
			((Component)offGroup).gameObject.SetActive(!on);
			offGroup.alpha = ((!on) ? 1 : 0);
		}
	}

	[SerializeField]
	private CanvasGroup screenCanvas;

	[Space]
	[Header("PROTECTED TIME")]
	public RustText protectedTimeText;

	public int decayWarningThreshold = 130;

	public GameObject decayWarningGroup;

	public GameObject decayingGroup;

	[Space]
	[Header("UPKEEP")]
	public VirtualItemIcon[] costIcons;

	public RustText[] paginationTexts;

	[Header("BLOCKS")]
	[Space]
	public GameObject[] blocksType;

	public RustText blockCountText;

	public RustText doorCountText;

	[Space]
	public Renderer screenRenderer;

	[ColorUsage(true, true)]
	public Color fromScreenEmissionColor;

	[ColorUsage(true, true)]
	public Color screenEmissionColor;

	public AnimationCurve tweenCurve;

	public float animDuration = 0.7f;

	public Animation screensAnim;

	public Screen[] screens;
}


using System;
using UnityEngine;

[Serializable]
public struct Screen
{
	public CanvasGroup group;

	public CanvasGroup onGroup;

	public CanvasGroup offGroup;

	public void TurnOnOff(bool on)
	{
		((Component)onGroup).gameObject.SetActive(on);
		onGroup.alpha = (on ? 1 : 0);
		((Component)offGroup).gameObject.SetActive(!on);
		offGroup.alpha = ((!on) ? 1 : 0);
	}
}


using UnityEngine;

public class DoorWithLock : Door
{
	[ItemSelector]
	[Header("Lock Settings")]
	public GameObjectRef lockObject;
}


public class Gate : Door, INotifyTrigger, ISimpleUpgradable
{
}


using UnityEngine;

public class OBBComponent : MonoBehaviour
{
	public Bounds Bounds;

	public OBB GetObb()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(((Component)this).transform, Bounds);
	}
}


using UnityEngine;

public class ProceduralLiftCabin : MonoBehaviour
{
}


using UnityEngine;

public class ProceduralLiftStop : MonoBehaviour
{
}


using System;

public class SimpleBuildingBlockModelVariant : PrefabAttribute
{
	public GameObjectRef prefab;

	public BaseEntity.Flags Flag;

	protected override Type GetIndexedType()
	{
		return typeof(SimpleBuildingBlockModelVariant);
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class SimplePrivilege : BaseEntity
{
	public List<PlayerNameID> authorizedPlayers = new List<PlayerNameID>();

	public const Flags Flag_MaxAuths = Flags.Reserved5;

	public override void ResetState()
	{
		base.ResetState();
		authorizedPlayers.Clear();
	}

	public bool IsAuthed(BasePlayer player)
	{
		return authorizedPlayers.Any((PlayerNameID x) => x.userid == (ulong)player.userID);
	}

	public bool IsAuthed(ulong userID)
	{
		return authorizedPlayers.Any((PlayerNameID x) => x.userid == userID);
	}

	public bool AnyAuthed()
	{
		return authorizedPlayers.Count > 0;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.buildingPrivilege = Pool.Get<BuildingPrivilege>();
		info.msg.buildingPrivilege.users = authorizedPlayers;
	}

	public override void PostSave(SaveInfo info)
	{
		info.msg.buildingPrivilege.users = null;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		authorizedPlayers.Clear();
		if (info.msg.buildingPrivilege != null && info.msg.buildingPrivilege.users != null)
		{
			authorizedPlayers = info.msg.buildingPrivilege.users;
			info.msg.buildingPrivilege.users = null;
		}
	}

	public bool AtMaxAuthCapacity()
	{
		return HasFlag(Flags.Reserved5);
	}

	public void UpdateMaxAuthCapacity()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode) && activeGameMode.limitTeamAuths)
		{
			SetFlag(Flags.Reserved5, authorizedPlayers.Count >= activeGameMode.GetMaxRelationshipTeamSize());
		}
	}
}


using System.Collections.Generic;

public interface ISimpleUpgradable
{
	bool UpgradingEnabled();

	bool CanUpgrade(BasePlayer player, ItemDefinition upgradeItem);

	bool CostIsItem();

	void DoUpgrade(BasePlayer player, ItemDefinition upgradeItem);

	List<ItemDefinition> GetUpgradeItems();
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

internal static class SimpleUpgrade
{
	public static bool CanUpgrade(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if ((Object)(object)upgradeItem == (Object)null)
		{
			return false;
		}
		if (!player.CanInteract())
		{
			return false;
		}
		if (player.IsBuildingBlocked(((Component)entity).transform.position, ((Component)entity).transform.rotation, entity.bounds))
		{
			return false;
		}
		if ((Object)(object)((Component)upgradeItem).GetComponent<ItemModDeployable>() == (Object)null)
		{
			return false;
		}
		if (IsUpgradeBlocked(entity, upgradeItem, player))
		{
			return false;
		}
		if (!CanAffordUpgrade(entity, upgradeItem, player))
		{
			return false;
		}
		return true;
	}

	public static bool CanAffordUpgrade(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		ISimpleUpgradable simpleUpgradable = entity as ISimpleUpgradable;
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if (simpleUpgradable.CostIsItem())
		{
			return player.inventory.GetAmount(upgradeItem) > 0;
		}
		if ((Object)(object)upgradeItem.Blueprint == (Object)null)
		{
			return false;
		}
		if (!ItemModStudyBlueprint.IsBlueprintUnlocked(upgradeItem, player))
		{
			return false;
		}
		foreach (ItemAmount ingredient in upgradeItem.Blueprint.GetIngredients())
		{
			if ((float)player.inventory.GetAmount(ingredient.itemid) < ingredient.amount)
			{
				return false;
			}
		}
		return true;
	}

	public static void PayForUpgrade(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		if ((Object)(object)player == (Object)null || (player.IsInCreativeMode && Creative.freeBuild) || !(entity is ISimpleUpgradable simpleUpgradable))
		{
			return;
		}
		List<Item> list = new List<Item>();
		if (simpleUpgradable.CostIsItem())
		{
			player.inventory.Take(list, upgradeItem.itemid, 1);
			player.Command("note.inv " + upgradeItem.itemid + " " + -1);
		}
		else
		{
			foreach (ItemAmount ingredient in upgradeItem.Blueprint.GetIngredients())
			{
				player.inventory.Take(list, ingredient.itemid, (int)ingredient.amount);
				player.Command("note.inv " + ingredient.itemid + " " + ingredient.amount * -1f);
			}
		}
		foreach (Item item in list)
		{
			item.Remove();
		}
	}

	public static void DoUpgrade(BaseEntity entity, BasePlayer player, ItemDefinition upgradeItem)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		if (!(entity is ISimpleUpgradable simpleUpgradable) || !simpleUpgradable.CanUpgrade(player, upgradeItem))
		{
			return;
		}
		PayForUpgrade(entity, upgradeItem, player);
		EntityRef[] slots = entity.GetSlots();
		BaseEntity parentEntity = entity.GetParentEntity();
		bool flag = entity is DecayEntity decayEntity && decayEntity.HasFlag(BaseEntity.Flags.Reserved2);
		ItemModDeployable component = ((Component)upgradeItem).GetComponent<ItemModDeployable>();
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.entityPrefab.resourcePath, ((Component)entity).transform.position, ((Component)entity).transform.rotation);
		baseEntity.SetParent(parentEntity);
		baseEntity.OwnerID = player.userID;
		Deployable component2 = component.entityPrefab.Get().GetComponent<Deployable>();
		if (component2 != null && component2.placeEffect.isValid)
		{
			Effect.server.Run(component2.placeEffect.resourcePath, ((Component)entity).transform.position, Vector3.up);
		}
		DecayEntity decayEntity2 = baseEntity as DecayEntity;
		if ((Object)(object)decayEntity2 != (Object)null)
		{
			decayEntity2.timePlaced = entity.GetNetworkTime();
		}
		List<SprayCan.ChildPreserveInfo> list = Pool.Get<List<SprayCan.ChildPreserveInfo>>();
		foreach (BaseEntity child in entity.children)
		{
			list.Add(new SprayCan.ChildPreserveInfo
			{
				TargetEntity = child,
				TargetBone = child.parentBone,
				LocalPosition = ((Component)child).transform.localPosition,
				LocalRotation = ((Component)child).transform.localRotation
			});
		}
		foreach (SprayCan.ChildPreserveInfo item in list)
		{
			item.TargetEntity.SetParent(null, worldPositionStays: true);
		}
		entity.Kill();
		if (baseEntity is DecayEntity decayEntity3)
		{
			decayEntity3.AttachToBuilding(null);
		}
		baseEntity.Spawn();
		foreach (SprayCan.ChildPreserveInfo item2 in list)
		{
			item2.TargetEntity.SetParent(baseEntity, item2.TargetBone, worldPositionStays: true);
			((Component)item2.TargetEntity).transform.localPosition = item2.LocalPosition;
			((Component)item2.TargetEntity).transform.localRotation = item2.LocalRotation;
			item2.TargetEntity.SendNetworkUpdate();
		}
		baseEntity.SetSlots(slots);
		if (!flag && baseEntity is DecayEntity decayEntity4)
		{
			decayEntity4.StopBeingDemolishable();
		}
		Pool.FreeUnmanaged<SprayCan.ChildPreserveInfo>(ref list);
	}

	public static bool IsUpgradeBlocked(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)upgradeItem == (Object)null)
		{
			return true;
		}
		if ((Object)(object)entity == (Object)null)
		{
			return true;
		}
		if (entity is DecorDeployable)
		{
			return false;
		}
		if (entity is BaseLock)
		{
			return false;
		}
		ItemModDeployable component = ((Component)upgradeItem).GetComponent<ItemModDeployable>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(component.entityPrefab.resourceID);
		if (DeployVolume.Check(((Component)entity).transform.position, ((Component)entity).transform.rotation, volumes, ~((1 << ((Component)entity).gameObject.layer) | 0x20000000)))
		{
			return true;
		}
		Socket_Base[] array = PrefabAttribute.server.FindAll<Socket_Base>(component.entityPrefab.resourceID);
		bool flag = false;
		Construction.Target target = new Construction.Target
		{
			position = ((Component)entity).transform.position,
			rotation = ((Component)entity).transform.eulerAngles,
			normal = ((Component)entity).transform.up,
			ray = player.eyes.HeadRay()
		};
		Socket_Base[] array2 = array;
		foreach (Socket_Base obj in array2)
		{
			Construction.Placement place = obj.DoPlacement(target);
			bool flag2 = true;
			SocketMod[] socketMods = obj.socketMods;
			for (int j = 0; j < socketMods.Length; j++)
			{
				if (!socketMods[j].DoCheck(place))
				{
					flag2 = false;
					break;
				}
			}
			if (flag2)
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return true;
		}
		return false;
	}
}


using UnityEngine;

public class WallpaperModelRenderer : MonoBehaviour, ICustomMaterialReplacer, IClientComponent
{
	public Renderer rend;

	public Material[] defaultMaterials;

	public Material baseMaterial;

	public bool autoLoad;

	public Material targetMaterial;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Wallpaper/Wallpaper Settings")]
public class WallpaperSettings : BaseScriptableObject
{
	public enum Category
	{
		Wall = 1,
		Floor = 2,
		Ceiling = 3,
		Last = 3
	}

	[Flags]
	public enum Side
	{
		Soft = 1,
		Hard = 2
	}

	[Serializable]
	public struct WallpaperSetting
	{
		public GameObjectRef WallpaperPrefab;

		public BuildingBlock BuildingBlock;

		public Side side;
	}

	public WallpaperSetting[] Wallpapers;

	public WallpaperSetting[] Floorings;

	public WallpaperSetting[] Ceilings;

	public ItemAmount PlacementPrice;

	private static ItemDefinition _wallpaperItem;

	private static ItemDefinition _flooringItem;

	private static ItemDefinition _ceilingItem;

	public static ItemDefinition WallpaperItemDef
	{
		get
		{
			if ((Object)(object)_wallpaperItem == (Object)null)
			{
				_wallpaperItem = ItemManager.FindItemDefinition("wallpaper.wall");
			}
			return _wallpaperItem;
		}
	}

	public static ItemDefinition FlooringItemDef
	{
		get
		{
			if ((Object)(object)_flooringItem == (Object)null)
			{
				_flooringItem = ItemManager.FindItemDefinition("wallpaper.flooring");
			}
			return _flooringItem;
		}
	}

	public static ItemDefinition CeilingItemDef
	{
		get
		{
			if ((Object)(object)_ceilingItem == (Object)null)
			{
				_ceilingItem = ItemManager.FindItemDefinition("wallpaper.ceiling");
			}
			return _ceilingItem;
		}
	}

	private (WallpaperSetting setting, Category category)? GetMatchingSetting(BuildingBlock buildingBlock, int side)
	{
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return null;
		}
		Side side2 = (Side)(side + 1);
		WallpaperSetting[] wallpapers = Wallpapers;
		for (int i = 0; i < wallpapers.Length; i++)
		{
			WallpaperSetting item = wallpapers[i];
			if ((Object)(object)item.BuildingBlock != (Object)null && item.BuildingBlock.prefabID == buildingBlock.prefabID && (item.side & side2) != 0)
			{
				return (item, Category.Wall);
			}
		}
		wallpapers = Ceilings;
		for (int i = 0; i < wallpapers.Length; i++)
		{
			WallpaperSetting item2 = wallpapers[i];
			if ((Object)(object)item2.BuildingBlock != (Object)null && item2.BuildingBlock.prefabID == buildingBlock.prefabID && (item2.side & side2) != 0)
			{
				return (item2, Category.Ceiling);
			}
		}
		wallpapers = Floorings;
		for (int i = 0; i < wallpapers.Length; i++)
		{
			WallpaperSetting item3 = wallpapers[i];
			if ((Object)(object)item3.BuildingBlock != (Object)null && item3.BuildingBlock.prefabID == buildingBlock.prefabID && (item3.side & side2) != 0)
			{
				return (item3, Category.Floor);
			}
		}
		return null;
	}

	public Category GetCategory(BuildingBlock buildingBlock, int side)
	{
		(WallpaperSetting, Category)? matchingSetting = GetMatchingSetting(buildingBlock, side);
		if (!matchingSetting.HasValue)
		{
			return (Category)0;
		}
		return matchingSetting.Value.Item2;
	}

	public GameObjectRef GetWallpaperPrefab(BuildingBlock buildingBlock, int side)
	{
		(WallpaperSetting, Category)? matchingSetting = GetMatchingSetting(buildingBlock, side);
		if (!matchingSetting.HasValue)
		{
			return null;
		}
		return matchingSetting.Value.Item1.WallpaperPrefab;
	}

	public Construction GetConstruction(BuildingBlock buildingBlock, int side)
	{
		GameObjectRef wallpaperPrefab = GetWallpaperPrefab(buildingBlock, side);
		if (wallpaperPrefab == null)
		{
			return null;
		}
		if (buildingBlock.isServer)
		{
			return PrefabAttribute.server.Find<Construction>(wallpaperPrefab.resourceID);
		}
		return null;
	}

	public Deployable GetDeployable(BuildingBlock buildingBlock)
	{
		GameObjectRef wallpaperPrefab = GetWallpaperPrefab(buildingBlock, 0);
		if (wallpaperPrefab == null)
		{
			return null;
		}
		if (buildingBlock.isServer)
		{
			return PrefabAttribute.server.Find<Deployable>(wallpaperPrefab.resourceID);
		}
		return null;
	}

	public bool CanUseWallpaper(BuildingBlock buildingBlock)
	{
		if (GetWallpaperPrefab(buildingBlock, 0) == null)
		{
			return GetWallpaperPrefab(buildingBlock, 1) != null;
		}
		return true;
	}

	public static ItemDefinition GetItemDefForCategory(Category category)
	{
		return category switch
		{
			Category.Wall => WallpaperItemDef, 
			Category.Floor => FlooringItemDef, 
			Category.Ceiling => CeilingItemDef, 
			_ => null, 
		};
	}

	public ItemDefinition GetWallpaperItem(BuildingBlock buildingBlock, int side)
	{
		(WallpaperSetting, Category)? matchingSetting = GetMatchingSetting(buildingBlock, side);
		if (!matchingSetting.HasValue)
		{
			return null;
		}
		return GetItemDefForCategory(matchingSetting.Value.Item2);
	}

	public int GetSideThatMustBeInside(BuildingBlock buildingBlock)
	{
		string prefabName = buildingBlock.PrefabName;
		if (prefabName.Contains("floor"))
		{
			return 1;
		}
		if (prefabName.Contains("wall"))
		{
			return 1;
		}
		return -1;
	}
}


public enum Category
{
	Wall = 1,
	Floor = 2,
	Ceiling = 3,
	Last = 3
}


using System;

[Flags]
public enum Side
{
	Soft = 1,
	Hard = 2
}


using System;

[Serializable]
public struct WallpaperSetting
{
	public GameObjectRef WallpaperPrefab;

	public BuildingBlock BuildingBlock;

	public Side side;
}


using UnityEngine;

public class WallpaperViewModel : MonoBehaviour
{
	public GameObject[] models;

	public void ToggleModels(WallpaperSettings.Category mode)
	{
		for (int i = 0; i < models.Length; i++)
		{
			models[i].SetActive(mode - 1 == (WallpaperSettings.Category)i);
		}
	}
}


using UnityEngine;

public class DeployableToSlot : MonoBehaviour
{
	public BaseEntity.Slot slot;
}


using UnityEngine;

public class EntityCollisionMessage : EntityComponent<BaseEntity>
{
	private void OnCollisionEnter(Collision collision)
	{
		if ((Object)(object)base.baseEntity == (Object)null || base.baseEntity.IsDestroyed)
		{
			return;
		}
		BaseEntity baseEntity = collision.GetEntity();
		if ((Object)(object)baseEntity == (Object)(object)base.baseEntity)
		{
			return;
		}
		if ((Object)(object)baseEntity != (Object)null)
		{
			if (baseEntity.IsDestroyed)
			{
				return;
			}
			if (base.baseEntity.isServer)
			{
				baseEntity = baseEntity.ToServer<BaseEntity>();
			}
		}
		base.baseEntity.OnCollision(collision, baseEntity);
	}
}


using System;
using UnityEngine;

public class EntityComponent<T> : EntityComponentBase where T : BaseEntity
{
	[NonSerialized]
	public T _baseEntity;

	public T baseEntity
	{
		get
		{
			if ((Object)(object)_baseEntity == (Object)null)
			{
				UpdateBaseEntity();
			}
			return _baseEntity;
		}
	}

	protected void UpdateBaseEntity()
	{
		if (Object.op_Implicit((Object)(object)this) && Object.op_Implicit((Object)(object)((Component)this).gameObject))
		{
			_baseEntity = ((Component)this).gameObject.ToBaseEntity() as T;
		}
	}

	public override BaseEntity GetBaseEntity()
	{
		return baseEntity;
	}

	public T GetCastedEntity()
	{
		return baseEntity;
	}
}


using Network;

public class EntityComponentBase : BaseMonoBehaviour
{
	public virtual BaseEntity GetBaseEntity()
	{
		return null;
	}

	public virtual void InitShared()
	{
	}

	public virtual void ResetState()
	{
	}

	public virtual void DestroyShared()
	{
	}

	public virtual void SaveComponent(BaseNetworkable.SaveInfo info)
	{
	}

	public virtual void LoadComponent(BaseNetworkable.LoadInfo info)
	{
	}

	public virtual void Hurt(HitInfo hitInfo)
	{
	}

	public virtual bool OnDied(HitInfo info)
	{
		return true;
	}

	public virtual bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		return false;
	}
}


using System.Diagnostics;
using UnityEngine;

public class EntityDebug : EntityComponent<BaseEntity>
{
	internal Stopwatch stopwatch = Stopwatch.StartNew();

	private void Update()
	{
		if (!base.baseEntity.IsValid() || !base.baseEntity.IsDebugging())
		{
			((Behaviour)this).enabled = false;
		}
		else if (!(stopwatch.Elapsed.TotalSeconds < 0.5))
		{
			_ = base.baseEntity.isClient;
			if (base.baseEntity.isServer)
			{
				base.baseEntity.DebugServer(1, (float)stopwatch.Elapsed.TotalSeconds);
			}
			stopwatch.Reset();
			stopwatch.Start();
		}
	}
}


using UnityEngine;

public class EntityFlag_Animator : EntityFlag_Toggle
{
	public enum AnimatorMode
	{
		Bool,
		Float,
		Trigger,
		Integer
	}

	public Animator TargetAnimator;

	public string ParamName = string.Empty;

	public AnimatorMode AnimationMode;

	public float FloatOnState;

	public float FloatOffState;

	public int IntegerOnState;

	public int IntegerOffState;
}


public enum AnimatorMode
{
	Bool,
	Float,
	Trigger,
	Integer
}


using System;
using UnityEngine;

public class EntityFlag_TOD : EntityComponent<BaseEntity>
{
	public BaseEntity.Flags desiredFlag;

	public bool onAtNight = true;

	public void Start()
	{
		((FacepunchBehaviour)this).Invoke((Action)Initialize, 1f);
	}

	public void Initialize()
	{
		if (!((Object)(object)base.baseEntity == (Object)null) && !base.baseEntity.isClient)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)DoTimeCheck, 0f, 5f, 1f);
		}
	}

	public bool WantsOn()
	{
		if ((Object)(object)TOD_Sky.Instance == (Object)null)
		{
			return false;
		}
		bool isNight = TOD_Sky.Instance.IsNight;
		if (onAtNight == isNight)
		{
			return true;
		}
		return false;
	}

	private void DoTimeCheck()
	{
		bool num = base.baseEntity.HasFlag(desiredFlag);
		bool flag = WantsOn();
		if (num != flag)
		{
			base.baseEntity.SetFlag(desiredFlag, flag);
		}
	}
}


using UnityEngine;
using UnityEngine.Events;

public class EntityFlag_Toggle : EntityComponent<BaseEntity>, IOnPostNetworkUpdate, IOnSendNetworkUpdate, IPrefabPreProcess
{
	private enum FlagCheck
	{
		All,
		Any
	}

	public bool runClientside = true;

	[Tooltip("Server-side only works if the EntityFlag_Toggle is on the same GameObject as the Entity")]
	public bool runServerside = true;

	public BaseEntity.Flags flag;

	[Tooltip("If multiple flags are defined in 'flag', should they all be set, or any?")]
	[SerializeField]
	private FlagCheck flagCheck;

	[SerializeField]
	[Tooltip("Specify any flags that must NOT be on for this toggle to be on")]
	private BaseEntity.Flags notFlag;

	[SerializeField]
	private UnityEvent onFlagEnabled = new UnityEvent();

	[SerializeField]
	private UnityEvent onFlagDisabled = new UnityEvent();

	internal bool hasRunOnce;

	internal bool lastToggleOn;

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	protected void OnDisable()
	{
		hasRunOnce = false;
		lastToggleOn = false;
	}

	public void DoUpdate(BaseEntity entity)
	{
		bool flag = ((flagCheck == FlagCheck.All) ? entity.HasFlag(this.flag) : entity.HasAny(this.flag));
		if (entity.HasAny(notFlag))
		{
			flag = false;
		}
		if (!hasRunOnce || flag != lastToggleOn)
		{
			hasRunOnce = true;
			lastToggleOn = flag;
			if (flag)
			{
				onFlagEnabled.Invoke();
			}
			else
			{
				onFlagDisabled.Invoke();
			}
			OnStateToggled(flag);
		}
	}

	protected virtual void OnStateToggled(bool state)
	{
	}

	public void OnPostNetworkUpdate(BaseEntity entity)
	{
		if (!((Object)(object)base.baseEntity != (Object)(object)entity) && runClientside)
		{
			DoUpdate(entity);
		}
	}

	public void OnSendNetworkUpdate(BaseEntity entity)
	{
		if (runServerside)
		{
			DoUpdate(entity);
		}
	}

	public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if ((!clientside || !runClientside) && (!serverside || !runServerside))
		{
			process.RemoveComponent((Component)(object)this);
		}
	}
}


private enum FlagCheck
{
	All,
	Any
}


using UnityEngine;

public class EntityFlag_ToggleNotify : EntityFlag_Toggle
{
	public bool UseEntityParent;

	protected override void OnStateToggled(bool state)
	{
		base.OnStateToggled(state);
		if (!UseEntityParent && (Object)(object)base.baseEntity != (Object)null && base.baseEntity is IFlagNotify flagNotify)
		{
			flagNotify.OnFlagToggled(state);
		}
		if (UseEntityParent && (Object)(object)base.baseEntity != (Object)null && (Object)(object)base.baseEntity.GetParentEntity() != (Object)null && base.baseEntity.GetParentEntity() is IFlagNotify flagNotify2)
		{
			flagNotify2.OnFlagToggled(state);
		}
	}
}


public interface IFlagNotify
{
	void OnFlagToggled(bool state);
}


using System;
using UnityEngine;

public class EntityItem_RotateWhenOn : EntityComponent<BaseEntity>
{
	[Serializable]
	public class State
	{
		public Vector3 rotation;

		public float initialDelay;

		public float timeToTake = 2f;

		public AnimationCurve animationCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		});

		public string effectOnStart = "";

		public string effectOnFinish = "";

		public SoundDefinition movementLoop;

		public float movementLoopFadeOutTime = 0.1f;

		public SoundDefinition startSound;

		public SoundDefinition stopSound;
	}

	public State on;

	public State off;

	internal bool currentlyOn;

	internal bool stateInitialized;

	public BaseEntity.Flags targetFlag = BaseEntity.Flags.On;
}


using System;
using UnityEngine;

[Serializable]
public class State
{
	public Vector3 rotation;

	public float initialDelay;

	public float timeToTake = 2f;

	public AnimationCurve animationCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 0f),
		new Keyframe(1f, 1f)
	});

	public string effectOnStart = "";

	public string effectOnFinish = "";

	public SoundDefinition movementLoop;

	public float movementLoopFadeOutTime = 0.1f;

	public SoundDefinition startSound;

	public SoundDefinition stopSound;
}


using System;
using UnityEngine;

public class EntityTimedDestroy : EntityComponent<BaseEntity>
{
	public float secondsTillDestroy = 1f;

	private void OnEnable()
	{
		((FacepunchBehaviour)this).Invoke((Action)TimedDestroy, secondsTillDestroy);
	}

	private void TimedDestroy()
	{
		if ((Object)(object)base.baseEntity != (Object)null)
		{
			base.baseEntity.Kill();
		}
		else
		{
			Debug.LogWarning((object)"EntityTimedDestroy failed, baseEntity was already null!");
		}
	}
}


using UnityEngine;

public class HeadDispenser : EntityComponent<BaseEntity>
{
	public ItemDefinition HeadDef;

	public GameObjectRef SourceEntity;

	private bool hasDispensed;

	public BaseEntity overrideEntity { get; set; }

	public void DispenseHead(HitInfo info, BaseCorpse corpse)
	{
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		if (hasDispensed || !(info.Weapon is BaseMelee baseMelee) || !baseMelee.gathering.ProduceHeadItem)
		{
			return;
		}
		if ((Object)(object)info.InitiatorPlayer != (Object)null)
		{
			Item item = ItemManager.CreateByItemID(HeadDef.itemid, 1, 0uL);
			item.SetItemOwnership(info.InitiatorPlayer, ItemOwnershipPhrases.Beheaded);
			HeadEntity associatedEntity = ItemModAssociatedEntity<HeadEntity>.GetAssociatedEntity(item);
			BaseEntity baseEntity = (((Object)(object)overrideEntity != (Object)null) ? overrideEntity : SourceEntity.GetEntity());
			overrideEntity = null;
			if ((Object)(object)associatedEntity != (Object)null && (Object)(object)baseEntity != (Object)null)
			{
				associatedEntity.SetupSourceId(baseEntity.prefabID);
				if (corpse is PlayerCorpse playerCorpse)
				{
					associatedEntity.SetupPlayerId(playerCorpse.playerName, playerCorpse.playerSteamID);
					associatedEntity.AssignClothing(playerCorpse.containers[1]);
				}
				else if (corpse is HorseCorpse horseCorpse)
				{
					associatedEntity.AssignHorseBreed(horseCorpse.breedIndex);
				}
			}
			if (info.InitiatorPlayer.inventory.GiveItem(item))
			{
				info.InitiatorPlayer.Command("note.inv", HeadDef.itemid, 1);
			}
			else
			{
				item.DropAndTossUpwards(info.HitPositionWorld);
			}
		}
		hasDispensed = true;
	}
}


using UnityEngine;

public class HideIfOwnerFirstPerson : EntityComponent<BaseEntity>, IClientComponent, IViewModeChanged
{
	public GameObject[] disableGameObjects;

	public bool worldModelEffect;
}


using UnityEngine;

public class HumanBodyResourceDispenser : ResourceDispenser
{
	public override bool OverrideOwnership(Item item, AttackEntity weapon)
	{
		if (item != null && item.info.shortname == "skull.human")
		{
			PlayerCorpse component = ((Component)this).GetComponent<PlayerCorpse>();
			if (Object.op_Implicit((Object)(object)component))
			{
				item.name = CreateSkullName(component.playerName);
				item.streamerName = CreateSkullName(component.streamerName);
				return true;
			}
		}
		return false;
	}

	public static string CreateSkullName(string playerName)
	{
		return "Skull of \"" + playerName + "\"";
	}
}


using UnityEngine;

public class LerpBetweenPointsBool : MonoBehaviour, IClientComponent
{
	public Vector3 offsetPosLocal;

	public float speed;

	public bool UseAsOffset;

	public void SetAtOffset(bool should)
	{
	}
}


using UnityEngine;

public class LootDistanceOverride : MonoBehaviour
{
	public float amount = 2.1f;
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

public class ResourceDispenser : EntityComponent<BaseEntity>, IServerComponent
{
	public enum GatherType
	{
		Tree,
		Ore,
		Flesh,
		UNSET,
		LAST
	}

	[Serializable]
	public class GatherPropertyEntry
	{
		public float gatherDamage;

		public float destroyFraction;

		public float conditionLost;
	}

	[Serializable]
	public class GatherProperties
	{
		public GatherPropertyEntry Tree;

		public GatherPropertyEntry Ore;

		public GatherPropertyEntry Flesh;

		public bool ProduceHeadItem;

		public float GetProficiency()
		{
			float num = 0f;
			for (int i = 0; i < 3; i++)
			{
				GatherPropertyEntry fromIndex = GetFromIndex(i);
				float num2 = fromIndex.gatherDamage * fromIndex.destroyFraction;
				if (num2 > 0f)
				{
					num += fromIndex.gatherDamage / num2;
				}
			}
			return num;
		}

		public bool Any()
		{
			for (int i = 0; i < 3; i++)
			{
				GatherPropertyEntry fromIndex = GetFromIndex(i);
				if (fromIndex.gatherDamage > 0f || fromIndex.conditionLost > 0f)
				{
					return true;
				}
			}
			return false;
		}

		public GatherPropertyEntry GetFromIndex(int index)
		{
			return GetFromIndex((GatherType)index);
		}

		public GatherPropertyEntry GetFromIndex(GatherType index)
		{
			return index switch
			{
				GatherType.Tree => Tree, 
				GatherType.Ore => Ore, 
				GatherType.Flesh => Flesh, 
				_ => null, 
			};
		}
	}

	public Phrase OwnershipPhrase;

	public GatherType gatherType = GatherType.UNSET;

	public List<ItemAmount> containedItems;

	public float maxDestroyFractionForFinishBonus = 0.2f;

	public List<ItemAmount> finishBonus;

	public bool forceFullFinishBonus;

	public float fractionRemaining = 1f;

	private float categoriesRemaining;

	private float startingItemCounts;

	private static Dictionary<GatherType, HashSet<int>> cachedResourceItemTypes;

	public void Start()
	{
		Initialize();
	}

	public void Initialize()
	{
		CacheResourceTypeItems();
		UpdateFraction();
		UpdateRemainingCategories();
		CountAllItems();
	}

	private void CacheResourceTypeItems()
	{
		if (cachedResourceItemTypes == null)
		{
			cachedResourceItemTypes = new Dictionary<GatherType, HashSet<int>>();
			HashSet<int> hashSet = new HashSet<int>();
			hashSet.Add(ItemManager.FindItemDefinition("wood").itemid);
			cachedResourceItemTypes.Add(GatherType.Tree, hashSet);
			HashSet<int> hashSet2 = new HashSet<int>();
			hashSet2.Add(ItemManager.FindItemDefinition("stones").itemid);
			hashSet2.Add(ItemManager.FindItemDefinition("sulfur.ore").itemid);
			hashSet2.Add(ItemManager.FindItemDefinition("metal.ore").itemid);
			hashSet2.Add(ItemManager.FindItemDefinition("hq.metal.ore").itemid);
			cachedResourceItemTypes.Add(GatherType.Ore, hashSet2);
		}
	}

	public void DoGather(HitInfo info, BaseCorpse corpse = null)
	{
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		if (!base.baseEntity.isServer || !info.CanGather || info.DidGather)
		{
			return;
		}
		if (gatherType == GatherType.UNSET)
		{
			Debug.LogWarning((object)("Object :" + ((Object)((Component)this).gameObject).name + ": has unset gathertype!"));
			return;
		}
		float num = 0f;
		float num2 = 0f;
		float num3 = (((Object)(object)info.InitiatorPlayer != (Object)null && info.InitiatorPlayer.HasPlayerFlag(BasePlayer.PlayerFlags.IsInTutorial)) ? 3f : 1f);
		BaseMelee baseMelee = (((Object)(object)info.Weapon == (Object)null) ? null : (info.Weapon as BaseMelee));
		if ((Object)(object)baseMelee != (Object)null)
		{
			GatherPropertyEntry gatherInfoFromIndex = baseMelee.GetGatherInfoFromIndex(gatherType);
			num = gatherInfoFromIndex.gatherDamage * info.gatherScale * num3;
			num2 = gatherInfoFromIndex.destroyFraction;
			if (num == 0f)
			{
				return;
			}
			baseMelee.SendPunch(new Vector3(Random.Range(0.5f, 1f), Random.Range(-0.25f, -0.5f), 0f) * -30f * (gatherInfoFromIndex.conditionLost / 6f), 0.05f);
			baseMelee.LoseCondition(gatherInfoFromIndex.conditionLost);
			if (!baseMelee.IsValid() || baseMelee.IsBroken())
			{
				return;
			}
			info.DidGather = true;
		}
		else
		{
			num = info.damageTypes.Total();
			num2 = 0.5f;
		}
		float num4 = fractionRemaining;
		GiveResources(info.InitiatorPlayer, num, num2, info.Weapon);
		UpdateFraction();
		float num5 = 0f;
		if (fractionRemaining <= 0f)
		{
			num5 = base.baseEntity.MaxHealth();
			if (info.DidGather && num2 < maxDestroyFractionForFinishBonus)
			{
				AssignFinishBonus(info.InitiatorPlayer, 1f - num2, info.Weapon);
			}
			HeadDispenser headDispenser = default(HeadDispenser);
			if (((Component)this).gameObject.TryGetComponent<HeadDispenser>(ref headDispenser))
			{
				headDispenser.DispenseHead(info, corpse);
			}
		}
		else
		{
			num5 = (num4 - fractionRemaining) * base.baseEntity.MaxHealth();
		}
		HitInfo hitInfo = new HitInfo(info.Initiator, base.baseEntity, DamageType.Generic, num5, ((Component)this).transform.position);
		hitInfo.gatherScale = 0f;
		hitInfo.PointStart = info.PointStart;
		hitInfo.PointEnd = info.PointEnd;
		hitInfo.WeaponPrefab = info.WeaponPrefab;
		hitInfo.Weapon = info.Weapon;
		base.baseEntity.OnAttacked(hitInfo);
	}

	public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)
	{
		if (forceFullFinishBonus)
		{
			fraction = 1f;
		}
		((Component)this).SendMessage("FinishBonusAssigned", (SendMessageOptions)1);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			int num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));
			int num2 = CalculateGatherBonus(player, finishBonu, num);
			Item item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", (object)this, (object)player, (object)item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				ApplyItemOwnership(player, item);
				Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);
				Interface.CallHook("OnDispenserBonusReceived", (object)this, (object)player, (object)item);
				while (item.amount > item.MaxStackable())
				{
					Item item2 = item.SplitItem(item.MaxStackable());
					player.GiveItem(item2, BaseEntity.GiveItemReason.ResourceHarvested);
				}
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

	public void OnAttacked(HitInfo info)
	{
		DoGather(info);
	}

	private void GiveResources(BasePlayer entity, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		if (!entity.IsValid() || gatherDamage <= 0f)
		{
			return;
		}
		ItemAmount itemAmount = null;
		int num = containedItems.Count;
		int num2 = Random.Range(0, containedItems.Count);
		while (num > 0)
		{
			if (num2 >= containedItems.Count)
			{
				num2 = 0;
			}
			if (containedItems[num2].amount > 0f)
			{
				itemAmount = containedItems[num2];
				break;
			}
			num2++;
			num--;
		}
		if (itemAmount == null)
		{
			return;
		}
		GiveResourceFromItem(entity, itemAmount, gatherDamage, destroyFraction, attackWeapon);
		UpdateVars();
		if (Object.op_Implicit((Object)(object)entity))
		{
			Debug.Assert(attackWeapon.GetItem() != null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " has no Item");
			Debug.Assert(((ItemId)(ref attackWeapon.ownerItemUID)).IsValid, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerItemUID is 0");
			Debug.Assert((Object)(object)attackWeapon.GetParentEntity() != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is null");
			Debug.Assert(attackWeapon.GetParentEntity().IsValid(), "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is not valid");
			Debug.Assert((Object)(object)attackWeapon.GetParentEntity().ToPlayer() != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is not a player");
			Debug.Assert(!attackWeapon.GetParentEntity().ToPlayer().IsDead(), "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is not valid");
			BasePlayer ownerPlayer = attackWeapon.GetOwnerPlayer();
			Debug.Assert((Object)(object)ownerPlayer != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerPlayer is null");
			Debug.Assert((Object)(object)ownerPlayer == (Object)(object)entity, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerPlayer is not player");
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				Debug.Assert((Object)(object)ownerPlayer.inventory != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerPlayer inventory is null");
				Debug.Assert(ownerPlayer.inventory.FindItemByUID(attackWeapon.ownerItemUID) != null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " FindItemByUID is null");
			}
		}
	}

	public void DestroyFraction(float fraction)
	{
		foreach (ItemAmount containedItem in containedItems)
		{
			if (containedItem.amount > 0f)
			{
				containedItem.amount -= fraction / categoriesRemaining;
			}
		}
		UpdateVars();
	}

	private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float num3 = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		num3 = Mathf.Round(num3);
		float num4 = num3 * destroyFraction * 2f;
		if (itemAmt.amount <= num3 + num4)
		{
			float num5 = (num3 + num4) / itemAmt.amount;
			num3 /= num5;
			num4 /= num5;
		}
		itemAmt.amount -= Mathf.Floor(num3);
		itemAmt.amount -= Mathf.Floor(num4);
		if (num3 < 1f)
		{
			num3 = ((Random.Range(0f, 1f) <= num3) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (!(num3 >= 1f))
		{
			return;
		}
		int num6 = CalculateGatherBonus(entity, itemAmt, num3);
		int iAmount = Mathf.FloorToInt(num3) + num6;
		Item item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);
		if (Interface.CallHook("OnDispenserGather", (object)this, (object)entity, (object)item) == null && item != null)
		{
			ApplyItemOwnership(entity, item);
			OverrideOwnership(item, attackWeapon);
			Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);
			Interface.CallHook("OnDispenserGathered", (object)this, (object)entity, (object)item);
			while (item.amount > item.MaxStackable())
			{
				Item item2 = item.SplitItem(item.MaxStackable());
				entity.GiveItem(item2, BaseEntity.GiveItemReason.ResourceHarvested);
			}
			entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
		}
	}

	private void ApplyItemOwnership(BasePlayer player, Item item)
	{
		if (OwnershipPhrase != null && !string.IsNullOrEmpty(OwnershipPhrase.token))
		{
			item.SetItemOwnership(player, OwnershipPhrase.token);
		}
		else
		{
			item.SetItemOwnership(player, ItemOwnershipPhrases.GatheredPhrase);
		}
	}

	private int CalculateGatherBonus(BaseEntity entity, ItemAmount item, float amountToGive)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return 0;
		}
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return 0;
		}
		if ((Object)(object)basePlayer.modifiers == (Object)null)
		{
			return 0;
		}
		amountToGive = Mathf.FloorToInt(amountToGive);
		float num = 1f;
		Modifier.ModifierType type;
		switch (gatherType)
		{
		case GatherType.Tree:
			type = Modifier.ModifierType.Wood_Yield;
			break;
		case GatherType.Ore:
			type = Modifier.ModifierType.Ore_Yield;
			break;
		case GatherType.Flesh:
			type = Modifier.ModifierType.Harvesting;
			break;
		default:
			return 0;
		}
		if (!IsProducedItemOfGatherType(item))
		{
			return 0;
		}
		num += basePlayer.modifiers.GetValue(type);
		float variableValue = basePlayer.modifiers.GetVariableValue(type, 0f);
		float num2 = ((num > 1f) ? Mathf.Max(amountToGive * num - amountToGive, 0f) : 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(type, variableValue);
		return num3;
	}

	private bool IsProducedItemOfGatherType(ItemAmount item)
	{
		if (gatherType == GatherType.Tree)
		{
			return cachedResourceItemTypes[GatherType.Tree].Contains(item.itemid);
		}
		if (gatherType == GatherType.Ore)
		{
			return cachedResourceItemTypes[GatherType.Ore].Contains(item.itemid);
		}
		if (gatherType == GatherType.Flesh)
		{
			return item.startAmount > 1f;
		}
		return false;
	}

	public virtual bool OverrideOwnership(Item item, AttackEntity weapon)
	{
		return false;
	}

	private void UpdateVars()
	{
		UpdateFraction();
		UpdateRemainingCategories();
	}

	public void UpdateRemainingCategories()
	{
		int num = 0;
		foreach (ItemAmount containedItem in containedItems)
		{
			if (containedItem.amount > 0f)
			{
				num++;
			}
		}
		categoriesRemaining = num;
	}

	public void CountAllItems()
	{
		startingItemCounts = containedItems.Sum((ItemAmount x) => x.startAmount);
	}

	private void UpdateFraction()
	{
		float num = containedItems.Sum((ItemAmount x) => x.startAmount);
		float num2 = containedItems.Sum((ItemAmount x) => x.amount);
		if (num == 0f)
		{
			fractionRemaining = 0f;
		}
		else
		{
			fractionRemaining = num2 / num;
		}
	}

	public bool HasItemToDispense(ItemDefinition def)
	{
		if ((Object)(object)def == (Object)null)
		{
			return false;
		}
		foreach (ItemAmount containedItem in containedItems)
		{
			if ((Object)(object)containedItem.itemDef == (Object)(object)def && containedItem.amount > 0f)
			{
				return true;
			}
		}
		return false;
	}
}


public enum GatherType
{
	Tree,
	Ore,
	Flesh,
	UNSET,
	LAST
}


using System;

[Serializable]
public class GatherPropertyEntry
{
	public float gatherDamage;

	public float destroyFraction;

	public float conditionLost;
}


using System;

[Serializable]
public class GatherProperties
{
	public GatherPropertyEntry Tree;

	public GatherPropertyEntry Ore;

	public GatherPropertyEntry Flesh;

	public bool ProduceHeadItem;

	public float GetProficiency()
	{
		float num = 0f;
		for (int i = 0; i < 3; i++)
		{
			GatherPropertyEntry fromIndex = GetFromIndex(i);
			float num2 = fromIndex.gatherDamage * fromIndex.destroyFraction;
			if (num2 > 0f)
			{
				num += fromIndex.gatherDamage / num2;
			}
		}
		return num;
	}

	public bool Any()
	{
		for (int i = 0; i < 3; i++)
		{
			GatherPropertyEntry fromIndex = GetFromIndex(i);
			if (fromIndex.gatherDamage > 0f || fromIndex.conditionLost > 0f)
			{
				return true;
			}
		}
		return false;
	}

	public GatherPropertyEntry GetFromIndex(int index)
	{
		return GetFromIndex((GatherType)index);
	}

	public GatherPropertyEntry GetFromIndex(GatherType index)
	{
		return index switch
		{
			GatherType.Tree => Tree, 
			GatherType.Ore => Ore, 
			GatherType.Flesh => Flesh, 
			_ => null, 
		};
	}
}


using System;
using Rust;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class Barricade : DecayEntity
{
	public float reflectDamage = 5f;

	public GameObjectRef reflectEffect;

	public bool canNpcSmash = true;

	public NavMeshModifierVolume NavMeshVolumeAnimals;

	public NavMeshModifierVolume NavMeshVolumeHumanoids;

	[NonSerialized]
	public NPCBarricadeTriggerBox NpcTriggerBox;

	private static int nonWalkableArea = -1;

	private static int animalAgentTypeId = -1;

	private static int humanoidAgentTypeId = -1;

	public override void ServerInit()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (nonWalkableArea < 0)
		{
			nonWalkableArea = NavMesh.GetAreaFromName("Not Walkable");
		}
		NavMeshBuildSettings settingsByIndex;
		if (animalAgentTypeId < 0)
		{
			settingsByIndex = NavMesh.GetSettingsByIndex(1);
			animalAgentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		}
		if ((Object)(object)NavMeshVolumeAnimals == (Object)null)
		{
			NavMeshVolumeAnimals = ((Component)this).gameObject.AddComponent<NavMeshModifierVolume>();
			NavMeshVolumeAnimals.area = nonWalkableArea;
			NavMeshVolumeAnimals.AddAgentType(animalAgentTypeId);
			NavMeshVolumeAnimals.center = Vector3.zero;
			NavMeshVolumeAnimals.size = Vector3.one;
		}
		if (!canNpcSmash)
		{
			if (humanoidAgentTypeId < 0)
			{
				settingsByIndex = NavMesh.GetSettingsByIndex(0);
				humanoidAgentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
			}
			if ((Object)(object)NavMeshVolumeHumanoids == (Object)null)
			{
				NavMeshVolumeHumanoids = ((Component)this).gameObject.AddComponent<NavMeshModifierVolume>();
				NavMeshVolumeHumanoids.area = nonWalkableArea;
				NavMeshVolumeHumanoids.AddAgentType(humanoidAgentTypeId);
				NavMeshVolumeHumanoids.center = Vector3.zero;
				NavMeshVolumeHumanoids.size = Vector3.one;
			}
		}
		else if ((Object)(object)NpcTriggerBox == (Object)null)
		{
			NpcTriggerBox = new GameObject("NpcTriggerBox").AddComponent<NPCBarricadeTriggerBox>();
			NpcTriggerBox.Setup(this);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && info.WeaponPrefab is BaseMelee && !info.IsProjectile())
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			if (Object.op_Implicit((Object)(object)basePlayer) && reflectDamage > 0f)
			{
				basePlayer.Hurt(reflectDamage * Random.Range(0.75f, 1.25f), DamageType.Stab, this);
				if (reflectEffect.isValid)
				{
					Effect.server.Run(reflectEffect.resourcePath, basePlayer, StringPool.closest, ((Component)this).transform.position, Vector3.up);
				}
			}
		}
		base.OnAttacked(info);
	}
}


public class BaseFuelLightSource : BaseOven
{
}


public class BaseLadder : BaseCombatEntity
{
	public override bool ShouldBlockProjectiles()
	{
		return false;
	}
}


using UnityEngine;

public class BoxStorage : StorageContainer
{
	public Hopper.MountType HopperMountType;

	public override Vector3 GetDropPosition()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return ClosestPoint(base.GetDropPosition() + base.LastAttackedDir * 10f);
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (children.Count != 0)
		{
			lastPickupError = Phrase.op_Implicit(string.Format(PickupErrors.ItemHasAttachment.translated, pickup.itemTarget.displayName.translated));
			return false;
		}
		return base.CanCompletePickup(player);
	}
}


using System;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class ElectricOven : BaseOven
{
	public GameObjectRef IoEntity;

	public Transform IoEntityAnchor;

	public EntityRef<IOEntity> spawnedIo;

	public override bool CanRunWithNoFuel
	{
		get
		{
			if (spawnedIo.IsValid(serverside: true))
			{
				return spawnedIo.Get(serverside: true).IsPowered();
			}
			return false;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SpawnIOEnt();
		}
	}

	public void SpawnIOEnt()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (IoEntity.isValid && (Object)(object)IoEntityAnchor != (Object)null)
		{
			IOEntity iOEntity = GameManager.server.CreateEntity(IoEntity.resourcePath, IoEntityAnchor.position, IoEntityAnchor.rotation) as IOEntity;
			iOEntity.SetParent(this, worldPositionStays: true);
			spawnedIo.Set(iOEntity);
			iOEntity.Spawn();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.simpleUID == null)
		{
			info.msg.simpleUID = Pool.Get<SimpleUID>();
		}
		info.msg.simpleUID.uid = spawnedIo.uid;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.simpleUID != null)
		{
			spawnedIo.uid = info.msg.simpleUID.uid;
		}
	}

	public override void OvenFull()
	{
		((FacepunchBehaviour)this).Invoke((Action)PauseCooking, 0f);
	}

	private void PauseCooking()
	{
		UpdateAttachmentTemperature();
		if (base.inventory != null)
		{
			base.inventory.temperature = 15f;
			foreach (Item item in base.inventory.itemList)
			{
				if (item.HasFlag(Item.Flag.OnFire))
				{
					item.SetFlag(Item.Flag.OnFire, b: false);
					item.MarkDirty();
				}
				if (item.HasFlag(Item.Flag.Cooking))
				{
					item.SetFlag(Item.Flag.Cooking, b: false);
					item.MarkDirty();
				}
			}
		}
		SetFlag(Flags.Reserved8, b: true);
	}

	public override void OnItemAddedOrRemoved(Item item, bool bAdded)
	{
		base.OnItemAddedOrRemoved(item, bAdded);
		if (item != null && !bAdded && HasFlag(Flags.Reserved8))
		{
			SetFlag(Flags.Reserved8, b: false);
		}
	}

	protected override bool CanPickupOven()
	{
		return children.Count == 1;
	}
}


public interface IImageReceiver
{
}


using UnityEngine;

public class ItemModSculpture : ItemModAssociatedEntity<AssociatedSculptureStorage>
{
	protected override bool AllowNullParenting => true;

	protected override bool ShouldAutoCreateEntity => false;

	public void OnSculpturePickUp(NetworkableId id, uint crc, Item item)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		AssociatedSculptureStorage associatedSculptureStorage = CreateAssociatedEntity(item);
		if ((Object)(object)associatedSculptureStorage != (Object)null)
		{
			associatedSculptureStorage.InitFromSculpture(crc, id);
		}
	}
}


using UnityEngine;

public class ItemModSign : ItemModAssociatedEntity<SignContent>
{
	protected override bool AllowNullParenting => true;

	protected override bool ShouldAutoCreateEntity => false;

	public void OnSignPickedUp(ISignage s, IUGCBrowserEntity ugc, Item toItem)
	{
		SignContent signContent = CreateAssociatedEntity(toItem);
		if ((Object)(object)signContent != (Object)null)
		{
			signContent.CopyInfoFromSign(s, ugc);
		}
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class PercentFullStorageContainer : StorageContainer
{
	private float prevPercentFull = -1f;

	public bool IsFull()
	{
		return GetPercentFull() == 1f;
	}

	public bool IsEmpty()
	{
		return GetPercentFull() == 0f;
	}

	protected virtual void OnPercentFullChanged(float newPercentFull)
	{
	}

	public float GetPercentFull()
	{
		if (base.isServer)
		{
			float num = 0f;
			if (base.inventory != null)
			{
				foreach (Item item in base.inventory.itemList)
				{
					num += (float)item.amount / (float)item.MaxStackable();
				}
				num /= (float)base.inventory.capacity;
			}
			return num;
		}
		return 0f;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.simpleInt;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.simpleInt = Pool.Get<SimpleInt>();
		info.msg.simpleInt.value = Mathf.CeilToInt(GetPercentFull() * 100f);
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		float percentFull = GetPercentFull();
		if (percentFull != prevPercentFull)
		{
			OnPercentFullChanged(percentFull);
			SendNetworkUpdate();
			prevPercentFull = percentFull;
		}
	}
}


using System;
using UnityEngine;

public class PoweredWaterPurifier : WaterPurifier
{
	public float ConvertInterval = 5f;

	public int PowerDrain = 5;

	public Material PoweredMaterial;

	public Material UnpoweredMaterial;

	public MeshRenderer TargetRenderer;

	public override void ResetState()
	{
		base.ResetState();
	}

	protected override void SpawnStorageEnt(bool load)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		if (load)
		{
			foreach (BaseEntity child in children)
			{
				if (child is LiquidContainer liquidContainer)
				{
					purifiedWaterStorage = liquidContainer;
				}
			}
		}
		if ((Object)(object)purifiedWaterStorage != (Object)null)
		{
			purifiedWaterStorage.SetConnectedTo(this);
			return;
		}
		purifiedWaterStorage = GameManager.server.CreateEntity(storagePrefab.resourcePath, storagePrefabAnchor.position, storagePrefabAnchor.rotation) as LiquidContainer;
		purifiedWaterStorage.SetParent(this, worldPositionStays: true);
		purifiedWaterStorage.Spawn();
		purifiedWaterStorage.SetConnectedTo(this);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (HasLiquidItem())
		{
			if (HasFlag(Flags.Reserved8) && !((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)ConvertWater, ConvertInterval, ConvertInterval, ConvertInterval * 0.1f);
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ConvertWater);
		}
	}

	private void ConvertWater()
	{
		if (HasDirtyWater())
		{
			ConvertWater(ConvertInterval);
			dirtyWaterProcssed = 0f;
		}
	}

	public override int ConsumptionAmount()
	{
		return PowerDrain;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer)
		{
			return;
		}
		if (old.HasFlag(Flags.Reserved8) != next.HasFlag(Flags.Reserved8))
		{
			if (next.HasFlag(Flags.Reserved8))
			{
				if (!((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
				{
					((FacepunchBehaviour)this).InvokeRandomized((Action)ConvertWater, ConvertInterval, ConvertInterval, ConvertInterval * 0.1f);
				}
			}
			else if (((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ConvertWater);
			}
		}
		if ((Object)(object)purifiedWaterStorage != (Object)null)
		{
			purifiedWaterStorage.SetFlag(Flags.Reserved8, HasFlag(Flags.Reserved8));
		}
	}
}


using UnityEngine;

public interface ISignage
{
	Vector2i TextureSize { get; }

	int TextureCount { get; }

	NetworkableId NetworkID { get; }

	FileStorage.Type FileType { get; }

	bool CanUpdateSign(BasePlayer player);

	float Distance(Vector3 position);

	uint[] GetTextureCRCs();

	void SetTextureCRCs(uint[] crcs);
}


using System.Collections.Generic;

public interface IUGCBrowserEntity
{
	uint[] GetContentCRCs { get; }

	UGCType ContentType { get; }

	List<ulong> EditingHistory { get; }

	BaseNetworkable UgcEntity { get; }

	string ContentString { get; }

	void ClearContent();
}


public enum UGCType
{
	ImageJpg,
	ImagePng,
	AudioOgg,
	Sculpt,
	PatternBoomer,
	VendingMachine
}


using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;

public class SignContent : ImageStorageEntity, IUGCBrowserEntity
{
	public uint[] textureIDs = new uint[1];

	private List<ulong> editHistory = new List<ulong>();

	protected override uint CrcToLoad => textureIDs[0];

	protected override FileStorage.Type StorageType => FileStorage.Type.png;

	public UGCType ContentType => UGCType.ImagePng;

	public uint[] GetContentCRCs => textureIDs;

	public FileStorage.Type FileType => StorageType;

	public List<ulong> EditingHistory => editHistory;

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public void CopyInfoFromSign(ISignage s, IUGCBrowserEntity b)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		uint[] textureCRCs = s.GetTextureCRCs();
		textureIDs = new uint[textureCRCs.Length];
		textureCRCs.CopyTo(textureIDs, 0);
		editHistory.Clear();
		foreach (ulong item in b.EditingHistory)
		{
			editHistory.Add(item);
		}
		FileStorage.server.ReassignEntityId(s.NetworkID, net.ID);
	}

	public void CopyInfoToSign(ISignage s, IUGCBrowserEntity b)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		FileStorage.server.ReassignEntityId(net.ID, s.NetworkID);
		s.SetTextureCRCs(textureIDs);
		b.EditingHistory.Clear();
		foreach (ulong item in editHistory)
		{
			b.EditingHistory.Add(item);
		}
		Interface.CallHook("OnSignContentCopied", (object)this, (object)s, (object)b);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.paintableSign == null)
		{
			info.msg.paintableSign = Pool.Get<PaintableSign>();
		}
		info.msg.paintableSign.crcs = Pool.Get<List<uint>>();
		uint[] array = textureIDs;
		foreach (uint item in array)
		{
			info.msg.paintableSign.crcs.Add(item);
		}
	}

	internal override void DoServerDestroy()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		FileStorage.server.RemoveAllByEntity(net.ID);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.paintableSign != null)
		{
			textureIDs = new uint[info.msg.paintableSign.crcs.Count];
			for (int i = 0; i < info.msg.paintableSign.crcs.Count; i++)
			{
				textureIDs[i] = info.msg.paintableSign.crcs[i];
			}
		}
	}

	public void ClearContent()
	{
		Kill();
	}
}


using UnityEngine;

public class VisualFoodModel : MonoBehaviour, IClientComponent
{
	public MeshRenderer[] meshRenderers;

	public Animator animator;

	public bool stopEffectOnEnd;

	public ParticleSystemContainer particleContainer;

	public bool lerpScale;

	public Vector3 startScale;

	public Vector3 endScale;

	public AnimationCurve riseCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve colorCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public SoundDefinition cookingSound;
}


using System;
using UnityEngine;

public class VisualFoodSettings : PrefabAttribute, IClientComponent
{
	[Serializable]
	public class VisualFoodSetting
	{
		public GameObjectRef model;

		public GameObjectRef effectPrefab;

		public ItemDefinition[] items;

		public Transform[] parents;

		public Transform[] effects;

		[HideInInspector]
		public Vector3[] parentPositions;

		[HideInInspector]
		public Quaternion[] parentRotations;

		[HideInInspector]
		public Vector3[] parentScales;

		[HideInInspector]
		public Vector3[] effectParentPositions;

		[HideInInspector]
		public Quaternion[] effectParentRotations;

		[HideInInspector]
		public Vector3[] effectParentScales;

		public void ProcessSpawnPos(Transform rootTransform)
		{
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0168: Unknown result type (might be due to invalid IL or missing references)
			if (parents != null && parents.Length != 0)
			{
				parentPositions = (Vector3[])(object)new Vector3[parents.Length];
				parentRotations = (Quaternion[])(object)new Quaternion[parents.Length];
				parentScales = (Vector3[])(object)new Vector3[parents.Length];
				for (int i = 0; i < parents.Length; i++)
				{
					if ((Object)(object)parents[i] != (Object)null)
					{
						parentPositions[i] = parents[i].position;
						parentRotations[i] = parents[i].rotation;
						parentScales[i] = parents[i].localScale;
					}
				}
			}
			if (effects == null || effects.Length == 0)
			{
				return;
			}
			effectParentPositions = (Vector3[])(object)new Vector3[effects.Length];
			effectParentRotations = (Quaternion[])(object)new Quaternion[effects.Length];
			effectParentScales = (Vector3[])(object)new Vector3[effects.Length];
			for (int j = 0; j < effects.Length; j++)
			{
				if ((Object)(object)effects[j] != (Object)null)
				{
					effectParentPositions[j] = effects[j].position;
					effectParentRotations[j] = effects[j].rotation;
					effectParentScales[j] = effects[j].localScale;
				}
			}
		}
	}

	public Transform strippedParent;

	public VisualFoodSetting[] settings;

	protected override Type GetIndexedType()
	{
		return typeof(VisualFoodSettings);
	}
}


using System;
using UnityEngine;

[Serializable]
public class VisualFoodSetting
{
	public GameObjectRef model;

	public GameObjectRef effectPrefab;

	public ItemDefinition[] items;

	public Transform[] parents;

	public Transform[] effects;

	[HideInInspector]
	public Vector3[] parentPositions;

	[HideInInspector]
	public Quaternion[] parentRotations;

	[HideInInspector]
	public Vector3[] parentScales;

	[HideInInspector]
	public Vector3[] effectParentPositions;

	[HideInInspector]
	public Quaternion[] effectParentRotations;

	[HideInInspector]
	public Vector3[] effectParentScales;

	public void ProcessSpawnPos(Transform rootTransform)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		if (parents != null && parents.Length != 0)
		{
			parentPositions = (Vector3[])(object)new Vector3[parents.Length];
			parentRotations = (Quaternion[])(object)new Quaternion[parents.Length];
			parentScales = (Vector3[])(object)new Vector3[parents.Length];
			for (int i = 0; i < parents.Length; i++)
			{
				if ((Object)(object)parents[i] != (Object)null)
				{
					parentPositions[i] = parents[i].position;
					parentRotations[i] = parents[i].rotation;
					parentScales[i] = parents[i].localScale;
				}
			}
		}
		if (effects == null || effects.Length == 0)
		{
			return;
		}
		effectParentPositions = (Vector3[])(object)new Vector3[effects.Length];
		effectParentRotations = (Quaternion[])(object)new Quaternion[effects.Length];
		effectParentScales = (Vector3[])(object)new Vector3[effects.Length];
		for (int j = 0; j < effects.Length; j++)
		{
			if ((Object)(object)effects[j] != (Object)null)
			{
				effectParentPositions[j] = effects[j].position;
				effectParentRotations[j] = effects[j].rotation;
				effectParentScales[j] = effects[j].localScale;
			}
		}
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class WaterCatcher : LiquidContainer
{
	[Header("Water Catcher")]
	public ItemDefinition itemToCreate;

	public WaterCatcherCollectRate collectionRates;

	public float maxItemToCreate = 10f;

	[Header("Outside Test")]
	public Vector3 rainTestPosition = new Vector3(0f, 1f, 0f);

	public float rainTestSize = 1f;

	public const float collectInterval = 60f;

	public override void ServerInit()
	{
		base.ServerInit();
		AddResource(1);
		((FacepunchBehaviour)this).InvokeRandomized((Action)CollectWater, 60f, 60f, 6f);
	}

	public void CollectWater()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (!IsFull() && Interface.CallHook("OnWaterCollect", (object)this) == null)
		{
			float baseRate = collectionRates.baseRate;
			baseRate += Climate.GetFog(((Component)this).transform.position) * collectionRates.fogRate;
			if (TestIsOutside(((Component)this).transform, rainTestPosition, rainTestSize, 256f))
			{
				baseRate += Climate.GetRain(((Component)this).transform.position) * collectionRates.rainRate;
				baseRate += Climate.GetSnow(((Component)this).transform.position) * collectionRates.snowRate;
			}
			AddResource(Mathf.CeilToInt(maxItemToCreate * baseRate));
		}
	}

	public bool IsFull()
	{
		if (base.inventory.itemList.Count == 0)
		{
			return false;
		}
		if (base.inventory.itemList[0].amount < base.inventory.maxStackSize)
		{
			return false;
		}
		return true;
	}

	public static bool TestIsOutside(Transform t, Vector3 testPositionOffset, float testSize, float testDistance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = t.localToWorldMatrix;
		return !Physics.SphereCast(new Ray(((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(testPositionOffset), Vector3.up), testSize, testDistance, 161546513);
	}

	public void AddResource(int iAmount)
	{
		if (outputs.Length != 0)
		{
			IOEntity iOEntity = CheckPushLiquid(outputs[0].connectedTo.Get(), iAmount, this, IOEntity.backtracking * 2);
			if ((Object)(object)iOEntity != (Object)null && iOEntity is LiquidContainer liquidContainer)
			{
				liquidContainer.inventory.AddItem(itemToCreate, iAmount, 0uL);
				return;
			}
		}
		base.inventory.AddItem(itemToCreate, iAmount, 0uL);
		UpdateOnFlag();
	}

	private IOEntity CheckPushLiquid(IOEntity connected, int amount, IOEntity fromSource, int depth)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		if (depth <= 0 || (Object)(object)itemToCreate == (Object)null)
		{
			return null;
		}
		if ((Object)(object)connected == (Object)null)
		{
			return null;
		}
		Vector3 worldHandlePosition = Vector3.zero;
		IOEntity iOEntity = connected.FindGravitySource(ref worldHandlePosition, IOEntity.backtracking, ignoreSelf: true);
		if ((Object)(object)iOEntity != (Object)null && !connected.AllowLiquidPassthrough(iOEntity, worldHandlePosition))
		{
			return null;
		}
		if ((Object)(object)connected == (Object)(object)this || ConsiderConnectedTo(connected))
		{
			return null;
		}
		if (connected.prefabID == 2150367216u)
		{
			return null;
		}
		IOSlot[] array = connected.outputs;
		foreach (IOSlot iOSlot in array)
		{
			IOEntity iOEntity2 = iOSlot.connectedTo.Get();
			Vector3 sourceWorldPosition = ((Component)connected).transform.TransformPoint(iOSlot.handlePosition);
			if ((Object)(object)iOEntity2 != (Object)null && (Object)(object)iOEntity2 != (Object)(object)fromSource && iOEntity2.AllowLiquidPassthrough(connected, sourceWorldPosition))
			{
				IOEntity iOEntity3 = CheckPushLiquid(iOEntity2, amount, fromSource, depth - 1);
				if ((Object)(object)iOEntity3 != (Object)null)
				{
					return iOEntity3;
				}
			}
		}
		if (connected is LiquidContainer liquidContainer && liquidContainer.inventory.GetAmount(itemToCreate.itemid, onlyUsableAmounts: false) + amount < liquidContainer.maxStackSize)
		{
			return connected;
		}
		return null;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/Water Catcher Rates", fileName = "Water Catcher Collection Rates.asset")]
public class WaterCatcherCollectRate : ScriptableObject
{
	[Tooltip("Base collection rate that happens at all times")]
	public float baseRate = 0.25f;

	[Tooltip("Additional rate during rain")]
	public float rainRate = 1f;

	[Tooltip("Additional rate during snow")]
	public float snowRate = 0.5f;

	[Tooltip("Additional rate during fog. Fog water is also collected indoors")]
	public float fogRate = 2f;
}


using System;
using Oxide.Core;
using UnityEngine;

public class WaterPump : LiquidContainer
{
	public Transform WaterResourceLocation;

	public float PumpInterval = 20f;

	public int AmountPerPump = 30;

	public int PowerConsumption = 5;

	public override bool IsGravitySource => true;

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public void CreateWater()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (!IsFull())
		{
			ItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(WaterResourceLocation.position);
			if ((Object)(object)itemDefinition != (Object)null && Interface.CallHook("OnWaterCollect", (object)this, (object)itemDefinition) == null)
			{
				base.inventory.AddItem(itemDefinition, AmountPerPump, 0uL);
				UpdateOnFlag();
			}
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool flag = next.HasFlag(Flags.Reserved8);
		if (!base.isServer || old.HasFlag(Flags.Reserved8) == flag)
		{
			return;
		}
		if (flag)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)CreateWater))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)CreateWater, PumpInterval, PumpInterval, PumpInterval * 0.1f);
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)CreateWater))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)CreateWater);
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return Mathf.Clamp(GetLiquidCount(), 0, maxOutputFlow);
	}

	public bool IsFull()
	{
		if (base.inventory.itemList.Count == 0)
		{
			return false;
		}
		if (base.inventory.itemList[0].amount < base.inventory.maxStackSize)
		{
			return false;
		}
		return true;
	}
}


using System;
using Oxide.Core;
using Rust;
using UnityEngine;

public class WaterPurifier : LiquidContainer
{
	public static class WaterPurifierFlags
	{
		public const Flags Boiling = Flags.Reserved1;
	}

	public GameObjectRef storagePrefab;

	public Transform storagePrefabAnchor;

	public ItemDefinition freshWater;

	public int waterToProcessPerMinute = 120;

	public int freshWaterRatio = 4;

	public bool stopWhenOutputFull;

	public LiquidContainer purifiedWaterStorage;

	public float dirtyWaterProcssed;

	public float pendingFreshWater;

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SpawnStorageEnt(load: false);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SpawnStorageEnt(load: true);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if ((Object)(object)purifiedWaterStorage != (Object)null)
		{
			purifiedWaterStorage.Kill();
		}
	}

	protected virtual void SpawnStorageEnt(bool load)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		if (load)
		{
			BaseEntity baseEntity = GetParentEntity();
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				foreach (BaseEntity child in baseEntity.children)
				{
					if ((Object)(object)child != (Object)(object)this && child is LiquidContainer liquidContainer)
					{
						purifiedWaterStorage = liquidContainer;
						break;
					}
				}
			}
		}
		if ((Object)(object)purifiedWaterStorage != (Object)null)
		{
			purifiedWaterStorage.SetConnectedTo(this);
			return;
		}
		purifiedWaterStorage = GameManager.server.CreateEntity(storagePrefab.resourcePath, storagePrefabAnchor.localPosition, storagePrefabAnchor.localRotation) as LiquidContainer;
		purifiedWaterStorage.SetParent(GetParentEntity());
		purifiedWaterStorage.Spawn();
		purifiedWaterStorage.SetConnectedTo(this);
	}

	internal override void OnParentRemoved()
	{
		Kill(DestroyMode.Gib);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if (!purifiedWaterStorage.IsDestroyed)
		{
			purifiedWaterStorage.Kill();
		}
	}

	public void ParentTemperatureUpdate(float temp)
	{
	}

	public void CheckCoolDown()
	{
		if (!Object.op_Implicit((Object)(object)GetParentEntity()) || !GetParentEntity().IsOn() || !HasDirtyWater())
		{
			SetFlag(Flags.Reserved1, b: false);
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckCoolDown);
		}
	}

	public bool HasDirtyWater()
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot != null && slot.info.itemType == ItemContainer.ContentsType.Liquid)
		{
			return slot.amount > 0;
		}
		return false;
	}

	public bool HasPurifiedWater()
	{
		if ((Object)(object)purifiedWaterStorage == (Object)null || purifiedWaterStorage.inventory == null)
		{
			return false;
		}
		Item slot = purifiedWaterStorage.inventory.GetSlot(0);
		if (slot != null && slot.info.itemType == ItemContainer.ContentsType.Liquid)
		{
			return slot.amount > 0;
		}
		return false;
	}

	public void Cook(float timeCooked)
	{
		if (!((Object)(object)purifiedWaterStorage == (Object)null))
		{
			bool flag = HasDirtyWater();
			if (!IsBoiling() && flag)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CheckCoolDown, 2f, 2f);
				SetFlag(Flags.Reserved1, b: true);
			}
			if (IsBoiling() && flag)
			{
				ConvertWater(timeCooked);
			}
		}
	}

	protected void ConvertWater(float timeCooked)
	{
		Item slot = purifiedWaterStorage.inventory.GetSlot(0);
		if ((stopWhenOutputFull && slot != null && slot.amount >= slot.MaxStackable()) || Interface.CallHook("OnWaterPurify", (object)this, (object)timeCooked) != null)
		{
			return;
		}
		float num = timeCooked * ((float)waterToProcessPerMinute / 60f);
		if (slot != null)
		{
			float num2 = Mathf.Max(slot.MaxStackable() - slot.amount, 0);
			num = Mathf.Min(num, num2 * (float)freshWaterRatio);
		}
		dirtyWaterProcssed += num;
		if (dirtyWaterProcssed >= 1f)
		{
			Item slot2 = base.inventory.GetSlot(0);
			int num3 = Mathf.Min(Mathf.FloorToInt(dirtyWaterProcssed), slot2.amount);
			num = num3;
			slot2.UseItem(num3);
			dirtyWaterProcssed -= num3;
			SendNetworkUpdate();
		}
		pendingFreshWater += num / (float)freshWaterRatio;
		if (!(pendingFreshWater >= 1f))
		{
			return;
		}
		int num4 = Mathf.FloorToInt(pendingFreshWater);
		pendingFreshWater -= num4;
		Item slot3 = purifiedWaterStorage.inventory.GetSlot(0);
		if (slot3 != null && (Object)(object)slot3.info != (Object)(object)freshWater)
		{
			slot3.RemoveFromContainer();
			slot3.Remove();
		}
		if (slot3 == null)
		{
			Item item = ItemManager.Create(freshWater, num4, 0uL);
			if (!item.MoveToContainer(purifiedWaterStorage.inventory))
			{
				item.Remove();
			}
		}
		else
		{
			slot3.amount += num4;
			slot3.amount = Mathf.Clamp(slot3.amount, 0, purifiedWaterStorage.maxStackSize);
			purifiedWaterStorage.inventory.MarkDirty();
		}
		Interface.CallHook("OnWaterPurified", (object)this, (object)timeCooked);
		purifiedWaterStorage.SendNetworkUpdate();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			SetFlag(Flags.On, b: false);
		}
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (HasDirtyWater() || HasPurifiedWater())
		{
			lastPickupError = Phrase.op_Implicit(string.Format(PickupErrors.ItemInventoryMustBeEmpty.translated, pickup.itemTarget.displayName.translated));
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public bool IsBoiling()
	{
		return HasFlag(Flags.Reserved1);
	}
}


public static class WaterPurifierFlags
{
	public const Flags Boiling = Flags.Reserved1;
}


using System;
using ConVar;

public class DebrisEntity : BaseCombatEntity
{
	public float DebrisDespawnOverride;

	public override void ServerInit()
	{
		ResetRemovalTime();
		base.ServerInit();
	}

	public void RemoveCorpse()
	{
		Kill();
	}

	public void ResetRemovalTime(float dur)
	{
		TimeWarning val = TimeWarning.New("ResetRemovalTime", 0);
		try
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)RemoveCorpse))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)RemoveCorpse);
			}
			((FacepunchBehaviour)this).Invoke((Action)RemoveCorpse, dur);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float GetRemovalTime()
	{
		if (!(DebrisDespawnOverride > 0f))
		{
			return Server.debrisdespawn;
		}
		return DebrisDespawnOverride;
	}

	public void ResetRemovalTime()
	{
		ResetRemovalTime(GetRemovalTime());
	}

	public override string Categorize()
	{
		return "debris";
	}
}


using ConVar;
using UnityEngine;

public class BuildingBlockDecay : Decay
{
	private bool isFoundation;

	public override float GetDecayDelay(BaseEntity entity)
	{
		BuildingBlock buildingBlock = entity as BuildingBlock;
		BuildingGrade.Enum grade = (Object.op_Implicit((Object)(object)buildingBlock) ? buildingBlock.grade : BuildingGrade.Enum.Twigs);
		return GetDecayDelay(grade);
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		BuildingBlock buildingBlock = entity as BuildingBlock;
		BuildingGrade.Enum grade = (Object.op_Implicit((Object)(object)buildingBlock) ? buildingBlock.grade : BuildingGrade.Enum.Twigs);
		return GetDecayDuration(grade);
	}

	public override bool ShouldDecay(BaseEntity entity)
	{
		if (entity.net.group != null && entity.net.group.restricted)
		{
			return false;
		}
		if (ConVar.Decay.upkeep)
		{
			return true;
		}
		if (isFoundation)
		{
			return true;
		}
		BuildingBlock buildingBlock = entity as BuildingBlock;
		return !Object.op_Implicit((Object)(object)buildingBlock) || buildingBlock.grade == BuildingGrade.Enum.Twigs;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		isFoundation = name.Contains("foundation");
	}
}


using ConVar;

public class BuildingGradeDecay : Decay
{
	public BuildingGrade.Enum decayGrade;

	public override float GetDecayDelay(BaseEntity entity)
	{
		return GetDecayDelay(decayGrade);
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		return GetDecayDuration(decayGrade);
	}

	public override bool ShouldDecay(BaseEntity entity)
	{
		if (ConVar.Decay.upkeep)
		{
			return true;
		}
		return entity.IsOutside();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public abstract class Decay : PrefabAttribute, IServerComponent
{
	private const float hours = 3600f;

	protected float GetDecayDelay(BuildingGrade.Enum grade)
	{
		if (ConVar.Decay.upkeep)
		{
			if (ConVar.Decay.delay_override > 0f)
			{
				return ConVar.Decay.delay_override;
			}
			return grade switch
			{
				BuildingGrade.Enum.Wood => ConVar.Decay.delay_wood * 3600f, 
				BuildingGrade.Enum.Stone => ConVar.Decay.delay_stone * 3600f, 
				BuildingGrade.Enum.Metal => ConVar.Decay.delay_metal * 3600f, 
				BuildingGrade.Enum.TopTier => ConVar.Decay.delay_toptier * 3600f, 
				_ => ConVar.Decay.delay_twig * 3600f, 
			};
		}
		return grade switch
		{
			BuildingGrade.Enum.Wood => 64800f, 
			BuildingGrade.Enum.Stone => 64800f, 
			BuildingGrade.Enum.Metal => 64800f, 
			BuildingGrade.Enum.TopTier => 86400f, 
			_ => 3600f, 
		};
	}

	protected float GetDecayDuration(BuildingGrade.Enum grade)
	{
		if (ConVar.Decay.upkeep)
		{
			if (ConVar.Decay.duration_override > 0f)
			{
				return ConVar.Decay.duration_override;
			}
			return grade switch
			{
				BuildingGrade.Enum.Wood => ConVar.Decay.duration_wood * 3600f, 
				BuildingGrade.Enum.Stone => ConVar.Decay.duration_stone * 3600f, 
				BuildingGrade.Enum.Metal => ConVar.Decay.duration_metal * 3600f, 
				BuildingGrade.Enum.TopTier => ConVar.Decay.duration_toptier * 3600f, 
				_ => ConVar.Decay.duration_twig * 3600f, 
			};
		}
		return grade switch
		{
			BuildingGrade.Enum.Wood => 86400f, 
			BuildingGrade.Enum.Stone => 172800f, 
			BuildingGrade.Enum.Metal => 259200f, 
			BuildingGrade.Enum.TopTier => 432000f, 
			_ => 3600f, 
		};
	}

	public static void BuildingDecayTouch(BuildingBlock buildingBlock)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.Decay.upkeep)
		{
			return;
		}
		List<DecayEntity> list = Pool.Get<List<DecayEntity>>();
		Vis.Entities(((Component)buildingBlock).transform.position, 40f, list, 2097408, (QueryTriggerInteraction)2);
		for (int i = 0; i < list.Count; i++)
		{
			DecayEntity decayEntity = list[i];
			BuildingBlock buildingBlock2 = decayEntity as BuildingBlock;
			if (!Object.op_Implicit((Object)(object)buildingBlock2) || buildingBlock2.buildingID == buildingBlock.buildingID)
			{
				decayEntity.DecayTouch();
			}
		}
		Pool.FreeUnmanaged<DecayEntity>(ref list);
	}

	public static void EntityLinkDecayTouch(BaseEntity ent)
	{
		if (!ConVar.Decay.upkeep)
		{
			ent.EntityLinkBroadcast(delegate(DecayEntity decayEnt)
			{
				decayEnt.DecayTouch();
			});
		}
	}

	public static void RadialDecayTouch(Vector3 pos, float radius, int mask)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!ConVar.Decay.upkeep)
		{
			List<DecayEntity> list = Pool.Get<List<DecayEntity>>();
			Vis.Entities(pos, radius, list, mask, (QueryTriggerInteraction)2);
			for (int i = 0; i < list.Count; i++)
			{
				list[i].DecayTouch();
			}
			Pool.FreeUnmanaged<DecayEntity>(ref list);
		}
	}

	public virtual bool ShouldDecay(BaseEntity entity)
	{
		return true;
	}

	public abstract float GetDecayDelay(BaseEntity entity);

	public abstract float GetDecayDuration(BaseEntity entity);

	public virtual float GetDecayTickOverride()
	{
		return 0f;
	}

	public virtual float GetHealScale(BaseEntity entity)
	{
		return ConVar.Decay.upkeep_heal_scale;
	}

	public virtual float GetHealDelay(DecayEntity decayEntity)
	{
		return 600f;
	}

	protected override Type GetIndexedType()
	{
		return typeof(Decay);
	}
}


using ConVar;

public class DeployableDecay : Decay
{
	public float decayDelay = 8f;

	public float decayDuration = 8f;

	public bool overrideHealRate;

	public float decayTickOverride;

	public bool decayIndoors;

	public float healRate = 1f;

	public override float GetDecayDelay(BaseEntity entity)
	{
		return decayDelay * 60f * 60f;
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		return decayDuration * 60f * 60f;
	}

	public override float GetHealScale(BaseEntity entity)
	{
		if (!overrideHealRate)
		{
			return base.GetHealScale(entity);
		}
		return healRate;
	}

	public override float GetDecayTickOverride()
	{
		return decayTickOverride;
	}

	public override bool ShouldDecay(BaseEntity entity)
	{
		if (ConVar.Decay.upkeep || decayIndoors)
		{
			return true;
		}
		return entity.IsOutside();
	}
}


using ConVar;
using UnityEngine;

public class SprayDecay : Decay
{
	public override bool ShouldDecay(BaseEntity entity)
	{
		return true;
	}

	public override float GetDecayDelay(BaseEntity entity)
	{
		return 0f;
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		return Mathf.Max(Global.SprayDuration, 1f);
	}
}


using System;

public class Upkeep : PrefabAttribute
{
	public float upkeepMultiplier = 1f;

	protected override Type GetIndexedType()
	{
		return typeof(Upkeep);
	}
}


using System;
using UnityEngine;

public class DestroyOutsideMonument : FacepunchBehaviour
{
	[SerializeField]
	private BaseCombatEntity baseCombatEntity;

	[SerializeField]
	private float checkEvery = 10f;

	private MonumentInfo ourMonument;

	private Vector3 OurPos => ((Component)baseCombatEntity).transform.position;

	protected void OnEnable()
	{
		if ((Object)(object)ourMonument == (Object)null)
		{
			ourMonument = GetOurMonument();
		}
		if ((Object)(object)ourMonument == (Object)null)
		{
			DoOutsideMonument();
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)CheckPosition, checkEvery, checkEvery, checkEvery * 0.1f);
		}
	}

	protected void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CheckPosition);
	}

	private MonumentInfo GetOurMonument()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			if (monument.IsInBounds(OurPos))
			{
				return monument;
			}
		}
		return null;
	}

	private void CheckPosition()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ourMonument == (Object)null)
		{
			DoOutsideMonument();
		}
		if (!ourMonument.IsInBounds(OurPos))
		{
			DoOutsideMonument();
		}
	}

	private void DoOutsideMonument()
	{
		baseCombatEntity.Kill(BaseNetworkable.DestroyMode.Gib);
	}
}


using UnityEngine;

public class DisableSave : MonoBehaviour
{
	private void OnValidate()
	{
		BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
		if ((Object)(object)component != (Object)null)
		{
			Debug.LogWarning((object)"DisableSave is attached to a GameObject but can't find entity");
		}
		else if (component.enableSaving)
		{
			Debug.LogError((object)"BaseEntity.enableSaving must be disabled for the DisableSave component to work");
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class EntityLink : IPooled
{
	public BaseEntity owner;

	public Socket_Base socket;

	public List<EntityLink> connections = new List<EntityLink>(8);

	public int capacity = int.MaxValue;

	public string name => socket.socketName;

	public void Setup(BaseEntity owner, Socket_Base socket)
	{
		this.owner = owner;
		this.socket = socket;
		if (socket.monogamous)
		{
			capacity = 1;
		}
	}

	public void EnterPool()
	{
		owner = null;
		socket = null;
		capacity = int.MaxValue;
	}

	public void LeavePool()
	{
	}

	public bool Contains(EntityLink entity)
	{
		return connections.Contains(entity);
	}

	public void Add(EntityLink entity)
	{
		connections.Add(entity);
	}

	public void Remove(EntityLink entity)
	{
		connections.Remove(entity);
	}

	public void Clear()
	{
		for (int i = 0; i < connections.Count; i++)
		{
			connections[i].Remove(this);
		}
		connections.Clear();
	}

	public bool IsEmpty()
	{
		return connections.Count == 0;
	}

	public bool IsOccupied()
	{
		return connections.Count >= capacity;
	}

	public bool IsMale()
	{
		return socket.male;
	}

	public bool IsFemale()
	{
		return socket.female;
	}

	public bool CanConnect(EntityLink link)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (IsOccupied())
		{
			return false;
		}
		if (link == null)
		{
			return false;
		}
		if (link.IsOccupied())
		{
			return false;
		}
		return socket.CanConnect(((Component)owner).transform.position, ((Component)owner).transform.rotation, link.socket, ((Component)link.owner).transform.position, ((Component)link.owner).transform.rotation);
	}
}


using System.Collections.Generic;
using Facepunch;

public static class EntityLinkEx
{
	public static void FreeLinks(this List<EntityLink> links)
	{
		for (int i = 0; i < links.Count; i++)
		{
			EntityLink entityLink = links[i];
			entityLink.Clear();
			Pool.Free<EntityLink>(ref entityLink);
		}
		links.Clear();
	}

	public static void ClearLinks(this List<EntityLink> links)
	{
		for (int i = 0; i < links.Count; i++)
		{
			links[i].Clear();
		}
	}

	public static void AddLinks(this List<EntityLink> links, BaseEntity entity, Socket_Base[] sockets)
	{
		foreach (Socket_Base socket in sockets)
		{
			EntityLink entityLink = Pool.Get<EntityLink>();
			entityLink.Setup(entity, socket);
			links.Add(entityLink);
		}
	}
}


using UnityEngine;

public struct EntityRef
{
	internal BaseEntity ent_cached;

	internal NetworkableId id_cached;

	public NetworkableId uid
	{
		get
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			if (ent_cached.IsValid())
			{
				id_cached = ent_cached.net.ID;
			}
			return id_cached;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			id_cached = value;
			if (!((NetworkableId)(ref id_cached)).IsValid)
			{
				ent_cached = null;
			}
			else if (!ent_cached.IsValid() || !(ent_cached.net.ID == id_cached))
			{
				ent_cached = null;
			}
		}
	}

	public bool IsSet()
	{
		return ((NetworkableId)(ref id_cached)).IsValid;
	}

	public bool IsValid(bool serverside)
	{
		return Get(serverside).IsValid();
	}

	public void Set(BaseEntity ent)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		ent_cached = ent;
		id_cached = default(NetworkableId);
		if (ent_cached.IsValid())
		{
			id_cached = ent_cached.net.ID;
		}
	}

	public BaseEntity Get(bool serverside)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent_cached == (Object)null && ((NetworkableId)(ref id_cached)).IsValid)
		{
			if (serverside)
			{
				ent_cached = BaseNetworkable.serverEntities.Find(id_cached) as BaseEntity;
			}
			else
			{
				Debug.LogWarning((object)"EntityRef: Looking for clientside entities on pure server!");
			}
		}
		if (!ent_cached.IsValid())
		{
			ent_cached = null;
		}
		return ent_cached;
	}
}


public struct EntityRef<T> where T : BaseEntity
{
	private EntityRef entityRef;

	public bool IsSet => entityRef.IsSet();

	public NetworkableId uid
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return entityRef.uid;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			entityRef.uid = value;
		}
	}

	public EntityRef(NetworkableId uid)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		entityRef = new EntityRef
		{
			uid = uid
		};
	}

	public bool IsValid(bool serverside)
	{
		return Get(serverside).IsValid();
	}

	public void Set(T entity)
	{
		entityRef.Set(entity);
	}

	public T Get(bool serverside)
	{
		BaseEntity baseEntity = entityRef.Get(serverside);
		if (baseEntity == null)
		{
			return null;
		}
		if (!(baseEntity is T result))
		{
			Set(null);
			return null;
		}
		return result;
	}

	public bool TryGet(bool serverside, out T entity)
	{
		entity = Get(serverside);
		return entity != null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

public class FireBall : BaseEntity, ISplashable
{
	private const Flags StationaryFlag = Flags.Reserved1;

	public float lifeTimeMin = 20f;

	public float lifeTimeMax = 40f;

	public ParticleSystem[] movementSystems;

	public ParticleSystem[] restingSystems;

	[NonSerialized]
	public float generation;

	public GameObjectRef spreadSubEntity;

	public float tickRate = 0.5f;

	public float damagePerSecond = 2f;

	public float radius = 0.5f;

	public int waterToExtinguish = 200;

	public bool canMerge;

	public LayerMask AttackLayers = LayerMask.op_Implicit(1220225809);

	public bool ignoreNPC;

	private Vector3 lastPos = Vector3.zero;

	private float deathTime;

	private int wetness;

	private float spawnTime;

	private Vector3 delayedVelocity;

	private bool IsStationary => HasFlag(Flags.Reserved1);

	public void SetDelayedVelocity(Vector3 delayed)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!(delayedVelocity != Vector3.zero))
		{
			delayedVelocity = delayed;
			((FacepunchBehaviour)this).Invoke((Action)ApplyDelayedVelocity, 0.1f);
		}
	}

	private void ApplyDelayedVelocity()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		SetVelocity(delayedVelocity);
		delayedVelocity = Vector3.zero;
	}

	public override void ServerInit()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)Think, Random.Range(0f, 1f), tickRate);
		float num = Random.Range(lifeTimeMin, lifeTimeMax);
		float num2 = num * Random.Range(0.9f, 1.1f);
		((FacepunchBehaviour)this).Invoke((Action)Extinguish, num2);
		((FacepunchBehaviour)this).Invoke((Action)TryToSpread, num * Random.Range(0.3f, 0.5f));
		deathTime = Time.realtimeSinceStartup + num2;
		spawnTime = Time.realtimeSinceStartup;
		((Component)this).transform.rotation = Quaternion.identity;
		SetFlag(Flags.OnFire, b: true);
	}

	public float GetDeathTime()
	{
		return deathTime;
	}

	public void AddLife(float amountToAdd)
	{
		float num = Mathf.Clamp(GetDeathTime() + amountToAdd, 0f, MaxLifeTime());
		((FacepunchBehaviour)this).Invoke((Action)Extinguish, num);
		deathTime = num;
	}

	public float MaxLifeTime()
	{
		return lifeTimeMax * 2.5f;
	}

	public float TimeLeft()
	{
		float num = deathTime - Time.realtimeSinceStartup;
		if (num < 0f)
		{
			num = 0f;
		}
		return num;
	}

	public void TryToSpread()
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.9f - generation * 0.1f;
		if (Random.Range(0f, 1f) < num && spreadSubEntity.isValid)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).transform.position = ((Component)this).transform.position + Vector3.up * 0.25f;
				baseEntity.Spawn();
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);
				baseEntity.creatorEntity = (((Object)(object)creatorEntity == (Object)null) ? baseEntity : creatorEntity);
				Interface.CallHook("OnFireBallSpread", (object)this, (object)baseEntity);
				baseEntity.SetVelocity(modifiedAimConeDirection * Random.Range(5f, 8f));
				((Component)baseEntity).SendMessage("SetGeneration", (object)(generation + 1f));
			}
		}
	}

	public void SetGeneration(int gen)
	{
		generation = gen;
	}

	public void Think()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			Vector3 val = (((Component)this).transform.localPosition - lastPos) / Time.deltaTime;
			UpdateIsStationary(((Vector3)(ref val)).magnitude < 0.05f);
			lastPos = ((Component)this).transform.localPosition;
			if (IsStationary)
			{
				DoRadialDamage();
			}
			if (WaterFactor() > 0.5f)
			{
				Extinguish();
			}
			if (wetness > waterToExtinguish)
			{
				Extinguish();
			}
		}
	}

	public void DoRadialDamage()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		List<BaseCombatEntity> list = Pool.Get<List<BaseCombatEntity>>();
		Vector3 position = ((Component)this).transform.position + new Vector3(0f, radius * 0.75f, 0f);
		Vis.Entities(position, radius, list, LayerMask.op_Implicit(AttackLayers), (QueryTriggerInteraction)1);
		HitInfo hitInfo = new HitInfo();
		hitInfo.DoHitEffects = true;
		hitInfo.DidHit = true;
		hitInfo.HitBone = 0u;
		hitInfo.Initiator = (((Object)(object)creatorEntity == (Object)null) ? ((Component)this).gameObject.ToBaseEntity() : creatorEntity);
		hitInfo.PointStart = ((Component)this).transform.position;
		foreach (BaseCombatEntity item in list)
		{
			if (!((Object)(object)item == (Object)null) && item.isServer && item.IsAlive() && (!ignoreNPC || !item.IsNpc) && item.IsVisible(position))
			{
				if (item is BasePlayer)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", item, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
				}
				hitInfo.PointEnd = ((Component)item).transform.position;
				hitInfo.HitPositionWorld = ((Component)item).transform.position;
				hitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);
				Interface.CallHook("OnFireBallDamage", (object)this, (object)item, (object)hitInfo);
				item.OnAttacked(hitInfo);
			}
		}
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list);
	}

	public bool CanMerge()
	{
		if (canMerge)
		{
			return TimeLeft() < MaxLifeTime() * 0.8f;
		}
		return false;
	}

	public float TimeAlive()
	{
		return Time.realtimeSinceStartup - spawnTime;
	}

	public void UpdateIsStationary(bool shouldBeStationary)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (shouldBeStationary != IsStationary && shouldBeStationary && CanMerge())
		{
			List<Collider> list = Pool.Get<List<Collider>>();
			Vis.Colliders<Collider>(((Component)this).transform.position, 0.5f, list, 512, (QueryTriggerInteraction)2);
			foreach (Collider item in list)
			{
				BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					FireBall fireBall = baseEntity.ToServer<FireBall>();
					if (Object.op_Implicit((Object)(object)fireBall) && fireBall.CanMerge() && (Object)(object)fireBall != (Object)(object)this)
					{
						((FacepunchBehaviour)fireBall).Invoke((Action)Extinguish, 1f);
						fireBall.canMerge = false;
						AddLife(fireBall.TimeLeft() * 0.25f);
					}
				}
			}
			Pool.FreeUnmanaged<Collider>(ref list);
		}
		SetFlag(Flags.Reserved1, shouldBeStationary);
	}

	public void Extinguish()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Extinguish);
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return !base.IsDestroyed;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		wetness += amount;
		return amount;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using UnityEngine;

public class FireSpot : BaseEntity
{
	public GameObject flameEffect;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using Oxide.Core;
using UnityEngine;

public class FlameExplosive : TimedExplosive
{
	public GameObjectRef createOnExplode;

	public bool blockCreateUnderwater;

	public float numToCreate = 10f;

	public float minVelocity = 2f;

	public float maxVelocity = 5f;

	public float spreadAngle = 90f;

	public bool forceUpForExplosion;

	public AnimationCurve velocityCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	public AnimationCurve spreadCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	public override void Explode()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		FlameExplode(forceUpForExplosion ? Vector3.up : (-((Component)this).transform.forward));
	}

	public void FlameExplode(Vector3 surfaceNormal)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		if (blockCreateUnderwater && WaterLevel.Test(position, waves: true, volumes: false))
		{
			base.Explode();
			return;
		}
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.enabled = false;
		}
		for (int i = 0; (float)i < numToCreate; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, position);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				float num = (float)i / numToCreate;
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle * spreadCurve.Evaluate(num), surfaceNormal);
				float num2 = Random.Range(0f, 360f);
				Quaternion val = Quaternion.Euler(0f, num2, 0f);
				((Component)baseEntity).transform.SetPositionAndRotation(position, val);
				baseEntity.creatorEntity = (((Object)(object)creatorEntity == (Object)null) ? baseEntity : creatorEntity);
				baseEntity.Spawn();
				Interface.CallHook("OnFlameExplosion", (object)this, (object)component);
				Vector3 val2 = ((Vector3)(ref modifiedAimConeDirection)).normalized * Random.Range(minVelocity, maxVelocity) * velocityCurve.Evaluate(num * Random.Range(1f, 1.1f));
				FireBall component2 = ((Component)baseEntity).GetComponent<FireBall>();
				if ((Object)(object)component2 != (Object)null)
				{
					component2.SetDelayedVelocity(val2);
				}
				else
				{
					baseEntity.SetVelocity(val2);
				}
			}
		}
		base.Explode();
	}

	public override void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		hitNormal = ((RaycastHit)(ref info)).normal;
		FlameExplode(((RaycastHit)(ref info)).normal);
	}
}


public class GrowableGene
{
	public GrowableGenetics.GeneType Type { get; private set; }

	public GrowableGenetics.GeneType PreviousType { get; private set; }

	public void Set(GrowableGenetics.GeneType geneType, bool firstSet = false)
	{
		if (firstSet)
		{
			SetPrevious(geneType);
		}
		else
		{
			SetPrevious(Type);
		}
		Type = geneType;
	}

	public void SetPrevious(GrowableGenetics.GeneType type)
	{
		PreviousType = type;
	}

	public string GetDisplayCharacter()
	{
		return GetDisplayCharacter(Type);
	}

	public static string GetDisplayCharacter(GrowableGenetics.GeneType type)
	{
		return type switch
		{
			GrowableGenetics.GeneType.Empty => "X", 
			GrowableGenetics.GeneType.GrowthSpeed => "G", 
			GrowableGenetics.GeneType.Hardiness => "H", 
			GrowableGenetics.GeneType.WaterRequirement => "W", 
			GrowableGenetics.GeneType.Yield => "Y", 
			_ => "U", 
		};
	}

	public string GetColourCodedDisplayCharacter()
	{
		return GetColourCodedDisplayCharacter(Type);
	}

	public static string GetColourCodedDisplayCharacter(GrowableGenetics.GeneType type)
	{
		return "<color=" + (IsPositive(type) ? "#60891B>" : "#AA4734>") + GetDisplayCharacter(type) + "</color>";
	}

	public static bool IsPositive(GrowableGenetics.GeneType type)
	{
		return type switch
		{
			GrowableGenetics.GeneType.Empty => false, 
			GrowableGenetics.GeneType.GrowthSpeed => true, 
			GrowableGenetics.GeneType.Hardiness => true, 
			GrowableGenetics.GeneType.WaterRequirement => false, 
			GrowableGenetics.GeneType.Yield => true, 
			_ => false, 
		};
	}

	public bool IsPositive()
	{
		return IsPositive(Type);
	}
}


using System.Text;
using ProtoBuf;
using UnityEngine;

public static class GrowableGeneEncoding
{
	public static void EncodeGenesToItem(GrowableEntity sourceGrowable, Item targetItem)
	{
		if (!((Object)(object)sourceGrowable == (Object)null) && sourceGrowable.Genes != null)
		{
			EncodeGenesToItem(EncodeGenesToInt(sourceGrowable.Genes), targetItem);
		}
	}

	public static void EncodeGenesToItem(int genes, Item targetItem)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		if (targetItem != null)
		{
			targetItem.instanceData = new InstanceData
			{
				ShouldPool = false,
				dataInt = genes
			};
		}
	}

	public static int EncodeGenesToInt(GrowableGenes genes)
	{
		int num = 0;
		for (int i = 0; i < genes.Genes.Length; i++)
		{
			num = Set(num, i, (int)genes.Genes[i].Type);
		}
		return num;
	}

	public static int EncodePreviousGenesToInt(GrowableGenes genes)
	{
		int num = 0;
		for (int i = 0; i < genes.Genes.Length; i++)
		{
			num = Set(num, i, (int)genes.Genes[i].PreviousType);
		}
		return num;
	}

	public static void DecodeIntToGenes(int data, GrowableGenes genes)
	{
		for (int i = 0; i < 6; i++)
		{
			genes.Genes[i].Set((GrowableGenetics.GeneType)Get(data, i));
		}
	}

	public static void DecodeIntToPreviousGenes(int data, GrowableGenes genes)
	{
		for (int i = 0; i < 6; i++)
		{
			genes.Genes[i].SetPrevious((GrowableGenetics.GeneType)Get(data, i));
		}
	}

	public static string DecodeIntToGeneString(int data)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < 6; i++)
		{
			stringBuilder.Append(GrowableGene.GetColourCodedDisplayCharacter((GrowableGenetics.GeneType)Get(data, i)));
		}
		return stringBuilder.ToString();
	}

	private static int Set(int storage, int slot, int value)
	{
		int num = slot * 5;
		int num2 = 31 << num;
		return (storage & ~num2) | (value << num);
	}

	private static int Get(int storage, int slot)
	{
		int num = slot * 5;
		int num2 = 31 << num;
		return (storage & num2) >> num;
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Growable Gene Properties")]
public class GrowableGeneProperties : ScriptableObject
{
	[Serializable]
	public struct GeneWeight
	{
		public float BaseWeight;

		public float[] SlotWeights;

		public float CrossBreedingWeight;
	}

	[ArrayIndexIsEnum(enumType = typeof(GrowableGenetics.GeneType))]
	public GeneWeight[] Weights = new GeneWeight[5];
}


using System;

[Serializable]
public struct GeneWeight
{
	public float BaseWeight;

	public float[] SlotWeights;

	public float CrossBreedingWeight;
}


using System;
using System.Text;
using Facepunch;
using UnityEngine;

public class GrowableGenes
{
	public GrowableGene[] Genes;

	private static GrowableGenetics.GeneWeighting[] baseWeights = new GrowableGenetics.GeneWeighting[6];

	private static GrowableGenetics.GeneWeighting[] slotWeights = new GrowableGenetics.GeneWeighting[6];

	public GrowableGenes()
	{
		Clear();
	}

	private void Clear()
	{
		Genes = new GrowableGene[6];
		for (int i = 0; i < 6; i++)
		{
			Genes[i] = new GrowableGene();
		}
	}

	public void GenerateFavourableGenes(GrowableEntity growable, float geneChance = -1f)
	{
		if (!((Object)(object)growable == (Object)null) && !((Object)(object)growable.Properties.Genes == (Object)null))
		{
			CalculateBaseWeights(growable.Properties.Genes);
			for (int i = 0; i < 6; i++)
			{
				CalculateSlotWeights(growable.Properties.Genes, i);
				Genes[i].Set(PickFavourableGeneType(geneChance), firstSet: true);
			}
		}
	}

	public void GenerateRandom(GrowableEntity growable)
	{
		if (!((Object)(object)growable == (Object)null) && !((Object)(object)growable.Properties.Genes == (Object)null))
		{
			CalculateBaseWeights(growable.Properties.Genes);
			for (int i = 0; i < 6; i++)
			{
				CalculateSlotWeights(growable.Properties.Genes, i);
				Genes[i].Set(PickWeightedGeneType(), firstSet: true);
			}
		}
	}

	private void CalculateBaseWeights(GrowableGeneProperties properties)
	{
		int num = 0;
		GrowableGeneProperties.GeneWeight[] weights = properties.Weights;
		for (int i = 0; i < weights.Length; i++)
		{
			GrowableGeneProperties.GeneWeight geneWeight = weights[i];
			baseWeights[num].GeneType = (slotWeights[num].GeneType = (GrowableGenetics.GeneType)num);
			baseWeights[num].Weighting = geneWeight.BaseWeight;
			num++;
		}
	}

	private void CalculateSlotWeights(GrowableGeneProperties properties, int slot)
	{
		int num = 0;
		GrowableGeneProperties.GeneWeight[] weights = properties.Weights;
		for (int i = 0; i < weights.Length; i++)
		{
			GrowableGeneProperties.GeneWeight geneWeight = weights[i];
			slotWeights[num].Weighting = baseWeights[num].Weighting + geneWeight.SlotWeights[slot];
			num++;
		}
	}

	private GrowableGenetics.GeneType PickWeightedGeneType()
	{
		float num = 0f;
		GrowableGenetics.GeneWeighting[] array = slotWeights;
		for (int i = 0; i < array.Length; i++)
		{
			GrowableGenetics.GeneWeighting geneWeighting = array[i];
			num += geneWeighting.Weighting;
		}
		GrowableGenetics.GeneType result = GrowableGenetics.GeneType.Empty;
		float num2 = Random.Range(0f, num);
		float num3 = 0f;
		array = slotWeights;
		for (int i = 0; i < array.Length; i++)
		{
			GrowableGenetics.GeneWeighting geneWeighting2 = array[i];
			num3 += geneWeighting2.Weighting;
			if (num2 < num3)
			{
				result = geneWeighting2.GeneType;
				break;
			}
		}
		return result;
	}

	private GrowableGenetics.GeneType PickFavourableGeneType(float favourableGeneChance = -1f)
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		if (favourableGeneChance < 0f)
		{
			favourableGeneChance = PlanterBoxStatic.FavourableGeneChance;
		}
		BufferList<GrowableGenetics.GeneWeighting> val = Pool.Get<BufferList<GrowableGenetics.GeneWeighting>>();
		BufferList<GrowableGenetics.GeneWeighting> val2 = Pool.Get<BufferList<GrowableGenetics.GeneWeighting>>();
		float num = 0f;
		float num2 = 0f;
		GrowableGenetics.GeneWeighting[] array = slotWeights;
		for (int i = 0; i < array.Length; i++)
		{
			GrowableGenetics.GeneWeighting geneWeighting = array[i];
			if (GrowableGene.IsPositive(geneWeighting.GeneType))
			{
				val.Add(geneWeighting);
				num += geneWeighting.Weighting;
			}
			else
			{
				val2.Add(geneWeighting);
				num2 += geneWeighting.Weighting;
			}
		}
		float num3 = Mathx.RemapValClamped(Mathf.Clamp(favourableGeneChance, 0f, 1f), 0f, 1f, 1f, 0f);
		float num4 = num + num2 * num3;
		float num5 = Random.Range(0f, num4);
		float num6 = 0f;
		Enumerator<GrowableGenetics.GeneWeighting> enumerator = val.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				GrowableGenetics.GeneWeighting current = enumerator.Current;
				num6 += current.Weighting;
				if (num5 < num6)
				{
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val);
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val2);
					return current.GeneType;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = val2.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				GrowableGenetics.GeneWeighting current2 = enumerator.Current;
				num6 += current2.Weighting * num3;
				if (num5 < num6)
				{
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val);
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val2);
					return current2.GeneType;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val);
		Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val2);
		return GrowableGenetics.GeneType.Empty;
	}

	public int GetGeneTypeCount(GrowableGenetics.GeneType geneType)
	{
		int num = 0;
		GrowableGene[] genes = Genes;
		for (int i = 0; i < genes.Length; i++)
		{
			if (genes[i].Type == geneType)
			{
				num++;
			}
		}
		return num;
	}

	public int GetPositiveGeneCount()
	{
		int num = 0;
		GrowableGene[] genes = Genes;
		for (int i = 0; i < genes.Length; i++)
		{
			if (genes[i].IsPositive())
			{
				num++;
			}
		}
		return num;
	}

	public int GetNegativeGeneCount()
	{
		int num = 0;
		GrowableGene[] genes = Genes;
		for (int i = 0; i < genes.Length; i++)
		{
			if (!genes[i].IsPositive())
			{
				num++;
			}
		}
		return num;
	}

	public void Save(BaseNetworkable.SaveInfo info)
	{
		info.msg.growableEntity.genes = GrowableGeneEncoding.EncodeGenesToInt(this);
		info.msg.growableEntity.previousGenes = GrowableGeneEncoding.EncodePreviousGenesToInt(this);
	}

	public void Load(BaseNetworkable.LoadInfo info)
	{
		if (info.msg.growableEntity != null)
		{
			GrowableGeneEncoding.DecodeIntToGenes(info.msg.growableEntity.genes, this);
			GrowableGeneEncoding.DecodeIntToPreviousGenes(info.msg.growableEntity.previousGenes, this);
		}
	}

	public void DebugPrint()
	{
		Debug.Log((object)GetDisplayString(previousGenes: false));
	}

	private string GetDisplayString(bool previousGenes)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < 6; i++)
		{
			stringBuilder.Append(GrowableGene.GetDisplayCharacter(previousGenes ? Genes[i].PreviousType : Genes[i].Type));
		}
		return stringBuilder.ToString();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class GrowableGenetics
{
	public enum GeneType
	{
		Empty,
		WaterRequirement,
		GrowthSpeed,
		Yield,
		Hardiness
	}

	public struct GeneWeighting
	{
		public float Weighting;

		public GeneType GeneType;
	}

	public const int GeneSlotCount = 6;

	public const float CrossBreedingRadius = 1.5f;

	private static GeneWeighting[] neighbourWeights = new GeneWeighting[Enum.GetValues(typeof(GeneType)).Length];

	private static GeneWeighting dominant = default(GeneWeighting);

	public static void CrossBreed(GrowableEntity growable)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
		Vis.Entities(((Component)growable).transform.position, 1.5f, list, 524288, (QueryTriggerInteraction)2);
		bool flag = false;
		for (int i = 0; i < 6; i++)
		{
			GrowableGene growableGene = growable.Genes.Genes[i];
			GeneWeighting dominantGeneWeighting = GetDominantGeneWeighting(growable, list, i);
			if (dominantGeneWeighting.Weighting > growable.Properties.Genes.Weights[(int)growableGene.Type].CrossBreedingWeight)
			{
				flag = true;
				growableGene.Set(dominantGeneWeighting.GeneType);
			}
		}
		if (flag)
		{
			growable.SendNetworkUpdate();
		}
	}

	private static GeneWeighting GetDominantGeneWeighting(GrowableEntity crossBreedingGrowable, List<GrowableEntity> neighbours, int slot)
	{
		PlanterBox planter = crossBreedingGrowable.GetPlanter();
		if ((Object)(object)planter == (Object)null)
		{
			dominant.Weighting = -1f;
			return dominant;
		}
		for (int i = 0; i < neighbourWeights.Length; i++)
		{
			neighbourWeights[i].Weighting = 0f;
			neighbourWeights[i].GeneType = (GeneType)i;
		}
		dominant.Weighting = 0f;
		foreach (GrowableEntity neighbour in neighbours)
		{
			if (!neighbour.isServer)
			{
				continue;
			}
			PlanterBox planter2 = neighbour.GetPlanter();
			if (!((Object)(object)planter2 == (Object)null) && !((Object)(object)planter2 != (Object)(object)planter) && !((Object)(object)neighbour == (Object)(object)crossBreedingGrowable) && neighbour.prefabID == crossBreedingGrowable.prefabID && !neighbour.IsDead())
			{
				GeneType type = neighbour.Genes.Genes[slot].Type;
				float crossBreedingWeight = neighbour.Properties.Genes.Weights[(int)type].CrossBreedingWeight;
				float num = (neighbourWeights[(int)type].Weighting += crossBreedingWeight);
				if (num > dominant.Weighting)
				{
					dominant.Weighting = num;
					dominant.GeneType = type;
				}
			}
		}
		return dominant;
	}
}


public enum GeneType
{
	Empty,
	WaterRequirement,
	GrowthSpeed,
	Yield,
	Hardiness
}


public struct GeneWeighting
{
	public float Weighting;

	public GeneType GeneType;
}


using UnityEngine;

public interface IItemContainerEntity : IIdealSlotEntity, ILootableEntity, IInventoryProvider
{
	ItemContainer inventory { get; }

	Transform Transform { get; }

	bool DropsLoot { get; }

	float DestroyLootPercent { get; }

	bool DropFloats { get; }

	void DropItems(BaseEntity initiator = null);

	bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true);

	bool ShouldDropItemsIndividually();

	void DropBonusItems(BaseEntity initiator, ItemContainer container);

	Vector3 GetDropPosition();
}


using System.Collections.Generic;

public interface IInventoryProvider
{
	void GetAllInventories(List<ItemContainer> list);
}


public interface IIdealSlotEntity
{
	int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);

	ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifiers);
}


public interface ILootableEntity
{
	ulong LastLootedBy { get; set; }

	BasePlayer LastLootedByPlayer { get; set; }
}


using Rust.Instruments;
using UnityEngine;

public class InstrumentDebugInput : MonoBehaviour
{
	public InstrumentKeyController KeyController;

	public InstrumentKeyController.KeySet Note = new InstrumentKeyController.KeySet
	{
		Note = Notes.A,
		NoteType = InstrumentKeyController.NoteType.Regular,
		OctaveShift = 3
	};

	public float Frequency = 0.75f;

	public float StopAfter = 0.1f;

	public SoundDefinition OverrideDefinition;
}


using UnityEngine;

public class InstrumentIKController : MonoBehaviour
{
	public Vector3 HitRotationVector = Vector3.forward;

	public Transform[] LeftHandIkTargets = (Transform[])(object)new Transform[0];

	public Transform[] LeftHandIKTargetHitRotations = (Transform[])(object)new Transform[0];

	public Transform[] RightHandIkTargets = (Transform[])(object)new Transform[0];

	public Transform[] RightHandIKTargetHitRotations = (Transform[])(object)new Transform[0];

	public Transform[] RightFootIkTargets = (Transform[])(object)new Transform[0];

	public AnimationCurve HandHeightCurve = AnimationCurve.Constant(0f, 1f, 0f);

	public float HandHeightMultiplier = 1f;

	public float HandMoveLerpSpeed = 50f;

	public bool DebugHitRotation;

	public AnimationCurve HandHitCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float NoteHitTime = 0.5f;

	[Header("Look IK")]
	public float BodyLookWeight;

	public float HeadLookWeight;

	public float LookWeightLimit;

	public bool HoldHandsAtPlay;
}


using UnityEngine;

public class InstrumentIKTargetAttribute : PropertyAttribute
{
}


using System;
using System.Runtime.InteropServices;
using Rust.Instruments;
using UnityEngine;

public class InstrumentKeyController : MonoBehaviour
{
	public enum IKType
	{
		LeftHand,
		RightHand,
		RightFoot
	}

	public enum NoteType
	{
		Regular,
		Sharp
	}

	public enum InstrumentType
	{
		Note,
		Hold
	}

	public enum AnimationSlot
	{
		None,
		One,
		Two,
		Three,
		Four,
		Five,
		Six,
		Seven
	}

	[Serializable]
	public struct KeySet
	{
		public Notes Note;

		public NoteType NoteType;

		public int OctaveShift;

		public override string ToString()
		{
			return string.Format("{0}{1}{2}", Note, (NoteType == NoteType.Sharp) ? "#" : string.Empty, OctaveShift);
		}
	}

	public struct NoteOverride
	{
		public bool Override;

		public KeySet Note;
	}

	[Serializable]
	public struct IKNoteTarget
	{
		public IKType TargetType;

		public int IkIndex;
	}

	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct NoteBinding
	{
	}

	public const float DEFAULT_NOTE_VELOCITY = 1f;

	public NoteBindingCollection Bindings;

	public NoteBinding[] NoteBindings = new NoteBinding[0];

	public Transform[] NoteSoundPositions;

	public InstrumentIKController IKController;

	public Transform LeftHandProp;

	public Transform RightHandProp;

	public Animator InstrumentAnimator;

	public BaseEntity RPCHandler;

	public uint overrideAchievementId;

	private const string ALL_NOTES_STATNAME = "played_notes";

	public bool PlayedNoteThisFrame { get; private set; }

	public void ProcessServerPlayedNote(BasePlayer forPlayer)
	{
		if (!((Object)(object)forPlayer == (Object)null))
		{
			forPlayer.stats.Add(Bindings.NotePlayedStatName, 1, (Stats)5);
			forPlayer.stats.Add("played_notes", 1, (Stats)5);
		}
	}
}


public enum IKType
{
	LeftHand,
	RightHand,
	RightFoot
}


public enum NoteType
{
	Regular,
	Sharp
}


public enum InstrumentType
{
	Note,
	Hold
}


public enum AnimationSlot
{
	None,
	One,
	Two,
	Three,
	Four,
	Five,
	Six,
	Seven
}


using System;
using Rust.Instruments;

[Serializable]
public struct KeySet
{
	public Notes Note;

	public NoteType NoteType;

	public int OctaveShift;

	public override string ToString()
	{
		return string.Format("{0}{1}{2}", Note, (NoteType == NoteType.Sharp) ? "#" : string.Empty, OctaveShift);
	}
}


public struct NoteOverride
{
	public bool Override;

	public KeySet Note;
}


using System;

[Serializable]
public struct IKNoteTarget
{
	public IKType TargetType;

	public int IkIndex;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct NoteBinding
{
}


using System;
using Rust.Instruments;
using UnityEngine;

[CreateAssetMenu]
public class NoteBindingCollection : ScriptableObject
{
	[Serializable]
	public struct NoteData
	{
		public SoundDefinition NoteSound;

		public SoundDefinition NoteStartSound;

		public Notes Note;

		public InstrumentKeyController.NoteType Type;

		public int MidiNoteNumber;

		public int NoteOctave;

		[InstrumentIKTarget]
		public InstrumentKeyController.IKNoteTarget NoteIKTarget;

		public InstrumentKeyController.AnimationSlot AnimationSlot;

		public int NoteSoundPositionTarget;

		public int[] AdditionalMidiTargets;

		public float PitchOffset;

		public bool MatchMidiCode(int code)
		{
			if (MidiNoteNumber == code)
			{
				return true;
			}
			if (AdditionalMidiTargets != null)
			{
				int[] additionalMidiTargets = AdditionalMidiTargets;
				for (int i = 0; i < additionalMidiTargets.Length; i++)
				{
					if (additionalMidiTargets[i] == code)
					{
						return true;
					}
				}
			}
			return false;
		}

		public string ToNoteString()
		{
			return string.Format("{0}{1}{2}", Note, (Type == InstrumentKeyController.NoteType.Sharp) ? "#" : string.Empty, NoteOctave);
		}
	}

	public NoteData[] BaseBindings;

	public float MinimumNoteTime;

	public float MaximumNoteLength;

	public bool AllowAutoplay = true;

	public float AutoplayLoopDelay = 0.25f;

	public string NotePlayedStatName;

	public string KeyMidiMapShortname = "";

	public bool AllowSustain;

	public bool AllowFullKeyboardInput = true;

	public string InstrumentShortName = "";

	public InstrumentKeyController.InstrumentType NotePlayType;

	public int MaxConcurrentNotes = 3;

	public bool LoopSounds;

	public float SoundFadeInTime;

	public float minimumSoundFadeOutTime = 0.1f;

	public InstrumentKeyController.KeySet PrimaryClickNote;

	public InstrumentKeyController.KeySet SecondaryClickNote = new InstrumentKeyController.KeySet
	{
		Note = Notes.B
	};

	public bool RunInstrumentAnimationController;

	public bool PlayRepeatAnimations = true;

	public float AnimationDeadTime = 1f;

	public float AnimationResetDelay;

	public float RecentlyPlayedThreshold = 1f;

	[Range(0f, 1f)]
	public float CrossfadeNormalizedAnimationTarget;

	public float AnimationCrossfadeDuration = 0.15f;

	public float CrossfadePlayerSpeedMulti = 1f;

	public int DefaultOctave;

	public int ShiftedOctave = 1;

	public bool UseClosestMidiNote = true;

	private const float MidiNoteUpOctaveShift = 2f;

	private const float MidiNoteDownOctaveShift = 0.1f;

	public bool FindNoteData(Notes note, int octave, InstrumentKeyController.NoteType type, out NoteData data, out int noteIndex)
	{
		for (int i = 0; i < BaseBindings.Length; i++)
		{
			NoteData noteData = BaseBindings[i];
			if (noteData.Note == note && noteData.Type == type && noteData.NoteOctave == octave)
			{
				data = noteData;
				noteIndex = i;
				return true;
			}
		}
		data = default(NoteData);
		noteIndex = -1;
		return false;
	}

	public bool FindNoteDataIndex(Notes note, int octave, InstrumentKeyController.NoteType type, out int noteIndex)
	{
		for (int i = 0; i < BaseBindings.Length; i++)
		{
			NoteData noteData = BaseBindings[i];
			if (noteData.Note == note && noteData.Type == type && noteData.NoteOctave == octave)
			{
				noteIndex = i;
				return true;
			}
		}
		noteIndex = -1;
		return false;
	}

	public NoteData CreateMidiBinding(NoteData basedOn, int octave, int midiCode)
	{
		NoteData result = basedOn;
		result.NoteOctave = octave;
		result.MidiNoteNumber = midiCode;
		int num = octave - basedOn.NoteOctave;
		if (octave > basedOn.NoteOctave)
		{
			result.PitchOffset = (float)num * 2f;
		}
		else
		{
			result.PitchOffset = 1f - Mathf.Abs((float)num * 0.1f);
		}
		return result;
	}
}


using System;
using Rust.Instruments;

[Serializable]
public struct NoteData
{
	public SoundDefinition NoteSound;

	public SoundDefinition NoteStartSound;

	public Notes Note;

	public InstrumentKeyController.NoteType Type;

	public int MidiNoteNumber;

	public int NoteOctave;

	[InstrumentIKTarget]
	public InstrumentKeyController.IKNoteTarget NoteIKTarget;

	public InstrumentKeyController.AnimationSlot AnimationSlot;

	public int NoteSoundPositionTarget;

	public int[] AdditionalMidiTargets;

	public float PitchOffset;

	public bool MatchMidiCode(int code)
	{
		if (MidiNoteNumber == code)
		{
			return true;
		}
		if (AdditionalMidiTargets != null)
		{
			int[] additionalMidiTargets = AdditionalMidiTargets;
			for (int i = 0; i < additionalMidiTargets.Length; i++)
			{
				if (additionalMidiTargets[i] == code)
				{
					return true;
				}
			}
		}
		return false;
	}

	public string ToNoteString()
	{
		return string.Format("{0}{1}{2}", Note, (Type == InstrumentKeyController.NoteType.Sharp) ? "#" : string.Empty, NoteOctave);
	}
}


using System;
using UnityEngine;

[Serializable]
public class LODGroupRenderers
{
	public LODGroup lodGroup;

	public Renderer[] renderers;

	public void SetRenderersEnabled(bool enabled)
	{
		Renderer[] array = renderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = enabled;
		}
	}
}


public static class BaseMetabolism
{
	public const float targetHeartRate = 0.05f;
}


using System;
using ConVar;
using Rust;
using UnityEngine;

public abstract class BaseMetabolism<T> : EntityComponent<T> where T : BaseCombatEntity
{
	protected T owner;

	public MetabolismAttribute calories = new MetabolismAttribute();

	public MetabolismAttribute hydration = new MetabolismAttribute();

	public MetabolismAttribute heartrate = new MetabolismAttribute();

	protected float timeSinceLastMetabolism;

	public virtual void Reset()
	{
		calories.Reset();
		hydration.Reset();
		heartrate.Reset();
	}

	protected virtual void OnDisable()
	{
		if (!Application.isQuitting)
		{
			owner = null;
		}
	}

	public virtual void ServerInit(T owner)
	{
		Reset();
		this.owner = owner;
	}

	public virtual void ServerUpdate(BaseCombatEntity ownerEntity, float delta)
	{
		timeSinceLastMetabolism += delta;
		if (!(timeSinceLastMetabolism <= ConVar.Server.metabolismtick))
		{
			if (Object.op_Implicit((Object)(object)owner) && !owner.IsDead())
			{
				RunMetabolism(ownerEntity, timeSinceLastMetabolism);
				DoMetabolismDamage(ownerEntity, timeSinceLastMetabolism);
			}
			timeSinceLastMetabolism = 0f;
		}
	}

	protected virtual void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta)
	{
		if (calories.value <= 20f)
		{
			TimeWarning val = TimeWarning.New("Calories Hurt", 0);
			try
			{
				ownerEntity.Hurt(Mathf.InverseLerp(20f, 0f, calories.value) * delta * (1f / 12f), DamageType.Hunger);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (hydration.value <= 20f)
		{
			TimeWarning val = TimeWarning.New("Hyration Hurt", 0);
			try
			{
				ownerEntity.Hurt(Mathf.InverseLerp(20f, 0f, hydration.value) * delta * (2f / 15f), DamageType.Thirst);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	protected virtual void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
	{
		if (calories.value > 200f)
		{
			ownerEntity.Heal(Mathf.InverseLerp(200f, 1000f, calories.value) * delta * (1f / 60f));
		}
		if (hydration.value > 200f)
		{
			ownerEntity.Heal(Mathf.InverseLerp(200f, 1000f, hydration.value) * delta * (1f / 60f));
		}
		hydration.MoveTowards(0f, delta * (1f / 120f));
		calories.MoveTowards(0f, delta * (1f / 60f));
		heartrate.MoveTowards(0.05f, delta * (1f / 60f));
	}

	public virtual void ApplyChange(MetabolismAttribute.Type type, float amount, float time)
	{
		FindAttribute(type)?.Add(amount);
	}

	public bool ShouldDie()
	{
		if (Object.op_Implicit((Object)(object)owner))
		{
			return owner.Health() <= 0f;
		}
		return false;
	}

	public virtual MetabolismAttribute FindAttribute(MetabolismAttribute.Type type)
	{
		return type switch
		{
			MetabolismAttribute.Type.Calories => calories, 
			MetabolismAttribute.Type.Hydration => hydration, 
			MetabolismAttribute.Type.Heartrate => heartrate, 
			_ => null, 
		};
	}
}


using System;
using UnityEngine;

[Serializable]
public class MetabolismAttribute
{
	public enum Type
	{
		Calories,
		Hydration,
		Heartrate,
		Poison,
		Radiation,
		Bleeding,
		Health,
		HealthOverTime
	}

	public float startMin;

	public float startMax;

	public float min;

	public float max;

	public float value;

	public float lastValue;

	internal float lastGreatFraction;

	private const float greatInterval = 0.1f;

	public float greatFraction => Mathf.Floor(Fraction() / 0.1f) / 10f;

	public void Reset()
	{
		value = Mathf.Clamp(Random.Range(startMin, startMax), min, max);
	}

	public float Fraction()
	{
		return Mathf.InverseLerp(min, max, value);
	}

	public float InverseFraction()
	{
		return 1f - Fraction();
	}

	public void Add(float val)
	{
		value = Mathf.Clamp(value + val, min, max);
	}

	public void Subtract(float val)
	{
		value = Mathf.Clamp(value - val, min, max);
	}

	public void Set(float val)
	{
		value = Mathf.Clamp(val, min, max);
	}

	public void Increase(float fTarget)
	{
		fTarget = Mathf.Clamp(fTarget, min, max);
		if (!(fTarget <= value))
		{
			value = fTarget;
		}
	}

	public void MoveTowards(float fTarget, float fRate)
	{
		if (fRate != 0f)
		{
			value = Mathf.Clamp(Mathf.MoveTowards(value, fTarget, fRate), min, max);
		}
	}

	public bool HasChanged()
	{
		bool result = lastValue != value;
		lastValue = value;
		return result;
	}

	public bool HasGreatlyChanged()
	{
		float num = greatFraction;
		bool result = lastGreatFraction != num;
		lastGreatFraction = num;
		return result;
	}

	public void SetValue(float newValue)
	{
		value = newValue;
	}
}


public enum Type
{
	Calories,
	Hydration,
	Heartrate,
	Poison,
	Radiation,
	Bleeding,
	Health,
	HealthOverTime
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BaseResourceExtractor : BaseCombatEntity
{
	public bool canExtractLiquid;

	public bool canExtractSolid = true;

	public override void ServerInit()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (base.isClient)
		{
			return;
		}
		List<SurveyCrater> list = Pool.Get<List<SurveyCrater>>();
		Vis.Entities(((Component)this).transform.position, 3f, list, 1, (QueryTriggerInteraction)2);
		foreach (SurveyCrater item in list)
		{
			if (item.isServer)
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<SurveyCrater>(ref list);
	}
}


using System;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class MiningQuarry : BaseResourceExtractor
{
	[Serializable]
	public enum QuarryType
	{
		None,
		Basic,
		Sulfur,
		HQM
	}

	[Serializable]
	public class ChildPrefab
	{
		public GameObjectRef prefabToSpawn;

		public GameObject origin;

		public BaseEntity instance;

		public void DoSpawn(MiningQuarry owner)
		{
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			if (prefabToSpawn.isValid)
			{
				instance = GameManager.server.CreateEntity(prefabToSpawn.resourcePath, origin.transform.localPosition, origin.transform.localRotation);
				instance.SetParent(owner);
				instance.Spawn();
			}
		}
	}

	public Animator beltAnimator;

	public Renderer beltScrollRenderer;

	public int scrollMatIndex = 3;

	public float animatorSpeedChange = 1f;

	public float beltScrollSpeedMultiplier = 1f;

	public SoundPlayer[] onSounds;

	public float processRate = 5f;

	public float workToAdd = 15f;

	public float workPerFuel = 1000f;

	public float pendingWork;

	public GameObjectRef bucketDropEffect;

	public GameObject bucketDropTransform;

	public ChildPrefab engineSwitchPrefab;

	public ChildPrefab hopperPrefab;

	public ChildPrefab fuelStoragePrefab;

	public QuarryType staticType;

	public bool isStatic;

	public ResourceDepositManager.ResourceDeposit _linkedDeposit;

	public bool IsEngineOn()
	{
		return HasFlag(Flags.On);
	}

	public void SetOn(bool isOn)
	{
		SetFlag(Flags.On, isOn);
		engineSwitchPrefab.instance.SetFlag(Flags.On, isOn);
		SendNetworkUpdate();
		engineSwitchPrefab.instance.SendNetworkUpdate();
		if (isOn)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessResources, processRate, processRate);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ProcessResources);
		}
	}

	public void EngineSwitch(bool isOn)
	{
		if (isOn && FuelCheck())
		{
			SetOn(isOn: true);
		}
		else
		{
			SetOn(isOn: false);
		}
	}

	public override void ServerInit()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (isStatic)
		{
			UpdateStaticDeposit();
		}
		else
		{
			ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(((Component)this).transform.position);
			_linkedDeposit = orCreate;
		}
		SpawnChildEntities();
		engineSwitchPrefab.instance.SetFlag(Flags.On, HasFlag(Flags.On));
		if (base.isServer)
		{
			ItemContainer inventory = ((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory;
			inventory.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(inventory.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
		}
	}

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		return item.info.shortname == "diesel_barrel";
	}

	public void UpdateStaticDeposit()
	{
		if (isStatic)
		{
			if (_linkedDeposit == null)
			{
				_linkedDeposit = new ResourceDepositManager.ResourceDeposit();
			}
			else
			{
				_linkedDeposit._resources.Clear();
			}
			if (staticType == QuarryType.None)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 1000, 0.3f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, 1000, 5f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, 1000, 7.5f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, 1000, 75f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			else if (staticType == QuarryType.Basic)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, 1000, 1f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 1000, 0.2f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			else if (staticType == QuarryType.Sulfur)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, 1000, 1f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			else if (staticType == QuarryType.HQM)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, 1000, 20f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			_linkedDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, 1000, 16.666666f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, liquid: true);
			_linkedDeposit.Add(ItemManager.FindItemDefinition("lowgradefuel"), 1f, 1000, 5.882353f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, liquid: true);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		EngineSwitch(HasFlag(Flags.On));
		UpdateStaticDeposit();
	}

	public void SpawnChildEntities()
	{
		engineSwitchPrefab.DoSpawn(this);
		hopperPrefab.DoSpawn(this);
		fuelStoragePrefab.DoSpawn(this);
	}

	public void ProcessResources()
	{
		if (_linkedDeposit == null || (Object)(object)hopperPrefab.instance == (Object)null)
		{
			return;
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
		float num = Mathf.Min(workToAdd, pendingWork);
		pendingWork -= num;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			float workNeeded = resource.workNeeded;
			int num2 = Mathf.FloorToInt(resource.workDone / workNeeded);
			resource.workDone += num;
			int num3 = Mathf.FloorToInt(resource.workDone / workNeeded);
			if (resource.workDone > workNeeded)
			{
				resource.workDone %= workNeeded;
			}
			if (num2 != num3)
			{
				int iAmount = num3 - num2;
				Item item = ItemManager.Create(resource.type, iAmount, 0uL);
				Analytics.Azure.OnQuarryItem(Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);
				if (Interface.CallHook("OnQuarryGather", (object)this, (object)item) != null)
				{
					item.Remove();
				}
				else if (!item.MoveToContainer(((Component)hopperPrefab.instance).GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
	}

	public bool FuelCheck()
	{
		if (pendingWork > 0f)
		{
			return true;
		}
		Item item = ((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory.FindItemByItemName("diesel_barrel");
		object obj = Interface.CallHook("OnQuarryConsumeFuel", (object)this, (object)item);
		if (obj is Item)
		{
			item = (Item)obj;
		}
		if (item != null && item.amount >= 1)
		{
			pendingWork += workPerFuel;
			Analytics.Azure.OnQuarryItem(Analytics.Azure.ResourceMode.Consumed, item.info.shortname, 1, this);
			item.UseItem();
			return true;
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if ((Object)(object)fuelStoragePrefab.instance == (Object)null || (Object)(object)hopperPrefab.instance == (Object)null)
			{
				Debug.Log((object)"Cannot save mining quary because children were null");
				return;
			}
			info.msg.miningQuarry = Pool.Get<MiningQuarry>();
			info.msg.miningQuarry.extractor = Pool.Get<ResourceExtractor>();
			info.msg.miningQuarry.extractor.fuelContents = ((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory.Save();
			info.msg.miningQuarry.extractor.outputContents = ((Component)hopperPrefab.instance).GetComponent<StorageContainer>().inventory.Save();
			info.msg.miningQuarry.staticType = (int)staticType;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && info.msg.miningQuarry != null)
		{
			if ((Object)(object)fuelStoragePrefab.instance == (Object)null || (Object)(object)hopperPrefab.instance == (Object)null)
			{
				Debug.Log((object)"Cannot load mining quary because children were null");
				return;
			}
			((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory.Load(info.msg.miningQuarry.extractor.fuelContents);
			((Component)hopperPrefab.instance).GetComponent<StorageContainer>().inventory.Load(info.msg.miningQuarry.extractor.outputContents);
			staticType = (QuarryType)info.msg.miningQuarry.staticType;
		}
	}
}


using System;

[Serializable]
public enum QuarryType
{
	None,
	Basic,
	Sulfur,
	HQM
}


using System;
using UnityEngine;

[Serializable]
public class ChildPrefab
{
	public GameObjectRef prefabToSpawn;

	public GameObject origin;

	public BaseEntity instance;

	public void DoSpawn(MiningQuarry owner)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (prefabToSpawn.isValid)
		{
			instance = GameManager.server.CreateEntity(prefabToSpawn.resourcePath, origin.transform.localPosition, origin.transform.localRotation);
			instance.SetParent(owner);
			instance.Spawn();
		}
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class ResourceDepositManager : BaseEntity
{
	[Serializable]
	public class ResourceDeposit
	{
		[Serializable]
		public enum surveySpawnType
		{
			ITEM,
			OIL,
			WATER
		}

		[Serializable]
		public class ResourceDepositEntry
		{
			public ItemDefinition type;

			public float efficiency = 1f;

			public int amount;

			public int startAmount;

			public float workNeeded = 1f;

			public float workDone;

			public surveySpawnType spawnType;

			public bool isLiquid;

			public void Subtract(int subamount)
			{
				if (subamount > 0)
				{
					amount -= subamount;
					if (amount < 0)
					{
						amount = 0;
					}
				}
			}
		}

		public float lastSurveyTime = float.NegativeInfinity;

		public Vector3 origin;

		public List<ResourceDepositEntry> _resources;

		public ResourceDeposit()
		{
			_resources = new List<ResourceDepositEntry>();
		}

		public void Add(ItemDefinition type, float efficiency, int amount, float workNeeded, surveySpawnType spawnType, bool liquid = false)
		{
			ResourceDepositEntry resourceDepositEntry = new ResourceDepositEntry();
			resourceDepositEntry.type = type;
			resourceDepositEntry.efficiency = efficiency;
			resourceDepositEntry.startAmount = (resourceDepositEntry.amount = amount);
			resourceDepositEntry.spawnType = spawnType;
			resourceDepositEntry.workNeeded = workNeeded;
			resourceDepositEntry.isLiquid = liquid;
			_resources.Add(resourceDepositEntry);
		}
	}

	public static ResourceDepositManager _manager;

	private const int resolution = 20;

	public Dictionary<Vector2i, ResourceDeposit> _deposits;

	public static Vector2i GetIndexFrom(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i((int)pos.x / 20, (int)pos.z / 20);
	}

	public static ResourceDepositManager Get()
	{
		return _manager;
	}

	public ResourceDepositManager()
	{
		_manager = this;
		_deposits = new Dictionary<Vector2i, ResourceDeposit>();
	}

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		Vector2i indexFrom = GetIndexFrom(pos);
		State state = Random.state;
		Random.InitState((int)SeedEx.Seed(new Vector2((float)indexFrom.x, (float)indexFrom.y), World.Seed + World.Salt));
		ResourceDeposit resourceDeposit = new ResourceDeposit
		{
			origin = new Vector3((float)(indexFrom.x * 20), 0f, (float)(indexFrom.y * 20))
		};
		if (Random.Range(0f, 1f) < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else
		{
			bool flag = false;
			float num = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f)
				{
					num += 0.25f;
				}
			}
			else
			{
				num += 0.15f;
			}
			if (Random.Range(0f, 1f) >= 1f - num)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, Random.Range(5000, 10000), Random.Range(8f, 10f), ResourceDeposit.surveySpawnType.ITEM, liquid: true);
				flag = true;
			}
			if (!flag)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, Random.Range(30000, 100000), Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
				float num2 = 0f;
				num2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f) ? 1f : 0f) * 0.25f));
				if (Random.Range(0f, 1f) >= 1f - num2)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, Random.Range(10000, 100000), Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num3 = 0f;
				num3 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f) ? 1f : 0f) * (0.25f + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));
				if (Random.Range(0f, 1f) >= 1f - num3)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, Random.Range(10000, 100000), Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num4 = 0f;
				if (World.Procedural)
				{
					if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
					{
						num4 += 0.25f;
					}
				}
				else
				{
					num4 += 0.15f;
				}
				if (Random.Range(0f, 1f) >= 1f - num4)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, Random.Range(5000, 10000), Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
				}
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", (object)resourceDeposit);
		Random.state = state;
		return resourceDeposit;
	}

	public ResourceDeposit GetFromPosition(Vector3 pos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		ResourceDeposit value = null;
		if (_deposits.TryGetValue(GetIndexFrom(pos), out value))
		{
			return value;
		}
		return null;
	}

	public static ResourceDeposit GetOrCreate(Vector3 pos)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		ResourceDeposit fromPosition = Get().GetFromPosition(pos);
		if (fromPosition != null)
		{
			return fromPosition;
		}
		return Get().CreateFromPosition(pos);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class ResourceDeposit
{
	[Serializable]
	public enum surveySpawnType
	{
		ITEM,
		OIL,
		WATER
	}

	[Serializable]
	public class ResourceDepositEntry
	{
		public ItemDefinition type;

		public float efficiency = 1f;

		public int amount;

		public int startAmount;

		public float workNeeded = 1f;

		public float workDone;

		public surveySpawnType spawnType;

		public bool isLiquid;

		public void Subtract(int subamount)
		{
			if (subamount > 0)
			{
				amount -= subamount;
				if (amount < 0)
				{
					amount = 0;
				}
			}
		}
	}

	public float lastSurveyTime = float.NegativeInfinity;

	public Vector3 origin;

	public List<ResourceDepositEntry> _resources;

	public ResourceDeposit()
	{
		_resources = new List<ResourceDepositEntry>();
	}

	public void Add(ItemDefinition type, float efficiency, int amount, float workNeeded, surveySpawnType spawnType, bool liquid = false)
	{
		ResourceDepositEntry resourceDepositEntry = new ResourceDepositEntry();
		resourceDepositEntry.type = type;
		resourceDepositEntry.efficiency = efficiency;
		resourceDepositEntry.startAmount = (resourceDepositEntry.amount = amount);
		resourceDepositEntry.spawnType = spawnType;
		resourceDepositEntry.workNeeded = workNeeded;
		resourceDepositEntry.isLiquid = liquid;
		_resources.Add(resourceDepositEntry);
	}
}


using System;

[Serializable]
public enum surveySpawnType
{
	ITEM,
	OIL,
	WATER
}


using System;

[Serializable]
public class ResourceDepositEntry
{
	public ItemDefinition type;

	public float efficiency = 1f;

	public int amount;

	public int startAmount;

	public float workNeeded = 1f;

	public float workDone;

	public surveySpawnType spawnType;

	public bool isLiquid;

	public void Subtract(int subamount)
	{
		if (subamount > 0)
		{
			amount -= subamount;
			if (amount < 0)
			{
				amount = 0;
			}
		}
	}
}


public class ResourceExtractorFuelStorage : StorageContainer
{
}


using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using UnityEngine;

public class SurveyCharge : TimedExplosive
{
	public GameObjectRef craterPrefab;

	public GameObjectRef craterPrefab_Oil;

	public override void Explode()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		base.Explode();
		if (WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: true, this))
		{
			return;
		}
		ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(((Component)this).transform.position);
		if (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)
		{
			return;
		}
		orCreate.lastSurveyTime = Time.realtimeSinceStartup;
		if (!TransformUtil.GetGroundInfo(((Component)this).transform.position, out var hitOut, 0.3f, LayerMask.op_Implicit(8388608)))
		{
			return;
		}
		Vector3 point = ((RaycastHit)(ref hitOut)).point;
		_ = ((RaycastHit)(ref hitOut)).normal;
		List<SurveyCrater> list = Pool.Get<List<SurveyCrater>>();
		Vis.Entities(((Component)this).transform.position, 10f, list, 1, (QueryTriggerInteraction)2);
		bool num = list.Count > 0;
		Pool.FreeUnmanaged<SurveyCrater>(ref list);
		if (num)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)
		{
			if (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)
			{
				int num2 = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);
				int iAmount = 1;
				flag = true;
				if (resource.isLiquid)
				{
					flag2 = true;
				}
				for (int i = 0; i < num2; i++)
				{
					Item item = ItemManager.Create(resource.type, iAmount, 0uL);
					Interface.CallHook("OnSurveyGather", (object)this, (object)item);
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up);
					BaseEntity baseEntity = item.Drop(((Component)this).transform.position + Vector3.up * 1f, GetInheritedDropVelocity() + modifiedAimConeDirection * Random.Range(5f, 10f), Random.rotation);
					Quaternion rotation = Random.rotation;
					baseEntity.SetAngularVelocity(((Quaternion)(ref rotation)).eulerAngles * 5f);
				}
			}
		}
		if (flag)
		{
			string strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);
			if (Object.op_Implicit((Object)(object)baseEntity2))
			{
				baseEntity2.Spawn();
			}
		}
	}
}


using UnityEngine;

public class NPCAutoTurret : AutoTurret
{
	public Transform centerMuzzle;

	public Transform muzzleLeft;

	public Transform muzzleRight;

	public bool useSleeperHostile = true;

	private bool useLeftMuzzle;

	[ReplicatedVar(Help = "How many seconds until a sleeping player is considered hostile")]
	public static float sleeperhostiledelay = 1200f;

	private Matrix4x4 toCenterMuzzleFromPitch;

	public override void ServerInit()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		SetOnline();
		SetPeacekeepermode(isOn: true);
		toCenterMuzzleFromPitch = gun_pitch.worldToLocalMatrix * centerMuzzle.localToWorldMatrix;
	}

	public virtual bool HasAmmo()
	{
		return true;
	}

	public override bool CheckPeekers()
	{
		return false;
	}

	public override float TargetScanRate()
	{
		return 1.25f;
	}

	public override bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		return true;
	}

	public override float GetMaxAngleForEngagement()
	{
		return 15f;
	}

	public override bool HasFallbackWeapon()
	{
		return true;
	}

	public override Matrix4x4 GetCenterMuzzle()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			return base.GetCenterMuzzle() * toCenterMuzzleFromPitch;
		}
		return centerMuzzle.localToWorldMatrix;
	}

	public override void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse = null, BaseCombatEntity target = null)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		muzzleToUse = muzzleRight;
		base.FireGun(targetPos, aimCone, muzzleToUse, target);
	}

	public override bool Ignore(BasePlayer player)
	{
		if (!(player is ScientistNPC))
		{
			return player is BanditGuard;
		}
		return true;
	}

	public override bool IsEntityHostile(BaseCombatEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsNpc)
			{
				if (basePlayer is ScientistNPC || basePlayer is BanditGuard)
				{
					return false;
				}
				if (basePlayer is NPCShopKeeper)
				{
					return false;
				}
				if (basePlayer is BasePet)
				{
					return base.IsEntityHostile(basePlayer);
				}
				return true;
			}
			if (basePlayer.IsSleeping() && useSleeperHostile && basePlayer.secondsSleeping >= sleeperhostiledelay)
			{
				return true;
			}
		}
		return base.IsEntityHostile(ent);
	}
}


using UnityEngine;

public class TargetTrigger : TriggerBase
{
	[Tooltip("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
	public Transform losEyes;

	public override GameObject InterestedInObject(GameObject obj)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if ((Object)(object)losEyes != (Object)null && !baseEntity.IsVisible(((Component)losEyes).transform.position, baseEntity.CenterPoint()))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;

public class BirthdayBalloonHandler : MonoBehaviour, IClientComponent
{
	public float checkOffset = 1f;

	public float checkRadius = 0.5f;
}


using Facepunch.CardGames;
using UnityEngine;

public class BlackjackMachine : BaseCardGameEntity
{
	[SerializeField]
	[Header("Blackjack Machine")]
	private GameObjectRef mainScreenPrefab;

	[SerializeField]
	private GameObjectRef smallScreenPrefab;

	[SerializeField]
	private Transform mainScreenParent;

	[SerializeField]
	private Transform[] smallScreenParents;

	private static int _maxbet = 500;

	private BlackjackController controller;

	private BlackjackMainScreenUI mainScreenUI;

	private BlackjackSmallScreenUI[] smallScreenUIs = new BlackjackSmallScreenUI[3];

	[ServerVar(Help = "Maximum initial bet per round")]
	public static int maxbet
	{
		get
		{
			return _maxbet;
		}
		set
		{
			_maxbet = Mathf.Clamp(value, 25, 1000000);
		}
	}

	protected override float MaxStorageInteractionDist => 1f;

	public override void InitShared()
	{
		base.InitShared();
		controller = (BlackjackController)base.GameController;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	public override void PlayerStorageChanged()
	{
		base.PlayerStorageChanged();
		SendNetworkUpdate();
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CardGamePlayerStorage : StorageContainer
{
	private EntityRef cardTableRef;

	public BaseCardGameEntity GetCardGameEntity()
	{
		BaseEntity baseEntity = cardTableRef.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as BaseCardGameEntity;
		}
		return null;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.simpleUID != null)
		{
			cardTableRef.uid = info.msg.simpleUID.uid;
		}
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		BaseCardGameEntity cardGameEntity = GetCardGameEntity();
		if ((Object)(object)cardGameEntity != (Object)null)
		{
			cardGameEntity.PlayerStorageChanged();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.simpleUID = Pool.Get<SimpleUID>();
		info.msg.simpleUID.uid = cardTableRef.uid;
	}

	public void SetCardTable(BaseCardGameEntity cardGameEntity)
	{
		cardTableRef.Set(cardGameEntity);
	}
}


using System;
using UnityEngine;

public class CardGameSounds : PrefabAttribute
{
	public enum SoundType
	{
		Chips,
		Draw,
		Play,
		Shuffle,
		Win,
		YourTurn,
		Check,
		Hit,
		Stand,
		Bet,
		IncreaseBet,
		DecreaseBet,
		AllIn,
		UIInteract,
		DealerCool,
		DealerHappy,
		DealerLove,
		DealerSad,
		DealerShocked
	}

	public SoundDefinition ChipsSfx;

	public SoundDefinition DrawSfx;

	public SoundDefinition PlaySfx;

	public SoundDefinition ShuffleSfx;

	public SoundDefinition WinSfx;

	public SoundDefinition LoseSfx;

	public SoundDefinition YourTurnSfx;

	public SoundDefinition CheckSfx;

	public SoundDefinition HitSfx;

	public SoundDefinition StandSfx;

	public SoundDefinition BetSfx;

	public SoundDefinition IncreaseBetSfx;

	public SoundDefinition DecreaseBetSfx;

	public SoundDefinition AllInSfx;

	public SoundDefinition UIInteractSfx;

	[Header("Dealer Reactions")]
	public SoundDefinition DealerCoolSfx;

	public SoundDefinition DealerHappySfx;

	public SoundDefinition DealerLoveSfx;

	public SoundDefinition DealerSadSfx;

	public SoundDefinition DealerShockedSfx;

	protected override Type GetIndexedType()
	{
		return typeof(CardGameSounds);
	}

	public void PlaySound(SoundType sound, GameObject forGameObject)
	{
		switch (sound)
		{
		case SoundType.Chips:
			ChipsSfx.Play(forGameObject);
			break;
		case SoundType.Draw:
			DrawSfx.Play(forGameObject);
			break;
		case SoundType.Play:
			PlaySfx.Play(forGameObject);
			break;
		case SoundType.Shuffle:
			ShuffleSfx.Play(forGameObject);
			break;
		case SoundType.Win:
			WinSfx.Play(forGameObject);
			break;
		case SoundType.YourTurn:
			YourTurnSfx.Play(forGameObject);
			break;
		case SoundType.Check:
			CheckSfx.Play(forGameObject);
			break;
		case SoundType.Hit:
			HitSfx.Play(forGameObject);
			break;
		case SoundType.Stand:
			StandSfx.Play(forGameObject);
			break;
		case SoundType.Bet:
			BetSfx.Play(forGameObject);
			break;
		case SoundType.IncreaseBet:
			IncreaseBetSfx.Play(forGameObject);
			break;
		case SoundType.DecreaseBet:
			DecreaseBetSfx.Play(forGameObject);
			break;
		case SoundType.AllIn:
			AllInSfx.Play(forGameObject);
			break;
		case SoundType.UIInteract:
			UIInteractSfx.Play(forGameObject);
			break;
		case SoundType.DealerCool:
			DealerCoolSfx.Play(forGameObject);
			break;
		case SoundType.DealerHappy:
			DealerHappySfx.Play(forGameObject);
			break;
		case SoundType.DealerLove:
			DealerLoveSfx.Play(forGameObject);
			break;
		case SoundType.DealerSad:
			DealerSadSfx.Play(forGameObject);
			break;
		case SoundType.DealerShocked:
			DealerShockedSfx.Play(forGameObject);
			break;
		default:
			throw new ArgumentOutOfRangeException("sound", sound, null);
		}
	}
}


public enum SoundType
{
	Chips,
	Draw,
	Play,
	Shuffle,
	Win,
	YourTurn,
	Check,
	Hit,
	Stand,
	Bet,
	IncreaseBet,
	DecreaseBet,
	AllIn,
	UIInteract,
	DealerCool,
	DealerHappy,
	DealerLove,
	DealerSad,
	DealerShocked
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class CardTable : BaseCardGameEntity
{
	[Serializable]
	public class ChipStack : IComparable<ChipStack>
	{
		public int chipValue;

		public GameObject[] chips;

		public int CompareTo(ChipStack other)
		{
			if (other == null)
			{
				return 1;
			}
			return chipValue.CompareTo(other.chipValue);
		}
	}

	[Header("Card Table")]
	[SerializeField]
	private ViewModel viewModel;

	[SerializeField]
	private CardGameUI.PlayingCardImage[] tableCards;

	[SerializeField]
	private Renderer[] tableCardBackings;

	[SerializeField]
	private Canvas cardUICanvas;

	[SerializeField]
	private Image[] tableCardImages;

	[SerializeField]
	private Sprite blankCard;

	[SerializeField]
	private ChipStack[] chipStacks;

	[SerializeField]
	private ChipStack[] fillerStacks;

	protected override float MaxStorageInteractionDist => 1f;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ChipStack : IComparable<ChipStack>
{
	public int chipValue;

	public GameObject[] chips;

	public int CompareTo(ChipStack other)
	{
		if (other == null)
		{
			return 1;
		}
		return chipValue.CompareTo(other.chipValue);
	}
}


using UnityEngine;

public class CardTableSeat : BaseChair
{
	public Transform CardsMesh;
}


using UnityEngine;
using UnityEngine.UI;

public class PlayingCardsViewmodel : MonoBehaviour
{
	[SerializeField]
	private Canvas cardUICanvas;

	[SerializeField]
	private Image cardA;

	[SerializeField]
	private Image cardB;

	[SerializeField]
	private Sprite blankCard;
}


public class DecorDeployable : DecayEntity
{
}


using ConVar;
using Oxide.Core;
using UnityEngine;

public class DropUtil
{
	public static void DropItems(ItemContainer container, Vector3 position)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", (object)container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			float num2 = Random.Range(0f, 2f);
			item.RemoveFromContainer();
			BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(Random.Range(0f - num, num), 1f, Random.Range(0f - num, num)));
			if ((Object)(object)baseEntity == (Object)null)
			{
				item.Remove();
				continue;
			}
			if (baseEntity is DroppedItem droppedItem && container.entityOwner is LootContainer)
			{
				droppedItem.DropReason = DroppedItem.DropReasonEnum.Loot;
			}
			if (num2 > 0f)
			{
				baseEntity.SetVelocity(new Vector3(Random.Range(-1f, 1f), Random.Range(0f, 1f), Random.Range(-1f, 1f)) * num2);
				baseEntity.SetAngularVelocity(new Vector3(Random.Range(-10f, 10f), Random.Range(-10f, 10f), Random.Range(-10f, 10f)) * num2);
			}
		}
	}
}


public class DynamicPreventBuilding : BaseEntity
{
}


using System;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class EnvSync : PointEntity
{
	private const float syncInterval = 5f;

	private const float syncIntervalInv = 0.2f;

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateNetwork, 5f, 5f);
	}

	private void UpdateNetwork()
	{
		if (NexusServer.Started && NexusServer.LastReset.HasValue && (Object)(object)TOD_Sky.Instance != (Object)null)
		{
			TOD_Time time = TOD_Sky.Instance.Components.Time;
			DateTimeOffset dateTimeOffset = DateTimeOffset.FromUnixTimeSeconds(NexusServer.LastReset.Value);
			double totalMinutes = (DateTimeOffset.UtcNow - dateTimeOffset).TotalMinutes;
			double num = (double)(Nexus.timeOffset / 24f) + totalMinutes / (double)time.DayLengthInMinutes;
			if (time.UseTimeCurve)
			{
				double num2 = Math.Truncate(num);
				double num3 = (num - num2) * 24.0;
				float num4 = time.EvaulateTimeCurve((float)num3);
				num = num2 + (double)(num4 / 24f);
			}
			double value = num * 24.0;
			DateTime dateTime = dateTimeOffset.Date.AddHours(value);
			TOD_Sky.Instance.Cycle.DateTime = dateTime;
		}
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.environment = Pool.Get<Environment>();
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			info.msg.environment.dateTime = TOD_Sky.Instance.Cycle.DateTime.ToBinary();
		}
		info.msg.environment.engineTime = Time.realtimeSinceStartup;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.environment != null && Object.op_Implicit((Object)(object)TOD_Sky.Instance) && base.isServer)
		{
			TOD_Sky.Instance.Cycle.DateTime = DateTime.FromBinary(info.msg.environment.dateTime);
		}
	}
}


using System;
using UnityEngine;

public class F15 : BaseCombatEntity
{
	public float speed = 150f;

	public float defaultAltitude = 150f;

	public float altitude = 250f;

	public float altitudeLerpSpeed = 30f;

	public float turnRate = 1f;

	public float flybySoundLengthUntilMax = 4.5f;

	public SoundPlayer flybySound;

	public GameObject body;

	public float rollSpeed = 1f;

	public Vector3 movePosition;

	public GameObjectRef missilePrefab;

	private float nextMissileTime;

	private float blockTurningFor;

	private bool isRetiring;

	private CH47PathFinder pathFinder = new CH47PathFinder();

	private float turnSeconds;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public float GetDesiredAltitude()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + ((Component)this).transform.forward * 200f;
		return (TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position) + TerrainMeta.HeightMap.GetHeight(val) + TerrainMeta.HeightMap.GetHeight(val + Vector3.right * 50f) + TerrainMeta.HeightMap.GetHeight(val - Vector3.right * 50f) + TerrainMeta.HeightMap.GetHeight(val + Vector3.forward * 50f) + TerrainMeta.HeightMap.GetHeight(val - Vector3.forward * 50f)) / 6f + defaultAltitude;
	}

	public override void ServerInit()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)RetireToSunset, 600f);
		movePosition = ((Component)this).transform.position;
		movePosition.y = defaultAltitude;
		((Component)this).transform.position = movePosition;
	}

	public void RetireToSunset()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		isRetiring = true;
		movePosition = new Vector3(10000f, defaultAltitude, 10000f);
	}

	public void PickNewPatrolPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		movePosition = pathFinder.GetRandomPatrolPoint();
		float num = 0f;
		if ((Object)(object)TerrainMeta.HeightMap != (Object)null)
		{
			num = TerrainMeta.HeightMap.GetHeight(movePosition);
		}
		movePosition.y = num + defaultAltitude;
	}

	private void FixedUpdate()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		if (isRetiring && Vector3.Distance(((Component)this).transform.position, Vector3.zero) > 4900f)
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, 0f);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)DelayedDestroy))
		{
			altitude = Mathf.Lerp(altitude, GetDesiredAltitude(), Time.fixedDeltaTime * 0.25f);
			if (Vector3Ex.Distance2D(movePosition, ((Component)this).transform.position) < 10f)
			{
				PickNewPatrolPoint();
				blockTurningFor = 6f;
			}
			blockTurningFor -= Time.fixedDeltaTime;
			bool num = blockTurningFor > 0f;
			movePosition.y = altitude;
			Vector3 val = Vector3Ex.Direction(movePosition, ((Component)this).transform.position);
			if (num)
			{
				Vector3 position = ((Component)this).transform.position;
				position.y = altitude;
				Vector3 val2 = QuaternionEx.LookRotationForcedUp(((Component)this).transform.forward, Vector3.up) * Vector3.forward;
				val = Vector3Ex.Direction(position + val2 * 2000f, ((Component)this).transform.position);
			}
			Vector3 forward = Vector3.Lerp(((Component)this).transform.forward, val, Time.fixedDeltaTime * turnRate);
			((Component)this).transform.forward = forward;
			bool flag = Vector3.Dot(((Component)this).transform.right, val) > 0.55f;
			bool flag2 = Vector3.Dot(-((Component)this).transform.right, val) > 0.55f;
			SetFlag(Flags.Reserved1, flag);
			SetFlag(Flags.Reserved2, flag2);
			if (flag2 || flag)
			{
				turnSeconds += Time.fixedDeltaTime;
			}
			else
			{
				turnSeconds = 0f;
			}
			if (turnSeconds > 10f)
			{
				turnSeconds = 0f;
				blockTurningFor = 8f;
			}
			Transform transform = ((Component)this).transform;
			transform.position += ((Component)this).transform.forward * speed * Time.fixedDeltaTime;
			nextMissileTime = Time.realtimeSinceStartup + 10f;
		}
	}

	public void DelayedDestroy()
	{
		Kill();
	}
}


public interface IAlwaysOn
{
	void SetAlwaysOn(bool flag);

	bool IsAlwaysOn()
	{
		return false;
	}

	void AlwaysOnToggled(bool flag);
}


using UnityEngine;

public interface IIgniteable
{
	void Ignite(Vector3 fromPos);

	bool CanIgnite();
}


public interface IReceivePlayerTickListener
{
	void OnReceivePlayerTick(BasePlayer player, PlayerTick msg);

	bool ShouldRemoveOnPlayerDeath();
}


public interface ISplashable
{
	bool WantsSplash(ItemDefinition splashType, int amount);

	int DoSplash(ItemDefinition splashType, int amount);
}


using System;
using ConVar;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

public class LootContainer : StorageContainer
{
	public enum spawnType
	{
		GENERIC,
		PLAYER,
		TOWN,
		AIRDROP,
		CRASHSITE,
		ROADSIDE
	}

	[Serializable]
	public struct LootSpawnSlot
	{
		public LootSpawn definition;

		public int numberToSpawn;

		public float probability;

		public string onlyWithLoadoutNamed;

		public Era[] eras;
	}

	public bool destroyOnEmpty = true;

	public LootSpawn lootDefinition;

	public int maxDefinitionsToSpawn;

	public float minSecondsBetweenRefresh = 3600f;

	public float maxSecondsBetweenRefresh = 7200f;

	public bool initialLootSpawn = true;

	public float xpLootedScale = 1f;

	public float xpDestroyedScale = 1f;

	public bool BlockPlayerItemInput;

	public int scrapAmount;

	public string deathStat = "";

	public LootSpawnSlot[] LootSpawnSlots;

	public spawnType SpawnType;

	public ClanScoreEventType clanScoreEventForFirstLooter = (ClanScoreEventType)(-1);

	[NonSerialized]
	public bool HasBeenLooted;

	[NonSerialized]
	public ulong FirstLooterId;

	private static ItemDefinition scrapDef;

	public bool shouldRefreshContents
	{
		get
		{
			if (minSecondsBetweenRefresh > 0f)
			{
				return maxSecondsBetweenRefresh > 0f;
			}
			return false;
		}
	}

	public override void ResetState()
	{
		FirstLooterId = 0uL;
		base.ResetState();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (initialLootSpawn)
		{
			SpawnLoot();
		}
		if (BlockPlayerItemInput && !Application.isLoadingSave && base.inventory != null)
		{
			base.inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
		}
		SetFlag(Flags.Reserved6, PlayerInventory.IsBirthday());
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (!added)
		{
			HasBeenLooted = true;
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (BlockPlayerItemInput && base.inventory != null)
		{
			base.inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
		}
	}

	public virtual void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log((object)"CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!");
			return;
		}
		base.inventory.Clear();
		ItemManager.DoRemoves();
		if (Interface.CallHook("OnLootSpawn", (object)this) == null)
		{
			PopulateLoot();
			if (shouldRefreshContents)
			{
				((FacepunchBehaviour)this).Invoke((Action)SpawnLoot, Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));
			}
		}
	}

	public int ScoreForRarity(Rarity rarity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Expected I4, but got Unknown
		return (rarity - 1) switch
		{
			0 => 1, 
			1 => 2, 
			2 => 3, 
			3 => 4, 
			_ => 5000, 
		};
	}

	public virtual void PopulateLoot()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (LootSpawnSlots.Length != 0)
		{
			LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
			for (int i = 0; i < lootSpawnSlots.Length; i++)
			{
				LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
				if (lootSpawnSlot.eras != null && lootSpawnSlot.eras.Length != 0 && Array.IndexOf(lootSpawnSlot.eras, ConVar.Server.Era) == -1)
				{
					continue;
				}
				for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
				{
					if (Random.Range(0f, 1f) <= lootSpawnSlot.probability)
					{
						lootSpawnSlot.definition.SpawnIntoContainer(base.inventory);
					}
				}
			}
		}
		else if ((Object)(object)lootDefinition != (Object)null)
		{
			for (int k = 0; k < maxDefinitionsToSpawn; k++)
			{
				lootDefinition.SpawnIntoContainer(base.inventory);
			}
		}
		if (SpawnType == spawnType.ROADSIDE || SpawnType == spawnType.TOWN)
		{
			foreach (Item item in base.inventory.itemList)
			{
				if (item.hasCondition)
				{
					item.condition = Random.Range(item.info.condition.foundCondition.fractionMin, item.info.condition.foundCondition.fractionMax) * item.info.condition.max;
				}
			}
		}
		GenerateScrap();
		HasBeenLooted = false;
	}

	public void GenerateScrap()
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (scrapAmount <= 0)
		{
			return;
		}
		if ((Object)(object)scrapDef == (Object)null)
		{
			scrapDef = ItemManager.FindItemDefinition("scrap");
		}
		int num = scrapAmount;
		if (num > 0)
		{
			Item item = ItemManager.Create(scrapDef, num, 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Drop(((Component)this).transform.position, GetInheritedDropVelocity());
			}
		}
	}

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		base.DropBonusItems(initiator, container);
		if ((Object)(object)initiator == (Object)null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null || scrapAmount <= 0 || !((Object)(object)scrapDef != (Object)null))
		{
			return;
		}
		float num = (((Object)(object)basePlayer.modifiers != (Object)null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", (object)item, (object)basePlayer, (object)container) == null)
			{
				(item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;
				Interface.CallHook("OnBonusItemDropped", (object)item, (object)basePlayer, (object)container);
			}
		}
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Invalid comparison between Unknown and I4
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (FirstLooterId == 0L)
		{
			FirstLooterId = baseEntity.userID;
			Analytics.Azure.OnFirstLooted(this, baseEntity);
			if ((int)clanScoreEventForFirstLooter != -1)
			{
				baseEntity.AddClanScore(clanScoreEventForFirstLooter);
			}
			if (base.inventory != null && base.inventory.itemList != null)
			{
				foreach (Item item in base.inventory.itemList)
				{
					item?.SetItemOwnership(baseEntity, ItemOwnershipPhrases.LootedPhrase);
				}
			}
		}
		return base.OnStartBeingLooted(baseEntity);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		if (destroyOnEmpty && (base.inventory == null || base.inventory.itemList == null || base.inventory.itemList.Count == 0))
		{
			Kill(DestroyMode.Gib);
		}
	}

	public void RemoveMe()
	{
		Kill(DestroyMode.Gib);
	}

	public override bool ShouldDropItemsIndividually()
	{
		return true;
	}

	public override void DropItems(BaseEntity initiator = null)
	{
		if (initiator is BasePlayer player)
		{
			foreach (Item item in base.inventory.itemList)
			{
				item?.SetItemOwnership(player, ItemOwnershipPhrases.LootedPhrase);
			}
		}
		base.DropItems(initiator);
	}

	public override void OnDied(HitInfo info)
	{
		if (info != null)
		{
			Analytics.Azure.OnLootContainerDestroyed(this, info.InitiatorPlayer, info.Weapon);
		}
		base.OnDied(info);
		if (info != null && (Object)(object)info.InitiatorPlayer != (Object)null && !string.IsNullOrEmpty(deathStat))
		{
			info.InitiatorPlayer.stats.Add(deathStat, 1, Stats.Life);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
	}

	public override void InitShared()
	{
		base.InitShared();
	}
}


public enum spawnType
{
	GENERIC,
	PLAYER,
	TOWN,
	AIRDROP,
	CRASHSITE,
	ROADSIDE
}


using System;
using Rust;

[Serializable]
public struct LootSpawnSlot
{
	public LootSpawn definition;

	public int numberToSpawn;

	public float probability;

	public string onlyWithLoadoutNamed;

	public Era[] eras;
}


public class LootContainerAchievement : LootContainer
{
	public string AchievementName = string.Empty;

	public bool AllowDuringTutorial;

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		if (!string.IsNullOrEmpty(AchievementName))
		{
			baseEntity.GiveAchievement(AchievementName, AllowDuringTutorial);
		}
		return base.OnStartBeingLooted(baseEntity);
	}
}


using System;
using UnityEngine;

public class m2bradleyAnimator : MonoBehaviour
{
	public Animator m2Animator;

	public Material treadLeftMaterial;

	public Material treadRightMaterial;

	private Rigidbody mainRigidbody;

	[Header("GunBones")]
	public Transform turret;

	public Transform mainCannon;

	public Transform coaxGun;

	public Transform rocketsPitch;

	public Transform spotLightYaw;

	public Transform spotLightPitch;

	public Transform sideMG;

	public Transform[] sideguns;

	[Header("WheelBones")]
	public Transform[] ShocksBones;

	public Transform[] ShockTraceLineBegin;

	public Vector3[] vecShocksOffsetPosition;

	[Header("Targeting")]
	public Transform targetTurret;

	public Transform targetSpotLight;

	public Transform[] targetSideguns;

	private Vector3 vecTurret = new Vector3(0f, 0f, 0f);

	private Vector3 vecMainCannon = new Vector3(0f, 0f, 0f);

	private Vector3 vecCoaxGun = new Vector3(0f, 0f, 0f);

	private Vector3 vecRocketsPitch = new Vector3(0f, 0f, 0f);

	private Vector3 vecSpotLightBase = new Vector3(0f, 0f, 0f);

	private Vector3 vecSpotLight = new Vector3(0f, 0f, 0f);

	private float sideMGPitchValue;

	[Header("MuzzleFlash locations")]
	public GameObject muzzleflashCannon;

	public GameObject muzzleflashCoaxGun;

	public GameObject muzzleflashSideMG;

	public GameObject[] muzzleflashRockets;

	public GameObject spotLightHaloSawnpoint;

	public GameObject[] muzzleflashSideguns;

	[Header("MuzzleFlash Particle Systems")]
	public GameObjectRef machineGunMuzzleFlashFX;

	public GameObjectRef mainCannonFireFX;

	public GameObjectRef rocketLaunchFX;

	[Header("Misc")]
	public bool rocketsOpen;

	public Vector3[] vecSideGunRotation;

	public float treadConstant = 0.14f;

	public float wheelSpinConstant = 80f;

	[Header("Gun Movement speeds")]
	public float sidegunsTurnSpeed = 30f;

	public float turretTurnSpeed = 6f;

	public float cannonPitchSpeed = 10f;

	public float rocketPitchSpeed = 20f;

	public float spotLightTurnSpeed = 60f;

	public float machineGunSpeed = 20f;

	private float wheelAngle;

	private void Start()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		mainRigidbody = ((Component)this).GetComponent<Rigidbody>();
		for (int i = 0; i < ShocksBones.Length; i++)
		{
			vecShocksOffsetPosition[i] = ShocksBones[i].localPosition;
		}
	}

	private void Update()
	{
		TrackTurret();
		TrackSpotLight();
		TrackSideGuns();
		AnimateWheelsTreads();
		AdjustShocksHeight();
		m2Animator.SetBool("rocketpods", rocketsOpen);
	}

	private void AnimateWheelsTreads()
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		if ((Object)(object)mainRigidbody != (Object)null)
		{
			num = Vector3.Dot(mainRigidbody.velocity, ((Component)this).transform.forward);
		}
		float num2 = Time.time * -1f * num * treadConstant % 1f;
		treadLeftMaterial.SetTextureOffset("_MainTex", new Vector2(num2, 0f));
		treadLeftMaterial.SetTextureOffset("_BumpMap", new Vector2(num2, 0f));
		treadLeftMaterial.SetTextureOffset("_SpecGlossMap", new Vector2(num2, 0f));
		treadRightMaterial.SetTextureOffset("_MainTex", new Vector2(num2, 0f));
		treadRightMaterial.SetTextureOffset("_BumpMap", new Vector2(num2, 0f));
		treadRightMaterial.SetTextureOffset("_SpecGlossMap", new Vector2(num2, 0f));
		if (num >= 0f)
		{
			wheelAngle = (wheelAngle + Time.deltaTime * num * wheelSpinConstant) % 360f;
		}
		else
		{
			wheelAngle += Time.deltaTime * num * wheelSpinConstant;
			if (wheelAngle <= 0f)
			{
				wheelAngle = 360f;
			}
		}
		m2Animator.SetFloat("wheel_spin", wheelAngle);
		m2Animator.SetFloat("speed", num);
	}

	private void AdjustShocksHeight()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		Ray val = default(Ray);
		int mask = LayerMask.GetMask(new string[3] { "Terrain", "World", "Construction" });
		int num = ShocksBones.Length;
		float num2 = 0.55f;
		float num3 = 0.79f;
		float num4 = 0.26f;
		RaycastHit val2 = default(RaycastHit);
		for (int i = 0; i < num; i++)
		{
			((Ray)(ref val)).origin = ShockTraceLineBegin[i].position;
			((Ray)(ref val)).direction = ((Component)this).transform.up * -1f;
			num4 = ((!Physics.SphereCast(val, 0.15f, ref val2, num3, mask)) ? 0.26f : (((RaycastHit)(ref val2)).distance - num2));
			vecShocksOffsetPosition[i].y = Mathf.Lerp(vecShocksOffsetPosition[i].y, Mathf.Clamp(num4 * -1f, -0.26f, 0f), Time.deltaTime * 5f);
			ShocksBones[i].localPosition = vecShocksOffsetPosition[i];
		}
	}

	private void TrackTurret()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)targetTurret != (Object)null))
		{
			return;
		}
		Vector3 val = targetTurret.position - turret.position;
		_ = ((Vector3)(ref val)).normalized;
		CalculateYawPitchOffset(turret, turret.position, targetTurret.position, out var yaw, out var pitch);
		yaw = NormalizeYaw(yaw);
		float num = Time.deltaTime * turretTurnSpeed;
		if (yaw < -0.5f)
		{
			vecTurret.y = (vecTurret.y - num) % 360f;
		}
		else if (yaw > 0.5f)
		{
			vecTurret.y = (vecTurret.y + num) % 360f;
		}
		turret.localEulerAngles = vecTurret;
		float num2 = Time.deltaTime * cannonPitchSpeed;
		CalculateYawPitchOffset(mainCannon, mainCannon.position, targetTurret.position, out yaw, out pitch);
		if (pitch < -0.5f)
		{
			vecMainCannon.x -= num2;
		}
		else if (pitch > 0.5f)
		{
			vecMainCannon.x += num2;
		}
		vecMainCannon.x = Mathf.Clamp(vecMainCannon.x, -55f, 5f);
		mainCannon.localEulerAngles = vecMainCannon;
		if (pitch < -0.5f)
		{
			vecCoaxGun.x -= num2;
		}
		else if (pitch > 0.5f)
		{
			vecCoaxGun.x += num2;
		}
		vecCoaxGun.x = Mathf.Clamp(vecCoaxGun.x, -65f, 15f);
		coaxGun.localEulerAngles = vecCoaxGun;
		if (rocketsOpen)
		{
			num2 = Time.deltaTime * rocketPitchSpeed;
			CalculateYawPitchOffset(rocketsPitch, rocketsPitch.position, targetTurret.position, out yaw, out pitch);
			if (pitch < -0.5f)
			{
				vecRocketsPitch.x -= num2;
			}
			else if (pitch > 0.5f)
			{
				vecRocketsPitch.x += num2;
			}
			vecRocketsPitch.x = Mathf.Clamp(vecRocketsPitch.x, -45f, 45f);
		}
		else
		{
			vecRocketsPitch.x = Mathf.Lerp(vecRocketsPitch.x, 0f, Time.deltaTime * 1.7f);
		}
		rocketsPitch.localEulerAngles = vecRocketsPitch;
	}

	private void TrackSpotLight()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetSpotLight != (Object)null)
		{
			Vector3 val = targetSpotLight.position - spotLightYaw.position;
			_ = ((Vector3)(ref val)).normalized;
			CalculateYawPitchOffset(spotLightYaw, spotLightYaw.position, targetSpotLight.position, out var yaw, out var pitch);
			yaw = NormalizeYaw(yaw);
			float num = Time.deltaTime * spotLightTurnSpeed;
			if (yaw < -0.5f)
			{
				vecSpotLightBase.y = (vecSpotLightBase.y - num) % 360f;
			}
			else if (yaw > 0.5f)
			{
				vecSpotLightBase.y = (vecSpotLightBase.y + num) % 360f;
			}
			spotLightYaw.localEulerAngles = vecSpotLightBase;
			CalculateYawPitchOffset(spotLightPitch, spotLightPitch.position, targetSpotLight.position, out yaw, out pitch);
			if (pitch < -0.5f)
			{
				vecSpotLight.x -= num;
			}
			else if (pitch > 0.5f)
			{
				vecSpotLight.x += num;
			}
			vecSpotLight.x = Mathf.Clamp(vecSpotLight.x, -50f, 50f);
			spotLightPitch.localEulerAngles = vecSpotLight;
			m2Animator.SetFloat("sideMG_pitch", vecSpotLight.x, 0.5f, Time.deltaTime);
		}
	}

	private void TrackSideGuns()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < sideguns.Length; i++)
		{
			if (!((Object)(object)targetSideguns[i] == (Object)null))
			{
				Vector3 val = targetSideguns[i].position - sideguns[i].position;
				_ = ((Vector3)(ref val)).normalized;
				CalculateYawPitchOffset(sideguns[i], sideguns[i].position, targetSideguns[i].position, out var yaw, out var pitch);
				yaw = NormalizeYaw(yaw);
				float num = Time.deltaTime * sidegunsTurnSpeed;
				if (yaw < -0.5f)
				{
					vecSideGunRotation[i].y -= num;
				}
				else if (yaw > 0.5f)
				{
					vecSideGunRotation[i].y += num;
				}
				if (pitch < -0.5f)
				{
					vecSideGunRotation[i].x -= num;
				}
				else if (pitch > 0.5f)
				{
					vecSideGunRotation[i].x += num;
				}
				vecSideGunRotation[i].x = Mathf.Clamp(vecSideGunRotation[i].x, -45f, 45f);
				vecSideGunRotation[i].y = Mathf.Clamp(vecSideGunRotation[i].y, -45f, 45f);
				sideguns[i].localEulerAngles = vecSideGunRotation[i];
			}
		}
	}

	public void CalculateYawPitchOffset(Transform objectTransform, Vector3 vecStart, Vector3 vecEnd, out float yaw, out float pitch)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = objectTransform.InverseTransformDirection(vecEnd - vecStart);
		float num = Mathf.Sqrt(val.x * val.x + val.z * val.z);
		pitch = (0f - Mathf.Atan2(val.y, num)) * (180f / MathF.PI);
		Vector3 val2 = vecEnd - vecStart;
		val = ((Vector3)(ref val2)).normalized;
		Vector3 forward = objectTransform.forward;
		forward.y = 0f;
		((Vector3)(ref forward)).Normalize();
		float num2 = Vector3.Dot(val, forward);
		float num3 = Vector3.Dot(val, objectTransform.right);
		float num4 = 360f * num3;
		float num5 = 360f * (0f - num2);
		yaw = (Mathf.Atan2(num4, num5) + MathF.PI) * (180f / MathF.PI);
	}

	public float NormalizeYaw(float flYaw)
	{
		if (flYaw > 180f)
		{
			return 360f - flYaw;
		}
		return flYaw * -1f;
	}
}


using UnityEngine;

public class M2BradleyPhysics : MonoBehaviour
{
	private m2bradleyAnimator m2Animator;

	public WheelCollider[] Wheels;

	public WheelCollider[] TurningWheels;

	public Rigidbody mainRigidbody;

	public Transform[] waypoints;

	private Vector3 currentWaypoint;

	private Vector3 nextWaypoint;
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class MapMarker : BaseEntity
{
	public enum ClusterType
	{
		None,
		Vending
	}

	public AppMarkerType appType;

	public GameObjectRef markerObj;

	public static readonly List<MapMarker> serverMapMarkers = new List<MapMarker>();

	public override void InitShared()
	{
		if (base.isServer && !serverMapMarkers.Contains(this))
		{
			serverMapMarkers.Add(this);
		}
		base.InitShared();
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			serverMapMarkers.Remove(this);
		}
		base.DestroyShared();
	}

	public virtual AppMarker GetAppMarkerData()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		AppMarker obj = Pool.Get<AppMarker>();
		Vector2 val = CompanionServer.Util.WorldToMap(((Component)this).transform.position);
		obj.id = net.ID;
		obj.type = appType;
		obj.x = val.x;
		obj.y = val.y;
		return obj;
	}
}


public enum ClusterType
{
	None,
	Vending
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public class MapMarkerMissionProvider : MapMarker
{
	private List<BaseMission> missionsProvided = new List<BaseMission>();

	private string providerToken = string.Empty;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.missionMapMarker == null)
		{
			return;
		}
		if (info.msg.missionMapMarker.missionIds != null)
		{
			missionsProvided.Clear();
			foreach (uint missionId in info.msg.missionMapMarker.missionIds)
			{
				BaseMission fromID = MissionManifest.GetFromID(missionId);
				if (fromID != null)
				{
					missionsProvided.Add(fromID);
				}
			}
		}
		providerToken = info.msg.missionMapMarker.providerToken;
	}

	public void AssignMissions(List<BaseMission> missions, string token)
	{
		missionsProvided.Clear();
		foreach (BaseMission mission in missions)
		{
			missionsProvided.Add(mission);
		}
		providerToken = token;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.missionMapMarker = Pool.Get<MissionMapMarker>();
		info.msg.missionMapMarker.missionIds = Pool.Get<List<uint>>();
		foreach (BaseMission item in missionsProvided)
		{
			info.msg.missionMapMarker.missionIds.Add(item.id);
		}
		info.msg.missionMapMarker.providerToken = providerToken;
	}
}


using UnityEngine;

public class PaintableItem : MonoBehaviour
{
	public MeshPaintableSource PaintableSource;
}


using UnityEngine;

public class AIHelicopterAnimation : MonoBehaviour
{
	public PatrolHelicopterAI _ai;

	public float swayAmount = 1f;

	public float impactSwayAmount = 1f;

	public float lastStrafeScalar;

	public float lastForwardBackScalar;

	public float degreeMax = 90f;

	public Vector3 lastPosition = Vector3.zero;

	public float oldMoveSpeed;

	public float smoothRateOfChange;

	public float flareAmount;

	public float swaySmoothingFactor = 0.1f;

	private float smoothedTime;

	private void Awake()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		lastPosition = ((Component)this).transform.position;
	}

	public void UpdateAnimation()
	{
		UpdateForwardBackTilting();
		UpdateStrafeTilting();
		ModifyHelicopterAngles();
		smoothedTime = Mathf.Lerp(smoothedTime, Time.time, swaySmoothingFactor * Time.deltaTime);
	}

	public void UpdateLastPosition()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		lastPosition = ((Component)this).transform.position;
	}

	private void UpdateForwardBackTilting()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Vector3 currentMoveDirection = GetCurrentMoveDirection();
		float num = Vector3.Angle(currentMoveDirection, ((Component)this).transform.forward);
		float num2 = Vector3.Angle(currentMoveDirection, -((Component)this).transform.forward);
		float num3 = 1f - Mathf.Clamp01(num / degreeMax);
		float num4 = 1f - Mathf.Clamp01(num2 / degreeMax);
		float num5 = num3 - num4;
		lastForwardBackScalar = Mathf.Lerp(lastForwardBackScalar, num5, Time.deltaTime * 2f);
	}

	private void UpdateStrafeTilting()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Vector3 currentMoveDirection = GetCurrentMoveDirection();
		float num = Vector3.Angle(currentMoveDirection, ((Component)this).transform.right);
		float num2 = Vector3.Angle(currentMoveDirection, -((Component)this).transform.right);
		float num3 = 1f - Mathf.Clamp01(num / degreeMax);
		float num4 = 1f - Mathf.Clamp01(num2 / degreeMax);
		float num5 = num3 - num4;
		lastStrafeScalar = Mathf.Lerp(lastStrafeScalar, num5, Time.deltaTime * 2f);
	}

	private void ModifyHelicopterAngles()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		zero.x += lastForwardBackScalar * impactSwayAmount;
		zero.z -= lastStrafeScalar * impactSwayAmount;
		zero.x += Mathf.Sin(smoothedTime) * swayAmount;
		zero.z -= Mathf.Cos(smoothedTime) * swayAmount / 2f;
		Quaternion localRotation = Quaternion.Euler(zero.x, zero.y, zero.z);
		_ai.helicopterBase.rotorPivot.transform.localRotation = localRotation;
	}

	private Vector3 GetCurrentMoveDirection()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - lastPosition;
		return ((Vector3)(ref val)).normalized;
	}
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class HelicopterDebris : ServerGib
{
	public ItemDefinition metalFragments;

	public ItemDefinition hqMetal;

	public ItemDefinition charcoal;

	[Tooltip("Divide mass by this amount to produce a scalar of resources, default = 5")]
	public float massReductionScalar = 5f;

	private ResourceDispenser resourceDispenser;

	public float tooHotUntil;

	public override void ServerInit()
	{
		base.ServerInit();
		tooHotUntil = Time.realtimeSinceStartup + 480f;
	}

	public override void PhysicsInit(Mesh mesh)
	{
		base.PhysicsInit(mesh);
		if (!base.isServer)
		{
			return;
		}
		resourceDispenser = ((Component)this).GetComponent<ResourceDispenser>();
		float num = Mathf.Clamp01(((Component)this).GetComponent<Rigidbody>().mass / massReductionScalar);
		resourceDispenser.containedItems = new List<ItemAmount>();
		if (num > 0.75f && (Object)(object)hqMetal != (Object)null)
		{
			resourceDispenser.containedItems.Add(new ItemAmount(hqMetal, Mathf.CeilToInt(7f * num)));
		}
		if (num > 0f)
		{
			if ((Object)(object)metalFragments != (Object)null)
			{
				resourceDispenser.containedItems.Add(new ItemAmount(metalFragments, Mathf.CeilToInt(150f * num)));
			}
			if ((Object)(object)charcoal != (Object)null)
			{
				resourceDispenser.containedItems.Add(new ItemAmount(charcoal, Mathf.CeilToInt(80f * num)));
			}
		}
		resourceDispenser.Initialize();
	}

	public bool IsTooHot()
	{
		return tooHotUntil > Time.realtimeSinceStartup;
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (IsTooHot() && info.WeaponPrefab is BaseMelee)
		{
			if (info.Initiator is BasePlayer)
			{
				HitInfo hitInfo = new HitInfo();
				hitInfo.damageTypes.Add(DamageType.Heat, 5f);
				hitInfo.DoHitEffects = true;
				hitInfo.DidHit = true;
				hitInfo.HitBone = 0u;
				hitInfo.Initiator = this;
				hitInfo.PointStart = ((Component)this).transform.position;
				Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", info.Initiator, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)resourceDispenser))
			{
				resourceDispenser.OnAttacked(info);
			}
			base.OnAttacked(info);
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using UnityEngine;

public class HelicopterTurret : MonoBehaviour
{
	public PatrolHelicopterAI _heliAI;

	public float fireRate = 0.125f;

	public float burstLength = 3f;

	public float timeBetweenBursts = 3f;

	public float maxTargetRange = 300f;

	public float loseTargetAfter = 5f;

	public Transform gun_yaw;

	public Transform gun_pitch;

	public Transform muzzleTransform;

	public bool left;

	public BaseCombatEntity _target;

	private float lastBurstTime = float.NegativeInfinity;

	private float lastFireTime = float.NegativeInfinity;

	private float lastSeenTargetTime = float.NegativeInfinity;

	private bool targetVisible;

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", (object)this, (object)newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

	public bool NeedsNewTarget()
	{
		if (HasTarget())
		{
			if (!targetVisible)
			{
				return TimeSinceTargetLastSeen() > loseTargetAfter;
			}
			return false;
		}
		return true;
	}

	public bool UpdateTargetFromList(List<PatrolHelicopterAI.targetinfo> newTargetList)
	{
		int num = Random.Range(0, newTargetList.Count);
		int num2 = newTargetList.Count;
		while (num2 >= 0)
		{
			num2--;
			PatrolHelicopterAI.targetinfo targetinfo = newTargetList[num];
			if (targetinfo != null && (Object)(object)targetinfo.ent != (Object)null && targetinfo.IsVisible() && InFiringArc(targetinfo.ply))
			{
				SetTarget(targetinfo.ply);
				return true;
			}
			num++;
			if (num >= newTargetList.Count)
			{
				num = 0;
			}
		}
		return false;
	}

	public bool TargetVisible()
	{
		UpdateTargetVisibility();
		return targetVisible;
	}

	public float TimeSinceTargetLastSeen()
	{
		return Time.realtimeSinceStartup - lastSeenTargetTime;
	}

	public bool HasTarget()
	{
		return (Object)(object)_target != (Object)null;
	}

	public void ClearTarget()
	{
		_target = null;
		targetVisible = false;
	}

	public void TurretThink()
	{
		if (HasTarget() && TimeSinceTargetLastSeen() > loseTargetAfter * 2f)
		{
			ClearTarget();
		}
		if (HasTarget())
		{
			if (Time.time - lastBurstTime > burstLength + timeBetweenBursts && TargetVisible())
			{
				lastBurstTime = Time.time;
			}
			if (Time.time < lastBurstTime + burstLength && Time.time - lastFireTime >= fireRate && InFiringArc(_target))
			{
				lastFireTime = Time.time;
				FireGun();
			}
		}
	}

	public void FireGun()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		_heliAI.FireGun(((Component)_target).transform.position + new Vector3(0f, 0.25f, 0f), ConVar.PatrolHelicopter.bulletAccuracy, left);
	}

	public Vector3 GetPositionForEntity(BaseCombatEntity potentialtarget)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)potentialtarget).transform.position;
	}

	public float AngleToTarget(BaseCombatEntity potentialtarget)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		Vector3 positionForEntity = GetPositionForEntity(potentialtarget);
		Vector3 position = muzzleTransform.position;
		Vector3 val = positionForEntity - position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return Vector3.Angle(left ? (-((Component)_heliAI).transform.right) : ((Component)_heliAI).transform.right, normalized);
	}

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", (object)potentialtarget, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

	public void UpdateTargetVisibility()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (HasTarget())
		{
			Vector3 position = ((Component)_target).transform.position;
			BasePlayer basePlayer = _target as BasePlayer;
			if (Object.op_Implicit((Object)(object)basePlayer))
			{
				position = basePlayer.eyes.position;
			}
			bool flag = false;
			float num = Vector3.Distance(position, muzzleTransform.position);
			Vector3 val = position - muzzleTransform.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			if (num < maxTargetRange && InFiringArc(_target) && GamePhysics.Trace(new Ray(muzzleTransform.position + normalized * 6f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417, (QueryTriggerInteraction)0) && (Object)(object)((Component)((RaycastHit)(ref hitInfo)).collider).gameObject.ToBaseEntity() == (Object)(object)_target)
			{
				flag = true;
			}
			if (flag)
			{
				lastSeenTargetTime = Time.realtimeSinceStartup;
			}
			targetVisible = flag;
		}
	}
}


using System;
using UnityEngine;

public class LockedByEntCrate : LootContainer
{
	public GameObject lockingEnt;

	public void SetLockingEnt(GameObject ent)
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Think);
		SetLocked(isLocked: false);
		lockingEnt = ent;
		if ((Object)(object)lockingEnt != (Object)null)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)Think, Random.Range(0f, 1f), 1f);
			SetLocked(isLocked: true);
		}
	}

	public void SetLocked(bool isLocked)
	{
		SetFlag(Flags.OnFire, isLocked);
		SetFlag(Flags.Locked, isLocked);
	}

	public void Think()
	{
		if ((Object)(object)lockingEnt == (Object)null && IsLocked())
		{
			SetLockingEnt(null);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Oxide.Core;
using Rust;
using Rust.Ai;
using UnityEngine;

public class PatrolHelicopterAI : BaseMonoBehaviour
{
	public class targetinfo
	{
		public BasePlayer ply;

		public BaseEntity ent;

		public float lastSeenTime = float.PositiveInfinity;

		public float visibleFor;

		public float nextLOSCheck;

		public targetinfo(BaseEntity initEnt, BasePlayer initPly = null)
		{
			ply = initPly;
			ent = initEnt;
			lastSeenTime = float.PositiveInfinity;
			nextLOSCheck = Time.realtimeSinceStartup + 1.5f;
		}

		public bool IsVisible()
		{
			return TimeSinceSeen() < 1.5f;
		}

		public float TimeSinceSeen()
		{
			return Time.realtimeSinceStartup - lastSeenTime;
		}
	}

	public class DangerZone
	{
		public float Radius;

		public bool IsInMonument;

		private float score;

		private float lastActiveTime = Time.realtimeSinceStartup;

		private const float isStaleTime = 5f;

		private Vector3 centre;

		private BaseEntity parent;

		public Vector3 Centre
		{
			get
			{
				//IL_0021: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				if ((Object)(object)parent == (Object)null)
				{
					return centre;
				}
				return ((Component)parent).transform.TransformPoint(centre);
			}
		}

		public float Score
		{
			get
			{
				return score;
			}
			set
			{
				score = value;
				lastActiveTime = Time.realtimeSinceStartup;
			}
		}

		public float LastActiveTime => lastActiveTime;

		public DangerZone(Vector3 centre, float radius = 20f, BaseEntity parent = null)
		{
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)parent == (Object)null)
			{
				this.centre = centre;
			}
			else
			{
				this.centre = ((Component)parent).transform.InverseTransformPoint(centre);
			}
			this.parent = parent;
			Radius = radius;
			IsInMonument = IsInsideMonument(this.centre);
		}

		public bool IsPointInside(Vector3 point)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			return Vector3.Distance(point, Centre) <= Radius;
		}

		public bool IsStale()
		{
			return Time.realtimeSinceStartup - lastActiveTime > 5f;
		}

		public Vector3 GetNearestEdge(Vector3 point)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = point - Centre;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			normalized.y = 0f;
			return Centre + normalized * Radius;
		}
	}

	public enum aiState
	{
		IDLE,
		MOVE,
		ORBIT,
		STRAFE,
		PATROL,
		ORBITSTRAFE,
		GUARD,
		FLEE,
		DEATH
	}

	public Vector3 interestZoneOrigin;

	public Vector3 destination;

	public bool hasInterestZone;

	public float moveSpeed;

	public float maxSpeed = 25f;

	public float courseAdjustLerpTime = 2f;

	public Quaternion targetRotation;

	public Vector3 windVec;

	public Vector3 targetWindVec;

	public float windForce = 5f;

	public float windFrequency = 1f;

	public float targetThrottleSpeed;

	public float throttleSpeed;

	public float maxRotationSpeed = 90f;

	public float rotationSpeed;

	public float terrainPushForce = 100f;

	public float obstaclePushForce = 100f;

	public HelicopterTurret leftGun;

	public HelicopterTurret rightGun;

	public static PatrolHelicopterAI heliInstance;

	public PatrolHelicopter helicopterBase;

	public aiState _currentState;

	public float oceanDepthTargetCutoff = 3f;

	public AIHelicopterAnimation anim;

	private Vector3 _aimTarget;

	private bool movementLockingAiming;

	private bool hasAimTarget;

	private bool aimDoorSide;

	private Vector3 pushVec = Vector3.zero;

	private Vector3 _lastPos;

	private Vector3 _lastMoveDir;

	public bool isDead;

	public bool isRetiring;

	public float spawnTime;

	public float lastDamageTime;

	private bool forceTerrainPushback;

	private bool restrictedPatrolSize;

	private TimeSince timeSinceRestrictedPatrolSize;

	[ServerVar]
	public static float flee_damage_percentage = 0.35f;

	[ServerVar]
	public static bool use_danger_zones = true;

	[ServerVar]
	public static bool monument_crash = true;

	private bool shouldDebug;

	public List<targetinfo> _targetList = new List<targetinfo>();

	private HashSet<BasePlayer> _targetSet = new HashSet<BasePlayer>();

	public List<DangerZone> dangerZones = new List<DangerZone>();

	public List<DangerZone> noGoZones = new List<DangerZone>();

	private const int max_zones = 20;

	private const float no_go_zone_size = 250f;

	private const float danger_zone_size = 20f;

	private DangerZone leastActiveZone;

	private float deathTimeout;

	private bool didImpact;

	private Collider[] collisions;

	private bool reachedSpinoutLocation;

	private const float FleeDistance = 130f;

	private float destination_min_dist = 2f;

	private float currentOrbitDistance;

	private float currentOrbitTime;

	private bool hasEnteredOrbit;

	private float orbitStartTime;

	public float maxOrbitDuration = 30f;

	private bool breakingOrbit;

	private int orbitPointsReached;

	private float timeBetweenRocketsOrbit = 0.5f;

	private bool didGetToDesination;

	public List<MonumentInfo> _visitedMonuments;

	public float arrivalTime;

	public GameObjectRef rocketProjectile;

	public GameObjectRef rocketProjectile_Napalm;

	public bool leftTubeFiredLast;

	public float lastRocketTime;

	public float timeBetweenRockets = 0.2f;

	public int numRocketsLeft = 12;

	public const int maxRockets = 12;

	public Vector3 strafe_target_position;

	[NonSerialized]
	public BasePlayer strafe_target;

	public bool puttingDistance;

	public const float strafe_approach_range = 175f;

	public const float strafe_firing_range = 150f;

	private float get_out_of_strafe_distance = 15f;

	private bool passNapalm;

	private Vector3 cached_strafe_pos;

	private TimeSince timeSinceRefreshed;

	private bool useNapalm;

	[NonSerialized]
	public float lastNapalmTime = float.NegativeInfinity;

	[NonSerialized]
	public float lastStrafeTime = float.NegativeInfinity;

	private float _lastThinkTime;

	public bool IsDead => isDead;

	[ServerVar]
	private void dumpstate()
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("[State] " + _currentState);
		stringBuilder.AppendLine($"[Has Interest Zone] {hasInterestZone}");
		stringBuilder.AppendLine($"[Interest Zone] {interestZoneOrigin}");
		stringBuilder.AppendLine($"[Target Count] {_targetList.Count}");
		stringBuilder.AppendLine($"[Retiring] {isRetiring}");
		stringBuilder.AppendLine($"[Has Entered Orbit] {hasEnteredOrbit}");
		stringBuilder.AppendLine($"[Breaking Orbit] {breakingOrbit}");
		stringBuilder.AppendLine($"[Orbit Distance] {currentOrbitDistance}");
		Debug.Log((object)stringBuilder.ToString());
	}

	public void Awake()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.PatrolHelicopter.lifetimeMinutes == 0f)
		{
			((FacepunchBehaviour)this).Invoke((Action)DestroyMe, 1f);
			return;
		}
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateWind, 0f, 1f / windFrequency);
		_lastPos = ((Component)this).transform.position;
		spawnTime = Time.realtimeSinceStartup;
		InitializeAI();
	}

	public void SetInitialDestination(Vector3 dest, float mapScaleDistance = 0.25f)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		hasInterestZone = true;
		interestZoneOrigin = dest;
		float x = TerrainMeta.Size.x;
		float y = dest.y + 45f;
		Vector3 val = Vector3Ex.Range(-1f, 1f);
		val.y = 0f;
		((Vector3)(ref val)).Normalize();
		val *= x * mapScaleDistance;
		val.y = y;
		if (mapScaleDistance == 0f)
		{
			val = interestZoneOrigin + new Vector3(0f, 10f, 0f);
		}
		((Component)this).transform.position = val;
		ExitCurrentState();
		dest.y = y;
		State_Move_Enter(dest);
	}

	public void Retire()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (!isRetiring && Interface.CallHook("OnHelicopterRetire", (object)this) == null)
		{
			((FacepunchBehaviour)this).Invoke((Action)DestroyMe, 240f);
			float x = TerrainMeta.Size.x;
			float y = 200f;
			Vector3 val = Vector3Ex.Range(-1f, 1f);
			val.y = 0f;
			((Vector3)(ref val)).Normalize();
			val *= x * 20f;
			val.y = y;
			ExitCurrentState();
			isRetiring = true;
			State_Move_Enter(val);
		}
	}

	public void SetIdealRotation(Quaternion newTargetRot, float rotationSpeedOverride = -1f)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		float num = ((rotationSpeedOverride == -1f) ? Mathf.Clamp01(moveSpeed / (maxSpeed * 0.5f)) : rotationSpeedOverride);
		rotationSpeed = num * maxRotationSpeed;
		targetRotation = newTargetRot;
	}

	public Quaternion GetYawRotationTo(Vector3 targetDest)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = targetDest;
		val.y = 0f;
		Vector3 position = ((Component)this).transform.position;
		position.y = 0f;
		Vector3 val2 = val - position;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		if (!(normalized != Vector3.zero))
		{
			return Quaternion.identity;
		}
		return Quaternion.LookRotation(normalized);
	}

	public void SetTargetDestination(Vector3 targetDest, float minDist = 5f, float minDistForFacingRotation = 30f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		destination = targetDest;
		destination_min_dist = minDist;
		float num = Vector3.Distance(targetDest, ((Component)this).transform.position);
		if (num > minDistForFacingRotation && !IsTargeting())
		{
			SetIdealRotation(GetYawRotationTo(destination));
		}
		targetThrottleSpeed = GetThrottleForDistance(num);
	}

	public bool AtDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(((Component)this).transform.position, destination) < destination_min_dist;
	}

	public bool AtRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Angle(((Component)this).transform.rotation, targetRotation) <= 8f;
	}

	private void NoGoZoneAdded(DangerZone zone)
	{
		if (use_danger_zones && Interface.CallHook("OnNoGoZoneAdded", (object)this, (object)zone) == null && !zone.IsInMonument)
		{
			ClearTargets();
			ExitCurrentState();
			State_Flee_Enter();
		}
	}

	public float GetRandomYHeight()
	{
		return Random.Range(35f, 45f);
	}

	public void MoveToDestination()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lastMoveDir = _lastMoveDir;
		Vector3 val = destination - ((Component)this).transform.position;
		Vector3 val2 = (_lastMoveDir = Vector3.Lerp(lastMoveDir, ((Vector3)(ref val)).normalized, Time.deltaTime / courseAdjustLerpTime));
		throttleSpeed = Mathf.Lerp(throttleSpeed, targetThrottleSpeed, Time.deltaTime / 3f);
		float num = throttleSpeed * maxSpeed;
		TerrainPushback();
		Vector3 val3 = windVec * windForce * Time.deltaTime;
		Vector3 val4 = val2 * num * Time.deltaTime;
		Transform transform = ((Component)this).transform;
		transform.position += val4 + val3;
		moveSpeed = Mathf.Lerp(moveSpeed, Vector3.Distance(_lastPos, ((Component)this).transform.position) / Time.deltaTime, Time.deltaTime * 2f);
		_lastPos = ((Component)this).transform.position;
	}

	public void TerrainPushback()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		if (_currentState != aiState.DEATH || forceTerrainPushback)
		{
			int mask = LayerMask.GetMask(new string[3] { "Terrain", "World", "Construction" });
			Vector3 val = ((Component)this).transform.position + new Vector3(0f, 2f, 0f);
			Vector3 val2 = destination - val;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			float num = Vector3.Distance(destination, ((Component)this).transform.position);
			Ray val3 = new Ray(val, normalized);
			float num2 = 5f;
			float num3 = Mathf.Min(100f, num);
			Vector3 val4 = Vector3.zero;
			RaycastHit val5 = default(RaycastHit);
			if (Physics.SphereCast(val3, num2, ref val5, num3 - num2 * 0.5f, mask))
			{
				float num4 = 1f - ((RaycastHit)(ref val5)).distance / num3;
				float num5 = terrainPushForce * num4;
				val4 = Vector3.up * num5;
			}
			Ray val6 = new Ray(val, _lastMoveDir);
			float num6 = Mathf.Min(10f, num);
			RaycastHit val7 = default(RaycastHit);
			if (Physics.SphereCast(val6, num2, ref val7, num6 - num2 * 0.5f, mask))
			{
				float num7 = 1f - ((RaycastHit)(ref val7)).distance / num6;
				float num8 = obstaclePushForce * num7;
				val4 += _lastMoveDir * num8 * -1f;
				val4 += Vector3.up * num8;
			}
			int mask2 = LayerMask.GetMask(new string[1] { "Water" });
			Ray ray = new Ray(val, Vector3.down);
			float num9 = 10f;
			if (GamePhysics.Trace(ray, num2, out var hitInfo, num9 - num2 * 0.5f, mask2, (QueryTriggerInteraction)0))
			{
				float num10 = 1f - ((RaycastHit)(ref hitInfo)).distance / num9;
				float num11 = obstaclePushForce * num10;
				val4 += Vector3.up * num11;
			}
			pushVec = Vector3.Lerp(pushVec, val4, Time.deltaTime);
			Transform transform = ((Component)this).transform;
			transform.position += pushVec * Time.deltaTime;
		}
	}

	public void UpdateRotation()
	{
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (hasAimTarget)
		{
			Vector3 position = ((Component)this).transform.position;
			position.y = 0f;
			Vector3 aimTarget = _aimTarget;
			aimTarget.y = 0f;
			Vector3 val = aimTarget - position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			Vector3 val2 = Vector3.Cross(normalized, Vector3.up);
			float num = Vector3.Angle(normalized, ((Component)this).transform.right);
			float num2 = Vector3.Angle(normalized, -((Component)this).transform.right);
			if (aimDoorSide)
			{
				if (num < num2)
				{
					targetRotation = Quaternion.LookRotation(val2);
				}
				else
				{
					targetRotation = Quaternion.LookRotation(-val2);
				}
			}
			else
			{
				targetRotation = Quaternion.LookRotation(normalized);
			}
		}
		rotationSpeed = Mathf.Lerp(rotationSpeed, maxRotationSpeed, Time.deltaTime / 2f);
		((Component)this).transform.rotation = Quaternion.Lerp(((Component)this).transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);
	}

	public void UpdateSpotlight()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (hasInterestZone)
		{
			helicopterBase.spotlightTarget = new Vector3(interestZoneOrigin.x, TerrainMeta.HeightMap.GetHeight(interestZoneOrigin), interestZoneOrigin.z);
		}
		else
		{
			helicopterBase.spotlightTarget = Vector3.zero;
		}
	}

	public void Update()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		if (helicopterBase.isClient)
		{
			return;
		}
		heliInstance = this;
		UpdateTargetList();
		MoveToDestination();
		UpdateRotation();
		UpdateSpotlight();
		anim.UpdateAnimation();
		anim.UpdateLastPosition();
		AIThink();
		DoMachineGuns();
		if (TimeSince.op_Implicit(timeSinceRestrictedPatrolSize) > 240f && restrictedPatrolSize)
		{
			restrictedPatrolSize = false;
			timeSinceRestrictedPatrolSize = TimeSince.op_Implicit(0f);
		}
		if (!isRetiring && !isDead)
		{
			float num = Mathf.Max(spawnTime + ConVar.PatrolHelicopter.lifetimeMinutes * 60f, lastDamageTime + 180f);
			if (Time.realtimeSinceStartup > num)
			{
				Retire();
			}
		}
	}

	public void FixedUpdate()
	{
		if (_currentState == aiState.DEATH)
		{
			PhysicsDeathCheck();
		}
	}

	public void OtherDamaged(HitInfo info)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = info.Initiator as BasePlayer;
		if (!((Object)(object)basePlayer == (Object)null) && use_danger_zones)
		{
			UpdateDangerZones(((Component)basePlayer).transform.position, info.damageTypes.Total(), basePlayer);
		}
	}

	public void WeakspotDamaged(PatrolHelicopter.weakspot weak, HitInfo info)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = info.Initiator as BasePlayer;
		if (!((Object)(object)basePlayer == (Object)null))
		{
			if (use_danger_zones)
			{
				UpdateDangerZones(((Component)basePlayer).transform.position, info.damageTypes.Total(), basePlayer, weak);
			}
			else
			{
				TryStrafePlayer(info, 5f);
			}
		}
	}

	public void TryStrafePlayer(HitInfo info, float timeSinceDamagedThreshold)
	{
		if (!isRetiring && IsAlive() && _currentState != aiState.FLEE)
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			bool num = ValidRocketTarget(basePlayer);
			bool flag = num && CanStrafe();
			bool flag2 = !num && CanUseNapalm();
			float num2 = Time.realtimeSinceStartup - lastDamageTime;
			lastDamageTime = Time.realtimeSinceStartup;
			if (num2 < timeSinceDamagedThreshold && (Object)(object)basePlayer != (Object)null && (flag || flag2))
			{
				ExitCurrentState();
				State_Strafe_Enter(basePlayer, flag2);
			}
		}
	}

	public void CriticalDamage()
	{
		isDead = true;
		ExitCurrentState();
		State_Death_Enter();
	}

	public void DoMachineGuns()
	{
		if (_targetList.Count > 0)
		{
			if (leftGun.NeedsNewTarget())
			{
				leftGun.UpdateTargetFromList(_targetList);
			}
			if (rightGun.NeedsNewTarget())
			{
				rightGun.UpdateTargetFromList(_targetList);
			}
		}
		leftGun.TurretThink();
		rightGun.TurretThink();
	}

	public void FireGun(Vector3 targetPos, float aimCone, bool left)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.PatrolHelicopter.guns == 0)
		{
			return;
		}
		Vector3 position = (left ? helicopterBase.left_gun_muzzle.transform : helicopterBase.right_gun_muzzle.transform).position;
		Vector3 val = targetPos - position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		position += normalized * 2f;
		Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, normalized);
		if (GamePhysics.Trace(new Ray(position, modifiedAimConeDirection), 0f, out var hitInfo, 300f, 1220225809, (QueryTriggerInteraction)0))
		{
			targetPos = ((RaycastHit)(ref hitInfo)).point;
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref hitInfo)).collider))
			{
				BaseEntity entity = hitInfo.GetEntity();
				if (Object.op_Implicit((Object)(object)entity) && (Object)(object)entity != (Object)(object)helicopterBase)
				{
					BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
					HitInfo info = new HitInfo(helicopterBase, entity, DamageType.Bullet, helicopterBase.bulletDamage * ConVar.PatrolHelicopter.bulletDamageScale, ((RaycastHit)(ref hitInfo)).point);
					if (Object.op_Implicit((Object)(object)baseCombatEntity))
					{
						baseCombatEntity.OnAttacked(info);
						if (baseCombatEntity is BasePlayer)
						{
							Effect.server.ImpactEffect(new HitInfo
							{
								HitPositionWorld = ((RaycastHit)(ref hitInfo)).point - modifiedAimConeDirection * 0.25f,
								HitNormalWorld = -modifiedAimConeDirection,
								HitMaterial = StringPool.Get("Flesh")
							});
						}
					}
					else
					{
						entity.OnAttacked(info);
					}
				}
			}
		}
		else
		{
			targetPos = position + modifiedAimConeDirection * 300f;
		}
		helicopterBase.ClientRPC(RpcTarget.NetworkGroup("FireGun"), left, targetPos);
	}

	public bool CanInterruptState()
	{
		aiState currentState = _currentState;
		return currentState == aiState.IDLE || currentState == aiState.MOVE || currentState == aiState.PATROL;
	}

	public bool IsAlive()
	{
		if (!isDead)
		{
			return _currentState != aiState.DEATH;
		}
		return false;
	}

	public void DestroyMe()
	{
		if (dangerZones != null)
		{
			helicopterBase.Kill();
		}
	}

	public Vector3 GetLastMoveDir()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _lastMoveDir;
	}

	public Vector3 GetMoveDirection()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = destination - ((Component)this).transform.position;
		return ((Vector3)(ref val)).normalized;
	}

	public float GetMoveSpeed()
	{
		return moveSpeed;
	}

	public float GetMaxRotationSpeed()
	{
		return maxRotationSpeed;
	}

	public bool IsTargeting()
	{
		return hasAimTarget;
	}

	public void UpdateWind()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		targetWindVec = Random.onUnitSphere;
	}

	public void SetAimTarget(Vector3 aimTarg, bool isDoorSide)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (!movementLockingAiming)
		{
			hasAimTarget = true;
			_aimTarget = aimTarg;
			aimDoorSide = isDoorSide;
		}
	}

	public void ClearAimTarget()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		hasAimTarget = false;
		_aimTarget = Vector3.zero;
	}

	public void UpdateTargetList()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer strafeTarget = null;
		bool flag = false;
		bool shouldUseNapalm = false;
		float num = 0f;
		targetinfo targetinfo = null;
		for (int num2 = _targetList.Count - 1; num2 >= 0; num2--)
		{
			targetinfo targetinfo2 = _targetList[num2];
			if (targetinfo2 == null || !targetinfo2.ent.IsValid())
			{
				RemoveTargetAt(num2);
			}
			else if (use_danger_zones && IsInNoGoZone(((Component)targetinfo2.ply).transform.position))
			{
				RemoveTargetAt(num2);
			}
			else if (AI.ignoreplayers || SimpleAIMemory.PlayerIgnoreList.Contains(targetinfo2.ply))
			{
				RemoveTargetAt(num2);
			}
			else
			{
				UpdateTargetLineOfSightTime(targetinfo2);
				bool flag2 = (Object.op_Implicit((Object)(object)targetinfo2.ply) ? targetinfo2.ply.IsDead() : (targetinfo2.ent.Health() <= 0f));
				if (targetinfo2.TimeSinceSeen() >= 6f || flag2)
				{
					bool flag3 = Random.Range(0f, 1f) >= 0f;
					if ((CanStrafe() || CanUseNapalm()) && IsAlive() && !flag && !flag2 && ((Object)(object)targetinfo2.ply == (Object)(object)leftGun._target || (Object)(object)targetinfo2.ply == (Object)(object)rightGun._target) && flag3)
					{
						shouldUseNapalm = !ValidRocketTarget(targetinfo2.ply) || Random.Range(0f, 1f) > 0.75f;
						flag = true;
						strafeTarget = targetinfo2.ply;
					}
					RemoveTargetAt(num2);
					if ((Object)(object)leftGun._target == (Object)(object)targetinfo2.ply)
					{
						leftGun._target = null;
					}
					if ((Object)(object)rightGun._target == (Object)(object)targetinfo2.ply)
					{
						rightGun._target = null;
					}
				}
				if (use_danger_zones && !flag && (CanStrafe() || CanUseNapalm()) && IsAlive() && (Time.realtimeSinceStartup - lastNapalmTime > 20f || Time.realtimeSinceStartup - lastStrafeTime > 15f) && IsInDangerZone(((Component)targetinfo2.ply).transform.position, out var dangerZone) && dangerZone != null && dangerZone.Score > num)
				{
					num = dangerZone.Score;
					targetinfo = targetinfo2;
				}
			}
		}
		if (use_danger_zones && !flag && targetinfo != null)
		{
			shouldUseNapalm = !ValidRocketTarget(targetinfo.ply) || Random.Range(0f, 1f) > 0.75f;
			flag = true;
			strafeTarget = targetinfo.ply;
			targetinfo = null;
		}
		AddNewTargetsToList();
		if (flag && !isRetiring && !isDead)
		{
			ExitCurrentState();
			State_Strafe_Enter(strafeTarget, shouldUseNapalm);
		}
	}

	private void UpdateTargetLineOfSightTime(targetinfo targ)
	{
		if (Time.realtimeSinceStartup > targ.nextLOSCheck)
		{
			targ.nextLOSCheck = Time.realtimeSinceStartup + 1f;
			if (PlayerVisible(targ.ply))
			{
				targ.lastSeenTime = Time.realtimeSinceStartup;
				targ.visibleFor += 1f;
			}
			else
			{
				targ.visibleFor = 0f;
			}
		}
	}

	private void AddNewTargetsToList()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("PatrolHelicoperAI.AddNewTargetsToList", 0);
		try
		{
			if (AI.ignoreplayers)
			{
				return;
			}
			PooledList<BasePlayer> val2 = Pool.Get<PooledList<BasePlayer>>();
			try
			{
				BaseEntity.Query.Server.GetPlayersInSphere(((Component)this).transform.position, 150f, (List<BasePlayer>)(object)val2, BaseEntity.Query.DistanceCheckType.None);
				foreach (BasePlayer item in (List<BasePlayer>)(object)val2)
				{
					if ((Object)(object)item == (Object)null || SimpleAIMemory.PlayerIgnoreList.Contains(item))
					{
						continue;
					}
					TimeWarning val3 = TimeWarning.New("PatrolHelicoperAI.SafeZone", 0);
					try
					{
						if (item.InSafeZone())
						{
							continue;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					if (item.IsInTutorial)
					{
						continue;
					}
					TimeWarning val4 = TimeWarning.New("PatrolHelicoperAI.NoGoZone", 0);
					try
					{
						if (use_danger_zones && IsInNoGoZone(((Component)item).transform.position))
						{
							continue;
						}
					}
					finally
					{
						((IDisposable)val4)?.Dispose();
					}
					if (!IsAlreadyInTargets(item) && item.GetThreatLevel() > 0.5f && PlayerVisible(item))
					{
						TryAddTarget(item);
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool TryAddTarget(BasePlayer ply)
	{
		if (IsAlreadyInTargets(ply))
		{
			return false;
		}
		_targetList.Add(new targetinfo(ply, ply));
		_targetSet.Add(ply);
		return true;
	}

	private void RemoveTargetAt(int i)
	{
		BasePlayer ply = _targetList[i].ply;
		_targetSet.Remove(ply);
		_targetList.RemoveAt(i);
	}

	private void ClearTargets()
	{
		_targetList.Clear();
		_targetSet.Clear();
	}

	private bool IsAlreadyInTargets(BasePlayer ply)
	{
		return _targetSet.Contains(ply);
	}

	private Vector3? FindTargetWithZones(bool withOffset = true)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		float num2 = 0f;
		for (int i = 0; i < _targetList.Count; i++)
		{
			if (use_danger_zones)
			{
				Vector3 position = ((Component)_targetList[i].ply).transform.position;
				if (!IsInNoGoZone(position) && IsInDangerZone(position, out var dangerZone) && dangerZone != null && dangerZone.Score > num2)
				{
					num2 = dangerZone.Score;
					num = i;
				}
			}
		}
		if (num == -1)
		{
			return null;
		}
		Vector3 val = Vector3.zero;
		if (withOffset)
		{
			val = GetTargetOffset();
		}
		return ((Component)_targetList[num].ply).transform.position + val;
	}

	private Vector3 FindDefaultTarget(bool withOffset = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		if (withOffset)
		{
			val = GetTargetOffset();
		}
		return ((Component)_targetList[0].ply).transform.position + val;
	}

	private Vector3 GetTargetOffset()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(0f, 20f, 0f);
	}

	public bool PlayerVisible(BasePlayer ply)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanHelicopterTarget", (object)this, (object)ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		TimeWarning val = TimeWarning.New("PatrolHelicoperAI.PlayerVisible", 0);
		try
		{
			Vector3 position = ply.eyes.position;
			if (ply.eyes.position.y < WaterSystem.OceanLevel && Mathf.Abs(WaterSystem.OceanLevel - ply.eyes.position.y) > oceanDepthTargetCutoff)
			{
				return false;
			}
			if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
			{
				return false;
			}
			Vector3 val2 = ((Component)this).transform.position - Vector3.up * 6f;
			float num = Vector3.Distance(position, val2);
			Vector3 val3 = position - val2;
			Vector3 normalized = ((Vector3)(ref val3)).normalized;
			if (GamePhysics.Trace(new Ray(val2 + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417, (QueryTriggerInteraction)0) && (Object)(object)((Component)((RaycastHit)(ref hitInfo)).collider).gameObject.ToBaseEntity() == (Object)(object)ply)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void WasAttacked(HitInfo info)
	{
		BasePlayer basePlayer = info.Initiator as BasePlayer;
		if (!(basePlayer is ScientistNPC) && basePlayer.IsValid())
		{
			TryAddTarget(basePlayer);
		}
	}

	public void UpdateDangerZones(Vector3 position, float damage, BasePlayer ply, PatrolHelicopter.weakspot weak = null)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		if (!use_danger_zones)
		{
			return;
		}
		if (IsInNoGoZone(position))
		{
			if (shouldDebug)
			{
				Debug.Log((object)"Inside no go zone - ignoring damage");
			}
			return;
		}
		float num = damage;
		if (weak != null)
		{
			if (shouldDebug)
			{
				Debug.Log((object)("Hit weakspot: " + num));
			}
			num = weak.body.MaxHealth() * weak.healthFractionOnDestroyed * (damage / weak.maxHealth);
			if (shouldDebug)
			{
				Debug.Log((object)("Potential Damage: " + num));
			}
		}
		if (dangerZones.Count == 0)
		{
			MakeZone(position, num, ply.GetParentEntity());
			return;
		}
		DangerZone dangerZone = null;
		bool flag = false;
		for (int num2 = dangerZones.Count - 1; num2 >= 0; num2--)
		{
			dangerZone = dangerZones[num2];
			if (dangerZone.IsStale())
			{
				if (shouldDebug)
				{
					Debug.Log((object)"zone is stale");
				}
				dangerZones.RemoveAt(num2);
			}
			else if (dangerZone.IsPointInside(position))
			{
				if (shouldDebug)
				{
					Debug.Log((object)("zone has " + dangerZone.Score + " score"));
				}
				if (leastActiveZone == null || dangerZone.LastActiveTime < leastActiveZone.LastActiveTime)
				{
					leastActiveZone = dangerZone;
				}
				dangerZone.Score += num;
				flag = true;
				UpdateNoGoZones(dangerZone);
				break;
			}
		}
		if (flag && shouldDebug)
		{
			Debug.Log((object)"We found a zone");
		}
		if (flag)
		{
			return;
		}
		if (shouldDebug)
		{
			Debug.Log((object)"making a new zone ");
		}
		if (dangerZones.Count + 1 > 20)
		{
			if (leastActiveZone != null && dangerZones.Contains(leastActiveZone))
			{
				dangerZones.Remove(leastActiveZone);
			}
			else
			{
				dangerZones.RemoveAt(0);
			}
		}
		MakeZone(position, num, ply.GetParentEntity());
	}

	public void MakeZone(Vector3 position, float damage, BaseEntity parent = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		DangerZone dangerZone = new DangerZone(position, 20f, parent);
		dangerZone.Score += damage;
		dangerZones.Add(dangerZone);
	}

	private void UpdateNoGoZones(DangerZone zone)
	{
		if (!zone.IsInMonument && zone.Score >= helicopterBase.startHealth * flee_damage_percentage)
		{
			dangerZones.Remove(zone);
			zone.Radius = 250f;
			noGoZones.Add(zone);
			NoGoZoneAdded(zone);
		}
	}

	public void ClearStaleZones()
	{
		for (int num = dangerZones.Count - 1; num >= 0; num--)
		{
			if (dangerZones[num].IsStale())
			{
				dangerZones.RemoveAt(num);
			}
		}
	}

	private void RemoveLeastSignificantZone()
	{
		dangerZones.Sort((DangerZone a, DangerZone b) => a.Score.CompareTo(b.Score));
		dangerZones.RemoveAt(0);
	}

	public bool IsInNoGoZone(Vector3 position)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("PatrolHelicoperAI.IsInNoGoZone", 0);
		try
		{
			bool result = false;
			foreach (DangerZone noGoZone in noGoZones)
			{
				if (noGoZone.IsPointInside(position))
				{
					result = true;
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsInDangerZone(Vector3 position, out DangerZone dangerZone)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		dangerZone = null;
		foreach (DangerZone dangerZone2 in dangerZones)
		{
			if (dangerZone2.IsPointInside(position))
			{
				dangerZone = dangerZone2;
				result = true;
			}
		}
		return result;
	}

	public void State_Death_Think(float timePassed)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!reachedSpinoutLocation)
		{
			if (AtDestination())
			{
				reachedSpinoutLocation = true;
				StartSpinout();
			}
			return;
		}
		float num = Time.realtimeSinceStartup * 0.25f;
		float num2 = Mathf.Sin(MathF.PI * 2f * num) * 10f;
		float num3 = Mathf.Cos(MathF.PI * 2f * num) * 10f;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(num2, 0f, num3);
		SetAimTarget(((Component)this).transform.position + val, isDoorSide: true);
		if (((Component)this).transform.position.y - WaterSystem.OceanLevel <= 0f)
		{
			didImpact = true;
		}
		if (didImpact || Time.realtimeSinceStartup > deathTimeout)
		{
			KillOfNaturalCauses();
		}
	}

	public void State_Death_Enter()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.DEATH;
		if (collisions == null)
		{
			collisions = (Collider[])(object)new Collider[10];
		}
		MonumentInfo monumentInfo = null;
		if (monument_crash)
		{
			monumentInfo = GetCloseMonument(1200f);
		}
		if ((Object)(object)monumentInfo == (Object)null || IsInsideMonument(((Component)this).transform.position))
		{
			reachedSpinoutLocation = true;
			StartSpinout();
			return;
		}
		forceTerrainPushback = true;
		Vector3 position = ((Component)monumentInfo).transform.position;
		position.y = TerrainMeta.HeightMap.GetHeight(position) + 200f;
		if (TransformUtil.GetGroundInfo(position, out var hitOut, 300f, LayerMask.op_Implicit(1235288065)))
		{
			position.y = ((RaycastHit)(ref hitOut)).point.y;
		}
		position.y += GetPlaneHeight();
		SetTargetDestination(position, 25f);
	}

	public void State_Death_Leave()
	{
	}

	private MonumentInfo GetCloseMonument(float maxDistance)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return GetCloseMonument(maxDistance, ((Component)this).transform.position);
	}

	private static MonumentInfo GetCloseMonument(float maxDistance, Vector3 position)
	{
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		MonumentInfo result = null;
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
		{
			float num = float.MaxValue;
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				if (monument.IsSafeZone)
				{
					continue;
				}
				MonumentType type = monument.Type;
				if (type != MonumentType.Mountain && type != MonumentType.Lighthouse && type != MonumentType.Lake && type != MonumentType.WaterWell && type != 0 && type != MonumentType.Building && monument.Tier != 0 && !(((Component)monument).transform.position.y < WaterSystem.OceanLevel) && monument.AllowPatrolHeliCrash)
				{
					float num2 = Vector3Ex.Distance2D(position, ((Component)monument).transform.position);
					float num3 = monument.GetWidest2DBound() * 0.5f;
					float num4 = Mathf.Max(0f, num2 - num3);
					if (num4 < num && num4 <= maxDistance)
					{
						num = num4;
						result = monument;
					}
				}
			}
		}
		return result;
	}

	private static bool IsInsideMonument(Vector3 position)
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
		{
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				if (monument.IsSafeZone)
				{
					continue;
				}
				MonumentType type = monument.Type;
				if (type != MonumentType.Mountain && type != MonumentType.Lighthouse && type != MonumentType.Lake && type != MonumentType.WaterWell && type != 0 && type != MonumentType.Building && monument.Tier != 0 && !(((Component)monument).transform.position.y < WaterSystem.OceanLevel) && monument.AllowPatrolHeliCrash)
				{
					float num = Vector3Ex.Distance2D(position, ((Component)monument).transform.position);
					float widest2DBound = monument.GetWidest2DBound();
					widest2DBound += widest2DBound * 0.1f;
					if (num <= widest2DBound)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private void PhysicsDeathCheck()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!reachedSpinoutLocation)
		{
			return;
		}
		int mask = LayerMask.GetMask(new string[4] { "Terrain", "World", "Construction", "Water" });
		didImpact = false;
		Physics.OverlapSphereNonAlloc(((Component)this).transform.position, 5f, collisions, mask);
		Collider[] array = collisions;
		foreach (Collider val in array)
		{
			if (!((Object)(object)val == (Object)null) && !((Object)(object)((Component)val).gameObject == (Object)(object)((Component)this).gameObject))
			{
				didImpact = true;
				break;
			}
		}
	}

	private void KillOfNaturalCauses()
	{
		helicopterBase.Hurt(helicopterBase.health * 2f, DamageType.Generic, null, useProtection: false);
	}

	private void StartSpinout()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		forceTerrainPushback = false;
		maxRotationSpeed *= 8f;
		Vector3 randomOffset = GetRandomOffset(((Component)this).transform.position, 20f, 60f, 0f, 0f);
		int num = 1237003025;
		TransformUtil.GetGroundInfo(randomOffset - Vector3.up * 2f, out var pos, out var _, 500f, LayerMask.op_Implicit(num));
		SetTargetDestination(pos);
		targetThrottleSpeed = 0.5f;
		deathTimeout = Time.realtimeSinceStartup + 10f;
	}

	public void State_Flee_Think(float timePassed)
	{
		UpdateMove(timePassed);
	}

	public void State_Flee_Enter()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.FLEE;
		if ((Object)(object)helicopterBase != (Object)null)
		{
			helicopterBase.DoFlare();
		}
		restrictedPatrolSize = true;
		timeSinceRestrictedPatrolSize = TimeSince.op_Implicit(0f);
		MonumentInfo closeMonument = GetCloseMonument(float.PositiveInfinity);
		Vector3 val;
		Vector3 normalized;
		if ((Object)(object)closeMonument != (Object)null)
		{
			val = ((Component)closeMonument).transform.position - ((Component)this).transform.position;
			normalized = ((Vector3)(ref val)).normalized;
			normalized.y = 0f;
		}
		else
		{
			Vector2 insideUnitCircle = Random.insideUnitCircle;
			val = new Vector3(insideUnitCircle.x, 0f, insideUnitCircle.y);
			normalized = ((Vector3)(ref val)).normalized;
		}
		Vector3 val2 = ((Component)this).transform.position + normalized * 130f;
		val2.y = GetPlaneHeight();
		TryMove(val2);
		if ((Object)(object)helicopterBase != (Object)null)
		{
			helicopterBase.CreateFleeMarker(val2);
		}
	}

	public void State_Flee_Leave()
	{
		if ((Object)(object)helicopterBase != (Object)null)
		{
			helicopterBase.DestroyFleeMarker();
		}
	}

	public void State_Idle_Think(float timePassed)
	{
		ExitCurrentState();
		State_Patrol_Enter();
	}

	public void State_Idle_Enter()
	{
		_currentState = aiState.IDLE;
	}

	public void State_Idle_Leave()
	{
	}

	public void State_Move_Think(float timePassed)
	{
		UpdateMove(timePassed);
	}

	public void State_Move_Enter(Vector3 newPos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.MOVE;
		TryMove(newPos);
	}

	public void State_Move_Leave()
	{
	}

	private void TryMove(Vector3 newPos)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		destination_min_dist = 10f;
		SetTargetDestination(newPos);
		float distToTarget = Vector3.Distance(((Component)this).transform.position, destination);
		targetThrottleSpeed = GetThrottleForDistance(distToTarget);
	}

	private void UpdateMove(float timePassed)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float distToTarget = Vector3.Distance(((Component)this).transform.position, destination);
		targetThrottleSpeed = GetThrottleForDistance(distToTarget);
		if (AtDestination())
		{
			ExitCurrentState();
			State_Idle_Enter();
		}
	}

	public void State_Orbit_Think(float timePassed)
	{
		OrbitUpdate(timePassed);
	}

	public Vector3 GetOrbitPosition(float rate)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Sin(rate) * currentOrbitDistance;
		float num2 = Mathf.Cos(rate) * currentOrbitDistance;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(num, 0f, num2);
		Vector3 result = interestZoneOrigin + val;
		float y = Mathf.Max(interestZoneOrigin.y, GetPlaneHeight());
		result.y = y;
		return result;
	}

	public void State_Orbit_Enter(float orbitDistance)
	{
		_currentState = aiState.ORBIT;
		OrbitInit(orbitDistance);
	}

	public void State_Orbit_Leave()
	{
		breakingOrbit = false;
		hasEnteredOrbit = false;
		currentOrbitTime = 0f;
		ClearAimTarget();
	}

	private void OrbitInit(float orbitDistance, float minDistForFacingRotation = 0f)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		orbitPointsReached = 0;
		breakingOrbit = false;
		hasEnteredOrbit = false;
		orbitStartTime = Time.realtimeSinceStartup;
		Vector3 val = ((Component)this).transform.position - interestZoneOrigin;
		currentOrbitTime = Mathf.Atan2(val.x, val.z);
		currentOrbitDistance = orbitDistance;
		ClearAimTarget();
		float num = Vector3Ex.Distance2D(((Component)this).transform.position, interestZoneOrigin);
		if (num > orbitDistance && num < 120f)
		{
			currentOrbitDistance = num;
		}
		SetTargetDestination(GetOrbitPosition(currentOrbitTime), 20f, minDistForFacingRotation);
		if (shouldDebug)
		{
			DebugOrbit();
		}
	}

	private void OrbitUpdate(float timePassed, float minDistForFacingRotation = 1f, bool canBreak = true)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		if (breakingOrbit)
		{
			if (AtDestination())
			{
				ExitCurrentState();
				State_Idle_Enter();
			}
		}
		else
		{
			if (Vector3Ex.Distance2D(((Component)this).transform.position, destination) > 15f)
			{
				return;
			}
			orbitPointsReached++;
			if (!hasEnteredOrbit)
			{
				hasEnteredOrbit = true;
				orbitStartTime = Time.realtimeSinceStartup;
			}
			if (_targetList.Count == 0 && !isRetiring && canBreak && orbitPointsReached > 15)
			{
				StartBreakOrbit();
				return;
			}
			float num = MathF.PI * 2f * currentOrbitDistance;
			float num2 = 0.5f * maxSpeed;
			float num3 = num / num2;
			currentOrbitTime += timePassed / num3;
			float rate = currentOrbitTime * 30f;
			Vector3 orbitPosition = GetOrbitPosition(rate);
			ClearAimTarget();
			SetTargetDestination(orbitPosition, 2f, minDistForFacingRotation);
			targetThrottleSpeed = 0.5f;
		}
		if (Time.realtimeSinceStartup - orbitStartTime > maxOrbitDuration && !breakingOrbit && canBreak)
		{
			StartBreakOrbit();
		}
	}

	private void StartBreakOrbit()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		breakingOrbit = true;
		Vector3 appropriatePosition = GetAppropriatePosition(((Component)this).transform.position + ((Component)this).transform.forward * 75f);
		SetTargetDestination(appropriatePosition, 15f, 0f);
	}

	private void DebugOrbit()
	{
	}

	public void State_OrbitStrafe_Enter()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.ORBITSTRAFE;
		if ((Object)(object)strafe_target == (Object)null)
		{
			ExitCurrentState();
			State_Patrol_Enter();
			return;
		}
		if ((Object)(object)strafe_target.GetParentEntity() != (Object)null)
		{
			ExitCurrentState();
			State_Patrol_Enter();
			return;
		}
		interestZoneOrigin = strafe_target_position;
		puttingDistance = true;
		didGetToDesination = false;
		Vector3 targetDest = interestZoneOrigin + ((Component)this).transform.forward * 95f;
		targetDest.y = ((Component)this).transform.position.y;
		SetTargetDestination(targetDest);
		if (strafe_target.IsNearEnemyBase() || Random.Range(0f, 1f) > 0.75f)
		{
			useNapalm = true;
			lastNapalmTime = Time.realtimeSinceStartup;
		}
		numRocketsLeft = 12 + Random.Range(-3, 16);
		lastRocketTime = 0f;
	}

	public void State_OrbitStrafe_Think(float timePassed)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		if (puttingDistance)
		{
			if (AtDestination())
			{
				didGetToDesination = true;
			}
			if (didGetToDesination)
			{
				SetIdealRotation(Quaternion.LookRotation(interestZoneOrigin - ((Component)this).transform.position), 0.8f);
				if (AtRotation())
				{
					puttingDistance = false;
					float num = Vector3Ex.Distance2D(((Component)this).transform.position, interestZoneOrigin);
					num = Mathf.Max(70f, num);
					OrbitInit(num, 1000f);
				}
			}
			return;
		}
		OrbitUpdate(timePassed, 1000f, canBreak: false);
		if (hasEnteredOrbit && !breakingOrbit)
		{
			SetIdealRotation(Quaternion.LookRotation(interestZoneOrigin - ((Component)this).transform.position), 3.5f);
			if (ClipRocketsLeft() > 0 && Time.realtimeSinceStartup - lastRocketTime > timeBetweenRocketsOrbit && CanSeeForStrafe(interestZoneOrigin))
			{
				FireRocket(interestZoneOrigin);
			}
		}
		if (ClipRocketsLeft() <= 0)
		{
			ExitCurrentState();
			State_Move_Enter(GetAppropriatePosition(strafe_target_position + ((Component)this).transform.forward * 120f));
		}
	}

	public void State_OrbitStrafe_Leave()
	{
		breakingOrbit = false;
		hasEnteredOrbit = false;
		currentOrbitTime = 0f;
		ClearAimTarget();
		lastStrafeTime = Time.realtimeSinceStartup;
		strafe_target = null;
	}

	public Vector3 GetRandomPatrolDestination()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = FindValidDestination();
		if (restrictedPatrolSize)
		{
			Vector3 val2 = val - ((Component)this).transform.position;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			normalized.y = 0f;
			Vector3 result = ((Component)this).transform.position + normalized * Random.Range(65f, 130f);
			result.y = GetPlaneHeight();
			return result;
		}
		return val;
	}

	private Vector3 FindValidDestination(int maxAttempts = 5)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (use_danger_zones)
		{
			for (int i = 0; i < maxAttempts; i++)
			{
				Vector3 val = GenerateRandomDestination();
				if (!IsInNoGoZone(val))
				{
					return val;
				}
			}
			Vector3 val2 = GenerateRandomDestination(forceMonument: true);
			if (IsInNoGoZone(val2))
			{
				noGoZones?.Clear();
			}
			return val2;
		}
		return GenerateRandomDestination();
	}

	public Vector3 GenerateRandomDestination(bool forceMonument = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		bool flag = Random.Range(0f, 1f) >= 0.6f;
		if (forceMonument)
		{
			flag = true;
		}
		if (flag)
		{
			if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
			{
				MonumentInfo monumentInfo = null;
				if (_visitedMonuments.Count > 0)
				{
					foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
					{
						if (monument.IsSafeZone)
						{
							continue;
						}
						bool flag2 = false;
						foreach (MonumentInfo visitedMonument in _visitedMonuments)
						{
							if ((Object)(object)monument == (Object)(object)visitedMonument)
							{
								flag2 = true;
							}
						}
						if (!flag2)
						{
							monumentInfo = monument;
							break;
						}
					}
				}
				if ((Object)(object)monumentInfo == (Object)null)
				{
					_visitedMonuments.Clear();
					for (int i = 0; i < 5; i++)
					{
						monumentInfo = TerrainMeta.Path.Monuments[Random.Range(0, TerrainMeta.Path.Monuments.Count)];
						if (!monumentInfo.IsSafeZone)
						{
							break;
						}
					}
				}
				if (Object.op_Implicit((Object)(object)monumentInfo))
				{
					val = ((Component)monumentInfo).transform.position;
					_visitedMonuments.Add(monumentInfo);
					val.y = TerrainMeta.HeightMap.GetHeight(val) + 200f;
					if (TransformUtil.GetGroundInfo(val, out var hitOut, 300f, LayerMask.op_Implicit(1235288065)))
					{
						val.y = ((RaycastHit)(ref hitOut)).point.y;
					}
					val.y += 45f;
				}
			}
			else
			{
				val = GetRandomMapPosition();
			}
		}
		else
		{
			val = GetRandomMapPosition();
		}
		return val;
	}

	public void State_Patrol_Think(float timePassed)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3Ex.Distance2D(((Component)this).transform.position, destination);
		if (num <= 25f)
		{
			targetThrottleSpeed = GetThrottleForDistance(num);
		}
		else
		{
			targetThrottleSpeed = 0.5f;
		}
		if (AtDestination() && arrivalTime == 0f)
		{
			arrivalTime = Time.realtimeSinceStartup;
			ExitCurrentState();
			maxOrbitDuration = 20f;
			State_Orbit_Enter(75f);
		}
		if (_targetList.Count > 0)
		{
			if (use_danger_zones)
			{
				Vector3? val = FindTargetWithZones();
				if (val.HasValue)
				{
					interestZoneOrigin = val.Value;
					OrbitInterestZone();
				}
			}
			else
			{
				interestZoneOrigin = FindDefaultTarget();
				OrbitInterestZone();
			}
		}
		else
		{
			interestZoneOrigin = ((Component)this).transform.position;
		}
	}

	private void OrbitInterestZone()
	{
		ExitCurrentState();
		maxOrbitDuration = 10f;
		State_Orbit_Enter(80f);
	}

	public void State_Patrol_Enter()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.PATROL;
		Vector3 randomPatrolDestination = GetRandomPatrolDestination();
		SetTargetDestination(randomPatrolDestination, 10f);
		interestZoneOrigin = randomPatrolDestination;
		arrivalTime = 0f;
	}

	public void State_Patrol_Leave()
	{
	}

	public float GetPlaneHeight()
	{
		return 50f;
	}

	private Vector3 GetRandomMapPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float planeHeight = GetPlaneHeight();
		Vector3 val = Vector3Ex.Range(-0.7f, 0.7f);
		val.y = 0f;
		((Vector3)(ref val)).Normalize();
		val *= x * Random.Range(0f, 0.75f);
		val.y = planeHeight;
		return val;
	}

	public int ClipRocketsLeft()
	{
		return numRocketsLeft;
	}

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (Time.realtimeSinceStartup - lastStrafeTime >= Random.Range(15f, 25f))
		{
			return CanInterruptState();
		}
		return false;
	}

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return Time.realtimeSinceStartup - lastNapalmTime >= Random.Range(25f, 35f);
	}

	public void State_Strafe_Enter(BasePlayer strafeTarget, bool shouldUseNapalm = false)
	{
		StartStrafe(strafeTarget, shouldUseNapalm);
	}

	public void State_Strafe_Think(float timePassed)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (puttingDistance)
		{
			if (AtDestination())
			{
				RefreshTargetPosition();
				SetIdealRotation(GetYawRotationTo(strafe_target_position), 1.2f);
				if (AtRotation())
				{
					puttingDistance = false;
					cached_strafe_pos = strafe_target_position;
					SetTargetDestination(strafe_target_position + new Vector3(0f, 40f, 0f), 10f);
				}
			}
			return;
		}
		RefreshTargetPosition();
		SetIdealRotation(GetYawRotationTo(strafe_target_position));
		float num = Vector3Ex.Distance2D(cached_strafe_pos, ((Component)this).transform.position);
		if (num <= 150f && ClipRocketsLeft() > 0 && Time.realtimeSinceStartup - lastRocketTime > timeBetweenRockets && CanSeeForStrafe(strafe_target_position))
		{
			FireRocket(strafe_target_position);
		}
		if (num <= get_out_of_strafe_distance || ClipRocketsLeft() <= 0)
		{
			if (Random.value > 0.6f && (Object)(object)strafe_target != (Object)null)
			{
				ExitCurrentState();
				State_OrbitStrafe_Enter();
			}
			else
			{
				ExitCurrentState();
				State_Move_Enter(GetAppropriatePosition(strafe_target_position + ((Component)this).transform.forward * 120f));
			}
		}
	}

	private Vector3 GetPredictedPosition()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = strafe_target_position;
		float num = TimeSince.op_Implicit(timeSinceRefreshed);
		RefreshTargetPosition();
		Vector3 val2 = strafe_target_position;
		return val2 + (val2 - val) * (num / Time.deltaTime);
	}

	private bool CanSeeForStrafe(Vector3 targetPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(targetPos, ((Component)this).transform.position) - 10f;
		if (num < 0f)
		{
			num = 0f;
		}
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = targetPos - ((Component)this).transform.position;
		return !Physics.Raycast(position, ((Vector3)(ref val)).normalized, num, LayerMask.GetMask(new string[2] { "Terrain", "World" }));
	}

	public bool ValidRocketTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", (object)this, (object)ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)ply == (Object)null)
		{
			return false;
		}
		return !ply.IsNearEnemyBase();
	}

	public void State_Strafe_Leave()
	{
		lastStrafeTime = Time.realtimeSinceStartup;
		if (useNapalm)
		{
			lastNapalmTime = Time.realtimeSinceStartup;
		}
		useNapalm = false;
		movementLockingAiming = false;
	}

	private void StartStrafe(BasePlayer strafeTarget, bool shouldUseNapalm = false)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnHelicopterStrafeEnter", (object)this, (object)((Component)strafeTarget).transform.position, (object)strafeTarget) == null)
		{
			strafe_target = strafeTarget;
			get_out_of_strafe_distance = Random.Range(13f, 17f);
			if (CanUseNapalm() && shouldUseNapalm)
			{
				passNapalm = shouldUseNapalm;
				useNapalm = true;
				lastNapalmTime = Time.realtimeSinceStartup;
			}
			lastStrafeTime = Time.realtimeSinceStartup;
			_currentState = aiState.STRAFE;
			RefreshTargetPosition();
			numRocketsLeft = 12 + Random.Range(-1, 1);
			lastRocketTime = 0f;
			movementLockingAiming = true;
			Vector3 randomOffset = GetRandomOffset(strafe_target_position, 175f, 192.5f);
			SetTargetDestination(randomOffset, 10f);
			SetIdealRotation(GetYawRotationTo(randomOffset));
			puttingDistance = true;
		}
	}

	public void FireRocket(Vector3 targetPos)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		numRocketsLeft--;
		lastRocketTime = Time.realtimeSinceStartup;
		float num = Random.Range(3.9f, 4.1f);
		bool flag = leftTubeFiredLast;
		leftTubeFiredLast = !leftTubeFiredLast;
		Transform val = (flag ? helicopterBase.rocket_tube_left.transform : helicopterBase.rocket_tube_right.transform);
		Vector3 val2 = val.position + val.forward * 1f;
		Vector3 val3 = targetPos - val2;
		Vector3 val4 = ((Vector3)(ref val3)).normalized;
		if (num > 0f)
		{
			val4 = AimConeUtil.GetModifiedAimConeDirection(num, val4);
		}
		Effect.server.Run(helicopterBase.rocket_fire_effect.resourcePath, helicopterBase, StringPool.Get(flag ? "rocket_tube_left" : "rocket_tube_right"), Vector3.zero, Vector3.forward, null, broadcast: true);
		BaseEntity baseEntity = GameManager.server.CreateEntity(useNapalm ? rocketProjectile_Napalm.resourcePath : rocketProjectile.resourcePath, val2);
		if (!((Object)(object)baseEntity == (Object)null))
		{
			ServerProjectile component = ((Component)baseEntity).GetComponent<ServerProjectile>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.InitializeVelocity(val4 * component.speed);
			}
			baseEntity.Spawn();
		}
	}

	private void RefreshTargetPosition()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)strafe_target == (Object)null))
		{
			timeSinceRefreshed = TimeSince.op_Implicit(0f);
			int mask = LayerMask.GetMask(new string[5] { "Terrain", "World", "Construction", "Water", "Vehicle Large" });
			if (TransformUtil.GetGroundInfo(((Component)strafe_target).transform.position, out var pos, out var _, 100f, LayerMask.op_Implicit(mask), ((Component)this).transform))
			{
				strafe_target_position = pos;
			}
			else
			{
				strafe_target_position = ((Component)strafe_target).transform.position;
			}
		}
	}

	public void InitializeAI()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		_lastThinkTime = Time.realtimeSinceStartup;
		timeSinceRestrictedPatrolSize = TimeSince.op_Implicit(0f);
	}

	public void OnCurrentStateExit()
	{
		switch (_currentState)
		{
		default:
			State_Idle_Leave();
			break;
		case aiState.MOVE:
			State_Move_Leave();
			break;
		case aiState.STRAFE:
			State_Strafe_Leave();
			break;
		case aiState.ORBIT:
			State_Orbit_Leave();
			break;
		case aiState.ORBITSTRAFE:
			State_OrbitStrafe_Leave();
			break;
		case aiState.FLEE:
			State_Flee_Leave();
			break;
		case aiState.PATROL:
			State_Patrol_Leave();
			break;
		}
	}

	public void ExitCurrentState()
	{
		if (isRetiring || isDead)
		{
			if (shouldDebug)
			{
				Debug.Log((object)"Patrol Helicopter attempting to exit state whilst retiring/dying.");
			}
		}
		else
		{
			OnCurrentStateExit();
			_currentState = aiState.IDLE;
		}
	}

	public float GetTime()
	{
		return Time.realtimeSinceStartup;
	}

	public void AIThink()
	{
		float time = GetTime();
		float timePassed = time - _lastThinkTime;
		_lastThinkTime = time;
		switch (_currentState)
		{
		default:
			State_Idle_Think(timePassed);
			break;
		case aiState.MOVE:
			State_Move_Think(timePassed);
			break;
		case aiState.STRAFE:
			State_Strafe_Think(timePassed);
			break;
		case aiState.ORBIT:
			State_Orbit_Think(timePassed);
			break;
		case aiState.PATROL:
			State_Patrol_Think(timePassed);
			break;
		case aiState.ORBITSTRAFE:
			State_OrbitStrafe_Think(timePassed);
			break;
		case aiState.FLEE:
			State_Flee_Think(timePassed);
			break;
		case aiState.DEATH:
			State_Death_Think(timePassed);
			break;
		}
	}

	public Vector3 GetRandomOffset(Vector3 origin, float minRange, float maxRange = 0f, float minHeight = 50f, float maxHeight = 60f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 onUnitSphere = Random.onUnitSphere;
		onUnitSphere.y = 0f;
		((Vector3)(ref onUnitSphere)).Normalize();
		maxRange = Mathf.Max(minRange, maxRange);
		Vector3 origin2 = origin + onUnitSphere * Random.Range(minRange, maxRange);
		return GetAppropriatePosition(origin2, minHeight, maxHeight);
	}

	public Vector3 GetAppropriatePosition(Vector3 origin, float minHeight = 50f, float maxHeight = 60f)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		float num = 100f;
		Ray val = default(Ray);
		((Ray)(ref val))..ctor(origin + new Vector3(0f, num, 0f), Vector3.down);
		float num2 = 5f;
		int mask = LayerMask.GetMask(new string[4] { "Terrain", "World", "Construction", "Water" });
		RaycastHit val2 = default(RaycastHit);
		if (Physics.SphereCast(val, num2, ref val2, num * 2f - num2, mask))
		{
			origin = ((RaycastHit)(ref val2)).point;
		}
		origin.y += Random.Range(minHeight, maxHeight);
		return origin;
	}

	public float GetThrottleForDistance(float distToTarget)
	{
		float num = 0f;
		if (distToTarget >= 75f)
		{
			return 1f;
		}
		if (distToTarget >= 50f)
		{
			return 0.75f;
		}
		if (distToTarget >= 25f)
		{
			return 0.33f;
		}
		if (distToTarget >= 5f)
		{
			return 0.05f;
		}
		return 0.05f * (1f - distToTarget / 5f);
	}
}


using UnityEngine;

public class targetinfo
{
	public BasePlayer ply;

	public BaseEntity ent;

	public float lastSeenTime = float.PositiveInfinity;

	public float visibleFor;

	public float nextLOSCheck;

	public targetinfo(BaseEntity initEnt, BasePlayer initPly = null)
	{
		ply = initPly;
		ent = initEnt;
		lastSeenTime = float.PositiveInfinity;
		nextLOSCheck = Time.realtimeSinceStartup + 1.5f;
	}

	public bool IsVisible()
	{
		return TimeSinceSeen() < 1.5f;
	}

	public float TimeSinceSeen()
	{
		return Time.realtimeSinceStartup - lastSeenTime;
	}
}


using UnityEngine;

public class DangerZone
{
	public float Radius;

	public bool IsInMonument;

	private float score;

	private float lastActiveTime = Time.realtimeSinceStartup;

	private const float isStaleTime = 5f;

	private Vector3 centre;

	private BaseEntity parent;

	public Vector3 Centre
	{
		get
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)parent == (Object)null)
			{
				return centre;
			}
			return ((Component)parent).transform.TransformPoint(centre);
		}
	}

	public float Score
	{
		get
		{
			return score;
		}
		set
		{
			score = value;
			lastActiveTime = Time.realtimeSinceStartup;
		}
	}

	public float LastActiveTime => lastActiveTime;

	public DangerZone(Vector3 centre, float radius = 20f, BaseEntity parent = null)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)parent == (Object)null)
		{
			this.centre = centre;
		}
		else
		{
			this.centre = ((Component)parent).transform.InverseTransformPoint(centre);
		}
		this.parent = parent;
		Radius = radius;
		IsInMonument = IsInsideMonument(this.centre);
	}

	public bool IsPointInside(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Distance(point, Centre) <= Radius;
	}

	public bool IsStale()
	{
		return Time.realtimeSinceStartup - lastActiveTime > 5f;
	}

	public Vector3 GetNearestEdge(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = point - Centre;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		normalized.y = 0f;
		return Centre + normalized * Radius;
	}
}


public enum aiState
{
	IDLE,
	MOVE,
	ORBIT,
	STRAFE,
	PATROL,
	ORBITSTRAFE,
	GUARD,
	FLEE,
	DEATH
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class ServerGib : BaseCombatEntity
{
	public GameObject _gibSource;

	public string _gibName;

	public PhysicMaterial physicsMaterial;

	public bool useContinuousCollision;

	private MeshCollider meshCollider;

	private Rigidbody rigidBody;

	public override float BoundsPadding()
	{
		return 3f;
	}

	public static List<ServerGib> CreateGibs(string entityToCreatePath, GameObject creator, GameObject gibSource, Vector3 inheritVelocity, float spreadVelocity)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		List<ServerGib> list = new List<ServerGib>();
		MeshRenderer[] componentsInChildren = gibSource.GetComponentsInChildren<MeshRenderer>(true);
		foreach (MeshRenderer val in componentsInChildren)
		{
			MeshFilter component = ((Component)val).GetComponent<MeshFilter>();
			Vector3 val2 = ((Component)val).transform.localPosition;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			Matrix4x4 localToWorldMatrix = creator.transform.localToWorldMatrix;
			Vector3 val3 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint(((Component)val).transform.localPosition) + normalized * 0.5f;
			Quaternion val4 = creator.transform.rotation * ((Component)val).transform.localRotation;
			BaseEntity baseEntity = GameManager.server.CreateEntity(entityToCreatePath, val3, val4);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				ServerGib component2 = ((Component)baseEntity).GetComponent<ServerGib>();
				((Component)component2).transform.SetPositionAndRotation(val3, val4);
				component2._gibName = ((Object)val).name;
				MeshCollider component3 = ((Component)val).GetComponent<MeshCollider>();
				Mesh physicsMesh = (((Object)(object)component3 != (Object)null) ? component3.sharedMesh : component.sharedMesh);
				component2.PhysicsInit(physicsMesh);
				val2 = ((Component)val).transform.localPosition;
				Vector3 val5 = ((Vector3)(ref val2)).normalized * spreadVelocity;
				component2.rigidBody.velocity = inheritVelocity + val5;
				Rigidbody obj = component2.rigidBody;
				val2 = Vector3Ex.Range(-1f, 1f);
				obj.angularVelocity = ((Vector3)(ref val2)).normalized * 1f;
				component2.rigidBody.WakeUp();
				component2.Spawn();
				list.Add(component2);
			}
		}
		foreach (ServerGib item in list)
		{
			foreach (ServerGib item2 in list)
			{
				if (!((Object)(object)item == (Object)(object)item2))
				{
					Physics.IgnoreCollision((Collider)(object)item2.GetCollider(), (Collider)(object)item.GetCollider(), true);
				}
			}
		}
		Interface.CallHook("OnGibsSpawned", (object)list, (object)creator);
		return list;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk && _gibName != "")
		{
			info.msg.servergib = Pool.Get<ServerGib>();
			info.msg.servergib.gibName = _gibName;
		}
	}

	public MeshCollider GetCollider()
	{
		if ((Object)(object)meshCollider == (Object)null)
		{
			meshCollider = ((Component)this).GetComponent<MeshCollider>();
		}
		if ((Object)(object)meshCollider == (Object)null)
		{
			meshCollider = ((Component)this).GetComponentInChildren<MeshCollider>();
		}
		return meshCollider;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 1800f);
	}

	public void RemoveMe()
	{
		Kill();
	}

	public virtual void PhysicsInit(Mesh physicsMesh)
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		Mesh sharedMesh = null;
		MeshFilter component = ((Component)this).gameObject.GetComponent<MeshFilter>();
		if ((Object)(object)component != (Object)null)
		{
			sharedMesh = component.sharedMesh;
			component.sharedMesh = physicsMesh;
		}
		meshCollider = ((Component)this).gameObject.AddComponent<MeshCollider>();
		meshCollider.sharedMesh = physicsMesh;
		meshCollider.convex = true;
		((Collider)meshCollider).material = physicsMaterial;
		if ((Object)(object)component != (Object)null)
		{
			component.sharedMesh = sharedMesh;
		}
		Rigidbody val = ((Component)this).gameObject.AddComponent<Rigidbody>();
		val.useGravity = true;
		Bounds val2 = ((Collider)meshCollider).bounds;
		Vector3 size = ((Bounds)(ref val2)).size;
		float magnitude = ((Vector3)(ref size)).magnitude;
		val2 = ((Collider)meshCollider).bounds;
		size = ((Bounds)(ref val2)).size;
		val.mass = Mathf.Clamp(magnitude * ((Vector3)(ref size)).magnitude * 20f, 10f, 2000f);
		val.interpolation = (RigidbodyInterpolation)1;
		val.collisionDetectionMode = (CollisionDetectionMode)(useContinuousCollision ? 2 : 0);
		if (base.isServer)
		{
			val.drag = 0.1f;
			val.angularDrag = 0.1f;
		}
		rigidBody = val;
		((Component)this).gameObject.layer = LayerMask.NameToLayer("Default");
		if (base.isClient)
		{
			val.isKinematic = true;
		}
	}
}


using System;

public class TimedUnlootableCrate : LootContainer
{
	public bool unlootableOnSpawn = true;

	public float unlootableDuration = 300f;

	public override void ServerInit()
	{
		base.ServerInit();
		if (unlootableOnSpawn)
		{
			SetUnlootableFor(unlootableDuration);
		}
	}

	public void SetUnlootableFor(float duration)
	{
		SetFlag(Flags.OnFire, b: true);
		SetFlag(Flags.Locked, b: true);
		unlootableDuration = duration;
		((FacepunchBehaviour)this).Invoke((Action)MakeLootable, duration);
	}

	public void MakeLootable()
	{
		SetFlag(Flags.OnFire, b: false);
		SetFlag(Flags.Locked, b: false);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PlanterBoxStatic : PlanterBox
{
	[ServerVar(Help = "Chance of a favourable gene being picked [0-1]. Setting this to 0 does not ensure no favourable genes are picked up, but it greatly reduces the chances.")]
	public static float FavourableGeneChance = 0.5f;

	public List<GameObjectRef> staticPlantsSpawnlist;

	public bool randomPerSlot;

	public float respawnCheckTimer = 30f;

	public override void SetupTimeCaches()
	{
	}

	public override void RefreshGrowables(GrowableEntity ignoreEntity = null)
	{
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)CreateStaticPlants, 1f, respawnCheckTimer);
	}

	public void CreateStaticPlants()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		soilSaturation = soilSaturationMax;
		GameObjectRef randomStaticPlant = GetRandomStaticPlant();
		Socket_Base[] array = PrefabAttribute.server.FindAll<Socket_Base>(prefabID);
		foreach (Socket_Base socket_Base in array)
		{
			if (socket_Base is Socket_Specific_Female && IsSpawnPointFreeSearch(socket_Base.localPosition))
			{
				if (randomPerSlot)
				{
					randomStaticPlant = GetRandomStaticPlant();
				}
				Vector3 pos = ((Component)this).transform.TransformPoint(socket_Base.localPosition);
				BaseEntity baseEntity = GameManager.server.CreateEntity(randomStaticPlant.resourcePath, pos, Quaternion.identity);
				baseEntity.SetParent(this, worldPositionStays: true);
				baseEntity.Spawn();
				GrowableEntity growableEntity = baseEntity as GrowableEntity;
				if ((Object)(object)growableEntity != (Object)null)
				{
					growableEntity.Fertilize();
					growableEntity.SetGodQuality(qual: true);
					growableEntity.SetMaxGrowingConditions();
					growableEntity.Genes.GenerateFavourableGenes(growableEntity);
					growableEntity.SendNetworkUpdate();
					OnPlantInserted(growableEntity, null);
				}
			}
		}
	}

	private GameObjectRef GetRandomStaticPlant()
	{
		if (staticPlantsSpawnlist == null || staticPlantsSpawnlist.Count == 0)
		{
			return null;
		}
		int index = Random.Range(0, staticPlantsSpawnlist.Count);
		return staticPlantsSpawnlist[index];
	}

	private bool IsSpawnPointFreeSearch(Vector3 localPos)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		foreach (BaseEntity child in children)
		{
			if (child is GrowableEntity && Vector3.Distance(((Component)child).transform.localPosition, localPos) < 0.05f)
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SeekerTarget
{
	public enum SeekerStrength
	{
		OFF = 0,
		LOW = 100,
		MEDIUM = 200,
		HIGH = 1000,
		HIGHEST = 1000
	}

	public interface ISeekerTargetOwner
	{
		Vector3 CenterPoint();

		bool InSafeZone();

		bool IsValidHomingTarget();

		bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

		void OnEntityMessage(BaseEntity from, string msg);
	}

	[NonSerialized]
	public SeekerStrength strength;

	public ISeekerTargetOwner owner;

	private static Dictionary<ISeekerTargetOwner, SeekerTarget> seekerTargets = new Dictionary<ISeekerTargetOwner, SeekerTarget>();

	public bool IsValidTarget()
	{
		if (owner.IsUnityNull())
		{
			return false;
		}
		if (!owner.InSafeZone())
		{
			return owner.IsValidHomingTarget();
		}
		return false;
	}

	public bool TryGetPosition(out Vector3 result)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (owner.IsUnityNull())
		{
			result = Vector3.zero;
			return false;
		}
		result = owner.CenterPoint();
		return true;
	}

	public void SendOwnerMessage(BaseEntity from, string message)
	{
		if (!owner.IsUnityNull())
		{
			owner.OnEntityMessage(from, message);
		}
	}

	public static SeekerTarget GetBestForPoint(Vector3 from, Vector3 forward, float maxCone, float maxDist, SeekerStrength minStrength = SeekerStrength.LOW)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		SeekerTarget result = null;
		float num = 0f;
		foreach (KeyValuePair<ISeekerTargetOwner, SeekerTarget> seekerTarget in seekerTargets)
		{
			ISeekerTargetOwner key = seekerTarget.Key;
			SeekerTarget value = seekerTarget.Value;
			if (value.strength < minStrength || !value.IsValidTarget() || !value.TryGetPosition(out var result2))
			{
				continue;
			}
			Vector3 val = Vector3Ex.Direction(result2, from);
			float num2 = Vector3.Dot(forward, val);
			float num3 = Vector3.Distance(result2, from);
			if (num3 < maxDist && num2 > maxCone)
			{
				float num4 = 1f - num3 / maxDist * 0.3f;
				float num5 = num2 / maxCone * 1f;
				float num6 = (float)value.strength / 1000f * 0.5f;
				float num7 = num4 + num5 + num6;
				if (num7 > num && key.IsVisible(from, maxDist))
				{
					result = value;
					num = num7;
				}
			}
		}
		return result;
	}

	public static void SetSeekerTarget(ISeekerTargetOwner toAdd, SeekerStrength strength)
	{
		if (strength == SeekerStrength.OFF)
		{
			if (seekerTargets.ContainsKey(toAdd))
			{
				seekerTargets.Remove(toAdd);
			}
		}
		else if (!seekerTargets.ContainsKey(toAdd))
		{
			SeekerTarget value = new SeekerTarget
			{
				strength = strength,
				owner = toAdd
			};
			seekerTargets.Add(toAdd, value);
		}
	}
}


public enum SeekerStrength
{
	OFF = 0,
	LOW = 100,
	MEDIUM = 200,
	HIGH = 1000,
	HIGHEST = 1000
}


using UnityEngine;

public interface ISeekerTargetOwner
{
	Vector3 CenterPoint();

	bool InSafeZone();

	bool IsValidHomingTarget();

	bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

	void OnEntityMessage(BaseEntity from, string msg);
}


using System;
using UnityEngine;

public class SeekingServerProjectile : ServerProjectile
{
	public float courseAdjustRate = 1f;

	public float maxTrackDistance = 500f;

	public float minLockDot;

	public float flareLockDot = 0.6f;

	public bool autoSeek;

	public float swimAfter = 6f;

	public float launchingDuration = 0.15f;

	public float armingDuration = 0.75f;

	public float velocityRampUpTime = 6f;

	public Vector3 armingFinalDir;

	public AnimationCurve airmingDirCurve;

	public AnimationCurve armingVelocityCurve;

	public float armingVelocity;

	public AnimationCurve velocityCurve;

	public float orphanedVectorChangeRate = 30f;

	public SeekerTarget lockedTarget;

	private float nextTargetUpdateTime = float.NegativeInfinity;

	private Vector3 seekingDestination;

	private float launchTime;

	private Vector3 initialDir = Vector3.forward;

	private bool orphanedProjectile;

	private Vector3 orphanedTargetVector;

	private Vector3 orphanedRotationAxis;

	public float totalArmingPhaseDuration => launchingDuration + armingDuration;

	public void NotifyOrphaned()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		orphanedProjectile = true;
		orphanedTargetVector = Random.onUnitSphere;
	}

	public virtual void UpdateTarget()
	{
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		if (orphanedProjectile)
		{
			lockedTarget = null;
			return;
		}
		if (Time.realtimeSinceStartup >= nextTargetUpdateTime)
		{
			if (autoSeek)
			{
				lockedTarget = SeekerTarget.GetBestForPoint(((Component)this).transform.position, ((Component)this).transform.forward, minLockDot, maxTrackDistance);
			}
			else
			{
				SeekerTarget bestForPoint = SeekerTarget.GetBestForPoint(((Component)this).transform.position, ((Component)this).transform.forward, flareLockDot, maxTrackDistance, SeekerTarget.SeekerStrength.HIGH);
				if (bestForPoint != null)
				{
					lockedTarget = bestForPoint;
				}
			}
			nextTargetUpdateTime = Time.realtimeSinceStartup + 0.1f;
		}
		if (lockedTarget != null && lockedTarget.TryGetPosition(out var result))
		{
			seekingDestination = result;
		}
		else
		{
			seekingDestination = ((Component)this).transform.position + ((Component)this).transform.forward * 1000f;
		}
		if (lockedTarget != null)
		{
			lockedTarget.SendOwnerMessage(base.baseEntity, "RadarLock");
		}
	}

	public Vector3 GetSeekingDestination()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return seekingDestination;
	}

	public override bool DoMovement()
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		float num = TimeSinceLaunch();
		if (!(num < launchingDuration))
		{
			if (num < totalArmingPhaseDuration)
			{
				float num2 = num - launchingDuration;
				Vector3 val = Vector3.Lerp(initialDir, armingFinalDir, Mathf.Clamp01(num2 / armingDuration));
				base.CurrentVelocity = val * armingVelocity * armingVelocityCurve.Evaluate(num);
			}
			else
			{
				UpdateTarget();
				Vector3 val2 = base.CurrentVelocity;
				Vector3 normalized = ((Vector3)(ref val2)).normalized;
				Vector3 normalized2;
				if (orphanedProjectile)
				{
					normalized2 = orphanedTargetVector;
					orphanedTargetVector = Quaternion.AngleAxis(orphanedVectorChangeRate * Time.deltaTime, orphanedRotationAxis) * orphanedTargetVector;
					if (Random.value < 0.02f)
					{
						PickNewRotationAxis();
					}
				}
				else
				{
					val2 = GetSeekingDestination() - ((Component)this).transform.position;
					normalized2 = ((Vector3)(ref val2)).normalized;
				}
				Vector3 val3 = Vector3.MoveTowards(normalized, normalized2, Time.fixedDeltaTime * courseAdjustRate);
				((Vector3)(ref val3)).Normalize();
				float num3 = armingVelocity + velocityCurve.Evaluate(TimeSinceArmed() / velocityRampUpTime) * speed;
				base.CurrentVelocity = val3 * num3;
			}
		}
		return base.DoMovement();
	}

	public float TimeSinceArmed()
	{
		return TimeSinceLaunch() - totalArmingPhaseDuration;
	}

	public float TimeSinceLaunch()
	{
		return Mathf.Max(Time.time - launchTime, 0f);
	}

	public void EnableBoosters()
	{
		base.baseEntity.SetFlag(BaseEntity.Flags.On, b: true);
		((FacepunchBehaviour)this).Invoke((Action)DisableBoosters, 1f);
	}

	public void DisableBoosters()
	{
		base.baseEntity.SetFlag(BaseEntity.Flags.On, b: false);
	}

	public override void InitializeVelocity(Vector3 overrideVel)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normalized = ((Vector3)(ref overrideVel)).normalized;
		launchTime = Time.time;
		initialDir = normalized;
		((FacepunchBehaviour)this).Invoke((Action)EnableBoosters, 0.5f);
		base.InitializeVelocity(overrideVel);
	}

	private void PickNewRotationAxis()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(orphanedTargetVector, Random.onUnitSphere);
		orphanedRotationAxis = ((Vector3)(ref val)).normalized;
	}
}


using System;
using System.Linq;
using Rust.Workshop;
using UnityEngine;

public static class SkinHelpers
{
	public static void SetSkin(GameObject itemModel, ItemDefinition itemDef, ulong skinID)
	{
		if ((Object)(object)itemDef == (Object)null)
		{
			return;
		}
		ItemSkinDirectory.Skin skin = itemDef.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == skinID);
		if ((ulong)skin.id == skinID)
		{
			ItemSkin itemSkin = skin.invItem as ItemSkin;
			if ((Object)(object)itemSkin != (Object)null)
			{
				itemSkin.ApplySkin(itemModel);
			}
		}
		else if (skinID != 0L)
		{
			WorkshopSkin.Apply(itemModel, skinID, (Action<Skin>)null, (Action)null);
		}
	}
}


public class SmokeBomb : TimedExplosive
{
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SmokeGrenade : TimedExplosive
{
	public float smokeDuration = 45f;

	public GameObjectRef smokeEffectPrefab;

	public GameObjectRef igniteSound;

	public SoundPlayer soundLoop;

	private GameObject smokeEffectInstance;

	public static List<SmokeGrenade> activeGrenades = new List<SmokeGrenade>();

	public float fieldMin = 5f;

	public float fieldMax = 8f;

	protected bool killing;

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckForWater, 1f, 1f);
	}

	public override void Explode()
	{
		if (WaterFactor() >= 0.5f)
		{
			FinishUp();
		}
		else if (!IsOn())
		{
			((FacepunchBehaviour)this).Invoke((Action)FinishUp, smokeDuration);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Open, b: true);
			InvalidateNetworkCache();
			SendNetworkUpdateImmediate();
			activeGrenades.Add(this);
			SingletonComponent<SmokeGrenadeManager>.Instance.Add(this);
		}
	}

	public void CheckForWater()
	{
		if (WaterFactor() >= 0.5f)
		{
			FinishUp();
		}
	}

	public void FinishUp()
	{
		if (!killing)
		{
			Kill();
			killing = true;
		}
	}

	public override void DestroyShared()
	{
		SingletonComponent<SmokeGrenadeManager>.Instance.Remove(this);
		activeGrenades.Remove(this);
		base.DestroyShared();
	}
}


using System;
using System.Collections.Generic;
using Spatial;
using UnityEngine;

public class SmokeGrenadeManager : SingletonComponent<SmokeGrenadeManager>
{
	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private Grid<BaseEntity> smokeGrid = new Grid<BaseEntity>(32, 8096f);

	public void Add(BaseEntity smoke)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (IsSmokeGrenade(smoke))
		{
			smokeGrid.Add(smoke, ((Component)smoke).transform.position.x, ((Component)smoke).transform.position.z);
		}
	}

	public void Move(BaseEntity smoke)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SmokeGrenadeManager.Move", 0);
		try
		{
			if (IsSmokeGrenade(smoke))
			{
				Vector3 position = ((Component)smoke).transform.position;
				smokeGrid.Move(smoke, position.x, position.z);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Remove(BaseEntity smoke)
	{
		if (IsSmokeGrenade(smoke))
		{
			smokeGrid.Remove(smoke);
		}
	}

	public void GetSmokeAround(Vector3 position, float range, List<BaseEntity> results)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SmokeGrenadeManager.GetSmokeAround", 0);
		try
		{
			if (smokeGrid != null)
			{
				smokeGrid.Query<BaseEntity>(position.x, position.z, range, results);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsSmokeGrenade(BaseEntity entity)
	{
		if (entity is SmokeGrenade)
		{
			return true;
		}
		return false;
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class SphereEntity : BaseEntity
{
	public float currentRadius = 1f;

	public float lerpRadius = 1f;

	public float lerpSpeed = 1f;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.sphereEntity = Pool.Get<SphereEntity>();
		info.msg.sphereEntity.radius = currentRadius;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer)
		{
			if (info.msg.sphereEntity != null)
			{
				currentRadius = (lerpRadius = info.msg.sphereEntity.radius);
			}
			UpdateScale();
		}
	}

	public void LerpRadiusTo(float radius, float speed)
	{
		lerpRadius = radius;
		lerpSpeed = speed;
	}

	public void UpdateScale()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = new Vector3(currentRadius, currentRadius, currentRadius);
	}

	public void Update()
	{
		if (currentRadius != lerpRadius && base.isServer)
		{
			currentRadius = Mathf.MoveTowards(currentRadius, lerpRadius, Time.deltaTime * lerpSpeed);
			UpdateScale();
			SendNetworkUpdate();
		}
	}
}


using UnityEngine;

public class StaticMissionItemDispenser : StorageContainer
{
	public override void ServerInit()
	{
		base.ServerInit();
		if (base.inventory != null)
		{
			base.inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (base.CanBeLooted(player))
		{
			return HasValidMission(player);
		}
		return false;
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		BaseMission.MissionInstance activeMissionInstance = player.GetActiveMissionInstance();
		if (activeMissionInstance != null)
		{
			for (int i = 0; i < activeMissionInstance.objectiveStatuses.Length; i++)
			{
				if (activeMissionInstance.objectiveStatuses[i].started && activeMissionInstance.GetMission().objectives[i].objective is MissionObjective_AcquireItem missionObjective_AcquireItem)
				{
					base.inventory.AddItem(missionObjective_AcquireItem.targetItem, missionObjective_AcquireItem.targetItemAmount, 0uL);
				}
			}
		}
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.inventory.Clear();
		base.PlayerStoppedLooting(player);
	}

	private bool HasValidMission(BasePlayer player)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		BaseMission.MissionInstance activeMissionInstance = player.GetActiveMissionInstance();
		if (activeMissionInstance != null)
		{
			for (int i = 0; i < activeMissionInstance.objectiveStatuses.Length; i++)
			{
				if (!activeMissionInstance.objectiveStatuses[i].started || activeMissionInstance.objectiveStatuses[i].completed || !(activeMissionInstance.GetMission().objectives[i].objective is MissionObjective_AcquireItem missionObjective_AcquireItem))
				{
					continue;
				}
				if (!string.IsNullOrEmpty(missionObjective_AcquireItem.requireProximityToPosition) && base.isServer)
				{
					if (!activeMissionInstance.missionPoints.ContainsKey(missionObjective_AcquireItem.requireProximityToPosition))
					{
						return false;
					}
					if (Vector3.Distance(activeMissionInstance.missionPoints[missionObjective_AcquireItem.requireProximityToPosition], ((Component)this).transform.position) > 3f)
					{
						return false;
					}
				}
				return true;
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class StaticRespawnArea : SleepingBag
{
	public Transform[] spawnAreas;

	public bool allowHostileSpawns;

	public bool requireAuth;

	[NonSerialized]
	private HashSet<ulong> authorizedUsers = new HashSet<ulong>();

	public static HashSet<StaticRespawnArea> staticRespawnAreas = new HashSet<StaticRespawnArea>();

	public override void ServerInit()
	{
		base.ServerInit();
		staticRespawnAreas.Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		staticRespawnAreas.Remove(this);
	}

	public bool IsAuthed(ulong playerID)
	{
		if (!requireAuth)
		{
			return true;
		}
		return authorizedUsers.Contains(playerID);
	}

	public void Authorize(ulong playerID)
	{
		authorizedUsers.Add(playerID);
	}

	public void Deauthorize(ulong playerID)
	{
		authorizedUsers.Remove(playerID);
	}

	public override bool ValidForPlayer(ulong playerID, bool ignoreTimers)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(playerID);
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
		{
			return false;
		}
		if (ignoreTimers || allowHostileSpawns)
		{
			return true;
		}
		return basePlayer.GetHostileDuration() <= 0f;
	}

	public override void GetSpawnPos(out Vector3 pos, out Quaternion rot)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		Transform val = spawnAreas[Random.Range(0, spawnAreas.Length)];
		pos = ((Component)val).transform.position + spawnOffset;
		Quaternion rotation = ((Component)val).transform.rotation;
		rot = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
	}

	public override void SetUnlockTime(float newTime)
	{
		unlockTime = 0f;
	}

	public override float GetUnlockSeconds(ulong playerID)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(playerID);
		if ((Object)(object)basePlayer == (Object)null || allowHostileSpawns)
		{
			return base.GetUnlockSeconds(playerID);
		}
		return Mathf.Max(basePlayer.GetHostileDuration(), base.GetUnlockSeconds(playerID));
	}

	public override void Save(SaveInfo info)
	{
		if (info.forDisk)
		{
			info.msg.staticRespawn = Pool.Get<StaticRespawnAreaData>();
			info.msg.staticRespawn.authorizedUsers = Pool.Get<List<ulong>>();
			info.msg.staticRespawn.authorizedUsers.AddRange(authorizedUsers);
		}
		base.Save(info);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk || info.msg.staticRespawn == null || info.msg.staticRespawn.authorizedUsers == null)
		{
			return;
		}
		authorizedUsers.Clear();
		foreach (ulong authorizedUser in info.msg.staticRespawn.authorizedUsers)
		{
			authorizedUsers.Add(authorizedUser);
		}
	}
}


using System;
using ConVar;
using Oxide.Core;
using Rust;
using UnityEngine;

public class SupplyDrop : LootContainer
{
	public const Flags FlagNightLight = Flags.Reserved1;

	private const Flags ShowParachute = Flags.Reserved2;

	public GameObject ParachuteRoot;

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SetFlag(Flags.Reserved2, b: true);
		}
		isLootable = false;
		((FacepunchBehaviour)this).Invoke((Action)MakeLootable, 300f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckNightLight, 0f, 30f);
	}

	public void RemoveParachute()
	{
		SetFlag(Flags.Reserved2, b: false);
	}

	public void MakeLootable()
	{
		isLootable = true;
	}

	private void OnCollisionEnter(Collision collision)
	{
		bool flag = ((1 << ((Component)collision.collider).gameObject.layer) & 0x40A10111) > 0;
		if (((1 << ((Component)collision.collider).gameObject.layer) & 0x8000000) > 0 && collision.GetEntity() is Tugboat)
		{
			flag = true;
		}
		if (flag)
		{
			RemoveParachute();
			MakeLootable();
		}
		Interface.CallHook("OnSupplyDropLanded", (object)this);
	}

	public void CheckNightLight()
	{
		SetFlag(Flags.Reserved1, Env.time > 20f || Env.time < 7f);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if ((Object)(object)ParachuteRoot != (Object)null)
		{
			ParachuteRoot.SetActive(next.HasFlag(Flags.Reserved2));
		}
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class SupplySignal : TimedExplosive
{
	public GameObjectRef smokeEffectPrefab;

	public GameObjectRef EntityToCreate;

	[NonSerialized]
	public GameObject smokeEffect;

	public override void Explode()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(Random.Range(-20f, 20f), 0f, Random.Range(-20f, 20f));
			((Component)baseEntity).SendMessage("InitDropPosition", (object)(((Component)this).transform.position + val), (SendMessageOptions)1);
			baseEntity.Spawn();
			Interface.CallHook("OnCargoPlaneSignaled", (object)baseEntity, (object)this);
		}
		((FacepunchBehaviour)this).Invoke((Action)FinishUp, 210f);
		SetFlag(Flags.On, b: true);
		SendNetworkUpdateImmediate();
	}

	public void FinishUp()
	{
		Kill();
	}
}


using UnityEngine;

public class TorpedoServerProjectile : ServerProjectile
{
	[SerializeField]
	[Tooltip("Make sure to leave some allowance for waves, which affect the true depth.")]
	private float minWaterDepth = 0.5f;

	[SerializeField]
	private float shallowWaterInaccuracy;

	[SerializeField]
	private float deepWaterInaccuracy;

	[SerializeField]
	private float shallowWaterCutoff = 2f;

	public override bool HasRangeLimit => false;

	protected override int mask => 1237003009;

	public override bool DoMovement()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!base.DoMovement())
		{
			return false;
		}
		float num = WaterLevel.GetWaterInfo(((Component)this).transform.position, waves: true, volumes: false).surfaceLevel - ((Component)this).transform.position.y;
		if (num < -1f)
		{
			gravityModifier = 1f;
		}
		else if (num <= minWaterDepth)
		{
			Vector3 currentVelocity = base.CurrentVelocity;
			currentVelocity.y = 0f;
			base.CurrentVelocity = currentVelocity;
			gravityModifier = 0.1f;
		}
		else if (num > minWaterDepth + 0.3f && num <= minWaterDepth + 0.7f)
		{
			gravityModifier = -0.1f;
		}
		else
		{
			gravityModifier = Mathf.Clamp(base.CurrentVelocity.y, -0.1f, 0.1f);
		}
		return true;
	}

	public override void InitializeVelocity(Vector3 overrideVel)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.InitializeVelocity(overrideVel);
		float num = WaterLevel.GetWaterInfo(((Component)this).transform.position, waves: true, volumes: false).surfaceLevel - ((Component)this).transform.position.y;
		float num2 = Mathf.InverseLerp(shallowWaterCutoff, shallowWaterCutoff + 2f, num);
		float num3 = Mathf.Lerp(shallowWaterInaccuracy, deepWaterInaccuracy, num2);
		initialVelocity = Vector3Ex.GetWithInaccuracy(initialVelocity, num3);
		base.CurrentVelocity = initialVelocity;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TrainSignal : BaseEntity
{
	public enum LightState
	{
		None,
		Green,
		Yellow,
		Red
	}

	private class SplineSection
	{
		public readonly TrainTrackSpline spline;

		public readonly float startDist;

		public readonly float endDist;

		public SplineSection(TrainTrackSpline spline, float startDist, float endDist)
		{
			this.spline = spline;
			this.startDist = startDist;
			this.endDist = endDist;
		}
	}

	[SerializeField]
	private bool testFX;

	[SerializeField]
	private VehicleLight redLight;

	[SerializeField]
	private VehicleLight yellowLight;

	[SerializeField]
	private VehicleLight greenLight;

	private const Flags Flag_Red = Flags.Reserved1;

	private const Flags Flag_Yellow = Flags.Reserved2;

	private const Flags Flag_Green = Flags.Reserved3;

	private LightState lightState;

	[NonSerialized]
	public TrainSignal nextSignal;

	private TrainTrackSpline ourSpline;

	private float ourSplineDist;

	private readonly List<SplineSection> ourSplines = new List<SplineSection>();

	private LightState prevTargetLightState;

	public float SplineDist => ourSplineDist;

	public bool HasNextSignal => (Object)(object)nextSignal != (Object)null;

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isClient)
		{
			if ((next & Flags.Reserved1) == Flags.Reserved1)
			{
				SetLightState(LightState.Red);
			}
			else if ((next & Flags.Reserved2) == Flags.Reserved2)
			{
				SetLightState(LightState.Yellow);
			}
			else if ((next & Flags.Reserved3) == Flags.Reserved3)
			{
				SetLightState(LightState.Green);
			}
		}
	}

	private void SetLightState(LightState newState)
	{
		if (lightState != newState)
		{
			lightState = newState;
			if (base.isServer)
			{
				SetFlag(Flags.Reserved1, newState == LightState.Red, recursive: false, networkupdate: false);
				SetFlag(Flags.Reserved2, newState == LightState.Yellow, recursive: false, networkupdate: false);
				SetFlag(Flags.Reserved3, newState == LightState.Green, recursive: false, networkupdate: false);
				SendNetworkUpdate_Flags();
			}
		}
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (TrainTrackSpline.TryFindTrackNear(((Component)this).transform.position, 10f, out ourSpline, out ourSplineDist))
		{
			ourSpline.RegisterSignal(this);
			((FacepunchBehaviour)this).Invoke((Action)SetUpSignal, 0f);
		}
		else
		{
			Debug.LogWarning((object)"TrainSignal found no nearby track. Disabling lights.");
			SetLightState(LightState.None);
		}
	}

	private void SetUpSignal()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ourSpline != (Object)null)
		{
			TrainTrackSpline trainTrackSpline = ourSpline;
			float prevSplineDist = ourSplineDist;
			Vector3 askerForward = -((Component)this).transform.forward;
			TrainTrackSpline.MoveRequest.SplineAction onSpline = ProcessSplineSection;
			TrainTrackSpline.MoveResult moveResult = trainTrackSpline.MoveAlongSpline(prevSplineDist, askerForward, 500f, default(TrainTrackSpline.TrackRequest), onSpline);
			if (!testFX)
			{
				RefreshLightState();
				((FacepunchBehaviour)this).InvokeRandomized((Action)RefreshLightState, 1f, 1f, 0.1f);
			}
			Debug.DrawLine(((Component)this).transform.position, moveResult.spline.GetPosition(moveResult.distAlongSpline), IsForward() ? Color.blue : Color.cyan, 1000f);
		}
		if (testFX)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)TestLights, 1f, 1f);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (ourSplines.Count > 0)
		{
			ourSplines[0].spline.DeregisterSignal(this);
		}
	}

	public void RefreshLightState()
	{
		LightState lightState = (HasOccupant() ? LightState.Red : ((!HasNextSignal) ? LightState.Green : ((nextSignal.lightState != LightState.Red) ? LightState.Green : LightState.Yellow)));
		if (lightState == LightState.Green)
		{
			if (prevTargetLightState == LightState.Green)
			{
				SetLightState(lightState);
			}
		}
		else
		{
			SetLightState(lightState);
		}
		prevTargetLightState = lightState;
	}

	private bool HasOccupant()
	{
		foreach (SplineSection ourSpline in ourSplines)
		{
			foreach (TrainTrackSpline.ITrainTrackUser trackUser in ourSpline.spline.trackUsers)
			{
				float frontWheelSplineDist = trackUser.FrontWheelSplineDist;
				if (frontWheelSplineDist >= ourSpline.startDist && frontWheelSplineDist <= ourSpline.endDist)
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool IsForward()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return ourSpline.IsForward(-((Component)this).transform.forward, ourSplineDist);
	}

	private void TestLights()
	{
		SetLightState((LightState)Random.Range(1, 4));
	}

	private TrainTrackSpline.MoveResult ProcessSplineSection(TrainTrackSpline.MoveResult result, TrainTrackSpline.MoveRequest request, TrainTrackSpline spline, float splineLength)
	{
		float num = request.distAlongSpline;
		float num2 = result.distAlongSpline;
		bool flag = true;
		float num3 = num;
		if (num2 < num)
		{
			flag = false;
			num = num2;
			num2 = num3;
		}
		TrainSignal trainSignal = null;
		float num4 = float.MaxValue;
		foreach (TrainSignal signal in spline.signals)
		{
			if (!((Object)(object)signal == (Object)(object)this) && signal.IsValid() && signal.IsForward() == flag && signal.SplineDist >= num && signal.SplineDist <= num2)
			{
				float num5 = Mathf.Abs(signal.SplineDist - num3);
				if (result.totalDistMoved + num5 >= 5f && num5 < num4)
				{
					trainSignal = signal;
					num4 = num5;
				}
			}
		}
		if ((Object)(object)trainSignal != (Object)null)
		{
			result.distAlongSpline = trainSignal.SplineDist;
			if ((Object)(object)trainSignal != (Object)null)
			{
				nextSignal = trainSignal;
			}
		}
		float num6 = Mathf.Clamp(request.distAlongSpline, 0f, splineLength);
		float num7 = Mathf.Clamp(result.distAlongSpline, 0f, splineLength);
		if (num7 < num6)
		{
			SplineSection item = new SplineSection(spline, num7, num6);
			ourSplines.Add(item);
		}
		else if (num7 > num6)
		{
			SplineSection item2 = new SplineSection(spline, num6, num7);
			ourSplines.Add(item2);
		}
		return result;
	}
}


public enum LightState
{
	None,
	Green,
	Yellow,
	Red
}


private class SplineSection
{
	public readonly TrainTrackSpline spline;

	public readonly float startDist;

	public readonly float endDist;

	public SplineSection(TrainTrackSpline spline, float startDist, float endDist)
	{
		this.spline = spline;
		this.startDist = startDist;
		this.endDist = endDist;
	}
}


using UnityEngine;

public class TravellingVendorSounds : MonoBehaviour
{
	[SerializeField]
	[Header("Engine")]
	private EngineAudioSet EngineAudioSet;

	[SerializeField]
	private BlendedLoopEngineSound blendedEngineLoops;

	[SerializeField]
	private float engineRPMThrottleWeight = 0.75f;

	[SerializeField]
	private float engineRPMThrottleSpeedWeight = 0.25f;

	[SerializeField]
	private float engineRPMSpeedWeight = 0.25f;

	[SerializeField]
	private float wheelRatioMultiplier = 600f;

	[SerializeField]
	private SoundDefinition missGearSoundDef;

	[SerializeField]
	private float gearMissCooldown = 5f;

	[Header("Suspension")]
	[SerializeField]
	private SoundDefinition suspensionDef;

	[SerializeField]
	private float suspensionMinTimeBetweenSounds = 0.25f;

	[SerializeField]
	private float suspensionUpAngleDeltaThreshold = 0.05f;

	[SerializeField]
	private AnimationCurve suspensionDeltaSpeedGain;

	[SerializeField]
	private AnimationCurve suspensionUpAngleDeltaGain;

	[Header("Tires")]
	[SerializeField]
	private SoundDefinition tireDirtSoundDef;

	[SerializeField]
	private SoundDefinition tireGrassSoundDef;

	[SerializeField]
	private SoundDefinition tireSnowSoundDef;

	[SerializeField]
	private SoundDefinition tireWaterSoundDef;

	[SerializeField]
	private AnimationCurve tireGainCurve;

	[Header("Movement")]
	[SerializeField]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private AnimationCurve movementLoopGainCurve;

	[SerializeField]
	[Header("Brakes")]
	private SoundDefinition brakeLoopDef;

	[SerializeField]
	private SoundDefinition brakeHissDef;

	[SerializeField]
	private float brakeHissCooldown = 2f;

	[Header("Misc")]
	[SerializeField]
	private SoundDefinition angryHornSoundDef;

	[SerializeField]
	private SoundDefinition musicLoopSoundDef;
}


using UnityEngine;

public class TravellingVendorVisuals : VehicleChassisVisuals<TravellingVendor>, IClientComponent
{
	[Header("References")]
	public Transform frontAxle;

	public ModularCarChassisVisuals.Steering steering;

	public ModularCarChassisVisuals.LookAtTarget transmission;

	[Header("Settings")]
	public float wheelTurnLerpSpeed = 5f;
}


using System;

public class TutorialContainer : StorageContainer
{
	private bool acceptingItems;

	public void LoadStorage(ItemAmount[] toLoad)
	{
		base.inventory.Clear();
		acceptingItems = true;
		foreach (ItemAmount itemAmount in toLoad)
		{
			base.inventory.GiveItem(ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL));
		}
		acceptingItems = false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		return acceptingItems;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class VendingMachineMapMarker : MapMarker
{
	public string markerShopName;

	public VendingMachine server_vendingMachine;

	public VendingMachine client_vendingMachine;

	[NonSerialized]
	public NetworkableId client_vendingMachineNetworkID;

	public GameObjectRef clusterMarkerObj;

	private UIMapVendingMachineMarker myUIMarker;

	private RectTransform markerTransform;

	public void SetVendingMachine(VendingMachine vm, string shopName)
	{
		_ = (Object)(object)vm == (Object)null;
		server_vendingMachine = vm;
		markerShopName = shopName;
		if (!((FacepunchBehaviour)this).IsInvoking((Action)TryUpdatePosition))
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)TryUpdatePosition, 30f, 30f, 10f);
		}
	}

	public void TryUpdatePosition()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)server_vendingMachine != (Object)null && (Object)(object)server_vendingMachine.GetParentEntity() != (Object)null)
		{
			((Component)this).transform.position = ((Component)server_vendingMachine).transform.position;
			try
			{
				syncPosition = true;
				NetworkPositionTick();
			}
			finally
			{
				syncPosition = false;
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.vendingMachine = Pool.Get<VendingMachine>();
		info.msg.vendingMachine.shopName = markerShopName;
		if ((Object)(object)server_vendingMachine != (Object)null)
		{
			if (server_vendingMachine is NPCVendingMachine { IsLocalized: not false } nPCVendingMachine)
			{
				info.msg.vendingMachine.translationToken = nPCVendingMachine.GetTranslationToken();
			}
			info.msg.vendingMachine.networkID = server_vendingMachine.net.ID;
			info.msg.vendingMachine.sellOrderContainer = server_vendingMachine.sellOrders.Copy();
			info.msg.vendingMachine.sellOrderContainer.sellOrders.RemoveAll(delegate(SellOrder x)
			{
				//IL_001d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0030: Unknown result type (might be due to invalid IL or missing references)
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(x.itemToSellID);
				return !ItemManager.FindItemDefinition(x.currencyID).IsAllowed(server_vendingMachine.CurrentEraRestriction) || !itemDefinition.IsAllowed(server_vendingMachine.CurrentEraRestriction);
			});
		}
	}

	public override AppMarker GetAppMarkerData()
	{
		AppMarker appMarkerData = base.GetAppMarkerData();
		appMarkerData.name = markerShopName ?? "";
		appMarkerData.outOfStock = !HasFlag(Flags.Busy);
		if ((Object)(object)server_vendingMachine != (Object)null)
		{
			appMarkerData.sellOrders = Pool.Get<List<SellOrder>>();
			foreach (SellOrder sellOrder in server_vendingMachine.sellOrders.sellOrders)
			{
				if (server_vendingMachine.CanSellOrBuyItem(sellOrder.itemToSellID, sellOrder.currencyID))
				{
					SellOrder val = Pool.Get<SellOrder>();
					val.itemId = sellOrder.itemToSellID;
					val.quantity = sellOrder.itemToSellAmount;
					val.currencyId = sellOrder.currencyID;
					val.costPerItem = sellOrder.currencyAmountPerItem;
					val.amountInStock = sellOrder.inStock;
					val.itemIsBlueprint = sellOrder.itemToSellIsBP;
					val.currencyIsBlueprint = sellOrder.currencyIsBP;
					val.itemCondition = sellOrder.itemCondition;
					val.itemConditionMax = sellOrder.itemConditionMax;
					val.priceMultiplier = sellOrder.priceMultiplier;
					appMarkerData.sellOrders.Add(val);
				}
			}
		}
		return appMarkerData;
	}
}


using System;
using ProtoBuf;
using UnityEngine;

public class VisualStorageContainer : LootContainer
{
	[Serializable]
	public class DisplayModel
	{
		public GameObject displayModel;

		public ItemDefinition def;

		public int slot;
	}

	public VisualStorageContainerNode[] displayNodes;

	public DisplayModel[] displayModels;

	public Transform nodeParent;

	public GameObject defaultDisplayModel;

	public override void ServerInit()
	{
		base.ServerInit();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
	}

	public override void PopulateLoot()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		base.PopulateLoot();
		for (int i = 0; i < inventorySlots; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			DroppedItem component = ((Component)slot.Drop(((Component)displayNodes[i]).transform.position + new Vector3(0f, 0.25f, 0f), Vector3.zero, ((Component)displayNodes[i]).transform.rotation)).GetComponent<DroppedItem>();
			if (Object.op_Implicit((Object)(object)component))
			{
				ReceiveCollisionMessages(b: false);
				((FacepunchBehaviour)this).CancelInvoke((Action)component.IdleDestroy);
				Rigidbody componentInChildren = ((Component)component).GetComponentInChildren<Rigidbody>();
				if (Object.op_Implicit((Object)(object)componentInChildren))
				{
					componentInChildren.constraints = (RigidbodyConstraints)10;
				}
			}
		}
	}

	public void ClearRigidBodies()
	{
		if (displayModels == null)
		{
			return;
		}
		DisplayModel[] array = displayModels;
		foreach (DisplayModel displayModel in array)
		{
			if (displayModel != null)
			{
				Object.Destroy((Object)(object)displayModel.displayModel.GetComponentInChildren<Rigidbody>());
			}
		}
	}

	public void SetItemsVisible(bool vis)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (displayModels == null)
		{
			return;
		}
		DisplayModel[] array = displayModels;
		foreach (DisplayModel displayModel in array)
		{
			if (displayModel != null)
			{
				LODGroup componentInChildren = displayModel.displayModel.GetComponentInChildren<LODGroup>();
				if (Object.op_Implicit((Object)(object)componentInChildren))
				{
					componentInChildren.localReferencePoint = (Vector3)(vis ? Vector3.zero : new Vector3(10000f, 10000f, 10000f));
				}
				else
				{
					Debug.Log((object)("VisualStorageContainer item missing LODGroup" + ((Object)displayModel.displayModel.gameObject).name));
				}
			}
		}
	}

	public void ItemUpdateComplete()
	{
		ClearRigidBodies();
		SetItemsVisible(vis: true);
	}

	public void UpdateVisibleItems(ItemContainer msg)
	{
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < displayModels.Length; i++)
		{
			DisplayModel displayModel = displayModels[i];
			if (displayModel != null)
			{
				Object.Destroy((Object)(object)displayModel.displayModel);
				displayModels[i] = null;
			}
		}
		if (msg == null)
		{
			return;
		}
		foreach (Item content in msg.contents)
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(content.itemid);
			GameObject val = null;
			val = ((itemDefinition.GetWorldModel(content.amount) == null || !itemDefinition.GetWorldModel(content.amount).isValid) ? Object.Instantiate<GameObject>(defaultDisplayModel) : itemDefinition.GetWorldModel(content.amount).Instantiate());
			if (Object.op_Implicit((Object)(object)val))
			{
				val.transform.SetPositionAndRotation(((Component)displayNodes[content.slot]).transform.position + new Vector3(0f, 0.25f, 0f), ((Component)displayNodes[content.slot]).transform.rotation);
				Rigidbody obj = val.AddComponent<Rigidbody>();
				obj.mass = 1f;
				obj.drag = 0.1f;
				obj.angularDrag = 0.1f;
				obj.interpolation = (RigidbodyInterpolation)1;
				obj.constraints = (RigidbodyConstraints)10;
				displayModels[content.slot].displayModel = val;
				displayModels[content.slot].slot = content.slot;
				displayModels[content.slot].def = itemDefinition;
				val.SetActive(true);
			}
		}
		SetItemsVisible(vis: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ItemUpdateComplete);
		((FacepunchBehaviour)this).Invoke((Action)ItemUpdateComplete, 1f);
	}
}


using System;
using UnityEngine;

[Serializable]
public class DisplayModel
{
	public GameObject displayModel;

	public ItemDefinition def;

	public int slot;
}


using UnityEngine;

public class VisualStorageContainerNode : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using UnityEngine;

public class WaterBall : BaseEntity
{
	public ItemDefinition liquidType;

	public int waterAmount;

	public GameObjectRef waterExplosion;

	public Collider waterCollider;

	public Rigidbody myRigidBody;

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)Extinguish, 10f);
	}

	public void Extinguish()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Extinguish);
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public void FixedUpdate()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && (Object)(object)myRigidBody != (Object)null)
		{
			myRigidBody.AddForce(Physics.gravity, (ForceMode)5);
		}
	}

	public static bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount, bool funWater = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanWaterBallSplash", (object)liquidDef, (object)position, (object)radius, (object)amount, (object)funWater);
		if (obj is bool)
		{
			return (bool)obj;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, radius, list, 1220225811, (QueryTriggerInteraction)2);
		int num = 0;
		int num2 = amount;
		bool flag = false;
		while (amount > 0 && num < 3)
		{
			List<ISplashable> list2 = Pool.Get<List<ISplashable>>();
			foreach (BaseEntity item in list)
			{
				if (item.isClient || !(item is ISplashable splashable) || list2.Contains(splashable) || !splashable.WantsSplash(liquidDef, amount))
				{
					continue;
				}
				bool flag2 = true;
				bool flag3 = item is PlanterBox;
				bool flag4 = item is TimedExplosive;
				if (flag3 || flag4)
				{
					Vector3 val = Vector3.zero;
					if (flag3)
					{
						val = Vector3.up;
					}
					if (!GamePhysics.LineOfSight(((Component)item).transform.position + val, position, 2097152))
					{
						flag2 = false;
					}
					if (flag2)
					{
						flag = true;
					}
				}
				if (flag2)
				{
					list2.Add(splashable);
				}
			}
			if (list2.Count == 0)
			{
				break;
			}
			int num3 = Mathf.CeilToInt((float)(amount / list2.Count));
			foreach (ISplashable item2 in list2)
			{
				if (!flag || !(item2 is BasePlayer))
				{
					int num4 = 0;
					BasePlayer basePlayer = item2 as BasePlayer;
					num4 = ((!(basePlayer != null && funWater)) ? item2.DoSplash(liquidDef, Mathf.Min(amount, num3)) : basePlayer.DoSplashFunWater(liquidDef, Mathf.Min(amount, num3)));
					amount -= num4;
					if (amount <= 0)
					{
						break;
					}
				}
			}
			Pool.FreeUnmanaged<ISplashable>(ref list2);
			num++;
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return amount < num2;
	}

	private void OnCollisionEnter(Collision collision)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && !myRigidBody.isKinematic)
		{
			float num = 2.5f;
			Vector3 position = ((Component)this).transform.position;
			float num2 = num * 0.75f;
			if (GamePhysics.Trace(new Ray(position, Vector3.up), 0.05f, out var hitInfo, num2, 1084293377, (QueryTriggerInteraction)0))
			{
				num2 = ((RaycastHit)(ref hitInfo)).distance;
			}
			DoSplash(position + new Vector3(0f, num2, 0f), num, liquidType, waterAmount);
			Effect.server.Run(waterExplosion.resourcePath, position, Vector3.up);
			myRigidBody.isKinematic = true;
			waterCollider.enabled = false;
			((FacepunchBehaviour)this).Invoke((Action)Extinguish, 2f);
		}
	}
}


using UnityEngine;

public class WeaponRackBatchAutoSet : MonoBehaviour
{
	public Transform Anchor;

	public Object MountConfigScript;
}


public static class WeaponRackGhost
{
}


using ProtoBuf;
using Rust;
using UnityEngine;

public class WeaponRackSlot
{
	[InspectorFlags]
	public AmmoTypes AmmoTypes;

	public bool Used { get; private set; }

	public ItemDefinition ItemDef { get; private set; }

	public int ClientItemID { get; private set; }

	public ulong ClientItemSkinID { get; private set; }

	public ItemDefinition AmmoItemDef { get; private set; }

	public int AmmoItemID { get; private set; }

	public int AmmoCount { get; private set; }

	public int AmmoMax { get; private set; }

	public float Condition { get; private set; }

	public int InventoryIndex { get; private set; }

	public int GridSlotIndex { get; private set; }

	public int Rotation { get; private set; }

	public float ReloadTime { get; private set; }

	public void SetUsed(bool flag)
	{
		Used = flag;
	}

	public WeaponRackItem SaveToProto(Item item, WeaponRackItem proto)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Expected I4, but got Unknown
		proto.itemID = item?.info.itemid ?? 0;
		proto.skinid = item?.skin ?? 0;
		proto.inventorySlot = InventoryIndex;
		proto.gridSlotIndex = GridSlotIndex;
		proto.rotation = Rotation;
		proto.ammoCount = AmmoCount;
		proto.ammoMax = AmmoMax;
		proto.ammoID = AmmoItemID;
		proto.condition = Condition;
		proto.ammoTypes = (int)AmmoTypes;
		proto.reloadTime = ReloadTime;
		return proto;
	}

	public void InitFromProto(WeaponRackItem item)
	{
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		ClientItemID = item.itemID;
		ClientItemSkinID = item.skinid;
		ItemDef = ItemManager.FindItemDefinition(ClientItemID);
		InventoryIndex = item.inventorySlot;
		GridSlotIndex = item.gridSlotIndex;
		AmmoCount = item.ammoCount;
		AmmoMax = item.ammoMax;
		AmmoItemID = item.ammoID;
		AmmoItemDef = ((AmmoItemID != 0) ? ItemManager.FindItemDefinition(AmmoItemID) : null);
		Condition = item.condition;
		Rotation = item.rotation;
		AmmoTypes = (AmmoTypes)item.ammoTypes;
		ReloadTime = item.reloadTime;
	}

	public void SetItem(Item item, ItemDefinition updatedItemDef, int gridCellIndex, int rotation)
	{
		InventoryIndex = item.position;
		GridSlotIndex = gridCellIndex;
		Condition = item.conditionNormalized;
		Rotation = rotation;
		SetAmmoDetails(item);
		ItemDef = updatedItemDef;
	}

	public void SetAmmoDetails(Item item)
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		ClearAmmoDetails();
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
			if (!((Object)(object)component == (Object)null))
			{
				AmmoItemDef = component.primaryMagazine.ammoType;
				AmmoItemID = (((Object)(object)AmmoItemDef != (Object)null) ? AmmoItemDef.itemid : 0);
				AmmoCount = component.primaryMagazine.contents;
				AmmoMax = component.primaryMagazine.capacity;
				AmmoTypes = component.primaryMagazine.definition.ammoTypes;
				ReloadTime = component.GetReloadDuration();
			}
		}
	}

	private void ClearAmmoDetails()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		AmmoItemDef = null;
		AmmoTypes = (AmmoTypes)0;
		AmmoItemID = 0;
		AmmoCount = 0;
		AmmoMax = 0;
		ReloadTime = 0f;
	}

	public bool CanBeReloadedAtWeaponRack()
	{
		if ((Object)(object)ItemDef == (Object)null)
		{
			return false;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(ItemDef);
		if ((Object)(object)forItemDef == (Object)null)
		{
			return false;
		}
		return forItemDef.CanReloadOnWeaponRack;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public class WhitelistLootContainer : LootContainer
{
	public static readonly Phrase CantLootToast = new Phrase("whitelistcontainer.noloot", "You are not authorized to access this box");

	[NonSerialized]
	public List<ulong> whitelist = new List<ulong>();

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			return;
		}
		info.msg.whitelist = Pool.Get<Whitelist>();
		info.msg.whitelist.users = Pool.Get<List<ulong>>();
		foreach (ulong item in whitelist)
		{
			info.msg.whitelist.users.Add(item);
		}
	}

	public override void Load(LoadInfo info)
	{
		if (info.fromDisk && info.msg.whitelist != null)
		{
			foreach (ulong user in info.msg.whitelist.users)
			{
				whitelist.Add(user);
			}
		}
		base.Load(info);
	}

	public void MissionSetupPlayer(BasePlayer player)
	{
		AddToWhitelist(player.userID);
	}

	public void AddToWhitelist(ulong userid)
	{
		if (!whitelist.Contains(userid))
		{
			whitelist.Add(userid);
		}
	}

	public void RemoveFromWhitelist(ulong userid)
	{
		if (whitelist.Contains(userid))
		{
			whitelist.Remove(userid);
		}
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		ulong item = player.userID.Get();
		if (!whitelist.Contains(item))
		{
			player.ShowToast(GameTip.Styles.Red_Normal, CantLootToast, false);
			return false;
		}
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Cronos;
using Facepunch;
using Facepunch.Math;
using Newtonsoft.Json;
using ProtoBuf;
using TimeZoneConverter;
using UnityEngine;

public class WipeTimer : BaseEntity
{
	public enum WipeFrequency
	{
		Monthly,
		Weekly,
		BiWeekly
	}

	[ServerVar(Help = "0=sun,1=mon,2=tues,3=wed,4=thur,5=fri,6=sat")]
	public static int wipeDayOfWeek = 4;

	[ServerVar(Help = "Which hour to wipe? 14.5 = 2:30pm")]
	public static float wipeHourOfDay = 19f;

	[ServerVar(Help = "The timezone to use for wipes. Defaults to the server's time zone if not set or invalid. Value should be a TZ identifier as seen here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones")]
	public static string wipeTimezone = "Europe/London";

	[ServerVar(Help = "Unix timestamp (seconds) for the upcoming wipe. Overrides all other convars if set to a time in the future.")]
	public static long wipeUnixTimestampOverride = 0L;

	[ServerVar(Help = "Custom cron expression for the wipe schedule. Overrides all other convars (except wipeUnixTimestampOverride) if set. Uses Cronos as a parser: https://github.com/HangfireIO/Cronos/")]
	public static string wipeCronOverride = "";

	public bool useWipeDayOverride;

	public DayOfWeek wipeDayOfWeekOverride = DayOfWeek.Thursday;

	public WipeFrequency wipeFrequency;

	[ServerVar(Name = "days_to_add_test")]
	public static int daysToAddTest = 0;

	[ServerVar(Name = "hours_to_add_test")]
	public static float hoursToAddTest = 0f;

	public static WipeTimer serverinstance;

	public static WipeTimer clientinstance;

	private string oldTags = "";

	private static string cronExprCacheKey = null;

	private static CronExpression cronExprCache = null;

	private static (WipeFrequency, int, float)? cronCacheKey = null;

	private static string cronCache = null;

	private static string timezoneCacheKey = null;

	private static TimeZoneInfo timezoneCache = null;

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			serverinstance = this;
		}
		if (base.isClient)
		{
			clientinstance = this;
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			serverinstance = null;
		}
		if (base.isClient)
		{
			clientinstance = null;
		}
		base.DestroyShared();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		RecalculateWipeFrequency();
		((FacepunchBehaviour)this).InvokeRepeating((Action)TryAndUpdate, 1f, 4f);
	}

	public void RecalculateWipeFrequency()
	{
		string tags = Server.tags;
		if (tags.Contains("monthly"))
		{
			wipeFrequency = WipeFrequency.Monthly;
		}
		else if (tags.Contains("biweekly"))
		{
			wipeFrequency = WipeFrequency.BiWeekly;
		}
		else if (tags.Contains("weekly"))
		{
			wipeFrequency = WipeFrequency.Weekly;
		}
		else
		{
			wipeFrequency = WipeFrequency.Monthly;
		}
	}

	public void TryAndUpdate()
	{
		if (Server.tags != oldTags)
		{
			RecalculateWipeFrequency();
			oldTags = Server.tags;
		}
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk && info.msg.landmine == null)
		{
			info.msg.landmine = Pool.Get<Landmine>();
			info.msg.landmine.triggeredID = (ulong)GetTicksUntilWipe();
		}
	}

	public TimeSpan GetTimeSpanUntilWipe()
	{
		DateTimeOffset dateTimeOffset = DateTimeOffset.UtcNow.AddDays(daysToAddTest).AddHours(hoursToAddTest);
		return GetWipeTime(dateTimeOffset) - dateTimeOffset;
	}

	public long GetTicksUntilWipe()
	{
		return GetTimeSpanUntilWipe().Ticks;
	}

	[ServerVar]
	public static void PrintWipe(Arg arg)
	{
		if ((Object)(object)serverinstance == (Object)null)
		{
			arg.ReplyWith("WipeTimer not found!");
			return;
		}
		serverinstance.RecalculateWipeFrequency();
		serverinstance.TryAndUpdate();
		TimeZoneInfo timeZone = GetTimeZone();
		string text = default(string);
		string text2 = (TZConvert.TryWindowsToIana(timeZone.Id, ref text) ? text : timeZone.Id);
		DateTimeOffset dateTimeOffset = DateTimeOffset.UtcNow.AddDays(daysToAddTest).AddHours(hoursToAddTest);
		DateTimeOffset wipeTime = serverinstance.GetWipeTime(dateTimeOffset);
		TimeSpan timeSpan = wipeTime - dateTimeOffset;
		string cronString = GetCronString(serverinstance.wipeFrequency, serverinstance.useWipeDayOverride ? ((int)serverinstance.wipeDayOfWeekOverride) : wipeDayOfWeek, wipeHourOfDay);
		CronExpression cronExpression = GetCronExpression(serverinstance.wipeFrequency, serverinstance.useWipeDayOverride ? ((int)serverinstance.wipeDayOfWeekOverride) : wipeDayOfWeek, wipeHourOfDay);
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Frequency: {serverinstance.wipeFrequency}");
		stringBuilder.AppendLine("Timezone: " + timeZone.StandardName + " (ID=" + timeZone.Id + ", IANA=" + text2 + ")");
		stringBuilder.AppendLine($"Wipe day of week: {(DayOfWeek)wipeDayOfWeek}");
		stringBuilder.AppendLine($"Wipe hour: {wipeHourOfDay}");
		stringBuilder.AppendLine($"Test time: {dateTimeOffset:O}");
		stringBuilder.AppendLine($"Wipe time: {wipeTime:O}");
		stringBuilder.AppendLine($"Time until wipe: {timeSpan:g}");
		stringBuilder.AppendLine($"Ticks until wipe: {timeSpan.Ticks}");
		stringBuilder.AppendLine();
		stringBuilder.AppendLine("Cron: " + cronString);
		stringBuilder.AppendLine("Next 10 occurrences:");
		int num = 0;
		foreach (DateTimeOffset item in cronExpression.GetOccurrences(dateTimeOffset, dateTimeOffset.AddYears(2), timeZone, true, false).Take(10))
		{
			stringBuilder.AppendLine($"  {num}. {item:O}");
			num++;
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void PrintTimeZones(Arg arg)
	{
		List<string> systemTzs = (from z in TimeZoneInfo.GetSystemTimeZones()
			select z.Id).ToList();
		IReadOnlyCollection<string> knownWindowsTimeZoneIds = TZConvert.KnownWindowsTimeZoneIds;
		IReadOnlyCollection<string> knownIanaTimeZoneNames = TZConvert.KnownIanaTimeZoneNames;
		arg.ReplyWith(JsonConvert.SerializeObject((object)new
		{
			systemTzs = systemTzs,
			windowsTzs = knownWindowsTimeZoneIds,
			ianaTzs = knownIanaTimeZoneNames
		}));
	}

	public DateTimeOffset GetWipeTime(DateTimeOffset nowTime)
	{
		if (wipeUnixTimestampOverride > 0 && wipeUnixTimestampOverride > Epoch.Current)
		{
			return Epoch.ToDateTime(wipeUnixTimestampOverride);
		}
		try
		{
			return GetCronExpression(wipeFrequency, useWipeDayOverride ? ((int)wipeDayOfWeekOverride) : wipeDayOfWeek, wipeHourOfDay).GetNextOccurrence(nowTime, GetTimeZone(), false) ?? DateTimeOffset.MaxValue;
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			return DateTimeOffset.MaxValue;
		}
	}

	private bool HoursUntilWipe(float hours)
	{
		if (serverinstance.GetTimeSpanUntilWipe().TotalHours < (double)hours)
		{
			return true;
		}
		return false;
	}

	private static CronExpression GetCronExpression(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
	{
		string cronString = GetCronString(frequency, dayOfWeek, hourOfDay);
		if (cronString == cronExprCacheKey && cronExprCache != (CronExpression)null)
		{
			return cronExprCache;
		}
		cronExprCache = CronExpression.Parse(cronString);
		cronExprCacheKey = cronString;
		return cronExprCache;
	}

	private static string GetCronString(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
	{
		if (!string.IsNullOrWhiteSpace(wipeCronOverride))
		{
			return wipeCronOverride;
		}
		(WipeFrequency, int, float) tuple = (frequency, dayOfWeek, hourOfDay);
		(WipeFrequency, int, float) tuple2 = tuple;
		(WipeFrequency, int, float)? tuple3 = cronCacheKey;
		if (tuple3.HasValue)
		{
			(WipeFrequency, int, float) valueOrDefault = tuple3.GetValueOrDefault();
			if (tuple2.Item1 == valueOrDefault.Item1 && tuple2.Item2 == valueOrDefault.Item2 && tuple2.Item3 == valueOrDefault.Item3 && cronCache != null)
			{
				return cronCache;
			}
		}
		cronCache = BuildCronString(frequency, dayOfWeek, hourOfDay);
		cronCacheKey = tuple;
		return cronCache;
	}

	private static string BuildCronString(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
	{
		int num = Mathf.FloorToInt(hourOfDay);
		int num2 = Mathf.FloorToInt((hourOfDay - (float)num) * 60f);
		return frequency switch
		{
			WipeFrequency.Weekly => $"{num2} {num} * * {dayOfWeek}", 
			WipeFrequency.BiWeekly => $"{num2} {num} 1-7,15-21,29-31 * {dayOfWeek}", 
			WipeFrequency.Monthly => $"{num2} {num} * * {dayOfWeek}#1", 
			_ => throw new NotSupportedException($"WipeFrequency {frequency}"), 
		};
	}

	private static TimeZoneInfo GetTimeZone()
	{
		if (string.IsNullOrWhiteSpace(wipeTimezone))
		{
			return TimeZoneInfo.Local;
		}
		if (wipeTimezone == timezoneCacheKey && timezoneCache != null)
		{
			return timezoneCache;
		}
		if (TZConvert.TryGetTimeZoneInfo(wipeTimezone, ref timezoneCache))
		{
			timezoneCacheKey = wipeTimezone;
			return timezoneCache;
		}
		return TimeZoneInfo.Local;
	}
}


public enum WipeFrequency
{
	Monthly,
	Weekly,
	BiWeekly
}


using UnityEngine;
using UnityEngine.UI;

public class WipeTimerScreen : MonoBehaviour
{
	public Text timerText;
}


using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

public abstract class BaseModifiers<T> : EntityComponent<T> where T : BaseCombatEntity
{
	public List<Modifier> All = new List<Modifier>();

	protected Dictionary<Modifier.ModifierType, float> totalValues = new Dictionary<Modifier.ModifierType, float>();

	protected Dictionary<Modifier.ModifierType, float> modifierVariables = new Dictionary<Modifier.ModifierType, float>();

	protected Dictionary<Modifier.ModifierSource, int> sourceCounts = new Dictionary<Modifier.ModifierSource, int>();

	protected T owner;

	protected bool dirty = true;

	protected double timeSinceLastTick;

	protected double lastTickTime;

	public int ActiveModifierCount => All.Count;

	public int ActiveTeaCount
	{
		get
		{
			int num = 0;
			foreach (Modifier item in All)
			{
				if (item != null && item.Source == Modifier.ModifierSource.Tea)
				{
					num++;
				}
			}
			return num;
		}
	}

	public void Add(List<ModifierDefintion> modDefs, float effectScale = 1f, float durationScale = 1f)
	{
		foreach (ModifierDefintion modDef in modDefs)
		{
			if (IsCompatible(modDef.type))
			{
				Add(modDef, effectScale, durationScale);
			}
		}
	}

	protected virtual bool IsCompatible(Modifier.ModifierType modType)
	{
		return true;
	}

	protected void Add(ModifierDefintion def, float effectScale = 1f, float durationScale = 1f)
	{
		Modifier modifier = new Modifier();
		modifier.Init(def.type, def.source, def.value * effectScale, def.duration * durationScale, def.duration * durationScale);
		Add(modifier);
	}

	protected void Add(Modifier modifier)
	{
		if (!CanAdd(modifier))
		{
			return;
		}
		int maxModifierCount = GetMaxModifierCount(modifier);
		if (GetActiveCount(modifier.Type, modifier.Source) >= maxModifierCount)
		{
			Modifier shortestLifeModifier = GetShortestLifeModifier(modifier.Type, modifier.Source);
			if (shortestLifeModifier == null)
			{
				return;
			}
			Remove(shortestLifeModifier);
		}
		All.Add(modifier);
		if (!modifier.IsHiddenModifier())
		{
			AdjustSourceCount(modifier.Source, 1);
		}
		ApplyModifierValue(modifier);
		SetDirty(flag: true);
	}

	private void AdjustSourceCount(Modifier.ModifierSource source, int adjustBy)
	{
		sourceCounts.TryGetValue(source, out var value);
		sourceCounts[source] = value + 1;
	}

	public int GetSourceCount(Modifier.ModifierSource source)
	{
		return sourceCounts.GetValueOrDefault(source, 0);
	}

	private void ApplyModifierValue(Modifier modifier)
	{
		float value = modifier.Value;
		if (!totalValues.ContainsKey(modifier.Type))
		{
			totalValues.Add(modifier.Type, value);
		}
		else
		{
			totalValues[modifier.Type] += value;
		}
		totalValues[modifier.Type] = GetClampedValue(modifier, totalValues[modifier.Type]);
	}

	private bool CanAdd(Modifier modifier)
	{
		if (All.Contains(modifier))
		{
			return false;
		}
		if (modifier.HasNegativeSource() && (Object)(object)owner != (Object)null && owner is BasePlayer basePlayer && basePlayer.IsGod())
		{
			return false;
		}
		return true;
	}

	private int GetMaxModifiersForSourceType(Modifier.ModifierSource source)
	{
		if (source == Modifier.ModifierSource.Tea || source == Modifier.ModifierSource.Interaction)
		{
			return 1;
		}
		return int.MaxValue;
	}

	protected virtual int GetMaxModifierCount(Modifier modifier)
	{
		if (modifier == null)
		{
			return 0;
		}
		Modifier.ModifierSource source = modifier.Source;
		if (source == Modifier.ModifierSource.Tea || source == Modifier.ModifierSource.Interaction)
		{
			return 1;
		}
		return int.MaxValue;
	}

	protected virtual float GetClampedValue(Modifier modifier, float value)
	{
		return value;
	}

	private int GetActiveCount(Modifier.ModifierType type, Modifier.ModifierSource source)
	{
		int num = 0;
		foreach (Modifier item in All)
		{
			if (item.Type == type && item.Source == source)
			{
				num++;
			}
		}
		return num;
	}

	private Modifier GetShortestLifeModifier(Modifier.ModifierType type, Modifier.ModifierSource source)
	{
		Modifier modifier = null;
		foreach (Modifier item in All)
		{
			if (item.Type == type && item.Source == source)
			{
				if (modifier == null)
				{
					modifier = item;
				}
				else if (item.TimeRemaining < modifier.TimeRemaining)
				{
					modifier = item;
				}
			}
		}
		return modifier;
	}

	private void Remove(Modifier toRemove)
	{
		bool flag = false;
		bool flag2 = false;
		Modifier.ModifierType type = toRemove.Type;
		foreach (Modifier item in All)
		{
			if (toRemove == item)
			{
				flag = true;
			}
			else if (item.Type == type)
			{
				flag2 = true;
			}
		}
		if (flag)
		{
			All.Remove(toRemove);
			AdjustSourceCount(toRemove.Source, -1);
			if (!flag2)
			{
				totalValues.Remove(toRemove.Type);
			}
			SetDirty(flag: true);
		}
	}

	public void RemoveAll()
	{
		All.Clear();
		totalValues.Clear();
		sourceCounts.Clear();
		SetDirty(flag: true);
	}

	public void RemoveFromSource(Modifier.ModifierSource source)
	{
		for (int num = All.Count - 1; num >= 0; num--)
		{
			Modifier modifier = All[num];
			if (modifier != null && modifier.Source == source)
			{
				Remove(modifier);
			}
		}
	}

	public void RemoveAllExceptFromSource(Modifier.ModifierSource source)
	{
		for (int num = All.Count - 1; num >= 0; num--)
		{
			Modifier modifier = All[num];
			if (modifier != null && modifier.Source != source)
			{
				Remove(modifier);
			}
		}
	}

	public float GetValue(Modifier.ModifierType type, float defaultValue = 0f)
	{
		float num = 1f;
		if (IsModifierCompatibleWithDigestionBoost(type))
		{
			num = GetValue(Modifier.ModifierType.DigestionBoost, 1f);
		}
		if (totalValues.TryGetValue(type, out var value))
		{
			return value * num;
		}
		return defaultValue * num;
	}

	public void SetValue(Modifier.ModifierSource source, Modifier.ModifierType type, float value)
	{
		Modifier modifier = new Modifier();
		bool flag = false;
		foreach (Modifier item in All)
		{
			if (item != null && item.Source == source && item.Type == type)
			{
				modifier.Init(item.Type, item.Source, value, item.Duration, item.TimeRemaining);
				flag = true;
				break;
			}
		}
		if (flag)
		{
			Add(modifier);
		}
	}

	public float GetVariableValue(Modifier.ModifierType type, float defaultValue)
	{
		if (modifierVariables.TryGetValue(type, out var value))
		{
			return value;
		}
		return defaultValue;
	}

	public void SetVariableValue(Modifier.ModifierType type, float value)
	{
		if (modifierVariables.TryGetValue(type, out var _))
		{
			modifierVariables[type] = value;
		}
		else
		{
			modifierVariables.Add(type, value);
		}
	}

	public void RemoveVariable(Modifier.ModifierType type)
	{
		modifierVariables.Remove(type);
	}

	protected virtual void OnDisable()
	{
		if (!Application.isQuitting)
		{
			owner = null;
		}
	}

	public void SetDirty(bool flag)
	{
		dirty = flag;
	}

	public virtual void ServerInit(T owner)
	{
		this.owner = owner;
		ResetTicking();
		RemoveAll();
	}

	public void ResetTicking()
	{
		lastTickTime = Time.timeAsDouble;
		timeSinceLastTick = 0.0;
	}

	public virtual void ServerUpdate(BaseCombatEntity ownerEntity)
	{
		double num = Time.timeAsDouble - lastTickTime;
		lastTickTime = Time.timeAsDouble;
		timeSinceLastTick += num;
		if (!(timeSinceLastTick <= (double)ConVar.Server.modifierTickRate))
		{
			if ((Object)(object)owner != (Object)null && !owner.IsDead())
			{
				TickModifiers(ownerEntity, timeSinceLastTick);
			}
			timeSinceLastTick = 0.0;
		}
	}

	protected virtual void TickModifiers(BaseCombatEntity ownerEntity, double delta)
	{
		for (int num = All.Count - 1; num >= 0; num--)
		{
			Modifier modifier = All[num];
			float num2 = (IsModifierCompatibleWithDigestionBoost(modifier.Type) ? GetValue(Modifier.ModifierType.DigestionBoostTimeMod, 1f) : 1f);
			modifier.Tick(ownerEntity, delta * (double)num2);
			if (modifier.Expired)
			{
				Remove(modifier);
			}
		}
	}

	protected bool IsModifierCompatibleWithDigestionBoost(Modifier.ModifierType modifierType)
	{
		if ((uint)modifierType <= 1u || modifierType == Modifier.ModifierType.Scrap_Yield || modifierType == Modifier.ModifierType.Harvesting)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HorseModifiers : BaseModifiers<RidableHorse>
{
	public static void AddToHorse(RidableHorse horse, List<ModifierDefintion> modifiers)
	{
		if (!((Object)(object)horse == (Object)null) && !((Object)(object)horse.modifiers == (Object)null) && modifiers != null)
		{
			horse.modifiers.Add(modifiers);
		}
	}

	protected override bool IsCompatible(Modifier.ModifierType modType)
	{
		if ((uint)(modType - 20) <= 1u)
		{
			return true;
		}
		return false;
	}

	public HorseModifiers Save(bool forDisk)
	{
		HorseModifiers val = Pool.Get<HorseModifiers>();
		val.modifiers = Pool.Get<List<Modifier>>();
		foreach (Modifier item2 in All)
		{
			if (item2 != null && (!forDisk || item2.Source != Modifier.ModifierSource.Interaction))
			{
				Modifier item = item2.Save();
				val.modifiers.Add(item);
			}
		}
		return val;
	}

	public void Load(HorseModifiers m, bool fromDisk)
	{
		RemoveAll();
		if (m == null || m.modifiers == null)
		{
			return;
		}
		foreach (Modifier modifier2 in m.modifiers)
		{
			if (modifier2 != null && (!fromDisk || modifier2.source != 2))
			{
				Modifier modifier = new Modifier();
				modifier.Init((Modifier.ModifierType)modifier2.type, (Modifier.ModifierSource)modifier2.source, modifier2.value, modifier2.duration, modifier2.timeRemaining);
				Add(modifier);
			}
		}
	}
}


using System;

[Serializable]
public class ModifierDefintion
{
	public Modifier.ModifierType type;

	public Modifier.ModifierSource source;

	public float value;

	public float duration;
}


using System;

[Serializable]
public class ModifierLimit
{
	public Modifier.ModifierSource source;

	public int MaxApplications;

	public float minValue;

	public float maxValue;
}


using System;
using System.Collections.Generic;

[Serializable]
public class ModifierLimits
{
	public Modifier.ModifierType type;

	public float minValue;

	public float maxValue;

	public List<ModifierLimit> limits;
}


using System;
using Facepunch;
using ProtoBuf;

public class Modifier
{
	public enum ModifierType
	{
		Wood_Yield,
		Ore_Yield,
		Radiation_Resistance,
		Radiation_Exposure_Resistance,
		Max_Health,
		Scrap_Yield,
		MoveSpeed,
		ObscureVision,
		Warming,
		Cooling,
		CoreTemperatureMinAdjustment,
		CoreTemperatureMaxAdjustment,
		Crafting_Quality,
		VisionCare,
		MetabolismBooster,
		Harvesting,
		DigestionBoost,
		FishingBoost,
		Collectible_DoubleYield,
		Farming_BetterGenes,
		HorseGallopSpeed,
		HorseDungProductionBoost,
		Comfort,
		Clotting,
		HunterVision,
		Radiation,
		DigestionBoostTimeMod
	}

	public enum ModifierSource
	{
		Tea,
		Dart,
		Interaction,
		NegativeEffect
	}

	public static Phrase WoodYieldPhrase = new Phrase("mod.woodyield", "Wood Yield");

	public static Phrase OreYieldPhrase = new Phrase("mod.oreyield", "Ore Yield");

	public static Phrase RadiationResistancePhrase = new Phrase("mod.radiationresistance", "Radiation Resistance");

	public static Phrase RadiationExposureResistancePhrase = new Phrase("mod.radiationexposureresistance", "Radiation Exposure Resistance");

	public static Phrase MaxHealthPhrase = new Phrase("mod.maxhealth", "Max Health");

	public static Phrase ScrapYieldPhrase = new Phrase("mod.scrapyield", "Scrap Yield");

	public static Phrase MoveSpeedPhrase = new Phrase("mod.movespeed", "Movement Speed");

	public static Phrase ObscureVisionPhrase = new Phrase("mod.ObscureVision", "Obscure Vision");

	public static Phrase RadiationPhrase = new Phrase("mod.radiation", "Radiation");

	public static Phrase CraftingQualityPhrase = new Phrase("mod.craftingquality", "Crafting Quality");

	public static Phrase WarmingPhrase = new Phrase("mod.warming", "Warming");

	public static Phrase CoolingPhrase = new Phrase("mod.cooling", "Cooling");

	public static Phrase CoreTempMinPhrase = new Phrase("mod.coretempmin", "Min Temp");

	public static Phrase CoreTempMaxPhrase = new Phrase("mod.coretempmax", "Max Temp");

	public static Phrase VisionCarePhrase = new Phrase("mod.VisionCare", "Vision Care");

	public static Phrase MetabolismBoosterPhrase = new Phrase("mod.MetabolismBooster", "Metabolism Booster");

	public static Phrase HarvestingPhrase = new Phrase("mod.Harvesting", "Harvesting");

	public static Phrase DigestionBoostPhrase = new Phrase("mod.DigestionBoost", "Digestion Boost");

	public static Phrase FishingBoostPhrase = new Phrase("mod.FishingBoost", "Fishing Boost");

	public static Phrase CollectibleYieldPhrase = new Phrase("mod.CollectibleDoubleYield", "Double Yield Chance");

	public static Phrase Farming_BetterGenesPhrase = new Phrase("mod.Farming_BetterGenes", "Better Genes Chance");

	public static Phrase HorseGallopSpeedPhrase = new Phrase("mod.HorseGallopSpeed", "Horse Gallop Speed");

	public static Phrase ComfortPhrase = new Phrase("mod.Comfort", "Comfort");

	public static Phrase ClottingPhrase = new Phrase("mod.Clotting", "Clotting");

	public static Phrase Temperature = new Phrase("mod.temperature", "Temperature: ");

	public static Phrase MinTemp = new Phrase("mod.mintemp", "Min temperature: ");

	public static Phrase MaxTemp = new Phrase("mod.maxtemp", "Max temperature: ");

	public static Phrase HunterVisionPhrase = new Phrase("mod.huntervision", "Hunter Vision");

	public static Phrase Farming_BetterGenesPanelPhrase = new Phrase("mod.Farming_BetterGenes.panel", "Increase");

	public ModifierType Type { get; private set; }

	public ModifierSource Source { get; private set; }

	public float Value { get; private set; } = 1f;

	public float Duration { get; private set; } = 10f;

	public double TimeRemaining { get; private set; }

	public bool Expired { get; private set; }

	public void Init(ModifierType type, ModifierSource source, float value, float duration, double remaining)
	{
		Type = type;
		Source = source;
		Value = value;
		Duration = duration;
		Expired = false;
		TimeRemaining = remaining;
	}

	public void Tick(BaseCombatEntity ownerEntity, double delta)
	{
		TimeRemaining -= delta;
		Expired = Duration > 0f && TimeRemaining <= 0.0;
	}

	public Modifier Save()
	{
		Modifier obj = Pool.Get<Modifier>();
		obj.type = (int)Type;
		obj.source = (int)Source;
		obj.value = Value;
		obj.timeRemaining = TimeRemaining;
		obj.duration = Duration;
		return obj;
	}

	public void Load(Modifier m)
	{
		Type = (ModifierType)m.type;
		Source = (ModifierSource)m.source;
		Value = m.value;
		TimeRemaining = m.timeRemaining;
		Duration = m.duration;
	}

	public static Phrase GetPhraseForModType(ModifierType type)
	{
		switch (type)
		{
		case ModifierType.Wood_Yield:
			return WoodYieldPhrase;
		case ModifierType.Ore_Yield:
			return OreYieldPhrase;
		case ModifierType.Radiation_Resistance:
			return RadiationResistancePhrase;
		case ModifierType.Radiation_Exposure_Resistance:
			return RadiationExposureResistancePhrase;
		case ModifierType.Max_Health:
			return MaxHealthPhrase;
		case ModifierType.Scrap_Yield:
			return ScrapYieldPhrase;
		case ModifierType.MoveSpeed:
			return MoveSpeedPhrase;
		case ModifierType.ObscureVision:
			return ObscureVisionPhrase;
		case ModifierType.Crafting_Quality:
			return CraftingQualityPhrase;
		case ModifierType.Warming:
			return WarmingPhrase;
		case ModifierType.Cooling:
			return CoolingPhrase;
		case ModifierType.CoreTemperatureMinAdjustment:
			return CoreTempMinPhrase;
		case ModifierType.CoreTemperatureMaxAdjustment:
			return CoreTempMaxPhrase;
		case ModifierType.VisionCare:
			return VisionCarePhrase;
		case ModifierType.MetabolismBooster:
			return MetabolismBoosterPhrase;
		case ModifierType.Harvesting:
			return HarvestingPhrase;
		case ModifierType.DigestionBoost:
		case ModifierType.HorseDungProductionBoost:
			return DigestionBoostPhrase;
		case ModifierType.FishingBoost:
			return FishingBoostPhrase;
		case ModifierType.Collectible_DoubleYield:
			return CollectibleYieldPhrase;
		case ModifierType.Farming_BetterGenes:
			return Farming_BetterGenesPhrase;
		case ModifierType.HorseGallopSpeed:
			return HorseGallopSpeedPhrase;
		case ModifierType.Comfort:
			return ComfortPhrase;
		case ModifierType.Clotting:
			return ClottingPhrase;
		case ModifierType.HunterVision:
			return HunterVisionPhrase;
		case ModifierType.Radiation:
			return RadiationPhrase;
		default:
			throw new ArgumentOutOfRangeException("type", type, $"Couldn't find a phrase for this modifier! {type}");
		}
	}

	public static Phrase GetPanelPhraseForModType(ModifierType type)
	{
		if (type == ModifierType.Farming_BetterGenes)
		{
			return Farming_BetterGenesPanelPhrase;
		}
		throw new ArgumentOutOfRangeException("type", type, $"Couldn't find a phrase for this modifier! {type}");
	}

	public bool IsHiddenModifier()
	{
		return Type == ModifierType.DigestionBoostTimeMod;
	}

	public bool HasNegativeSource()
	{
		if (Source != ModifierSource.Dart)
		{
			return Source == ModifierSource.NegativeEffect;
		}
		return true;
	}
}


public enum ModifierType
{
	Wood_Yield,
	Ore_Yield,
	Radiation_Resistance,
	Radiation_Exposure_Resistance,
	Max_Health,
	Scrap_Yield,
	MoveSpeed,
	ObscureVision,
	Warming,
	Cooling,
	CoreTemperatureMinAdjustment,
	CoreTemperatureMaxAdjustment,
	Crafting_Quality,
	VisionCare,
	MetabolismBooster,
	Harvesting,
	DigestionBoost,
	FishingBoost,
	Collectible_DoubleYield,
	Farming_BetterGenes,
	HorseGallopSpeed,
	HorseDungProductionBoost,
	Comfort,
	Clotting,
	HunterVision,
	Radiation,
	DigestionBoostTimeMod
}


public enum ModifierSource
{
	Tea,
	Dart,
	Interaction,
	NegativeEffect
}


using UnityEngine;

public class ExcavatorEffects : MonoBehaviour
{
	public static ExcavatorEffects instance;

	public ParticleSystemContainer[] miningParticles;

	public SoundPlayer[] miningSounds;

	public SoundFollowCollider[] beltSounds;

	public SoundPlayer[] miningStartSounds;

	public GameObject[] ambientMetalRattles;

	public bool wasMining;
}


using UnityEngine;

public class ExcavatorEngineSounds : MonoBehaviour, IClientComponent
{
	public SoundPlayer[] engineStartClunks;

	public void PlayStartClunks()
	{
	}
}


public class ExcavatorOutputPile : StorageContainer
{
}


using UnityEngine;

public class ExcavatorServerEffects : MonoBehaviour
{
	public static ExcavatorServerEffects instance;

	public TriggerBase[] miningTriggers;

	public void Awake()
	{
		instance = this;
		SetMining(isMining: false, force: true);
	}

	public void OnDestroy()
	{
		instance = null;
	}

	public static void SetMining(bool isMining, bool force = false)
	{
		if ((Object)(object)instance == (Object)null)
		{
			return;
		}
		TriggerBase[] array = instance.miningTriggers;
		foreach (TriggerBase triggerBase in array)
		{
			if (!((Object)(object)triggerBase == (Object)null))
			{
				((Component)triggerBase).gameObject.SetActive(isMining);
			}
		}
	}
}


using UnityEngine;

public class ExcavatorYawSounds : MonoBehaviour, IClientComponent
{
	public SoundPlayer[] miningStartClunks;

	public void PlayStartClunks()
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Rust;
using Rust;
using UnityEngine;

public class LargeShredder : BaseEntity
{
	public Transform shredRail;

	public Transform shredRailStartPos;

	public Transform shredRailEndPos;

	public Vector3 shredRailStartRotation;

	public Vector3 shredRailEndRotation;

	public LargeShredderTrigger trigger;

	public float shredDurationRotation = 2f;

	public float shredDurationPosition = 5f;

	public float shredSwayAmount = 1f;

	public float shredSwaySpeed = 3f;

	public BaseEntity currentlyShredding;

	public GameObject[] shreddingWheels;

	public float shredRotorSpeed = 1f;

	public GameObjectRef shredSoundEffect;

	public Transform resourceSpawnPoint;

	private Quaternion entryRotation;

	public const string SHRED_STAT = "cars_shredded";

	public const Flags IsShreddingFlag = Flags.Reserved10;

	public bool isShredding;

	private float shreddingEntityNormalizedHealth = 1f;

	public float shredStartTime;

	private float prevDelta;

	public virtual void OnEntityEnteredTrigger(BaseEntity ent)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		if (ent.IsDestroyed)
		{
			return;
		}
		Rigidbody component = ((Component)ent).GetComponent<Rigidbody>();
		if (isShredding || (Object)(object)currentlyShredding != (Object)null)
		{
			if (!component.isKinematic)
			{
				component.velocity = -component.velocity * 3f;
			}
			return;
		}
		shreddingEntityNormalizedHealth = 1f;
		MagnetLiftable magnetLiftable = default(MagnetLiftable);
		if (((Component)ent).TryGetComponent<MagnetLiftable>(ref magnetLiftable))
		{
			if (magnetLiftable.requireObjectOff && ent.IsOn())
			{
				return;
			}
			if (magnetLiftable.scaleScrapResourcesByHealth && ent is BaseCombatEntity baseCombatEntity)
			{
				shreddingEntityNormalizedHealth = baseCombatEntity.healthFraction;
			}
		}
		((Component)shredRail).transform.position = shredRailStartPos.position;
		((Component)shredRail).transform.rotation = Quaternion.LookRotation(shredRailStartRotation);
		entryRotation = ((Component)ent).transform.rotation;
		Quaternion rotation = ((Component)ent).transform.rotation;
		PooledList<Collider> val = Pool.Get<PooledList<Collider>>();
		try
		{
			((Component)ent).GetComponentsInChildren<Collider>((List<Collider>)(object)val);
			foreach (Collider item in (List<Collider>)(object)val)
			{
				item.enabled = false;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		component.isKinematic = true;
		currentlyShredding = ent;
		((Component)ent).transform.rotation = rotation;
		isShredding = true;
		SetShredding(isShredding: true);
		prevDelta = 0f;
		shredStartTime = Time.realtimeSinceStartup;
	}

	public void CreateShredResources()
	{
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)currentlyShredding == (Object)null)
		{
			return;
		}
		MagnetLiftable component = ((Component)currentlyShredding).GetComponent<MagnetLiftable>();
		if ((Object)(object)component == (Object)null)
		{
			return;
		}
		if ((Object)(object)component.associatedPlayer != (Object)null && GameInfo.HasAchievements)
		{
			component.associatedPlayer.stats.Add("cars_shredded", 1);
			component.associatedPlayer.stats.Save(forceSteamSave: true);
		}
		List<Item> list = Pool.Get<List<Item>>();
		if (component.shredResources.Length > list.Capacity)
		{
			list.Capacity = component.shredResources.Length;
		}
		ItemAmount[] shredResources = component.shredResources;
		foreach (ItemAmount itemAmount in shredResources)
		{
			int num = Mathf.RoundToInt(itemAmount.amount * shreddingEntityNormalizedHealth);
			if (num > 0)
			{
				Item item = ItemManager.Create(itemAmount.itemDef, num, 0uL);
				if ((Object)(object)component.associatedPlayer != (Object)null)
				{
					item.SetItemOwnership(component.associatedPlayer, ItemOwnershipPhrases.Shredded);
				}
				float num2 = 0.5f;
				if ((Object)(object)item.CreateWorldObject(((Component)resourceSpawnPoint).transform.position + new Vector3(Random.Range(0f - num2, num2), 1f, Random.Range(0f - num2, num2))) == (Object)null)
				{
					item.Remove();
					continue;
				}
				list.Add(item);
				Analytics.Azure.AddPendingItems(currentlyShredding, item.info.shortname, item.amount, "car_shred", consumed: false);
			}
		}
		Analytics.Azure.OnCarShredded(component, list);
		Pool.Free<Item>(ref list, false);
		BaseModularVehicle component2 = ((Component)currentlyShredding).GetComponent<BaseModularVehicle>();
		if (!Object.op_Implicit((Object)(object)component2))
		{
			return;
		}
		foreach (BaseVehicleModule attachedModuleEntity in component2.AttachedModuleEntities)
		{
			if (!Object.op_Implicit((Object)(object)attachedModuleEntity.AssociatedItemDef) || !Object.op_Implicit((Object)(object)attachedModuleEntity.AssociatedItemDef.Blueprint))
			{
				continue;
			}
			foreach (ItemAmount ingredient in attachedModuleEntity.AssociatedItemDef.Blueprint.GetIngredients())
			{
				int num3 = Mathf.FloorToInt(ingredient.amount * 0.5f);
				if (num3 != 0)
				{
					Item item2 = ItemManager.Create(ingredient.itemDef, num3, 0uL);
					float num4 = 0.5f;
					if ((Object)(object)item2.CreateWorldObject(((Component)resourceSpawnPoint).transform.position + new Vector3(Random.Range(0f - num4, num4), 1f, Random.Range(0f - num4, num4))) == (Object)null)
					{
						item2.Remove();
					}
				}
			}
		}
	}

	public void UpdateBonePosition(float delta)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		float num = delta / shredDurationPosition;
		float num2 = delta / shredDurationRotation;
		((Component)shredRail).transform.localPosition = Vector3.Lerp(shredRailStartPos.localPosition, shredRailEndPos.localPosition, num);
		((Component)shredRail).transform.rotation = Quaternion.LookRotation(Vector3.Lerp(shredRailStartRotation, shredRailEndRotation, num2));
	}

	public void SetShredding(bool isShredding)
	{
		if (isShredding)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)FireShredEffect, 0.25f, 0.75f, 0.25f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FireShredEffect);
		}
	}

	public void FireShredEffect()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(shredSoundEffect.resourcePath, ((Component)this).transform.position + Vector3.up * 3f, Vector3.up);
	}

	public void ServerUpdate()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		SetFlag(Flags.Reserved10, isShredding);
		if (!isShredding)
		{
			return;
		}
		float num = Time.realtimeSinceStartup - shredStartTime;
		float num2 = num / shredDurationPosition;
		float num3 = num / shredDurationRotation;
		((Component)shredRail).transform.localPosition = Vector3.Lerp(shredRailStartPos.localPosition, shredRailEndPos.localPosition, num2);
		((Component)shredRail).transform.rotation = Quaternion.LookRotation(Vector3.Lerp(shredRailStartRotation, shredRailEndRotation, num3));
		MagnetLiftable component = ((Component)currentlyShredding).GetComponent<MagnetLiftable>();
		((Component)currentlyShredding).transform.position = ((Component)shredRail).transform.position;
		Vector3 val = ((Component)this).transform.TransformDirection(component.shredDirection);
		if (Vector3.Dot(-val, ((Component)currentlyShredding).transform.forward) > Vector3.Dot(val, ((Component)currentlyShredding).transform.forward))
		{
			val = ((Component)this).transform.TransformDirection(-component.shredDirection);
		}
		bool flag = Vector3.Dot(((Component)component).transform.up, Vector3.up) >= -0.95f;
		Quaternion val2 = QuaternionEx.LookRotationForcedUp(val, flag ? (-((Component)this).transform.right) : ((Component)this).transform.right);
		float num4 = Time.time * shredSwaySpeed;
		float num5 = Mathf.PerlinNoise(num4, 0f);
		float num6 = Mathf.PerlinNoise(0f, num4 + 150f);
		val2 *= Quaternion.Euler(num5 * shredSwayAmount, 0f, num6 * shredSwayAmount);
		((Component)currentlyShredding).transform.rotation = Quaternion.Lerp(entryRotation, val2, num3);
		if (prevDelta < 1.5f && num > 1.5f)
		{
			if (currentlyShredding is BaseVehicle baseVehicle)
			{
				foreach (BaseVehicle.MountPointInfo mountPoint in baseVehicle.mountPoints)
				{
					if ((Object)(object)mountPoint.mountable != (Object)null && (Object)(object)mountPoint.mountable.GetMounted() != (Object)null)
					{
						mountPoint.mountable.GetMounted().Hurt(999f, DamageType.Blunt, this, useProtection: false);
					}
				}
			}
			if (currentlyShredding is ScrapTransportHelicopter)
			{
				PooledList<BasePlayer> val3 = Pool.Get<PooledList<BasePlayer>>();
				try
				{
					foreach (BaseEntity child in currentlyShredding.children)
					{
						if (child is BasePlayer { isMounted: false } basePlayer)
						{
							((List<BasePlayer>)(object)val3).Add(basePlayer);
						}
					}
					foreach (BasePlayer item in (List<BasePlayer>)(object)val3)
					{
						item.Hurt(999f, DamageType.Blunt, this, useProtection: false);
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
		}
		prevDelta = num;
		if (num > 5f)
		{
			CreateShredResources();
			currentlyShredding.Kill();
			currentlyShredding = null;
			isShredding = false;
			SetShredding(isShredding: false);
		}
	}

	private void Update()
	{
		ServerUpdate();
	}
}


using UnityEngine;

public class LargeShredderTrigger : TriggerBase
{
	public LargeShredder shredder;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!baseEntity.syncPosition)
		{
			return null;
		}
		if (!Object.op_Implicit((Object)(object)((Component)baseEntity).GetComponent<MagnetLiftable>()))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		shredder.OnEntityEnteredTrigger(ent);
	}
}


using UnityEngine;

public class LightListener : BaseEntity
{
	public string onMessage = "";

	public string offMessage = "";

	[Tooltip("Must be part of this prefab")]
	public LightGroupAtTime onLights;

	[Tooltip("Must be part of this prefab")]
	public LightGroupAtTime offLights;

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		base.OnEntityMessage(from, msg);
		if (msg == onMessage)
		{
			SetFlag(Flags.On, b: true);
		}
		else if (msg == offMessage)
		{
			SetFlag(Flags.On, b: false);
		}
	}
}


using UnityEngine;

public class FruitScale : MonoBehaviour, IClientComponent
{
	public void SetProgress(float progress)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = Vector3.one * progress;
	}
}


using System;
using UnityEngine;

public class LifeScale : BaseMonoBehaviour
{
	[NonSerialized]
	private bool initialized;

	[NonSerialized]
	private Vector3 initialScale;

	public Vector3 finalScale = Vector3.one;

	private Vector3 targetLerpScale = Vector3.zero;

	private Action updateScaleAction;

	protected void Awake()
	{
		updateScaleAction = UpdateScale;
	}

	public void OnEnable()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Init();
		((Component)this).transform.localScale = initialScale;
	}

	public void SetProgress(float progress)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Init();
		targetLerpScale = Vector3.Lerp(initialScale, finalScale, progress);
		((FacepunchBehaviour)this).InvokeRepeating(updateScaleAction, 0f, 0.015f);
	}

	public void Init()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			initialScale = ((Component)this).transform.localScale;
			initialized = true;
		}
	}

	public void UpdateScale()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = Vector3.Lerp(((Component)this).transform.localScale, targetLerpScale, Time.deltaTime);
		if (((Component)this).transform.localScale == targetLerpScale)
		{
			targetLerpScale = Vector3.zero;
			((FacepunchBehaviour)this).CancelInvoke(updateScaleAction);
		}
	}
}


using UnityEngine;

public class MaterialColorLerp : MonoBehaviour, IClientComponent
{
	public Color startColor;

	public Color endColor;

	public Color currentColor;

	public float delta;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Plant Properties")]
public class PlantProperties : ScriptableObject
{
	public enum State
	{
		Seed,
		Seedling,
		Sapling,
		Crossbreed,
		Mature,
		Fruiting,
		Ripe,
		Dying
	}

	[Serializable]
	public struct Stage
	{
		public State nextState;

		public float lifeLength;

		public float health;

		public float resources;

		public float yield;

		public GameObjectRef skinObject;

		public bool IgnoreConditions;

		public float lifeLengthSeconds => lifeLength * 60f;
	}

	public Phrase Description;

	public GrowableGeneProperties Genes;

	[ArrayIndexIsEnum(enumType = typeof(State))]
	public Stage[] stages = new Stage[8];

	[Header("Metabolism")]
	public AnimationCurve timeOfDayHappiness = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 0f),
		new Keyframe(12f, 1f),
		new Keyframe(24f, 0f)
	});

	public AnimationCurve temperatureHappiness = new AnimationCurve((Keyframe[])(object)new Keyframe[5]
	{
		new Keyframe(-10f, -1f),
		new Keyframe(1f, 0f),
		new Keyframe(30f, 1f),
		new Keyframe(50f, 0f),
		new Keyframe(80f, -1f)
	});

	public AnimationCurve temperatureWaterRequirementMultiplier = new AnimationCurve((Keyframe[])(object)new Keyframe[5]
	{
		new Keyframe(-10f, 1f),
		new Keyframe(0f, 1f),
		new Keyframe(30f, 1f),
		new Keyframe(50f, 1f),
		new Keyframe(80f, 1f)
	});

	public AnimationCurve fruitVisualScaleCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 0f),
		new Keyframe(0.75f, 1f),
		new Keyframe(1f, 0f)
	});

	public int MaxSeasons = 1;

	public float WaterIntake = 20f;

	public float OptimalLightQuality = 1f;

	public float OptimalWaterQuality = 1f;

	public float OptimalGroundQuality = 1f;

	public float OptimalTemperatureQuality = 1f;

	[Header("Harvesting")]
	public BaseEntity.Menu.Option pickOption;

	public BaseEntity.Menu.Option pickAllOption;

	public BaseEntity.Menu.Option eatOption;

	public ItemDefinition pickupItem;

	public BaseEntity.Menu.Option cloneOption;

	public BaseEntity.Menu.Option cloneAllOption;

	public BaseEntity.Menu.Option removeDyingOption;

	public BaseEntity.Menu.Option removeDyingAllOption;

	public ItemDefinition removeDyingItem;

	public GameObjectRef removeDyingEffect;

	public int pickupMultiplier = 1;

	public GameObjectRef pickEffect;

	public int maxHarvests = 1;

	public bool disappearAfterHarvest;

	[Header("Seeds")]
	public GameObjectRef CrossBreedEffect;

	public ItemDefinition SeedItem;

	public ItemDefinition CloneItem;

	public int BaseCloneCount = 1;

	[Header("Market")]
	public int BaseMarketValue = 10;
}


public enum State
{
	Seed,
	Seedling,
	Sapling,
	Crossbreed,
	Mature,
	Fruiting,
	Ripe,
	Dying
}


using System;

[Serializable]
public struct Stage
{
	public State nextState;

	public float lifeLength;

	public float health;

	public float resources;

	public float yield;

	public GameObjectRef skinObject;

	public bool IgnoreConditions;

	public float lifeLengthSeconds => lifeLength * 60f;
}


using UnityEngine;

public class PlantSkin : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class PlatformEntity : BaseEntity
{
	private const float movementSpeed = 1f;

	private const float rotationSpeed = 10f;

	private const float radius = 10f;

	private Vector3 targetPosition = Vector3.zero;

	private Quaternion targetRotation = Quaternion.identity;

	protected void FixedUpdate()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient)
		{
			if (targetPosition == Vector3.zero || Vector3.Distance(((Component)this).transform.position, targetPosition) < 0.01f)
			{
				Vector2 val = Random.insideUnitCircle * 10f;
				targetPosition = ((Component)this).transform.position + new Vector3(val.x, 0f, val.y);
				targetPosition.y = WaterLevel.GetWaterOrTerrainSurface(targetPosition, waves: false, volumes: false) + 1f;
				targetRotation = Quaternion.LookRotation(targetPosition - ((Component)this).transform.position);
			}
			((Component)this).transform.SetPositionAndRotation(Vector3.MoveTowards(((Component)this).transform.position, targetPosition, Time.fixedDeltaTime * 1f), Quaternion.RotateTowards(((Component)this).transform.rotation, targetRotation, Time.fixedDeltaTime * 10f));
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}
}


using ProtoBuf;

public interface IEntityPingSource
{
	bool IsPingValid(MapNote note);
}


using Facepunch.Math;
using ProtoBuf;

public static class PlayerStateEx
{
	public static bool IsSaveStale(this PlayerState state)
	{
		int protocol = state.protocol;
		uint seed = state.seed;
		int saveCreatedTime = state.saveCreatedTime;
		int num = Epoch.FromDateTime(SaveRestore.SaveCreatedTime);
		if (270 == protocol && World.Seed == seed)
		{
			return num != saveCreatedTime;
		}
		return true;
	}
}


using UnityEngine;

public class PlayerAnimationEvents : MonoBehaviour
{
	private static readonly int Up = Animator.StringToHash("up");

	private static readonly int Right = Animator.StringToHash("right");
}


using System;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class PlayerBelt
{
	public static int ClientAutoSelectSlot = -1;

	public static uint ClientAutoSeletItemUID = 0u;

	public static EncryptedValue<int> SelectedSlot = -1;

	protected BasePlayer player;

	public static int MaxBeltSlots => 6;

	public PlayerBelt(BasePlayer player)
	{
		this.player = player;
	}

	public void DropActive(Vector3 position, Vector3 velocity)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		if (player.GetActiveShield(out var foundShield))
		{
			if (Interface.CallHook("OnPlayerActiveShieldDrop", (object)player, (object)foundShield) != null)
			{
				return;
			}
			DroppedItem droppedItem = foundShield.GetItem().Drop(position, velocity) as DroppedItem;
			if ((Object)(object)droppedItem != (Object)null)
			{
				droppedItem.DropReason = DroppedItem.DropReasonEnum.Death;
				droppedItem.DroppedBy = player.userID;
				droppedItem.DroppedTime = DateTime.UtcNow;
				Analytics.Azure.OnItemDropped(player, droppedItem, DroppedItem.DropReasonEnum.Death);
			}
		}
		Item activeItem = player.GetActiveItem();
		if (activeItem == null || Interface.CallHook("OnPlayerDropActiveItem", (object)player, (object)activeItem) != null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("PlayerBelt.DropActive", 0);
		try
		{
			DroppedItem droppedItem2 = activeItem.Drop(position, velocity) as DroppedItem;
			if ((Object)(object)droppedItem2 != (Object)null)
			{
				droppedItem2.DropReason = DroppedItem.DropReasonEnum.Death;
				droppedItem2.DroppedBy = player.userID;
				droppedItem2.DroppedTime = DateTime.UtcNow;
				Analytics.Azure.OnItemDropped(player, droppedItem2, DroppedItem.DropReasonEnum.Death);
			}
			player.svActiveItemID = default(ItemId);
			player.SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Item GetItemInSlot(int slot)
	{
		if ((Object)(object)player == (Object)null)
		{
			return null;
		}
		if ((Object)(object)player.inventory == (Object)null)
		{
			return null;
		}
		if (player.inventory.containerBelt == null)
		{
			return null;
		}
		return player.inventory.containerBelt.GetSlot(slot);
	}

	public Handcuffs GetRestraintItem()
	{
		if ((Object)(object)player == (Object)null)
		{
			return null;
		}
		if ((Object)(object)player.inventory == (Object)null)
		{
			return null;
		}
		if (player.inventory.containerBelt == null)
		{
			return null;
		}
		foreach (Item item in player.inventory.containerBelt.itemList)
		{
			if (item != null)
			{
				Handcuffs handcuffs = item.GetHeldEntity() as Handcuffs;
				if (!((Object)(object)handcuffs == (Object)null) && handcuffs.Locked)
				{
					return handcuffs;
				}
			}
		}
		return null;
	}

	public bool CanHoldItem()
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (player.IsWounded())
		{
			return false;
		}
		if (player.IsSleeping())
		{
			return false;
		}
		if (player.isMounted && !player.GetMounted().CanHoldItems())
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class PlayerBlueprints : EntityComponent<BasePlayer>
{
	public SteamInventory steamInventory;

	public void Reset()
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		if (persistantPlayerInfo.unlockedItems != null)
		{
			persistantPlayerInfo.unlockedItems.Clear();
		}
		else
		{
			persistantPlayerInfo.unlockedItems = Pool.Get<List<int>>();
		}
		base.baseEntity.PersistantPlayerInfo = persistantPlayerInfo;
		base.baseEntity.SendNetworkUpdate();
	}

	public void UnlockAll()
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		foreach (ItemBlueprint bp in ItemManager.bpList)
		{
			if (bp.userCraftable && !bp.defaultBlueprint && !persistantPlayerInfo.unlockedItems.Contains(bp.targetItem.itemid))
			{
				persistantPlayerInfo.unlockedItems.Add(bp.targetItem.itemid);
			}
		}
		base.baseEntity.PersistantPlayerInfo = persistantPlayerInfo;
		base.baseEntity.SendNetworkUpdateImmediate();
		base.baseEntity.ClientRPC(RpcTarget.Player("UnlockedBlueprint", base.baseEntity), 0);
	}

	public bool IsUnlocked(ItemDefinition itemDef)
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		if (persistantPlayerInfo.unlockedItems != null)
		{
			return persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid);
		}
		return false;
	}

	public void Unlock(ItemDefinition itemDef)
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		if (!persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
		{
			persistantPlayerInfo.unlockedItems.Add(itemDef.itemid);
			base.baseEntity.PersistantPlayerInfo = persistantPlayerInfo;
			base.baseEntity.SendNetworkUpdateImmediate();
			base.baseEntity.ClientRPC(RpcTarget.Player("UnlockedBlueprint", base.baseEntity), itemDef.itemid);
			base.baseEntity.stats.Add("blueprint_studied", 1, (Stats)5);
		}
	}

	public bool HasUnlocked(ItemDefinition targetItem)
	{
		if (base.baseEntity.IsCraftingTutorialBlocked(targetItem, out var forceUnlock))
		{
			return false;
		}
		if (forceUnlock)
		{
			return true;
		}
		if (Object.op_Implicit((Object)(object)targetItem.Blueprint))
		{
			if ((Object)(object)targetItem.Blueprint.RequireUnlockedItem != (Object)null && !HasUnlocked(targetItem.Blueprint.RequireUnlockedItem))
			{
				return false;
			}
			if (targetItem.Blueprint.NeedsSteamItem)
			{
				if ((Object)(object)targetItem.steamItem != (Object)null)
				{
					if ((Object)(object)targetItem.steamItem.UnlockedViaSteamItem != (Object)null)
					{
						if (!steamInventory.HasItem(targetItem.steamItem.UnlockedViaSteamItem.id))
						{
							return false;
						}
					}
					else if (!steamInventory.HasItem(targetItem.steamItem.id))
					{
						return false;
					}
				}
				if (base.baseEntity.UnlockAllSkins)
				{
					return true;
				}
				if ((Object)(object)targetItem.steamItem == (Object)null)
				{
					bool flag = false;
					ItemSkinDirectory.Skin[] skins = targetItem.skins;
					for (int i = 0; i < skins.Length; i++)
					{
						ItemSkinDirectory.Skin skin = skins[i];
						if (steamInventory.HasItem(skin.id))
						{
							flag = true;
							break;
						}
					}
					if (!flag && targetItem.skins2 != null)
					{
						IPlayerItemDefinition[] skins2 = targetItem.skins2;
						foreach (IPlayerItemDefinition val in skins2)
						{
							if (steamInventory.HasItem(val.DefinitionId))
							{
								flag = true;
								break;
							}
						}
					}
					if (!flag)
					{
						return false;
					}
				}
				return true;
			}
			if (targetItem.Blueprint.NeedsSteamDLC)
			{
				if (base.baseEntity.UnlockAllSkins)
				{
					return true;
				}
				if ((Object)(object)targetItem.steamDlc != (Object)null && targetItem.steamDlc.HasLicense(base.baseEntity.userID))
				{
					return true;
				}
			}
		}
		int[] defaultBlueprints = ItemManager.defaultBlueprints;
		for (int i = 0; i < defaultBlueprints.Length; i++)
		{
			if (defaultBlueprints[i] == targetItem.itemid)
			{
				return true;
			}
		}
		if (base.baseEntity.isServer)
		{
			return IsUnlocked(targetItem);
		}
		return false;
	}

	public bool CanCraft(int itemid, int skinItemId, ulong playerId)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemid);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", (object)this, (object)itemDefinition, (object)skinItemId);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (skinItemId != 0 && !base.baseEntity.UnlockAllSkins && !CheckSkinOwnership(skinItemId, playerId))
		{
			return false;
		}
		if (base.baseEntity.currentCraftLevel < (float)itemDefinition.Blueprint.GetWorkbenchLevel())
		{
			return false;
		}
		if (HasUnlocked(itemDefinition))
		{
			return true;
		}
		return false;
	}

	public bool CheckSkinOwnership(int skinItemId, ulong playerId)
	{
		ItemSkinDirectory.Skin skin = ItemSkinDirectory.FindByInventoryDefinitionId(skinItemId);
		if ((Object)(object)skin.invItem != (Object)null && skin.invItem.HasUnlocked(playerId))
		{
			return true;
		}
		return steamInventory.HasItem(skinItemId);
	}
}


using UnityEngine;

public class PlayerEyes : EntityComponent<BasePlayer>
{
	public static readonly Vector3 EyeOffset = new Vector3(0f, 1.5f, 0f);

	public static readonly Vector3 DuckOffset = new Vector3(0f, -0.6f, 0f);

	public static readonly Vector3 CrawlOffset = new Vector3(0f, -1.15f, 0.175f);

	public static readonly Vector3 ParachuteOffset = new Vector3(0f, -1.45f, 0.3f);

	public Vector3 thirdPersonSleepingOffset = new Vector3(0.43f, 1.25f, 0.7f);

	public LazyAimProperties defaultLazyAim;

	private EncryptedValue<Vector3> viewOffset = Vector3.zero;

	public Vector3 worldMountedPosition
	{
		get
		{
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)base.baseEntity) && base.baseEntity.isMounted)
			{
				Vector3 val = base.baseEntity.GetMounted().EyePositionForPlayer(base.baseEntity, GetLookRotation());
				if (val != Vector3.zero)
				{
					return val;
				}
			}
			return worldStandingPosition;
		}
	}

	public Vector3 worldStandingPosition => ((Component)this).transform.position + EyeOffset;

	public Vector3 worldCrouchedPosition => worldStandingPosition + DuckOffset;

	public Vector3 worldCrawlingPosition => worldStandingPosition + CrawlOffset;

	public Vector3 position
	{
		get
		{
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)base.baseEntity) && base.baseEntity.isMounted)
			{
				Vector3 val = base.baseEntity.GetMounted().EyePositionForPlayer(base.baseEntity, GetLookRotation());
				if (val != Vector3.zero)
				{
					return val;
				}
				return ((Component)this).transform.position + ((Component)this).transform.up * (EyeOffset.y + viewOffset.Get().y) + BodyLeanOffset;
			}
			return ((Component)this).transform.position + ((Component)this).transform.rotation * (EyeOffset + (Vector3)viewOffset) + BodyLeanOffset;
		}
	}

	private Vector3 BodyLeanOffset => Vector3.zero;

	public Vector3 center
	{
		get
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)base.baseEntity) && base.baseEntity.isMounted)
			{
				Vector3 val = base.baseEntity.GetMounted().EyeCenterForPlayer(base.baseEntity, GetLookRotation());
				if (val != Vector3.zero)
				{
					return val;
				}
			}
			return ((Component)this).transform.position + ((Component)this).transform.up * (EyeOffset.y + DuckOffset.y);
		}
	}

	public Vector3 offset => ((Component)this).transform.up * (EyeOffset.y + viewOffset.Get().y);

	public Quaternion rotation
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return parentRotation * bodyRotation;
		}
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			bodyRotation = Quaternion.Inverse(parentRotation) * value;
		}
	}

	public Quaternion bodyRotation { get; set; }

	public Quaternion parentRotation
	{
		get
		{
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			if (base.baseEntity.isMounted || !((Object)(object)((Component)this).transform.parent != (Object)null))
			{
				return Quaternion.identity;
			}
			Quaternion val = ((Component)this).transform.parent.rotation;
			return Quaternion.Euler(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f);
		}
	}

	public void NetworkUpdate(Quaternion rot)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (base.baseEntity.IsCrawling())
		{
			viewOffset = CrawlOffset;
		}
		else
		{
			viewOffset = Vector3.zero;
			viewOffset = Vector3.Lerp((Vector3)viewOffset, DuckOffset, base.baseEntity.modelState.ducking);
		}
		bodyRotation = rot;
	}

	public Vector3 MovementForward()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = rotation;
		return Quaternion.Euler(new Vector3(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f)) * Vector3.forward;
	}

	public Vector3 MovementRight()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = rotation;
		return Quaternion.Euler(new Vector3(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f)) * Vector3.right;
	}

	public Ray BodyRay()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Ray(position, BodyForward());
	}

	public Vector3 BodyForward()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return rotation * Vector3.forward;
	}

	public Vector3 BodyRight()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return rotation * Vector3.right;
	}

	public Vector3 BodyUp()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return rotation * Vector3.up;
	}

	public Ray HeadRay()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Ray(position, HeadForward());
	}

	public Vector3 HeadForward()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetLookRotation() * Vector3.forward;
	}

	public Vector3 HeadRight()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetLookRotation() * Vector3.right;
	}

	public Vector3 HeadUp()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetLookRotation() * Vector3.up;
	}

	public Quaternion GetLookRotation()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return rotation;
	}

	public Quaternion GetAimRotation()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return rotation;
	}
}


using System;
using Rust;

public class PlayerInput : EntityComponent<BasePlayer>
{
	public InputState state = new InputState();

	[NonSerialized]
	public bool hadInputBuffer = true;

	protected void OnDisable()
	{
		if (!Application.isQuitting)
		{
			state.Clear();
		}
	}
}


public static class PlayerInventoryErrors
{
	public static readonly Phrase InvalidItem = new Phrase("error_activeitembroken", "Invalid item");

	public static readonly Phrase CannotMoveItem = new Phrase("error_cannotmoveitem", "Cannot move item!");

	public static readonly Phrase ContainerLocked = new Phrase("error_containerlocked", "Container locked");

	public static readonly Phrase InvalidContainer = new Phrase("error_invalidcontainer", "Invalid container");

	public static readonly Phrase DoesntAcceptPlayerItems = new Phrase("error_doesntacceptplayeritems", "Container does not accept player items!");

	public static readonly Phrase CannotEquipBroken = new Phrase("error_cannotequipbroken", "Cannot equip a broken item");

	public static readonly Phrase ActiveItemBroken = new Phrase("error_activeitembroken", "Your active item was broken!");

	public static readonly Phrase LootableDoesntExist = new Phrase("error_lootabledoesntexist", "Lootable doesn't exist!");
}


using System;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class PlayerModel : ListComponent<PlayerModel>
{
	public enum MountPoses
	{
		Chair = 0,
		Driving = 1,
		Horseback = 2,
		HeliUnarmed = 3,
		HeliArmed = 4,
		HandMotorBoat = 5,
		MotorBoatPassenger = 6,
		SitGeneric = 7,
		SitRaft = 8,
		StandDrive = 9,
		SitShootingGeneric = 10,
		SitMinicopter_Pilot = 11,
		SitMinicopter_Passenger = 12,
		ArcadeLeft = 13,
		ArcadeRight = 14,
		SitSummer_Ring = 15,
		SitSummer_BoogieBoard = 16,
		SitCarPassenger = 17,
		SitSummer_Chair = 18,
		SitRaft_NoPaddle = 19,
		Sit_SecretLab = 20,
		Sit_Workcart = 21,
		Sit_Cardgame = 22,
		Sit_Crane = 23,
		Sit_Snowmobile_Shooting = 24,
		Sit_RetroSnowmobile_Shooting = 25,
		Driving_Snowmobile = 26,
		ZiplineHold = 27,
		Sit_Locomotive = 28,
		Sit_Throne = 29,
		Parachute = 30,
		Sit_DPV = 31,
		Standing_Ballista = 32,
		Sit_BatteringRam = 33,
		VineSwinging = 34,
		Sit_Ejectorseat = 35,
		Standing = 128
	}

	protected static int speed = Animator.StringToHash("speed");

	protected static int acceleration = Animator.StringToHash("acceleration");

	protected static int rotationYaw = Animator.StringToHash("rotationYaw");

	protected static int forward = Animator.StringToHash("forward");

	protected static int right = Animator.StringToHash("right");

	protected static int up = Animator.StringToHash("up");

	protected static int ducked = Animator.StringToHash("ducked");

	protected static int grounded = Animator.StringToHash("grounded");

	protected static int crawling = Animator.StringToHash("crawling");

	protected static int waterlevel = Animator.StringToHash("waterlevel");

	protected static int attack = Animator.StringToHash("attack");

	protected static int attack_alt = Animator.StringToHash("attack_alt");

	protected static int deploy = Animator.StringToHash("deploy");

	protected static int turnOn = Animator.StringToHash("turnOn");

	protected static int turnOff = Animator.StringToHash("turnOff");

	protected static int reload = Animator.StringToHash("reload");

	protected static int throwWeapon = Animator.StringToHash("throw");

	protected static int holster = Animator.StringToHash("holster");

	protected static int aiming = Animator.StringToHash("aiming");

	protected static int onLadder = Animator.StringToHash("onLadder");

	protected static int posing = Animator.StringToHash("posing");

	protected static int poseType = Animator.StringToHash("poseType");

	protected static int relaxGunPose = Animator.StringToHash("relaxGunPose");

	protected static int vehicle_aim_yaw = Animator.StringToHash("vehicleAimYaw");

	protected static int vehicle_aim_speed = Animator.StringToHash("vehicleAimYawSpeed");

	protected static int usePoseTransition = Animator.StringToHash("usePoseTransition");

	protected static int onPhone = Animator.StringToHash("onPhone");

	protected static int leftFootIK = Animator.StringToHash("leftFootIK");

	protected static int rightFootIK = Animator.StringToHash("rightFootIK");

	protected static int vehicleSteering = Animator.StringToHash("vehicleSteering");

	protected static int sitReaction = Animator.StringToHash("sitReaction");

	protected static int forwardReaction = Animator.StringToHash("forwardReaction");

	protected static int rightReaction = Animator.StringToHash("rightReaction");

	protected static int ladderType = Animator.StringToHash("ladderType");

	protected static int hasParachute = Animator.StringToHash("hasParachute");

	protected static int nonGroundedTime = Animator.StringToHash("nonGroundedTime");

	protected static int deployParachuteTrigger = Animator.StringToHash("deployParachute");

	protected static int catching = Animator.StringToHash("waitingToCatch");

	protected static int shieldBlockingParam = Animator.StringToHash("shieldBlocking");

	protected static int shieldDeploy = Animator.StringToHash("ShieldDeploy");

	protected static int shieldMeleeAttackParam = Animator.StringToHash("shieldMeleeAttack");

	public BoxCollider collision;

	public GameObject censorshipCube;

	public GameObject censorshipCubeBreasts;

	public GameObject jawBone;

	public GameObject neckBone;

	public GameObject headBone;

	public EyeController eyeController;

	public EyeBlink blinkController;

	public Transform[] SpineBones;

	public Transform leftFootBone;

	public Transform rightFootBone;

	public Transform leftHandPropBone;

	public Transform rightHandPropBone;

	public Vector3 rightHandTarget;

	public bool isPreview;

	[Header("IK")]
	public Vector3 leftHandTargetPosition;

	public Quaternion leftHandTargetRotation;

	public Vector3 rightHandTargetPosition;

	public Quaternion rightHandTargetRotation;

	public float steeringTargetDegrees;

	public Vector3 rightFootTargetPosition;

	public Quaternion rightFootTargetRotation;

	public Vector3 leftFootTargetPosition;

	public Quaternion leftFootTargetRotation;

	public LegsAnimator legsAnimator;

	public RuntimeAnimatorController CinematicAnimationController;

	public Avatar DefaultAvatar;

	public Avatar CinematicAvatar;

	public RuntimeAnimatorController DefaultHoldType;

	public RuntimeAnimatorController SleepGesture;

	public RuntimeAnimatorController CrawlToIncapacitatedGesture;

	public RuntimeAnimatorController CrawlToIncapacitatedGestureHandcuff;

	public RuntimeAnimatorController StandToIncapacitatedGesture;

	[NonSerialized]
	public RuntimeAnimatorController CurrentGesture;

	[Header("Skin")]
	public SkinSetCollection MaleSkin;

	public SkinSetCollection FemaleSkin;

	public SubsurfaceProfile subsurfaceProfile;

	[Header("Parameters")]
	[Range(0f, 1f)]
	public float voiceVolume;

	[Range(0f, 1f)]
	public float skinColor = 1f;

	[Range(0f, 1f)]
	public float skinNumber = 1f;

	[Range(0f, 1f)]
	public float meshNumber;

	[Range(0f, 1f)]
	public float hairNumber;

	[Range(0f, 1f)]
	public int skinType;

	public MovementSounds movementSounds;

	public bool showSash;

	public int tempPoseType;

	public uint underwearSkin;

	public Transform[] Shoulders;

	public Transform[] AdditionalSpineBones;

	public ulong overrideSkinSeed { get; private set; }

	public bool IsFemale => skinType == 1;

	public SkinSetCollection SkinSet
	{
		get
		{
			if (!IsFemale)
			{
				return MaleSkin;
			}
			return FemaleSkin;
		}
	}

	public Quaternion AimAngles { get; set; }

	public Quaternion LookAngles { get; set; }

	private static Vector3 GetFlat(Vector3 dir)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		dir.y = 0f;
		return ((Vector3)(ref dir)).normalized;
	}

	public static void RebuildAll()
	{
	}
}


public enum MountPoses
{
	Chair = 0,
	Driving = 1,
	Horseback = 2,
	HeliUnarmed = 3,
	HeliArmed = 4,
	HandMotorBoat = 5,
	MotorBoatPassenger = 6,
	SitGeneric = 7,
	SitRaft = 8,
	StandDrive = 9,
	SitShootingGeneric = 10,
	SitMinicopter_Pilot = 11,
	SitMinicopter_Passenger = 12,
	ArcadeLeft = 13,
	ArcadeRight = 14,
	SitSummer_Ring = 15,
	SitSummer_BoogieBoard = 16,
	SitCarPassenger = 17,
	SitSummer_Chair = 18,
	SitRaft_NoPaddle = 19,
	Sit_SecretLab = 20,
	Sit_Workcart = 21,
	Sit_Cardgame = 22,
	Sit_Crane = 23,
	Sit_Snowmobile_Shooting = 24,
	Sit_RetroSnowmobile_Shooting = 25,
	Driving_Snowmobile = 26,
	ZiplineHold = 27,
	Sit_Locomotive = 28,
	Sit_Throne = 29,
	Parachute = 30,
	Sit_DPV = 31,
	Standing_Ballista = 32,
	Sit_BatteringRam = 33,
	VineSwinging = 34,
	Sit_Ejectorseat = 35,
	Standing = 128
}


using System;
using UnityEngine;

public class PlayerModelCinematicList : PrefabAttribute, IClientComponent
{
	[Serializable]
	public struct PlayerModelCinematicAnimation
	{
		public string StateName;

		public string ClipName;

		public float Length;
	}

	public PlayerModelCinematicAnimation[] Animations;

	protected override Type GetIndexedType()
	{
		return typeof(PlayerModelCinematicList);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
	}
}


using System;

[Serializable]
public struct PlayerModelCinematicAnimation
{
	public string StateName;

	public string ClipName;

	public float Length;
}


using UnityEngine;

public class PlayerModelReactionEnded : StateMachineBehaviour
{
}


using UnityEngine;
using UnityEngine.UI;

public class PlayerNameTag : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public Text text;

	public Gradient color;

	public float minDistance = 3f;

	public float maxDistance = 10f;

	public Vector3 positionOffset;

	public Transform parentBone;
}


[Factory("nametags")]
public class nametags : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static bool enabled = true;
}


public class PlayerVoiceRecorder : EntityComponent<BasePlayer>
{
}


public class PlayerVoiceSpeaker : EntityComponent<BasePlayer>
{
	public VoiceProcessor voiceProcessor;
}


using UnityEngine;

public class VoiceProcessor : EntityComponentBase
{
	public AudioSource mouthSpeaker;

	public PlayerVoiceSpeaker playerSpeaker;

	public float volumeMultiplier = 1f;
}


public static class LocalPlayer
{
}


using System;
using UnityEngine;

public class BaseMovement : MonoBehaviour
{
	[NonSerialized]
	public bool adminCheat;

	[NonSerialized]
	public float adminSpeed = 1f;
}


using UnityEngine;

public class PlayerWalkMovement : BaseMovement
{
	public const float WaterLevelHead = 0.75f;

	public const float WaterLevelNeck = 0.65f;

	public PhysicMaterial zeroFrictionMaterial;

	public PhysicMaterial highFrictionMaterial;
}


using System;

public class PlayerCache : StableObjectCache<BasePlayer>
{
	public ValidView<BasePlayer> ValidPlayers => new ValidView<BasePlayer>((StableObjectCache<BasePlayer>)this);

	public ReadOnlySpan<BasePlayer> Players => base.Objects;

	public ReadOnlySpan<BaseEntity> AsEntities
	{
		get
		{
			BaseEntity[] objects = base.Objects;
			return objects;
		}
	}

	public PlayerCache(int initialCapacity)
		: base(initialCapacity)
	{
	}
}


using System.Collections.Generic;
using System.Linq;
using ConVar;
using UnityEngine;

public class CombatLog
{
	public struct Event
	{
		public float time;

		public ulong attacker_id;

		public ulong target_id;

		public string attacker;

		public string target;

		public string weapon;

		public string ammo;

		public string bone;

		public HitArea area;

		public float distance;

		public float health_old;

		public float health_new;

		public string info;

		public int proj_hits;

		public float proj_integrity;

		public float proj_travel;

		public float proj_mismatch;

		public int desync;

		public bool attacker_dead;
	}

	private const string selfname = "you";

	private const string noname = "N/A";

	private BasePlayer player;

	private Queue<Event> storage;

	private static Dictionary<ulong, Queue<Event>> players = new Dictionary<ulong, Queue<Event>>();

	public float LastActive { get; private set; }

	public CombatLog(BasePlayer player)
	{
		this.player = player;
	}

	public void Init()
	{
		storage = Get(player.userID);
		LastActive = storage.LastOrDefault().time;
	}

	public void Save()
	{
	}

	public void LogInvalid(BasePlayer player, AttackEntity weapon, string description)
	{
		Log(player, weapon, null, description);
	}

	public void LogInvalid(HitInfo info, string description)
	{
		Log(info.Initiator, info.Weapon, info.HitEntity as BaseCombatEntity, description, info.ProjectilePrefab, info.ProjectileID, -1f, info);
	}

	public void LogAttack(HitInfo info, string description, float oldHealth = -1f)
	{
		Log(info.Initiator, info.Weapon, info.HitEntity as BaseCombatEntity, description, info.ProjectilePrefab, info.ProjectileID, oldHealth, info);
	}

	public void Log(BaseEntity attacker, AttackEntity weapon, BaseCombatEntity hitEntity, string description, Projectile projectilePrefab = null, int projectileId = -1, float healthOld = -1f, HitInfo hitInfo = null)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		Event val = default(Event);
		float distance = 0f;
		if (hitInfo != null)
		{
			distance = (hitInfo.IsProjectile() ? hitInfo.ProjectileDistance : Vector3.Distance(hitInfo.PointStart, hitInfo.HitPositionWorld));
			if (hitInfo.Initiator is BasePlayer basePlayer && (Object)(object)hitInfo.HitEntity != (Object)(object)hitInfo.Initiator)
			{
				val.attacker_dead = basePlayer.IsDead() || basePlayer.IsWounded();
			}
		}
		float health_new = (((Object)(object)hitEntity != (Object)null) ? hitEntity.Health() : 0f);
		val.time = Time.realtimeSinceStartup;
		val.attacker_id = ((NetworkableId)(((Object)(object)attacker != (Object)null && attacker.net != null) ? attacker.net.ID : default(NetworkableId))).Value;
		val.target_id = ((NetworkableId)(((Object)(object)hitEntity != (Object)null && hitEntity.net != null) ? hitEntity.net.ID : default(NetworkableId))).Value;
		val.attacker = (((Object)(object)player == (Object)(object)attacker) ? "you" : (attacker?.ShortPrefabName ?? "N/A"));
		val.target = (((Object)(object)player == (Object)(object)hitEntity) ? "you" : (hitEntity?.ShortPrefabName ?? "N/A"));
		val.weapon = (((Object)(object)weapon != (Object)null) ? ((Object)weapon).name : "N/A");
		val.ammo = ((!((Object)(object)projectilePrefab != (Object)null)) ? "N/A" : ((projectilePrefab != null) ? ((Object)projectilePrefab).name : null));
		val.bone = hitInfo?.boneName ?? "N/A";
		val.area = hitInfo?.boneArea ?? ((HitArea)0);
		val.distance = distance;
		val.health_old = ((healthOld == -1f) ? 0f : healthOld);
		val.health_new = health_new;
		val.info = description ?? string.Empty;
		val.proj_hits = hitInfo?.ProjectileHits ?? 0;
		val.proj_integrity = hitInfo?.ProjectileIntegrity ?? 0f;
		val.proj_travel = hitInfo?.ProjectileTravelTime ?? 0f;
		val.proj_mismatch = hitInfo?.ProjectileTrajectoryMismatch ?? 0f;
		BasePlayer basePlayer2 = attacker as BasePlayer;
		if ((Object)(object)basePlayer2 != (Object)null && (Object)(object)projectilePrefab != (Object)null && basePlayer2.firedProjectiles.TryGetValue(projectileId, out var value))
		{
			val.desync = (int)(value.desyncLifeTime * 1000f);
		}
		Log(val);
	}

	private void Log(Event val)
	{
		LastActive = Time.realtimeSinceStartup;
		if (storage != null)
		{
			storage.Enqueue(val);
			int num = Mathf.Max(0, Server.combatlogsize);
			while (storage.Count > num)
			{
				storage.Dequeue();
			}
		}
	}

	public string Get(int count, NetworkableId filterByAttacker = default(NetworkableId), bool json = false, bool isAdmin = false, ulong requestingUser = 0uL)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		if (storage == null)
		{
			return string.Empty;
		}
		if (storage.Count == 0 && !json)
		{
			return "Combat log empty.";
		}
		TextTable val = new TextTable();
		val.AddColumn("time");
		val.AddColumn("attacker");
		val.AddColumn("id");
		val.AddColumn("target");
		val.AddColumn("id");
		val.AddColumn("weapon");
		val.AddColumn("ammo");
		val.AddColumn("area");
		val.AddColumn("distance");
		val.AddColumn("old_hp");
		val.AddColumn("new_hp");
		val.AddColumn("info");
		val.AddColumn("hits");
		val.AddColumn("integrity");
		val.AddColumn("travel");
		val.AddColumn("mismatch");
		val.AddColumn("desync");
		int num = storage.Count - count;
		int num2 = ((!player.IsAdmin && !player.IsDeveloper) ? Server.combatlogdelay : 0);
		int num3 = 0;
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		foreach (Event item in storage)
		{
			if (num > 0)
			{
				num--;
			}
			else
			{
				if ((((NetworkableId)(ref filterByAttacker)).IsValid && item.attacker_id != filterByAttacker.Value) || ((Object)(object)activeGameMode != (Object)null && !activeGameMode.returnValidCombatlog && !isAdmin && item.proj_hits > 0))
				{
					continue;
				}
				float num4 = Time.realtimeSinceStartup - item.time;
				if (num4 >= (float)num2)
				{
					string text = num4.ToString("0.00s");
					string attacker = item.attacker;
					ulong attacker_id = item.attacker_id;
					string text2 = attacker_id.ToString();
					string target = item.target;
					attacker_id = item.target_id;
					string text3 = attacker_id.ToString();
					string weapon = item.weapon;
					string ammo = item.ammo;
					string text4 = HitAreaUtil.Format(item.area).ToLower();
					float distance = item.distance;
					string text5 = distance.ToString("0.0m");
					distance = item.health_old;
					string text6 = distance.ToString("0.0");
					distance = item.health_new;
					string text7 = distance.ToString("0.0");
					string text8 = item.info;
					if (!player.IsDestroyed && (ulong)player.userID == requestingUser && item.attacker_dead)
					{
						text8 = "you died first (" + text8 + ")";
					}
					int proj_hits = item.proj_hits;
					string text9 = proj_hits.ToString();
					distance = item.proj_integrity;
					string text10 = distance.ToString("0.00");
					distance = item.proj_travel;
					string text11 = distance.ToString("0.00s");
					distance = item.proj_mismatch;
					string text12 = distance.ToString("0.00m");
					proj_hits = item.desync;
					string text13 = proj_hits.ToString();
					val.AddRow(new string[17]
					{
						text, attacker, text2, target, text3, weapon, ammo, text4, text5, text6,
						text7, text8, text9, text10, text11, text12, text13
					});
				}
				else
				{
					num3++;
				}
			}
		}
		string text14;
		if (json)
		{
			text14 = val.ToJson(true);
		}
		else
		{
			text14 = ((object)val).ToString();
			if (num3 > 0)
			{
				text14 = text14 + "+ " + num3 + " " + ((num3 > 1) ? "events" : "event");
				text14 = text14 + " in the last " + num2 + " " + ((num2 > 1) ? "seconds" : "second");
			}
		}
		return text14;
	}

	public static Queue<Event> Get(ulong id)
	{
		if (players.TryGetValue(id, out var value))
		{
			return value;
		}
		value = new Queue<Event>();
		players.Add(id, value);
		return value;
	}
}


public struct Event
{
	public float time;

	public ulong attacker_id;

	public ulong target_id;

	public string attacker;

	public string target;

	public string weapon;

	public string ammo;

	public string bone;

	public HitArea area;

	public float distance;

	public float health_old;

	public float health_new;

	public string info;

	public int proj_hits;

	public float proj_integrity;

	public float proj_travel;

	public float proj_mismatch;

	public int desync;

	public bool attacker_dead;
}


public enum Stats
{
	Steam = 1,
	Server = 2,
	Life = 4,
	All = -1
}


using ConVar;

public class PlayerStatistics
{
	public SteamStatistics steam;

	public ServerStatistics server;

	public CombatLog combat;

	public BasePlayer forPlayer;

	private TimeSince lastSteamSave;

	public PlayerStatistics(BasePlayer player)
	{
		steam = new SteamStatistics(player);
		server = new ServerStatistics(player);
		combat = new CombatLog(player);
		forPlayer = player;
	}

	public void Init()
	{
		steam.Init();
		server.Init();
		combat.Init();
	}

	public void Save(bool forceSteamSave = false)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (Server.official && (forceSteamSave || TimeSince.op_Implicit(lastSteamSave) > 60f))
		{
			lastSteamSave = TimeSince.op_Implicit(0f);
			steam.Save();
		}
		server.Save();
		combat.Save();
	}

	public void Add(string name, int val, Stats stats = Stats.Steam)
	{
		if ((stats & Stats.Steam) != 0)
		{
			steam.Add(name, val);
		}
		if ((stats & Stats.Server) != 0)
		{
			server.Add(name, val);
		}
		if ((stats & Stats.Life) != 0)
		{
			forPlayer.LifeStoryGenericStat(name, val);
		}
	}
}


using System.Collections.Generic;

public class ServerStatistics
{
	public class Storage
	{
		private Dictionary<string, int> dict = new Dictionary<string, int>();

		public int Get(string name)
		{
			dict.TryGetValue(name, out var value);
			return value;
		}

		public void Add(string name, int val)
		{
			if (dict.ContainsKey(name))
			{
				dict[name] += val;
			}
			else
			{
				dict.Add(name, val);
			}
		}
	}

	private BasePlayer player;

	private Storage storage;

	private static Dictionary<ulong, Storage> players = new Dictionary<ulong, Storage>();

	public ServerStatistics(BasePlayer player)
	{
		this.player = player;
	}

	public void Init()
	{
		storage = Get(player.userID);
	}

	public void Save()
	{
	}

	public void Add(string name, int val)
	{
		if (storage != null)
		{
			storage.Add(name, val);
		}
	}

	public static Storage Get(ulong id)
	{
		if (players.TryGetValue(id, out var value))
		{
			return value;
		}
		value = new Storage();
		players.Add(id, value);
		return value;
	}
}


using System.Collections.Generic;

public class Storage
{
	private Dictionary<string, int> dict = new Dictionary<string, int>();

	public int Get(string name)
	{
		dict.TryGetValue(name, out var value);
		return value;
	}

	public void Add(string name, int val)
	{
		if (dict.ContainsKey(name))
		{
			dict[name] += val;
		}
		else
		{
			dict.Add(name, val);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using ConVar;
using UnityEngine;

public class SteamStatistics
{
	private BasePlayer player;

	public Dictionary<string, int> intStats = new Dictionary<string, int>();

	private Task refresh;

	public SteamStatistics(BasePlayer p)
	{
		player = p;
	}

	public void Init()
	{
		if (PlatformService.Instance.IsValid)
		{
			refresh = PlatformService.Instance.LoadPlayerStats((ulong)player.userID);
			intStats.Clear();
		}
	}

	public void Save()
	{
		if (PlatformService.Instance.IsValid)
		{
			PlatformService.Instance.SavePlayerStats((ulong)player.userID);
		}
	}

	public void Add(string name, int var)
	{
		if (!PlatformService.Instance.IsValid || refresh == null || !refresh.IsCompleted)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("PlayerStats.Add", 0);
		try
		{
			int value = 0;
			if (intStats.TryGetValue(name, out value))
			{
				intStats[name] += var;
				PlatformService.Instance.SetPlayerStatInt((ulong)player.userID, name, (long)intStats[name]);
				return;
			}
			value = (int)PlatformService.Instance.GetPlayerStatInt((ulong)player.userID, name, 0L);
			if (!PlatformService.Instance.SetPlayerStatInt((ulong)player.userID, name, (long)(value + var)))
			{
				if (Global.developer > 0)
				{
					Debug.LogWarning((object)("[STEAMWORKS] Couldn't SetUserStat: " + name));
				}
			}
			else
			{
				intStats.Add(name, value + var);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public int Get(string name)
	{
		if (!PlatformService.Instance.IsValid)
		{
			return 0;
		}
		if (refresh == null || !refresh.IsCompleted)
		{
			return 0;
		}
		TimeWarning val = TimeWarning.New("PlayerStats.Get", 0);
		try
		{
			if (intStats.TryGetValue(name, out var value))
			{
				return value;
			}
			return (int)PlatformService.Instance.GetPlayerStatInt((ulong)player.userID, name, 0L);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class PlayerCorpse : LootableCorpse
{
	public Buoyancy buoyancy;

	public const Flags Flag_Buoyant = Flags.Reserved6;

	public uint underwearSkin;

	public PlayerBonePosData bonePosData;

	public const Flags BlockClothingRebuild = Flags.Reserved2;

	private Vector3 prevLocalPos;

	private const float SLEEP_CHECK_FREQUENCY = 10f;

	public Ragdoll CorpseRagdollScript { get; private set; }

	public override bool CorpseIsRagdoll => (Object)(object)CorpseRagdollScript != (Object)null;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public bool IsBuoyant()
	{
		return HasFlag(Flags.Reserved6);
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		if ((baseEntity.InSafeZone() || InSafeZone()) && (ulong)baseEntity.userID != playerSteamID)
		{
			return false;
		}
		return base.OnStartBeingLooted(baseEntity);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if ((Object)(object)buoyancy == (Object)null)
		{
			Debug.LogWarning((object)("Player corpse has no buoyancy assigned, searching at runtime :" + ((Object)this).name));
			buoyancy = ((Component)this).GetComponent<Buoyancy>();
		}
		if ((Object)(object)buoyancy != (Object)null)
		{
			buoyancy.SubmergedChanged = BuoyancyChanged;
			buoyancy.forEntity = this;
		}
		if (Application.isLoadingSave)
		{
			CorpseRagdollScript = ((Component)this).GetComponent<Ragdoll>();
		}
		if (CorpseIsRagdoll)
		{
			CorpseRagdollScript.simOnServer = true;
			CorpseRagdollScript.ServerInit();
			((FacepunchBehaviour)this).InvokeRandomized((Action)SleepCheck, 5f, 10f, Random.Range(-1f, 1f));
		}
	}

	public override void ServerInitCorpse(BaseEntity pr, Vector3 posOnDeah, Quaternion rotOnDeath, BasePlayer.PlayerFlags playerFlagsOnDeath, ModelState modelState)
	{
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		parentEnt = pr;
		BasePlayer basePlayer = (BasePlayer)pr;
		CorpseRagdollScript = ((Component)this).GetComponent<Ragdoll>();
		SpawnPointInstance component = ((Component)this).GetComponent<SpawnPointInstance>();
		if ((Object)(object)component != (Object)null)
		{
			spawnGroup = component.parentSpawnPointUser as SpawnGroup;
		}
		Skeleton component2 = ((Component)this).GetComponent<Skeleton>();
		if ((Object)(object)component2 != (Object)null)
		{
			PlayerBonePosData.BonePosData bonePositionData = bonePosData.GetBonePositionData(playerFlagsOnDeath, modelState);
			if (bonePositionData != null)
			{
				component2.CopyFrom(bonePositionData.bonePositions, bonePositionData.boneRotations, true);
				Transform transform = component2.Bones[0].transform;
				transform.localEulerAngles += bonePositionData.rootRotationOffset;
			}
		}
		if (CorpseIsRagdoll)
		{
			Quaternion val = (((playerFlagsOnDeath & BasePlayer.PlayerFlags.Sleeping) != 0) ? Quaternion.identity : rotOnDeath);
			((Component)this).transform.SetPositionAndRotation(posOnDeah, val);
		}
		else
		{
			((Component)this).transform.SetPositionAndRotation(parentEnt.CenterPoint(), basePlayer.eyes.bodyRotation);
		}
	}

	public void BuoyancyChanged(bool isSubmerged)
	{
		if (!IsBuoyant())
		{
			SetFlag(Flags.Reserved6, isSubmerged, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}

	public void BecomeActive()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (CorpseIsRagdoll)
		{
			CorpseRagdollScript.BecomeActive();
			prevLocalPos = ((Component)this).transform.localPosition;
		}
	}

	public void BecomeInactive()
	{
		if (CorpseIsRagdoll)
		{
			CorpseRagdollScript.BecomeInactive();
		}
	}

	protected override void PushRagdoll(HitInfo info)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (CorpseIsRagdoll)
		{
			BecomeActive();
			PushRigidbodies(CorpseRagdollScript.rigidbodies, info.HitPositionWorld, info.attackNormal);
		}
		else
		{
			base.PushRagdoll(info);
		}
	}

	private void SleepCheck()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (!CorpseIsRagdoll)
		{
			return;
		}
		if (CorpseRagdollScript.IsKinematic)
		{
			if (!GamePhysics.Trace(new Ray(CenterPoint(), Vector3.down), 0f, out var _, 0.25f, -928830701, (QueryTriggerInteraction)1, this))
			{
				BecomeActive();
			}
		}
		else if (!rigidBody.IsSleeping() && !buoyancy.ShouldWake() && Vector3.SqrMagnitude(((Component)this).transform.localPosition - prevLocalPos) < 0.1f)
		{
			BecomeInactive();
		}
		prevLocalPos = ((Component)this).transform.localPosition;
	}

	public override bool BuoyancySleep(bool inWater)
	{
		if (CorpseIsRagdoll)
		{
			if (!rigidBody.IsSleeping())
			{
				BecomeInactive();
			}
			return true;
		}
		return base.BuoyancySleep(inWater);
	}

	public override bool BuoyancyWake()
	{
		if (CorpseIsRagdoll)
		{
			BecomeActive();
			return true;
		}
		return base.BuoyancyWake();
	}

	public override float BoundsPadding()
	{
		return 0.9f;
	}

	private void OnPhysicsNeighbourChanged()
	{
		BecomeActive();
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.lootableCorpse != null)
		{
			info.msg.lootableCorpse.underwearSkin = underwearSkin;
		}
		if (base.isServer && containers != null && containers.Length > 1 && !info.forDisk)
		{
			info.msg.storageBox = Pool.Get<StorageBox>();
			info.msg.storageBox.contents = containers[1].Save();
		}
	}

	public override string Categorize()
	{
		return "playercorpse";
	}
}


public class PointEntity : BaseEntity
{
}


using UnityEngine;

public class PropSway : MonoBehaviour
{
	public Transform pivotRotator;

	public float swaySpeed = 1f;

	public float swayDistance = 0.25f;

	public float lerpSpeed = 2f;
}


using ConVar;
using UnityEngine;

public class BushEntity : BaseEntity, IPrefabPreProcess
{
	public GameObjectRef prefab;

	public bool globalBillboard = true;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			DecorComponent[] components = PrefabAttribute.server.FindAll<DecorComponent>(prefabID);
			((Component)this).transform.ApplyDecorComponentsScaleOnly(components);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (globalBillboard)
		{
			TreeManager.OnTreeSpawned(this);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (globalBillboard)
		{
			TreeManager.OnTreeDestroyed(this);
		}
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (serverside)
		{
			globalBroadcast = Tree.global_broadcast;
		}
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class RandomItemDispenser : PrefabAttribute, IServerComponent
{
	[Serializable]
	public struct RandomItemChance
	{
		public ItemDefinition Item;

		public int Amount;

		[Range(0f, 1f)]
		public float Chance;

		public bool IgnoreInTutorial;
	}

	public RandomItemChance[] Chances;

	public bool OnlyAwardOne = true;

	protected override Type GetIndexedType()
	{
		return typeof(RandomItemDispenser);
	}

	public void DistributeItems(BasePlayer forPlayer, Vector3 distributorPosition)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		RandomItemChance[] chances = Chances;
		for (int i = 0; i < chances.Length; i++)
		{
			RandomItemChance itemChance = chances[i];
			if (!((Object)(object)forPlayer != (Object)null) || !forPlayer.IsInTutorial || !itemChance.IgnoreInTutorial)
			{
				bool flag = TryAward(itemChance, forPlayer, distributorPosition);
				if (OnlyAwardOne && flag)
				{
					break;
				}
			}
		}
	}

	private bool TryAward(RandomItemChance itemChance, BasePlayer forPlayer, Vector3 distributorPosition)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnRandomItemAward", (object)this, (object)itemChance, (object)forPlayer, (object)distributorPosition) != null)
		{
			return false;
		}
		float num = Random.Range(0f, 1f);
		if (itemChance.Chance >= num)
		{
			Item item = ItemManager.Create(itemChance.Item, itemChance.Amount, 0uL);
			if (item != null)
			{
				item.SetItemOwnership(forPlayer, ItemOwnershipPhrases.GatheredPhrase);
				if (Object.op_Implicit((Object)(object)forPlayer))
				{
					forPlayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
				}
				else
				{
					item.Drop(distributorPosition + Vector3.up * 0.5f, Vector3.up);
				}
			}
			return true;
		}
		return false;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct RandomItemChance
{
	public ItemDefinition Item;

	public int Amount;

	[Range(0f, 1f)]
	public float Chance;

	public bool IgnoreInTutorial;
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Serialization;

public class ResourceEntity : BaseEntity
{
	[FormerlySerializedAs("health")]
	public float startHealth;

	[FormerlySerializedAs("protection")]
	public ProtectionProperties baseProtection;

	public float health;

	public ResourceDispenser resourceDispenser;

	[NonSerialized]
	protected bool isKilled;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.resource != null)
		{
			health = info.msg.resource.health;
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			DecorComponent[] components = PrefabAttribute.server.FindAll<DecorComponent>(prefabID);
			((Component)this).transform.ApplyDecorComponentsScaleOnly(components);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		resourceDispenser = ((Component)this).GetComponent<ResourceDispenser>();
		if (health == 0f)
		{
			health = startHealth;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.resource = Pool.Get<BaseResource>();
			info.msg.resource.health = Health();
		}
	}

	public override float MaxHealth()
	{
		return startHealth;
	}

	public override float Health()
	{
		return health;
	}

	protected virtual void OnHealthChanged()
	{
	}

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isServer || isKilled || Interface.CallHook("OnEntityTakeDamage", (object)this, (object)info) != null)
		{
			return;
		}
		if ((Object)(object)resourceDispenser != (Object)null)
		{
			resourceDispenser.OnAttacked(info);
		}
		if (!info.DidGather)
		{
			if (Object.op_Implicit((Object)(object)baseProtection))
			{
				baseProtection.Scale(info.damageTypes);
			}
			float num = info.damageTypes.Total();
			health -= num;
			if (health <= 0f)
			{
				OnDied(info);
			}
			else
			{
				OnHealthChanged();
			}
		}
	}

	public virtual void OnDied(HitInfo info)
	{
		isKilled = true;
		Interface.CallHook("OnEntityDeath", (object)this, (object)info);
		Kill();
	}

	public override float BoundsPadding()
	{
		return 1f;
	}
}


using UnityEngine;

public class StagedResourceBreakEffect : MonoBehaviour, IEffect
{
}


using System;
using UnityEngine;

public class StagedResourceEntityInfo : PrefabAttribute
{
	[Serializable]
	public class ResourceStage
	{
		public float Health;

		public Mesh CollisionMesh;

		public Mesh[] VisualMeshLods;
	}

	public ResourceStage[] Stages;

	public Mesh GetCollisionMesh(int index)
	{
		index = Mathf.Clamp(index, 0, Stages.Length);
		return Stages[index].CollisionMesh;
	}

	public Mesh[] GetVisualMeshLods(int index)
	{
		index = Mathf.Clamp(index, 0, Stages.Length);
		return Stages[index].VisualMeshLods;
	}

	public float GetHealth(int index)
	{
		index = Mathf.Clamp(index, 0, Stages.Length);
		return Stages[index].Health;
	}

	protected override Type GetIndexedType()
	{
		return typeof(StagedResourceEntityInfo);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResourceStage
{
	public float Health;

	public Mesh CollisionMesh;

	public Mesh[] VisualMeshLods;
}


using System;
using UnityEngine;

public class TreeMarkerData : PrefabAttribute, IServerComponent
{
	[Serializable]
	public struct MarkerLocation
	{
		public Vector3 LocalPosition;

		public Vector3 LocalNormal;
	}

	[Serializable]
	public struct GenerationArc
	{
		public Vector3 CentrePoint;

		public float Radius;

		public Vector3 Rotation;

		public int OverrideCount;
	}

	public GenerationArc[] GenerationArcs;

	public MarkerLocation[] Markers;

	public Vector3 GenerationStartPoint = Vector3.up * 2f;

	public float GenerationRadius = 2f;

	public float MaxY = 1.7f;

	public float MinY = 0.2f;

	public bool ProcessAngleChecks;

	protected override Type GetIndexedType()
	{
		return typeof(TreeMarkerData);
	}

	public Vector3 GetNearbyPoint(Vector3 point, ref int ignoreIndex, out Vector3 normal)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		int num = Markers.Length;
		if (ignoreIndex != -1 && ProcessAngleChecks)
		{
			ignoreIndex++;
			if (ignoreIndex >= num)
			{
				ignoreIndex = 0;
			}
			normal = Markers[ignoreIndex].LocalNormal;
			return Markers[ignoreIndex].LocalPosition;
		}
		int num2 = Random.Range(0, num);
		float num3 = float.MaxValue;
		int num4 = -1;
		for (int i = 0; i < num; i++)
		{
			if (ignoreIndex == num2)
			{
				continue;
			}
			MarkerLocation markerLocation = Markers[num2];
			if (!(markerLocation.LocalPosition.y < MinY))
			{
				Vector3 val = markerLocation.LocalPosition;
				val.y = Mathf.Lerp(val.y, point.y, 0.5f);
				Vector3 val2 = val - point;
				float sqrMagnitude = ((Vector3)(ref val2)).sqrMagnitude;
				sqrMagnitude *= Random.Range(0.95f, 1.05f);
				if (sqrMagnitude < num3)
				{
					num3 = sqrMagnitude;
					num4 = num2;
				}
				num2++;
				if (num2 >= num)
				{
					num2 = 0;
				}
			}
		}
		if (num4 > -1)
		{
			normal = Markers[num4].LocalNormal;
			ignoreIndex = num4;
			return Markers[num4].LocalPosition;
		}
		normal = Markers[0].LocalNormal;
		return Markers[0].LocalPosition;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct MarkerLocation
{
	public Vector3 LocalPosition;

	public Vector3 LocalNormal;
}


using System;
using UnityEngine;

[Serializable]
public struct GenerationArc
{
	public Vector3 CentrePoint;

	public float Radius;

	public Vector3 Rotation;

	public int OverrideCount;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class VineSwingingTree : TreeEntity
{
	public GameObjectRef StumpPrefab;

	public MeshRenderer[] BranchRenderers;

	public GameObject[] BranchRoots;

	public MeshRenderer BranchHighlightRenderer;

	public float VineSpawnHeight = 15f;

	public float VineSpawnRadius = 5f;

	public VineLaunchPoint[] LaunchPoints;

	public Collider[] ClimbColliders;

	public Collider StumpCollider;

	public List<EntityRef<VineMountable>> SpawnedVines = new List<EntityRef<VineMountable>>();

	public VineMountable GetSpawnedVine(VineLaunchPoint point)
	{
		int index = point.Index();
		EnsureVineArrayLength(index);
		return SpawnedVines[index].Get(base.isServer);
	}

	private void EnsureVineArrayLength(int index)
	{
		if (SpawnedVines.Count <= index)
		{
			while (SpawnedVines.Count <= index)
			{
				SpawnedVines.Add(default(EntityRef<VineMountable>));
			}
		}
	}

	public void SetSpawnedVine(VineLaunchPoint point, VineMountable vine)
	{
		int index = point.Index();
		EnsureVineArrayLength(index);
		EntityRef<VineMountable> value = default(EntityRef<VineMountable>);
		value.Set(vine);
		SpawnedVines[index] = value;
	}

	public Vector3 GetVineSpawnPos(List<VineLaunchPoint> possibleDestinations)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		if (possibleDestinations.Count == 0)
		{
			return Vector3.zero;
		}
		Vector3 val = Vector3.zero;
		foreach (VineLaunchPoint possibleDestination in possibleDestinations)
		{
			val += ((Component)possibleDestination).transform.position;
		}
		val /= (float)possibleDestinations.Count;
		Vector3 val2 = ((Component)this).transform.position + ((Component)this).transform.up * VineSpawnHeight;
		val = Vector3Ex.WithY(val, val2.y);
		Vector3 val3 = val - val2;
		Vector3 normalized = ((Vector3)(ref val3)).normalized;
		return val2 + normalized * VineSpawnRadius;
	}

	public override void InitShared()
	{
		base.InitShared();
		GameObject[] branchRoots = BranchRoots;
		foreach (GameObject val in branchRoots)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.SetActive(true);
			}
		}
		if ((Object)(object)StumpCollider != (Object)null)
		{
			StumpCollider.enabled = false;
		}
	}

	public void RefreshVineState()
	{
		if (Application.isLoading)
		{
			((FacepunchBehaviour)this).Invoke((Action)RefreshVineState, 0.25f);
			return;
		}
		VineLaunchPoint[] launchPoints = LaunchPoints;
		for (int i = 0; i < launchPoints.Length; i++)
		{
			launchPoints[i].SpawnVineIfPossible(this);
		}
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		RefreshVineState();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		VineLaunchPoint[] launchPoints = LaunchPoints;
		for (int i = 0; i < launchPoints.Length; i++)
		{
			launchPoints[i].ServerInit();
		}
		((FacepunchBehaviour)this).Invoke((Action)RefreshVineState, 0.25f);
	}

	internal override void DoServerDestroy()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		VineLaunchPoint[] launchPoints = LaunchPoints;
		foreach (VineLaunchPoint vineLaunchPoint in launchPoints)
		{
			if ((Object)(object)vineLaunchPoint != (Object)null)
			{
				vineLaunchPoint.DoServerDestroy();
			}
		}
		if (StumpPrefab.isValid)
		{
			VineSwingingTreeStump obj = base.gameManager.CreateEntity(StumpPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation) as VineSwingingTreeStump;
			obj.InitializeTree(this);
			obj.Spawn();
		}
	}

	public void NotifyNearbyTreesSpawned()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		PooledList<VineSwingingTree> val = Pool.Get<PooledList<VineSwingingTree>>();
		try
		{
			Vis.Entities(((Component)this).transform.position, 64f, (List<VineSwingingTree>)(object)val, 1073741824, (QueryTriggerInteraction)2);
			foreach (VineSwingingTree item in (List<VineSwingingTree>)(object)val)
			{
				if (!item.isClient && !((Object)(object)item == (Object)(object)this))
				{
					item.RefreshVineState();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.vineTree = Pool.Get<VineTree>();
		info.msg.vineTree.spawnedVines = Pool.Get<List<NetworkableId>>();
		foreach (EntityRef<VineMountable> spawnedVine in SpawnedVines)
		{
			info.msg.vineTree.spawnedVines.Add(spawnedVine.uid);
		}
	}

	protected override void OnFallServer()
	{
		base.OnFallServer();
		ToggleClimbColliders(state: false);
		GameObject[] branchRoots = BranchRoots;
		foreach (GameObject val in branchRoots)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.SetActive(false);
			}
		}
		PooledList<Collider> val2 = Pool.Get<PooledList<Collider>>();
		try
		{
			((Component)this).GetComponentsInChildren<Collider>((List<Collider>)(object)val2);
			foreach (Collider item in (List<Collider>)(object)val2)
			{
				if (!item.isTrigger)
				{
					item.enabled = false;
				}
			}
			VineLaunchPoint[] launchPoints = LaunchPoints;
			for (int i = 0; i < launchPoints.Length; i++)
			{
				launchPoints[i].DoServerDestroy();
			}
			if ((Object)(object)StumpCollider != (Object)null)
			{
				StumpCollider.enabled = true;
			}
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		base.OnAttacked(info);
		if ((Object)(object)info.InitiatorPlayer == (Object)null || base.isClient)
		{
			return;
		}
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			VineMountable.pointGrid.Query<VineMountable>(((Component)this).transform.position.x, ((Component)this).transform.position.z, 10f, (List<VineMountable>)(object)val);
			foreach (VineMountable item in (List<VineMountable>)(object)val)
			{
				if (!item.IsOn())
				{
					VineLaunchPoint vineLaunchPoint = item.currentLocation.Get(isServer: true);
					if ((Object)(object)vineLaunchPoint != (Object)null && (Object)(object)vineLaunchPoint.ParentTree == (Object)(object)this && item.AttackedByPlayer(info.InitiatorPlayer))
					{
						break;
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.vineTree == null || info.msg.vineTree.spawnedVines == null)
		{
			return;
		}
		SpawnedVines.Clear();
		foreach (NetworkableId spawnedVine in info.msg.vineTree.spawnedVines)
		{
			SpawnedVines.Add(new EntityRef<VineMountable>(spawnedVine));
		}
	}

	private void ToggleClimbColliders(bool state)
	{
		Collider[] climbColliders = ClimbColliders;
		foreach (Collider val in climbColliders)
		{
			if ((Object)(object)val != (Object)null)
			{
				((Component)val).gameObject.SetActive(state);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class VineSwingingTreeStump : BaseEntity
{
	public GameObjectRef[] TreePrefabs;

	public float MaxTreeRespawnTime = 5f;

	public float MinTreeRespawnTime = 10f;

	public GameObject PreventBuildingVolume;

	private TimeUntil treeRespawnTime;

	private int treeToRespawn;

	public void InitializeTree(VineSwingingTree fromTree)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		treeRespawnTime = TimeUntil.op_Implicit(Random.Range(MinTreeRespawnTime, MaxTreeRespawnTime));
		((FacepunchBehaviour)this).Invoke((Action)RespawnTreeInvoke, TimeUntil.op_Implicit(treeRespawnTime));
		treeToRespawn = 0;
		for (int i = 0; i < TreePrefabs.Length; i++)
		{
			if (TreePrefabs[i].resourceID == fromTree.prefabID)
			{
				treeToRespawn = i;
				break;
			}
		}
	}

	private void RespawnTreeInvoke()
	{
		RespawnTree();
	}

	public bool RespawnTree()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		GameObjectRef gameObjectRef = TreePrefabs[Mathf.Clamp(treeToRespawn, 0, TreePrefabs.Length)];
		if (gameObjectRef.isValid)
		{
			if (!IsTreeRespawnClear())
			{
				((FacepunchBehaviour)this).Invoke((Action)RespawnTreeInvoke, 10f);
				return false;
			}
			VineSwingingTree obj = base.gameManager.CreateEntity(gameObjectRef.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation) as VineSwingingTree;
			obj.Spawn();
			obj.NotifyNearbyTreesSpawned();
			Kill();
			return true;
		}
		return false;
	}

	private bool IsTreeRespawnClear()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		PooledList<Collider> val = Pool.Get<PooledList<Collider>>();
		try
		{
			PreventBuildingVolume.GetComponents<Collider>((List<Collider>)(object)val);
			Vector3 val4 = default(Vector3);
			foreach (Collider item in (List<Collider>)(object)val)
			{
				BoxCollider val2 = (BoxCollider)(object)((item is BoxCollider) ? item : null);
				if (val2 != null)
				{
					if (GamePhysics.CheckOBB(new OBB(PreventBuildingVolume.transform, new Bounds(val2.center, val2.size)), 131072, (QueryTriggerInteraction)0))
					{
						return false;
					}
					continue;
				}
				CapsuleCollider val3 = (CapsuleCollider)(object)((item is CapsuleCollider) ? item : null);
				if (val3 != null)
				{
					((Vector3)(ref val4))..ctor(0f, val3.height * 0.5f, 0f);
					if (GamePhysics.CheckCapsule(((Component)item).transform.TransformPoint(val3.center + val4), ((Component)item).transform.TransformPoint(val3.center - val4), val3.radius, 131072, (QueryTriggerInteraction)0))
					{
						return false;
					}
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.treeRespawn = Pool.Get<TreeRespawn>();
			info.msg.treeRespawn.timeToRespawn = TimeUntil.op_Implicit(treeRespawnTime);
			info.msg.treeRespawn.treeIndex = treeToRespawn;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.fromDisk && info.msg.treeRespawn != null)
		{
			treeRespawnTime = TimeUntil.op_Implicit(info.msg.treeRespawn.timeToRespawn);
			treeToRespawn = info.msg.treeRespawn.treeIndex;
			((FacepunchBehaviour)this).Invoke((Action)RespawnTreeInvoke, TimeUntil.op_Implicit(treeRespawnTime));
		}
	}
}


using Oxide.Core;
using UnityEngine;

public class RoadFlare : TimedExplosive, SeekerTarget.ISeekerTargetOwner
{
	public LightEx FlareLightEx;

	public override void ServerInit()
	{
		base.ServerInit();
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.HIGH);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.OnCollision(collision, hitEntity);
	}

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	internal override void DoServerDestroy()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.DoServerDestroy();
	}
}


using Facepunch;
using ProtoBuf;

public class AssociatedSculptureStorage : BaseEntity
{
	public uint Crc;

	public void InitFromSculpture(uint crc, NetworkableId id)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		Crc = crc;
		FileStorage.server.ReassignEntityId(id, net.ID);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseSculpture = Pool.Get<BaseSculpture>();
		info.msg.baseSculpture.crc = Crc;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		Crc = (uint)(((int?)info.msg.baseSculpture?.crc) ?? (-1));
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct AddAndBlurSphereJob : IJob
{
	public Point3DGrid Grid;

	public int3 Origin;

	public int R;

	public void Execute()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		int num = R * R;
		int3 val = default(int3);
		for (int i = -R; i <= R; i++)
		{
			for (int j = -R; j <= R; j++)
			{
				for (int k = -R; k <= R; k++)
				{
					((int3)(ref val))..ctor(i, j, k);
					int3 val2 = Origin + val;
					if (!(math.distancesq(float3.op_Implicit(val2), float3.op_Implicit(Origin)) > (float)num) && Grid.InBoundsNotTouching(val2))
					{
						Grid[val2] = true;
					}
				}
			}
		}
		int3 val3 = default(int3);
		for (int l = -R; l <= R; l++)
		{
			for (int m = -R; m <= R; m++)
			{
				for (int n = -R; n <= R; n++)
				{
					((int3)(ref val3))..ctor(l, m, n);
					int3 val4 = Origin + val3;
					if (math.distancesq(float3.op_Implicit(val4), float3.op_Implicit(Origin)) > (float)num || !Grid.InBoundsNotTouching(val4))
					{
						continue;
					}
					float num2 = 0f;
					int num3 = 0;
					for (int num4 = -1; num4 <= 1; num4++)
					{
						for (int num5 = -1; num5 <= 1; num5++)
						{
							for (int num6 = -1; num6 <= 1; num6++)
							{
								if (num4 != 0 || num5 != 0 || num6 != 0)
								{
									int3 val5 = val4 + new int3(num4, num5, num6);
									if (Grid.InBounds(val5))
									{
										num2 += Grid.Sample(val5);
										num3++;
									}
								}
							}
						}
					}
					Grid[val4] = num2 / (float)num3 > 0.5f;
				}
			}
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct BoxBlur3DJob : IJobFor
{
	[ReadOnly]
	public Point3DGrid InputGrid;

	public NativeBitArray OutputGrid;

	public int Width;

	public int WidthHeight;

	public void Execute(int index)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		int3 val = default(int3);
		((int3)(ref val))..ctor(index % Width, index % WidthHeight / Width, index / WidthHeight);
		bool flag = InputGrid[index];
		if (!InputGrid.InBoundsNotTouching(val))
		{
			((NativeBitArray)(ref OutputGrid)).Set(index, false);
			return;
		}
		float num = 0f;
		for (int i = -1; i <= 1; i++)
		{
			for (int j = -1; j <= 1; j++)
			{
				for (int k = -1; k <= 1; k++)
				{
					if (i != 0 || j != 0 || k != 0)
					{
						num += InputGrid.Sample(val + new int3(i, j, k));
					}
				}
			}
		}
		bool flag2 = num / 26f >= (flag ? 0.33f : 0.66f);
		if (flag2 != flag)
		{
			flag2 = flag2 || flag2;
		}
		((NativeBitArray)(ref OutputGrid)).Set(index, flag2);
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
public struct BoxBlurCylinderJob : IJob
{
	public Point3DGrid Grid;

	public float3 P0;

	public float3 P1;

	public float R;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		float3 val = math.float3(R);
		float3 val2 = math.min(P0, P1) - val;
		float3 val3 = math.max(P0, P1) + val;
		float3 val4 = P1 - P0;
		float v = math.dot(val4, val4);
		float r = R * R;
		for (float num = val2.x; num <= val3.x; num += 1f)
		{
			for (float num2 = val2.y; num2 <= val3.y; num2 += 1f)
			{
				for (float num3 = val2.z; num3 <= val3.z; num3 += 1f)
				{
					float3 val5 = math.float3(num, num2, num3);
					int3 val6 = math.int3(val5);
					if (!Grid.InBoundsNotTouching(val6) || !SculptMathUtil.InFlatEndedCapsule(P0, val4, v, r, val5))
					{
						continue;
					}
					float num4 = 0f;
					int num5 = 0;
					for (int i = -1; i <= 1; i++)
					{
						for (int j = -1; j <= 1; j++)
						{
							for (int k = -1; k <= 1; k++)
							{
								if (i != 0 || j != 0 || k != 0)
								{
									int3 val7 = val6 + new int3(i, j, k);
									if (Grid.InBounds(val7))
									{
										num4 += Grid.Sample(val7);
										num5++;
									}
								}
							}
						}
					}
					Grid[val6] = num4 / (float)num5 > 0.5f;
				}
			}
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct BoxBlurSphereJob : IJob
{
	public Point3DGrid Grid;

	public int3 Origin;

	public int R;

	public void Execute()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		int num = R * R;
		int3 val = default(int3);
		for (int i = -R; i <= R; i++)
		{
			for (int j = -R; j <= R; j++)
			{
				for (int k = -R; k <= R; k++)
				{
					((int3)(ref val))..ctor(i, j, k);
					int3 val2 = Origin + val;
					if (math.distancesq(float3.op_Implicit(val2), float3.op_Implicit(Origin)) > (float)num || !Grid.InBoundsNotTouching(val2))
					{
						continue;
					}
					float num2 = 0f;
					int num3 = 0;
					for (int l = -1; l <= 1; l++)
					{
						for (int m = -1; m <= 1; m++)
						{
							for (int n = -1; n <= 1; n++)
							{
								if (l != 0 || m != 0 || n != 0)
								{
									int3 val3 = val2 + new int3(l, m, n);
									if (Grid.InBounds(val3))
									{
										num2 += Grid.Sample(val3);
										num3++;
									}
								}
							}
						}
					}
					Grid[val2] = num2 / (float)num3 > 0.5f;
				}
			}
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
public struct CarveAndBlurCylinderJob : IJob
{
	public Point3DGrid Grid;

	public float3 P0;

	public float3 P1;

	public float R;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		float3 val = math.float3(R);
		float3 val2 = math.min(P0, P1) - val;
		float3 val3 = math.max(P0, P1) + val;
		float3 val4 = P1 - P0;
		float v = math.dot(val4, val4);
		float num = R * R;
		NativeList<int3> val5 = default(NativeList<int3>);
		val5..ctor((int)num, AllocatorHandle.op_Implicit((Allocator)2));
		for (float num2 = val2.x; num2 <= val3.x; num2 += 1f)
		{
			for (float num3 = val2.y; num3 <= val3.y; num3 += 1f)
			{
				for (float num4 = val2.z; num4 <= val3.z; num4 += 1f)
				{
					float3 val6 = math.float3(num2, num3, num4);
					int3 p = math.int3(val6);
					if (Grid.InBounds(p) && SculptMathUtil.InFlatEndedCapsule(P0, val4, v, num, val6))
					{
						Grid[p] = false;
						val5.Add(ref p);
					}
				}
			}
		}
		NativeArray<int3> val7 = val5.AsArray();
		int length = val5.Length;
		for (int i = 0; i < length; i++)
		{
			int3 val8 = val7[i];
			if (!Grid.InBoundsNotTouching(val8))
			{
				continue;
			}
			float num5 = 0f;
			int num6 = 0;
			for (int j = -1; j <= 1; j++)
			{
				for (int k = -1; k <= 1; k++)
				{
					for (int l = -1; l <= 1; l++)
					{
						if (j != 0 || k != 0 || l != 0)
						{
							int3 val9 = val8 + new int3(j, k, l);
							if (Grid.InBounds(val9))
							{
								num5 += Grid.Sample(val9);
								num6++;
							}
						}
					}
				}
			}
			Grid[val8] = num5 / (float)num6 > 0.5f;
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct CarveAndBlurSphereJob : IJob
{
	public Point3DGrid Grid;

	public int3 Origin;

	public int R;

	public void Execute()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		int num = R * R;
		int3 val = default(int3);
		for (int i = -R; i <= R; i++)
		{
			for (int j = -R; j <= R; j++)
			{
				for (int k = -R; k <= R; k++)
				{
					((int3)(ref val))..ctor(i, j, k);
					int3 val2 = Origin + val;
					if (!(math.distancesq(float3.op_Implicit(val2), float3.op_Implicit(Origin)) > (float)num) && Grid.InBounds(val2))
					{
						Grid[val2] = false;
					}
				}
			}
		}
		int3 val3 = default(int3);
		for (int l = -R; l <= R; l++)
		{
			for (int m = -R; m <= R; m++)
			{
				for (int n = -R; n <= R; n++)
				{
					((int3)(ref val3))..ctor(l, m, n);
					int3 val4 = Origin + val3;
					if (math.distancesq(float3.op_Implicit(val4), float3.op_Implicit(Origin)) > (float)num || !Grid.InBoundsNotTouching(val4))
					{
						continue;
					}
					float num2 = 0f;
					int num3 = 0;
					for (int num4 = -1; num4 <= 1; num4++)
					{
						for (int num5 = -1; num5 <= 1; num5++)
						{
							for (int num6 = -1; num6 <= 1; num6++)
							{
								if (num4 != 0 || num5 != 0 || num6 != 0)
								{
									int3 val5 = val4 + new int3(num4, num5, num6);
									if (Grid.InBounds(val5))
									{
										num2 += Grid.Sample(val5);
										num3++;
									}
								}
							}
						}
					}
					Grid[val4] = num2 / (float)num3 > 0.5f;
				}
			}
		}
	}
}


using System;
using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Profiling;

[BurstCompile]
internal struct CleanFloatingIslandsJob : IJob
{
	private struct NativeStack : IDisposable
	{
		public NativeList<int3> arr;

		public NativeStack(Allocator allocator)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			arr = new NativeList<int3>(AllocatorHandle.op_Implicit(allocator));
		}

		public void Dispose()
		{
			arr.Dispose();
		}

		public void Push(int3 v)
		{
			arr.Add(ref v);
		}

		public bool TryPop(out int3 v)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			v = default(int3);
			if (arr.Length == 0)
			{
				return false;
			}
			v = arr[arr.Length - 1];
			arr.RemoveAtSwapBack(arr.Length - 1);
			return true;
		}
	}

	public Point3DGrid Sampler;

	public static readonly ProfilerMarker k_Init = new ProfilerMarker("Init");

	public static readonly ProfilerMarker k_Flood = new ProfilerMarker("Flood");

	public static readonly ProfilerMarker k_Copy = new ProfilerMarker("CopyBack");

	public void Execute()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray other = default(NativeBitArray);
		((NativeBitArray)(ref other))..ctor(Sampler.Length, AllocatorHandle.op_Implicit((Allocator)2), (NativeArrayOptions)1);
		NativeStack nativeStack = new NativeStack((Allocator)2);
		int width = Sampler.Width;
		int depth = Sampler.Depth;
		int3 val = default(int3);
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < depth; j++)
			{
				((int3)(ref val))..ctor(i, 1, j);
				int num = Sampler.ToIndex(val);
				if (Sampler[num])
				{
					nativeStack.Push(val);
					((NativeBitArray)(ref other)).Set(num, true);
				}
			}
		}
		int3 v;
		int3 val2 = default(int3);
		while (nativeStack.TryPop(out v))
		{
			int num2 = v.x - 1;
			((int3)(ref val2))..ctor(num2, ((int3)(ref v)).yz);
			int num3 = 0;
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(--num2, ((int3)(ref v)).yz);
			}
			int num4 = v.x + 1;
			((int3)(ref val2))..ctor(num4, ((int3)(ref v)).yz);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(++num4, ((int3)(ref v)).yz);
			}
			int num5 = v.z - 1;
			((int3)(ref val2))..ctor(((int3)(ref v)).xy, num5);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(((int3)(ref v)).xy, --num5);
			}
			int num6 = v.z + 1;
			((int3)(ref val2))..ctor(((int3)(ref v)).xy, num6);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(((int3)(ref v)).xy, ++num6);
			}
			for (int k = num2; k < num4; k++)
			{
				for (int l = num5; l < num6; l++)
				{
					for (int m = -1; m <= 1; m += 2)
					{
						((int3)(ref val2))..ctor(k, v.y + m, l);
						if (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
						{
							nativeStack.Push(val2);
							((NativeBitArray)(ref other)).Set(num3, true);
						}
					}
				}
			}
		}
		Sampler.CopyFromNativeBitArray(ref other);
	}
}


using System;
using Unity.Collections;
using Unity.Mathematics;

private struct NativeStack : IDisposable
{
	public NativeList<int3> arr;

	public NativeStack(Allocator allocator)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		arr = new NativeList<int3>(AllocatorHandle.op_Implicit(allocator));
	}

	public void Dispose()
	{
		arr.Dispose();
	}

	public void Push(int3 v)
	{
		arr.Add(ref v);
	}

	public bool TryPop(out int3 v)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		v = default(int3);
		if (arr.Length == 0)
		{
			return false;
		}
		v = arr[arr.Length - 1];
		arr.RemoveAtSwapBack(arr.Length - 1);
		return true;
	}
}


using Unity.Mathematics;

public static class SculptMathUtil
{
	public static bool InFlatEndedCapsule(float3 p0, float3 v, float v2, float r2, float3 check)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		float3 val = check - p0;
		if (math.dot(val, v) > v2)
		{
			return false;
		}
		return math.lengthsq(math.cross(val, v)) * math.rcp(v2) <= r2;
	}
}


using System;
using UnityEngine;

public class SculptingToolData : PrefabAttribute
{
	public enum CarvingShapeType
	{
		Cylinder,
		Sphere,
		Rectangle
	}

	[Flags]
	public enum CarvingMode
	{
		Carve = 1,
		Smooth = 2,
		Additive = 4
	}

	public CarvingShapeType CarvingShape;

	public CarvingMode CarvingModes = CarvingMode.Carve | CarvingMode.Smooth | CarvingMode.Additive;

	public Vector2Int CarvingSizeLimits = new Vector2Int(2, 5);

	public bool AllowCarve => (CarvingModes & CarvingMode.Carve) != 0;

	public bool AllowSmooth => (CarvingModes & CarvingMode.Smooth) != 0;

	public bool AllowAdditive => (CarvingModes & CarvingMode.Additive) != 0;

	public int MinCarvingSize => ((Vector2Int)(ref CarvingSizeLimits)).x;

	public int MaxCarvingSize => ((Vector2Int)(ref CarvingSizeLimits)).y;

	protected override Type GetIndexedType()
	{
		return typeof(SculptingToolData);
	}
}


public enum CarvingShapeType
{
	Cylinder,
	Sphere,
	Rectangle
}


using System;

[Flags]
public enum CarvingMode
{
	Carve = 1,
	Smooth = 2,
	Additive = 4
}


public class SeasonalTimedExplosive : TimedExplosive
{
	public RandomRendererEnable randomRenderer;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ServerProjectile : EntityComponent<BaseEntity>
{
	public interface IProjectileImpact
	{
		void ProjectileImpact(RaycastHit hitInfo, Vector3 rayOrigin);
	}

	public Vector3 initialVelocity;

	public float drag;

	public float gravityModifier = 1f;

	public float speed = 15f;

	public float scanRange;

	public Vector3 swimScale;

	public Vector3 swimSpeed;

	public float radius;

	public bool IgnoreAI;

	[HideInInspector]
	public BaseEntity ignoreEntity;

	protected bool shouldMoveProjectile = true;

	public bool impacted;

	public float swimRandom;

	public virtual bool HasRangeLimit => true;

	protected virtual int mask => 1237003025;

	public Vector3 CurrentVelocity { get; set; }

	public bool Impacted => impacted;

	public float GetMaxRange(float maxFuseTime)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (gravityModifier == 0f)
		{
			return float.PositiveInfinity;
		}
		float num = Mathf.Sin(MathF.PI / 2f) * speed * speed / (0f - Physics.gravity.y * gravityModifier);
		float num2 = speed * maxFuseTime;
		return Mathf.Min(num, num2);
	}

	protected void FixedUpdate()
	{
		if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity.isServer)
		{
			DoMovement();
		}
	}

	public void AdjustVelocity(Vector3 adjustment)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		CurrentVelocity += adjustment;
	}

	public virtual Vector3 GetVelocityStep()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return Physics.gravity * gravityModifier * Time.fixedDeltaTime * Time.timeScale;
	}

	public virtual void InitializeVelocity(Vector3 overrideVel)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (AutomaticallyRotate())
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref overrideVel)).normalized);
		}
		initialVelocity = overrideVel;
		CurrentVelocity = overrideVel;
	}

	public void SetVelocity(Vector3 overrideVel)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (AutomaticallyRotate() && overrideVel != Vector3.zero)
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref overrideVel)).normalized);
		}
		CurrentVelocity = overrideVel;
	}

	public virtual bool DoMovement()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (base.baseEntity.isClient)
		{
			return false;
		}
		if (impacted)
		{
			return false;
		}
		CurrentVelocity += GetVelocityStep();
		Vector3 val = AddSwim(CurrentVelocity);
		float num = ((Vector3)(ref val)).magnitude * Time.fixedDeltaTime;
		if (DoHitDetection(val, num))
		{
			return false;
		}
		if (shouldMoveProjectile)
		{
			Transform transform = ((Component)this).transform;
			transform.position += ((Component)this).transform.forward * num;
		}
		if (AutomaticallyRotate() && val != Vector3.zero)
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
		}
		PostDoMove();
		return true;
	}

	protected virtual bool DoHitDetection(Vector3 velocityToUse, float distance)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		Vector3 position = ((Component)this).transform.position;
		GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref velocityToUse)).normalized), radius, list, distance + scanRange, mask, (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			BaseEntity entity = item.GetEntity();
			if ((!((Object)(object)entity != (Object)null) || !entity.isClient) && (!IgnoreAI || !IsAnIgnoredAI(entity)) && IsAValidHit(entity) && IsShootable(item))
			{
				ProcessHit(item, entity, position);
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				return true;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return false;
	}

	private Vector3 AddSwim(Vector3 currentVelocity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = currentVelocity;
		if (swimScale != Vector3.zero)
		{
			if (swimRandom == 0f)
			{
				swimRandom = Random.Range(0f, 20f);
			}
			float num = Time.time + swimRandom;
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(Mathf.Sin(num * swimSpeed.x) * swimScale.x, Mathf.Cos(num * swimSpeed.y) * swimScale.y, Mathf.Sin(num * swimSpeed.z) * swimScale.z);
			val2 = ((Component)this).transform.InverseTransformDirection(val2);
			val += val2;
		}
		return val;
	}

	protected void ProcessHit(RaycastHit hitInfo, BaseEntity hitEnt, Vector3 rayOrigin)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		transform.position += ((Component)this).transform.forward * Mathf.Max(0f, ((RaycastHit)(ref hitInfo)).distance - 0.1f);
		((Component)this).GetComponent<IProjectileImpact>()?.ProjectileImpact(hitInfo, rayOrigin);
		SingletonComponent<NpcNoiseManager>.Instance.OnServerProjectileHit(base.baseEntity, this, hitInfo);
		impacted = true;
		OnHit(hitInfo, hitEnt);
		PostDoMove();
	}

	protected bool IsShootable(RaycastHit hitInfo)
	{
		ColliderInfo colliderInfo = (((Object)(object)((RaycastHit)(ref hitInfo)).collider != (Object)null) ? ((Component)((RaycastHit)(ref hitInfo)).collider).GetComponent<ColliderInfo>() : null);
		if (!((Object)(object)colliderInfo == (Object)null))
		{
			return colliderInfo.HasFlag(ColliderInfo.Flags.Shootable);
		}
		return true;
	}

	protected virtual void OnHit(RaycastHit rayHit, BaseEntity hitEntity)
	{
	}

	protected virtual void PostDoMove()
	{
	}

	protected virtual bool IsAValidHit(BaseEntity hitEnt)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (!hitEnt.IsValid())
		{
			return true;
		}
		if (base.baseEntity.creatorEntity.IsValid() && hitEnt.net.ID == base.baseEntity.creatorEntity.net.ID)
		{
			return false;
		}
		if (ignoreEntity.IsValid() && hitEnt.net.ID == ignoreEntity.net.ID)
		{
			return false;
		}
		return true;
	}

	protected virtual bool IsAnIgnoredAI(BaseEntity hitEnt)
	{
		return hitEnt is ScientistNPC;
	}

	protected virtual bool AutomaticallyRotate()
	{
		return true;
	}
}


using UnityEngine;

public interface IProjectileImpact
{
	void ProjectileImpact(RaycastHit hitInfo, Vector3 rayOrigin);
}


using System;
using UnityEngine;

public class Ballista : BaseSiegeWeapon
{
	[Header("Ballista")]
	public GameObjectRef ballistaGunPrefab;

	public EntityRef<BallistaGun> ballistaGunRef;

	public Transform dismountPositionsParent;

	[SerializeField]
	[Header("Effects")]
	private GameObjectRef fireEffectPrefab;

	public override float DriveWheelVelocity { get; }

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child.prefabID == ballistaGunPrefab.GetEntity().prefabID)
		{
			BallistaGun ballistaGun = (BallistaGun)child;
			ballistaGunRef.Set(ballistaGun);
			ballistaGun.ballistaOwner = this;
		}
	}

	private BallistaGun GetBallistaGun()
	{
		BallistaGun ballistaGun = ballistaGunRef.Get(base.isServer);
		if (ballistaGun.IsValid())
		{
			return ballistaGun;
		}
		return null;
	}

	protected override bool CanPullNow(BasePlayer puller)
	{
		if (base.CanPullNow(puller))
		{
			return !IsGunMounted();
		}
		return false;
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (base.CanPushNow(pusher))
		{
			return !IsGunMounted();
		}
		return false;
	}

	public bool IsGunMounted()
	{
		BallistaGun ballistaGun = GetBallistaGun();
		if ((Object)(object)ballistaGun != (Object)null)
		{
			return ballistaGun.IsMounted();
		}
		return false;
	}

	protected override void CreateEngineController()
	{
	}

	private void RotateDismountPositions()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ballistaGunRef.Get(base.isServer) != (Object)null)
		{
			dismountPositionsParent.rotation = ((Component)ballistaGunRef.Get(base.isServer)).transform.rotation;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		mountPose = PlayerModel.MountPoses.StandDrive;
		DisablePhysics();
		((FacepunchBehaviour)this).Invoke((Action)base.EnablePhysics, 1f);
	}

	public override BasePlayer GetMounted()
	{
		return GetDriver();
	}

	public override void OnTowAttach()
	{
		base.OnTowAttach();
		DismountAllPlayers();
	}

	public void OnFired()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (fireEffectPrefab != null && fireEffectPrefab.isValid)
		{
			Effect.server.Run(fireEffectPrefab.resourcePath, this, 0u, Vector3.zero, Vector3.up, null, broadcast: true);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.VehicleFixedUpdate();
		Vector3 worldVelocity = GetWorldVelocity();
		if (((Vector3)(ref worldVelocity)).magnitude > 5f || IsFlipping())
		{
			DismountAllPlayers();
		}
		RotateDismountPositions();
	}

	protected override void DoPushAction(BasePlayer player)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)rigidBody == (Object)null))
		{
			Vector3 val = Vector3.ProjectOnPlane(((Component)this).transform.position - player.eyes.position, ((Component)this).transform.up);
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float num = rigidBody.mass * 2.4f;
			rigidBody.AddForce(normalized * num, (ForceMode)1);
		}
	}

	public override void OnEngineStartFailed()
	{
	}

	public override bool MeetsEngineRequirements()
	{
		return false;
	}

	public override void LightToggle(BasePlayer player)
	{
	}
}


public class BallistaAnimationEvents : FacepunchBehaviour
{
	public BallistaGun ballista;

	public SoundDefinition reloadClickSoundDef;

	public SoundDefinition reloadWrenchForwardDef;

	public SoundDefinition reloadCompleteDef;
}


public class BaseSiegeWeaponVisuals : VehicleChassisVisuals<BaseSiegeWeapon>, IClientComponent
{
}


using UnityEngine;

public class SiegeWeaponVehicleAudio : GroundVehicleAudio
{
	[Header("Reload")]
	public SoundDefinition reloadProgressDef;

	public SoundDefinition reloadStartDef;

	public SoundDefinition reloadStopDef;

	public SoundDefinition reloadCompleteDef;

	[Header("Rattles")]
	[SerializeField]
	private SoundDefinition movementRattleLoop;

	[SerializeField]
	private float movementRattleMaxSpeed = 10f;

	[SerializeField]
	private float movementRattleIdleGain = 0.3f;

	[SerializeField]
	private float movementRattleGainChangeSpeed = 1f;

	[Header("Wheels")]
	[SerializeField]
	private SoundDefinition tyreRollingSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingWaterSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingGrassSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingSnowSoundDef;

	[SerializeField]
	private AnimationCurve tyreRollGainCurve;
}


using Rust;
using UnityEngine;

public class BatteringRamHead : BaseCombatEntity
{
	public float damagedHealthThreshold = 100f;

	public float brokenHealthThreshold = 20f;

	public Collider serverCollider;

	[HideInInspector]
	public BatteringRam batteringRamOwner;

	[HideInInspector]
	public DamageRenderer damageRenderer;

	public const Flags Flags_DamagedLow = Flags.Reserved6;

	public const Flags Flags_DamagedMid = Flags.Reserved7;

	public const Flags Flags_DamagedHeavy = Flags.Reserved8;

	public bool CanBeUsed()
	{
		return base.health > brokenHealthThreshold;
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateBrokenFlag();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateBrokenFlag();
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		base.OnHealthChanged(oldvalue, newvalue);
		UpdateDamageFlags();
	}

	private void UpdateDamageFlags()
	{
		float num = base.healthFraction;
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved7, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved8, b: false);
		if (num <= 0.1f)
		{
			SetFlag(Flags.Reserved8, b: true);
		}
		else if (num <= 0.5f)
		{
			SetFlag(Flags.Reserved7, b: true);
		}
		else if (num <= 0.75f)
		{
			SetFlag(Flags.Reserved6, b: true);
		}
	}

	private void UpdateBrokenFlag()
	{
		if (CanBeUsed())
		{
			batteringRamOwner.SetFlag(Flags.Broken, b: false);
			SetFlag(Flags.Broken, b: false);
		}
	}

	public override float GetDamageRepairCooldown()
	{
		return 0f;
	}

	public void TakeDamage(float damage)
	{
		damage = Mathf.Min(damage, base.health - 10f);
		Hurt(damage, DamageType.Blunt, this, useProtection: false);
		if (!CanBeUsed())
		{
			batteringRamOwner.SetFlag(Flags.Broken, b: true);
			SetFlag(Flags.Broken, b: true);
		}
	}

	[ServerVar]
	public static void hurt(Arg arg)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		BatteringRamHead[] array = Util.FindAll<BatteringRamHead>();
		foreach (BatteringRamHead batteringRamHead in array)
		{
			if (batteringRamHead.isServer && Vector3.Distance(((Component)batteringRamHead).transform.position, ((Component)basePlayer).transform.position) <= 10f)
			{
				batteringRamHead.TakeDamage(@float);
			}
		}
	}
}


public class BatteringRamSeat : BaseVehicleSeat
{
}


using UnityEngine;

public class BatteringRamVehicleAudio : SiegeWeaponVehicleAudio
{
	public Transform lightToggleSoundPos;
}


using UnityEngine;

public class BatteringRamVisuals : BaseSiegeWeaponVisuals, IClientComponent
{
	private BatteringRam ram;

	public Transform frontAxle;

	public Transform middleAxle;

	public Transform rearAxle;

	[Space]
	public ParticleSystem rockDoorParticle;

	public ParticleSystem dirtDoorParticle;
}


using System;
using UnityEngine;

public class CatapultAmmoContainer : StorageContainer
{
	[NonSerialized]
	public Catapult catapult;

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		catapult.UpdateLoadedAmmo(item, added);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((Object)(object)catapult != (Object)null)
		{
			return catapult.CanBeLooted(player);
		}
		return false;
	}
}


public class CatapultAnimationEvents : FacepunchBehaviour
{
	public Catapult catapult;

	public SoundDefinition reloadClickSoundDef;

	public void PlayReloadClick()
	{
	}

	public void PlaySound(SoundDefinition def)
	{
	}
}


using UnityEngine;

public class CatapultSounds : GroundVehicleAudio
{
	[Header("Reload")]
	public SoundDefinition reloadLoopDef;

	public SoundDefinition reloadStartDef;

	public SoundDefinition reloadStopDef;

	[SerializeField]
	[Header("Suspension")]
	private SoundDefinition suspensionDef;

	[SerializeField]
	private float suspensionMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionMinTimeBetweenSounds = 0.25f;

	[Header("Tires")]
	[SerializeField]
	private SoundDefinition tireDirtSoundDef;

	[SerializeField]
	private SoundDefinition tireGrassSoundDef;

	[SerializeField]
	private SoundDefinition tireSnowSoundDef;

	[SerializeField]
	private SoundDefinition tireWaterSoundDef;

	[SerializeField]
	private AnimationCurve tireGainCurve;

	[Header("Movement")]
	[SerializeField]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private AnimationCurve movementGainCurve;

	[SerializeField]
	private float movementGainAdjustmentSpeed = 5f;
}


using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ConstructableEntity : StorageContainer
{
	[Header("Constructable Entity")]
	public List<ItemAmount> ingredients = new List<ItemAmount>();

	private int[] currentMaterials;

	public GameObjectRef entityToSpawn;

	public PlayerDetectionTrigger trigger;

	public bool onlyRunTriggerCheckOnLastHit;

	public bool onlyBlockWhenStanding;

	public GameObject[] states;

	public SoundDefinition[] stateSounds;

	public GameObjectRef spawnEffect;

	public bool additiveMode;

	private int currentState;

	private void SetState(int index)
	{
		if (index < 0 || index >= states.Length)
		{
			return;
		}
		if (additiveMode)
		{
			for (int i = 0; i < states.Length; i++)
			{
				states[i].SetActive(i <= index);
			}
		}
		else
		{
			GameObject[] array = states;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(false);
			}
			states[index].SetActive(true);
		}
		currentState = index;
	}

	private void UpdateState()
	{
		int num = Mathf.FloorToInt(GetTotalMaterialFraction() * (float)states.Length);
		num = Mathf.Clamp(num, 0, states.Length - 1);
		if (num != currentState)
		{
			if (base.isServer)
			{
				timePlaced = GetNetworkTime();
			}
			SetState(num);
		}
	}

	private float GetTotalMaterialFraction()
	{
		float num = 0f;
		float num2 = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			num += Mathf.Min((float)currentMaterials[i], ingredients[i].amount);
			num2 += ingredients[i].amount;
		}
		if (!(num2 > 0f))
		{
			return 0f;
		}
		return num / num2;
	}

	public bool IsNearlyBuilt()
	{
		for (int i = 0; i < ingredients.Count; i++)
		{
			float num = Mathf.Max(0f, ingredients[i].amount - (float)currentMaterials[i]);
			if (!(num <= 0f))
			{
				int num2 = Mathf.CeilToInt(ingredients[i].amount / 10f);
				if (num > (float)num2)
				{
					return false;
				}
			}
		}
		return true;
	}

	public override void ServerInit()
	{
		SetState(0);
		base.ServerInit();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		base.OnRepairFinished(player);
		ulong ownerID = base.OwnerID;
		Kill();
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityToSpawn.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
		baseEntity.OwnerID = ownerID;
		baseEntity.Spawn();
		if (spawnEffect.isValid)
		{
			Effect.server.Run(spawnEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		}
	}

	public override float GetDamageRepairCooldown()
	{
		return 5f;
	}

	public override void DoRepair(BasePlayer player)
	{
		if (!CanRepair(player))
		{
			return;
		}
		bool flag = false;
		float num = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			ItemAmount itemAmount = ingredients[i];
			float num2 = Mathf.Max(0f, itemAmount.amount - (float)currentMaterials[i]);
			if (num2 != 0f)
			{
				int num3 = Mathf.CeilToInt(itemAmount.amount / 10f);
				int num4 = player.inventory.GetAmount(itemAmount.itemid);
				if (player.IsInCreativeMode && Creative.freeRepair)
				{
					num4 = int.MaxValue;
				}
				int num5 = Mathf.Min(new int[3]
				{
					num3,
					num4,
					Mathf.FloorToInt(num2)
				});
				if (num5 > 0)
				{
					currentMaterials[i] += num5;
					player.inventory.Take(null, itemAmount.itemid, num5);
					player.Command("note.inv", itemAmount.itemid, num5 * -1);
					flag = true;
					float num6 = MaxHealth() * (itemAmount.amount / GetTotalRequiredMaterials());
					num += num6 * ((float)num5 / itemAmount.amount);
				}
				else
				{
					OnBuildFailedResources(player, itemAmount.itemDef.itemid);
				}
			}
		}
		if (num != 0f)
		{
			SetHealth(Mathf.Min(Health() + num, MaxHealth()));
		}
		if (flag)
		{
			SendNetworkUpdate();
			UpdateState();
			if (IsFullyBuilt())
			{
				OnRepairFinished(player);
			}
			else
			{
				OnRepair();
			}
		}
	}

	public void OnBuildFailedResources(BasePlayer player, int itemID)
	{
		if ((Object)(object)player != (Object)null)
		{
			player.ClientRPC(RpcTarget.Player("Client_OnConstructableBuildFailed", player), itemID);
		}
	}

	private bool IsFullyBuilt()
	{
		for (int i = 0; i < ingredients.Count; i++)
		{
			if ((float)currentMaterials[i] < ingredients[i].amount)
			{
				return false;
			}
		}
		return true;
	}

	private float GetTotalRequiredMaterials()
	{
		float num = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			num += ingredients[i].amount;
		}
		return num;
	}

	protected virtual bool CanRepair(BasePlayer player)
	{
		if ((Object)(object)trigger != (Object)null && trigger.entityContents != null)
		{
			if (onlyRunTriggerCheckOnLastHit && !IsNearlyBuilt())
			{
				return true;
			}
			foreach (BaseEntity entityContent in trigger.entityContents)
			{
				if (entityContent is BaseVehicle baseVehicle)
				{
					if (!baseVehicle.IsDead() && !baseVehicle.isClient && !((Object)(object)((Component)baseVehicle).transform.root == (Object)(object)((Component)this).transform))
					{
						player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByVehicle, false);
						return false;
					}
				}
				else if (entityContent is BasePlayer { isClient: false } basePlayer && !basePlayer.IsDead() && (!onlyBlockWhenStanding || basePlayer.IsStandingOnEntity(this, 134226176)))
				{
					player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, overlay: false, (string[])null);
					return false;
				}
			}
		}
		return true;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.constructableEntity = Pool.Get<ConstructableEntity>();
		if (currentMaterials == null || currentMaterials.IsEmpty())
		{
			currentMaterials = new int[ingredients.Count];
			for (int i = 0; i < ingredients.Count; i++)
			{
				currentMaterials[i] = 0;
			}
		}
		info.msg.constructableEntity.addedResources = currentMaterials.ToList();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.constructableEntity != null)
		{
			currentMaterials = info.msg.constructableEntity.addedResources.ToArray();
		}
		UpdateState();
	}
}


using UnityEngine;

public class SiegeTowerDoor : Door
{
	private SiegeTower tower;

	protected override bool OnlyCheckForVehicles()
	{
		return false;
	}

	protected override bool InverseDotCheck()
	{
		return true;
	}

	protected override bool CheckOnClose()
	{
		return false;
	}

	public void SetupDoor(SiegeTower tower)
	{
		this.tower = tower;
	}

	private void UpdateTowerHP()
	{
		if (HasParent() && (Object)(object)tower != (Object)null)
		{
			tower.ProtectedSetHealth(base.health);
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateTowerHP();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateTowerHP();
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && (Object)(object)tower != (Object)null)
		{
			tower.ProtectedHurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)tower != (Object)null && !tower.IsDead())
		{
			tower.Die();
		}
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if ((Object)(object)tower != (Object)null && old != next)
		{
			tower.RefreshLastUseTime();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class StabilityEntity : DecayEntity
{
	public class StabilityCheckWorkQueue : ObjectWorkQueue<StabilityEntity>
	{
		protected override void RunJob(StabilityEntity entity)
		{
			if (((ObjectWorkQueue<StabilityEntity>)this).ShouldAdd(entity))
			{
				entity.StabilityCheck();
			}
		}

		protected override bool ShouldAdd(StabilityEntity entity)
		{
			if (!ConVar.Server.stability)
			{
				return false;
			}
			if (!entity.IsValid())
			{
				return false;
			}
			if (!entity.isServer)
			{
				return false;
			}
			return true;
		}
	}

	public class UpdateSurroundingsQueue : ObjectWorkQueue<Bounds>
	{
		protected override void RunJob(Bounds bounds)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			NotifyNeighbours(bounds);
		}

		public static void NotifyNeighbours(Bounds bounds)
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (!ConVar.Server.stability)
			{
				return;
			}
			List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
			Vector3 center = ((Bounds)(ref bounds)).center;
			Vector3 extents = ((Bounds)(ref bounds)).extents;
			Vis.Entities(center, ((Vector3)(ref extents)).magnitude + 1f, list, -2144696062, (QueryTriggerInteraction)2);
			foreach (BaseEntity item in list)
			{
				if (!item.IsDestroyed && !item.isClient)
				{
					if (item is StabilityEntity stabilityEntity)
					{
						stabilityEntity.OnPhysicsNeighbourChanged();
					}
					else
					{
						((Component)item).BroadcastMessage("OnPhysicsNeighbourChanged", (SendMessageOptions)1);
					}
				}
			}
			Pool.FreeUnmanaged<BaseEntity>(ref list);
		}
	}

	public class Support
	{
		public StabilityEntity parent;

		public EntityLink link;

		public float factor = 1f;

		public Support(StabilityEntity parent, EntityLink link, float factor)
		{
			this.parent = parent;
			this.link = link;
			this.factor = factor;
		}

		public StabilityEntity SupportEntity(StabilityEntity ignoreEntity = null)
		{
			StabilityEntity stabilityEntity = null;
			for (int i = 0; i < link.connections.Count; i++)
			{
				StabilityEntity stabilityEntity2 = link.connections[i].owner as StabilityEntity;
				Socket_Base socket = link.connections[i].socket;
				if ((Object)(object)stabilityEntity2 == (Object)null || (Object)(object)stabilityEntity2 == (Object)(object)parent || (Object)(object)stabilityEntity2 == (Object)(object)ignoreEntity || stabilityEntity2.isClient || stabilityEntity2.IsDestroyed || socket is ConstructionSocket { femaleNoStability: not false })
				{
					continue;
				}
				if ((Object)(object)stabilityEntity == (Object)null)
				{
					stabilityEntity = stabilityEntity2;
				}
				else if (Stability.support_highest_stability)
				{
					if (stabilityEntity2.cachedStability > stabilityEntity.cachedStability)
					{
						stabilityEntity = stabilityEntity2;
					}
				}
				else if (stabilityEntity2.cachedDistanceFromGround < stabilityEntity.cachedDistanceFromGround)
				{
					stabilityEntity = stabilityEntity2;
				}
			}
			return stabilityEntity;
		}
	}

	public bool grounded;

	[NonSerialized]
	public float cachedStability;

	[NonSerialized]
	public int cachedDistanceFromGround = int.MaxValue;

	private List<Support> supports;

	private int stabilityStrikes;

	private bool dirty;

	public static StabilityCheckWorkQueue stabilityCheckQueue = new StabilityCheckWorkQueue();

	public static UpdateSurroundingsQueue updateSurroundingsQueue = new UpdateSurroundingsQueue();

	public override void ResetState()
	{
		base.ResetState();
		cachedStability = 0f;
		cachedDistanceFromGround = int.MaxValue;
		if (base.isServer)
		{
			supports = null;
			stabilityStrikes = 0;
			dirty = false;
		}
	}

	public void InitializeSupports()
	{
		supports = new List<Support>();
		if (grounded || HasParent())
		{
			return;
		}
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			if (entityLink.IsMale())
			{
				if (entityLink.socket is StabilitySocket)
				{
					supports.Add(new Support(this, entityLink, (entityLink.socket as StabilitySocket).support));
				}
				if (entityLink.socket is ConstructionSocket)
				{
					supports.Add(new Support(this, entityLink, (entityLink.socket as ConstructionSocket).support));
				}
			}
		}
	}

	public int DistanceFromGround(StabilityEntity ignoreEntity = null)
	{
		if (grounded || HasParent())
		{
			return 1;
		}
		if (supports == null)
		{
			return 1;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		int num = int.MaxValue;
		for (int i = 0; i < supports.Count; i++)
		{
			StabilityEntity stabilityEntity = supports[i].SupportEntity(ignoreEntity);
			if (!((Object)(object)stabilityEntity == (Object)null))
			{
				int num2 = stabilityEntity.CachedDistanceFromGround(ignoreEntity);
				if (num2 != int.MaxValue)
				{
					num = Mathf.Min(num, num2 + 1);
				}
			}
		}
		return num;
	}

	public float SupportValue(StabilityEntity ignoreEntity = null)
	{
		if (grounded || HasParent())
		{
			return 1f;
		}
		if (supports == null)
		{
			return 1f;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		float num = 0f;
		for (int i = 0; i < supports.Count; i++)
		{
			Support support = supports[i];
			StabilityEntity stabilityEntity = support.SupportEntity(ignoreEntity);
			if (!((Object)(object)stabilityEntity == (Object)null))
			{
				float num2 = stabilityEntity.CachedSupportValue(ignoreEntity);
				if (num2 != 0f)
				{
					num += num2 * support.factor;
				}
			}
		}
		return Mathf.Clamp01(num);
	}

	public int CachedDistanceFromGround(StabilityEntity ignoreEntity = null)
	{
		if (grounded || HasParent())
		{
			return 1;
		}
		if (supports == null)
		{
			return 1;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		int num = int.MaxValue;
		for (int i = 0; i < supports.Count; i++)
		{
			StabilityEntity stabilityEntity = supports[i].SupportEntity(ignoreEntity);
			if (!((Object)(object)stabilityEntity == (Object)null))
			{
				int num2 = stabilityEntity.cachedDistanceFromGround;
				if (num2 != int.MaxValue)
				{
					num = Mathf.Min(num, num2 + 1);
				}
			}
		}
		return num;
	}

	public float CachedSupportValue(StabilityEntity ignoreEntity = null)
	{
		if (grounded || HasParent())
		{
			return 1f;
		}
		if (supports == null)
		{
			return 1f;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		float num = 0f;
		for (int i = 0; i < supports.Count; i++)
		{
			Support support = supports[i];
			StabilityEntity stabilityEntity = support.SupportEntity(ignoreEntity);
			if (!((Object)(object)stabilityEntity == (Object)null))
			{
				float num2 = stabilityEntity.cachedStability;
				if (num2 != 0f)
				{
					num += num2 * support.factor;
				}
			}
		}
		return Mathf.Clamp01(num);
	}

	public virtual void StabilityCheck()
	{
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if (base.IsDestroyed || Interface.CallHook("OnEntityStabilityCheck", (object)this) != null)
		{
			return;
		}
		if (supports == null)
		{
			InitializeSupports();
		}
		bool flag = false;
		int num = DistanceFromGround();
		if (num != cachedDistanceFromGround)
		{
			cachedDistanceFromGround = num;
			flag = true;
		}
		float num2 = SupportValue();
		if (Mathf.Abs(cachedStability - num2) > Stability.accuracy)
		{
			cachedStability = num2;
			flag = true;
		}
		if (flag)
		{
			dirty = true;
			UpdateConnectedEntities();
			UpdateStability();
		}
		else if (dirty)
		{
			dirty = false;
			SendNetworkUpdate();
		}
		if (num2 < Stability.collapse)
		{
			if (stabilityStrikes < Stability.strikes)
			{
				UpdateStability();
				stabilityStrikes++;
				return;
			}
			if (Stability.log_stability_death)
			{
				Debug.Log((object)$"Killing '{((object)this).ToString()}' at position {((Component)this).transform.position} due to low stability: {Math.Round(num2 * 100f, 2)} < {Math.Round(Stability.collapse * 100f, 1)}%");
			}
			Kill(DestroyMode.Gib);
		}
		else
		{
			stabilityStrikes = 0;
		}
	}

	public void UpdateStability()
	{
		((ObjectWorkQueue<StabilityEntity>)stabilityCheckQueue).Add(this);
	}

	public void UpdateSurroundingEntities()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		UpdateSurroundingsQueue obj = updateSurroundingsQueue;
		OBB val = WorldSpaceBounds();
		((ObjectWorkQueue<Bounds>)obj).Add(((OBB)(ref val)).ToBounds());
	}

	public void UpdateConnectedEntities()
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			if (!entityLink.IsFemale())
			{
				continue;
			}
			for (int j = 0; j < entityLink.connections.Count; j++)
			{
				StabilityEntity stabilityEntity = entityLink.connections[j].owner as StabilityEntity;
				if (!((Object)(object)stabilityEntity == (Object)null) && !stabilityEntity.isClient && !stabilityEntity.IsDestroyed)
				{
					stabilityEntity.UpdateStability();
				}
			}
		}
	}

	protected void OnPhysicsNeighbourChanged()
	{
		if (!base.IsDestroyed)
		{
			StabilityCheck();
		}
	}

	protected void DebugNudge()
	{
		StabilityCheck();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			UpdateStability();
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		UpdateSurroundingEntities();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.stabilityEntity = Pool.Get<StabilityEntity>();
		info.msg.stabilityEntity.stability = cachedStability;
		info.msg.stabilityEntity.distanceFromGround = cachedDistanceFromGround;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.stabilityEntity != null)
		{
			cachedStability = info.msg.stabilityEntity.stability;
			cachedDistanceFromGround = info.msg.stabilityEntity.distanceFromGround;
			if (cachedStability <= 0f)
			{
				cachedStability = 0f;
			}
			if (cachedDistanceFromGround <= 0)
			{
				cachedDistanceFromGround = int.MaxValue;
			}
		}
	}
}


using ConVar;

public class StabilityCheckWorkQueue : ObjectWorkQueue<StabilityEntity>
{
	protected override void RunJob(StabilityEntity entity)
	{
		if (((ObjectWorkQueue<StabilityEntity>)this).ShouldAdd(entity))
		{
			entity.StabilityCheck();
		}
	}

	protected override bool ShouldAdd(StabilityEntity entity)
	{
		if (!Server.stability)
		{
			return false;
		}
		if (!entity.IsValid())
		{
			return false;
		}
		if (!entity.isServer)
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class UpdateSurroundingsQueue : ObjectWorkQueue<Bounds>
{
	protected override void RunJob(Bounds bounds)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		NotifyNeighbours(bounds);
	}

	public static void NotifyNeighbours(Bounds bounds)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (!Server.stability)
		{
			return;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vector3 center = ((Bounds)(ref bounds)).center;
		Vector3 extents = ((Bounds)(ref bounds)).extents;
		Vis.Entities(center, ((Vector3)(ref extents)).magnitude + 1f, list, -2144696062, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.IsDestroyed && !item.isClient)
			{
				if (item is StabilityEntity stabilityEntity)
				{
					stabilityEntity.OnPhysicsNeighbourChanged();
				}
				else
				{
					((Component)item).BroadcastMessage("OnPhysicsNeighbourChanged", (SendMessageOptions)1);
				}
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}
}


using ConVar;
using UnityEngine;

public class Support
{
	public StabilityEntity parent;

	public EntityLink link;

	public float factor = 1f;

	public Support(StabilityEntity parent, EntityLink link, float factor)
	{
		this.parent = parent;
		this.link = link;
		this.factor = factor;
	}

	public StabilityEntity SupportEntity(StabilityEntity ignoreEntity = null)
	{
		StabilityEntity stabilityEntity = null;
		for (int i = 0; i < link.connections.Count; i++)
		{
			StabilityEntity stabilityEntity2 = link.connections[i].owner as StabilityEntity;
			Socket_Base socket = link.connections[i].socket;
			if ((Object)(object)stabilityEntity2 == (Object)null || (Object)(object)stabilityEntity2 == (Object)(object)parent || (Object)(object)stabilityEntity2 == (Object)(object)ignoreEntity || stabilityEntity2.isClient || stabilityEntity2.IsDestroyed || socket is ConstructionSocket { femaleNoStability: not false })
			{
				continue;
			}
			if ((Object)(object)stabilityEntity == (Object)null)
			{
				stabilityEntity = stabilityEntity2;
			}
			else if (Stability.support_highest_stability)
			{
				if (stabilityEntity2.cachedStability > stabilityEntity.cachedStability)
				{
					stabilityEntity = stabilityEntity2;
				}
			}
			else if (stabilityEntity2.cachedDistanceFromGround < stabilityEntity.cachedDistanceFromGround)
			{
				stabilityEntity = stabilityEntity2;
			}
		}
		return stabilityEntity;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

public class TimedExplosive : BaseEntity, ServerProjectile.IProjectileImpact
{
	public enum ExplosionEffectOffsetMode
	{
		Local,
		World
	}

	[Header("General")]
	public float timerAmountMin = 10f;

	public float timerAmountMax = 20f;

	public float minExplosionRadius;

	public float explosionRadius = 10f;

	public bool explodeOnContact;

	public bool canStick;

	public bool onlyDamageParent;

	[Header("AI")]
	public bool IgnoreAI;

	public bool BlindAI;

	public float aiBlindDuration = 2.5f;

	public float aiBlindRange = 4f;

	[Header("Offsets")]
	public ExplosionEffectOffsetMode explosionOffsetMode;

	public Vector3 explosionEffectOffset = Vector3.zero;

	[Header("Normals")]
	public bool explosionMatchesNormal;

	public bool explosionUsesForward;

	public bool explosionMatchesOrientation;

	public bool explosionMatchesVelocity;

	public bool explosionMatchesInverseVelocity;

	[Header("Effects")]
	public GameObjectRef explosionEffect;

	[Tooltip("Optional: Will fall back to watersurfaceExplosionEffect or explosionEffect if not assigned.")]
	public GameObjectRef underwaterExplosionEffect;

	public GameObjectRef stickEffect;

	public GameObjectRef bounceEffect;

	public GameObjectRef watersurfaceExplosionEffect;

	[Header("Water")]
	[Min(0f)]
	public float underwaterExplosionDepth = 1f;

	[Tooltip("Optional: Will fall back to underwaterExplosionEffect or explosionEffect if not assigned.")]
	[MinMax(0f, 100f)]
	public MinMax watersurfaceExplosionDepth = new MinMax(0.5f, 10f);

	public bool waterCausesExplosion;

	[Header("Other")]
	public int vibrationLevel = 3;

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	public List<DamageTypeEntry> playerDamage = new List<DamageTypeEntry>();

	public bool splashWallpaperThroughWalls;

	[NonSerialized]
	private float lastBounceTime;

	private bool hadRB;

	private float rbMass;

	private float rbDrag;

	private float rbAngularDrag;

	private Vector3 rbVelocityBeforeCollision;

	private CollisionDetectionMode rbCollisionMode;

	[NonSerialized]
	public ItemOwnershipShare ItemOwnership;

	protected BasePlayer creatorPlayer;

	private const int parentOnlySplashDamage = 166144;

	private const int fullSplashDamage = 1210222849;

	protected Vector3? hitNormal;

	private static BaseEntity[] queryResults = new BaseEntity[64];

	private Vector3 lastPosition = Vector3.zero;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	protected virtual bool AlwaysRunWaterCheck => false;

	public List<DamageTypeEntry> GetDamageList(BaseEntity entity)
	{
		if (ConVar.Server.explosive_testing_mode)
		{
			return new List<DamageTypeEntry>
			{
				new DamageTypeEntry
				{
					amount = 1f,
					type = DamageType.Explosion
				}
			};
		}
		if (entity is BasePlayer && playerDamage != null && playerDamage.Count > 0)
		{
			return playerDamage;
		}
		return damageTypes;
	}

	public void SetDamageScale(float scale)
	{
		foreach (DamageTypeEntry damageType in damageTypes)
		{
			damageType.amount *= scale;
		}
	}

	public void SetCreator(BasePlayer ply)
	{
		creatorPlayer = ply;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		lastBounceTime = Time.time;
		base.ServerInit();
		SetFuse(GetRandomTimerTime());
		if (((Component)(object)((Component)this).transform).HasComponent<Collider>())
		{
			ReceiveCollisionMessages(b: true);
		}
		if (waterCausesExplosion || AlwaysRunWaterCheck)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)WaterCheck, 0f, 0.5f);
		}
	}

	public virtual void WaterCheck()
	{
		if (waterCausesExplosion && WaterFactor() >= 0.5f)
		{
			Explode();
			Debug.Log((object)"water explode");
		}
	}

	public virtual void SetFuse(float fuseLength)
	{
		if (base.isServer)
		{
			object obj = Interface.CallHook("OnExplosiveFuseSet", (object)this, (object)fuseLength);
			if (obj is float)
			{
				fuseLength = (float)obj;
			}
			((FacepunchBehaviour)this).Invoke((Action)Explode, fuseLength);
			SetFlag(Flags.Reserved2, b: true);
		}
	}

	public virtual float GetRandomTimerTime()
	{
		return Random.Range(timerAmountMin, timerAmountMax);
	}

	public virtual void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		hitNormal = ((RaycastHit)(ref info)).normal;
		Explode();
	}

	public void ForceExplode()
	{
		if (this is DudTimedExplosive dudTimedExplosive)
		{
			dudTimedExplosive.dudChance = 0f;
		}
		if (this is RFTimedExplosive rFTimedExplosive)
		{
			rFTimedExplosive.DisarmRF();
		}
		Explode();
	}

	public virtual void Explode()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Explode(PivotPoint());
	}

	private Vector3 GetExplosionNormal()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result;
		if (explosionUsesForward)
		{
			result = ((Component)this).transform.forward;
		}
		else if (!explosionMatchesOrientation)
		{
			result = (explosionMatchesVelocity ? ((Vector3)(ref rbVelocityBeforeCollision)).normalized : ((!explosionMatchesInverseVelocity) ? Vector3.up : (-((Vector3)(ref rbVelocityBeforeCollision)).normalized)));
		}
		else
		{
			Quaternion rotation = ((Component)this).transform.rotation;
			Vector3 forward = Vector3.forward;
			result = rotation * forward;
		}
		if (explosionMatchesNormal && hitNormal.HasValue)
		{
			result = hitNormal.Value;
		}
		return result;
	}

	public virtual void Explode(Vector3 explosionFxPos)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0428: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		Analytics.Azure.OnExplosion(this);
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.enabled = false;
		}
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(explosionFxPos - new Vector3(0f, 0.25f, 0f), waves: true, volumes: true);
		if (underwaterExplosionEffect.isValid && waterInfo.isValid && waterInfo.currentDepth >= underwaterExplosionDepth)
		{
			Effect.server.Run(underwaterExplosionEffect.resourcePath, explosionFxPos, GetExplosionNormal(), null, broadcast: true);
		}
		else if (explosionEffect.isValid)
		{
			Vector3 val = explosionFxPos;
			if (explosionOffsetMode == ExplosionEffectOffsetMode.Local)
			{
				Vector3 val2 = ((Component)this).transform.TransformPoint(explosionEffectOffset) - ((Component)this).transform.position;
				val += val2;
			}
			if (explosionOffsetMode == ExplosionEffectOffsetMode.World)
			{
				val += explosionEffectOffset;
			}
			Effect.server.Run(explosionEffect.resourcePath, val, GetExplosionNormal(), null, broadcast: true);
		}
		if (watersurfaceExplosionEffect.isValid && waterInfo.isValid && waterInfo.overallDepth >= watersurfaceExplosionDepth.x && waterInfo.currentDepth <= watersurfaceExplosionDepth.y)
		{
			Effect.server.Run(watersurfaceExplosionEffect.resourcePath, Vector3Ex.WithY(explosionFxPos, waterInfo.surfaceLevel), GetExplosionNormal(), null, broadcast: true);
		}
		if (GetDamageList(null).Count > 0)
		{
			if (Interface.CallHook("OnTimedExplosiveExplode", (object)this, (object)explosionFxPos) != null)
			{
				return;
			}
			Vector3 val3 = ExplosionCenter();
			if (onlyDamageParent)
			{
				int num = 166144;
				if (!ConVar.AntiHack.explosive_vehicle_parent_damage_deployables && parentEntity.Get(serverside: true) is BaseVehicle)
				{
					num &= -257;
				}
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), val3, minExplosionRadius, explosionRadius, GetDamageList(null), num, useLineOfSight: true, IgnoreAI, ignoreAttackingPlayer: false, extendedLineOfSight: false, playerDamage);
				BaseEntity baseEntity = GetParentEntity();
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				while ((Object)(object)baseCombatEntity == (Object)null && (Object)(object)baseEntity != (Object)null && baseEntity.HasParent())
				{
					baseEntity = baseEntity.GetParentEntity();
					baseCombatEntity = baseEntity as BaseCombatEntity;
				}
				if ((Object)(object)baseEntity == (Object)null || !((Component)baseEntity).gameObject.IsOnLayer((Layer)21))
				{
					List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
					Vis.Entities(val3, explosionRadius, list, 2097152, (QueryTriggerInteraction)1);
					BuildingBlock buildingBlock = null;
					float num2 = float.PositiveInfinity;
					foreach (BuildingBlock item in list)
					{
						if (!item.isClient && !item.IsDestroyed && !(item.healthFraction <= 0f))
						{
							float num3 = Vector3.Distance(item.ClosestPoint(val3), val3);
							if (num3 < num2 && item.IsVisible(val3, explosionRadius))
							{
								buildingBlock = item;
								num2 = num3;
							}
						}
					}
					if (Object.op_Implicit((Object)(object)buildingBlock))
					{
						HitInfo hitInfo = new HitInfo();
						hitInfo.Initiator = creatorEntity;
						hitInfo.WeaponPrefab = LookupPrefab();
						hitInfo.damageTypes.Add(GetDamageList(buildingBlock));
						hitInfo.PointStart = val3;
						hitInfo.PointEnd = ((Component)buildingBlock).transform.position;
						float amount = 1f - Mathf.Clamp01((num2 - minExplosionRadius) / (explosionRadius - minExplosionRadius));
						hitInfo.damageTypes.ScaleAll(amount);
						buildingBlock.Hurt(hitInfo);
					}
					Pool.FreeUnmanaged<BuildingBlock>(ref list);
				}
				if (Object.op_Implicit((Object)(object)baseCombatEntity))
				{
					HitInfo hitInfo2 = new HitInfo();
					hitInfo2.Initiator = creatorEntity;
					hitInfo2.WeaponPrefab = LookupPrefab();
					hitInfo2.damageTypes.Add(GetDamageList(baseEntity));
					baseCombatEntity.Hurt(hitInfo2);
				}
				else if ((Object)(object)baseEntity != (Object)null)
				{
					HitInfo hitInfo3 = new HitInfo();
					hitInfo3.Initiator = creatorEntity;
					hitInfo3.WeaponPrefab = LookupPrefab();
					hitInfo3.damageTypes.Add(GetDamageList(baseEntity));
					hitInfo3.PointStart = val3;
					hitInfo3.PointEnd = ((Component)baseEntity).transform.position;
					baseEntity.OnAttacked(hitInfo3);
				}
				if (splashWallpaperThroughWalls)
				{
					List<BuildingBlock> list2 = Pool.Get<List<BuildingBlock>>();
					Vis.Entities(val3, 3.4f, list2, 2097152, (QueryTriggerInteraction)1);
					foreach (BuildingBlock item2 in list2)
					{
						item2.RemoveWallpaper(0);
						item2.RemoveWallpaper(1);
					}
					Pool.FreeUnmanaged<BuildingBlock>(ref list2);
				}
			}
			else
			{
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), val3, minExplosionRadius, explosionRadius, GetDamageList(null), 1210222849, useLineOfSight: true, IgnoreAI, ignoreAttackingPlayer: false, extendedLineOfSight: false, playerDamage, splashWallpaperThroughWalls);
			}
			SeismicSensor.Notify(val3, vibrationLevel);
			BlindAnyAI();
		}
		if (!base.IsDestroyed && !HasFlag(Flags.Broken) && !ConVar.Server.explosive_testing_mode)
		{
			Kill(DestroyMode.Gib);
		}
	}

	private Vector3 ExplosionCenter()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (IsStuck() && parentEntity.Get(base.isServer) is BaseVehicle)
		{
			OBB val = WorldSpaceBounds();
			return CenterPoint() - val.forward * (val.extents.z + 0.1f);
		}
		return CenterPoint();
	}

	private void BlindAnyAI()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (!BlindAI)
		{
			return;
		}
		int brainsInSphereFast = Query.Server.GetBrainsInSphereFast(((Component)this).transform.position, 10f, queryResults);
		for (int i = 0; i < brainsInSphereFast; i++)
		{
			BaseEntity baseEntity = queryResults[i];
			if (Vector3.Distance(((Component)this).transform.position, ((Component)baseEntity).transform.position) > aiBlindRange)
			{
				continue;
			}
			BaseAIBrain component = ((Component)baseEntity).GetComponent<BaseAIBrain>();
			if (!((Object)(object)component == (Object)null))
			{
				BaseEntity brainBaseEntity = component.GetBrainBaseEntity();
				if (!((Object)(object)brainBaseEntity == (Object)null) && brainBaseEntity.IsVisible(CenterPoint()))
				{
					float blinded = aiBlindDuration * component.BlindDurationMultiplier * Random.Range(0.6f, 1.4f);
					component.SetBlinded(blinded);
					queryResults[i] = null;
				}
			}
		}
	}

	public void FixedUpdate()
	{
		CheckClippingThroughWalls();
	}

	protected virtual bool ShouldBypassClippingWallCheck()
	{
		return false;
	}

	private void CheckClippingThroughWalls()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		if (!canStick)
		{
			return;
		}
		if (lastPosition == default(Vector3) || !parentEntity.IsValid(serverside: true))
		{
			lastPosition = CenterPoint();
			return;
		}
		Vector3 val = lastPosition;
		Vector3 val2 = CenterPoint();
		Vector3 val3 = val2 - val;
		lastPosition = val2;
		if (val == val2 || !IsStuck(bypassColliderCheck: true) || ShouldBypassClippingWallCheck())
		{
			return;
		}
		Ray ray = new Ray(val, val2 - val);
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(ray, 0f, list, Vector3.Distance(val2, val), 2097152, (QueryTriggerInteraction)0);
		foreach (RaycastHit item in list)
		{
			if ((Object)(object)(item.GetEntity() as BuildingBlock) != (Object)null)
			{
				Transform transform = ((Component)this).transform;
				transform.position -= val3;
				ForceExplode();
				break;
			}
		}
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if (canStick && !IsStuck())
		{
			bool flag = true;
			if (Object.op_Implicit((Object)(object)hitEntity))
			{
				flag = CanStickTo(hitEntity);
				if (!flag)
				{
					Collider component = ((Component)this).GetComponent<Collider>();
					if ((Object)(object)collision.collider != (Object)null && (Object)(object)component != (Object)null)
					{
						Physics.IgnoreCollision(collision.collider, component);
					}
				}
			}
			if (flag)
			{
				DoCollisionStick(collision, hitEntity);
			}
		}
		if (explodeOnContact && !IsBusy())
		{
			hitNormal = ((ContactPoint)(ref collision.contacts[0])).normal;
			SetMotionEnabled(wantsMotion: false);
			SetFlag(Flags.Busy, b: true, recursive: false, networkupdate: false);
			((FacepunchBehaviour)this).Invoke((Action)Explode, 0.015f);
		}
		else
		{
			DoBounceEffect();
		}
	}

	public virtual bool CanStickTo(BaseEntity entity)
	{
		object obj = Interface.CallHook("CanExplosiveStick", (object)this, (object)entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		DecorDeployable decorDeployable = default(DecorDeployable);
		if (((Component)entity).TryGetComponent<DecorDeployable>(ref decorDeployable))
		{
			return false;
		}
		if (entity is Drone)
		{
			return false;
		}
		if (entity is TravellingVendor)
		{
			return false;
		}
		return true;
	}

	private void DoBounceEffect()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!bounceEffect.isValid || Time.time - lastBounceTime < 0.2f)
		{
			return;
		}
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component))
		{
			Vector3 velocity = component.velocity;
			if (((Vector3)(ref velocity)).magnitude < 1f)
			{
				return;
			}
		}
		if (bounceEffect.isValid)
		{
			Effect.server.Run(bounceEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
		}
		lastBounceTime = Time.time;
	}

	private void DoCollisionStick(Collision collision, BaseEntity ent)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		ContactPoint contact = collision.GetContact(0);
		DoStick(((ContactPoint)(ref contact)).point, ((ContactPoint)(ref contact)).normal, ent, collision.collider);
	}

	public virtual void SetMotionEnabled(bool wantsMotion)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (wantsMotion)
		{
			if ((Object)(object)component == (Object)null && hadRB)
			{
				component = ((Component)this).gameObject.AddComponent<Rigidbody>();
				component.mass = rbMass;
				component.drag = rbDrag;
				component.angularDrag = rbAngularDrag;
				component.collisionDetectionMode = rbCollisionMode;
				component.useGravity = true;
				component.isKinematic = false;
			}
		}
		else if ((Object)(object)component != (Object)null)
		{
			hadRB = true;
			rbMass = component.mass;
			rbDrag = component.drag;
			rbAngularDrag = component.angularDrag;
			rbCollisionMode = component.collisionDetectionMode;
			rbVelocityBeforeCollision = component.velocity;
			Object.Destroy((Object)(object)component);
		}
	}

	public bool IsStuck(bool bypassColliderCheck = false)
	{
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component) && !component.isKinematic)
		{
			return false;
		}
		if (!bypassColliderCheck)
		{
			Collider component2 = ((Component)this).GetComponent<Collider>();
			if (Object.op_Implicit((Object)(object)component2) && component2.enabled)
			{
				return false;
			}
		}
		return parentEntity.IsValid(serverside: true);
	}

	public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent, Collider collider)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null)
		{
			return;
		}
		if (ent is TimedExplosive)
		{
			if (!ent.HasParent())
			{
				return;
			}
			position = ((Component)ent).transform.position;
			ent = ent.parentEntity.Get(serverside: true);
		}
		SetMotionEnabled(wantsMotion: false);
		if (!HasChild(ent))
		{
			((Component)this).transform.position = position;
			((Component)this).transform.rotation = Quaternion.LookRotation(normal, ((Component)this).transform.up);
			if ((Object)(object)collider != (Object)null)
			{
				SetParent(ent, ent.FindBoneID(((Component)collider).transform), worldPositionStays: true);
			}
			else
			{
				SetParent(ent, StringPool.closest, worldPositionStays: true);
			}
			if (ent is BaseCombatEntity baseCombatEntity)
			{
				baseCombatEntity.SetJustAttacked();
			}
			if (stickEffect.isValid)
			{
				Effect.server.Run(stickEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
			}
			ReceiveCollisionMessages(b: false);
		}
	}

	public void UnStick()
	{
		if (Object.op_Implicit((Object)(object)GetParentEntity()))
		{
			SetParent(null, worldPositionStays: true, sendImmediate: true);
			SetMotionEnabled(wantsMotion: true);
			if (((Component)(object)((Component)this).transform).HasComponent<Collider>())
			{
				ReceiveCollisionMessages(b: true);
			}
		}
	}

	internal override void OnParentRemoved()
	{
		UnStick();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
	}

	public override void PostServerLoad()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		if (parentEntity.IsValid(serverside: true))
		{
			DoStick(((Component)this).transform.position, ((Component)this).transform.forward, parentEntity.Get(serverside: true), null);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.explosive != null)
		{
			parentEntity.uid = info.msg.explosive.parentid;
		}
	}

	public virtual void SetCollisionEnabled(bool wantsCollision)
	{
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component) && component.enabled != wantsCollision)
		{
			component.enabled = wantsCollision;
		}
	}
}


public enum ExplosionEffectOffsetMode
{
	Local,
	World
}


using UnityEngine;

public class BaseTrap : DecayEntity
{
	public virtual void ObjectEntered(GameObject obj)
	{
	}

	public virtual void Arm()
	{
		SetFlag(Flags.On, b: true);
		SendNetworkUpdate();
	}

	public virtual void OnEmpty()
	{
	}
}


using Oxide.Core;
using UnityEngine;

public class BaseTrapTrigger : TriggerBase
{
	public BaseTrap _trap;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		Interface.CallHook("OnTrapSnapped", (object)this, (object)obj, (object)col);
		base.OnObjectAdded(obj, col);
		_trap.ObjectEntered(obj);
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		_trap.OnEmpty();
	}
}


public class BearTrapTrigger : BaseTrapTrigger
{
}


using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class SurvivalFishTrap : WildlifeTrap
{
	private WaterBody cachedWaterBody;

	private bool bypassItemFilter;

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (GamePhysics.Trace(new Ray(((Component)this).transform.position + Vector3.up, Vector3.down), 0f, out var hitInfo, 1.5f, 16, (QueryTriggerInteraction)0))
		{
			cachedWaterBody = hitInfo.GetWaterBody();
		}
	}

	public override bool HasBait()
	{
		ItemModCompostable itemModCompostable = default(ItemModCompostable);
		foreach (Item item in base.inventory.itemList)
		{
			if (item != null && ((Component)item.info).TryGetComponent<ItemModCompostable>(ref itemModCompostable) && itemModCompostable.BaitValue > 0f)
			{
				return true;
			}
		}
		return false;
	}

	public override void TrapThink()
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		ItemDefinition itemDefinition = null;
		Item item = null;
		int usedLureAmount = 0;
		using (List<Item>.Enumerator enumerator = base.inventory.itemList.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				Item current = enumerator.Current;
				ItemModCompostable itemModCompostable = default(ItemModCompostable);
				if ((((Component)current.info).TryGetComponent<ItemModCompostable>(ref itemModCompostable) ? itemModCompostable.BaitValue : 0f) > 0f)
				{
					item = current;
					itemDefinition = FishLookup.Instance.GetFish(((Component)this).transform.position, cachedWaterBody, current, out var _, ((Component)current.info).GetComponent<ItemModFishable>(), out usedLureAmount, 5f);
				}
			}
		}
		item?.UseItem(usedLureAmount);
		if (Random.Range(0f, 1f) <= trapSuccessRate || !((Object)(object)itemDefinition != (Object)null))
		{
			return;
		}
		try
		{
			bypassItemFilter = true;
			if (Interface.CallHook("OnWildlifeTrap", (object)this, (object)itemDefinition) == null)
			{
				Item item2 = ItemManager.Create(itemDefinition, 1, 0uL);
				if ((Object)(object)base.LastLootedByPlayer != (Object)null)
				{
					item2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);
				}
				if (!item2.MoveToContainer(base.inventory))
				{
					item2.Drop(((Component)this).transform.position, Vector3.zero, Quaternion.identity);
				}
				OnTrappedWildlife(setFlag: true);
			}
		}
		finally
		{
			bypassItemFilter = false;
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (FishLookup.Instance == null || item == null)
		{
			return false;
		}
		FishLookup.LoadFish();
		if (bypassItemFilter)
		{
			return true;
		}
		bool flag = false;
		ItemDefinition[] baitItems = FishLookup.BaitItems;
		for (int i = 0; i < baitItems.Length; i++)
		{
			if ((Object)(object)baitItems[i] == (Object)(object)item.info)
			{
				flag = true;
				break;
			}
		}
		return base.ItemFilter(item, targetSlot) && flag;
	}

	protected override bool CanAcceptItem(Item item, int slot)
	{
		if (FishLookup.Instance == null || item == null)
		{
			return false;
		}
		FishLookup.LoadFish();
		if (bypassItemFilter)
		{
			return true;
		}
		bool result = false;
		ItemDefinition[] baitItems = FishLookup.BaitItems;
		for (int i = 0; i < baitItems.Length; i++)
		{
			if ((Object)(object)baitItems[i] == (Object)(object)item.info)
			{
				result = true;
				break;
			}
		}
		return result;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
[CreateAssetMenu(menuName = "Rust/TrappableWildlife")]
public class TrappableWildlife : ScriptableObject
{
	[Serializable]
	public class BaitType
	{
		public float successRate = 1f;

		public ItemDefinition bait;

		public int minForInterest = 1;

		public int maxToConsume = 1;
	}

	public GameObjectRef worldObject;

	public ItemDefinition inventoryObject;

	public int minToCatch;

	public int maxToCatch;

	public List<BaitType> baitTypes;

	public int caloriesForInterest = 20;

	public float successRate = 1f;

	public float xpScale = 1f;
}


using System;

[Serializable]
public class BaitType
{
	public float successRate = 1f;

	public ItemDefinition bait;

	public int minForInterest = 1;

	public int maxToConsume = 1;
}


using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Rust;
using UnityEngine;

public class WildlifeTrap : StorageContainer
{
	[Serializable]
	public class WildlifeWeight
	{
		public TrappableWildlife wildlife;

		public int weight;
	}

	public static class WildlifeTrapFlags
	{
		public const Flags Occupied = Flags.Reserved1;
	}

	public float tickRate = 60f;

	public GameObjectRef trappedEffect;

	public float trappedEffectRepeatRate = 30f;

	public float trapSuccessRate = 0.5f;

	public List<ItemDefinition> ignoreBait;

	public List<WildlifeWeight> targetWildlife;

	public override void ResetState()
	{
		base.ResetState();
	}

	public void SetTrapActive(bool trapOn)
	{
		if (trapOn != IsTrapActive())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TrapThink);
			SetFlag(Flags.On, trapOn);
			if (trapOn)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)TrapThink, tickRate * 0.8f + tickRate * Random.Range(0f, 0.4f), tickRate);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer && IsOn())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)TrapThink, tickRate * 0.8f + tickRate * Random.Range(0f, 0.4f), tickRate);
		}
	}

	[ContextMenu("DebugPrintout")]
	public void DebugPrintout()
	{
		bool flag = ((FacepunchBehaviour)this).IsInvoking((Action)TrapThink);
		Debug.Log((object)$"is invoking: {flag}");
	}

	private int CalculateBaitCalories(Item bait)
	{
		ItemModConsumable component = ((Component)bait.info).GetComponent<ItemModConsumable>();
		if ((Object)(object)component == (Object)null)
		{
			return 0;
		}
		if (ignoreBait.Contains(bait.info))
		{
			return 0;
		}
		int num = 0;
		foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
		{
			if (effect.type == MetabolismAttribute.Type.Calories && effect.amount > 0f)
			{
				num += Mathf.CeilToInt(effect.amount * (float)bait.amount);
			}
		}
		return num;
	}

	public int GetBaitCalories()
	{
		int num = 0;
		foreach (Item item in base.inventory.itemList)
		{
			num += CalculateBaitCalories(item);
		}
		return num;
	}

	public void DestroyRandomFoodItem()
	{
		int count = base.inventory.itemList.Count;
		int num = Random.Range(0, count);
		for (int i = 0; i < count; i++)
		{
			int num2 = num + i;
			if (num2 >= count)
			{
				num2 -= count;
			}
			Item item = base.inventory.itemList[num2];
			if (item != null && !((Object)(object)((Component)item.info).GetComponent<ItemModConsumable>() == (Object)null))
			{
				item.UseItem();
				break;
			}
		}
	}

	public void UseBaitCalories(int numToUse)
	{
		foreach (Item item in base.inventory.itemList)
		{
			int itemCalories = GetItemCalories(item);
			if (itemCalories > 0)
			{
				numToUse -= itemCalories;
				item.UseItem();
				if (numToUse <= 0)
				{
					break;
				}
			}
		}
	}

	public int GetItemCalories(Item item)
	{
		ItemModConsumable component = ((Component)item.info).GetComponent<ItemModConsumable>();
		if ((Object)(object)component == (Object)null)
		{
			return 0;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
		{
			if (effect.type == MetabolismAttribute.Type.Calories && effect.amount > 0f)
			{
				return Mathf.CeilToInt(effect.amount);
			}
		}
		return 0;
	}

	public virtual void TrapThink()
	{
		int baitCalories = GetBaitCalories();
		if (baitCalories <= 0)
		{
			return;
		}
		TrappableWildlife randomWildlife = GetRandomWildlife();
		if (baitCalories >= randomWildlife.caloriesForInterest && Random.Range(0f, 1f) <= randomWildlife.successRate)
		{
			UseBaitCalories(randomWildlife.caloriesForInterest);
			if (Random.Range(0f, 1f) <= trapSuccessRate)
			{
				TrapWildlife(randomWildlife);
			}
		}
	}

	public void TrapWildlife(TrappableWildlife trapped)
	{
		if (Interface.CallHook("OnWildlifeTrap", (object)this, (object)trapped) == null)
		{
			Item item = ItemManager.Create(trapped.inventoryObject, Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL);
			if ((Object)(object)base.LastLootedByPlayer != (Object)null)
			{
				item.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);
			}
			if (!item.MoveToContainer(base.inventory))
			{
				item.Remove();
				OnTrappedWildlife(setFlag: false);
			}
			else
			{
				OnTrappedWildlife(setFlag: true);
			}
		}
	}

	protected void OnTrappedWildlife(bool setFlag)
	{
		if (setFlag)
		{
			SetFlag(Flags.Reserved1, b: true);
		}
		SetTrapActive(trapOn: false);
		Hurt(StartMaxHealth() * 0.1f, DamageType.Decay, null, useProtection: false);
	}

	public void ClearTrap()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public virtual bool HasBait()
	{
		return GetBaitCalories() > 0;
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		SetTrapActive(HasBait());
		ClearTrap();
		base.PlayerStoppedLooting(player);
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		ClearTrap();
		return base.OnStartBeingLooted(baseEntity);
	}

	public TrappableWildlife GetRandomWildlife()
	{
		int num = targetWildlife.Sum((WildlifeWeight x) => x.weight);
		int num2 = Random.Range(0, num);
		for (int i = 0; i < targetWildlife.Count; i++)
		{
			num -= targetWildlife[i].weight;
			if (num2 >= num)
			{
				return targetWildlife[i].wildlife;
			}
		}
		return null;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	protected virtual bool CanAcceptItem(Item item, int slot)
	{
		if (CalculateBaitCalories(item) > 0)
		{
			return true;
		}
		foreach (WildlifeWeight item2 in targetWildlife)
		{
			if ((Object)(object)item2.wildlife?.inventoryObject == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasCatch()
	{
		return HasFlag(Flags.Reserved1);
	}

	public bool IsTrapActive()
	{
		return HasFlag(Flags.On);
	}
}


using System;

[Serializable]
public class WildlifeWeight
{
	public TrappableWildlife wildlife;

	public int weight;
}


public static class WildlifeTrapFlags
{
	public const Flags Occupied = Flags.Reserved1;
}


using UnityEngine;

public class BaseAimable : BaseVehicleMountPoint
{
	public Transform aimBase;
}


public class BaseChair : BaseMountable
{
	public override float GetComfort()
	{
		return 1f;
	}
}


using UnityEngine;

public class BaseVehicleMountPoint : BaseMountable
{
	[Tooltip("Only Set this if you definitely need a VehicleFixedUpdate tick on the seat for some reason")]
	[Header("BaseVehicleMountPoint")]
	public bool RequiresVehicleFixedUpdateOnSeat;

	public override bool DirectlyMountable()
	{
		return false;
	}

	public override BaseVehicle VehicleParent()
	{
		BaseVehicle baseVehicle = GetParentEntity() as BaseVehicle;
		while ((Object)(object)baseVehicle != (Object)null && !baseVehicle.IsVehicleRoot())
		{
			BaseVehicle baseVehicle2 = baseVehicle.GetParentEntity() as BaseVehicle;
			if ((Object)(object)baseVehicle2 == (Object)null)
			{
				return baseVehicle;
			}
			baseVehicle = baseVehicle2;
		}
		return baseVehicle;
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle == (Object)null)
		{
			info = default(WaterLevel.WaterInfo);
			return 0f;
		}
		return baseVehicle.WaterFactorForPlayer(player, out info);
	}

	public override float AirFactor()
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle == (Object)null)
		{
			return 0f;
		}
		return baseVehicle.AirFactor();
	}
}


using UnityEngine;

public class BaseVehicleSeat : BaseVehicleMountPoint
{
	[Header("Vehicle Seat")]
	public float mountedAnimationSpeed;

	public bool sendClientInputToVehicleParent;

	public bool forcePlayerModelUpdate;

	public bool giveCrosshair;

	public bool canTeamInteract = true;

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.ScaleDamageForPlayer(player, info);
		}
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.MounteeTookDamage(mountee, info);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			baseVehicle.PlayerServerInput(inputState, player);
		}
		base.PlayerServerInput(inputState, player);
	}

	public override void LightToggle(BasePlayer player)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.LightToggle(player);
		}
	}

	public override void SwitchParent(BaseEntity ent)
	{
	}

	public override Vector3 GetMountRagdollVelocity(BasePlayer player)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			return baseVehicle.GetMountRagdollVelocity(player);
		}
		return base.GetMountRagdollVelocity(player);
	}
}


using System;
using UnityEngine;

public class BasicCar : BaseVehicle
{
	[Serializable]
	public class VehicleWheel
	{
		public Transform shock;

		public WheelCollider wheelCollider;

		public Transform wheel;

		public Transform axle;

		public bool steerWheel;

		public bool brakeWheel = true;

		public bool powerWheel = true;
	}

	public VehicleWheel[] wheels;

	public float brakePedal;

	public float gasPedal;

	public float steering;

	public Transform centerOfMass;

	public Transform steeringWheel;

	public float motorForceConstant = 150f;

	public float brakeForceConstant = 500f;

	public float GasLerpTime = 20f;

	public float SteeringLerpTime = 20f;

	public Transform driverEye;

	public GameObjectRef chairRef;

	public Transform chairAnchorTest;

	public SoundPlayer idleLoopPlayer;

	public Transform engineOffset;

	public SoundDefinition engineSoundDef;

	private static bool chairtest;

	public float throttle;

	public float brake;

	public bool lightsOn = true;

	public override float MaxVelocity()
	{
		return 50f;
	}

	public override Vector3 EyePositionForPlayer(BasePlayer player, Quaternion viewRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (PlayerIsMounted(player))
		{
			return ((Component)driverEye).transform.position;
		}
		return Vector3.zero;
	}

	public override void ServerInit()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient)
		{
			base.ServerInit();
			rigidBody = ((Component)this).GetComponent<Rigidbody>();
			rigidBody.centerOfMass = centerOfMass.localPosition;
			rigidBody.isKinematic = false;
			if (chairtest)
			{
				SpawnChairTest();
			}
		}
	}

	public void SpawnChairTest()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(chairRef.resourcePath, ((Component)chairAnchorTest).transform.localPosition);
		baseEntity.Spawn();
		DestroyOnGroundMissing component = ((Component)baseEntity).GetComponent<DestroyOnGroundMissing>();
		if ((Object)(object)component != (Object)null)
		{
			((Behaviour)component).enabled = false;
		}
		MeshCollider component2 = ((Component)baseEntity).GetComponent<MeshCollider>();
		if (Object.op_Implicit((Object)(object)component2))
		{
			component2.convex = true;
		}
		baseEntity.SetParent(this);
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("BasicCar.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (!HasDriver())
			{
				NoDriverInput();
			}
			ConvertInputToThrottle();
			DoSteering();
			ApplyForceAtWheels();
			SetFlag(Flags.Reserved1, HasDriver());
			SetFlag(Flags.Reserved2, HasDriver() && lightsOn);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void DoSteering()
	{
		VehicleWheel[] array = wheels;
		foreach (VehicleWheel vehicleWheel in array)
		{
			if (vehicleWheel.steerWheel)
			{
				vehicleWheel.wheelCollider.steerAngle = steering;
			}
		}
		SetFlag(Flags.Reserved4, steering < -2f);
		SetFlag(Flags.Reserved5, steering > 2f);
	}

	public void ConvertInputToThrottle()
	{
	}

	public void ApplyForceAtWheels()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		Vector3 velocity = rigidBody.velocity;
		float num = ((Vector3)(ref velocity)).magnitude * Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward);
		float num2 = brakePedal;
		float num3 = gasPedal;
		if (num > 0f && num3 < 0f)
		{
			num2 = 100f;
		}
		else if (num < 0f && num3 > 0f)
		{
			num2 = 100f;
		}
		VehicleWheel[] array = wheels;
		foreach (VehicleWheel vehicleWheel in array)
		{
			if (vehicleWheel.wheelCollider.isGrounded)
			{
				if (vehicleWheel.powerWheel)
				{
					vehicleWheel.wheelCollider.motorTorque = num3 * motorForceConstant;
				}
				if (vehicleWheel.brakeWheel)
				{
					vehicleWheel.wheelCollider.brakeTorque = num2 * brakeForceConstant;
				}
			}
		}
		SetFlag(Flags.Reserved3, num2 >= 100f && AnyMounted());
	}

	public void NoDriverInput()
	{
		if (chairtest)
		{
			gasPedal = Mathf.Sin(Time.time) * 50f;
			return;
		}
		gasPedal = 0f;
		brakePedal = Mathf.Lerp(brakePedal, 100f, Time.deltaTime * GasLerpTime / 5f);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			DriverInput(inputState, player);
		}
	}

	public void DriverInput(InputState inputState, BasePlayer player)
	{
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			gasPedal = 100f;
			brakePedal = 0f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			gasPedal = -30f;
			brakePedal = 0f;
		}
		else
		{
			gasPedal = 0f;
			brakePedal = 30f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			steering = -60f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			steering = 60f;
		}
		else
		{
			steering = 0f;
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			lightsOn = !lightsOn;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class VehicleWheel
{
	public Transform shock;

	public WheelCollider wheelCollider;

	public Transform wheel;

	public Transform axle;

	public bool steerWheel;

	public bool brakeWheel = true;

	public bool powerWheel = true;
}


using UnityEngine;

public class BicycleAudio : BikeVehicleAudio
{
	[Header("Bicycle")]
	[SerializeField]
	private SoundDefinition pedalActiveSoundDef;

	[SerializeField]
	private SoundDefinition pedalCoastSoundDef;

	[SerializeField]
	private SoundDefinition pedalStartDef;

	[SerializeField]
	private SoundDefinition pedalStopDef;

	[SerializeField]
	private SoundDefinition bellSoundDef;

	[SerializeField]
	private AnimationCurve pedalGainCurve;

	[SerializeField]
	private AnimationCurve pedalPitchCurve;

	[SerializeField]
	private SlicedGranularAudioClip pedalClicks;

	[SerializeField]
	private AnimationCurve pedalClickFrequencyCurve;
}


using System;
using UnityEngine;

public class BikeChassisVisuals : VehicleChassisVisuals<Bike>, IClientComponent
{
	[Serializable]
	private class SuspensionSettings
	{
		public bool enabled;

		public Transform front;

		public float frontMinZ = 0.3f;

		public float frontMaxZ = 0.55f;

		public Transform rearTop;

		public Transform rearBottom;

		public Transform rearSwingArm;

		public float swingArmMinAngle = 5f;

		public float swingArmMaxAngle = 25f;
	}

	[Serializable]
	private class PedalBikeSettings
	{
		public bool enabled;

		public Transform axle;

		public float ratio = 0.5f;

		public Transform left;

		public Transform right;

		public Transform[] clockwiseCogs;

		public Transform[] anticlockwiseCogs;

		public float cogRatio = 1f;
	}

	[Serializable]
	private class KickstandSettiongs
	{
		public bool enabled;

		public Transform pivot;

		public Transform spring;

		public Transform springTarget;

		public float kickstandZ;

		public float upX = 180f;

		public float downX = 80f;
	}

	[Serializable]
	private class ChainRenderer
	{
		public Renderer renderer;

		public int materialIndex;
	}

	[SerializeField]
	private SuspensionSettings suspension;

	[SerializeField]
	private PedalBikeSettings pedals;

	[SerializeField]
	private KickstandSettiongs kickstand;

	[SerializeField]
	private BikeVehicleAudio audioScript;

	[SerializeField]
	private ChainRenderer[] chainRenderers;

	[SerializeField]
	private float chainSpeedMultiplier = 1f;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private float minGroundFXSpeed = 3f;
}


using System;
using UnityEngine;

[Serializable]
private class SuspensionSettings
{
	public bool enabled;

	public Transform front;

	public float frontMinZ = 0.3f;

	public float frontMaxZ = 0.55f;

	public Transform rearTop;

	public Transform rearBottom;

	public Transform rearSwingArm;

	public float swingArmMinAngle = 5f;

	public float swingArmMaxAngle = 25f;
}


using System;
using UnityEngine;

[Serializable]
private class PedalBikeSettings
{
	public bool enabled;

	public Transform axle;

	public float ratio = 0.5f;

	public Transform left;

	public Transform right;

	public Transform[] clockwiseCogs;

	public Transform[] anticlockwiseCogs;

	public float cogRatio = 1f;
}


using System;
using UnityEngine;

[Serializable]
private class KickstandSettiongs
{
	public bool enabled;

	public Transform pivot;

	public Transform spring;

	public Transform springTarget;

	public float kickstandZ;

	public float upX = 180f;

	public float downX = 80f;
}


using System;
using UnityEngine;

[Serializable]
private class ChainRenderer
{
	public Renderer renderer;

	public int materialIndex;
}


using UnityEngine;

public class BikeDriverSeat : BikeSeat
{
	[SerializeField]
	private Vector3 sprintPosOffset;
}


using UnityEngine;

public class BikeSeat : MouseSteerableSeat
{
	[SerializeField]
	private Transform eyePosRef;
}


using UnityEngine;

public class BikeVehicleAudio : GroundVehicleAudio
{
	[SerializeField]
	[Header("Engine")]
	private EngineAudioSet engineAudioSet;

	[Header("Suspension")]
	[SerializeField]
	private SoundDefinition suspensionDef;

	[SerializeField]
	private float suspensionMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionMinTimeBetweenSounds = 0.25f;

	[Header("Tires")]
	[SerializeField]
	private SoundDefinition tireDirtSoundDef;

	[SerializeField]
	private SoundDefinition tireGrassSoundDef;

	[SerializeField]
	private SoundDefinition tireSnowSoundDef;

	[SerializeField]
	private SoundDefinition tireWaterSoundDef;

	[SerializeField]
	private AnimationCurve tireGainCurve;

	[SerializeField]
	[Header("Skid")]
	private SoundDefinition skidSoundLoop;

	[SerializeField]
	private SoundDefinition skidSoundDirtLoop;

	[SerializeField]
	private SoundDefinition skidSoundSnowLoop;

	[SerializeField]
	private float skidMinSlip = 10f;

	[SerializeField]
	private float skidMaxSlip = 25f;
}


public class MotorbikeAudio : BikeVehicleAudio
{
}


using System;
using UnityEngine;

public class SidecarBikeChassisVisuals : BikeChassisVisuals
{
	[Serializable]
	private class SidecarSuspensionSettings
	{
		public Transform sidecarVisualHinge;

		public Transform sidecarTop;

		public Transform sidecarBottom;

		public Transform sidecarSwingArm;

		public float scSwingArmMinAngle = -10f;

		public float scSwingArmMaxAngle = 10f;
	}

	[SerializeField]
	private SidecarSuspensionSettings sidecarSuspension;
}


using System;
using UnityEngine;

[Serializable]
private class SidecarSuspensionSettings
{
	public Transform sidecarVisualHinge;

	public Transform sidecarTop;

	public Transform sidecarBottom;

	public Transform sidecarSwingArm;

	public float scSwingArmMinAngle = -10f;

	public float scSwingArmMaxAngle = 10f;
}


