using UnityEngine;

public class StaticMissionItemDispenser : StorageContainer
{
	public override void ServerInit()
	{
		base.ServerInit();
		if (base.inventory != null)
		{
			base.inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (base.CanBeLooted(player))
		{
			return HasValidMission(player);
		}
		return false;
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		BaseMission.MissionInstance activeMissionInstance = player.GetActiveMissionInstance();
		if (activeMissionInstance != null)
		{
			for (int i = 0; i < activeMissionInstance.objectiveStatuses.Length; i++)
			{
				if (activeMissionInstance.objectiveStatuses[i].started && activeMissionInstance.GetMission().objectives[i].objective is MissionObjective_AcquireItem missionObjective_AcquireItem)
				{
					base.inventory.AddItem(missionObjective_AcquireItem.targetItem, missionObjective_AcquireItem.targetItemAmount, 0uL);
				}
			}
		}
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.inventory.Clear();
		base.PlayerStoppedLooting(player);
	}

	private bool HasValidMission(BasePlayer player)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		BaseMission.MissionInstance activeMissionInstance = player.GetActiveMissionInstance();
		if (activeMissionInstance != null)
		{
			for (int i = 0; i < activeMissionInstance.objectiveStatuses.Length; i++)
			{
				if (!activeMissionInstance.objectiveStatuses[i].started || activeMissionInstance.objectiveStatuses[i].completed || !(activeMissionInstance.GetMission().objectives[i].objective is MissionObjective_AcquireItem missionObjective_AcquireItem))
				{
					continue;
				}
				if (!string.IsNullOrEmpty(missionObjective_AcquireItem.requireProximityToPosition) && base.isServer)
				{
					if (!activeMissionInstance.missionPoints.ContainsKey(missionObjective_AcquireItem.requireProximityToPosition))
					{
						return false;
					}
					if (Vector3.Distance(activeMissionInstance.missionPoints[missionObjective_AcquireItem.requireProximityToPosition], ((Component)this).transform.position) > 3f)
					{
						return false;
					}
				}
				return true;
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class StaticRespawnArea : SleepingBag
{
	public Transform[] spawnAreas;

	public bool allowHostileSpawns;

	public bool requireAuth;

	[NonSerialized]
	private HashSet<ulong> authorizedUsers = new HashSet<ulong>();

	public static HashSet<StaticRespawnArea> staticRespawnAreas = new HashSet<StaticRespawnArea>();

	public override void ServerInit()
	{
		base.ServerInit();
		staticRespawnAreas.Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		staticRespawnAreas.Remove(this);
	}

	public bool IsAuthed(ulong playerID)
	{
		if (!requireAuth)
		{
			return true;
		}
		return authorizedUsers.Contains(playerID);
	}

	public void Authorize(ulong playerID)
	{
		authorizedUsers.Add(playerID);
	}

	public void Deauthorize(ulong playerID)
	{
		authorizedUsers.Remove(playerID);
	}

	public override bool ValidForPlayer(ulong playerID, bool ignoreTimers)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(playerID);
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
		{
			return false;
		}
		if (ignoreTimers || allowHostileSpawns)
		{
			return true;
		}
		return basePlayer.GetHostileDuration() <= 0f;
	}

	public override void GetSpawnPos(out Vector3 pos, out Quaternion rot)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		Transform val = spawnAreas[Random.Range(0, spawnAreas.Length)];
		pos = ((Component)val).transform.position + spawnOffset;
		Quaternion rotation = ((Component)val).transform.rotation;
		rot = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
	}

	public override void SetUnlockTime(float newTime)
	{
		unlockTime = 0f;
	}

	public override float GetUnlockSeconds(ulong playerID)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(playerID);
		if ((Object)(object)basePlayer == (Object)null || allowHostileSpawns)
		{
			return base.GetUnlockSeconds(playerID);
		}
		return Mathf.Max(basePlayer.GetHostileDuration(), base.GetUnlockSeconds(playerID));
	}

	public override void Save(SaveInfo info)
	{
		if (info.forDisk)
		{
			info.msg.staticRespawn = Pool.Get<StaticRespawnAreaData>();
			info.msg.staticRespawn.authorizedUsers = Pool.Get<List<ulong>>();
			info.msg.staticRespawn.authorizedUsers.AddRange(authorizedUsers);
		}
		base.Save(info);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk || info.msg.staticRespawn == null || info.msg.staticRespawn.authorizedUsers == null)
		{
			return;
		}
		authorizedUsers.Clear();
		foreach (ulong authorizedUser in info.msg.staticRespawn.authorizedUsers)
		{
			authorizedUsers.Add(authorizedUser);
		}
	}
}


using System;
using ConVar;
using Oxide.Core;
using Rust;
using UnityEngine;

public class SupplyDrop : LootContainer
{
	public const Flags FlagNightLight = Flags.Reserved1;

	private const Flags ShowParachute = Flags.Reserved2;

	public GameObject ParachuteRoot;

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SetFlag(Flags.Reserved2, b: true);
		}
		isLootable = false;
		((FacepunchBehaviour)this).Invoke((Action)MakeLootable, 300f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckNightLight, 0f, 30f);
	}

	public void RemoveParachute()
	{
		SetFlag(Flags.Reserved2, b: false);
	}

	public void MakeLootable()
	{
		isLootable = true;
	}

	private void OnCollisionEnter(Collision collision)
	{
		bool flag = ((1 << ((Component)collision.collider).gameObject.layer) & 0x40A10111) > 0;
		if (((1 << ((Component)collision.collider).gameObject.layer) & 0x8000000) > 0 && collision.GetEntity() is Tugboat)
		{
			flag = true;
		}
		if (flag)
		{
			RemoveParachute();
			MakeLootable();
		}
		Interface.CallHook("OnSupplyDropLanded", (object)this);
	}

	public void CheckNightLight()
	{
		SetFlag(Flags.Reserved1, Env.time > 20f || Env.time < 7f);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if ((Object)(object)ParachuteRoot != (Object)null)
		{
			ParachuteRoot.SetActive(next.HasFlag(Flags.Reserved2));
		}
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class SupplySignal : TimedExplosive
{
	public GameObjectRef smokeEffectPrefab;

	public GameObjectRef EntityToCreate;

	[NonSerialized]
	public GameObject smokeEffect;

	public override void Explode()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(Random.Range(-20f, 20f), 0f, Random.Range(-20f, 20f));
			((Component)baseEntity).SendMessage("InitDropPosition", (object)(((Component)this).transform.position + val), (SendMessageOptions)1);
			baseEntity.Spawn();
			Interface.CallHook("OnCargoPlaneSignaled", (object)baseEntity, (object)this);
		}
		((FacepunchBehaviour)this).Invoke((Action)FinishUp, 210f);
		SetFlag(Flags.On, b: true);
		SendNetworkUpdateImmediate();
	}

	public void FinishUp()
	{
		Kill();
	}
}


using UnityEngine;

public class TorpedoServerProjectile : ServerProjectile
{
	[SerializeField]
	[Tooltip("Make sure to leave some allowance for waves, which affect the true depth.")]
	private float minWaterDepth = 0.5f;

	[SerializeField]
	private float shallowWaterInaccuracy;

	[SerializeField]
	private float deepWaterInaccuracy;

	[SerializeField]
	private float shallowWaterCutoff = 2f;

	public override bool HasRangeLimit => false;

	protected override int mask => 1237003009;

	public override bool DoMovement()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!base.DoMovement())
		{
			return false;
		}
		float num = WaterLevel.GetWaterInfo(((Component)this).transform.position, waves: true, volumes: false).surfaceLevel - ((Component)this).transform.position.y;
		if (num < -1f)
		{
			gravityModifier = 1f;
		}
		else if (num <= minWaterDepth)
		{
			Vector3 currentVelocity = base.CurrentVelocity;
			currentVelocity.y = 0f;
			base.CurrentVelocity = currentVelocity;
			gravityModifier = 0.1f;
		}
		else if (num > minWaterDepth + 0.3f && num <= minWaterDepth + 0.7f)
		{
			gravityModifier = -0.1f;
		}
		else
		{
			gravityModifier = Mathf.Clamp(base.CurrentVelocity.y, -0.1f, 0.1f);
		}
		return true;
	}

	public override void InitializeVelocity(Vector3 overrideVel)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.InitializeVelocity(overrideVel);
		float num = WaterLevel.GetWaterInfo(((Component)this).transform.position, waves: true, volumes: false).surfaceLevel - ((Component)this).transform.position.y;
		float num2 = Mathf.InverseLerp(shallowWaterCutoff, shallowWaterCutoff + 2f, num);
		float num3 = Mathf.Lerp(shallowWaterInaccuracy, deepWaterInaccuracy, num2);
		initialVelocity = Vector3Ex.GetWithInaccuracy(initialVelocity, num3);
		base.CurrentVelocity = initialVelocity;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TrainSignal : BaseEntity
{
	public enum LightState
	{
		None,
		Green,
		Yellow,
		Red
	}

	private class SplineSection
	{
		public readonly TrainTrackSpline spline;

		public readonly float startDist;

		public readonly float endDist;

		public SplineSection(TrainTrackSpline spline, float startDist, float endDist)
		{
			this.spline = spline;
			this.startDist = startDist;
			this.endDist = endDist;
		}
	}

	[SerializeField]
	private bool testFX;

	[SerializeField]
	private VehicleLight redLight;

	[SerializeField]
	private VehicleLight yellowLight;

	[SerializeField]
	private VehicleLight greenLight;

	private const Flags Flag_Red = Flags.Reserved1;

	private const Flags Flag_Yellow = Flags.Reserved2;

	private const Flags Flag_Green = Flags.Reserved3;

	private LightState lightState;

	[NonSerialized]
	public TrainSignal nextSignal;

	private TrainTrackSpline ourSpline;

	private float ourSplineDist;

	private readonly List<SplineSection> ourSplines = new List<SplineSection>();

	private LightState prevTargetLightState;

	public float SplineDist => ourSplineDist;

	public bool HasNextSignal => (Object)(object)nextSignal != (Object)null;

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isClient)
		{
			if ((next & Flags.Reserved1) == Flags.Reserved1)
			{
				SetLightState(LightState.Red);
			}
			else if ((next & Flags.Reserved2) == Flags.Reserved2)
			{
				SetLightState(LightState.Yellow);
			}
			else if ((next & Flags.Reserved3) == Flags.Reserved3)
			{
				SetLightState(LightState.Green);
			}
		}
	}

	private void SetLightState(LightState newState)
	{
		if (lightState != newState)
		{
			lightState = newState;
			if (base.isServer)
			{
				SetFlag(Flags.Reserved1, newState == LightState.Red, recursive: false, networkupdate: false);
				SetFlag(Flags.Reserved2, newState == LightState.Yellow, recursive: false, networkupdate: false);
				SetFlag(Flags.Reserved3, newState == LightState.Green, recursive: false, networkupdate: false);
				SendNetworkUpdate_Flags();
			}
		}
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (TrainTrackSpline.TryFindTrackNear(((Component)this).transform.position, 10f, out ourSpline, out ourSplineDist))
		{
			ourSpline.RegisterSignal(this);
			((FacepunchBehaviour)this).Invoke((Action)SetUpSignal, 0f);
		}
		else
		{
			Debug.LogWarning((object)"TrainSignal found no nearby track. Disabling lights.");
			SetLightState(LightState.None);
		}
	}

	private void SetUpSignal()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ourSpline != (Object)null)
		{
			TrainTrackSpline trainTrackSpline = ourSpline;
			float prevSplineDist = ourSplineDist;
			Vector3 askerForward = -((Component)this).transform.forward;
			TrainTrackSpline.MoveRequest.SplineAction onSpline = ProcessSplineSection;
			TrainTrackSpline.MoveResult moveResult = trainTrackSpline.MoveAlongSpline(prevSplineDist, askerForward, 500f, default(TrainTrackSpline.TrackRequest), onSpline);
			if (!testFX)
			{
				RefreshLightState();
				((FacepunchBehaviour)this).InvokeRandomized((Action)RefreshLightState, 1f, 1f, 0.1f);
			}
			Debug.DrawLine(((Component)this).transform.position, moveResult.spline.GetPosition(moveResult.distAlongSpline), IsForward() ? Color.blue : Color.cyan, 1000f);
		}
		if (testFX)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)TestLights, 1f, 1f);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (ourSplines.Count > 0)
		{
			ourSplines[0].spline.DeregisterSignal(this);
		}
	}

	public void RefreshLightState()
	{
		LightState lightState = (HasOccupant() ? LightState.Red : ((!HasNextSignal) ? LightState.Green : ((nextSignal.lightState != LightState.Red) ? LightState.Green : LightState.Yellow)));
		if (lightState == LightState.Green)
		{
			if (prevTargetLightState == LightState.Green)
			{
				SetLightState(lightState);
			}
		}
		else
		{
			SetLightState(lightState);
		}
		prevTargetLightState = lightState;
	}

	private bool HasOccupant()
	{
		foreach (SplineSection ourSpline in ourSplines)
		{
			foreach (TrainTrackSpline.ITrainTrackUser trackUser in ourSpline.spline.trackUsers)
			{
				float frontWheelSplineDist = trackUser.FrontWheelSplineDist;
				if (frontWheelSplineDist >= ourSpline.startDist && frontWheelSplineDist <= ourSpline.endDist)
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool IsForward()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return ourSpline.IsForward(-((Component)this).transform.forward, ourSplineDist);
	}

	private void TestLights()
	{
		SetLightState((LightState)Random.Range(1, 4));
	}

	private TrainTrackSpline.MoveResult ProcessSplineSection(TrainTrackSpline.MoveResult result, TrainTrackSpline.MoveRequest request, TrainTrackSpline spline, float splineLength)
	{
		float num = request.distAlongSpline;
		float num2 = result.distAlongSpline;
		bool flag = true;
		float num3 = num;
		if (num2 < num)
		{
			flag = false;
			num = num2;
			num2 = num3;
		}
		TrainSignal trainSignal = null;
		float num4 = float.MaxValue;
		foreach (TrainSignal signal in spline.signals)
		{
			if (!((Object)(object)signal == (Object)(object)this) && signal.IsValid() && signal.IsForward() == flag && signal.SplineDist >= num && signal.SplineDist <= num2)
			{
				float num5 = Mathf.Abs(signal.SplineDist - num3);
				if (result.totalDistMoved + num5 >= 5f && num5 < num4)
				{
					trainSignal = signal;
					num4 = num5;
				}
			}
		}
		if ((Object)(object)trainSignal != (Object)null)
		{
			result.distAlongSpline = trainSignal.SplineDist;
			if ((Object)(object)trainSignal != (Object)null)
			{
				nextSignal = trainSignal;
			}
		}
		float num6 = Mathf.Clamp(request.distAlongSpline, 0f, splineLength);
		float num7 = Mathf.Clamp(result.distAlongSpline, 0f, splineLength);
		if (num7 < num6)
		{
			SplineSection item = new SplineSection(spline, num7, num6);
			ourSplines.Add(item);
		}
		else if (num7 > num6)
		{
			SplineSection item2 = new SplineSection(spline, num6, num7);
			ourSplines.Add(item2);
		}
		return result;
	}
}


public enum LightState
{
	None,
	Green,
	Yellow,
	Red
}


private class SplineSection
{
	public readonly TrainTrackSpline spline;

	public readonly float startDist;

	public readonly float endDist;

	public SplineSection(TrainTrackSpline spline, float startDist, float endDist)
	{
		this.spline = spline;
		this.startDist = startDist;
		this.endDist = endDist;
	}
}


using UnityEngine;

public class TravellingVendorSounds : MonoBehaviour
{
	[SerializeField]
	[Header("Engine")]
	private EngineAudioSet EngineAudioSet;

	[SerializeField]
	private BlendedLoopEngineSound blendedEngineLoops;

	[SerializeField]
	private float engineRPMThrottleWeight = 0.75f;

	[SerializeField]
	private float engineRPMThrottleSpeedWeight = 0.25f;

	[SerializeField]
	private float engineRPMSpeedWeight = 0.25f;

	[SerializeField]
	private float wheelRatioMultiplier = 600f;

	[SerializeField]
	private SoundDefinition missGearSoundDef;

	[SerializeField]
	private float gearMissCooldown = 5f;

	[SerializeField]
	[Header("Suspension")]
	private SoundDefinition suspensionDef;

	[SerializeField]
	private float suspensionMinTimeBetweenSounds = 0.25f;

	[SerializeField]
	private float suspensionUpAngleDeltaThreshold = 0.05f;

	[SerializeField]
	private AnimationCurve suspensionDeltaSpeedGain;

	[SerializeField]
	private AnimationCurve suspensionUpAngleDeltaGain;

	[Header("Tires")]
	[SerializeField]
	private SoundDefinition tireDirtSoundDef;

	[SerializeField]
	private SoundDefinition tireGrassSoundDef;

	[SerializeField]
	private SoundDefinition tireSnowSoundDef;

	[SerializeField]
	private SoundDefinition tireWaterSoundDef;

	[SerializeField]
	private AnimationCurve tireGainCurve;

	[SerializeField]
	[Header("Movement")]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private AnimationCurve movementLoopGainCurve;

	[SerializeField]
	[Header("Brakes")]
	private SoundDefinition brakeLoopDef;

	[SerializeField]
	private SoundDefinition brakeHissDef;

	[SerializeField]
	private float brakeHissCooldown = 2f;

	[SerializeField]
	[Header("Misc")]
	private SoundDefinition angryHornSoundDef;

	[SerializeField]
	private SoundDefinition musicLoopSoundDef;
}


using UnityEngine;

public class TravellingVendorVisuals : VehicleChassisVisuals<TravellingVendor>, IClientComponent
{
	[Header("References")]
	public Transform frontAxle;

	public ModularCarChassisVisuals.Steering steering;

	public ModularCarChassisVisuals.LookAtTarget transmission;

	[Header("Settings")]
	public float wheelTurnLerpSpeed = 5f;
}


using System;

public class TutorialContainer : StorageContainer
{
	private bool acceptingItems;

	public void LoadStorage(ItemAmount[] toLoad)
	{
		base.inventory.Clear();
		acceptingItems = true;
		foreach (ItemAmount itemAmount in toLoad)
		{
			base.inventory.GiveItem(ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL));
		}
		acceptingItems = false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		return acceptingItems;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class VendingMachineMapMarker : MapMarker
{
	public string markerShopName;

	public VendingMachine server_vendingMachine;

	public VendingMachine client_vendingMachine;

	[NonSerialized]
	public NetworkableId client_vendingMachineNetworkID;

	public GameObjectRef clusterMarkerObj;

	private UIMapVendingMachineMarker myUIMarker;

	private RectTransform markerTransform;

	public void SetVendingMachine(VendingMachine vm, string shopName)
	{
		_ = (Object)(object)vm == (Object)null;
		server_vendingMachine = vm;
		markerShopName = shopName;
		if (!((FacepunchBehaviour)this).IsInvoking((Action)TryUpdatePosition))
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)TryUpdatePosition, 30f, 30f, 10f);
		}
	}

	public void TryUpdatePosition()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)server_vendingMachine != (Object)null && (Object)(object)server_vendingMachine.GetParentEntity() != (Object)null)
		{
			((Component)this).transform.position = ((Component)server_vendingMachine).transform.position;
			try
			{
				syncPosition = true;
				NetworkPositionTick();
			}
			finally
			{
				syncPosition = false;
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.vendingMachine = Pool.Get<VendingMachine>();
		info.msg.vendingMachine.shopName = markerShopName;
		if ((Object)(object)server_vendingMachine != (Object)null)
		{
			if (server_vendingMachine is NPCVendingMachine { IsLocalized: not false } nPCVendingMachine)
			{
				info.msg.vendingMachine.translationToken = nPCVendingMachine.GetTranslationToken();
			}
			info.msg.vendingMachine.networkID = server_vendingMachine.net.ID;
			info.msg.vendingMachine.sellOrderContainer = server_vendingMachine.sellOrders.Copy();
			info.msg.vendingMachine.sellOrderContainer.sellOrders.RemoveAll(delegate(SellOrder x)
			{
				//IL_001d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0030: Unknown result type (might be due to invalid IL or missing references)
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(x.itemToSellID);
				return !ItemManager.FindItemDefinition(x.currencyID).IsAllowed(server_vendingMachine.CurrentEraRestriction) || !itemDefinition.IsAllowed(server_vendingMachine.CurrentEraRestriction);
			});
		}
	}

	public override AppMarker GetAppMarkerData()
	{
		AppMarker appMarkerData = base.GetAppMarkerData();
		appMarkerData.name = markerShopName ?? "";
		appMarkerData.outOfStock = !HasFlag(Flags.Busy);
		if ((Object)(object)server_vendingMachine != (Object)null)
		{
			appMarkerData.sellOrders = Pool.Get<List<SellOrder>>();
			foreach (SellOrder sellOrder in server_vendingMachine.sellOrders.sellOrders)
			{
				if (server_vendingMachine.CanSellOrBuyItem(sellOrder.itemToSellID, sellOrder.currencyID))
				{
					SellOrder val = Pool.Get<SellOrder>();
					val.itemId = sellOrder.itemToSellID;
					val.quantity = sellOrder.itemToSellAmount;
					val.currencyId = sellOrder.currencyID;
					val.costPerItem = sellOrder.currencyAmountPerItem;
					val.amountInStock = sellOrder.inStock;
					val.itemIsBlueprint = sellOrder.itemToSellIsBP;
					val.currencyIsBlueprint = sellOrder.currencyIsBP;
					val.itemCondition = sellOrder.itemCondition;
					val.itemConditionMax = sellOrder.itemConditionMax;
					val.priceMultiplier = sellOrder.priceMultiplier;
					appMarkerData.sellOrders.Add(val);
				}
			}
		}
		return appMarkerData;
	}
}


using System;
using ProtoBuf;
using UnityEngine;

public class VisualStorageContainer : LootContainer
{
	[Serializable]
	public class DisplayModel
	{
		public GameObject displayModel;

		public ItemDefinition def;

		public int slot;
	}

	public VisualStorageContainerNode[] displayNodes;

	public DisplayModel[] displayModels;

	public Transform nodeParent;

	public GameObject defaultDisplayModel;

	public override void ServerInit()
	{
		base.ServerInit();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
	}

	public override void PopulateLoot()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		base.PopulateLoot();
		for (int i = 0; i < inventorySlots; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			DroppedItem component = ((Component)slot.Drop(((Component)displayNodes[i]).transform.position + new Vector3(0f, 0.25f, 0f), Vector3.zero, ((Component)displayNodes[i]).transform.rotation)).GetComponent<DroppedItem>();
			if (Object.op_Implicit((Object)(object)component))
			{
				ReceiveCollisionMessages(b: false);
				((FacepunchBehaviour)this).CancelInvoke((Action)component.IdleDestroy);
				Rigidbody componentInChildren = ((Component)component).GetComponentInChildren<Rigidbody>();
				if (Object.op_Implicit((Object)(object)componentInChildren))
				{
					componentInChildren.constraints = (RigidbodyConstraints)10;
				}
			}
		}
	}

	public void ClearRigidBodies()
	{
		if (displayModels == null)
		{
			return;
		}
		DisplayModel[] array = displayModels;
		foreach (DisplayModel displayModel in array)
		{
			if (displayModel != null)
			{
				Object.Destroy((Object)(object)displayModel.displayModel.GetComponentInChildren<Rigidbody>());
			}
		}
	}

	public void SetItemsVisible(bool vis)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (displayModels == null)
		{
			return;
		}
		DisplayModel[] array = displayModels;
		foreach (DisplayModel displayModel in array)
		{
			if (displayModel != null)
			{
				LODGroup componentInChildren = displayModel.displayModel.GetComponentInChildren<LODGroup>();
				if (Object.op_Implicit((Object)(object)componentInChildren))
				{
					componentInChildren.localReferencePoint = (Vector3)(vis ? Vector3.zero : new Vector3(10000f, 10000f, 10000f));
				}
				else
				{
					Debug.Log((object)("VisualStorageContainer item missing LODGroup" + ((Object)displayModel.displayModel.gameObject).name));
				}
			}
		}
	}

	public void ItemUpdateComplete()
	{
		ClearRigidBodies();
		SetItemsVisible(vis: true);
	}

	public void UpdateVisibleItems(ItemContainer msg)
	{
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < displayModels.Length; i++)
		{
			DisplayModel displayModel = displayModels[i];
			if (displayModel != null)
			{
				Object.Destroy((Object)(object)displayModel.displayModel);
				displayModels[i] = null;
			}
		}
		if (msg == null)
		{
			return;
		}
		foreach (Item content in msg.contents)
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(content.itemid);
			GameObject val = null;
			val = ((itemDefinition.GetWorldModel(content.amount) == null || !itemDefinition.GetWorldModel(content.amount).isValid) ? Object.Instantiate<GameObject>(defaultDisplayModel) : itemDefinition.GetWorldModel(content.amount).Instantiate());
			if (Object.op_Implicit((Object)(object)val))
			{
				val.transform.SetPositionAndRotation(((Component)displayNodes[content.slot]).transform.position + new Vector3(0f, 0.25f, 0f), ((Component)displayNodes[content.slot]).transform.rotation);
				Rigidbody obj = val.AddComponent<Rigidbody>();
				obj.mass = 1f;
				obj.drag = 0.1f;
				obj.angularDrag = 0.1f;
				obj.interpolation = (RigidbodyInterpolation)1;
				obj.constraints = (RigidbodyConstraints)10;
				displayModels[content.slot].displayModel = val;
				displayModels[content.slot].slot = content.slot;
				displayModels[content.slot].def = itemDefinition;
				val.SetActive(true);
			}
		}
		SetItemsVisible(vis: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ItemUpdateComplete);
		((FacepunchBehaviour)this).Invoke((Action)ItemUpdateComplete, 1f);
	}
}


using System;
using UnityEngine;

[Serializable]
public class DisplayModel
{
	public GameObject displayModel;

	public ItemDefinition def;

	public int slot;
}


using UnityEngine;

public class VisualStorageContainerNode : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using UnityEngine;

public class WaterBall : BaseEntity
{
	public ItemDefinition liquidType;

	public int waterAmount;

	public GameObjectRef waterExplosion;

	public Collider waterCollider;

	public Rigidbody myRigidBody;

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)Extinguish, 10f);
	}

	public void Extinguish()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Extinguish);
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public void FixedUpdate()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && (Object)(object)myRigidBody != (Object)null)
		{
			myRigidBody.AddForce(Physics.gravity, (ForceMode)5);
		}
	}

	public static bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount, bool funWater = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanWaterBallSplash", (object)liquidDef, (object)position, (object)radius, (object)amount, (object)funWater);
		if (obj is bool)
		{
			return (bool)obj;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, radius, list, 1220225811, (QueryTriggerInteraction)2);
		int num = 0;
		int num2 = amount;
		bool flag = false;
		while (amount > 0 && num < 3)
		{
			List<ISplashable> list2 = Pool.Get<List<ISplashable>>();
			foreach (BaseEntity item in list)
			{
				if (item.isClient || !(item is ISplashable splashable) || list2.Contains(splashable) || !splashable.WantsSplash(liquidDef, amount))
				{
					continue;
				}
				bool flag2 = true;
				bool flag3 = item is PlanterBox;
				bool flag4 = item is TimedExplosive;
				if (flag3 || flag4)
				{
					Vector3 val = Vector3.zero;
					if (flag3)
					{
						val = Vector3.up;
					}
					if (!GamePhysics.LineOfSight(((Component)item).transform.position + val, position, 2097152))
					{
						flag2 = false;
					}
					if (flag2)
					{
						flag = true;
					}
				}
				if (flag2)
				{
					list2.Add(splashable);
				}
			}
			if (list2.Count == 0)
			{
				break;
			}
			int num3 = Mathf.CeilToInt((float)(amount / list2.Count));
			foreach (ISplashable item2 in list2)
			{
				if (!flag || !(item2 is BasePlayer))
				{
					int num4 = 0;
					BasePlayer basePlayer = item2 as BasePlayer;
					num4 = ((!(basePlayer != null && funWater)) ? item2.DoSplash(liquidDef, Mathf.Min(amount, num3)) : basePlayer.DoSplashFunWater(liquidDef, Mathf.Min(amount, num3)));
					amount -= num4;
					if (amount <= 0)
					{
						break;
					}
				}
			}
			Pool.FreeUnmanaged<ISplashable>(ref list2);
			num++;
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return amount < num2;
	}

	private void OnCollisionEnter(Collision collision)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && !myRigidBody.isKinematic)
		{
			float num = 2.5f;
			Vector3 position = ((Component)this).transform.position;
			float num2 = num * 0.75f;
			if (GamePhysics.Trace(new Ray(position, Vector3.up), 0.05f, out var hitInfo, num2, 1084293377, (QueryTriggerInteraction)0))
			{
				num2 = ((RaycastHit)(ref hitInfo)).distance;
			}
			DoSplash(position + new Vector3(0f, num2, 0f), num, liquidType, waterAmount);
			Effect.server.Run(waterExplosion.resourcePath, position, Vector3.up);
			myRigidBody.isKinematic = true;
			waterCollider.enabled = false;
			((FacepunchBehaviour)this).Invoke((Action)Extinguish, 2f);
		}
	}
}


using UnityEngine;

public class WeaponRackBatchAutoSet : MonoBehaviour
{
	public Transform Anchor;

	public Object MountConfigScript;
}


public static class WeaponRackGhost
{
}


using ProtoBuf;
using Rust;
using UnityEngine;

public class WeaponRackSlot
{
	[InspectorFlags]
	public AmmoTypes AmmoTypes;

	public bool Used { get; private set; }

	public ItemDefinition ItemDef { get; private set; }

	public int ClientItemID { get; private set; }

	public ulong ClientItemSkinID { get; private set; }

	public ItemDefinition AmmoItemDef { get; private set; }

	public int AmmoItemID { get; private set; }

	public int AmmoCount { get; private set; }

	public int AmmoMax { get; private set; }

	public float Condition { get; private set; }

	public int InventoryIndex { get; private set; }

	public int GridSlotIndex { get; private set; }

	public int Rotation { get; private set; }

	public float ReloadTime { get; private set; }

	public void SetUsed(bool flag)
	{
		Used = flag;
	}

	public WeaponRackItem SaveToProto(Item item, WeaponRackItem proto)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Expected I4, but got Unknown
		proto.itemID = item?.info.itemid ?? 0;
		proto.skinid = item?.skin ?? 0;
		proto.inventorySlot = InventoryIndex;
		proto.gridSlotIndex = GridSlotIndex;
		proto.rotation = Rotation;
		proto.ammoCount = AmmoCount;
		proto.ammoMax = AmmoMax;
		proto.ammoID = AmmoItemID;
		proto.condition = Condition;
		proto.ammoTypes = (int)AmmoTypes;
		proto.reloadTime = ReloadTime;
		return proto;
	}

	public void InitFromProto(WeaponRackItem item)
	{
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		ClientItemID = item.itemID;
		ClientItemSkinID = item.skinid;
		ItemDef = ItemManager.FindItemDefinition(ClientItemID);
		InventoryIndex = item.inventorySlot;
		GridSlotIndex = item.gridSlotIndex;
		AmmoCount = item.ammoCount;
		AmmoMax = item.ammoMax;
		AmmoItemID = item.ammoID;
		AmmoItemDef = ((AmmoItemID != 0) ? ItemManager.FindItemDefinition(AmmoItemID) : null);
		Condition = item.condition;
		Rotation = item.rotation;
		AmmoTypes = (AmmoTypes)item.ammoTypes;
		ReloadTime = item.reloadTime;
	}

	public void SetItem(Item item, ItemDefinition updatedItemDef, int gridCellIndex, int rotation)
	{
		InventoryIndex = item.position;
		GridSlotIndex = gridCellIndex;
		Condition = item.conditionNormalized;
		Rotation = rotation;
		SetAmmoDetails(item);
		ItemDef = updatedItemDef;
	}

	public void SetAmmoDetails(Item item)
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		ClearAmmoDetails();
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
			if (!((Object)(object)component == (Object)null))
			{
				AmmoItemDef = component.primaryMagazine.ammoType;
				AmmoItemID = (((Object)(object)AmmoItemDef != (Object)null) ? AmmoItemDef.itemid : 0);
				AmmoCount = component.primaryMagazine.contents;
				AmmoMax = component.primaryMagazine.capacity;
				AmmoTypes = component.primaryMagazine.definition.ammoTypes;
				ReloadTime = component.GetReloadDuration();
			}
		}
	}

	private void ClearAmmoDetails()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		AmmoItemDef = null;
		AmmoTypes = (AmmoTypes)0;
		AmmoItemID = 0;
		AmmoCount = 0;
		AmmoMax = 0;
		ReloadTime = 0f;
	}

	public bool CanBeReloadedAtWeaponRack()
	{
		if ((Object)(object)ItemDef == (Object)null)
		{
			return false;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(ItemDef);
		if ((Object)(object)forItemDef == (Object)null)
		{
			return false;
		}
		return forItemDef.CanReloadOnWeaponRack;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public class WhitelistLootContainer : LootContainer
{
	public static readonly Phrase CantLootToast = new Phrase("whitelistcontainer.noloot", "You are not authorized to access this box");

	[NonSerialized]
	public List<ulong> whitelist = new List<ulong>();

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			return;
		}
		info.msg.whitelist = Pool.Get<Whitelist>();
		info.msg.whitelist.users = Pool.Get<List<ulong>>();
		foreach (ulong item in whitelist)
		{
			info.msg.whitelist.users.Add(item);
		}
	}

	public override void Load(LoadInfo info)
	{
		if (info.fromDisk && info.msg.whitelist != null)
		{
			foreach (ulong user in info.msg.whitelist.users)
			{
				whitelist.Add(user);
			}
		}
		base.Load(info);
	}

	public void MissionSetupPlayer(BasePlayer player)
	{
		AddToWhitelist(player.userID);
	}

	public void AddToWhitelist(ulong userid)
	{
		if (!whitelist.Contains(userid))
		{
			whitelist.Add(userid);
		}
	}

	public void RemoveFromWhitelist(ulong userid)
	{
		if (whitelist.Contains(userid))
		{
			whitelist.Remove(userid);
		}
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		ulong item = player.userID.Get();
		if (!whitelist.Contains(item))
		{
			player.ShowToast(GameTip.Styles.Red_Normal, CantLootToast, false);
			return false;
		}
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Cronos;
using Facepunch;
using Facepunch.Math;
using Newtonsoft.Json;
using ProtoBuf;
using TimeZoneConverter;
using UnityEngine;

public class WipeTimer : BaseEntity
{
	public enum WipeFrequency
	{
		Monthly,
		Weekly,
		BiWeekly
	}

	[ServerVar(Help = "0=sun,1=mon,2=tues,3=wed,4=thur,5=fri,6=sat")]
	public static int wipeDayOfWeek = 4;

	[ServerVar(Help = "Which hour to wipe? 14.5 = 2:30pm")]
	public static float wipeHourOfDay = 19f;

	[ServerVar(Help = "The timezone to use for wipes. Defaults to the server's time zone if not set or invalid. Value should be a TZ identifier as seen here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones")]
	public static string wipeTimezone = "Europe/London";

	[ServerVar(Help = "Unix timestamp (seconds) for the upcoming wipe. Overrides all other convars if set to a time in the future.")]
	public static long wipeUnixTimestampOverride = 0L;

	[ServerVar(Help = "Custom cron expression for the wipe schedule. Overrides all other convars (except wipeUnixTimestampOverride) if set. Uses Cronos as a parser: https://github.com/HangfireIO/Cronos/")]
	public static string wipeCronOverride = "";

	public bool useWipeDayOverride;

	public DayOfWeek wipeDayOfWeekOverride = DayOfWeek.Thursday;

	public WipeFrequency wipeFrequency;

	[ServerVar(Name = "days_to_add_test")]
	public static int daysToAddTest = 0;

	[ServerVar(Name = "hours_to_add_test")]
	public static float hoursToAddTest = 0f;

	public static WipeTimer serverinstance;

	public static WipeTimer clientinstance;

	private string oldTags = "";

	private static string cronExprCacheKey = null;

	private static CronExpression cronExprCache = null;

	private static (WipeFrequency, int, float)? cronCacheKey = null;

	private static string cronCache = null;

	private static string timezoneCacheKey = null;

	private static TimeZoneInfo timezoneCache = null;

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			serverinstance = this;
		}
		if (base.isClient)
		{
			clientinstance = this;
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			serverinstance = null;
		}
		if (base.isClient)
		{
			clientinstance = null;
		}
		base.DestroyShared();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		RecalculateWipeFrequency();
		((FacepunchBehaviour)this).InvokeRepeating((Action)TryAndUpdate, 1f, 4f);
	}

	public void RecalculateWipeFrequency()
	{
		string tags = Server.tags;
		if (tags.Contains("monthly"))
		{
			wipeFrequency = WipeFrequency.Monthly;
		}
		else if (tags.Contains("biweekly"))
		{
			wipeFrequency = WipeFrequency.BiWeekly;
		}
		else if (tags.Contains("weekly"))
		{
			wipeFrequency = WipeFrequency.Weekly;
		}
		else
		{
			wipeFrequency = WipeFrequency.Monthly;
		}
	}

	public void TryAndUpdate()
	{
		if (Server.tags != oldTags)
		{
			RecalculateWipeFrequency();
			oldTags = Server.tags;
		}
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk && info.msg.landmine == null)
		{
			info.msg.landmine = Pool.Get<Landmine>();
			info.msg.landmine.triggeredID = (ulong)GetTicksUntilWipe();
		}
	}

	public TimeSpan GetTimeSpanUntilWipe()
	{
		DateTimeOffset dateTimeOffset = DateTimeOffset.UtcNow.AddDays(daysToAddTest).AddHours(hoursToAddTest);
		return GetWipeTime(dateTimeOffset) - dateTimeOffset;
	}

	public long GetTicksUntilWipe()
	{
		return GetTimeSpanUntilWipe().Ticks;
	}

	[ServerVar]
	public static void PrintWipe(Arg arg)
	{
		if ((Object)(object)serverinstance == (Object)null)
		{
			arg.ReplyWith("WipeTimer not found!");
			return;
		}
		serverinstance.RecalculateWipeFrequency();
		serverinstance.TryAndUpdate();
		TimeZoneInfo timeZone = GetTimeZone();
		string text = default(string);
		string text2 = (TZConvert.TryWindowsToIana(timeZone.Id, ref text) ? text : timeZone.Id);
		DateTimeOffset dateTimeOffset = DateTimeOffset.UtcNow.AddDays(daysToAddTest).AddHours(hoursToAddTest);
		DateTimeOffset wipeTime = serverinstance.GetWipeTime(dateTimeOffset);
		TimeSpan timeSpan = wipeTime - dateTimeOffset;
		string cronString = GetCronString(serverinstance.wipeFrequency, serverinstance.useWipeDayOverride ? ((int)serverinstance.wipeDayOfWeekOverride) : wipeDayOfWeek, wipeHourOfDay);
		CronExpression cronExpression = GetCronExpression(serverinstance.wipeFrequency, serverinstance.useWipeDayOverride ? ((int)serverinstance.wipeDayOfWeekOverride) : wipeDayOfWeek, wipeHourOfDay);
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Frequency: {serverinstance.wipeFrequency}");
		stringBuilder.AppendLine("Timezone: " + timeZone.StandardName + " (ID=" + timeZone.Id + ", IANA=" + text2 + ")");
		stringBuilder.AppendLine($"Wipe day of week: {(DayOfWeek)wipeDayOfWeek}");
		stringBuilder.AppendLine($"Wipe hour: {wipeHourOfDay}");
		stringBuilder.AppendLine($"Test time: {dateTimeOffset:O}");
		stringBuilder.AppendLine($"Wipe time: {wipeTime:O}");
		stringBuilder.AppendLine($"Time until wipe: {timeSpan:g}");
		stringBuilder.AppendLine($"Ticks until wipe: {timeSpan.Ticks}");
		stringBuilder.AppendLine();
		stringBuilder.AppendLine("Cron: " + cronString);
		stringBuilder.AppendLine("Next 10 occurrences:");
		int num = 0;
		foreach (DateTimeOffset item in cronExpression.GetOccurrences(dateTimeOffset, dateTimeOffset.AddYears(2), timeZone, true, false).Take(10))
		{
			stringBuilder.AppendLine($"  {num}. {item:O}");
			num++;
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void PrintTimeZones(Arg arg)
	{
		List<string> systemTzs = (from z in TimeZoneInfo.GetSystemTimeZones()
			select z.Id).ToList();
		IReadOnlyCollection<string> knownWindowsTimeZoneIds = TZConvert.KnownWindowsTimeZoneIds;
		IReadOnlyCollection<string> knownIanaTimeZoneNames = TZConvert.KnownIanaTimeZoneNames;
		arg.ReplyWith(JsonConvert.SerializeObject((object)new
		{
			systemTzs = systemTzs,
			windowsTzs = knownWindowsTimeZoneIds,
			ianaTzs = knownIanaTimeZoneNames
		}));
	}

	public DateTimeOffset GetWipeTime(DateTimeOffset nowTime)
	{
		if (wipeUnixTimestampOverride > 0 && wipeUnixTimestampOverride > Epoch.Current)
		{
			return Epoch.ToDateTime(wipeUnixTimestampOverride);
		}
		try
		{
			return GetCronExpression(wipeFrequency, useWipeDayOverride ? ((int)wipeDayOfWeekOverride) : wipeDayOfWeek, wipeHourOfDay).GetNextOccurrence(nowTime, GetTimeZone(), false) ?? DateTimeOffset.MaxValue;
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			return DateTimeOffset.MaxValue;
		}
	}

	private bool HoursUntilWipe(float hours)
	{
		if (serverinstance.GetTimeSpanUntilWipe().TotalHours < (double)hours)
		{
			return true;
		}
		return false;
	}

	private static CronExpression GetCronExpression(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
	{
		string cronString = GetCronString(frequency, dayOfWeek, hourOfDay);
		if (cronString == cronExprCacheKey && cronExprCache != (CronExpression)null)
		{
			return cronExprCache;
		}
		cronExprCache = CronExpression.Parse(cronString);
		cronExprCacheKey = cronString;
		return cronExprCache;
	}

	private static string GetCronString(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
	{
		if (!string.IsNullOrWhiteSpace(wipeCronOverride))
		{
			return wipeCronOverride;
		}
		(WipeFrequency, int, float) tuple = (frequency, dayOfWeek, hourOfDay);
		(WipeFrequency, int, float) tuple2 = tuple;
		(WipeFrequency, int, float)? tuple3 = cronCacheKey;
		if (tuple3.HasValue)
		{
			(WipeFrequency, int, float) valueOrDefault = tuple3.GetValueOrDefault();
			if (tuple2.Item1 == valueOrDefault.Item1 && tuple2.Item2 == valueOrDefault.Item2 && tuple2.Item3 == valueOrDefault.Item3 && cronCache != null)
			{
				return cronCache;
			}
		}
		cronCache = BuildCronString(frequency, dayOfWeek, hourOfDay);
		cronCacheKey = tuple;
		return cronCache;
	}

	private static string BuildCronString(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
	{
		int num = Mathf.FloorToInt(hourOfDay);
		int num2 = Mathf.FloorToInt((hourOfDay - (float)num) * 60f);
		return frequency switch
		{
			WipeFrequency.Weekly => $"{num2} {num} * * {dayOfWeek}", 
			WipeFrequency.BiWeekly => $"{num2} {num} 1-7,15-21,29-31 * {dayOfWeek}", 
			WipeFrequency.Monthly => $"{num2} {num} * * {dayOfWeek}#1", 
			_ => throw new NotSupportedException($"WipeFrequency {frequency}"), 
		};
	}

	private static TimeZoneInfo GetTimeZone()
	{
		if (string.IsNullOrWhiteSpace(wipeTimezone))
		{
			return TimeZoneInfo.Local;
		}
		if (wipeTimezone == timezoneCacheKey && timezoneCache != null)
		{
			return timezoneCache;
		}
		if (TZConvert.TryGetTimeZoneInfo(wipeTimezone, ref timezoneCache))
		{
			timezoneCacheKey = wipeTimezone;
			return timezoneCache;
		}
		return TimeZoneInfo.Local;
	}
}


public enum WipeFrequency
{
	Monthly,
	Weekly,
	BiWeekly
}


using UnityEngine;
using UnityEngine.UI;

public class WipeTimerScreen : MonoBehaviour
{
	public Text timerText;
}


using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

public abstract class BaseModifiers<T> : EntityComponent<T> where T : BaseCombatEntity
{
	public List<Modifier> All = new List<Modifier>();

	protected Dictionary<Modifier.ModifierType, float> totalValues = new Dictionary<Modifier.ModifierType, float>();

	protected Dictionary<Modifier.ModifierType, float> modifierVariables = new Dictionary<Modifier.ModifierType, float>();

	protected Dictionary<Modifier.ModifierSource, int> sourceCounts = new Dictionary<Modifier.ModifierSource, int>();

	protected T owner;

	protected bool dirty = true;

	protected double timeSinceLastTick;

	protected double lastTickTime;

	public int ActiveModifierCount => All.Count;

	public int ActiveTeaCount
	{
		get
		{
			int num = 0;
			foreach (Modifier item in All)
			{
				if (item != null && item.Source == Modifier.ModifierSource.Tea)
				{
					num++;
				}
			}
			return num;
		}
	}

	public void Add(List<ModifierDefintion> modDefs, float effectScale = 1f, float durationScale = 1f)
	{
		foreach (ModifierDefintion modDef in modDefs)
		{
			if (IsCompatible(modDef.type))
			{
				Add(modDef, effectScale, durationScale);
			}
		}
	}

	protected virtual bool IsCompatible(Modifier.ModifierType modType)
	{
		return true;
	}

	protected void Add(ModifierDefintion def, float effectScale = 1f, float durationScale = 1f)
	{
		Modifier modifier = new Modifier();
		modifier.Init(def.type, def.source, def.value * effectScale, def.duration * durationScale, def.duration * durationScale);
		Add(modifier);
	}

	protected void Add(Modifier modifier)
	{
		if (!CanAdd(modifier))
		{
			return;
		}
		int maxModifierCount = GetMaxModifierCount(modifier);
		if (GetActiveCount(modifier.Type, modifier.Source) >= maxModifierCount)
		{
			Modifier shortestLifeModifier = GetShortestLifeModifier(modifier.Type, modifier.Source);
			if (shortestLifeModifier == null)
			{
				return;
			}
			Remove(shortestLifeModifier);
		}
		All.Add(modifier);
		if (!modifier.IsHiddenModifier())
		{
			AdjustSourceCount(modifier.Source, 1);
		}
		ApplyModifierValue(modifier);
		SetDirty(flag: true);
	}

	private void AdjustSourceCount(Modifier.ModifierSource source, int adjustBy)
	{
		sourceCounts.TryGetValue(source, out var value);
		sourceCounts[source] = value + 1;
	}

	public int GetSourceCount(Modifier.ModifierSource source)
	{
		return sourceCounts.GetValueOrDefault(source, 0);
	}

	private void ApplyModifierValue(Modifier modifier)
	{
		float value = modifier.Value;
		if (!totalValues.ContainsKey(modifier.Type))
		{
			totalValues.Add(modifier.Type, value);
		}
		else
		{
			totalValues[modifier.Type] += value;
		}
		totalValues[modifier.Type] = GetClampedValue(modifier, totalValues[modifier.Type]);
	}

	private bool CanAdd(Modifier modifier)
	{
		if (All.Contains(modifier))
		{
			return false;
		}
		if (modifier.HasNegativeSource() && (Object)(object)owner != (Object)null && owner is BasePlayer basePlayer && basePlayer.IsGod())
		{
			return false;
		}
		return true;
	}

	private int GetMaxModifiersForSourceType(Modifier.ModifierSource source)
	{
		if (source == Modifier.ModifierSource.Tea || source == Modifier.ModifierSource.Interaction)
		{
			return 1;
		}
		return int.MaxValue;
	}

	protected virtual int GetMaxModifierCount(Modifier modifier)
	{
		if (modifier == null)
		{
			return 0;
		}
		Modifier.ModifierSource source = modifier.Source;
		if (source == Modifier.ModifierSource.Tea || source == Modifier.ModifierSource.Interaction)
		{
			return 1;
		}
		return int.MaxValue;
	}

	protected virtual float GetClampedValue(Modifier modifier, float value)
	{
		return value;
	}

	private int GetActiveCount(Modifier.ModifierType type, Modifier.ModifierSource source)
	{
		int num = 0;
		foreach (Modifier item in All)
		{
			if (item.Type == type && item.Source == source)
			{
				num++;
			}
		}
		return num;
	}

	private Modifier GetShortestLifeModifier(Modifier.ModifierType type, Modifier.ModifierSource source)
	{
		Modifier modifier = null;
		foreach (Modifier item in All)
		{
			if (item.Type == type && item.Source == source)
			{
				if (modifier == null)
				{
					modifier = item;
				}
				else if (item.TimeRemaining < modifier.TimeRemaining)
				{
					modifier = item;
				}
			}
		}
		return modifier;
	}

	private void Remove(Modifier toRemove)
	{
		bool flag = false;
		bool flag2 = false;
		Modifier.ModifierType type = toRemove.Type;
		foreach (Modifier item in All)
		{
			if (toRemove == item)
			{
				flag = true;
			}
			else if (item.Type == type)
			{
				flag2 = true;
			}
		}
		if (flag)
		{
			All.Remove(toRemove);
			AdjustSourceCount(toRemove.Source, -1);
			if (!flag2)
			{
				totalValues.Remove(toRemove.Type);
			}
			SetDirty(flag: true);
		}
	}

	public void RemoveAll()
	{
		All.Clear();
		totalValues.Clear();
		sourceCounts.Clear();
		SetDirty(flag: true);
	}

	public void RemoveFromSource(Modifier.ModifierSource source)
	{
		for (int num = All.Count - 1; num >= 0; num--)
		{
			Modifier modifier = All[num];
			if (modifier != null && modifier.Source == source)
			{
				Remove(modifier);
			}
		}
	}

	public void RemoveAllExceptFromSource(Modifier.ModifierSource source)
	{
		for (int num = All.Count - 1; num >= 0; num--)
		{
			Modifier modifier = All[num];
			if (modifier != null && modifier.Source != source)
			{
				Remove(modifier);
			}
		}
	}

	public float GetValue(Modifier.ModifierType type, float defaultValue = 0f)
	{
		float num = 1f;
		if (IsModifierCompatibleWithDigestionBoost(type))
		{
			num = GetValue(Modifier.ModifierType.DigestionBoost, 1f);
		}
		if (totalValues.TryGetValue(type, out var value))
		{
			return value * num;
		}
		return defaultValue * num;
	}

	public void SetValue(Modifier.ModifierSource source, Modifier.ModifierType type, float value)
	{
		Modifier modifier = new Modifier();
		bool flag = false;
		foreach (Modifier item in All)
		{
			if (item != null && item.Source == source && item.Type == type)
			{
				modifier.Init(item.Type, item.Source, value, item.Duration, item.TimeRemaining);
				flag = true;
				break;
			}
		}
		if (flag)
		{
			Add(modifier);
		}
	}

	public float GetVariableValue(Modifier.ModifierType type, float defaultValue)
	{
		if (modifierVariables.TryGetValue(type, out var value))
		{
			return value;
		}
		return defaultValue;
	}

	public void SetVariableValue(Modifier.ModifierType type, float value)
	{
		if (modifierVariables.TryGetValue(type, out var _))
		{
			modifierVariables[type] = value;
		}
		else
		{
			modifierVariables.Add(type, value);
		}
	}

	public void RemoveVariable(Modifier.ModifierType type)
	{
		modifierVariables.Remove(type);
	}

	protected virtual void OnDisable()
	{
		if (!Application.isQuitting)
		{
			owner = null;
		}
	}

	public void SetDirty(bool flag)
	{
		dirty = flag;
	}

	public virtual void ServerInit(T owner)
	{
		this.owner = owner;
		ResetTicking();
		RemoveAll();
	}

	public void ResetTicking()
	{
		lastTickTime = Time.timeAsDouble;
		timeSinceLastTick = 0.0;
	}

	public virtual void ServerUpdate(BaseCombatEntity ownerEntity)
	{
		double num = Time.timeAsDouble - lastTickTime;
		lastTickTime = Time.timeAsDouble;
		timeSinceLastTick += num;
		if (!(timeSinceLastTick <= (double)ConVar.Server.modifierTickRate))
		{
			if ((Object)(object)owner != (Object)null && !owner.IsDead())
			{
				TickModifiers(ownerEntity, timeSinceLastTick);
			}
			timeSinceLastTick = 0.0;
		}
	}

	protected virtual void TickModifiers(BaseCombatEntity ownerEntity, double delta)
	{
		for (int num = All.Count - 1; num >= 0; num--)
		{
			Modifier modifier = All[num];
			float num2 = (IsModifierCompatibleWithDigestionBoost(modifier.Type) ? GetValue(Modifier.ModifierType.DigestionBoostTimeMod, 1f) : 1f);
			modifier.Tick(ownerEntity, delta * (double)num2);
			if (modifier.Expired)
			{
				Remove(modifier);
			}
		}
	}

	protected bool IsModifierCompatibleWithDigestionBoost(Modifier.ModifierType modifierType)
	{
		if ((uint)modifierType <= 1u || modifierType == Modifier.ModifierType.Scrap_Yield || modifierType == Modifier.ModifierType.Harvesting)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HorseModifiers : BaseModifiers<RidableHorse>
{
	public static void AddToHorse(RidableHorse horse, List<ModifierDefintion> modifiers)
	{
		if (!((Object)(object)horse == (Object)null) && !((Object)(object)horse.modifiers == (Object)null) && modifiers != null)
		{
			horse.modifiers.Add(modifiers);
		}
	}

	protected override bool IsCompatible(Modifier.ModifierType modType)
	{
		if ((uint)(modType - 20) <= 1u)
		{
			return true;
		}
		return false;
	}

	public HorseModifiers Save(bool forDisk)
	{
		HorseModifiers val = Pool.Get<HorseModifiers>();
		val.modifiers = Pool.Get<List<Modifier>>();
		foreach (Modifier item2 in All)
		{
			if (item2 != null && (!forDisk || item2.Source != Modifier.ModifierSource.Interaction))
			{
				Modifier item = item2.Save();
				val.modifiers.Add(item);
			}
		}
		return val;
	}

	public void Load(HorseModifiers m, bool fromDisk)
	{
		RemoveAll();
		if (m == null || m.modifiers == null)
		{
			return;
		}
		foreach (Modifier modifier2 in m.modifiers)
		{
			if (modifier2 != null && (!fromDisk || modifier2.source != 2))
			{
				Modifier modifier = new Modifier();
				modifier.Init((Modifier.ModifierType)modifier2.type, (Modifier.ModifierSource)modifier2.source, modifier2.value, modifier2.duration, modifier2.timeRemaining);
				Add(modifier);
			}
		}
	}
}


using System;

[Serializable]
public class ModifierDefintion
{
	public Modifier.ModifierType type;

	public Modifier.ModifierSource source;

	public float value;

	public float duration;
}


using System;

[Serializable]
public class ModifierLimit
{
	public Modifier.ModifierSource source;

	public int MaxApplications;

	public float minValue;

	public float maxValue;
}


using System;
using System.Collections.Generic;

[Serializable]
public class ModifierLimits
{
	public Modifier.ModifierType type;

	public float minValue;

	public float maxValue;

	public List<ModifierLimit> limits;
}


using System;
using Facepunch;
using ProtoBuf;

public class Modifier
{
	public enum ModifierType
	{
		Wood_Yield,
		Ore_Yield,
		Radiation_Resistance,
		Radiation_Exposure_Resistance,
		Max_Health,
		Scrap_Yield,
		MoveSpeed,
		ObscureVision,
		Warming,
		Cooling,
		CoreTemperatureMinAdjustment,
		CoreTemperatureMaxAdjustment,
		Crafting_Quality,
		VisionCare,
		MetabolismBooster,
		Harvesting,
		DigestionBoost,
		FishingBoost,
		Collectible_DoubleYield,
		Farming_BetterGenes,
		HorseGallopSpeed,
		HorseDungProductionBoost,
		Comfort,
		Clotting,
		HunterVision,
		Radiation,
		DigestionBoostTimeMod
	}

	public enum ModifierSource
	{
		Tea,
		Dart,
		Interaction,
		NegativeEffect
	}

	public static Phrase WoodYieldPhrase = new Phrase("mod.woodyield", "Wood Yield");

	public static Phrase OreYieldPhrase = new Phrase("mod.oreyield", "Ore Yield");

	public static Phrase RadiationResistancePhrase = new Phrase("mod.radiationresistance", "Radiation Resistance");

	public static Phrase RadiationExposureResistancePhrase = new Phrase("mod.radiationexposureresistance", "Radiation Exposure Resistance");

	public static Phrase MaxHealthPhrase = new Phrase("mod.maxhealth", "Max Health");

	public static Phrase ScrapYieldPhrase = new Phrase("mod.scrapyield", "Scrap Yield");

	public static Phrase MoveSpeedPhrase = new Phrase("mod.movespeed", "Movement Speed");

	public static Phrase ObscureVisionPhrase = new Phrase("mod.ObscureVision", "Obscure Vision");

	public static Phrase RadiationPhrase = new Phrase("mod.radiation", "Radiation");

	public static Phrase CraftingQualityPhrase = new Phrase("mod.craftingquality", "Crafting Quality");

	public static Phrase WarmingPhrase = new Phrase("mod.warming", "Warming");

	public static Phrase CoolingPhrase = new Phrase("mod.cooling", "Cooling");

	public static Phrase CoreTempMinPhrase = new Phrase("mod.coretempmin", "Min Temp");

	public static Phrase CoreTempMaxPhrase = new Phrase("mod.coretempmax", "Max Temp");

	public static Phrase VisionCarePhrase = new Phrase("mod.VisionCare", "Vision Care");

	public static Phrase MetabolismBoosterPhrase = new Phrase("mod.MetabolismBooster", "Metabolism Booster");

	public static Phrase HarvestingPhrase = new Phrase("mod.Harvesting", "Harvesting");

	public static Phrase DigestionBoostPhrase = new Phrase("mod.DigestionBoost", "Digestion Boost");

	public static Phrase FishingBoostPhrase = new Phrase("mod.FishingBoost", "Fishing Boost");

	public static Phrase CollectibleYieldPhrase = new Phrase("mod.CollectibleDoubleYield", "Double Yield Chance");

	public static Phrase Farming_BetterGenesPhrase = new Phrase("mod.Farming_BetterGenes", "Better Genes Chance");

	public static Phrase HorseGallopSpeedPhrase = new Phrase("mod.HorseGallopSpeed", "Horse Gallop Speed");

	public static Phrase ComfortPhrase = new Phrase("mod.Comfort", "Comfort");

	public static Phrase ClottingPhrase = new Phrase("mod.Clotting", "Clotting");

	public static Phrase Temperature = new Phrase("mod.temperature", "Temperature: ");

	public static Phrase MinTemp = new Phrase("mod.mintemp", "Min temperature: ");

	public static Phrase MaxTemp = new Phrase("mod.maxtemp", "Max temperature: ");

	public static Phrase HunterVisionPhrase = new Phrase("mod.huntervision", "Hunter Vision");

	public static Phrase Farming_BetterGenesPanelPhrase = new Phrase("mod.Farming_BetterGenes.panel", "Increase");

	public ModifierType Type { get; private set; }

	public ModifierSource Source { get; private set; }

	public float Value { get; private set; } = 1f;

	public float Duration { get; private set; } = 10f;

	public double TimeRemaining { get; private set; }

	public bool Expired { get; private set; }

	public void Init(ModifierType type, ModifierSource source, float value, float duration, double remaining)
	{
		Type = type;
		Source = source;
		Value = value;
		Duration = duration;
		Expired = false;
		TimeRemaining = remaining;
	}

	public void Tick(BaseCombatEntity ownerEntity, double delta)
	{
		TimeRemaining -= delta;
		Expired = Duration > 0f && TimeRemaining <= 0.0;
	}

	public Modifier Save()
	{
		Modifier obj = Pool.Get<Modifier>();
		obj.type = (int)Type;
		obj.source = (int)Source;
		obj.value = Value;
		obj.timeRemaining = TimeRemaining;
		obj.duration = Duration;
		return obj;
	}

	public void Load(Modifier m)
	{
		Type = (ModifierType)m.type;
		Source = (ModifierSource)m.source;
		Value = m.value;
		TimeRemaining = m.timeRemaining;
		Duration = m.duration;
	}

	public static Phrase GetPhraseForModType(ModifierType type)
	{
		switch (type)
		{
		case ModifierType.Wood_Yield:
			return WoodYieldPhrase;
		case ModifierType.Ore_Yield:
			return OreYieldPhrase;
		case ModifierType.Radiation_Resistance:
			return RadiationResistancePhrase;
		case ModifierType.Radiation_Exposure_Resistance:
			return RadiationExposureResistancePhrase;
		case ModifierType.Max_Health:
			return MaxHealthPhrase;
		case ModifierType.Scrap_Yield:
			return ScrapYieldPhrase;
		case ModifierType.MoveSpeed:
			return MoveSpeedPhrase;
		case ModifierType.ObscureVision:
			return ObscureVisionPhrase;
		case ModifierType.Crafting_Quality:
			return CraftingQualityPhrase;
		case ModifierType.Warming:
			return WarmingPhrase;
		case ModifierType.Cooling:
			return CoolingPhrase;
		case ModifierType.CoreTemperatureMinAdjustment:
			return CoreTempMinPhrase;
		case ModifierType.CoreTemperatureMaxAdjustment:
			return CoreTempMaxPhrase;
		case ModifierType.VisionCare:
			return VisionCarePhrase;
		case ModifierType.MetabolismBooster:
			return MetabolismBoosterPhrase;
		case ModifierType.Harvesting:
			return HarvestingPhrase;
		case ModifierType.DigestionBoost:
		case ModifierType.HorseDungProductionBoost:
			return DigestionBoostPhrase;
		case ModifierType.FishingBoost:
			return FishingBoostPhrase;
		case ModifierType.Collectible_DoubleYield:
			return CollectibleYieldPhrase;
		case ModifierType.Farming_BetterGenes:
			return Farming_BetterGenesPhrase;
		case ModifierType.HorseGallopSpeed:
			return HorseGallopSpeedPhrase;
		case ModifierType.Comfort:
			return ComfortPhrase;
		case ModifierType.Clotting:
			return ClottingPhrase;
		case ModifierType.HunterVision:
			return HunterVisionPhrase;
		case ModifierType.Radiation:
			return RadiationPhrase;
		default:
			throw new ArgumentOutOfRangeException("type", type, $"Couldn't find a phrase for this modifier! {type}");
		}
	}

	public static Phrase GetPanelPhraseForModType(ModifierType type)
	{
		if (type == ModifierType.Farming_BetterGenes)
		{
			return Farming_BetterGenesPanelPhrase;
		}
		throw new ArgumentOutOfRangeException("type", type, $"Couldn't find a phrase for this modifier! {type}");
	}

	public bool IsHiddenModifier()
	{
		return Type == ModifierType.DigestionBoostTimeMod;
	}

	public bool HasNegativeSource()
	{
		if (Source != ModifierSource.Dart)
		{
			return Source == ModifierSource.NegativeEffect;
		}
		return true;
	}
}


public enum ModifierType
{
	Wood_Yield,
	Ore_Yield,
	Radiation_Resistance,
	Radiation_Exposure_Resistance,
	Max_Health,
	Scrap_Yield,
	MoveSpeed,
	ObscureVision,
	Warming,
	Cooling,
	CoreTemperatureMinAdjustment,
	CoreTemperatureMaxAdjustment,
	Crafting_Quality,
	VisionCare,
	MetabolismBooster,
	Harvesting,
	DigestionBoost,
	FishingBoost,
	Collectible_DoubleYield,
	Farming_BetterGenes,
	HorseGallopSpeed,
	HorseDungProductionBoost,
	Comfort,
	Clotting,
	HunterVision,
	Radiation,
	DigestionBoostTimeMod
}


public enum ModifierSource
{
	Tea,
	Dart,
	Interaction,
	NegativeEffect
}


using UnityEngine;

public class ExcavatorEffects : MonoBehaviour
{
	public static ExcavatorEffects instance;

	public ParticleSystemContainer[] miningParticles;

	public SoundPlayer[] miningSounds;

	public SoundFollowCollider[] beltSounds;

	public SoundPlayer[] miningStartSounds;

	public GameObject[] ambientMetalRattles;

	public bool wasMining;
}


using UnityEngine;

public class ExcavatorEngineSounds : MonoBehaviour, IClientComponent
{
	public SoundPlayer[] engineStartClunks;

	public void PlayStartClunks()
	{
	}
}


public class ExcavatorOutputPile : StorageContainer
{
}


using UnityEngine;

public class ExcavatorServerEffects : MonoBehaviour
{
	public static ExcavatorServerEffects instance;

	public TriggerBase[] miningTriggers;

	public void Awake()
	{
		instance = this;
		SetMining(isMining: false, force: true);
	}

	public void OnDestroy()
	{
		instance = null;
	}

	public static void SetMining(bool isMining, bool force = false)
	{
		if ((Object)(object)instance == (Object)null)
		{
			return;
		}
		TriggerBase[] array = instance.miningTriggers;
		foreach (TriggerBase triggerBase in array)
		{
			if (!((Object)(object)triggerBase == (Object)null))
			{
				((Component)triggerBase).gameObject.SetActive(isMining);
			}
		}
	}
}


using UnityEngine;

public class ExcavatorYawSounds : MonoBehaviour, IClientComponent
{
	public SoundPlayer[] miningStartClunks;

	public void PlayStartClunks()
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Rust;
using Rust;
using UnityEngine;

public class LargeShredder : BaseEntity
{
	public Transform shredRail;

	public Transform shredRailStartPos;

	public Transform shredRailEndPos;

	public Vector3 shredRailStartRotation;

	public Vector3 shredRailEndRotation;

	public LargeShredderTrigger trigger;

	public float shredDurationRotation = 2f;

	public float shredDurationPosition = 5f;

	public float shredSwayAmount = 1f;

	public float shredSwaySpeed = 3f;

	public BaseEntity currentlyShredding;

	public GameObject[] shreddingWheels;

	public float shredRotorSpeed = 1f;

	public GameObjectRef shredSoundEffect;

	public Transform resourceSpawnPoint;

	private Quaternion entryRotation;

	public const string SHRED_STAT = "cars_shredded";

	public const Flags IsShreddingFlag = Flags.Reserved10;

	public bool isShredding;

	private float shreddingEntityNormalizedHealth = 1f;

	public float shredStartTime;

	private float prevDelta;

	public virtual void OnEntityEnteredTrigger(BaseEntity ent)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		if (ent.IsDestroyed)
		{
			return;
		}
		Rigidbody component = ((Component)ent).GetComponent<Rigidbody>();
		if (isShredding || (Object)(object)currentlyShredding != (Object)null)
		{
			if (!component.isKinematic)
			{
				component.velocity = -component.velocity * 3f;
			}
			return;
		}
		shreddingEntityNormalizedHealth = 1f;
		MagnetLiftable magnetLiftable = default(MagnetLiftable);
		if (((Component)ent).TryGetComponent<MagnetLiftable>(ref magnetLiftable))
		{
			if (magnetLiftable.requireObjectOff && ent.IsOn())
			{
				return;
			}
			if (magnetLiftable.scaleScrapResourcesByHealth && ent is BaseCombatEntity baseCombatEntity)
			{
				shreddingEntityNormalizedHealth = baseCombatEntity.healthFraction;
			}
		}
		((Component)shredRail).transform.position = shredRailStartPos.position;
		((Component)shredRail).transform.rotation = Quaternion.LookRotation(shredRailStartRotation);
		entryRotation = ((Component)ent).transform.rotation;
		Quaternion rotation = ((Component)ent).transform.rotation;
		PooledList<Collider> val = Pool.Get<PooledList<Collider>>();
		try
		{
			((Component)ent).GetComponentsInChildren<Collider>((List<Collider>)(object)val);
			foreach (Collider item in (List<Collider>)(object)val)
			{
				item.enabled = false;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		component.isKinematic = true;
		currentlyShredding = ent;
		((Component)ent).transform.rotation = rotation;
		isShredding = true;
		SetShredding(isShredding: true);
		prevDelta = 0f;
		shredStartTime = Time.realtimeSinceStartup;
	}

	public void CreateShredResources()
	{
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)currentlyShredding == (Object)null)
		{
			return;
		}
		MagnetLiftable component = ((Component)currentlyShredding).GetComponent<MagnetLiftable>();
		if ((Object)(object)component == (Object)null)
		{
			return;
		}
		if ((Object)(object)component.associatedPlayer != (Object)null && GameInfo.HasAchievements)
		{
			component.associatedPlayer.stats.Add("cars_shredded", 1);
			component.associatedPlayer.stats.Save(forceSteamSave: true);
		}
		List<Item> list = Pool.Get<List<Item>>();
		if (component.shredResources.Length > list.Capacity)
		{
			list.Capacity = component.shredResources.Length;
		}
		ItemAmount[] shredResources = component.shredResources;
		foreach (ItemAmount itemAmount in shredResources)
		{
			int num = Mathf.RoundToInt(itemAmount.amount * shreddingEntityNormalizedHealth);
			if (num > 0)
			{
				Item item = ItemManager.Create(itemAmount.itemDef, num, 0uL);
				if ((Object)(object)component.associatedPlayer != (Object)null)
				{
					item.SetItemOwnership(component.associatedPlayer, ItemOwnershipPhrases.Shredded);
				}
				float num2 = 0.5f;
				if ((Object)(object)item.CreateWorldObject(((Component)resourceSpawnPoint).transform.position + new Vector3(Random.Range(0f - num2, num2), 1f, Random.Range(0f - num2, num2))) == (Object)null)
				{
					item.Remove();
					continue;
				}
				list.Add(item);
				Analytics.Azure.AddPendingItems(currentlyShredding, item.info.shortname, item.amount, "car_shred", consumed: false);
			}
		}
		Analytics.Azure.OnCarShredded(component, list);
		Pool.Free<Item>(ref list, false);
		BaseModularVehicle component2 = ((Component)currentlyShredding).GetComponent<BaseModularVehicle>();
		if (!Object.op_Implicit((Object)(object)component2))
		{
			return;
		}
		foreach (BaseVehicleModule attachedModuleEntity in component2.AttachedModuleEntities)
		{
			if (!Object.op_Implicit((Object)(object)attachedModuleEntity.AssociatedItemDef) || !Object.op_Implicit((Object)(object)attachedModuleEntity.AssociatedItemDef.Blueprint))
			{
				continue;
			}
			foreach (ItemAmount ingredient in attachedModuleEntity.AssociatedItemDef.Blueprint.GetIngredients())
			{
				int num3 = Mathf.FloorToInt(ingredient.amount * 0.5f);
				if (num3 != 0)
				{
					Item item2 = ItemManager.Create(ingredient.itemDef, num3, 0uL);
					float num4 = 0.5f;
					if ((Object)(object)item2.CreateWorldObject(((Component)resourceSpawnPoint).transform.position + new Vector3(Random.Range(0f - num4, num4), 1f, Random.Range(0f - num4, num4))) == (Object)null)
					{
						item2.Remove();
					}
				}
			}
		}
	}

	public void UpdateBonePosition(float delta)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		float num = delta / shredDurationPosition;
		float num2 = delta / shredDurationRotation;
		((Component)shredRail).transform.localPosition = Vector3.Lerp(shredRailStartPos.localPosition, shredRailEndPos.localPosition, num);
		((Component)shredRail).transform.rotation = Quaternion.LookRotation(Vector3.Lerp(shredRailStartRotation, shredRailEndRotation, num2));
	}

	public void SetShredding(bool isShredding)
	{
		if (isShredding)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)FireShredEffect, 0.25f, 0.75f, 0.25f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FireShredEffect);
		}
	}

	public void FireShredEffect()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(shredSoundEffect.resourcePath, ((Component)this).transform.position + Vector3.up * 3f, Vector3.up);
	}

	public void ServerUpdate()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		SetFlag(Flags.Reserved10, isShredding);
		if (!isShredding)
		{
			return;
		}
		float num = Time.realtimeSinceStartup - shredStartTime;
		float num2 = num / shredDurationPosition;
		float num3 = num / shredDurationRotation;
		((Component)shredRail).transform.localPosition = Vector3.Lerp(shredRailStartPos.localPosition, shredRailEndPos.localPosition, num2);
		((Component)shredRail).transform.rotation = Quaternion.LookRotation(Vector3.Lerp(shredRailStartRotation, shredRailEndRotation, num3));
		MagnetLiftable component = ((Component)currentlyShredding).GetComponent<MagnetLiftable>();
		((Component)currentlyShredding).transform.position = ((Component)shredRail).transform.position;
		Vector3 val = ((Component)this).transform.TransformDirection(component.shredDirection);
		if (Vector3.Dot(-val, ((Component)currentlyShredding).transform.forward) > Vector3.Dot(val, ((Component)currentlyShredding).transform.forward))
		{
			val = ((Component)this).transform.TransformDirection(-component.shredDirection);
		}
		bool flag = Vector3.Dot(((Component)component).transform.up, Vector3.up) >= -0.95f;
		Quaternion val2 = QuaternionEx.LookRotationForcedUp(val, flag ? (-((Component)this).transform.right) : ((Component)this).transform.right);
		float num4 = Time.time * shredSwaySpeed;
		float num5 = Mathf.PerlinNoise(num4, 0f);
		float num6 = Mathf.PerlinNoise(0f, num4 + 150f);
		val2 *= Quaternion.Euler(num5 * shredSwayAmount, 0f, num6 * shredSwayAmount);
		((Component)currentlyShredding).transform.rotation = Quaternion.Lerp(entryRotation, val2, num3);
		if (prevDelta < 1.5f && num > 1.5f)
		{
			if (currentlyShredding is BaseVehicle baseVehicle)
			{
				foreach (BaseVehicle.MountPointInfo mountPoint in baseVehicle.mountPoints)
				{
					if ((Object)(object)mountPoint.mountable != (Object)null && (Object)(object)mountPoint.mountable.GetMounted() != (Object)null)
					{
						mountPoint.mountable.GetMounted().Hurt(999f, DamageType.Blunt, this, useProtection: false);
					}
				}
			}
			if (currentlyShredding is ScrapTransportHelicopter)
			{
				PooledList<BasePlayer> val3 = Pool.Get<PooledList<BasePlayer>>();
				try
				{
					foreach (BaseEntity child in currentlyShredding.children)
					{
						if (child is BasePlayer { isMounted: false } basePlayer)
						{
							((List<BasePlayer>)(object)val3).Add(basePlayer);
						}
					}
					foreach (BasePlayer item in (List<BasePlayer>)(object)val3)
					{
						item.Hurt(999f, DamageType.Blunt, this, useProtection: false);
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
		}
		prevDelta = num;
		if (num > 5f)
		{
			CreateShredResources();
			currentlyShredding.Kill();
			currentlyShredding = null;
			isShredding = false;
			SetShredding(isShredding: false);
		}
	}

	private void Update()
	{
		ServerUpdate();
	}
}


using UnityEngine;

public class LargeShredderTrigger : TriggerBase
{
	public LargeShredder shredder;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!baseEntity.syncPosition)
		{
			return null;
		}
		if (!Object.op_Implicit((Object)(object)((Component)baseEntity).GetComponent<MagnetLiftable>()))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		shredder.OnEntityEnteredTrigger(ent);
	}
}


using UnityEngine;

public class LightListener : BaseEntity
{
	public string onMessage = "";

	public string offMessage = "";

	[Tooltip("Must be part of this prefab")]
	public LightGroupAtTime onLights;

	[Tooltip("Must be part of this prefab")]
	public LightGroupAtTime offLights;

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		base.OnEntityMessage(from, msg);
		if (msg == onMessage)
		{
			SetFlag(Flags.On, b: true);
		}
		else if (msg == offMessage)
		{
			SetFlag(Flags.On, b: false);
		}
	}
}


using UnityEngine;

public class FruitScale : MonoBehaviour, IClientComponent
{
	public void SetProgress(float progress)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = Vector3.one * progress;
	}
}


using System;
using UnityEngine;

public class LifeScale : BaseMonoBehaviour
{
	[NonSerialized]
	private bool initialized;

	[NonSerialized]
	private Vector3 initialScale;

	public Vector3 finalScale = Vector3.one;

	private Vector3 targetLerpScale = Vector3.zero;

	private Action updateScaleAction;

	protected void Awake()
	{
		updateScaleAction = UpdateScale;
	}

	public void OnEnable()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Init();
		((Component)this).transform.localScale = initialScale;
	}

	public void SetProgress(float progress)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Init();
		targetLerpScale = Vector3.Lerp(initialScale, finalScale, progress);
		((FacepunchBehaviour)this).InvokeRepeating(updateScaleAction, 0f, 0.015f);
	}

	public void Init()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			initialScale = ((Component)this).transform.localScale;
			initialized = true;
		}
	}

	public void UpdateScale()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = Vector3.Lerp(((Component)this).transform.localScale, targetLerpScale, Time.deltaTime);
		if (((Component)this).transform.localScale == targetLerpScale)
		{
			targetLerpScale = Vector3.zero;
			((FacepunchBehaviour)this).CancelInvoke(updateScaleAction);
		}
	}
}


using UnityEngine;

public class MaterialColorLerp : MonoBehaviour, IClientComponent
{
	public Color startColor;

	public Color endColor;

	public Color currentColor;

	public float delta;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Plant Properties")]
public class PlantProperties : ScriptableObject
{
	public enum State
	{
		Seed,
		Seedling,
		Sapling,
		Crossbreed,
		Mature,
		Fruiting,
		Ripe,
		Dying
	}

	[Serializable]
	public struct Stage
	{
		public State nextState;

		public float lifeLength;

		public float health;

		public float resources;

		public float yield;

		public GameObjectRef skinObject;

		public bool IgnoreConditions;

		public float lifeLengthSeconds => lifeLength * 60f;
	}

	public Phrase Description;

	public GrowableGeneProperties Genes;

	[ArrayIndexIsEnum(enumType = typeof(State))]
	public Stage[] stages = new Stage[8];

	[Header("Metabolism")]
	public AnimationCurve timeOfDayHappiness = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 0f),
		new Keyframe(12f, 1f),
		new Keyframe(24f, 0f)
	});

	public AnimationCurve temperatureHappiness = new AnimationCurve((Keyframe[])(object)new Keyframe[5]
	{
		new Keyframe(-10f, -1f),
		new Keyframe(1f, 0f),
		new Keyframe(30f, 1f),
		new Keyframe(50f, 0f),
		new Keyframe(80f, -1f)
	});

	public AnimationCurve temperatureWaterRequirementMultiplier = new AnimationCurve((Keyframe[])(object)new Keyframe[5]
	{
		new Keyframe(-10f, 1f),
		new Keyframe(0f, 1f),
		new Keyframe(30f, 1f),
		new Keyframe(50f, 1f),
		new Keyframe(80f, 1f)
	});

	public AnimationCurve fruitVisualScaleCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 0f),
		new Keyframe(0.75f, 1f),
		new Keyframe(1f, 0f)
	});

	public int MaxSeasons = 1;

	public float WaterIntake = 20f;

	public float OptimalLightQuality = 1f;

	public float OptimalWaterQuality = 1f;

	public float OptimalGroundQuality = 1f;

	public float OptimalTemperatureQuality = 1f;

	[Header("Harvesting")]
	public BaseEntity.Menu.Option pickOption;

	public BaseEntity.Menu.Option pickAllOption;

	public BaseEntity.Menu.Option eatOption;

	public ItemDefinition pickupItem;

	public BaseEntity.Menu.Option cloneOption;

	public BaseEntity.Menu.Option cloneAllOption;

	public BaseEntity.Menu.Option removeDyingOption;

	public BaseEntity.Menu.Option removeDyingAllOption;

	public ItemDefinition removeDyingItem;

	public GameObjectRef removeDyingEffect;

	public int pickupMultiplier = 1;

	public GameObjectRef pickEffect;

	public int maxHarvests = 1;

	public bool disappearAfterHarvest;

	[Header("Seeds")]
	public GameObjectRef CrossBreedEffect;

	public ItemDefinition SeedItem;

	public ItemDefinition CloneItem;

	public int BaseCloneCount = 1;

	[Header("Market")]
	public int BaseMarketValue = 10;
}


public enum State
{
	Seed,
	Seedling,
	Sapling,
	Crossbreed,
	Mature,
	Fruiting,
	Ripe,
	Dying
}


using System;

[Serializable]
public struct Stage
{
	public State nextState;

	public float lifeLength;

	public float health;

	public float resources;

	public float yield;

	public GameObjectRef skinObject;

	public bool IgnoreConditions;

	public float lifeLengthSeconds => lifeLength * 60f;
}


using UnityEngine;

public class PlantSkin : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class PlatformEntity : BaseEntity
{
	private const float movementSpeed = 1f;

	private const float rotationSpeed = 10f;

	private const float radius = 10f;

	private Vector3 targetPosition = Vector3.zero;

	private Quaternion targetRotation = Quaternion.identity;

	protected void FixedUpdate()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient)
		{
			if (targetPosition == Vector3.zero || Vector3.Distance(((Component)this).transform.position, targetPosition) < 0.01f)
			{
				Vector2 val = Random.insideUnitCircle * 10f;
				targetPosition = ((Component)this).transform.position + new Vector3(val.x, 0f, val.y);
				targetPosition.y = WaterLevel.GetWaterOrTerrainSurface(targetPosition, waves: false, volumes: false) + 1f;
				targetRotation = Quaternion.LookRotation(targetPosition - ((Component)this).transform.position);
			}
			((Component)this).transform.SetPositionAndRotation(Vector3.MoveTowards(((Component)this).transform.position, targetPosition, Time.fixedDeltaTime * 1f), Quaternion.RotateTowards(((Component)this).transform.rotation, targetRotation, Time.fixedDeltaTime * 10f));
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}
}


using ProtoBuf;

public interface IEntityPingSource
{
	bool IsPingValid(MapNote note);
}


using Facepunch.Math;
using ProtoBuf;

public static class PlayerStateEx
{
	public static bool IsSaveStale(this PlayerState state)
	{
		int protocol = state.protocol;
		uint seed = state.seed;
		int saveCreatedTime = state.saveCreatedTime;
		int num = Epoch.FromDateTime(SaveRestore.SaveCreatedTime);
		if (271 == protocol && World.Seed == seed)
		{
			return num != saveCreatedTime;
		}
		return true;
	}
}


using UnityEngine;

public class PlayerAnimationEvents : MonoBehaviour
{
	private static readonly int Up = Animator.StringToHash("up");

	private static readonly int Right = Animator.StringToHash("right");
}


using System;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class PlayerBelt
{
	public static int ClientAutoSelectSlot = -1;

	public static uint ClientAutoSeletItemUID = 0u;

	public static EncryptedValue<int> SelectedSlot = -1;

	protected BasePlayer player;

	public static int MaxBeltSlots => 6;

	public PlayerBelt(BasePlayer player)
	{
		this.player = player;
	}

	public void DropActive(Vector3 position, Vector3 velocity)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		if (player.GetActiveShield(out var foundShield))
		{
			if (Interface.CallHook("OnPlayerActiveShieldDrop", (object)player, (object)foundShield) != null)
			{
				return;
			}
			DroppedItem droppedItem = foundShield.GetItem().Drop(position, velocity) as DroppedItem;
			if ((Object)(object)droppedItem != (Object)null)
			{
				droppedItem.DropReason = DroppedItem.DropReasonEnum.Death;
				droppedItem.DroppedBy = player.userID;
				droppedItem.DroppedTime = DateTime.UtcNow;
				Analytics.Azure.OnItemDropped(player, droppedItem, DroppedItem.DropReasonEnum.Death);
			}
		}
		Item activeItem = player.GetActiveItem();
		if (activeItem == null || Interface.CallHook("OnPlayerDropActiveItem", (object)player, (object)activeItem) != null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("PlayerBelt.DropActive", 0);
		try
		{
			DroppedItem droppedItem2 = activeItem.Drop(position, velocity) as DroppedItem;
			if ((Object)(object)droppedItem2 != (Object)null)
			{
				droppedItem2.DropReason = DroppedItem.DropReasonEnum.Death;
				droppedItem2.DroppedBy = player.userID;
				droppedItem2.DroppedTime = DateTime.UtcNow;
				Analytics.Azure.OnItemDropped(player, droppedItem2, DroppedItem.DropReasonEnum.Death);
			}
			player.svActiveItemID = default(ItemId);
			player.SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Item GetItemInSlot(int slot)
	{
		if ((Object)(object)player == (Object)null)
		{
			return null;
		}
		if ((Object)(object)player.inventory == (Object)null)
		{
			return null;
		}
		if (player.inventory.containerBelt == null)
		{
			return null;
		}
		return player.inventory.containerBelt.GetSlot(slot);
	}

	public Handcuffs GetRestraintItem()
	{
		if ((Object)(object)player == (Object)null)
		{
			return null;
		}
		if ((Object)(object)player.inventory == (Object)null)
		{
			return null;
		}
		if (player.inventory.containerBelt == null)
		{
			return null;
		}
		foreach (Item item in player.inventory.containerBelt.itemList)
		{
			if (item != null)
			{
				Handcuffs handcuffs = item.GetHeldEntity() as Handcuffs;
				if (!((Object)(object)handcuffs == (Object)null) && handcuffs.Locked)
				{
					return handcuffs;
				}
			}
		}
		return null;
	}

	public bool CanHoldItem()
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (player.IsWounded())
		{
			return false;
		}
		if (player.IsSleeping())
		{
			return false;
		}
		if (player.isMounted && !player.GetMounted().CanHoldItems())
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class PlayerBlueprints : EntityComponent<BasePlayer>
{
	public SteamInventory steamInventory;

	public void Reset()
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		if (persistantPlayerInfo.unlockedItems != null)
		{
			persistantPlayerInfo.unlockedItems.Clear();
		}
		else
		{
			persistantPlayerInfo.unlockedItems = Pool.Get<List<int>>();
		}
		base.baseEntity.PersistantPlayerInfo = persistantPlayerInfo;
		base.baseEntity.SendNetworkUpdate();
	}

	public void UnlockAll()
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		foreach (ItemBlueprint bp in ItemManager.bpList)
		{
			if (bp.userCraftable && !bp.defaultBlueprint && !persistantPlayerInfo.unlockedItems.Contains(bp.targetItem.itemid))
			{
				persistantPlayerInfo.unlockedItems.Add(bp.targetItem.itemid);
			}
		}
		base.baseEntity.PersistantPlayerInfo = persistantPlayerInfo;
		base.baseEntity.SendNetworkUpdateImmediate();
		base.baseEntity.ClientRPC(RpcTarget.Player("UnlockedBlueprint", base.baseEntity), 0);
	}

	public bool IsUnlocked(ItemDefinition itemDef)
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		if (persistantPlayerInfo.unlockedItems != null)
		{
			return persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid);
		}
		return false;
	}

	public void Unlock(ItemDefinition itemDef)
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		if (!persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
		{
			persistantPlayerInfo.unlockedItems.Add(itemDef.itemid);
			base.baseEntity.PersistantPlayerInfo = persistantPlayerInfo;
			base.baseEntity.SendNetworkUpdateImmediate();
			base.baseEntity.ClientRPC(RpcTarget.Player("UnlockedBlueprint", base.baseEntity), itemDef.itemid);
			base.baseEntity.stats.Add("blueprint_studied", 1, (Stats)5);
		}
	}

	public bool HasUnlocked(ItemDefinition targetItem)
	{
		if (base.baseEntity.IsCraftingTutorialBlocked(targetItem, out var forceUnlock))
		{
			return false;
		}
		if (forceUnlock)
		{
			return true;
		}
		if (Object.op_Implicit((Object)(object)targetItem.Blueprint))
		{
			if ((Object)(object)targetItem.Blueprint.RequireUnlockedItem != (Object)null && !HasUnlocked(targetItem.Blueprint.RequireUnlockedItem))
			{
				return false;
			}
			if (targetItem.Blueprint.NeedsSteamItem)
			{
				if ((Object)(object)targetItem.steamItem != (Object)null)
				{
					if ((Object)(object)targetItem.steamItem.UnlockedViaSteamItem != (Object)null)
					{
						if (!steamInventory.HasItem(targetItem.steamItem.UnlockedViaSteamItem.id))
						{
							return false;
						}
					}
					else if (!steamInventory.HasItem(targetItem.steamItem.id))
					{
						return false;
					}
				}
				if (base.baseEntity.UnlockAllSkins)
				{
					return true;
				}
				if ((Object)(object)targetItem.steamItem == (Object)null)
				{
					bool flag = false;
					ItemSkinDirectory.Skin[] skins = targetItem.skins;
					for (int i = 0; i < skins.Length; i++)
					{
						ItemSkinDirectory.Skin skin = skins[i];
						if (steamInventory.HasItem(skin.id))
						{
							flag = true;
							break;
						}
					}
					if (!flag && targetItem.skins2 != null)
					{
						IPlayerItemDefinition[] skins2 = targetItem.skins2;
						foreach (IPlayerItemDefinition val in skins2)
						{
							if (steamInventory.HasItem(val.DefinitionId))
							{
								flag = true;
								break;
							}
						}
					}
					if (!flag)
					{
						return false;
					}
				}
				return true;
			}
			if (targetItem.Blueprint.NeedsSteamDLC)
			{
				if (base.baseEntity.UnlockAllSkins)
				{
					return true;
				}
				if ((Object)(object)targetItem.steamDlc != (Object)null && targetItem.steamDlc.HasLicense(base.baseEntity.userID))
				{
					return true;
				}
			}
		}
		int[] defaultBlueprints = ItemManager.defaultBlueprints;
		for (int i = 0; i < defaultBlueprints.Length; i++)
		{
			if (defaultBlueprints[i] == targetItem.itemid)
			{
				return true;
			}
		}
		if (base.baseEntity.isServer)
		{
			return IsUnlocked(targetItem);
		}
		return false;
	}

	public bool CanCraft(int itemid, int skinItemId, ulong playerId)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemid);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", (object)this, (object)itemDefinition, (object)skinItemId);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (skinItemId != 0 && !base.baseEntity.UnlockAllSkins && !CheckSkinOwnership(skinItemId, playerId))
		{
			return false;
		}
		if (base.baseEntity.currentCraftLevel < (float)itemDefinition.Blueprint.GetWorkbenchLevel())
		{
			return false;
		}
		if (HasUnlocked(itemDefinition))
		{
			return true;
		}
		return false;
	}

	public bool CheckSkinOwnership(int skinItemId, ulong playerId)
	{
		ItemSkinDirectory.Skin skin = ItemSkinDirectory.FindByInventoryDefinitionId(skinItemId);
		if ((Object)(object)skin.invItem != (Object)null && skin.invItem.HasUnlocked(playerId))
		{
			return true;
		}
		return steamInventory.HasItem(skinItemId);
	}
}


using UnityEngine;

public class PlayerEyes : EntityComponent<BasePlayer>
{
	public static readonly Vector3 EyeOffset = new Vector3(0f, 1.5f, 0f);

	public static readonly Vector3 DuckOffset = new Vector3(0f, -0.6f, 0f);

	public static readonly Vector3 CrawlOffset = new Vector3(0f, -1.15f, 0.175f);

	public static readonly Vector3 ParachuteOffset = new Vector3(0f, -1.45f, 0.3f);

	public Vector3 thirdPersonSleepingOffset = new Vector3(0.43f, 1.25f, 0.7f);

	public LazyAimProperties defaultLazyAim;

	private EncryptedValue<Vector3> viewOffset = Vector3.zero;

	public Vector3 worldMountedPosition
	{
		get
		{
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)base.baseEntity) && base.baseEntity.isMounted)
			{
				Vector3 val = base.baseEntity.GetMounted().EyePositionForPlayer(base.baseEntity, GetLookRotation());
				if (val != Vector3.zero)
				{
					return val;
				}
			}
			return worldStandingPosition;
		}
	}

	public Vector3 worldStandingPosition => ((Component)this).transform.position + EyeOffset;

	public Vector3 worldCrouchedPosition => worldStandingPosition + DuckOffset;

	public Vector3 worldCrawlingPosition => worldStandingPosition + CrawlOffset;

	public Vector3 position
	{
		get
		{
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)base.baseEntity) && base.baseEntity.isMounted)
			{
				Vector3 val = base.baseEntity.GetMounted().EyePositionForPlayer(base.baseEntity, GetLookRotation());
				if (val != Vector3.zero)
				{
					return val;
				}
				return ((Component)this).transform.position + ((Component)this).transform.up * (EyeOffset.y + viewOffset.Get().y) + BodyLeanOffset;
			}
			return ((Component)this).transform.position + ((Component)this).transform.rotation * (EyeOffset + (Vector3)viewOffset) + BodyLeanOffset;
		}
	}

	private Vector3 BodyLeanOffset => Vector3.zero;

	public Vector3 center
	{
		get
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)base.baseEntity) && base.baseEntity.isMounted)
			{
				Vector3 val = base.baseEntity.GetMounted().EyeCenterForPlayer(base.baseEntity, GetLookRotation());
				if (val != Vector3.zero)
				{
					return val;
				}
			}
			return ((Component)this).transform.position + ((Component)this).transform.up * (EyeOffset.y + DuckOffset.y);
		}
	}

	public Vector3 offset => ((Component)this).transform.up * (EyeOffset.y + viewOffset.Get().y);

	public Quaternion rotation
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return parentRotation * bodyRotation;
		}
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			bodyRotation = Quaternion.Inverse(parentRotation) * value;
		}
	}

	public Quaternion bodyRotation { get; set; }

	public Quaternion parentRotation
	{
		get
		{
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			if (base.baseEntity.isMounted || !((Object)(object)((Component)this).transform.parent != (Object)null))
			{
				return Quaternion.identity;
			}
			Quaternion val = ((Component)this).transform.parent.rotation;
			return Quaternion.Euler(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f);
		}
	}

	public void NetworkUpdate(Quaternion rot)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (base.baseEntity.IsCrawling())
		{
			viewOffset = CrawlOffset;
		}
		else
		{
			viewOffset = Vector3.zero;
			viewOffset = Vector3.Lerp((Vector3)viewOffset, DuckOffset, base.baseEntity.modelState.ducking);
		}
		bodyRotation = rot;
	}

	public Vector3 MovementForward()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = rotation;
		return Quaternion.Euler(new Vector3(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f)) * Vector3.forward;
	}

	public Vector3 MovementRight()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = rotation;
		return Quaternion.Euler(new Vector3(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f)) * Vector3.right;
	}

	public Ray BodyRay()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Ray(position, BodyForward());
	}

	public Vector3 BodyForward()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return rotation * Vector3.forward;
	}

	public Vector3 BodyRight()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return rotation * Vector3.right;
	}

	public Vector3 BodyUp()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return rotation * Vector3.up;
	}

	public Ray HeadRay()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Ray(position, HeadForward());
	}

	public Vector3 HeadForward()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetLookRotation() * Vector3.forward;
	}

	public Vector3 HeadRight()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetLookRotation() * Vector3.right;
	}

	public Vector3 HeadUp()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetLookRotation() * Vector3.up;
	}

	public Quaternion GetLookRotation()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return rotation;
	}

	public Quaternion GetAimRotation()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return rotation;
	}
}


using System;
using Rust;

public class PlayerInput : EntityComponent<BasePlayer>
{
	public InputState state = new InputState();

	[NonSerialized]
	public bool hadInputBuffer = true;

	protected void OnDisable()
	{
		if (!Application.isQuitting)
		{
			state.Clear();
		}
	}
}


public static class PlayerInventoryErrors
{
	public static readonly Phrase InvalidItem = new Phrase("error_invaliditem", "Invalid item");

	public static readonly Phrase CannotMoveItem = new Phrase("error_cannotmoveitem", "Cannot move item!");

	public static readonly Phrase ContainerLocked = new Phrase("error_containerlocked", "Container locked");

	public static readonly Phrase InvalidContainer = new Phrase("error_invalidcontainer", "Invalid container");

	public static readonly Phrase DoesntAcceptPlayerItems = new Phrase("error_doesntacceptplayeritems", "Container does not accept player items!");

	public static readonly Phrase CannotEquipBroken = new Phrase("error_cannotequipbroken", "Cannot equip a broken item");

	public static readonly Phrase ActiveItemBroken = new Phrase("error_activeitembroken", "Your active item was broken!");

	public static readonly Phrase LootableDoesntExist = new Phrase("error_lootabledoesntexist", "Lootable doesn't exist!");
}


using System;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class PlayerModel : ListComponent<PlayerModel>
{
	public enum MountPoses
	{
		Chair = 0,
		Driving = 1,
		Horseback = 2,
		HeliUnarmed = 3,
		HeliArmed = 4,
		HandMotorBoat = 5,
		MotorBoatPassenger = 6,
		SitGeneric = 7,
		SitRaft = 8,
		StandDrive = 9,
		SitShootingGeneric = 10,
		SitMinicopter_Pilot = 11,
		SitMinicopter_Passenger = 12,
		ArcadeLeft = 13,
		ArcadeRight = 14,
		SitSummer_Ring = 15,
		SitSummer_BoogieBoard = 16,
		SitCarPassenger = 17,
		SitSummer_Chair = 18,
		SitRaft_NoPaddle = 19,
		Sit_SecretLab = 20,
		Sit_Workcart = 21,
		Sit_Cardgame = 22,
		Sit_Crane = 23,
		Sit_Snowmobile_Shooting = 24,
		Sit_RetroSnowmobile_Shooting = 25,
		Driving_Snowmobile = 26,
		ZiplineHold = 27,
		Sit_Locomotive = 28,
		Sit_Throne = 29,
		Parachute = 30,
		Sit_DPV = 31,
		Standing_Ballista = 32,
		Sit_BatteringRam = 33,
		VineSwinging = 34,
		Sit_Ejectorseat = 35,
		Sit_Beanbag = 36,
		Standing = 128
	}

	protected static int speed = Animator.StringToHash("speed");

	protected static int acceleration = Animator.StringToHash("acceleration");

	protected static int rotationYaw = Animator.StringToHash("rotationYaw");

	protected static int forward = Animator.StringToHash("forward");

	protected static int right = Animator.StringToHash("right");

	protected static int up = Animator.StringToHash("up");

	protected static int ducked = Animator.StringToHash("ducked");

	protected static int grounded = Animator.StringToHash("grounded");

	protected static int crawling = Animator.StringToHash("crawling");

	protected static int waterlevel = Animator.StringToHash("waterlevel");

	protected static int attack = Animator.StringToHash("attack");

	protected static int attack_alt = Animator.StringToHash("attack_alt");

	protected static int deploy = Animator.StringToHash("deploy");

	protected static int turnOn = Animator.StringToHash("turnOn");

	protected static int turnOff = Animator.StringToHash("turnOff");

	protected static int reload = Animator.StringToHash("reload");

	protected static int throwWeapon = Animator.StringToHash("throw");

	protected static int holster = Animator.StringToHash("holster");

	protected static int aiming = Animator.StringToHash("aiming");

	protected static int onLadder = Animator.StringToHash("onLadder");

	protected static int posing = Animator.StringToHash("posing");

	protected static int poseType = Animator.StringToHash("poseType");

	protected static int relaxGunPose = Animator.StringToHash("relaxGunPose");

	protected static int vehicle_aim_yaw = Animator.StringToHash("vehicleAimYaw");

	protected static int vehicle_aim_speed = Animator.StringToHash("vehicleAimYawSpeed");

	protected static int usePoseTransition = Animator.StringToHash("usePoseTransition");

	protected static int onPhone = Animator.StringToHash("onPhone");

	protected static int leftFootIK = Animator.StringToHash("leftFootIK");

	protected static int rightFootIK = Animator.StringToHash("rightFootIK");

	protected static int vehicleSteering = Animator.StringToHash("vehicleSteering");

	protected static int sitReaction = Animator.StringToHash("sitReaction");

	protected static int forwardReaction = Animator.StringToHash("forwardReaction");

	protected static int rightReaction = Animator.StringToHash("rightReaction");

	protected static int ladderType = Animator.StringToHash("ladderType");

	protected static int hasParachute = Animator.StringToHash("hasParachute");

	protected static int nonGroundedTime = Animator.StringToHash("nonGroundedTime");

	protected static int deployParachuteTrigger = Animator.StringToHash("deployParachute");

	protected static int catching = Animator.StringToHash("waitingToCatch");

	protected static int shieldBlockingParam = Animator.StringToHash("shieldBlocking");

	protected static int shieldDeploy = Animator.StringToHash("ShieldDeploy");

	protected static int shieldMeleeAttackParam = Animator.StringToHash("shieldMeleeAttack");

	public BoxCollider collision;

	public GameObject censorshipCube;

	public GameObject censorshipCubeBreasts;

	public GameObject jawBone;

	public GameObject neckBone;

	public GameObject headBone;

	public EyeController eyeController;

	public EyeBlink blinkController;

	public Transform[] SpineBones;

	public Transform leftFootBone;

	public Transform rightFootBone;

	public Transform leftHandPropBone;

	public Transform rightHandPropBone;

	public Vector3 rightHandTarget;

	public bool isPreview;

	[Header("IK")]
	public Vector3 leftHandTargetPosition;

	public Quaternion leftHandTargetRotation;

	public Vector3 rightHandTargetPosition;

	public Quaternion rightHandTargetRotation;

	public float steeringTargetDegrees;

	public Vector3 rightFootTargetPosition;

	public Quaternion rightFootTargetRotation;

	public Vector3 leftFootTargetPosition;

	public Quaternion leftFootTargetRotation;

	public LegsAnimator legsAnimator;

	public RuntimeAnimatorController CinematicAnimationController;

	public Avatar DefaultAvatar;

	public Avatar CinematicAvatar;

	public RuntimeAnimatorController DefaultHoldType;

	public RuntimeAnimatorController SleepGesture;

	public RuntimeAnimatorController CrawlToIncapacitatedGesture;

	public RuntimeAnimatorController CrawlToIncapacitatedGestureHandcuff;

	public RuntimeAnimatorController StandToIncapacitatedGesture;

	[NonSerialized]
	public RuntimeAnimatorController CurrentGesture;

	[Header("Skin")]
	public SkinSetCollection MaleSkin;

	public SkinSetCollection FemaleSkin;

	public SkinSetCollection MannequinSkin;

	public SubsurfaceProfile subsurfaceProfile;

	[Header("Parameters")]
	[Range(0f, 1f)]
	public float voiceVolume;

	[Range(0f, 1f)]
	public float skinColor = 1f;

	[Range(0f, 1f)]
	public float skinNumber = 1f;

	[Range(0f, 1f)]
	public float meshNumber;

	[Range(0f, 1f)]
	public float hairNumber;

	[Range(0f, 1f)]
	public int skinType;

	public MovementSounds movementSounds;

	public bool showSash;

	public int tempPoseType;

	public uint underwearSkin;

	public Transform[] Shoulders;

	public Transform[] AdditionalSpineBones;

	public ulong overrideSkinSeed { get; private set; }

	public bool IsFemale => skinType == 1;

	public SkinSetCollection SkinSet
	{
		get
		{
			if (!IsMannequin)
			{
				if (!IsFemale)
				{
					return MaleSkin;
				}
				return FemaleSkin;
			}
			return MannequinSkin;
		}
	}

	public Quaternion AimAngles { get; set; }

	public Quaternion LookAngles { get; set; }

	public bool IsMannequin { get; set; }

	private static Vector3 GetFlat(Vector3 dir)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		dir.y = 0f;
		return ((Vector3)(ref dir)).normalized;
	}

	public static void RebuildAll()
	{
	}
}


public enum MountPoses
{
	Chair = 0,
	Driving = 1,
	Horseback = 2,
	HeliUnarmed = 3,
	HeliArmed = 4,
	HandMotorBoat = 5,
	MotorBoatPassenger = 6,
	SitGeneric = 7,
	SitRaft = 8,
	StandDrive = 9,
	SitShootingGeneric = 10,
	SitMinicopter_Pilot = 11,
	SitMinicopter_Passenger = 12,
	ArcadeLeft = 13,
	ArcadeRight = 14,
	SitSummer_Ring = 15,
	SitSummer_BoogieBoard = 16,
	SitCarPassenger = 17,
	SitSummer_Chair = 18,
	SitRaft_NoPaddle = 19,
	Sit_SecretLab = 20,
	Sit_Workcart = 21,
	Sit_Cardgame = 22,
	Sit_Crane = 23,
	Sit_Snowmobile_Shooting = 24,
	Sit_RetroSnowmobile_Shooting = 25,
	Driving_Snowmobile = 26,
	ZiplineHold = 27,
	Sit_Locomotive = 28,
	Sit_Throne = 29,
	Parachute = 30,
	Sit_DPV = 31,
	Standing_Ballista = 32,
	Sit_BatteringRam = 33,
	VineSwinging = 34,
	Sit_Ejectorseat = 35,
	Sit_Beanbag = 36,
	Standing = 128
}


using System;
using UnityEngine;

public class PlayerModelCinematicList : PrefabAttribute, IClientComponent
{
	[Serializable]
	public struct PlayerModelCinematicAnimation
	{
		public string StateName;

		public string ClipName;

		public float Length;
	}

	public PlayerModelCinematicAnimation[] Animations;

	protected override Type GetIndexedType()
	{
		return typeof(PlayerModelCinematicList);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
	}
}


using System;

[Serializable]
public struct PlayerModelCinematicAnimation
{
	public string StateName;

	public string ClipName;

	public float Length;
}


using UnityEngine;

public class PlayerModelReactionEnded : StateMachineBehaviour
{
}


using UnityEngine;
using UnityEngine.UI;

public class PlayerNameTag : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public Text text;

	public Gradient color;

	public float minDistance = 3f;

	public float maxDistance = 10f;

	public Vector3 positionOffset;

	public Transform parentBone;
}


[Factory("nametags")]
public class nametags : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static bool enabled = true;
}


public class PlayerVoiceRecorder : EntityComponent<BasePlayer>
{
}


public class PlayerVoiceSpeaker : EntityComponent<BasePlayer>
{
	public VoiceProcessor voiceProcessor;
}


using UnityEngine;

public class VoiceProcessor : EntityComponentBase
{
	public AudioSource mouthSpeaker;

	public PlayerVoiceSpeaker playerSpeaker;

	public float volumeMultiplier = 1f;
}


public static class LocalPlayer
{
}


using System;
using UnityEngine;

public class BaseMovement : MonoBehaviour
{
	[NonSerialized]
	public bool adminCheat;

	[NonSerialized]
	public float adminSpeed = 1f;
}


using UnityEngine;

public class PlayerWalkMovement : BaseMovement
{
	public const float WaterLevelHead = 0.75f;

	public const float WaterLevelNeck = 0.65f;

	public PhysicMaterial zeroFrictionMaterial;

	public PhysicMaterial highFrictionMaterial;
}


using System;

public class PlayerCache : StableObjectCache<BasePlayer>
{
	public ValidView<BasePlayer> ValidPlayers => new ValidView<BasePlayer>((StableObjectCache<BasePlayer>)this);

	public ReadOnlySpan<BasePlayer> Players => base.Objects;

	public ReadOnlySpan<BaseEntity> AsEntities
	{
		get
		{
			BaseEntity[] objects = base.Objects;
			return objects;
		}
	}

	public PlayerCache(int initialCapacity)
		: base(initialCapacity)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using UnityEngine;

public class CombatLog
{
	public struct Event
	{
		public float time;

		public ulong attacker_id;

		public ulong target_id;

		public string attacker;

		public string target;

		public string weapon;

		public string ammo;

		public string bone;

		public HitArea area;

		public float distance;

		public float health_old;

		public float health_new;

		public string info;

		public int proj_hits;

		public float proj_integrity;

		public float proj_travel;

		public float proj_mismatch;

		public int desync;

		public bool attacker_dead;
	}

	private const string selfname = "you";

	private const string noname = "N/A";

	private BasePlayer player;

	private Queue<Event> storage;

	private static Dictionary<ulong, Queue<Event>> players = new Dictionary<ulong, Queue<Event>>();

	public float LastActive { get; private set; }

	public CombatLog(BasePlayer player)
	{
		this.player = player;
	}

	public void Init()
	{
		storage = Get(player.userID);
		LastActive = storage.LastOrDefault().time;
	}

	public void Save()
	{
	}

	public void LogInvalid(BasePlayer player, AttackEntity weapon, string description)
	{
		Log(player, weapon, null, description);
	}

	public void LogInvalid(HitInfo info, string description)
	{
		Log(info.Initiator, info.Weapon, info.HitEntity as BaseCombatEntity, description, info.ProjectilePrefab, info.ProjectileID, -1f, info);
	}

	public void LogAttack(HitInfo info, string description, float oldHealth = -1f)
	{
		Log(info.Initiator, info.Weapon, info.HitEntity as BaseCombatEntity, description, info.ProjectilePrefab, info.ProjectileID, oldHealth, info);
	}

	public void Log(BaseEntity attacker, AttackEntity weapon, BaseCombatEntity hitEntity, string description, Projectile projectilePrefab = null, int projectileId = -1, float healthOld = -1f, HitInfo hitInfo = null)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		Event val = default(Event);
		float distance = 0f;
		if (hitInfo != null)
		{
			distance = (hitInfo.IsProjectile() ? hitInfo.ProjectileDistance : Vector3.Distance(hitInfo.PointStart, hitInfo.HitPositionWorld));
			if (hitInfo.Initiator is BasePlayer basePlayer && (Object)(object)hitInfo.HitEntity != (Object)(object)hitInfo.Initiator)
			{
				val.attacker_dead = basePlayer.IsDead() || basePlayer.IsWounded();
			}
		}
		float health_new = (((Object)(object)hitEntity != (Object)null) ? hitEntity.Health() : 0f);
		val.time = Time.realtimeSinceStartup;
		val.attacker_id = ((NetworkableId)(((Object)(object)attacker != (Object)null && attacker.net != null) ? attacker.net.ID : default(NetworkableId))).Value;
		val.target_id = ((NetworkableId)(((Object)(object)hitEntity != (Object)null && hitEntity.net != null) ? hitEntity.net.ID : default(NetworkableId))).Value;
		val.attacker = (((Object)(object)player == (Object)(object)attacker) ? "you" : (attacker?.ShortPrefabName ?? "N/A"));
		val.target = (((Object)(object)player == (Object)(object)hitEntity) ? "you" : (hitEntity?.ShortPrefabName ?? "N/A"));
		val.weapon = (((Object)(object)weapon != (Object)null) ? ((Object)weapon).name : "N/A");
		val.ammo = ((!((Object)(object)projectilePrefab != (Object)null)) ? "N/A" : ((projectilePrefab != null) ? ((Object)projectilePrefab).name : null));
		val.bone = hitInfo?.boneName ?? "N/A";
		val.area = hitInfo?.boneArea ?? ((HitArea)0);
		val.distance = distance;
		val.health_old = ((healthOld == -1f) ? 0f : healthOld);
		val.health_new = health_new;
		val.info = description ?? string.Empty;
		val.proj_hits = hitInfo?.ProjectileHits ?? 0;
		val.proj_integrity = hitInfo?.ProjectileIntegrity ?? 0f;
		val.proj_travel = hitInfo?.ProjectileTravelTime ?? 0f;
		val.proj_mismatch = hitInfo?.ProjectileTrajectoryMismatch ?? 0f;
		BasePlayer basePlayer2 = attacker as BasePlayer;
		if ((Object)(object)basePlayer2 != (Object)null && (Object)(object)projectilePrefab != (Object)null && basePlayer2.firedProjectiles.TryGetValue(projectileId, out var value))
		{
			val.desync = (int)(value.desyncLifeTime * 1000f);
		}
		Log(val);
	}

	private void Log(Event val)
	{
		LastActive = Time.realtimeSinceStartup;
		if (storage != null)
		{
			storage.Enqueue(val);
			int num = Mathf.Max(0, Server.combatlogsize);
			while (storage.Count > num)
			{
				storage.Dequeue();
			}
		}
	}

	public string Get(int count, NetworkableId filterByAttacker = default(NetworkableId), bool json = false, bool isAdmin = false, ulong requestingUser = 0uL)
	{
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		if (storage == null)
		{
			return string.Empty;
		}
		if (storage.Count == 0 && !json)
		{
			return "Combat log empty.";
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !json;
			val.AddColumn("time");
			val.AddColumn("attacker");
			val.AddColumn("id");
			val.AddColumn("target");
			val.AddColumn("id");
			val.AddColumn("weapon");
			val.AddColumn("ammo");
			val.AddColumn("area");
			val.AddColumn("distance");
			val.AddColumn("old_hp");
			val.AddColumn("new_hp");
			val.AddColumn("info");
			val.AddColumn("hits");
			val.AddColumn("integrity");
			val.AddColumn("travel");
			val.AddColumn("mismatch");
			val.AddColumn("desync");
			int num = storage.Count - count;
			int num2 = ((!player.IsAdmin && !player.IsDeveloper) ? Server.combatlogdelay : 0);
			int num3 = 0;
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
			foreach (Event item in storage)
			{
				if (num > 0)
				{
					num--;
				}
				else
				{
					if ((((NetworkableId)(ref filterByAttacker)).IsValid && item.attacker_id != filterByAttacker.Value) || ((Object)(object)activeGameMode != (Object)null && !activeGameMode.returnValidCombatlog && !isAdmin && item.proj_hits > 0))
					{
						continue;
					}
					float num4 = Time.realtimeSinceStartup - item.time;
					if (num4 >= (float)num2)
					{
						string text = num4.ToString("0.00s");
						string attacker = item.attacker;
						ulong attacker_id = item.attacker_id;
						string text2 = attacker_id.ToString();
						string target = item.target;
						attacker_id = item.target_id;
						string text3 = attacker_id.ToString();
						string weapon = item.weapon;
						string ammo = item.ammo;
						string text4 = HitAreaUtil.Format(item.area).ToLower();
						float distance = item.distance;
						string text5 = distance.ToString("0.0m");
						distance = item.health_old;
						string text6 = distance.ToString("0.0");
						distance = item.health_new;
						string text7 = distance.ToString("0.0");
						string text8 = item.info;
						if (!player.IsDestroyed && (ulong)player.userID == requestingUser && item.attacker_dead)
						{
							text8 = "you died first (" + text8 + ")";
						}
						int proj_hits = item.proj_hits;
						string text9 = proj_hits.ToString();
						distance = item.proj_integrity;
						string text10 = distance.ToString("0.00");
						distance = item.proj_travel;
						string text11 = distance.ToString("0.00s");
						distance = item.proj_mismatch;
						string text12 = distance.ToString("0.00m");
						proj_hits = item.desync;
						string text13 = proj_hits.ToString();
						val.AddRow(new string[17]
						{
							text, attacker, text2, target, text3, weapon, ammo, text4, text5, text6,
							text7, text8, text9, text10, text11, text12, text13
						});
					}
					else
					{
						num3++;
					}
				}
			}
			string text14;
			if (json)
			{
				text14 = val.ToJson(true);
			}
			else
			{
				text14 = ((object)val).ToString();
				if (num3 > 0)
				{
					text14 = text14 + "+ " + num3 + " " + ((num3 > 1) ? "events" : "event");
					text14 = text14 + " in the last " + num2 + " " + ((num2 > 1) ? "seconds" : "second");
				}
			}
			return text14;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Queue<Event> Get(ulong id)
	{
		if (players.TryGetValue(id, out var value))
		{
			return value;
		}
		value = new Queue<Event>();
		players.Add(id, value);
		return value;
	}
}


public struct Event
{
	public float time;

	public ulong attacker_id;

	public ulong target_id;

	public string attacker;

	public string target;

	public string weapon;

	public string ammo;

	public string bone;

	public HitArea area;

	public float distance;

	public float health_old;

	public float health_new;

	public string info;

	public int proj_hits;

	public float proj_integrity;

	public float proj_travel;

	public float proj_mismatch;

	public int desync;

	public bool attacker_dead;
}


public enum Stats
{
	Steam = 1,
	Server = 2,
	Life = 4,
	All = -1
}


using ConVar;

public class PlayerStatistics
{
	public SteamStatistics steam;

	public ServerStatistics server;

	public CombatLog combat;

	public BasePlayer forPlayer;

	private TimeSince lastSteamSave;

	public PlayerStatistics(BasePlayer player)
	{
		steam = new SteamStatistics(player);
		server = new ServerStatistics(player);
		combat = new CombatLog(player);
		forPlayer = player;
	}

	public void Init()
	{
		steam.Init();
		server.Init();
		combat.Init();
	}

	public void Save(bool forceSteamSave = false)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (Server.official && (forceSteamSave || TimeSince.op_Implicit(lastSteamSave) > 60f))
		{
			lastSteamSave = TimeSince.op_Implicit(0f);
			steam.Save();
		}
		server.Save();
		combat.Save();
	}

	public void Add(string name, int val, Stats stats = Stats.Steam)
	{
		if ((stats & Stats.Steam) != 0)
		{
			steam.Add(name, val);
		}
		if ((stats & Stats.Server) != 0)
		{
			server.Add(name, val);
		}
		if ((stats & Stats.Life) != 0)
		{
			forPlayer.LifeStoryGenericStat(name, val);
		}
	}
}


using System.Collections.Generic;

public class ServerStatistics
{
	public class Storage
	{
		private Dictionary<string, int> dict = new Dictionary<string, int>();

		public int Get(string name)
		{
			dict.TryGetValue(name, out var value);
			return value;
		}

		public void Add(string name, int val)
		{
			if (dict.ContainsKey(name))
			{
				dict[name] += val;
			}
			else
			{
				dict.Add(name, val);
			}
		}
	}

	private BasePlayer player;

	private Storage storage;

	private static Dictionary<ulong, Storage> players = new Dictionary<ulong, Storage>();

	public ServerStatistics(BasePlayer player)
	{
		this.player = player;
	}

	public void Init()
	{
		storage = Get(player.userID);
	}

	public void Save()
	{
	}

	public void Add(string name, int val)
	{
		if (storage != null)
		{
			storage.Add(name, val);
		}
	}

	public static Storage Get(ulong id)
	{
		if (players.TryGetValue(id, out var value))
		{
			return value;
		}
		value = new Storage();
		players.Add(id, value);
		return value;
	}
}


using System.Collections.Generic;

public class Storage
{
	private Dictionary<string, int> dict = new Dictionary<string, int>();

	public int Get(string name)
	{
		dict.TryGetValue(name, out var value);
		return value;
	}

	public void Add(string name, int val)
	{
		if (dict.ContainsKey(name))
		{
			dict[name] += val;
		}
		else
		{
			dict.Add(name, val);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using ConVar;
using UnityEngine;

public class SteamStatistics
{
	private BasePlayer player;

	public Dictionary<string, int> intStats = new Dictionary<string, int>();

	private Task refresh;

	public SteamStatistics(BasePlayer p)
	{
		player = p;
	}

	public void Init()
	{
		if (PlatformService.Instance.IsValid)
		{
			refresh = PlatformService.Instance.LoadPlayerStats((ulong)player.userID);
			intStats.Clear();
		}
	}

	public void Save()
	{
		if (PlatformService.Instance.IsValid)
		{
			PlatformService.Instance.SavePlayerStats((ulong)player.userID);
		}
	}

	public void Add(string name, int var)
	{
		if (!PlatformService.Instance.IsValid || refresh == null || !refresh.IsCompleted)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("PlayerStats.Add", 0);
		try
		{
			int value = 0;
			if (intStats.TryGetValue(name, out value))
			{
				intStats[name] += var;
				PlatformService.Instance.SetPlayerStatInt((ulong)player.userID, name, (long)intStats[name]);
				return;
			}
			value = (int)PlatformService.Instance.GetPlayerStatInt((ulong)player.userID, name, 0L);
			if (!PlatformService.Instance.SetPlayerStatInt((ulong)player.userID, name, (long)(value + var)))
			{
				if (Global.developer > 0)
				{
					Debug.LogWarning((object)("[STEAMWORKS] Couldn't SetUserStat: " + name));
				}
			}
			else
			{
				intStats.Add(name, value + var);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public int Get(string name)
	{
		if (!PlatformService.Instance.IsValid)
		{
			return 0;
		}
		if (refresh == null || !refresh.IsCompleted)
		{
			return 0;
		}
		TimeWarning val = TimeWarning.New("PlayerStats.Get", 0);
		try
		{
			if (intStats.TryGetValue(name, out var value))
			{
				return value;
			}
			return (int)PlatformService.Instance.GetPlayerStatInt((ulong)player.userID, name, 0L);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class PlayerCorpse : LootableCorpse
{
	public Buoyancy buoyancy;

	public const Flags Flag_Buoyant = Flags.Reserved6;

	public uint underwearSkin;

	public PlayerBonePosData bonePosData;

	public const Flags BlockClothingRebuild = Flags.Reserved2;

	private Vector3 prevLocalPos;

	private const float SLEEP_CHECK_FREQUENCY = 10f;

	public Ragdoll CorpseRagdollScript { get; private set; }

	public override bool CorpseIsRagdoll => (Object)(object)CorpseRagdollScript != (Object)null;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public bool IsBuoyant()
	{
		return HasFlag(Flags.Reserved6);
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		if ((baseEntity.InSafeZone() || InSafeZone()) && (ulong)baseEntity.userID != playerSteamID)
		{
			return false;
		}
		return base.OnStartBeingLooted(baseEntity);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if ((Object)(object)buoyancy == (Object)null)
		{
			Debug.LogWarning((object)("Player corpse has no buoyancy assigned, searching at runtime :" + ((Object)this).name));
			buoyancy = ((Component)this).GetComponent<Buoyancy>();
		}
		if ((Object)(object)buoyancy != (Object)null)
		{
			buoyancy.SubmergedChanged = BuoyancyChanged;
			buoyancy.forEntity = this;
		}
		if (Application.isLoadingSave)
		{
			CorpseRagdollScript = ((Component)this).GetComponent<Ragdoll>();
		}
		if (CorpseIsRagdoll)
		{
			CorpseRagdollScript.simOnServer = true;
			CorpseRagdollScript.ServerInit();
			((FacepunchBehaviour)this).InvokeRandomized((Action)SleepCheck, 5f, 10f, Random.Range(-1f, 1f));
		}
	}

	public override void ServerInitCorpse(BaseEntity pr, Vector3 posOnDeah, Quaternion rotOnDeath, BasePlayer.PlayerFlags playerFlagsOnDeath, ModelState modelState)
	{
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		parentEnt = pr;
		BasePlayer basePlayer = (BasePlayer)pr;
		CorpseRagdollScript = ((Component)this).GetComponent<Ragdoll>();
		SpawnPointInstance component = ((Component)this).GetComponent<SpawnPointInstance>();
		if ((Object)(object)component != (Object)null)
		{
			spawnGroup = component.parentSpawnPointUser as SpawnGroup;
		}
		Skeleton component2 = ((Component)this).GetComponent<Skeleton>();
		if ((Object)(object)component2 != (Object)null)
		{
			PlayerBonePosData.BonePosData bonePositionData = bonePosData.GetBonePositionData(playerFlagsOnDeath, modelState);
			if (bonePositionData != null)
			{
				component2.CopyFrom(bonePositionData.bonePositions, bonePositionData.boneRotations, true);
				Transform transform = component2.Bones[0].transform;
				transform.localEulerAngles += bonePositionData.rootRotationOffset;
			}
		}
		if (CorpseIsRagdoll)
		{
			Quaternion val = (((playerFlagsOnDeath & BasePlayer.PlayerFlags.Sleeping) != 0) ? Quaternion.identity : rotOnDeath);
			((Component)this).transform.SetPositionAndRotation(posOnDeah, val);
		}
		else
		{
			((Component)this).transform.SetPositionAndRotation(parentEnt.CenterPoint(), basePlayer.eyes.bodyRotation);
		}
	}

	public void BuoyancyChanged(bool isSubmerged)
	{
		if (!IsBuoyant())
		{
			SetFlag(Flags.Reserved6, isSubmerged, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}

	public void BecomeActive()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (CorpseIsRagdoll)
		{
			CorpseRagdollScript.BecomeActive();
			prevLocalPos = ((Component)this).transform.localPosition;
		}
	}

	public void BecomeInactive()
	{
		if (CorpseIsRagdoll)
		{
			CorpseRagdollScript.BecomeInactive();
		}
	}

	protected override void PushRagdoll(HitInfo info)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (CorpseIsRagdoll)
		{
			BecomeActive();
			PushRigidbodies(CorpseRagdollScript.rigidbodies, info.HitPositionWorld, info.attackNormal);
		}
		else
		{
			base.PushRagdoll(info);
		}
	}

	private void SleepCheck()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (!CorpseIsRagdoll)
		{
			return;
		}
		if (CorpseRagdollScript.IsKinematic)
		{
			if (!GamePhysics.Trace(new Ray(CenterPoint(), Vector3.down), 0f, out var _, 0.25f, -928830701, (QueryTriggerInteraction)1, this))
			{
				BecomeActive();
			}
		}
		else if (!rigidBody.IsSleeping() && !buoyancy.ShouldWake() && Vector3.SqrMagnitude(((Component)this).transform.localPosition - prevLocalPos) < 0.1f)
		{
			BecomeInactive();
		}
		prevLocalPos = ((Component)this).transform.localPosition;
	}

	public override bool BuoyancySleep(bool inWater)
	{
		if (CorpseIsRagdoll)
		{
			if (!rigidBody.IsSleeping())
			{
				BecomeInactive();
			}
			return true;
		}
		return base.BuoyancySleep(inWater);
	}

	public override bool BuoyancyWake()
	{
		if (CorpseIsRagdoll)
		{
			BecomeActive();
			return true;
		}
		return base.BuoyancyWake();
	}

	public override float BoundsPadding()
	{
		return 0.9f;
	}

	private void OnPhysicsNeighbourChanged()
	{
		BecomeActive();
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.lootableCorpse != null)
		{
			info.msg.lootableCorpse.underwearSkin = underwearSkin;
		}
		if (base.isServer && containers != null && containers.Length > 1 && !info.forDisk)
		{
			info.msg.storageBox = Pool.Get<StorageBox>();
			info.msg.storageBox.contents = containers[1].Save();
		}
	}

	public override string Categorize()
	{
		return "playercorpse";
	}
}


public class PointEntity : BaseEntity
{
}


using UnityEngine;

public class PropSway : MonoBehaviour
{
	public Transform pivotRotator;

	public float swaySpeed = 1f;

	public float swayDistance = 0.25f;

	public float lerpSpeed = 2f;
}


using ConVar;
using UnityEngine;

public class BushEntity : BaseEntity, IPrefabPreProcess
{
	public GameObjectRef prefab;

	public bool globalBillboard = true;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			DecorComponent[] components = PrefabAttribute.server.FindAll<DecorComponent>(prefabID);
			((Component)this).transform.ApplyDecorComponentsScaleOnly(components);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (globalBillboard)
		{
			TreeManager.OnTreeSpawned(this);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (globalBillboard)
		{
			TreeManager.OnTreeDestroyed(this);
		}
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (serverside)
		{
			globalBroadcast = Tree.global_broadcast;
		}
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class RandomItemDispenser : PrefabAttribute, IServerComponent
{
	[Serializable]
	public struct RandomItemChance
	{
		public ItemDefinition Item;

		public int Amount;

		[Range(0f, 1f)]
		public float Chance;

		public bool IgnoreInTutorial;
	}

	public RandomItemChance[] Chances;

	public bool OnlyAwardOne = true;

	protected override Type GetIndexedType()
	{
		return typeof(RandomItemDispenser);
	}

	public void DistributeItems(BasePlayer forPlayer, Vector3 distributorPosition)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		RandomItemChance[] chances = Chances;
		for (int i = 0; i < chances.Length; i++)
		{
			RandomItemChance itemChance = chances[i];
			if (!((Object)(object)forPlayer != (Object)null) || !forPlayer.IsInTutorial || !itemChance.IgnoreInTutorial)
			{
				bool flag = TryAward(itemChance, forPlayer, distributorPosition);
				if (OnlyAwardOne && flag)
				{
					break;
				}
			}
		}
	}

	private bool TryAward(RandomItemChance itemChance, BasePlayer forPlayer, Vector3 distributorPosition)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnRandomItemAward", (object)this, (object)itemChance, (object)forPlayer, (object)distributorPosition) != null)
		{
			return false;
		}
		float num = Random.Range(0f, 1f);
		if (itemChance.Chance >= num)
		{
			Item item = ItemManager.Create(itemChance.Item, itemChance.Amount, 0uL);
			if (item != null)
			{
				item.SetItemOwnership(forPlayer, ItemOwnershipPhrases.GatheredPhrase);
				if (Object.op_Implicit((Object)(object)forPlayer))
				{
					forPlayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
				}
				else
				{
					item.Drop(distributorPosition + Vector3.up * 0.5f, Vector3.up);
				}
			}
			return true;
		}
		return false;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct RandomItemChance
{
	public ItemDefinition Item;

	public int Amount;

	[Range(0f, 1f)]
	public float Chance;

	public bool IgnoreInTutorial;
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Serialization;

public class ResourceEntity : BaseEntity
{
	[FormerlySerializedAs("health")]
	public float startHealth;

	[FormerlySerializedAs("protection")]
	public ProtectionProperties baseProtection;

	public float health;

	public ResourceDispenser resourceDispenser;

	[NonSerialized]
	protected bool isKilled;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.resource != null)
		{
			health = info.msg.resource.health;
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			DecorComponent[] components = PrefabAttribute.server.FindAll<DecorComponent>(prefabID);
			((Component)this).transform.ApplyDecorComponentsScaleOnly(components);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		resourceDispenser = ((Component)this).GetComponent<ResourceDispenser>();
		if (health == 0f)
		{
			health = startHealth;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.resource = Pool.Get<BaseResource>();
			info.msg.resource.health = Health();
		}
	}

	public override float MaxHealth()
	{
		return startHealth;
	}

	public override float Health()
	{
		return health;
	}

	protected virtual void OnHealthChanged()
	{
	}

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isServer || isKilled || Interface.CallHook("OnEntityTakeDamage", (object)this, (object)info) != null)
		{
			return;
		}
		if ((Object)(object)resourceDispenser != (Object)null)
		{
			resourceDispenser.OnAttacked(info);
		}
		if (!info.DidGather)
		{
			if (Object.op_Implicit((Object)(object)baseProtection))
			{
				baseProtection.Scale(info.damageTypes);
			}
			float num = info.damageTypes.Total();
			health -= num;
			if (health <= 0f)
			{
				OnDied(info);
			}
			else
			{
				OnHealthChanged();
			}
		}
	}

	public virtual void OnDied(HitInfo info)
	{
		isKilled = true;
		Interface.CallHook("OnEntityDeath", (object)this, (object)info);
		Kill();
	}

	public override float BoundsPadding()
	{
		return 1f;
	}
}


using UnityEngine;

public class StagedResourceBreakEffect : MonoBehaviour, IEffect
{
}


using System;
using UnityEngine;

public class StagedResourceEntityInfo : PrefabAttribute
{
	[Serializable]
	public class ResourceStage
	{
		public float Health;

		public Mesh CollisionMesh;

		public Mesh[] VisualMeshLods;
	}

	public ResourceStage[] Stages;

	public Mesh GetCollisionMesh(int index)
	{
		index = Mathf.Clamp(index, 0, Stages.Length);
		return Stages[index].CollisionMesh;
	}

	public Mesh[] GetVisualMeshLods(int index)
	{
		index = Mathf.Clamp(index, 0, Stages.Length);
		return Stages[index].VisualMeshLods;
	}

	public float GetHealth(int index)
	{
		index = Mathf.Clamp(index, 0, Stages.Length);
		return Stages[index].Health;
	}

	protected override Type GetIndexedType()
	{
		return typeof(StagedResourceEntityInfo);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResourceStage
{
	public float Health;

	public Mesh CollisionMesh;

	public Mesh[] VisualMeshLods;
}


using System;
using UnityEngine;

public class TreeMarkerData : PrefabAttribute, IServerComponent
{
	[Serializable]
	public struct MarkerLocation
	{
		public Vector3 LocalPosition;

		public Vector3 LocalNormal;
	}

	[Serializable]
	public struct GenerationArc
	{
		public Vector3 CentrePoint;

		public float Radius;

		public Vector3 Rotation;

		public int OverrideCount;
	}

	public GenerationArc[] GenerationArcs;

	public MarkerLocation[] Markers;

	public Vector3 GenerationStartPoint = Vector3.up * 2f;

	public float GenerationRadius = 2f;

	public float MaxY = 1.7f;

	public float MinY = 0.2f;

	public bool ProcessAngleChecks;

	protected override Type GetIndexedType()
	{
		return typeof(TreeMarkerData);
	}

	public Vector3 GetNearbyPoint(Vector3 point, ref int ignoreIndex, out Vector3 normal)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		int num = Markers.Length;
		if (ignoreIndex != -1 && ProcessAngleChecks)
		{
			ignoreIndex++;
			if (ignoreIndex >= num)
			{
				ignoreIndex = 0;
			}
			normal = Markers[ignoreIndex].LocalNormal;
			return Markers[ignoreIndex].LocalPosition;
		}
		int num2 = Random.Range(0, num);
		float num3 = float.MaxValue;
		int num4 = -1;
		for (int i = 0; i < num; i++)
		{
			if (ignoreIndex == num2)
			{
				continue;
			}
			MarkerLocation markerLocation = Markers[num2];
			if (!(markerLocation.LocalPosition.y < MinY))
			{
				Vector3 val = markerLocation.LocalPosition;
				val.y = Mathf.Lerp(val.y, point.y, 0.5f);
				Vector3 val2 = val - point;
				float sqrMagnitude = ((Vector3)(ref val2)).sqrMagnitude;
				sqrMagnitude *= Random.Range(0.95f, 1.05f);
				if (sqrMagnitude < num3)
				{
					num3 = sqrMagnitude;
					num4 = num2;
				}
				num2++;
				if (num2 >= num)
				{
					num2 = 0;
				}
			}
		}
		if (num4 > -1)
		{
			normal = Markers[num4].LocalNormal;
			ignoreIndex = num4;
			return Markers[num4].LocalPosition;
		}
		normal = Markers[0].LocalNormal;
		return Markers[0].LocalPosition;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct MarkerLocation
{
	public Vector3 LocalPosition;

	public Vector3 LocalNormal;
}


using System;
using UnityEngine;

[Serializable]
public struct GenerationArc
{
	public Vector3 CentrePoint;

	public float Radius;

	public Vector3 Rotation;

	public int OverrideCount;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class VineSwingingTree : TreeEntity
{
	public GameObjectRef StumpPrefab;

	public MeshRenderer[] BranchRenderers;

	public GameObject[] BranchRoots;

	public MeshRenderer BranchHighlightRenderer;

	public float VineSpawnHeight = 15f;

	public float VineSpawnRadius = 5f;

	public VineLaunchPoint[] LaunchPoints;

	public Collider[] ClimbColliders;

	public Collider StumpCollider;

	public List<EntityRef<VineMountable>> SpawnedVines = new List<EntityRef<VineMountable>>();

	public VineMountable GetSpawnedVine(VineLaunchPoint point)
	{
		int index = point.Index();
		EnsureVineArrayLength(index);
		return SpawnedVines[index].Get(base.isServer);
	}

	private void EnsureVineArrayLength(int index)
	{
		if (SpawnedVines.Count <= index)
		{
			while (SpawnedVines.Count <= index)
			{
				SpawnedVines.Add(default(EntityRef<VineMountable>));
			}
		}
	}

	public void SetSpawnedVine(VineLaunchPoint point, VineMountable vine)
	{
		int index = point.Index();
		EnsureVineArrayLength(index);
		EntityRef<VineMountable> value = default(EntityRef<VineMountable>);
		value.Set(vine);
		SpawnedVines[index] = value;
	}

	public Vector3 GetVineSpawnPos(List<VineLaunchPoint> possibleDestinations)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		if (possibleDestinations.Count == 0)
		{
			return Vector3.zero;
		}
		Vector3 val = Vector3.zero;
		foreach (VineLaunchPoint possibleDestination in possibleDestinations)
		{
			val += ((Component)possibleDestination).transform.position;
		}
		val /= (float)possibleDestinations.Count;
		Vector3 val2 = ((Component)this).transform.position + ((Component)this).transform.up * VineSpawnHeight;
		val = Vector3Ex.WithY(val, val2.y);
		Vector3 val3 = val - val2;
		Vector3 normalized = ((Vector3)(ref val3)).normalized;
		return val2 + normalized * VineSpawnRadius;
	}

	public override void InitShared()
	{
		base.InitShared();
		GameObject[] branchRoots = BranchRoots;
		foreach (GameObject val in branchRoots)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.SetActive(true);
			}
		}
		if ((Object)(object)StumpCollider != (Object)null)
		{
			StumpCollider.enabled = false;
		}
	}

	public void RefreshVineState()
	{
		if (Application.isLoading)
		{
			((FacepunchBehaviour)this).Invoke((Action)RefreshVineState, 0.25f);
			return;
		}
		VineLaunchPoint[] launchPoints = LaunchPoints;
		for (int i = 0; i < launchPoints.Length; i++)
		{
			launchPoints[i].SpawnVineIfPossible(this);
		}
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		RefreshVineState();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		VineLaunchPoint[] launchPoints = LaunchPoints;
		for (int i = 0; i < launchPoints.Length; i++)
		{
			launchPoints[i].ServerInit();
		}
		((FacepunchBehaviour)this).Invoke((Action)RefreshVineState, 0.25f);
	}

	internal override void DoServerDestroy()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		VineLaunchPoint[] launchPoints = LaunchPoints;
		foreach (VineLaunchPoint vineLaunchPoint in launchPoints)
		{
			if ((Object)(object)vineLaunchPoint != (Object)null)
			{
				vineLaunchPoint.DoServerDestroy();
			}
		}
		if (StumpPrefab.isValid)
		{
			VineSwingingTreeStump obj = base.gameManager.CreateEntity(StumpPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation) as VineSwingingTreeStump;
			obj.InitializeTree(this);
			obj.Spawn();
		}
	}

	public void NotifyNearbyTreesSpawned()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		PooledList<VineSwingingTree> val = Pool.Get<PooledList<VineSwingingTree>>();
		try
		{
			Vis.Entities(((Component)this).transform.position, 64f, (List<VineSwingingTree>)(object)val, 1073741824, (QueryTriggerInteraction)2);
			foreach (VineSwingingTree item in (List<VineSwingingTree>)(object)val)
			{
				if (!item.isClient && !((Object)(object)item == (Object)(object)this))
				{
					item.RefreshVineState();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.vineTree = Pool.Get<VineTree>();
		info.msg.vineTree.spawnedVines = Pool.Get<List<NetworkableId>>();
		foreach (EntityRef<VineMountable> spawnedVine in SpawnedVines)
		{
			info.msg.vineTree.spawnedVines.Add(spawnedVine.uid);
		}
	}

	protected override void OnFallServer()
	{
		base.OnFallServer();
		ToggleClimbColliders(state: false);
		GameObject[] branchRoots = BranchRoots;
		foreach (GameObject val in branchRoots)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.SetActive(false);
			}
		}
		PooledList<Collider> val2 = Pool.Get<PooledList<Collider>>();
		try
		{
			((Component)this).GetComponentsInChildren<Collider>((List<Collider>)(object)val2);
			foreach (Collider item in (List<Collider>)(object)val2)
			{
				if (!item.isTrigger)
				{
					item.enabled = false;
				}
			}
			VineLaunchPoint[] launchPoints = LaunchPoints;
			for (int i = 0; i < launchPoints.Length; i++)
			{
				launchPoints[i].DoServerDestroy();
			}
			if ((Object)(object)StumpCollider != (Object)null)
			{
				StumpCollider.enabled = true;
			}
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		base.OnAttacked(info);
		if ((Object)(object)info.InitiatorPlayer == (Object)null || base.isClient)
		{
			return;
		}
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			VineMountable.pointGrid.Query<VineMountable>(((Component)this).transform.position.x, ((Component)this).transform.position.z, 10f, (List<VineMountable>)(object)val);
			foreach (VineMountable item in (List<VineMountable>)(object)val)
			{
				if (!item.IsOn())
				{
					VineLaunchPoint vineLaunchPoint = item.currentLocation.Get(isServer: true);
					if ((Object)(object)vineLaunchPoint != (Object)null && (Object)(object)vineLaunchPoint.ParentTree == (Object)(object)this && item.AttackedByPlayer(info.InitiatorPlayer))
					{
						break;
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.vineTree == null || info.msg.vineTree.spawnedVines == null)
		{
			return;
		}
		SpawnedVines.Clear();
		foreach (NetworkableId spawnedVine in info.msg.vineTree.spawnedVines)
		{
			SpawnedVines.Add(new EntityRef<VineMountable>(spawnedVine));
		}
	}

	private void ToggleClimbColliders(bool state)
	{
		Collider[] climbColliders = ClimbColliders;
		foreach (Collider val in climbColliders)
		{
			if ((Object)(object)val != (Object)null)
			{
				((Component)val).gameObject.SetActive(state);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class VineSwingingTreeStump : BaseEntity
{
	public GameObjectRef[] TreePrefabs;

	public float MaxTreeRespawnTime = 5f;

	public float MinTreeRespawnTime = 10f;

	public GameObject PreventBuildingVolume;

	private TimeUntil treeRespawnTime;

	private int treeToRespawn;

	public void InitializeTree(VineSwingingTree fromTree)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		treeRespawnTime = TimeUntil.op_Implicit(Random.Range(MinTreeRespawnTime, MaxTreeRespawnTime));
		((FacepunchBehaviour)this).Invoke((Action)RespawnTreeInvoke, TimeUntil.op_Implicit(treeRespawnTime));
		treeToRespawn = 0;
		for (int i = 0; i < TreePrefabs.Length; i++)
		{
			if (TreePrefabs[i].resourceID == fromTree.prefabID)
			{
				treeToRespawn = i;
				break;
			}
		}
	}

	private void RespawnTreeInvoke()
	{
		RespawnTree();
	}

	public bool RespawnTree()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		GameObjectRef gameObjectRef = TreePrefabs[Mathf.Clamp(treeToRespawn, 0, TreePrefabs.Length)];
		if (gameObjectRef.isValid)
		{
			if (!IsTreeRespawnClear())
			{
				((FacepunchBehaviour)this).Invoke((Action)RespawnTreeInvoke, 10f);
				return false;
			}
			VineSwingingTree obj = base.gameManager.CreateEntity(gameObjectRef.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation) as VineSwingingTree;
			obj.Spawn();
			obj.NotifyNearbyTreesSpawned();
			Kill();
			return true;
		}
		return false;
	}

	private bool IsTreeRespawnClear()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		PooledList<Collider> val = Pool.Get<PooledList<Collider>>();
		try
		{
			PreventBuildingVolume.GetComponents<Collider>((List<Collider>)(object)val);
			Vector3 val4 = default(Vector3);
			foreach (Collider item in (List<Collider>)(object)val)
			{
				BoxCollider val2 = (BoxCollider)(object)((item is BoxCollider) ? item : null);
				if (val2 != null)
				{
					if (GamePhysics.CheckOBB(new OBB(PreventBuildingVolume.transform, new Bounds(val2.center, val2.size)), 131072, (QueryTriggerInteraction)0))
					{
						return false;
					}
					continue;
				}
				CapsuleCollider val3 = (CapsuleCollider)(object)((item is CapsuleCollider) ? item : null);
				if (val3 != null)
				{
					((Vector3)(ref val4))..ctor(0f, val3.height * 0.5f, 0f);
					if (GamePhysics.CheckCapsule(((Component)item).transform.TransformPoint(val3.center + val4), ((Component)item).transform.TransformPoint(val3.center - val4), val3.radius, 131072, (QueryTriggerInteraction)0))
					{
						return false;
					}
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.treeRespawn = Pool.Get<TreeRespawn>();
			info.msg.treeRespawn.timeToRespawn = TimeUntil.op_Implicit(treeRespawnTime);
			info.msg.treeRespawn.treeIndex = treeToRespawn;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.fromDisk && info.msg.treeRespawn != null)
		{
			treeRespawnTime = TimeUntil.op_Implicit(info.msg.treeRespawn.timeToRespawn);
			treeToRespawn = info.msg.treeRespawn.treeIndex;
			((FacepunchBehaviour)this).Invoke((Action)RespawnTreeInvoke, TimeUntil.op_Implicit(treeRespawnTime));
		}
	}
}


using Oxide.Core;
using UnityEngine;

public class RoadFlare : TimedExplosive, SeekerTarget.ISeekerTargetOwner
{
	public LightEx FlareLightEx;

	public override void ServerInit()
	{
		base.ServerInit();
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.HIGH);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.OnCollision(collision, hitEntity);
	}

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	internal override void DoServerDestroy()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.DoServerDestroy();
	}
}


using Facepunch;
using ProtoBuf;

public class AssociatedSculptureStorage : BaseEntity
{
	public uint Crc;

	public void InitFromSculpture(uint crc, NetworkableId id)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		Crc = crc;
		FileStorage.server.ReassignEntityId(id, net.ID);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseSculpture = Pool.Get<BaseSculpture>();
		info.msg.baseSculpture.crc = Crc;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		Crc = (uint)(((int?)info.msg.baseSculpture?.crc) ?? (-1));
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct AddAndBlurSphereJob : IJob
{
	public Point3DGrid Grid;

	public int3 Origin;

	public int R;

	public void Execute()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		int num = R * R;
		int3 val = default(int3);
		for (int i = -R; i <= R; i++)
		{
			for (int j = -R; j <= R; j++)
			{
				for (int k = -R; k <= R; k++)
				{
					((int3)(ref val))..ctor(i, j, k);
					int3 val2 = Origin + val;
					if (!(math.distancesq(float3.op_Implicit(val2), float3.op_Implicit(Origin)) > (float)num) && Grid.InBoundsNotTouching(val2))
					{
						Grid[val2] = true;
					}
				}
			}
		}
		int3 val3 = default(int3);
		for (int l = -R; l <= R; l++)
		{
			for (int m = -R; m <= R; m++)
			{
				for (int n = -R; n <= R; n++)
				{
					((int3)(ref val3))..ctor(l, m, n);
					int3 val4 = Origin + val3;
					if (math.distancesq(float3.op_Implicit(val4), float3.op_Implicit(Origin)) > (float)num || !Grid.InBoundsNotTouching(val4))
					{
						continue;
					}
					float num2 = 0f;
					int num3 = 0;
					for (int num4 = -1; num4 <= 1; num4++)
					{
						for (int num5 = -1; num5 <= 1; num5++)
						{
							for (int num6 = -1; num6 <= 1; num6++)
							{
								if (num4 != 0 || num5 != 0 || num6 != 0)
								{
									int3 val5 = val4 + new int3(num4, num5, num6);
									if (Grid.InBounds(val5))
									{
										num2 += Grid.Sample(val5);
										num3++;
									}
								}
							}
						}
					}
					Grid[val4] = num2 / (float)num3 > 0.5f;
				}
			}
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct BoxBlur3DJob : IJobFor
{
	[ReadOnly]
	public Point3DGrid InputGrid;

	public NativeBitArray OutputGrid;

	public int Width;

	public int WidthHeight;

	public void Execute(int index)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		int3 val = default(int3);
		((int3)(ref val))..ctor(index % Width, index % WidthHeight / Width, index / WidthHeight);
		bool flag = InputGrid[index];
		if (!InputGrid.InBoundsNotTouching(val))
		{
			((NativeBitArray)(ref OutputGrid)).Set(index, false);
			return;
		}
		float num = 0f;
		for (int i = -1; i <= 1; i++)
		{
			for (int j = -1; j <= 1; j++)
			{
				for (int k = -1; k <= 1; k++)
				{
					if (i != 0 || j != 0 || k != 0)
					{
						num += InputGrid.Sample(val + new int3(i, j, k));
					}
				}
			}
		}
		bool flag2 = num / 26f >= (flag ? 0.33f : 0.66f);
		if (flag2 != flag)
		{
			flag2 = flag2 || flag2;
		}
		((NativeBitArray)(ref OutputGrid)).Set(index, flag2);
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
public struct BoxBlurCylinderJob : IJob
{
	public Point3DGrid Grid;

	public float3 P0;

	public float3 P1;

	public float R;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		float3 val = math.float3(R);
		float3 val2 = math.min(P0, P1) - val;
		float3 val3 = math.max(P0, P1) + val;
		float3 val4 = P1 - P0;
		float v = math.dot(val4, val4);
		float r = R * R;
		for (float num = val2.x; num <= val3.x; num += 1f)
		{
			for (float num2 = val2.y; num2 <= val3.y; num2 += 1f)
			{
				for (float num3 = val2.z; num3 <= val3.z; num3 += 1f)
				{
					float3 val5 = math.float3(num, num2, num3);
					int3 val6 = math.int3(val5);
					if (!Grid.InBoundsNotTouching(val6) || !SculptMathUtil.InFlatEndedCapsule(P0, val4, v, r, val5))
					{
						continue;
					}
					float num4 = 0f;
					int num5 = 0;
					for (int i = -1; i <= 1; i++)
					{
						for (int j = -1; j <= 1; j++)
						{
							for (int k = -1; k <= 1; k++)
							{
								if (i != 0 || j != 0 || k != 0)
								{
									int3 val7 = val6 + new int3(i, j, k);
									if (Grid.InBounds(val7))
									{
										num4 += Grid.Sample(val7);
										num5++;
									}
								}
							}
						}
					}
					Grid[val6] = num4 / (float)num5 > 0.5f;
				}
			}
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct BoxBlurSphereJob : IJob
{
	public Point3DGrid Grid;

	public int3 Origin;

	public int R;

	public void Execute()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		int num = R * R;
		int3 val = default(int3);
		for (int i = -R; i <= R; i++)
		{
			for (int j = -R; j <= R; j++)
			{
				for (int k = -R; k <= R; k++)
				{
					((int3)(ref val))..ctor(i, j, k);
					int3 val2 = Origin + val;
					if (math.distancesq(float3.op_Implicit(val2), float3.op_Implicit(Origin)) > (float)num || !Grid.InBoundsNotTouching(val2))
					{
						continue;
					}
					float num2 = 0f;
					int num3 = 0;
					for (int l = -1; l <= 1; l++)
					{
						for (int m = -1; m <= 1; m++)
						{
							for (int n = -1; n <= 1; n++)
							{
								if (l != 0 || m != 0 || n != 0)
								{
									int3 val3 = val2 + new int3(l, m, n);
									if (Grid.InBounds(val3))
									{
										num2 += Grid.Sample(val3);
										num3++;
									}
								}
							}
						}
					}
					Grid[val2] = num2 / (float)num3 > 0.5f;
				}
			}
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
public struct CarveAndBlurCylinderJob : IJob
{
	public Point3DGrid Grid;

	public float3 P0;

	public float3 P1;

	public float R;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		float3 val = math.float3(R);
		float3 val2 = math.min(P0, P1) - val;
		float3 val3 = math.max(P0, P1) + val;
		float3 val4 = P1 - P0;
		float v = math.dot(val4, val4);
		float num = R * R;
		NativeList<int3> val5 = default(NativeList<int3>);
		val5..ctor((int)num, AllocatorHandle.op_Implicit((Allocator)2));
		for (float num2 = val2.x; num2 <= val3.x; num2 += 1f)
		{
			for (float num3 = val2.y; num3 <= val3.y; num3 += 1f)
			{
				for (float num4 = val2.z; num4 <= val3.z; num4 += 1f)
				{
					float3 val6 = math.float3(num2, num3, num4);
					int3 p = math.int3(val6);
					if (Grid.InBounds(p) && SculptMathUtil.InFlatEndedCapsule(P0, val4, v, num, val6))
					{
						Grid[p] = false;
						val5.Add(ref p);
					}
				}
			}
		}
		NativeArray<int3> val7 = val5.AsArray();
		int length = val5.Length;
		for (int i = 0; i < length; i++)
		{
			int3 val8 = val7[i];
			if (!Grid.InBoundsNotTouching(val8))
			{
				continue;
			}
			float num5 = 0f;
			int num6 = 0;
			for (int j = -1; j <= 1; j++)
			{
				for (int k = -1; k <= 1; k++)
				{
					for (int l = -1; l <= 1; l++)
					{
						if (j != 0 || k != 0 || l != 0)
						{
							int3 val9 = val8 + new int3(j, k, l);
							if (Grid.InBounds(val9))
							{
								num5 += Grid.Sample(val9);
								num6++;
							}
						}
					}
				}
			}
			Grid[val8] = num5 / (float)num6 > 0.5f;
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct CarveAndBlurSphereJob : IJob
{
	public Point3DGrid Grid;

	public int3 Origin;

	public int R;

	public void Execute()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		int num = R * R;
		int3 val = default(int3);
		for (int i = -R; i <= R; i++)
		{
			for (int j = -R; j <= R; j++)
			{
				for (int k = -R; k <= R; k++)
				{
					((int3)(ref val))..ctor(i, j, k);
					int3 val2 = Origin + val;
					if (!(math.distancesq(float3.op_Implicit(val2), float3.op_Implicit(Origin)) > (float)num) && Grid.InBounds(val2))
					{
						Grid[val2] = false;
					}
				}
			}
		}
		int3 val3 = default(int3);
		for (int l = -R; l <= R; l++)
		{
			for (int m = -R; m <= R; m++)
			{
				for (int n = -R; n <= R; n++)
				{
					((int3)(ref val3))..ctor(l, m, n);
					int3 val4 = Origin + val3;
					if (math.distancesq(float3.op_Implicit(val4), float3.op_Implicit(Origin)) > (float)num || !Grid.InBoundsNotTouching(val4))
					{
						continue;
					}
					float num2 = 0f;
					int num3 = 0;
					for (int num4 = -1; num4 <= 1; num4++)
					{
						for (int num5 = -1; num5 <= 1; num5++)
						{
							for (int num6 = -1; num6 <= 1; num6++)
							{
								if (num4 != 0 || num5 != 0 || num6 != 0)
								{
									int3 val5 = val4 + new int3(num4, num5, num6);
									if (Grid.InBounds(val5))
									{
										num2 += Grid.Sample(val5);
										num3++;
									}
								}
							}
						}
					}
					Grid[val4] = num2 / (float)num3 > 0.5f;
				}
			}
		}
	}
}


using System;
using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Profiling;

[BurstCompile]
internal struct CleanFloatingIslandsJob : IJob
{
	private struct NativeStack : IDisposable
	{
		public NativeList<int3> arr;

		public NativeStack(Allocator allocator)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			arr = new NativeList<int3>(AllocatorHandle.op_Implicit(allocator));
		}

		public void Dispose()
		{
			arr.Dispose();
		}

		public void Push(int3 v)
		{
			arr.Add(ref v);
		}

		public bool TryPop(out int3 v)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			v = default(int3);
			if (arr.Length == 0)
			{
				return false;
			}
			v = arr[arr.Length - 1];
			arr.RemoveAtSwapBack(arr.Length - 1);
			return true;
		}
	}

	public Point3DGrid Sampler;

	public static readonly ProfilerMarker k_Init = new ProfilerMarker("Init");

	public static readonly ProfilerMarker k_Flood = new ProfilerMarker("Flood");

	public static readonly ProfilerMarker k_Copy = new ProfilerMarker("CopyBack");

	public void Execute()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray other = default(NativeBitArray);
		((NativeBitArray)(ref other))..ctor(Sampler.Length, AllocatorHandle.op_Implicit((Allocator)2), (NativeArrayOptions)1);
		NativeStack nativeStack = new NativeStack((Allocator)2);
		int width = Sampler.Width;
		int depth = Sampler.Depth;
		int3 val = default(int3);
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < depth; j++)
			{
				((int3)(ref val))..ctor(i, 1, j);
				int num = Sampler.ToIndex(val);
				if (Sampler[num])
				{
					nativeStack.Push(val);
					((NativeBitArray)(ref other)).Set(num, true);
				}
			}
		}
		int3 v;
		int3 val2 = default(int3);
		while (nativeStack.TryPop(out v))
		{
			int num2 = v.x - 1;
			((int3)(ref val2))..ctor(num2, ((int3)(ref v)).yz);
			int num3 = 0;
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(--num2, ((int3)(ref v)).yz);
			}
			int num4 = v.x + 1;
			((int3)(ref val2))..ctor(num4, ((int3)(ref v)).yz);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(++num4, ((int3)(ref v)).yz);
			}
			int num5 = v.z - 1;
			((int3)(ref val2))..ctor(((int3)(ref v)).xy, num5);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(((int3)(ref v)).xy, --num5);
			}
			int num6 = v.z + 1;
			((int3)(ref val2))..ctor(((int3)(ref v)).xy, num6);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(((int3)(ref v)).xy, ++num6);
			}
			for (int k = num2; k < num4; k++)
			{
				for (int l = num5; l < num6; l++)
				{
					for (int m = -1; m <= 1; m += 2)
					{
						((int3)(ref val2))..ctor(k, v.y + m, l);
						if (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
						{
							nativeStack.Push(val2);
							((NativeBitArray)(ref other)).Set(num3, true);
						}
					}
				}
			}
		}
		Sampler.CopyFromNativeBitArray(ref other);
	}
}


using System;
using Unity.Collections;
using Unity.Mathematics;

private struct NativeStack : IDisposable
{
	public NativeList<int3> arr;

	public NativeStack(Allocator allocator)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		arr = new NativeList<int3>(AllocatorHandle.op_Implicit(allocator));
	}

	public void Dispose()
	{
		arr.Dispose();
	}

	public void Push(int3 v)
	{
		arr.Add(ref v);
	}

	public bool TryPop(out int3 v)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		v = default(int3);
		if (arr.Length == 0)
		{
			return false;
		}
		v = arr[arr.Length - 1];
		arr.RemoveAtSwapBack(arr.Length - 1);
		return true;
	}
}


using Unity.Mathematics;

public static class SculptMathUtil
{
	public static bool InFlatEndedCapsule(float3 p0, float3 v, float v2, float r2, float3 check)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		float3 val = check - p0;
		if (math.dot(val, v) > v2)
		{
			return false;
		}
		return math.lengthsq(math.cross(val, v)) * math.rcp(v2) <= r2;
	}
}


using System;
using UnityEngine;

public class SculptingToolData : PrefabAttribute
{
	public enum CarvingShapeType
	{
		Cylinder,
		Sphere,
		Rectangle
	}

	[Flags]
	public enum CarvingMode
	{
		Carve = 1,
		Smooth = 2,
		Additive = 4
	}

	public CarvingShapeType CarvingShape;

	public CarvingMode CarvingModes = CarvingMode.Carve | CarvingMode.Smooth | CarvingMode.Additive;

	public Vector2Int CarvingSizeLimits = new Vector2Int(2, 5);

	public bool AllowCarve => (CarvingModes & CarvingMode.Carve) != 0;

	public bool AllowSmooth => (CarvingModes & CarvingMode.Smooth) != 0;

	public bool AllowAdditive => (CarvingModes & CarvingMode.Additive) != 0;

	public int MinCarvingSize => ((Vector2Int)(ref CarvingSizeLimits)).x;

	public int MaxCarvingSize => ((Vector2Int)(ref CarvingSizeLimits)).y;

	protected override Type GetIndexedType()
	{
		return typeof(SculptingToolData);
	}
}


public enum CarvingShapeType
{
	Cylinder,
	Sphere,
	Rectangle
}


using System;

[Flags]
public enum CarvingMode
{
	Carve = 1,
	Smooth = 2,
	Additive = 4
}


public class SeasonalTimedExplosive : TimedExplosive
{
	public RandomRendererEnable randomRenderer;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ServerProjectile : EntityComponent<BaseEntity>
{
	public interface IProjectileImpact
	{
		void ProjectileImpact(RaycastHit hitInfo, Vector3 rayOrigin);
	}

	public Vector3 initialVelocity;

	public float drag;

	public float gravityModifier = 1f;

	public float speed = 15f;

	public float scanRange;

	public Vector3 swimScale;

	public Vector3 swimSpeed;

	public float radius;

	public bool IgnoreAI;

	[HideInInspector]
	public BaseEntity ignoreEntity;

	protected bool shouldMoveProjectile = true;

	public bool impacted;

	public float swimRandom;

	public virtual bool HasRangeLimit => true;

	protected virtual int mask => 1237003025;

	public Vector3 CurrentVelocity { get; set; }

	public bool Impacted => impacted;

	public float GetMaxRange(float maxFuseTime)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (gravityModifier == 0f)
		{
			return float.PositiveInfinity;
		}
		float num = Mathf.Sin(MathF.PI / 2f) * speed * speed / (0f - Physics.gravity.y * gravityModifier);
		float num2 = speed * maxFuseTime;
		return Mathf.Min(num, num2);
	}

	protected void FixedUpdate()
	{
		if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity.isServer)
		{
			DoMovement();
		}
	}

	public void AdjustVelocity(Vector3 adjustment)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		CurrentVelocity += adjustment;
	}

	public virtual Vector3 GetVelocityStep()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return Physics.gravity * gravityModifier * Time.fixedDeltaTime * Time.timeScale;
	}

	public virtual void InitializeVelocity(Vector3 overrideVel)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (AutomaticallyRotate())
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref overrideVel)).normalized);
		}
		initialVelocity = overrideVel;
		CurrentVelocity = overrideVel;
	}

	public void SetVelocity(Vector3 overrideVel)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (AutomaticallyRotate() && overrideVel != Vector3.zero)
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref overrideVel)).normalized);
		}
		CurrentVelocity = overrideVel;
	}

	public virtual bool DoMovement()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (base.baseEntity.isClient)
		{
			return false;
		}
		if (impacted)
		{
			return false;
		}
		CurrentVelocity += GetVelocityStep();
		Vector3 val = AddSwim(CurrentVelocity);
		float num = ((Vector3)(ref val)).magnitude * Time.fixedDeltaTime;
		if (DoHitDetection(val, num))
		{
			return false;
		}
		if (shouldMoveProjectile)
		{
			Transform transform = ((Component)this).transform;
			transform.position += ((Component)this).transform.forward * num;
		}
		if (AutomaticallyRotate() && val != Vector3.zero)
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
		}
		PostDoMove();
		return true;
	}

	protected virtual bool DoHitDetection(Vector3 velocityToUse, float distance)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		Vector3 position = ((Component)this).transform.position;
		GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref velocityToUse)).normalized), radius, list, distance + scanRange, mask, (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			BaseEntity entity = item.GetEntity();
			if ((!((Object)(object)entity != (Object)null) || !entity.isClient) && (!IgnoreAI || !IsAnIgnoredAI(entity)) && IsAValidHit(entity) && IsShootable(item))
			{
				ProcessHit(item, entity, position);
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				return true;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return false;
	}

	private Vector3 AddSwim(Vector3 currentVelocity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = currentVelocity;
		if (swimScale != Vector3.zero)
		{
			if (swimRandom == 0f)
			{
				swimRandom = Random.Range(0f, 20f);
			}
			float num = Time.time + swimRandom;
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(Mathf.Sin(num * swimSpeed.x) * swimScale.x, Mathf.Cos(num * swimSpeed.y) * swimScale.y, Mathf.Sin(num * swimSpeed.z) * swimScale.z);
			val2 = ((Component)this).transform.InverseTransformDirection(val2);
			val += val2;
		}
		return val;
	}

	protected void ProcessHit(RaycastHit hitInfo, BaseEntity hitEnt, Vector3 rayOrigin)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		transform.position += ((Component)this).transform.forward * Mathf.Max(0f, ((RaycastHit)(ref hitInfo)).distance - 0.1f);
		((Component)this).GetComponent<IProjectileImpact>()?.ProjectileImpact(hitInfo, rayOrigin);
		SingletonComponent<NpcNoiseManager>.Instance.OnServerProjectileHit(base.baseEntity, this, hitInfo);
		impacted = true;
		OnHit(hitInfo, hitEnt);
		PostDoMove();
	}

	protected bool IsShootable(RaycastHit hitInfo)
	{
		ColliderInfo colliderInfo = (((Object)(object)((RaycastHit)(ref hitInfo)).collider != (Object)null) ? ((Component)((RaycastHit)(ref hitInfo)).collider).GetComponent<ColliderInfo>() : null);
		if (!((Object)(object)colliderInfo == (Object)null))
		{
			return colliderInfo.HasFlag(ColliderInfo.Flags.Shootable);
		}
		return true;
	}

	protected virtual void OnHit(RaycastHit rayHit, BaseEntity hitEntity)
	{
	}

	protected virtual void PostDoMove()
	{
	}

	protected virtual bool IsAValidHit(BaseEntity hitEnt)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (!hitEnt.IsValid())
		{
			return true;
		}
		if (base.baseEntity.creatorEntity.IsValid() && hitEnt.net.ID == base.baseEntity.creatorEntity.net.ID)
		{
			return false;
		}
		if (ignoreEntity.IsValid() && hitEnt.net.ID == ignoreEntity.net.ID)
		{
			return false;
		}
		return true;
	}

	protected virtual bool IsAnIgnoredAI(BaseEntity hitEnt)
	{
		return hitEnt is ScientistNPC;
	}

	protected virtual bool AutomaticallyRotate()
	{
		return true;
	}
}


using UnityEngine;

public interface IProjectileImpact
{
	void ProjectileImpact(RaycastHit hitInfo, Vector3 rayOrigin);
}


using System;
using UnityEngine;

public class Ballista : BaseSiegeWeapon
{
	[Header("Ballista")]
	public GameObjectRef ballistaGunPrefab;

	public EntityRef<BallistaGun> ballistaGunRef;

	public Transform dismountPositionsParent;

	[Header("Effects")]
	[SerializeField]
	private GameObjectRef fireEffectPrefab;

	public override float DriveWheelVelocity { get; }

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child.prefabID == ballistaGunPrefab.GetEntity().prefabID)
		{
			BallistaGun ballistaGun = (BallistaGun)child;
			ballistaGunRef.Set(ballistaGun);
			ballistaGun.ballistaOwner = this;
		}
	}

	private BallistaGun GetBallistaGun()
	{
		BallistaGun ballistaGun = ballistaGunRef.Get(base.isServer);
		if (ballistaGun.IsValid())
		{
			return ballistaGun;
		}
		return null;
	}

	protected override bool CanPullNow(BasePlayer puller)
	{
		if (base.CanPullNow(puller))
		{
			return !IsGunMounted();
		}
		return false;
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (base.CanPushNow(pusher))
		{
			return !IsGunMounted();
		}
		return false;
	}

	public bool IsGunMounted()
	{
		BallistaGun ballistaGun = GetBallistaGun();
		if ((Object)(object)ballistaGun != (Object)null)
		{
			return ballistaGun.IsMounted();
		}
		return false;
	}

	protected override void CreateEngineController()
	{
	}

	private void RotateDismountPositions()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ballistaGunRef.Get(base.isServer) != (Object)null)
		{
			dismountPositionsParent.rotation = ((Component)ballistaGunRef.Get(base.isServer)).transform.rotation;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		mountPose = PlayerModel.MountPoses.StandDrive;
		DisablePhysics();
		((FacepunchBehaviour)this).Invoke((Action)base.EnablePhysics, 1f);
	}

	public override BasePlayer GetMounted()
	{
		return GetDriver();
	}

	public override void OnTowAttach()
	{
		base.OnTowAttach();
		DismountAllPlayers();
	}

	public void OnFired()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (fireEffectPrefab != null && fireEffectPrefab.isValid)
		{
			Effect.server.Run(fireEffectPrefab.resourcePath, this, 0u, Vector3.zero, Vector3.up, null, broadcast: true);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.VehicleFixedUpdate();
		Vector3 worldVelocity = GetWorldVelocity();
		if (((Vector3)(ref worldVelocity)).magnitude > 5f || IsFlipping())
		{
			DismountAllPlayers();
		}
		RotateDismountPositions();
	}

	protected override void DoPushAction(BasePlayer player)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)rigidBody == (Object)null))
		{
			Vector3 val = Vector3.ProjectOnPlane(((Component)this).transform.position - player.eyes.position, ((Component)this).transform.up);
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float num = rigidBody.mass * 2.4f;
			rigidBody.AddForce(normalized * num, (ForceMode)1);
		}
	}

	public override void OnEngineStartFailed()
	{
	}

	public override bool MeetsEngineRequirements()
	{
		return false;
	}

	public override void LightToggle(BasePlayer player)
	{
	}
}


public class BallistaAnimationEvents : FacepunchBehaviour
{
	public BallistaGun ballista;

	public SoundDefinition reloadClickSoundDef;

	public SoundDefinition reloadWrenchForwardDef;

	public SoundDefinition reloadCompleteDef;
}


public class BaseSiegeWeaponVisuals : VehicleChassisVisuals<BaseSiegeWeapon>, IClientComponent
{
}


using UnityEngine;

public class SiegeWeaponVehicleAudio : GroundVehicleAudio
{
	[Header("Reload")]
	public SoundDefinition reloadProgressDef;

	public SoundDefinition reloadStartDef;

	public SoundDefinition reloadStopDef;

	public SoundDefinition reloadCompleteDef;

	[Header("Rattles")]
	[SerializeField]
	private SoundDefinition movementRattleLoop;

	[SerializeField]
	private float movementRattleMaxSpeed = 10f;

	[SerializeField]
	private float movementRattleIdleGain = 0.3f;

	[SerializeField]
	private float movementRattleGainChangeSpeed = 1f;

	[SerializeField]
	[Header("Wheels")]
	private SoundDefinition tyreRollingSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingWaterSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingGrassSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingSnowSoundDef;

	[SerializeField]
	private AnimationCurve tyreRollGainCurve;
}


using Rust;
using UnityEngine;

public class BatteringRamHead : BaseCombatEntity
{
	public float damagedHealthThreshold = 100f;

	public float brokenHealthThreshold = 20f;

	public Collider serverCollider;

	[HideInInspector]
	public BatteringRam batteringRamOwner;

	[HideInInspector]
	public DamageRenderer damageRenderer;

	public const Flags Flags_DamagedLow = Flags.Reserved6;

	public const Flags Flags_DamagedMid = Flags.Reserved7;

	public const Flags Flags_DamagedHeavy = Flags.Reserved8;

	public bool CanBeUsed()
	{
		return base.health > brokenHealthThreshold;
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateBrokenFlag();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateBrokenFlag();
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		base.OnHealthChanged(oldvalue, newvalue);
		UpdateDamageFlags();
	}

	private void UpdateDamageFlags()
	{
		float num = base.healthFraction;
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved7, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved8, b: false);
		if (num <= 0.1f)
		{
			SetFlag(Flags.Reserved8, b: true);
		}
		else if (num <= 0.5f)
		{
			SetFlag(Flags.Reserved7, b: true);
		}
		else if (num <= 0.75f)
		{
			SetFlag(Flags.Reserved6, b: true);
		}
	}

	private void UpdateBrokenFlag()
	{
		if (CanBeUsed())
		{
			batteringRamOwner.SetFlag(Flags.Broken, b: false);
			SetFlag(Flags.Broken, b: false);
		}
	}

	public override float GetDamageRepairCooldown()
	{
		return 0f;
	}

	public void TakeDamage(float damage)
	{
		damage = Mathf.Min(damage, base.health - 10f);
		Hurt(damage, DamageType.Blunt, this, useProtection: false);
		if (!CanBeUsed())
		{
			batteringRamOwner.SetFlag(Flags.Broken, b: true);
			SetFlag(Flags.Broken, b: true);
		}
	}

	[ServerVar]
	public static void hurt(Arg arg)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		BatteringRamHead[] array = Util.FindAll<BatteringRamHead>();
		foreach (BatteringRamHead batteringRamHead in array)
		{
			if (batteringRamHead.isServer && Vector3.Distance(((Component)batteringRamHead).transform.position, ((Component)basePlayer).transform.position) <= 10f)
			{
				batteringRamHead.TakeDamage(@float);
			}
		}
	}
}


public class BatteringRamSeat : BaseVehicleSeat
{
}


using UnityEngine;

public class BatteringRamVehicleAudio : SiegeWeaponVehicleAudio
{
	public Transform lightToggleSoundPos;
}


using UnityEngine;

public class BatteringRamVisuals : BaseSiegeWeaponVisuals, IClientComponent
{
	private BatteringRam ram;

	public Transform frontAxle;

	public Transform middleAxle;

	public Transform rearAxle;

	[Space]
	public ParticleSystem rockDoorParticle;

	public ParticleSystem dirtDoorParticle;
}


using System;
using UnityEngine;

public class CatapultAmmoContainer : StorageContainer
{
	[NonSerialized]
	public Catapult catapult;

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		catapult.UpdateLoadedAmmo(item, added);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((Object)(object)catapult != (Object)null)
		{
			return catapult.CanBeLooted(player);
		}
		return false;
	}
}


public class CatapultAnimationEvents : FacepunchBehaviour
{
	public Catapult catapult;

	public SoundDefinition reloadClickSoundDef;

	public void PlayReloadClick()
	{
	}

	public void PlaySound(SoundDefinition def)
	{
	}
}


using UnityEngine;

public class CatapultSounds : GroundVehicleAudio
{
	[Header("Reload")]
	public SoundDefinition reloadLoopDef;

	public SoundDefinition reloadStartDef;

	public SoundDefinition reloadStopDef;

	[Header("Suspension")]
	[SerializeField]
	private SoundDefinition suspensionDef;

	[SerializeField]
	private float suspensionMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionMinTimeBetweenSounds = 0.25f;

	[Header("Tires")]
	[SerializeField]
	private SoundDefinition tireDirtSoundDef;

	[SerializeField]
	private SoundDefinition tireGrassSoundDef;

	[SerializeField]
	private SoundDefinition tireSnowSoundDef;

	[SerializeField]
	private SoundDefinition tireWaterSoundDef;

	[SerializeField]
	private AnimationCurve tireGainCurve;

	[Header("Movement")]
	[SerializeField]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private AnimationCurve movementGainCurve;

	[SerializeField]
	private float movementGainAdjustmentSpeed = 5f;
}


using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ConstructableEntity : StorageContainer
{
	[Header("Constructable Entity")]
	public List<ItemAmount> ingredients = new List<ItemAmount>();

	private int[] currentMaterials;

	public GameObjectRef entityToSpawn;

	public PlayerDetectionTrigger trigger;

	public bool onlyRunTriggerCheckOnLastHit;

	public bool onlyBlockWhenStanding;

	public GameObject[] states;

	public SoundDefinition[] stateSounds;

	public GameObjectRef spawnEffect;

	public bool additiveMode;

	private int currentState;

	private void SetState(int index)
	{
		if (index < 0 || index >= states.Length)
		{
			return;
		}
		if (additiveMode)
		{
			for (int i = 0; i < states.Length; i++)
			{
				states[i].SetActive(i <= index);
			}
		}
		else
		{
			GameObject[] array = states;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(false);
			}
			states[index].SetActive(true);
		}
		currentState = index;
	}

	private void UpdateState()
	{
		int num = Mathf.FloorToInt(GetTotalMaterialFraction() * (float)states.Length);
		num = Mathf.Clamp(num, 0, states.Length - 1);
		if (num != currentState)
		{
			if (base.isServer)
			{
				timePlaced = GetNetworkTime();
			}
			SetState(num);
		}
	}

	private float GetTotalMaterialFraction()
	{
		float num = 0f;
		float num2 = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			num += Mathf.Min((float)currentMaterials[i], ingredients[i].amount);
			num2 += ingredients[i].amount;
		}
		if (!(num2 > 0f))
		{
			return 0f;
		}
		return num / num2;
	}

	public bool IsNearlyBuilt()
	{
		for (int i = 0; i < ingredients.Count; i++)
		{
			float num = Mathf.Max(0f, ingredients[i].amount - (float)currentMaterials[i]);
			if (!(num <= 0f))
			{
				int num2 = Mathf.CeilToInt(ingredients[i].amount / 10f);
				if (num > (float)num2)
				{
					return false;
				}
			}
		}
		return true;
	}

	public override void ServerInit()
	{
		SetState(0);
		base.ServerInit();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		base.OnRepairFinished(player);
		ulong ownerID = base.OwnerID;
		Kill();
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityToSpawn.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
		baseEntity.OwnerID = ownerID;
		baseEntity.Spawn();
		if (spawnEffect.isValid)
		{
			Effect.server.Run(spawnEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		}
	}

	public override float GetDamageRepairCooldown()
	{
		return 5f;
	}

	public override void DoRepair(BasePlayer player)
	{
		if (!CanRepair(player))
		{
			return;
		}
		bool flag = false;
		float num = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			ItemAmount itemAmount = ingredients[i];
			float num2 = Mathf.Max(0f, itemAmount.amount - (float)currentMaterials[i]);
			if (num2 != 0f)
			{
				int num3 = Mathf.CeilToInt(itemAmount.amount / 10f);
				int num4 = player.inventory.GetAmount(itemAmount.itemid);
				if (player.IsInCreativeMode && Creative.freeRepair)
				{
					num4 = int.MaxValue;
				}
				int num5 = Mathf.Min(new int[3]
				{
					num3,
					num4,
					Mathf.FloorToInt(num2)
				});
				if (num5 > 0)
				{
					currentMaterials[i] += num5;
					player.inventory.Take(null, itemAmount.itemid, num5);
					player.Command("note.inv", itemAmount.itemid, num5 * -1);
					flag = true;
					float num6 = MaxHealth() * (itemAmount.amount / GetTotalRequiredMaterials());
					num += num6 * ((float)num5 / itemAmount.amount);
				}
				else
				{
					OnBuildFailedResources(player, itemAmount.itemDef.itemid);
				}
			}
		}
		if (num != 0f)
		{
			SetHealth(Mathf.Min(Health() + num, MaxHealth()));
		}
		if (flag)
		{
			SendNetworkUpdate();
			UpdateState();
			if (IsFullyBuilt())
			{
				OnRepairFinished(player);
			}
			else
			{
				OnRepair();
			}
		}
	}

	public void OnBuildFailedResources(BasePlayer player, int itemID)
	{
		if ((Object)(object)player != (Object)null)
		{
			player.ClientRPC(RpcTarget.Player("Client_OnConstructableBuildFailed", player), itemID);
		}
	}

	private bool IsFullyBuilt()
	{
		for (int i = 0; i < ingredients.Count; i++)
		{
			if ((float)currentMaterials[i] < ingredients[i].amount)
			{
				return false;
			}
		}
		return true;
	}

	private float GetTotalRequiredMaterials()
	{
		float num = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			num += ingredients[i].amount;
		}
		return num;
	}

	protected virtual bool CanRepair(BasePlayer player)
	{
		if ((Object)(object)trigger != (Object)null && trigger.entityContents != null)
		{
			if (onlyRunTriggerCheckOnLastHit && !IsNearlyBuilt())
			{
				return true;
			}
			foreach (BaseEntity entityContent in trigger.entityContents)
			{
				if (entityContent is BaseVehicle baseVehicle)
				{
					if (!baseVehicle.IsDead() && !baseVehicle.isClient && !((Object)(object)((Component)baseVehicle).transform.root == (Object)(object)((Component)this).transform))
					{
						player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByVehicle, false);
						return false;
					}
				}
				else if (entityContent is BasePlayer { isClient: false } basePlayer && !basePlayer.IsDead() && (!onlyBlockWhenStanding || basePlayer.IsStandingOnEntity(this, 134226176)))
				{
					player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, overlay: false, (string[])null);
					return false;
				}
			}
		}
		return true;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.constructableEntity = Pool.Get<ConstructableEntity>();
		if (currentMaterials == null || currentMaterials.IsEmpty())
		{
			currentMaterials = new int[ingredients.Count];
			for (int i = 0; i < ingredients.Count; i++)
			{
				currentMaterials[i] = 0;
			}
		}
		info.msg.constructableEntity.addedResources = currentMaterials.ToList();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.constructableEntity != null)
		{
			currentMaterials = info.msg.constructableEntity.addedResources.ToArray();
		}
		UpdateState();
	}
}


using UnityEngine;

public class SiegeTowerDoor : Door
{
	private SiegeTower tower;

	protected override bool OnlyCheckForVehicles()
	{
		return false;
	}

	protected override bool InverseDotCheck()
	{
		return true;
	}

	protected override bool CheckOnClose()
	{
		return false;
	}

	public void SetupDoor(SiegeTower tower)
	{
		this.tower = tower;
	}

	private void UpdateTowerHP()
	{
		if (HasParent() && (Object)(object)tower != (Object)null)
		{
			tower.ProtectedSetHealth(base.health);
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateTowerHP();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateTowerHP();
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && (Object)(object)tower != (Object)null)
		{
			tower.ProtectedHurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)tower != (Object)null && !tower.IsDead())
		{
			tower.Die();
		}
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if ((Object)(object)tower != (Object)null && old != next)
		{
			tower.RefreshLastUseTime();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class StabilityEntity : DecayEntity
{
	public class StabilityCheckWorkQueue : ObjectWorkQueue<StabilityEntity>
	{
		protected override void RunJob(StabilityEntity entity)
		{
			if (((ObjectWorkQueue<StabilityEntity>)this).ShouldAdd(entity))
			{
				entity.StabilityCheck();
			}
		}

		protected override bool ShouldAdd(StabilityEntity entity)
		{
			if (!ConVar.Server.stability)
			{
				return false;
			}
			if (!entity.IsValid())
			{
				return false;
			}
			if (!entity.isServer)
			{
				return false;
			}
			return true;
		}
	}

	public class UpdateSurroundingsQueue : ObjectWorkQueue<Bounds>
	{
		protected override void RunJob(Bounds bounds)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			NotifyNeighbours(bounds);
		}

		public static void NotifyNeighbours(Bounds bounds)
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (!ConVar.Server.stability)
			{
				return;
			}
			List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
			Vector3 center = ((Bounds)(ref bounds)).center;
			Vector3 extents = ((Bounds)(ref bounds)).extents;
			Vis.Entities(center, ((Vector3)(ref extents)).magnitude + 1f, list, -2144696062, (QueryTriggerInteraction)2);
			foreach (BaseEntity item in list)
			{
				if (!item.IsDestroyed && !item.isClient)
				{
					if (item is StabilityEntity stabilityEntity)
					{
						stabilityEntity.OnPhysicsNeighbourChanged();
					}
					else
					{
						((Component)item).BroadcastMessage("OnPhysicsNeighbourChanged", (SendMessageOptions)1);
					}
				}
			}
			Pool.FreeUnmanaged<BaseEntity>(ref list);
		}
	}

	public class Support
	{
		public StabilityEntity parent;

		public EntityLink link;

		public float factor = 1f;

		public Support(StabilityEntity parent, EntityLink link, float factor)
		{
			this.parent = parent;
			this.link = link;
			this.factor = factor;
		}

		public StabilityEntity SupportEntity(StabilityEntity ignoreEntity = null)
		{
			StabilityEntity stabilityEntity = null;
			for (int i = 0; i < link.connections.Count; i++)
			{
				StabilityEntity stabilityEntity2 = link.connections[i].owner as StabilityEntity;
				Socket_Base socket = link.connections[i].socket;
				if ((Object)(object)stabilityEntity2 == (Object)null || (Object)(object)stabilityEntity2 == (Object)(object)parent || (Object)(object)stabilityEntity2 == (Object)(object)ignoreEntity || stabilityEntity2.isClient || stabilityEntity2.IsDestroyed || socket is ConstructionSocket { femaleNoStability: not false })
				{
					continue;
				}
				if ((Object)(object)stabilityEntity == (Object)null)
				{
					stabilityEntity = stabilityEntity2;
				}
				else if (Stability.support_highest_stability)
				{
					if (stabilityEntity2.cachedStability > stabilityEntity.cachedStability)
					{
						stabilityEntity = stabilityEntity2;
					}
				}
				else if (stabilityEntity2.cachedDistanceFromGround < stabilityEntity.cachedDistanceFromGround)
				{
					stabilityEntity = stabilityEntity2;
				}
			}
			return stabilityEntity;
		}
	}

	public bool grounded;

	[NonSerialized]
	public float cachedStability;

	[NonSerialized]
	public int cachedDistanceFromGround = int.MaxValue;

	private List<Support> supports;

	private int stabilityStrikes;

	private bool dirty;

	public static StabilityCheckWorkQueue stabilityCheckQueue = new StabilityCheckWorkQueue();

	public static UpdateSurroundingsQueue updateSurroundingsQueue = new UpdateSurroundingsQueue();

	public override void ResetState()
	{
		base.ResetState();
		cachedStability = 0f;
		cachedDistanceFromGround = int.MaxValue;
		if (base.isServer)
		{
			supports = null;
			stabilityStrikes = 0;
			dirty = false;
		}
	}

	public void InitializeSupports()
	{
		supports = new List<Support>();
		if (grounded || HasParent())
		{
			return;
		}
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			if (entityLink.IsMale())
			{
				if (entityLink.socket is StabilitySocket)
				{
					supports.Add(new Support(this, entityLink, (entityLink.socket as StabilitySocket).support));
				}
				if (entityLink.socket is ConstructionSocket)
				{
					supports.Add(new Support(this, entityLink, (entityLink.socket as ConstructionSocket).support));
				}
			}
		}
	}

	public int DistanceFromGround(StabilityEntity ignoreEntity = null)
	{
		if (grounded || HasParent())
		{
			return 1;
		}
		if (supports == null)
		{
			return 1;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		int num = int.MaxValue;
		for (int i = 0; i < supports.Count; i++)
		{
			StabilityEntity stabilityEntity = supports[i].SupportEntity(ignoreEntity);
			if (!((Object)(object)stabilityEntity == (Object)null))
			{
				int num2 = stabilityEntity.CachedDistanceFromGround(ignoreEntity);
				if (num2 != int.MaxValue)
				{
					num = Mathf.Min(num, num2 + 1);
				}
			}
		}
		return num;
	}

	public float SupportValue(StabilityEntity ignoreEntity = null)
	{
		if (grounded || HasParent())
		{
			return 1f;
		}
		if (supports == null)
		{
			return 1f;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		float num = 0f;
		for (int i = 0; i < supports.Count; i++)
		{
			Support support = supports[i];
			StabilityEntity stabilityEntity = support.SupportEntity(ignoreEntity);
			if (!((Object)(object)stabilityEntity == (Object)null))
			{
				float num2 = stabilityEntity.CachedSupportValue(ignoreEntity);
				if (num2 != 0f)
				{
					num += num2 * support.factor;
				}
			}
		}
		return Mathf.Clamp01(num);
	}

	public int CachedDistanceFromGround(StabilityEntity ignoreEntity = null)
	{
		if (grounded || HasParent())
		{
			return 1;
		}
		if (supports == null)
		{
			return 1;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		int num = int.MaxValue;
		for (int i = 0; i < supports.Count; i++)
		{
			StabilityEntity stabilityEntity = supports[i].SupportEntity(ignoreEntity);
			if (!((Object)(object)stabilityEntity == (Object)null))
			{
				int num2 = stabilityEntity.cachedDistanceFromGround;
				if (num2 != int.MaxValue)
				{
					num = Mathf.Min(num, num2 + 1);
				}
			}
		}
		return num;
	}

	public float CachedSupportValue(StabilityEntity ignoreEntity = null)
	{
		if (grounded || HasParent())
		{
			return 1f;
		}
		if (supports == null)
		{
			return 1f;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		float num = 0f;
		for (int i = 0; i < supports.Count; i++)
		{
			Support support = supports[i];
			StabilityEntity stabilityEntity = support.SupportEntity(ignoreEntity);
			if (!((Object)(object)stabilityEntity == (Object)null))
			{
				float num2 = stabilityEntity.cachedStability;
				if (num2 != 0f)
				{
					num += num2 * support.factor;
				}
			}
		}
		return Mathf.Clamp01(num);
	}

	public virtual void StabilityCheck()
	{
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if (base.IsDestroyed || Interface.CallHook("OnEntityStabilityCheck", (object)this) != null)
		{
			return;
		}
		if (supports == null)
		{
			InitializeSupports();
		}
		bool flag = false;
		int num = DistanceFromGround();
		if (num != cachedDistanceFromGround)
		{
			cachedDistanceFromGround = num;
			flag = true;
		}
		float num2 = SupportValue();
		if (Mathf.Abs(cachedStability - num2) > Stability.accuracy)
		{
			cachedStability = num2;
			flag = true;
		}
		if (flag)
		{
			dirty = true;
			UpdateConnectedEntities();
			UpdateStability();
		}
		else if (dirty)
		{
			dirty = false;
			SendNetworkUpdate();
		}
		if (num2 < Stability.collapse)
		{
			if (stabilityStrikes < Stability.strikes)
			{
				UpdateStability();
				stabilityStrikes++;
				return;
			}
			if (Stability.log_stability_death)
			{
				Debug.Log((object)$"Killing '{((object)this).ToString()}' at position {((Component)this).transform.position} due to low stability: {Math.Round(num2 * 100f, 2)} < {Math.Round(Stability.collapse * 100f, 1)}%");
			}
			Kill(DestroyMode.Gib);
		}
		else
		{
			stabilityStrikes = 0;
		}
	}

	public void UpdateStability()
	{
		((ObjectWorkQueue<StabilityEntity>)stabilityCheckQueue).Add(this);
	}

	public void UpdateSurroundingEntities()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		UpdateSurroundingsQueue obj = updateSurroundingsQueue;
		OBB val = WorldSpaceBounds();
		((ObjectWorkQueue<Bounds>)obj).Add(((OBB)(ref val)).ToBounds());
	}

	public void UpdateConnectedEntities()
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			if (!entityLink.IsFemale())
			{
				continue;
			}
			for (int j = 0; j < entityLink.connections.Count; j++)
			{
				StabilityEntity stabilityEntity = entityLink.connections[j].owner as StabilityEntity;
				if (!((Object)(object)stabilityEntity == (Object)null) && !stabilityEntity.isClient && !stabilityEntity.IsDestroyed)
				{
					stabilityEntity.UpdateStability();
				}
			}
		}
	}

	protected void OnPhysicsNeighbourChanged()
	{
		if (!base.IsDestroyed)
		{
			StabilityCheck();
		}
	}

	protected void DebugNudge()
	{
		StabilityCheck();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			UpdateStability();
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		UpdateSurroundingEntities();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.stabilityEntity = Pool.Get<StabilityEntity>();
		info.msg.stabilityEntity.stability = cachedStability;
		info.msg.stabilityEntity.distanceFromGround = cachedDistanceFromGround;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.stabilityEntity != null)
		{
			cachedStability = info.msg.stabilityEntity.stability;
			cachedDistanceFromGround = info.msg.stabilityEntity.distanceFromGround;
			if (cachedStability <= 0f)
			{
				cachedStability = 0f;
			}
			if (cachedDistanceFromGround <= 0)
			{
				cachedDistanceFromGround = int.MaxValue;
			}
		}
	}
}


using ConVar;

public class StabilityCheckWorkQueue : ObjectWorkQueue<StabilityEntity>
{
	protected override void RunJob(StabilityEntity entity)
	{
		if (((ObjectWorkQueue<StabilityEntity>)this).ShouldAdd(entity))
		{
			entity.StabilityCheck();
		}
	}

	protected override bool ShouldAdd(StabilityEntity entity)
	{
		if (!Server.stability)
		{
			return false;
		}
		if (!entity.IsValid())
		{
			return false;
		}
		if (!entity.isServer)
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class UpdateSurroundingsQueue : ObjectWorkQueue<Bounds>
{
	protected override void RunJob(Bounds bounds)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		NotifyNeighbours(bounds);
	}

	public static void NotifyNeighbours(Bounds bounds)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (!Server.stability)
		{
			return;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vector3 center = ((Bounds)(ref bounds)).center;
		Vector3 extents = ((Bounds)(ref bounds)).extents;
		Vis.Entities(center, ((Vector3)(ref extents)).magnitude + 1f, list, -2144696062, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.IsDestroyed && !item.isClient)
			{
				if (item is StabilityEntity stabilityEntity)
				{
					stabilityEntity.OnPhysicsNeighbourChanged();
				}
				else
				{
					((Component)item).BroadcastMessage("OnPhysicsNeighbourChanged", (SendMessageOptions)1);
				}
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}
}


using ConVar;
using UnityEngine;

public class Support
{
	public StabilityEntity parent;

	public EntityLink link;

	public float factor = 1f;

	public Support(StabilityEntity parent, EntityLink link, float factor)
	{
		this.parent = parent;
		this.link = link;
		this.factor = factor;
	}

	public StabilityEntity SupportEntity(StabilityEntity ignoreEntity = null)
	{
		StabilityEntity stabilityEntity = null;
		for (int i = 0; i < link.connections.Count; i++)
		{
			StabilityEntity stabilityEntity2 = link.connections[i].owner as StabilityEntity;
			Socket_Base socket = link.connections[i].socket;
			if ((Object)(object)stabilityEntity2 == (Object)null || (Object)(object)stabilityEntity2 == (Object)(object)parent || (Object)(object)stabilityEntity2 == (Object)(object)ignoreEntity || stabilityEntity2.isClient || stabilityEntity2.IsDestroyed || socket is ConstructionSocket { femaleNoStability: not false })
			{
				continue;
			}
			if ((Object)(object)stabilityEntity == (Object)null)
			{
				stabilityEntity = stabilityEntity2;
			}
			else if (Stability.support_highest_stability)
			{
				if (stabilityEntity2.cachedStability > stabilityEntity.cachedStability)
				{
					stabilityEntity = stabilityEntity2;
				}
			}
			else if (stabilityEntity2.cachedDistanceFromGround < stabilityEntity.cachedDistanceFromGround)
			{
				stabilityEntity = stabilityEntity2;
			}
		}
		return stabilityEntity;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

public class TimedExplosive : BaseEntity, ServerProjectile.IProjectileImpact
{
	public enum ExplosionEffectOffsetMode
	{
		Local,
		World
	}

	[Header("General")]
	public float timerAmountMin = 10f;

	public float timerAmountMax = 20f;

	public float minExplosionRadius;

	public float explosionRadius = 10f;

	public bool explodeOnContact;

	public bool canStick;

	public bool onlyDamageParent;

	[Header("AI")]
	public bool IgnoreAI;

	public bool BlindAI;

	public float aiBlindDuration = 2.5f;

	public float aiBlindRange = 4f;

	[Header("Offsets")]
	public ExplosionEffectOffsetMode explosionOffsetMode;

	public Vector3 explosionEffectOffset = Vector3.zero;

	[Header("Normals")]
	public bool explosionMatchesNormal;

	public bool explosionUsesForward;

	public bool explosionMatchesOrientation;

	public bool explosionMatchesVelocity;

	public bool explosionMatchesInverseVelocity;

	[Header("Effects")]
	public GameObjectRef explosionEffect;

	[Tooltip("Optional: Will fall back to watersurfaceExplosionEffect or explosionEffect if not assigned.")]
	public GameObjectRef underwaterExplosionEffect;

	public GameObjectRef stickEffect;

	public GameObjectRef bounceEffect;

	public GameObjectRef watersurfaceExplosionEffect;

	[Header("Water")]
	[Min(0f)]
	public float underwaterExplosionDepth = 1f;

	[Tooltip("Optional: Will fall back to underwaterExplosionEffect or explosionEffect if not assigned.")]
	[MinMax(0f, 100f)]
	public MinMax watersurfaceExplosionDepth = new MinMax(0.5f, 10f);

	public bool waterCausesExplosion;

	[Header("Other")]
	public int vibrationLevel = 3;

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	public List<DamageTypeEntry> playerDamage = new List<DamageTypeEntry>();

	public bool splashWallpaperThroughWalls;

	[NonSerialized]
	private float lastBounceTime;

	private bool hadRB;

	private float rbMass;

	private float rbDrag;

	private float rbAngularDrag;

	private Vector3 rbVelocityBeforeCollision;

	private CollisionDetectionMode rbCollisionMode;

	[NonSerialized]
	public ItemOwnershipShare ItemOwnership;

	protected BasePlayer creatorPlayer;

	private const int parentOnlySplashDamage = 166144;

	private const int fullSplashDamage = 1210222849;

	protected Vector3? hitNormal;

	private static BaseEntity[] queryResults = new BaseEntity[64];

	private Vector3 lastPosition = Vector3.zero;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	protected virtual bool AlwaysRunWaterCheck => false;

	public List<DamageTypeEntry> GetDamageList(BaseEntity entity)
	{
		if (ConVar.Server.explosive_testing_mode)
		{
			return new List<DamageTypeEntry>
			{
				new DamageTypeEntry
				{
					amount = 1f,
					type = DamageType.Explosion
				}
			};
		}
		if (entity is BasePlayer && playerDamage != null && playerDamage.Count > 0)
		{
			return playerDamage;
		}
		return damageTypes;
	}

	public void SetDamageScale(float scale)
	{
		foreach (DamageTypeEntry damageType in damageTypes)
		{
			damageType.amount *= scale;
		}
	}

	public void SetCreator(BasePlayer ply)
	{
		creatorPlayer = ply;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		lastBounceTime = Time.time;
		base.ServerInit();
		SetFuse(GetRandomTimerTime());
		if (((Component)(object)((Component)this).transform).HasComponent<Collider>())
		{
			ReceiveCollisionMessages(b: true);
		}
		if (waterCausesExplosion || AlwaysRunWaterCheck)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)WaterCheck, 0f, 0.5f);
		}
	}

	public virtual void WaterCheck()
	{
		if (waterCausesExplosion && WaterFactor() >= 0.5f)
		{
			Explode();
			Debug.Log((object)"water explode");
		}
	}

	public virtual void SetFuse(float fuseLength)
	{
		if (base.isServer)
		{
			object obj = Interface.CallHook("OnExplosiveFuseSet", (object)this, (object)fuseLength);
			if (obj is float)
			{
				fuseLength = (float)obj;
			}
			((FacepunchBehaviour)this).Invoke((Action)Explode, fuseLength);
			SetFlag(Flags.Reserved2, b: true);
		}
	}

	public virtual float GetRandomTimerTime()
	{
		return Random.Range(timerAmountMin, timerAmountMax);
	}

	public virtual void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		hitNormal = ((RaycastHit)(ref info)).normal;
		Explode();
	}

	public void ForceExplode()
	{
		if (this is DudTimedExplosive dudTimedExplosive)
		{
			dudTimedExplosive.dudChance = 0f;
		}
		if (this is RFTimedExplosive rFTimedExplosive)
		{
			rFTimedExplosive.DisarmRF();
		}
		Explode();
	}

	public virtual void Explode()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Explode(PivotPoint());
	}

	private Vector3 GetExplosionNormal()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result;
		if (explosionUsesForward)
		{
			result = ((Component)this).transform.forward;
		}
		else if (!explosionMatchesOrientation)
		{
			result = (explosionMatchesVelocity ? ((Vector3)(ref rbVelocityBeforeCollision)).normalized : ((!explosionMatchesInverseVelocity) ? Vector3.up : (-((Vector3)(ref rbVelocityBeforeCollision)).normalized)));
		}
		else
		{
			Quaternion rotation = ((Component)this).transform.rotation;
			Vector3 forward = Vector3.forward;
			result = rotation * forward;
		}
		if (explosionMatchesNormal && hitNormal.HasValue)
		{
			result = hitNormal.Value;
		}
		return result;
	}

	public virtual void Explode(Vector3 explosionFxPos)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0428: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		Analytics.Azure.OnExplosion(this);
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.enabled = false;
		}
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(explosionFxPos - new Vector3(0f, 0.25f, 0f), waves: true, volumes: true);
		if (underwaterExplosionEffect.isValid && waterInfo.isValid && waterInfo.currentDepth >= underwaterExplosionDepth)
		{
			Effect.server.Run(underwaterExplosionEffect.resourcePath, explosionFxPos, GetExplosionNormal(), null, broadcast: true);
		}
		else if (explosionEffect.isValid)
		{
			Vector3 val = explosionFxPos;
			if (explosionOffsetMode == ExplosionEffectOffsetMode.Local)
			{
				Vector3 val2 = ((Component)this).transform.TransformPoint(explosionEffectOffset) - ((Component)this).transform.position;
				val += val2;
			}
			if (explosionOffsetMode == ExplosionEffectOffsetMode.World)
			{
				val += explosionEffectOffset;
			}
			Effect.server.Run(explosionEffect.resourcePath, val, GetExplosionNormal(), null, broadcast: true);
		}
		if (watersurfaceExplosionEffect.isValid && waterInfo.isValid && waterInfo.overallDepth >= watersurfaceExplosionDepth.x && waterInfo.currentDepth <= watersurfaceExplosionDepth.y)
		{
			Effect.server.Run(watersurfaceExplosionEffect.resourcePath, Vector3Ex.WithY(explosionFxPos, waterInfo.surfaceLevel), GetExplosionNormal(), null, broadcast: true);
		}
		if (GetDamageList(null).Count > 0)
		{
			if (Interface.CallHook("OnTimedExplosiveExplode", (object)this, (object)explosionFxPos) != null)
			{
				return;
			}
			Vector3 val3 = ExplosionCenter();
			if (onlyDamageParent)
			{
				int num = 166144;
				if (!ConVar.AntiHack.explosive_vehicle_parent_damage_deployables && parentEntity.Get(serverside: true) is BaseVehicle)
				{
					num &= -257;
				}
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), val3, minExplosionRadius, explosionRadius, GetDamageList(null), num, useLineOfSight: true, IgnoreAI, ignoreAttackingPlayer: false, extendedLineOfSight: false, playerDamage);
				BaseEntity baseEntity = GetParentEntity();
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				while ((Object)(object)baseCombatEntity == (Object)null && (Object)(object)baseEntity != (Object)null && baseEntity.HasParent())
				{
					baseEntity = baseEntity.GetParentEntity();
					baseCombatEntity = baseEntity as BaseCombatEntity;
				}
				if ((Object)(object)baseEntity == (Object)null || !((Component)baseEntity).gameObject.IsOnLayer((Layer)21))
				{
					List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
					Vis.Entities(val3, explosionRadius, list, 2097152, (QueryTriggerInteraction)1);
					BuildingBlock buildingBlock = null;
					float num2 = float.PositiveInfinity;
					foreach (BuildingBlock item in list)
					{
						if (!item.isClient && !item.IsDestroyed && !(item.healthFraction <= 0f))
						{
							float num3 = Vector3.Distance(item.ClosestPoint(val3), val3);
							if (num3 < num2 && item.IsVisible(val3, explosionRadius))
							{
								buildingBlock = item;
								num2 = num3;
							}
						}
					}
					if (Object.op_Implicit((Object)(object)buildingBlock))
					{
						HitInfo hitInfo = new HitInfo();
						hitInfo.Initiator = creatorEntity;
						hitInfo.WeaponPrefab = LookupPrefab();
						hitInfo.damageTypes.Add(GetDamageList(buildingBlock));
						hitInfo.PointStart = val3;
						hitInfo.PointEnd = ((Component)buildingBlock).transform.position;
						float amount = 1f - Mathf.Clamp01((num2 - minExplosionRadius) / (explosionRadius - minExplosionRadius));
						hitInfo.damageTypes.ScaleAll(amount);
						buildingBlock.Hurt(hitInfo);
					}
					Pool.FreeUnmanaged<BuildingBlock>(ref list);
				}
				if (Object.op_Implicit((Object)(object)baseCombatEntity))
				{
					HitInfo hitInfo2 = new HitInfo();
					hitInfo2.Initiator = creatorEntity;
					hitInfo2.WeaponPrefab = LookupPrefab();
					hitInfo2.damageTypes.Add(GetDamageList(baseEntity));
					baseCombatEntity.Hurt(hitInfo2);
				}
				else if ((Object)(object)baseEntity != (Object)null)
				{
					HitInfo hitInfo3 = new HitInfo();
					hitInfo3.Initiator = creatorEntity;
					hitInfo3.WeaponPrefab = LookupPrefab();
					hitInfo3.damageTypes.Add(GetDamageList(baseEntity));
					hitInfo3.PointStart = val3;
					hitInfo3.PointEnd = ((Component)baseEntity).transform.position;
					baseEntity.OnAttacked(hitInfo3);
				}
				if (splashWallpaperThroughWalls)
				{
					List<BuildingBlock> list2 = Pool.Get<List<BuildingBlock>>();
					Vis.Entities(val3, 3.4f, list2, 2097152, (QueryTriggerInteraction)1);
					foreach (BuildingBlock item2 in list2)
					{
						item2.RemoveWallpaper(0);
						item2.RemoveWallpaper(1);
					}
					Pool.FreeUnmanaged<BuildingBlock>(ref list2);
				}
			}
			else
			{
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), val3, minExplosionRadius, explosionRadius, GetDamageList(null), 1210222849, useLineOfSight: true, IgnoreAI, ignoreAttackingPlayer: false, extendedLineOfSight: false, playerDamage, splashWallpaperThroughWalls);
			}
			SeismicSensor.Notify(val3, vibrationLevel);
			BlindAnyAI();
		}
		if (!base.IsDestroyed && !HasFlag(Flags.Broken) && !ConVar.Server.explosive_testing_mode)
		{
			Kill(DestroyMode.Gib);
		}
	}

	private Vector3 ExplosionCenter()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (IsStuck() && parentEntity.Get(base.isServer) is BaseVehicle)
		{
			OBB val = WorldSpaceBounds();
			return CenterPoint() - val.forward * (val.extents.z + 0.1f);
		}
		return CenterPoint();
	}

	private void BlindAnyAI()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (!BlindAI)
		{
			return;
		}
		int brainsInSphereFast = Query.Server.GetBrainsInSphereFast(((Component)this).transform.position, 10f, queryResults);
		for (int i = 0; i < brainsInSphereFast; i++)
		{
			BaseEntity baseEntity = queryResults[i];
			if (Vector3.Distance(((Component)this).transform.position, ((Component)baseEntity).transform.position) > aiBlindRange)
			{
				continue;
			}
			BaseAIBrain component = ((Component)baseEntity).GetComponent<BaseAIBrain>();
			if (!((Object)(object)component == (Object)null))
			{
				BaseEntity brainBaseEntity = component.GetBrainBaseEntity();
				if (!((Object)(object)brainBaseEntity == (Object)null) && brainBaseEntity.IsVisible(CenterPoint()))
				{
					float blinded = aiBlindDuration * component.BlindDurationMultiplier * Random.Range(0.6f, 1.4f);
					component.SetBlinded(blinded);
					queryResults[i] = null;
				}
			}
		}
	}

	public void FixedUpdate()
	{
		CheckClippingThroughWalls();
	}

	protected virtual bool ShouldBypassClippingWallCheck()
	{
		return false;
	}

	private void CheckClippingThroughWalls()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		if (!canStick)
		{
			return;
		}
		if (lastPosition == default(Vector3) || !parentEntity.IsValid(serverside: true))
		{
			lastPosition = CenterPoint();
			return;
		}
		Vector3 val = lastPosition;
		Vector3 val2 = CenterPoint();
		Vector3 val3 = val2 - val;
		lastPosition = val2;
		if (val == val2 || !IsStuck(bypassColliderCheck: true) || ShouldBypassClippingWallCheck())
		{
			return;
		}
		Ray ray = new Ray(val, val2 - val);
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(ray, 0f, list, Vector3.Distance(val2, val), 2097152, (QueryTriggerInteraction)0);
		foreach (RaycastHit item in list)
		{
			if ((Object)(object)(item.GetEntity() as BuildingBlock) != (Object)null)
			{
				Transform transform = ((Component)this).transform;
				transform.position -= val3;
				ForceExplode();
				break;
			}
		}
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if (canStick && !IsStuck())
		{
			bool flag = true;
			if (Object.op_Implicit((Object)(object)hitEntity))
			{
				flag = CanStickTo(hitEntity);
				if (!flag)
				{
					Collider component = ((Component)this).GetComponent<Collider>();
					if ((Object)(object)collision.collider != (Object)null && (Object)(object)component != (Object)null)
					{
						Physics.IgnoreCollision(collision.collider, component);
					}
				}
			}
			if (flag)
			{
				DoCollisionStick(collision, hitEntity);
			}
		}
		if (explodeOnContact && !IsBusy())
		{
			hitNormal = ((ContactPoint)(ref collision.contacts[0])).normal;
			SetMotionEnabled(wantsMotion: false);
			SetFlag(Flags.Busy, b: true, recursive: false, networkupdate: false);
			((FacepunchBehaviour)this).Invoke((Action)Explode, 0.015f);
		}
		else
		{
			DoBounceEffect();
		}
	}

	public virtual bool CanStickTo(BaseEntity entity)
	{
		object obj = Interface.CallHook("CanExplosiveStick", (object)this, (object)entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		DecorDeployable decorDeployable = default(DecorDeployable);
		if (((Component)entity).TryGetComponent<DecorDeployable>(ref decorDeployable))
		{
			return false;
		}
		if (entity is Drone)
		{
			return false;
		}
		if (entity is TravellingVendor)
		{
			return false;
		}
		return true;
	}

	private void DoBounceEffect()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!bounceEffect.isValid || Time.time - lastBounceTime < 0.2f)
		{
			return;
		}
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component))
		{
			Vector3 velocity = component.velocity;
			if (((Vector3)(ref velocity)).magnitude < 1f)
			{
				return;
			}
		}
		if (bounceEffect.isValid)
		{
			Effect.server.Run(bounceEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
		}
		lastBounceTime = Time.time;
	}

	private void DoCollisionStick(Collision collision, BaseEntity ent)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		ContactPoint contact = collision.GetContact(0);
		DoStick(((ContactPoint)(ref contact)).point, ((ContactPoint)(ref contact)).normal, ent, collision.collider);
	}

	public virtual void SetMotionEnabled(bool wantsMotion)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (wantsMotion)
		{
			if ((Object)(object)component == (Object)null && hadRB)
			{
				component = ((Component)this).gameObject.AddComponent<Rigidbody>();
				component.mass = rbMass;
				component.drag = rbDrag;
				component.angularDrag = rbAngularDrag;
				component.collisionDetectionMode = rbCollisionMode;
				component.useGravity = true;
				component.isKinematic = false;
			}
		}
		else if ((Object)(object)component != (Object)null)
		{
			hadRB = true;
			rbMass = component.mass;
			rbDrag = component.drag;
			rbAngularDrag = component.angularDrag;
			rbCollisionMode = component.collisionDetectionMode;
			rbVelocityBeforeCollision = component.velocity;
			Object.Destroy((Object)(object)component);
		}
	}

	public bool IsStuck(bool bypassColliderCheck = false)
	{
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component) && !component.isKinematic)
		{
			return false;
		}
		if (!bypassColliderCheck)
		{
			Collider component2 = ((Component)this).GetComponent<Collider>();
			if (Object.op_Implicit((Object)(object)component2) && component2.enabled)
			{
				return false;
			}
		}
		return parentEntity.IsValid(serverside: true);
	}

	public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent, Collider collider)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null)
		{
			return;
		}
		if (ent is TimedExplosive)
		{
			if (!ent.HasParent())
			{
				return;
			}
			position = ((Component)ent).transform.position;
			ent = ent.parentEntity.Get(serverside: true);
		}
		SetMotionEnabled(wantsMotion: false);
		if (!HasChild(ent))
		{
			((Component)this).transform.position = position;
			((Component)this).transform.rotation = Quaternion.LookRotation(normal, ((Component)this).transform.up);
			if ((Object)(object)collider != (Object)null)
			{
				SetParent(ent, ent.FindBoneID(((Component)collider).transform), worldPositionStays: true);
			}
			else
			{
				SetParent(ent, StringPool.closest, worldPositionStays: true);
			}
			if (ent is BaseCombatEntity baseCombatEntity)
			{
				baseCombatEntity.SetJustAttacked();
			}
			if (stickEffect.isValid)
			{
				Effect.server.Run(stickEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
			}
			ReceiveCollisionMessages(b: false);
		}
	}

	public void UnStick()
	{
		if (Object.op_Implicit((Object)(object)GetParentEntity()))
		{
			SetParent(null, worldPositionStays: true, sendImmediate: true);
			SetMotionEnabled(wantsMotion: true);
			if (((Component)(object)((Component)this).transform).HasComponent<Collider>())
			{
				ReceiveCollisionMessages(b: true);
			}
		}
	}

	internal override void OnParentRemoved()
	{
		UnStick();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
	}

	public override void PostServerLoad()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		if (parentEntity.IsValid(serverside: true))
		{
			DoStick(((Component)this).transform.position, ((Component)this).transform.forward, parentEntity.Get(serverside: true), null);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.explosive != null)
		{
			parentEntity.uid = info.msg.explosive.parentid;
		}
	}

	public virtual void SetCollisionEnabled(bool wantsCollision)
	{
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component) && component.enabled != wantsCollision)
		{
			component.enabled = wantsCollision;
		}
	}
}


public enum ExplosionEffectOffsetMode
{
	Local,
	World
}


using UnityEngine;

public class BaseTrap : DecayEntity
{
	public virtual void ObjectEntered(GameObject obj)
	{
	}

	public virtual void Arm()
	{
		SetFlag(Flags.On, b: true);
		SendNetworkUpdate();
	}

	public virtual void OnEmpty()
	{
	}
}


using Oxide.Core;
using UnityEngine;

public class BaseTrapTrigger : TriggerBase
{
	public BaseTrap _trap;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		Interface.CallHook("OnTrapSnapped", (object)this, (object)obj, (object)col);
		base.OnObjectAdded(obj, col);
		_trap.ObjectEntered(obj);
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		_trap.OnEmpty();
	}
}


public class BearTrapTrigger : BaseTrapTrigger
{
}


using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class SurvivalFishTrap : WildlifeTrap
{
	private WaterBody cachedWaterBody;

	private bool bypassItemFilter;

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (GamePhysics.Trace(new Ray(((Component)this).transform.position + Vector3.up, Vector3.down), 0f, out var hitInfo, 1.5f, 16, (QueryTriggerInteraction)0))
		{
			cachedWaterBody = hitInfo.GetWaterBody();
		}
	}

	public override bool HasBait()
	{
		ItemModCompostable itemModCompostable = default(ItemModCompostable);
		foreach (Item item in base.inventory.itemList)
		{
			if (item != null && ((Component)item.info).TryGetComponent<ItemModCompostable>(ref itemModCompostable) && itemModCompostable.BaitValue > 0f)
			{
				return true;
			}
		}
		return false;
	}

	public override void TrapThink()
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		ItemDefinition itemDefinition = null;
		Item item = null;
		int usedLureAmount = 0;
		using (List<Item>.Enumerator enumerator = base.inventory.itemList.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				Item current = enumerator.Current;
				ItemModCompostable itemModCompostable = default(ItemModCompostable);
				if ((((Component)current.info).TryGetComponent<ItemModCompostable>(ref itemModCompostable) ? itemModCompostable.BaitValue : 0f) > 0f)
				{
					item = current;
					itemDefinition = FishLookup.Instance.GetFish(((Component)this).transform.position, cachedWaterBody, current, out var _, ((Component)current.info).GetComponent<ItemModFishable>(), out usedLureAmount, 5f);
				}
			}
		}
		item?.UseItem(usedLureAmount);
		if (Random.Range(0f, 1f) <= trapSuccessRate || !((Object)(object)itemDefinition != (Object)null))
		{
			return;
		}
		try
		{
			bypassItemFilter = true;
			if (Interface.CallHook("OnWildlifeTrap", (object)this, (object)itemDefinition) == null)
			{
				Item item2 = ItemManager.Create(itemDefinition, 1, 0uL);
				if ((Object)(object)base.LastLootedByPlayer != (Object)null)
				{
					item2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);
				}
				if (!item2.MoveToContainer(base.inventory))
				{
					item2.Drop(((Component)this).transform.position, Vector3.zero, Quaternion.identity);
				}
				OnTrappedWildlife(setFlag: true);
			}
		}
		finally
		{
			bypassItemFilter = false;
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (FishLookup.Instance == null || item == null)
		{
			return false;
		}
		FishLookup.LoadFish();
		if (bypassItemFilter)
		{
			return true;
		}
		bool flag = false;
		ItemDefinition[] baitItems = FishLookup.BaitItems;
		for (int i = 0; i < baitItems.Length; i++)
		{
			if ((Object)(object)baitItems[i] == (Object)(object)item.info)
			{
				flag = true;
				break;
			}
		}
		return base.ItemFilter(item, targetSlot) && flag;
	}

	protected override bool CanAcceptItem(Item item, int slot)
	{
		if (FishLookup.Instance == null || item == null)
		{
			return false;
		}
		FishLookup.LoadFish();
		if (bypassItemFilter)
		{
			return true;
		}
		bool result = false;
		ItemDefinition[] baitItems = FishLookup.BaitItems;
		for (int i = 0; i < baitItems.Length; i++)
		{
			if ((Object)(object)baitItems[i] == (Object)(object)item.info)
			{
				result = true;
				break;
			}
		}
		return result;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
[CreateAssetMenu(menuName = "Rust/TrappableWildlife")]
public class TrappableWildlife : ScriptableObject
{
	[Serializable]
	public class BaitType
	{
		public float successRate = 1f;

		public ItemDefinition bait;

		public int minForInterest = 1;

		public int maxToConsume = 1;
	}

	public GameObjectRef worldObject;

	public ItemDefinition inventoryObject;

	public int minToCatch;

	public int maxToCatch;

	public List<BaitType> baitTypes;

	public int caloriesForInterest = 20;

	public float successRate = 1f;

	public float xpScale = 1f;
}


using System;

[Serializable]
public class BaitType
{
	public float successRate = 1f;

	public ItemDefinition bait;

	public int minForInterest = 1;

	public int maxToConsume = 1;
}


using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Rust;
using UnityEngine;

public class WildlifeTrap : StorageContainer
{
	[Serializable]
	public class WildlifeWeight
	{
		public TrappableWildlife wildlife;

		public int weight;
	}

	public static class WildlifeTrapFlags
	{
		public const Flags Occupied = Flags.Reserved1;
	}

	public float tickRate = 60f;

	public GameObjectRef trappedEffect;

	public float trappedEffectRepeatRate = 30f;

	public float trapSuccessRate = 0.5f;

	public List<ItemDefinition> ignoreBait;

	public List<WildlifeWeight> targetWildlife;

	public override void ResetState()
	{
		base.ResetState();
	}

	public void SetTrapActive(bool trapOn)
	{
		if (trapOn != IsTrapActive())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TrapThink);
			SetFlag(Flags.On, trapOn);
			if (trapOn)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)TrapThink, tickRate * 0.8f + tickRate * Random.Range(0f, 0.4f), tickRate);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer && IsOn())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)TrapThink, tickRate * 0.8f + tickRate * Random.Range(0f, 0.4f), tickRate);
		}
	}

	[ContextMenu("DebugPrintout")]
	public void DebugPrintout()
	{
		bool flag = ((FacepunchBehaviour)this).IsInvoking((Action)TrapThink);
		Debug.Log((object)$"is invoking: {flag}");
	}

	private int CalculateBaitCalories(Item bait)
	{
		ItemModConsumable component = ((Component)bait.info).GetComponent<ItemModConsumable>();
		if ((Object)(object)component == (Object)null)
		{
			return 0;
		}
		if (ignoreBait.Contains(bait.info))
		{
			return 0;
		}
		int num = 0;
		foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
		{
			if (effect.type == MetabolismAttribute.Type.Calories && effect.amount > 0f)
			{
				num += Mathf.CeilToInt(effect.amount * (float)bait.amount);
			}
		}
		return num;
	}

	public int GetBaitCalories()
	{
		int num = 0;
		foreach (Item item in base.inventory.itemList)
		{
			num += CalculateBaitCalories(item);
		}
		return num;
	}

	public void DestroyRandomFoodItem()
	{
		int count = base.inventory.itemList.Count;
		int num = Random.Range(0, count);
		for (int i = 0; i < count; i++)
		{
			int num2 = num + i;
			if (num2 >= count)
			{
				num2 -= count;
			}
			Item item = base.inventory.itemList[num2];
			if (item != null && !((Object)(object)((Component)item.info).GetComponent<ItemModConsumable>() == (Object)null))
			{
				item.UseItem();
				break;
			}
		}
	}

	public void UseBaitCalories(int numToUse)
	{
		foreach (Item item in base.inventory.itemList)
		{
			int itemCalories = GetItemCalories(item);
			if (itemCalories > 0)
			{
				numToUse -= itemCalories;
				item.UseItem();
				if (numToUse <= 0)
				{
					break;
				}
			}
		}
	}

	public int GetItemCalories(Item item)
	{
		ItemModConsumable component = ((Component)item.info).GetComponent<ItemModConsumable>();
		if ((Object)(object)component == (Object)null)
		{
			return 0;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
		{
			if (effect.type == MetabolismAttribute.Type.Calories && effect.amount > 0f)
			{
				return Mathf.CeilToInt(effect.amount);
			}
		}
		return 0;
	}

	public virtual void TrapThink()
	{
		int baitCalories = GetBaitCalories();
		if (baitCalories <= 0)
		{
			return;
		}
		TrappableWildlife randomWildlife = GetRandomWildlife();
		if (baitCalories >= randomWildlife.caloriesForInterest && Random.Range(0f, 1f) <= randomWildlife.successRate)
		{
			UseBaitCalories(randomWildlife.caloriesForInterest);
			if (Random.Range(0f, 1f) <= trapSuccessRate)
			{
				TrapWildlife(randomWildlife);
			}
		}
	}

	public void TrapWildlife(TrappableWildlife trapped)
	{
		if (Interface.CallHook("OnWildlifeTrap", (object)this, (object)trapped) == null)
		{
			Item item = ItemManager.Create(trapped.inventoryObject, Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL);
			if ((Object)(object)base.LastLootedByPlayer != (Object)null)
			{
				item.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);
			}
			if (!item.MoveToContainer(base.inventory))
			{
				item.Remove();
				OnTrappedWildlife(setFlag: false);
			}
			else
			{
				OnTrappedWildlife(setFlag: true);
			}
		}
	}

	protected void OnTrappedWildlife(bool setFlag)
	{
		if (setFlag)
		{
			SetFlag(Flags.Reserved1, b: true);
		}
		SetTrapActive(trapOn: false);
		Hurt(StartMaxHealth() * 0.1f, DamageType.Decay, null, useProtection: false);
	}

	public void ClearTrap()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public virtual bool HasBait()
	{
		return GetBaitCalories() > 0;
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		SetTrapActive(HasBait());
		ClearTrap();
		base.PlayerStoppedLooting(player);
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		ClearTrap();
		return base.OnStartBeingLooted(baseEntity);
	}

	public TrappableWildlife GetRandomWildlife()
	{
		int num = targetWildlife.Sum((WildlifeWeight x) => x.weight);
		int num2 = Random.Range(0, num);
		for (int i = 0; i < targetWildlife.Count; i++)
		{
			num -= targetWildlife[i].weight;
			if (num2 >= num)
			{
				return targetWildlife[i].wildlife;
			}
		}
		return null;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	protected virtual bool CanAcceptItem(Item item, int slot)
	{
		if (CalculateBaitCalories(item) > 0)
		{
			return true;
		}
		foreach (WildlifeWeight item2 in targetWildlife)
		{
			if ((Object)(object)item2.wildlife?.inventoryObject == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasCatch()
	{
		return HasFlag(Flags.Reserved1);
	}

	public bool IsTrapActive()
	{
		return HasFlag(Flags.On);
	}
}


using System;

[Serializable]
public class WildlifeWeight
{
	public TrappableWildlife wildlife;

	public int weight;
}


public static class WildlifeTrapFlags
{
	public const Flags Occupied = Flags.Reserved1;
}


using UnityEngine;

public class BaseAimable : BaseVehicleMountPoint
{
	public Transform aimBase;
}


public class BaseChair : BaseMountable
{
	public override float GetComfort()
	{
		return 1f;
	}
}


using UnityEngine;

public class BaseVehicleMountPoint : BaseMountable
{
	[Header("BaseVehicleMountPoint")]
	[Tooltip("Only Set this if you definitely need a VehicleFixedUpdate tick on the seat for some reason")]
	public bool RequiresVehicleFixedUpdateOnSeat;

	public override bool DirectlyMountable()
	{
		return false;
	}

	public override BaseVehicle VehicleParent()
	{
		BaseVehicle baseVehicle = GetParentEntity() as BaseVehicle;
		while ((Object)(object)baseVehicle != (Object)null && !baseVehicle.IsVehicleRoot())
		{
			BaseVehicle baseVehicle2 = baseVehicle.GetParentEntity() as BaseVehicle;
			if ((Object)(object)baseVehicle2 == (Object)null)
			{
				return baseVehicle;
			}
			baseVehicle = baseVehicle2;
		}
		return baseVehicle;
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle == (Object)null)
		{
			info = default(WaterLevel.WaterInfo);
			return 0f;
		}
		return baseVehicle.WaterFactorForPlayer(player, out info);
	}

	public override float AirFactor()
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle == (Object)null)
		{
			return 0f;
		}
		return baseVehicle.AirFactor();
	}
}


using UnityEngine;

public class BaseVehicleSeat : BaseVehicleMountPoint
{
	[Header("Vehicle Seat")]
	public bool sendClientInputToVehicleParent;

	public bool forcePlayerModelUpdate;

	public bool giveCrosshair;

	public bool canTeamInteract = true;

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.ScaleDamageForPlayer(player, info);
		}
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.MounteeTookDamage(mountee, info);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			baseVehicle.PlayerServerInput(inputState, player);
		}
		base.PlayerServerInput(inputState, player);
	}

	public override void LightToggle(BasePlayer player)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.LightToggle(player);
		}
	}

	public override void SwitchParent(BaseEntity ent)
	{
	}

	public override Vector3 GetMountRagdollVelocity(BasePlayer player)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			return baseVehicle.GetMountRagdollVelocity(player);
		}
		return base.GetMountRagdollVelocity(player);
	}
}


using System;
using UnityEngine;

public class BasicCar : BaseVehicle
{
	[Serializable]
	public class VehicleWheel
	{
		public Transform shock;

		public WheelCollider wheelCollider;

		public Transform wheel;

		public Transform axle;

		public bool steerWheel;

		public bool brakeWheel = true;

		public bool powerWheel = true;
	}

	public VehicleWheel[] wheels;

	public float brakePedal;

	public float gasPedal;

	public float steering;

	public Transform centerOfMass;

	public Transform steeringWheel;

	public float motorForceConstant = 150f;

	public float brakeForceConstant = 500f;

	public float GasLerpTime = 20f;

	public float SteeringLerpTime = 20f;

	public Transform driverEye;

	public GameObjectRef chairRef;

	public Transform chairAnchorTest;

	public SoundPlayer idleLoopPlayer;

	public Transform engineOffset;

	public SoundDefinition engineSoundDef;

	private static bool chairtest;

	public float throttle;

	public float brake;

	public bool lightsOn = true;

	public override float MaxVelocity()
	{
		return 50f;
	}

	public override Vector3 EyePositionForPlayer(BasePlayer player, Quaternion viewRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (PlayerIsMounted(player))
		{
			return ((Component)driverEye).transform.position;
		}
		return Vector3.zero;
	}

	public override void ServerInit()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient)
		{
			base.ServerInit();
			rigidBody = ((Component)this).GetComponent<Rigidbody>();
			rigidBody.centerOfMass = centerOfMass.localPosition;
			rigidBody.isKinematic = false;
			if (chairtest)
			{
				SpawnChairTest();
			}
		}
	}

	public void SpawnChairTest()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(chairRef.resourcePath, ((Component)chairAnchorTest).transform.localPosition);
		baseEntity.Spawn();
		DestroyOnGroundMissing component = ((Component)baseEntity).GetComponent<DestroyOnGroundMissing>();
		if ((Object)(object)component != (Object)null)
		{
			((Behaviour)component).enabled = false;
		}
		MeshCollider component2 = ((Component)baseEntity).GetComponent<MeshCollider>();
		if (Object.op_Implicit((Object)(object)component2))
		{
			component2.convex = true;
		}
		baseEntity.SetParent(this);
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("BasicCar.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (!HasDriver())
			{
				NoDriverInput();
			}
			ConvertInputToThrottle();
			DoSteering();
			ApplyForceAtWheels();
			SetFlag(Flags.Reserved1, HasDriver());
			SetFlag(Flags.Reserved2, HasDriver() && lightsOn);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void DoSteering()
	{
		VehicleWheel[] array = wheels;
		foreach (VehicleWheel vehicleWheel in array)
		{
			if (vehicleWheel.steerWheel)
			{
				vehicleWheel.wheelCollider.steerAngle = steering;
			}
		}
		SetFlag(Flags.Reserved4, steering < -2f);
		SetFlag(Flags.Reserved5, steering > 2f);
	}

	public void ConvertInputToThrottle()
	{
	}

	public void ApplyForceAtWheels()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		Vector3 velocity = rigidBody.velocity;
		float num = ((Vector3)(ref velocity)).magnitude * Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward);
		float num2 = brakePedal;
		float num3 = gasPedal;
		if (num > 0f && num3 < 0f)
		{
			num2 = 100f;
		}
		else if (num < 0f && num3 > 0f)
		{
			num2 = 100f;
		}
		VehicleWheel[] array = wheels;
		foreach (VehicleWheel vehicleWheel in array)
		{
			if (vehicleWheel.wheelCollider.isGrounded)
			{
				if (vehicleWheel.powerWheel)
				{
					vehicleWheel.wheelCollider.motorTorque = num3 * motorForceConstant;
				}
				if (vehicleWheel.brakeWheel)
				{
					vehicleWheel.wheelCollider.brakeTorque = num2 * brakeForceConstant;
				}
			}
		}
		SetFlag(Flags.Reserved3, num2 >= 100f && AnyMounted());
	}

	public void NoDriverInput()
	{
		if (chairtest)
		{
			gasPedal = Mathf.Sin(Time.time) * 50f;
			return;
		}
		gasPedal = 0f;
		brakePedal = Mathf.Lerp(brakePedal, 100f, Time.deltaTime * GasLerpTime / 5f);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			DriverInput(inputState, player);
		}
	}

	public void DriverInput(InputState inputState, BasePlayer player)
	{
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			gasPedal = 100f;
			brakePedal = 0f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			gasPedal = -30f;
			brakePedal = 0f;
		}
		else
		{
			gasPedal = 0f;
			brakePedal = 30f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			steering = -60f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			steering = 60f;
		}
		else
		{
			steering = 0f;
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			lightsOn = !lightsOn;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class VehicleWheel
{
	public Transform shock;

	public WheelCollider wheelCollider;

	public Transform wheel;

	public Transform axle;

	public bool steerWheel;

	public bool brakeWheel = true;

	public bool powerWheel = true;
}


using UnityEngine;

public class BicycleAudio : BikeVehicleAudio
{
	[Header("Bicycle")]
	[SerializeField]
	private SoundDefinition pedalActiveSoundDef;

	[SerializeField]
	private SoundDefinition pedalCoastSoundDef;

	[SerializeField]
	private SoundDefinition pedalStartDef;

	[SerializeField]
	private SoundDefinition pedalStopDef;

	[SerializeField]
	private SoundDefinition bellSoundDef;

	[SerializeField]
	private AnimationCurve pedalGainCurve;

	[SerializeField]
	private AnimationCurve pedalPitchCurve;

	[SerializeField]
	private SlicedGranularAudioClip pedalClicks;

	[SerializeField]
	private AnimationCurve pedalClickFrequencyCurve;
}


using System;
using UnityEngine;

public class BikeChassisVisuals : VehicleChassisVisuals<Bike>, IClientComponent
{
	[Serializable]
	private class SuspensionSettings
	{
		public bool enabled;

		public Transform front;

		public float frontMinZ = 0.3f;

		public float frontMaxZ = 0.55f;

		public Transform rearTop;

		public Transform rearBottom;

		public Transform rearSwingArm;

		public float swingArmMinAngle = 5f;

		public float swingArmMaxAngle = 25f;
	}

	[Serializable]
	private class PedalBikeSettings
	{
		public bool enabled;

		public Transform axle;

		public float ratio = 0.5f;

		public Transform left;

		public Transform right;

		public Transform[] clockwiseCogs;

		public Transform[] anticlockwiseCogs;

		public float cogRatio = 1f;
	}

	[Serializable]
	private class KickstandSettiongs
	{
		public bool enabled;

		public Transform pivot;

		public Transform spring;

		public Transform springTarget;

		public float kickstandZ;

		public float upX = 180f;

		public float downX = 80f;
	}

	[Serializable]
	private class ChainRenderer
	{
		public Renderer renderer;

		public int materialIndex;
	}

	[SerializeField]
	private SuspensionSettings suspension;

	[SerializeField]
	private PedalBikeSettings pedals;

	[SerializeField]
	private KickstandSettiongs kickstand;

	[SerializeField]
	private BikeVehicleAudio audioScript;

	[SerializeField]
	private ChainRenderer[] chainRenderers;

	[SerializeField]
	private float chainSpeedMultiplier = 1f;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private float minGroundFXSpeed = 3f;
}


using System;
using UnityEngine;

[Serializable]
private class SuspensionSettings
{
	public bool enabled;

	public Transform front;

	public float frontMinZ = 0.3f;

	public float frontMaxZ = 0.55f;

	public Transform rearTop;

	public Transform rearBottom;

	public Transform rearSwingArm;

	public float swingArmMinAngle = 5f;

	public float swingArmMaxAngle = 25f;
}


using System;
using UnityEngine;

[Serializable]
private class PedalBikeSettings
{
	public bool enabled;

	public Transform axle;

	public float ratio = 0.5f;

	public Transform left;

	public Transform right;

	public Transform[] clockwiseCogs;

	public Transform[] anticlockwiseCogs;

	public float cogRatio = 1f;
}


using System;
using UnityEngine;

[Serializable]
private class KickstandSettiongs
{
	public bool enabled;

	public Transform pivot;

	public Transform spring;

	public Transform springTarget;

	public float kickstandZ;

	public float upX = 180f;

	public float downX = 80f;
}


using System;
using UnityEngine;

[Serializable]
private class ChainRenderer
{
	public Renderer renderer;

	public int materialIndex;
}


using UnityEngine;

public class BikeDriverSeat : BikeSeat
{
	[SerializeField]
	private Vector3 sprintPosOffset;
}


using UnityEngine;

public class BikeSeat : MouseSteerableSeat
{
	[SerializeField]
	private Transform eyePosRef;
}


using UnityEngine;

public class BikeVehicleAudio : GroundVehicleAudio
{
	[Header("Engine")]
	[SerializeField]
	private EngineAudioSet engineAudioSet;

	[Header("Suspension")]
	[SerializeField]
	private SoundDefinition suspensionDef;

	[SerializeField]
	private float suspensionMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionMinTimeBetweenSounds = 0.25f;

	[Header("Tires")]
	[SerializeField]
	private SoundDefinition tireDirtSoundDef;

	[SerializeField]
	private SoundDefinition tireGrassSoundDef;

	[SerializeField]
	private SoundDefinition tireSnowSoundDef;

	[SerializeField]
	private SoundDefinition tireWaterSoundDef;

	[SerializeField]
	private AnimationCurve tireGainCurve;

	[SerializeField]
	[Header("Skid")]
	private SoundDefinition skidSoundLoop;

	[SerializeField]
	private SoundDefinition skidSoundDirtLoop;

	[SerializeField]
	private SoundDefinition skidSoundSnowLoop;

	[SerializeField]
	private float skidMinSlip = 10f;

	[SerializeField]
	private float skidMaxSlip = 25f;
}


public class MotorbikeAudio : BikeVehicleAudio
{
}


using System;
using UnityEngine;

public class SidecarBikeChassisVisuals : BikeChassisVisuals
{
	[Serializable]
	private class SidecarSuspensionSettings
	{
		public Transform sidecarVisualHinge;

		public Transform sidecarTop;

		public Transform sidecarBottom;

		public Transform sidecarSwingArm;

		public float scSwingArmMinAngle = -10f;

		public float scSwingArmMaxAngle = 10f;
	}

	[SerializeField]
	private SidecarSuspensionSettings sidecarSuspension;
}


using System;
using UnityEngine;

[Serializable]
private class SidecarSuspensionSettings
{
	public Transform sidecarVisualHinge;

	public Transform sidecarTop;

	public Transform sidecarBottom;

	public Transform sidecarSwingArm;

	public float scSwingArmMinAngle = -10f;

	public float scSwingArmMaxAngle = 10f;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using VacuumBreather;

public class BaseBoat : BaseVehicle
{
	[Header("Boat")]
	public float engineThrust = 10f;

	public float steeringScale = 0.1f;

	public Transform thrustPoint;

	public Transform centerOfMass;

	public Buoyancy buoyancy;

	public bool preventDecayIndoors = true;

	[Header("Correction Forces")]
	public bool applyCorrectionForces = true;

	public Transform[] planeFitPoints;

	public Vector3 inAirPID;

	public float inAirDesiredPitch = -15f;

	public Vector3 wavePID;

	public MinMax correctionRange;

	public float correctionSpringForce;

	public float correctionSpringDamping;

	private Vector3[] worldAnchors;

	private PidQuaternionController pidController;

	[ServerVar]
	public static bool generate_paths = true;

	[ServerVar]
	public static bool do_shore_drift = true;

	public static int secondsUntilShoreDrift = 7200;

	public static int secondsBetweenShoreDrift = 120;

	[ServerVar]
	[Help("Shore drift speed in metres per second")]
	public static float drift_speed = 1f;

	[NonSerialized]
	public float gasPedal;

	[NonSerialized]
	public float steering;

	private TimeSince shoreDriftTimer;

	private string lastDriftCheckStatus = "Never checked";

	protected virtual bool AllowKinematicDrift => false;

	protected virtual bool SkipBoatForcedUpdate => false;

	[Help("Seconds until boat starts drifting to shore if there's nobody around")]
	[ServerVar]
	public static int seconds_until_shore_drift(Arg arg)
	{
		secondsUntilShoreDrift = arg.GetInt(0, secondsUntilShoreDrift);
		UpdateShoreDriftInvokeOnAll();
		return secondsUntilShoreDrift;
	}

	[ServerVar]
	[Help("Seconds between shore drift teleport ticks")]
	public static int seconds_between_shore_drift(Arg arg)
	{
		secondsBetweenShoreDrift = arg.GetInt(0, secondsBetweenShoreDrift);
		UpdateShoreDriftInvokeOnAll();
		return secondsBetweenShoreDrift;
	}

	public bool InDryDock()
	{
		return (Object)(object)GetParentEntity() != (Object)null;
	}

	public override float MaxVelocity()
	{
		return 25f;
	}

	public override void ServerInit()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.isKinematic = false;
		if ((Object)(object)rigidBody == (Object)null)
		{
			Debug.LogWarning((object)"Boat rigidbody null");
			return;
		}
		if ((Object)(object)centerOfMass == (Object)null)
		{
			Debug.LogWarning((object)"boat COM null");
			return;
		}
		rigidBody.centerOfMass = centerOfMass.localPosition;
		if (planeFitPoints == null || planeFitPoints.Length != 3)
		{
			Debug.LogWarning((object)"Boats require 3 plane fit points");
			return;
		}
		worldAnchors = (Vector3[])(object)new Vector3[3];
		pidController = new PidQuaternionController(wavePID.x, wavePID.y, wavePID.z);
		if (Application.isLoadingSave)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
			return;
		}
		shoreDriftTimer = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, (float)secondsUntilShoreDrift, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			DriverInput(inputState, player);
		}
	}

	public virtual void DriverInput(InputState inputState, BasePlayer player)
	{
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			gasPedal = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			gasPedal = -0.5f;
		}
		else
		{
			gasPedal = 0f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			steering = 1f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			steering = -1f;
		}
		else
		{
			steering = 0f;
		}
	}

	public void OnPoolDestroyed()
	{
		Kill(DestroyMode.Gib);
	}

	public void WakeUp()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
			rigidBody.AddForce(Vector3.up * 0.1f, (ForceMode)1);
		}
	}

	protected override void OnServerWake()
	{
		if ((Object)(object)buoyancy != (Object)null)
		{
			buoyancy.Wake();
		}
	}

	public virtual bool EngineOn()
	{
		if (HasDriver())
		{
			return !IsFlipped();
		}
		return false;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseBoat.VehicleFixedUpdate", 0);
		try
		{
			if (!EngineOn())
			{
				gasPedal = 0f;
				steering = 0f;
			}
			base.VehicleFixedUpdate();
			if (!SkipBoatForcedUpdate)
			{
				ApplyCorrectionForces();
				bool flag = WaterLevel.Test(thrustPoint.position, waves: true, volumes: true, this);
				if (gasPedal != 0f && flag && buoyancy.submergedFraction > 0.3f)
				{
					Vector3 val2 = ((Component)this).transform.forward + ((Component)this).transform.right * steering * steeringScale;
					Vector3 val3 = ((Vector3)(ref val2)).normalized * gasPedal * engineThrust;
					rigidBody.AddForceAtPosition(val3, thrustPoint.position, (ForceMode)0);
				}
				if (AnyMounted() && IsFlipped())
				{
					DismountAllPlayers();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected void ApplyCorrectionForces()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0310: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		if (applyCorrectionForces && planeFitPoints != null && planeFitPoints.Length == 3 && HasDriver() && !(buoyancy.submergedFraction < 0.5f))
		{
			Matrix4x4 val = Matrix4x4.TRS(((Component)this).transform.position, Quaternion.Euler(0f, ((Component)this).transform.eulerAngles.y, 0f), Vector3.one);
			for (int i = 0; i < planeFitPoints.Length; i++)
			{
				Vector3 val2 = ((Matrix4x4)(ref val)).MultiplyPoint(planeFitPoints[i].localPosition);
				val2.y = WaterLevel.GetWaterSurface(val2, waves: true, volumes: false);
				worldAnchors[i] = val2;
			}
			Plane val3 = default(Plane);
			((Plane)(ref val3))..ctor(worldAnchors[0], worldAnchors[1], worldAnchors[2]);
			Vector3 normal = ((Plane)(ref val3)).normal;
			Vector3 val4 = Vector3.Normalize(worldAnchors[2] - worldAnchors[1]);
			Quaternion desiredOrientation = Quaternion.LookRotation(Vector3.Cross(normal, val4), normal);
			float y = planeFitPoints[0].localPosition.y;
			float num = (worldAnchors[0].y + worldAnchors[1].y + worldAnchors[2].y) / 3f - y;
			float y2 = ((Component)this).transform.position.y;
			float num2 = num - y2;
			Vector3 velocity = rigidBody.velocity;
			if (y2 > num + correctionRange.x && y2 < num + correctionRange.y)
			{
				float num3 = num2 * correctionSpringForce;
				float num4 = (0f - velocity.y) * correctionSpringDamping;
				rigidBody.AddForce(0f, num3 + num4, 0f, (ForceMode)0);
			}
			if (y2 > num + correctionRange.y)
			{
				desiredOrientation = Quaternion.Euler(inAirDesiredPitch, ((Component)this).transform.eulerAngles.y, 0f);
				pidController.Kp = inAirPID.x;
				pidController.Ki = inAirPID.y;
				pidController.Kd = inAirPID.z;
				Vector3 val5 = pidController.ComputeRequiredAngularAcceleration(((Component)this).transform.rotation, desiredOrientation, rigidBody.angularVelocity, Time.fixedDeltaTime);
				rigidBody.AddTorque(val5, (ForceMode)5);
			}
			else if (y2 > num + correctionRange.x)
			{
				pidController.Kp = wavePID.x;
				pidController.Ki = wavePID.y;
				pidController.Kd = wavePID.z;
				Vector3 val6 = pidController.ComputeRequiredAngularAcceleration(((Component)this).transform.rotation, desiredOrientation, rigidBody.angularVelocity, Time.fixedDeltaTime);
				val6.y = 0f;
				rigidBody.AddTorque(val6, (ForceMode)5);
			}
		}
	}

	public static void WaterVehicleDecay(BaseCombatEntity entity, float decayTickRate, float timeSinceLastUsed, float outsideDecayMinutes, float deepWaterDecayMinutes, float decayStartDelayMinutes, bool preventDecayIndoors)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (entity.healthFraction != 0f && !(timeSinceLastUsed < 60f * decayStartDelayMinutes))
		{
			float overallWaterDepth = WaterLevel.GetOverallWaterDepth(((Component)entity).transform.position, waves: true, volumes: false);
			float num = outsideDecayMinutes;
			if (preventDecayIndoors && !entity.IsOutside())
			{
				num = float.PositiveInfinity;
			}
			if (overallWaterDepth > 12f)
			{
				float num2 = Mathf.InverseLerp(12f, 16f, overallWaterDepth);
				float num3 = Mathf.Lerp(0.1f, 1f, num2);
				num = Mathf.Min(num, deepWaterDecayMinutes / num3);
			}
			if (!float.IsPositiveInfinity(num))
			{
				float num4 = decayTickRate / 60f / num;
				entity.Hurt(entity.MaxHealth() * num4, DamageType.Decay, entity, useProtection: false);
			}
		}
	}

	private void CheckDriftToShore()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		if (!do_shore_drift)
		{
			return;
		}
		if (TimeSince.op_Implicit(shoreDriftTimer) < (float)secondsUntilShoreDrift - 1f)
		{
			lastDriftCheckStatus = "Was too soon";
			return;
		}
		if (!AllowKinematicDrift && rigidBody.isKinematic)
		{
			lastDriftCheckStatus = "Was kinematic";
			return;
		}
		if (IsOn())
		{
			lastDriftCheckStatus = "Was on";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (AnyPlayersOnBoat())
		{
			lastDriftCheckStatus = "Players were on boat";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (HasParent())
		{
			lastDriftCheckStatus = "Was parented";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (IsDead())
		{
			lastDriftCheckStatus = "Is dead";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (WaterFactor() < 0.1f)
		{
			lastDriftCheckStatus = "Not in water";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if ((Object)(object)TerrainTexturing.Instance == (Object)null)
		{
			lastDriftCheckStatus = "No terrain tex";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (BaseNetworkable.HasConnections(((Component)this).transform.position))
		{
			lastDriftCheckStatus = "Players were nearby";
			return;
		}
		float num = bounds.MaxExtent() + 2f;
		float num2 = drift_speed * (float)secondsBetweenShoreDrift;
		(Vector3 shoreDir, float shoreDist) coarseVectorToShore = TerrainTexturing.Instance.GetCoarseVectorToShore(((Component)this).transform.position);
		Vector3 item = coarseVectorToShore.shoreDir;
		float item2 = coarseVectorToShore.shoreDist;
		float num3 = 2f * num;
		if (item2 < num3)
		{
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			lastDriftCheckStatus = "Was near shore already";
			return;
		}
		float maxDistance = num2 - num;
		Vector3 val = ((Component)this).transform.position + ((Bounds)(ref bounds)).center + item * (num + 1f);
		Vector3 val2 = ((Component)this).transform.position + ((Bounds)(ref bounds)).center + item * num2;
		Ray ray = new Ray(val, item);
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(ray, num, list, maxDistance, 1235583233, (QueryTriggerInteraction)1, this);
		if (list.Count > 0)
		{
			foreach (RaycastHit item3 in list)
			{
				RaycastHit current = item3;
				if ((Object)(object)((RaycastHit)(ref current)).collider != (Object)null)
				{
					BaseEntity baseEntity = ((RaycastHit)(ref current)).collider.ToBaseEntity();
					if ((Object)(object)baseEntity != (Object)null && baseEntity.HasEntityInParents(this))
					{
						continue;
					}
				}
				if (((RaycastHit)(ref current)).distance <= num3)
				{
					lastDriftCheckStatus = $"Was blocked by {((Object)((RaycastHit)(ref current)).transform).name} at {((RaycastHit)(ref current)).transform.position}";
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return;
				}
				val2 = ((RaycastHit)(ref current)).point - item * num3;
				val2.y = ((Component)this).transform.position.y + ((Bounds)(ref bounds)).center.y;
				break;
			}
		}
		Vector3 position = ((Component)this).transform.position;
		((Component)this).transform.position = val2 - ((Bounds)(ref bounds)).center;
		rigidBody.velocity = Vector3.zero;
		rigidBody.angularVelocity = Vector3.zero;
		lastDriftCheckStatus = $"Drifted {Vector3.Distance(position, ((Component)this).transform.position):F0}m";
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		((FacepunchBehaviour)this).Invoke((Action)GoToSleep, 0f);
	}

	private void GoToSleep()
	{
		rigidBody.Sleep();
	}

	public virtual bool AnyPlayersOnBoat()
	{
		return AnyMounted();
	}

	public string GetDriftStatus()
	{
		return lastDriftCheckStatus;
	}

	public static void UpdateShoreDriftInvokeOnAll()
	{
		BaseBoat[] array = Util.FindAll<BaseBoat>();
		foreach (BaseBoat baseBoat in array)
		{
			if (baseBoat.IsValid())
			{
				baseBoat.UpdateShoreDriftInvoke();
			}
		}
	}

	private void UpdateShoreDriftInvoke()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Max(0f, (float)secondsUntilShoreDrift - TimeSince.op_Implicit(shoreDriftTimer));
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, num, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.baseBoat = Pool.Get<BaseBoat>();
		info.msg.baseBoat.shoreDriftTimerValue = TimeSince.op_Implicit(shoreDriftTimer);
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.baseBoat != null && base.isServer)
		{
			shoreDriftTimer = TimeSince.op_Implicit(info.msg.baseBoat.shoreDriftTimerValue);
		}
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		info = WaterLevel.GetWaterInfo(player.eyes.position, waves: true, volumes: true);
		if (!info.isValid)
		{
			return 0f;
		}
		return 1f;
	}

	public static List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnBoatPathGenerate");
		if (obj is List<Vector3>)
		{
			return (List<Vector3>)obj;
		}
		float x = TerrainMeta.Size.x;
		float num = x * 2f * MathF.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		List<Vector3> list = new List<Vector3>();
		float num4 = x;
		float num5 = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num6 = (float)i / (float)num3 * 360f;
			list.Add(new Vector3(Mathf.Sin(num6 * (MathF.PI / 180f)) * num4, num5, Mathf.Cos(num6 * (MathF.PI / 180f)) * num4));
		}
		float num7 = 4f;
		float num8 = 200f;
		bool flag = true;
		RaycastHit val9 = default(RaycastHit);
		for (int j = 0; j < AI.ocean_patrol_path_iterations && flag; j++)
		{
			flag = false;
			for (int k = 0; k < num3; k++)
			{
				Vector3 val = list[k];
				int index = ((k == 0) ? (num3 - 1) : (k - 1));
				int index2 = ((k != num3 - 1) ? (k + 1) : 0);
				Vector3 val2 = list[index2];
				Vector3 val3 = list[index];
				Vector3 val4 = val;
				Vector3 val5 = Vector3.zero - val;
				Vector3 normalized = ((Vector3)(ref val5)).normalized;
				Vector3 val6 = val + normalized * num7;
				if (Vector3.Distance(val6, val2) > num8 || Vector3.Distance(val6, val3) > num8)
				{
					continue;
				}
				bool flag2 = true;
				int num9 = 16;
				for (int l = 0; l < num9; l++)
				{
					float num10 = (float)l / (float)num9 * 360f;
					val5 = new Vector3(Mathf.Sin(num10 * (MathF.PI / 180f)), num5, Mathf.Cos(num10 * (MathF.PI / 180f)));
					Vector3 normalized2 = ((Vector3)(ref val5)).normalized;
					Vector3 val7 = val6 + normalized2 * 1f;
					Vector3 val8 = normalized;
					if (val7 != Vector3.zero)
					{
						val5 = val7 - val6;
						val8 = ((Vector3)(ref val5)).normalized;
					}
					if (Physics.SphereCast(val4, 3f, val8, ref val9, minDistanceFromShore, 1084293377))
					{
						flag2 = false;
						break;
					}
				}
				if (flag2)
				{
					flag = true;
					list[k] = val6;
				}
			}
		}
		if (flag)
		{
			Debug.LogWarning((object)"Failed to generate ocean patrol path");
			return null;
		}
		List<int> list2 = new List<int>();
		LineUtility.Simplify(list, 5f, list2);
		List<Vector3> list3 = list;
		list = new List<Vector3>();
		foreach (int item in list2)
		{
			list.Add(list3[item]);
		}
		Debug.Log((object)("Generated ocean patrol path with node count: " + list.Count));
		return list;
	}
}


using System;
using ConVar;
using UnityEngine;
using UnityEngine.Serialization;

public class Buoyancy : ListComponent<Buoyancy>, IServerComponent, IPrefabPreProcess
{
	public enum Priority
	{
		High,
		Low
	}

	[Serializable]
	private struct BuoyancyPointData
	{
		[ReadOnly]
		public Vector3 localPosition;

		[ReadOnly]
		public Vector3 rootToPoint;

		[NonSerialized]
		public Vector3 position;
	}

	public BuoyancyPoint[] points;

	public GameObjectRef[] waterImpacts;

	public Rigidbody rigidBody;

	public float buoyancyScale = 1f;

	public bool scaleForceWithMass;

	public bool doEffects = true;

	public float flowMovementScale = 1f;

	public float requiredSubmergedFraction = 0.5f;

	public bool useUnderwaterDrag;

	[Range(0f, 3f)]
	public float underwaterDrag = 2f;

	[Tooltip("How much this object will pay attention to the wave system, 0 = flat water, 1 = full waves (default 1)")]
	[Range(0f, 1f)]
	[FormerlySerializedAs("flatWaterLerp")]
	public float wavesEffect = 1f;

	public Action<bool> SubmergedChanged;

	public BaseEntity forEntity;

	[NonSerialized]
	public float submergedFraction;

	[ReadOnly]
	[SerializeField]
	private BuoyancyPointData[] pointData;

	private bool initedPointArrays;

	private Vector2[] pointPositionArray;

	private Vector2[] pointPositionUVArray;

	private float[] pointShoreDistanceArray;

	private float[] pointTerrainHeightArray;

	private float[] pointWaterHeightArray;

	private float defaultDrag;

	private float defaultAngularDrag;

	private float timeInWater;

	[NonSerialized]
	public float? ArtificialHeight;

	private BaseVehicle forVehicle;

	private bool hasLocalPlayers;

	private bool hadLocalPlayers;

	public float timeOutOfWater { get; private set; }

	public bool InWater => submergedFraction > requiredSubmergedFraction;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public Priority BuoyancyPriority { get; set; }

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!Application.isPlaying || serverside)
		{
			SavePointData(forced: false);
		}
	}

	public void SavePointData(bool forced)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		if (points == null || points.Length == 0)
		{
			Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)this).gameObject.AddComponent<Rigidbody>();
			}
			GameObject val2 = new GameObject("BuoyancyPoint");
			val2.transform.parent = ((Component)val).gameObject.transform;
			val2.transform.localPosition = val.centerOfMass;
			BuoyancyPoint buoyancyPoint = val2.AddComponent<BuoyancyPoint>();
			buoyancyPoint.buoyancyForce = val.mass * (0f - Physics.gravity.y);
			buoyancyPoint.buoyancyForce *= 1.32f;
			buoyancyPoint.size = 0.2f;
			points = new BuoyancyPoint[1];
			points[0] = buoyancyPoint;
		}
		if (pointData == null || pointData.Length != points.Length || forced)
		{
			pointData = new BuoyancyPointData[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Transform transform = ((Component)points[i]).transform;
				pointData[i].localPosition = transform.localPosition;
				pointData[i].rootToPoint = ((Component)this).transform.InverseTransformPoint(transform.position);
			}
		}
	}

	public static string DefaultWaterImpact()
	{
		return "assets/bundled/prefabs/fx/impacts/physics/water-enter-exit.prefab";
	}

	private void Awake()
	{
		forVehicle = forEntity as BaseVehicle;
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckSleepState, 0.5f, 5f, 1f);
	}

	public void Sleep()
	{
		if (((Object)(object)forEntity == (Object)null || !forEntity.BuoyancySleep(InWater)) && (Object)(object)rigidBody != (Object)null)
		{
			rigidBody.Sleep();
		}
		((Behaviour)this).enabled = false;
	}

	public void Wake()
	{
		if (((Object)(object)forEntity == (Object)null || !forEntity.BuoyancyWake()) && (Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
		}
		((Behaviour)this).enabled = true;
	}

	public void CheckSleepState()
	{
		if ((Object)(object)((Component)this).transform == (Object)null || (Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		hasLocalPlayers = HasLocalPlayers();
		bool flag = rigidBody.IsSleeping() || rigidBody.isKinematic;
		bool flag2 = flag || (!hasLocalPlayers && timeInWater > 6f);
		if ((Object)(object)forVehicle != (Object)null && forVehicle.IsOn())
		{
			flag2 = false;
		}
		if (((Behaviour)this).enabled && flag2)
		{
			((FacepunchBehaviour)this).Invoke((Action)Sleep, 0f);
			return;
		}
		if (!((Behaviour)this).enabled && hasLocalPlayers && !hadLocalPlayers)
		{
			DoCycle(forced: true);
		}
		bool flag3 = !flag || ShouldWake(hasLocalPlayers);
		if (!((Behaviour)this).enabled && flag3)
		{
			((FacepunchBehaviour)this).Invoke((Action)Wake, 0f);
		}
		hadLocalPlayers = hasLocalPlayers;
	}

	public void LowPriorityCheck(bool forceHighPriority)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		Priority buoyancyPriority = BuoyancyPriority;
		Priority priority = buoyancyPriority;
		if (forceHighPriority)
		{
			priority = Priority.High;
		}
		else
		{
			Vector3 position = ((Component)this).transform.position;
			priority = ((!BaseNetworkable.HasCloseConnections(position, Server.lowPriorityBuoyancyRange)) ? Priority.Low : Priority.High);
			if (priority == Priority.Low && priority != buoyancyPriority)
			{
				Vector3 val = Vector3Ex.WithY(((Component)this).transform.TransformPoint(Vector3.forward * 2f), position.y);
				Rigidbody obj = rigidBody;
				Vector3 val2 = val - rigidBody.position;
				obj.rotation = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
			}
		}
		if (priority != buoyancyPriority)
		{
			rigidBody.velocity = Vector3.zero;
			rigidBody.angularVelocity = Vector3.zero;
			BuoyancyPriority = priority;
		}
	}

	public bool ShouldWake()
	{
		return ShouldWake(HasLocalPlayers());
	}

	public bool ShouldWake(bool hasLocalPlayers)
	{
		if (hasLocalPlayers)
		{
			return submergedFraction > 0f;
		}
		return false;
	}

	private bool HasLocalPlayers()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return BaseNetworkable.HasCloseConnections(((Component)this).transform.position, 100f);
	}

	protected void DoCycle(bool forced = false)
	{
		if (!((Behaviour)this).enabled && !forced)
		{
			return;
		}
		bool num = submergedFraction > 0f;
		BuoyancyFixedUpdate();
		bool flag = submergedFraction > 0f;
		if (num == flag)
		{
			return;
		}
		if (useUnderwaterDrag && (Object)(object)rigidBody != (Object)null)
		{
			if (flag)
			{
				defaultDrag = rigidBody.drag;
				defaultAngularDrag = rigidBody.angularDrag;
				rigidBody.drag = underwaterDrag;
				rigidBody.angularDrag = underwaterDrag;
			}
			else
			{
				rigidBody.drag = defaultDrag;
				rigidBody.angularDrag = defaultAngularDrag;
			}
		}
		if (SubmergedChanged != null)
		{
			SubmergedChanged(flag);
		}
	}

	public static void Cycle()
	{
		bool autoSyncTransforms = Physics.autoSyncTransforms;
		try
		{
			Physics.autoSyncTransforms = false;
			Buoyancy[] buffer = ListComponent<Buoyancy>.InstanceList.Values.Buffer;
			int count = ListComponent<Buoyancy>.InstanceList.Count;
			for (int i = 0; i < count; i++)
			{
				buffer[i].DoCycle();
			}
		}
		finally
		{
			if (autoSyncTransforms)
			{
				Physics.SyncTransforms();
			}
			Physics.autoSyncTransforms = autoSyncTransforms;
		}
	}

	private Vector3 GetFlowDirection(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return WaterLevel.GetWaterFlowDirection(worldPos);
	}

	public void BuoyancyFixedUpdate()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0442: Unknown result type (might be due to invalid IL or missing references)
		//IL_0444: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		if (buoyancyScale == 0f)
		{
			((FacepunchBehaviour)this).Invoke((Action)Sleep, 0f);
			return;
		}
		if (BuoyancyPriority == Priority.Low)
		{
			WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(((Component)this).transform.position, waves: true, volumes: true, forEntity);
			Vector3 position = rigidBody.position;
			if (position.y < waterInfo.surfaceLevel)
			{
				rigidBody.position = new Vector3(position.x, waterInfo.surfaceLevel, position.z);
			}
			return;
		}
		if (!initedPointArrays)
		{
			InitPointArrays();
		}
		float time = Time.time;
		float x = TerrainMeta.Position.x;
		float z = TerrainMeta.Position.z;
		float x2 = TerrainMeta.OneOverSize.x;
		float z2 = TerrainMeta.OneOverSize.z;
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		for (int i = 0; i < pointData.Length; i++)
		{
			Vector3 val = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(pointData[i].rootToPoint);
			pointData[i].position = val;
			float num = (val.x - x) * x2;
			float num2 = (val.z - z) * z2;
			pointPositionArray[i] = new Vector2(val.x, val.z);
			pointPositionUVArray[i] = new Vector2(num, num2);
		}
		WaterSystem.GetHeightArray(pointPositionArray, pointPositionUVArray, pointShoreDistanceArray, pointTerrainHeightArray, pointWaterHeightArray);
		bool flag = wavesEffect < 1f;
		int num3 = 0;
		Vector3 accumForce = default(Vector3);
		Vector3 val2 = default(Vector3);
		for (int j = 0; j < points.Length; j++)
		{
			BuoyancyPoint buoyancyPoint = points[j];
			Vector3 pos = pointData[j].position;
			Vector3 localPosition = pointData[j].localPosition;
			Vector2 posUV = pointPositionUVArray[j];
			float terrainHeight = pointTerrainHeightArray[j];
			float num4 = pointWaterHeightArray[j];
			if (ArtificialHeight.HasValue)
			{
				num4 = ArtificialHeight.Value;
			}
			else if (flag)
			{
				num4 = Mathf.Lerp(0f, num4, wavesEffect);
			}
			bool doDeepwaterChecks = !ArtificialHeight.HasValue;
			WaterLevel.WaterInfo waterInfo2 = WaterLevel.GetBuoyancyWaterInfo(pos, posUV, terrainHeight, num4, doDeepwaterChecks, forEntity);
			if (flag && waterInfo2.isValid)
			{
				waterInfo2.currentDepth = Mathf.Lerp(waterInfo2.currentDepth, waterInfo2.surfaceLevel - pos.y, wavesEffect);
			}
			bool flag2 = false;
			if (pos.y < waterInfo2.surfaceLevel && waterInfo2.isValid)
			{
				flag2 = true;
				num3++;
				float currentDepth = waterInfo2.currentDepth;
				float num5 = Mathf.InverseLerp(0f, buoyancyPoint.size, currentDepth);
				float num6 = 1f + Mathf.PerlinNoise(buoyancyPoint.randomOffset + time * buoyancyPoint.waveFrequency, 0f) * buoyancyPoint.waveScale;
				float num7 = buoyancyPoint.buoyancyForce * buoyancyScale;
				if (scaleForceWithMass)
				{
					num7 *= rigidBody.mass;
				}
				((Vector3)(ref accumForce))..ctor(0f, num6 * num5 * num7, 0f);
				AccumulateFlowForce(ref accumForce, in pos, in waterInfo2, Mathf.Abs(pointShoreDistanceArray[j]), num7);
				rigidBody.AddForceAtPosition(accumForce, pos, (ForceMode)0);
			}
			if (buoyancyPoint.doSplashEffects && ((!buoyancyPoint.wasSubmergedLastFrame && flag2) || (!flag2 && buoyancyPoint.wasSubmergedLastFrame)) && doEffects)
			{
				Vector3 relativePointVelocity = rigidBody.GetRelativePointVelocity(localPosition);
				if (((Vector3)(ref relativePointVelocity)).magnitude > 1f)
				{
					string strName = ((waterImpacts != null && waterImpacts.Length != 0 && waterImpacts[0].isValid) ? waterImpacts[0].resourcePath : DefaultWaterImpact());
					((Vector3)(ref val2))..ctor(Random.Range(-0.25f, 0.25f), 0f, Random.Range(-0.25f, 0.25f));
					Effect.server.Run(strName, pos + val2, Vector3.up);
					buoyancyPoint.nexSplashTime = Time.time + 0.25f;
				}
			}
			buoyancyPoint.wasSubmergedLastFrame = flag2;
		}
		if (points.Length != 0)
		{
			submergedFraction = (float)num3 / (float)points.Length;
		}
		if (InWater)
		{
			timeInWater += Time.fixedDeltaTime;
			timeOutOfWater = 0f;
		}
		else
		{
			timeOutOfWater += Time.fixedDeltaTime;
			timeInWater = 0f;
		}
	}

	public void AccumulateFlowForce(ref Vector3 accumForce, in Vector3 pos, in WaterLevel.WaterInfo waterInfo, float shoreDistance, float scaledBuoyancyForce)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		if ((waterInfo.topology & 0x10000) == 0)
		{
			float num = Mathf.Clamp01(Mathf.InverseLerp(60f, 0f, shoreDistance));
			if (!(num <= Mathf.Epsilon))
			{
				num = Mathf.Pow(num, 0.5f);
				Vector3 flowDirection = GetFlowDirection(pos);
				scaledBuoyancyForce *= 0.025f * num;
				accumForce.x += flowDirection.x * scaledBuoyancyForce * flowMovementScale;
				accumForce.z += flowDirection.z * scaledBuoyancyForce * flowMovementScale;
			}
		}
	}

	private void InitPointArrays()
	{
		pointPositionArray = (Vector2[])(object)new Vector2[points.Length];
		pointPositionUVArray = (Vector2[])(object)new Vector2[points.Length];
		pointShoreDistanceArray = new float[points.Length];
		pointTerrainHeightArray = new float[points.Length];
		pointWaterHeightArray = new float[points.Length];
		initedPointArrays = true;
	}
}


public enum Priority
{
	High,
	Low
}


using System;
using UnityEngine;

[Serializable]
private struct BuoyancyPointData
{
	[ReadOnly]
	public Vector3 localPosition;

	[ReadOnly]
	public Vector3 rootToPoint;

	[NonSerialized]
	public Vector3 position;
}


using System;
using UnityEngine;

public class BuoyancyPoint : MonoBehaviour
{
	public float buoyancyForce = 10f;

	public float size = 0.1f;

	public float waveScale = 0.2f;

	public float waveFrequency = 1f;

	public bool doSplashEffects = true;

	[NonSerialized]
	public float randomOffset;

	[NonSerialized]
	public bool wasSubmergedLastFrame;

	[NonSerialized]
	public float nexSplashTime;

	private static readonly Color gizmoColour = new Color(1f, 0f, 0f, 0.25f);

	public void Start()
	{
		randomOffset = Random.Range(0f, 20f);
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = gizmoColour;
		Gizmos.DrawSphere(((Component)this).transform.position, size * 0.5f);
	}
}


using UnityEngine;

public class KayakSeat : BaseVehicleSeat
{
	public ItemDefinition PaddleItem;

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		if ((Object)(object)VehicleParent() != (Object)null)
		{
			VehicleParent().OnPlayerMounted();
		}
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		if ((Object)(object)VehicleParent() != (Object)null)
		{
			VehicleParent().OnPlayerDismounted(player);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class RHIBAIController : FacepunchBehaviour
{
	public List<Vector3> nodes = new List<Vector3>();

	[ContextMenu("Calculate Path")]
	public void SetupPatrolPath()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float num = x * 2f * MathF.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		nodes = new List<Vector3>();
		float num4 = x;
		float num5 = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num6 = (float)i / (float)num3 * 360f;
			nodes.Add(new Vector3(Mathf.Sin(num6 * (MathF.PI / 180f)) * num4, num5, Mathf.Cos(num6 * (MathF.PI / 180f)) * num4));
		}
		float num7 = 2f;
		float num8 = 200f;
		float num9 = 150f;
		float num10 = 8f;
		bool flag = true;
		int num11 = 1;
		float num12 = 20f;
		Vector3[] array = (Vector3[])(object)new Vector3[5]
		{
			new Vector3(0f, 0f, 0f),
			new Vector3(num12, 0f, 0f),
			new Vector3(0f - num12, 0f, 0f),
			new Vector3(0f, 0f, num12),
			new Vector3(0f, 0f, 0f - num12)
		};
		RaycastHit val9 = default(RaycastHit);
		while (flag)
		{
			Debug.Log((object)("Loop # :" + num11));
			num11++;
			flag = false;
			for (int j = 0; j < num3; j++)
			{
				Vector3 val = nodes[j];
				int index = ((j == 0) ? (num3 - 1) : (j - 1));
				int index2 = ((j != num3 - 1) ? (j + 1) : 0);
				Vector3 val2 = nodes[index2];
				Vector3 val3 = nodes[index];
				Vector3 val4 = val;
				Vector3 val5 = Vector3.zero - val;
				Vector3 normalized = ((Vector3)(ref val5)).normalized;
				Vector3 val6 = val + normalized * num7;
				if (Vector3.Distance(val6, val2) > num8 || Vector3.Distance(val6, val3) > num8)
				{
					continue;
				}
				bool flag2 = true;
				for (int k = 0; k < array.Length; k++)
				{
					Vector3 val7 = val6 + array[k];
					if (GetWaterDepth(val7) < num10)
					{
						flag2 = false;
					}
					Vector3 val8 = normalized;
					if (val7 != Vector3.zero)
					{
						val5 = val7 - val4;
						val8 = ((Vector3)(ref val5)).normalized;
					}
					if (Physics.Raycast(val4, val8, ref val9, num9, 1218511105))
					{
						flag2 = false;
					}
				}
				if (flag2)
				{
					flag = true;
					nodes[j] = val6;
				}
			}
		}
		List<int> list = new List<int>();
		LineUtility.Simplify(nodes, 15f, list);
		List<Vector3> list2 = nodes;
		nodes = new List<Vector3>();
		foreach (int item in list)
		{
			nodes.Add(list2[item]);
		}
	}

	public float GetWaterDepth(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (!Physics.Raycast(pos, Vector3.down, ref val, 100f, 8388608))
		{
			return 100f;
		}
		return ((RaycastHit)(ref val)).distance;
	}

	public void OnDrawGizmosSelected()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.Path.OceanPatrolClose != null)
		{
			for (int i = 0; i < TerrainMeta.Path.OceanPatrolClose.Count; i++)
			{
				Vector3 val = TerrainMeta.Path.OceanPatrolClose[i];
				Gizmos.color = Color.green;
				Gizmos.DrawSphere(val, 3f);
				Vector3 val2 = ((i + 1 == TerrainMeta.Path.OceanPatrolClose.Count) ? TerrainMeta.Path.OceanPatrolClose[0] : TerrainMeta.Path.OceanPatrolClose[i + 1]);
				Gizmos.DrawLine(val, val2);
			}
		}
	}
}


using UnityEngine;

public class TugboatInteriorSoundTrigger : MonoBehaviour, IClientComponent
{
	public TugboatSounds tugboatSounds;

	public bool bridge;
}


using UnityEngine;

public class TugboatSounds : MonoBehaviour, IClientComponent
{
	[SerializeField]
	private Tugboat tugboat;

	[SerializeField]
	private float roughHalfWidth = 5f;

	[SerializeField]
	private float roughHalfLength = 10f;

	private float soundCullDistanceSq;

	[Header("Engine")]
	[SerializeField]
	private SoundDefinition engineLoopDef;

	private Sound engineLoop;

	private SoundModulation.Modulator engineGainMod;

	private SoundModulation.Modulator enginePitchMod;

	[SerializeField]
	private SoundDefinition engineStartDef;

	[SerializeField]
	private SoundDefinition engineStartBridgeDef;

	[SerializeField]
	private SoundDefinition engineStopDef;

	[SerializeField]
	private SoundDefinition engineStopBridgeDef;

	[SerializeField]
	private float engineGainChangeRate = 1f;

	[SerializeField]
	private float enginePitchChangeRate = 0.5f;

	[SerializeField]
	private Transform engineTransform;

	[SerializeField]
	private Transform bridgeControlsTransform;

	[SerializeField]
	[Header("Water")]
	private SoundDefinition waterIdleDef;

	[SerializeField]
	private SoundDefinition waterSideMovementSlowDef;

	[SerializeField]
	private SoundDefinition waterSideMovementFastDef;

	[SerializeField]
	private SoundDefinition waterSternMovementDef;

	[SerializeField]
	private SoundDefinition waterInteriorIdleDef;

	[SerializeField]
	private SoundDefinition waterInteriorDef;

	[SerializeField]
	private AnimationCurve waterMovementGainCurve;

	[SerializeField]
	private float waterMovementGainChangeRate = 0.5f;

	[SerializeField]
	private AnimationCurve waterDistanceGainCurve;

	private Sound leftWaterSound;

	private SoundModulation.Modulator leftWaterGainMod;

	private Sound rightWaterSound;

	private SoundModulation.Modulator rightWaterGainMod;

	private Sound sternWaterSound;

	private SoundModulation.Modulator sternWaterGainMod;

	[SerializeField]
	private Transform wakeTransform;

	[SerializeField]
	private Vector3 sideSoundLineStern;

	[SerializeField]
	private Vector3 sideSoundLineBow;

	[Header("Ambient")]
	[SerializeField]
	private SoundDefinition ambientActiveLoopDef;

	private Sound ambientActiveSound;

	[SerializeField]
	private SoundDefinition hullGroanDef;

	[SerializeField]
	private float hullGroanCooldown = 1f;

	private float lastHullGroan;

	[SerializeField]
	private SoundDefinition chainRattleDef;

	[SerializeField]
	private float chainRattleCooldown = 1f;

	[SerializeField]
	private Transform[] chainRattleLocations;

	[SerializeField]
	private float chainRattleAngleDeltaThreshold = 1f;

	private float lastChainRattle;

	[SerializeField]
	[Header("Horn")]
	private SoundDefinition hornLoop;

	[SerializeField]
	private SoundDefinition hornStart;

	[SerializeField]
	private SoundDefinition hornStop;

	[Tooltip("The maximum amount of time a looped horn can last. If 0s then this is ignored.")]
	[SerializeField]
	[Min(0f)]
	private float maxHornTime;

	[SerializeField]
	[Min(0f)]
	[Tooltip("Used for rate limiting. This defines the maximum number of horn spams that can be invoked one after another.")]
	private int hornTokenCapacity = 3;

	[Min(0f)]
	[SerializeField]
	[Tooltip("Used for rate limiting. This defines how quickly a new token regenerates, permitting another horn honk.")]
	private float hornTokenRegenerationTime = 1f;

	private Line leftSoundLine;

	private Line rightSoundLine;

	[Header("Runtime")]
	public bool engineOn;

	public bool throttleOn;

	public bool inWater = true;
}


using System;
using UnityEngine;

[Serializable]
public class CarSettings
{
	[Header("Vehicle Setup")]
	[Range(0f, 1f)]
	public float rollingResistance = 0.05f;

	[Range(0f, 1f)]
	public float antiRoll;

	public bool canSleep = true;

	[Header("Wheels")]
	public bool tankSteering;

	[Range(0f, 50f)]
	public float maxSteerAngle = 35f;

	public bool steeringAssist = true;

	[Range(0f, 1f)]
	public float steeringAssistRatio = 0.5f;

	public bool steeringLimit;

	[Range(0f, 50f)]
	public float minSteerLimitAngle = 6f;

	[Range(10f, 50f)]
	public float minSteerLimitSpeed = 30f;

	[Range(0f, 1f)]
	public float rearWheelSteer = 1f;

	public float steerMinLerpSpeed = 75f;

	public float steerMaxLerpSpeed = 150f;

	public float steerReturnLerpSpeed = 200f;

	public bool retainLerpSpeed;

	[Header("Motor")]
	public float maxDriveSlip = 4f;

	public float driveForceToMaxSlip = 1000f;

	public float reversePercentSpeed = 0.3f;

	[Header("Brakes")]
	public float brakeForceMultiplier = 1000f;

	public bool disableHandbrakes;

	[Header("Front/Rear Vehicle Balance")]
	[Range(0f, 1f)]
	public float handlingBias = 0.5f;
}


using System;
using UnityEngine;

[Serializable]
public class CarWheel
{
	public WheelCollider wheelCollider;

	[Range(0.0001f, 3f)]
	public float tyreFriction = 1f;

	public bool steerWheel;

	public bool brakeWheel = true;

	public bool powerWheel = true;
}


using System;
using ConVar;
using UnityEngine;

public class CarPhysics<TCar> where TCar : BaseVehicle, CarPhysics<TCar>.ICar
{
	public interface ICar
	{
		VehicleTerrainHandler.Surface OnSurface { get; }

		float GetThrottleInput();

		float GetBrakeInput();

		float GetSteerInput();

		bool GetSteerSpeedMod(float speed);

		float GetSteerMaxMult(float speed);

		float GetMaxForwardSpeed();

		float GetMaxDriveForce();

		float GetAdjustedDriveForce(float absSpeed, float topSpeed);

		float GetModifiedDrag();

		CarWheel[] GetWheels();

		float GetWheelsMidPos();
	}

	private class ServerWheelData
	{
		public CarWheel wheel;

		public Transform wheelColliderTransform;

		public WheelCollider wheelCollider;

		public bool isGrounded;

		public float downforce;

		public float forceDistance;

		public WheelHit hit;

		public Vector2 localRigForce;

		public Vector2 localVelocity;

		public float angularVelocity;

		public Vector3 origin;

		public Vector2 tyreForce;

		public Vector2 tyreSlip;

		public Vector3 velocity;

		public bool isBraking;

		public bool hasThrottleInput;

		public bool isFrontWheel;

		public bool isLeftWheel;
	}

	private readonly ServerWheelData[] wheelData;

	private readonly TCar car;

	private readonly Transform transform;

	private readonly Rigidbody rBody;

	private readonly CarSettings vehicleSettings;

	private float speedAngle;

	private bool wasSleeping = true;

	private bool hasDriver;

	private bool hadDriver;

	private float steerLerpSpeed;

	public float lastMovingTime = float.MinValue;

	private WheelFrictionCurve zeroFriction;

	private Vector3 prevLocalCOM;

	private readonly float midWheelPos;

	private const bool WHEEL_HIT_CORRECTION = true;

	private const float SLEEP_SPEED = 0.25f;

	private const float SLEEP_DELAY = 10f;

	private const float AIR_DRAG = 0.25f;

	private const float DEFAULT_GROUND_GRIP = 0.75f;

	private const float ROAD_GROUND_GRIP = 1f;

	private const float ICE_GROUND_GRIP = 0.25f;

	private bool slowSpeedExitFlag;

	private const float SLOW_SPEED_EXIT_SPEED = 4f;

	public TimeSince timeSinceWaterCheck;

	public float DriveWheelVelocity { get; private set; }

	public float DriveWheelSlip { get; private set; }

	public float SteerAngle { get; private set; }

	public float TankThrottleLeft { get; private set; }

	public float TankThrottleRight { get; private set; }

	private bool InSlowSpeedExitMode
	{
		get
		{
			if (!hasDriver)
			{
				return slowSpeedExitFlag;
			}
			return false;
		}
	}

	public CarPhysics(TCar car, Transform transform, Rigidbody rBody, CarSettings vehicleSettings)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		WheelFrictionCurve val = default(WheelFrictionCurve);
		((WheelFrictionCurve)(ref val)).stiffness = 0f;
		zeroFriction = val;
		Transform transform2 = transform;
		base..ctor();
		CarPhysics<TCar> carPhysics = this;
		this.car = car;
		this.transform = transform2;
		this.rBody = rBody;
		this.vehicleSettings = vehicleSettings;
		timeSinceWaterCheck = default(TimeSince);
		timeSinceWaterCheck = TimeSince.op_Implicit(float.MaxValue);
		prevLocalCOM = rBody.centerOfMass;
		CarWheel[] wheels = car.GetWheels();
		wheelData = new ServerWheelData[wheels.Length];
		for (int i = 0; i < wheelData.Length; i++)
		{
			wheelData[i] = AddWheel(wheels[i]);
		}
		midWheelPos = car.GetWheelsMidPos();
		wheelData[0].wheel.wheelCollider.ConfigureVehicleSubsteps(1000f, 1, 1);
		lastMovingTime = Time.realtimeSinceStartup;
		ServerWheelData AddWheel(CarWheel wheel)
		{
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			ServerWheelData obj = new ServerWheelData
			{
				wheelCollider = wheel.wheelCollider,
				wheelColliderTransform = ((Component)wheel.wheelCollider).transform,
				forceDistance = GetWheelForceDistance(wheel.wheelCollider),
				wheel = wheel
			};
			obj.wheelCollider.sidewaysFriction = zeroFriction;
			obj.wheelCollider.forwardFriction = zeroFriction;
			Vector3 val2 = transform2.InverseTransformPoint(((Component)wheel.wheelCollider).transform.position);
			obj.isFrontWheel = val2.z > 0f;
			obj.isLeftWheel = val2.x < 0f;
			return obj;
		}
	}

	public void FixedUpdate(float dt, float speed)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("CarPhysics.FixedUpdate", 0);
		try
		{
			if (rBody.centerOfMass != prevLocalCOM)
			{
				COMChanged();
			}
			float num = Mathf.Abs(speed);
			hasDriver = car.HasDriver();
			if (!hasDriver && hadDriver)
			{
				if (num <= 4f)
				{
					slowSpeedExitFlag = true;
				}
			}
			else if (hasDriver && !hadDriver)
			{
				slowSpeedExitFlag = false;
			}
			if ((hasDriver || !vehicleSettings.canSleep) && rBody.IsSleeping())
			{
				rBody.WakeUp();
			}
			Vector3 val2;
			if (!rBody.IsSleeping())
			{
				if ((!wasSleeping || rBody.isKinematic) && !(num > 0.25f))
				{
					val2 = rBody.angularVelocity;
					if (!(Mathf.Abs(((Vector3)(ref val2)).magnitude) > 0.25f))
					{
						goto IL_0103;
					}
				}
				lastMovingTime = Time.time;
				goto IL_0103;
			}
			wasSleeping = true;
			goto IL_05ed;
			IL_0103:
			bool flag = vehicleSettings.canSleep && !hasDriver && Time.time > lastMovingTime + 10f;
			if (flag && (car.GetParentEntity() as BaseVehicle).IsValid())
			{
				flag = false;
			}
			if (flag)
			{
				for (int i = 0; i < wheelData.Length; i++)
				{
					ServerWheelData serverWheelData = wheelData[i];
					serverWheelData.wheelCollider.motorTorque = 0f;
					serverWheelData.wheelCollider.brakeTorque = 0f;
					serverWheelData.wheelCollider.steerAngle = 0f;
					if (vehicle.disable_wheels_when_sleeping)
					{
						((Collider)serverWheelData.wheelCollider).enabled = false;
					}
				}
				rBody.Sleep();
				goto IL_05dd;
			}
			speedAngle = Vector3.Angle(rBody.velocity, transform.forward) * Mathf.Sign(Vector3.Dot(rBody.velocity, transform.right));
			float maxDriveForce = car.GetMaxDriveForce();
			float maxForwardSpeed = car.GetMaxForwardSpeed();
			float num2 = (car.IsOn() ? car.GetThrottleInput() : 0f);
			float steerInput = car.GetSteerInput();
			float brakeInput = (InSlowSpeedExitMode ? 1f : car.GetBrakeInput());
			float num3 = 1f;
			if (num < 3f)
			{
				num3 = 2.75f;
			}
			else if (num < 9f)
			{
				float num4 = Mathf.InverseLerp(9f, 3f, num);
				num3 = Mathf.Lerp(1f, 2.75f, num4);
			}
			maxDriveForce *= num3;
			ComputeSteerAngle(num2, steerInput, dt, speed);
			if (TimeSince.op_Implicit(timeSinceWaterCheck) > 0.25f)
			{
				float num5 = car.WaterFactor();
				float num6 = 0f;
				if (car.FindTrigger<TriggerVehicleDrag>(out var result))
				{
					num6 = result.vehicleDrag;
				}
				float num7 = ((num2 != 0f) ? 0f : 0.25f);
				float num8 = Mathf.Max(num5, num6);
				num8 = Mathf.Max(num8, car.GetModifiedDrag());
				rBody.drag = Mathf.Max(num7, num8);
				rBody.angularDrag = num8 * 0.5f;
				timeSinceWaterCheck = TimeSince.op_Implicit(0f);
			}
			int num9 = 0;
			float num10 = 0f;
			int num11;
			if (!vehicleSettings.disableHandbrakes)
			{
				if (!hasDriver)
				{
					val2 = rBody.velocity;
					if (((Vector3)(ref val2)).magnitude < 2.5f && TimeSince.op_Implicit(car.timeSinceLastPush) > 2f)
					{
						num11 = ((car.OnSurface != VehicleTerrainHandler.Surface.Frictionless) ? 1 : 0);
						goto IL_0412;
					}
				}
				num11 = 0;
			}
			else
			{
				num11 = 0;
			}
			goto IL_0412;
			IL_0412:
			bool flag2 = (byte)num11 != 0;
			bool flag3 = !vehicleSettings.disableHandbrakes && !flag2 && num2 == 0f && num < 0.2f && TimeSince.op_Implicit(car.timeSinceLastPush) > 2f && car.OnSurface != VehicleTerrainHandler.Surface.Frictionless;
			for (int j = 0; j < wheelData.Length; j++)
			{
				ServerWheelData serverWheelData2 = wheelData[j];
				if (!((Collider)serverWheelData2.wheelCollider).enabled)
				{
					((Collider)serverWheelData2.wheelCollider).enabled = true;
					serverWheelData2.wheelCollider.ConfigureVehicleSubsteps(1000f, 1, 1);
				}
				serverWheelData2.wheelCollider.motorTorque = 1E-05f;
				if (flag2)
				{
					serverWheelData2.wheelCollider.brakeTorque = 10000f;
				}
				else if (flag3)
				{
					serverWheelData2.wheelCollider.brakeTorque = 1000f;
				}
				else
				{
					serverWheelData2.wheelCollider.brakeTorque = 0f;
				}
				if (serverWheelData2.wheel.steerWheel)
				{
					serverWheelData2.wheel.wheelCollider.steerAngle = (serverWheelData2.isFrontWheel ? SteerAngle : (vehicleSettings.rearWheelSteer * (0f - SteerAngle)));
				}
				UpdateSuspension(serverWheelData2);
				if (serverWheelData2.isGrounded)
				{
					num9++;
					num10 += wheelData[j].downforce;
				}
			}
			AdjustHitForces(num9, num10 / (float)num9);
			for (int k = 0; k < wheelData.Length; k++)
			{
				ServerWheelData wd = wheelData[k];
				UpdateLocalFrame(wd, dt);
				ComputeTyreForces(wd, speed, maxDriveForce, maxForwardSpeed, num2, brakeInput, num3);
				ApplyTyreForces(wd);
			}
			ComputeOverallForces();
			goto IL_05dd;
			IL_05ed:
			hadDriver = hasDriver;
			return;
			IL_05dd:
			wasSleeping = false;
			goto IL_05ed;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsGrounded()
	{
		int num = 0;
		for (int i = 0; i < wheelData.Length; i++)
		{
			if (wheelData[i].isGrounded)
			{
				num++;
			}
			if (num >= Mathf.FloorToInt((float)wheelData.Length * 0.5f))
			{
				return true;
			}
		}
		return false;
	}

	public bool IsWheelGrounded(int index)
	{
		if (index < 0 || index >= wheelData.Length)
		{
			return false;
		}
		return wheelData[index].isGrounded;
	}

	public bool HasHandbrake()
	{
		for (int i = 0; i < wheelData.Length; i++)
		{
			if (wheelData[i].wheelCollider.brakeTorque != 10000f)
			{
				return false;
			}
		}
		return true;
	}

	private void COMChanged()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			serverWheelData.forceDistance = GetWheelForceDistance(serverWheelData.wheel.wheelCollider);
		}
		prevLocalCOM = rBody.centerOfMass;
	}

	private void ComputeSteerAngle(float throttleInput, float steerInput, float dt, float speed)
	{
		if (vehicleSettings.tankSteering)
		{
			SteerAngle = 0f;
			ComputeTankSteeringThrottle(throttleInput, steerInput, speed);
			return;
		}
		float num = vehicleSettings.maxSteerAngle * steerInput;
		float num2 = Mathf.InverseLerp(0f, vehicleSettings.minSteerLimitSpeed, speed);
		if (vehicleSettings.steeringLimit)
		{
			float num3 = vehicleSettings.maxSteerAngle * car.GetSteerMaxMult(speed);
			float num4 = vehicleSettings.minSteerLimitAngle * car.GetSteerMaxMult(speed);
			float num5 = Mathf.Lerp(num3, num4, num2);
			num = Mathf.Clamp(num, 0f - num5, num5);
		}
		float num6 = 0f;
		if (vehicleSettings.steeringAssist)
		{
			float num7 = Mathf.InverseLerp(0.1f, 3f, speed);
			num6 = speedAngle * vehicleSettings.steeringAssistRatio * num7 * Mathf.InverseLerp(2f, 3f, Mathf.Abs(speedAngle));
		}
		float num8 = Mathf.Clamp(num + num6, 0f - vehicleSettings.maxSteerAngle, vehicleSettings.maxSteerAngle);
		if (SteerAngle == num8)
		{
			steerLerpSpeed = 0f;
			return;
		}
		float num9 = Mathf.Abs(SteerAngle / num8);
		float num10 = 1f - num2 * 0.7f;
		bool steerSpeedMod = car.GetSteerSpeedMod(speed);
		if ((SteerAngle == 0f || Mathf.Sign(num8) == Mathf.Sign(SteerAngle)) && Mathf.Abs(num8) > Mathf.Abs(SteerAngle))
		{
			float num11 = SteerAngle / vehicleSettings.maxSteerAngle;
			float num12 = vehicleSettings.steerMinLerpSpeed;
			if (steerSpeedMod)
			{
				num12 *= 1.8f;
			}
			float num13 = Mathf.Lerp(num12 * num10, vehicleSettings.steerMaxLerpSpeed * num10, num11 * num11);
			if (Mathf.Abs(num8) > Mathf.Abs(SteerAngle) && num9 > 0.85f)
			{
				num13 = Mathf.Lerp(num13, 0f, num9);
			}
			if (!vehicleSettings.retainLerpSpeed || num13 > steerLerpSpeed)
			{
				steerLerpSpeed = num13;
			}
		}
		else
		{
			float num14 = vehicleSettings.steerReturnLerpSpeed;
			if (num8 != 0f && Mathf.Sign(num8) != Mathf.Sign(SteerAngle))
			{
				num14 *= 1.33f;
			}
			if (steerSpeedMod)
			{
				num14 *= 1.5f;
			}
			steerLerpSpeed = num14 * num10;
		}
		if (steerSpeedMod)
		{
			steerLerpSpeed *= 1.2f;
		}
		SteerAngle = Mathf.MoveTowards(SteerAngle, num8, dt * steerLerpSpeed);
	}

	private float GetWheelForceDistance(WheelCollider col)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		return rBody.centerOfMass.y - transform.InverseTransformPoint(((Component)col).transform.position).y + col.radius + (1f - col.suspensionSpring.targetPosition) * col.suspensionDistance;
	}

	private void UpdateSuspension(ServerWheelData wd)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		wd.isGrounded = wd.wheelCollider.GetGroundHit(ref wd.hit);
		wd.origin = wd.wheelColliderTransform.TransformPoint(wd.wheelCollider.center);
		if (wd.isGrounded && GamePhysics.Trace(new Ray(wd.origin, -wd.wheelColliderTransform.up), 0f, out var hitInfo, wd.wheelCollider.suspensionDistance + wd.wheelCollider.radius, 1235321089, (QueryTriggerInteraction)1))
		{
			((WheelHit)(ref wd.hit)).point = ((RaycastHit)(ref hitInfo)).point;
			((WheelHit)(ref wd.hit)).normal = ((RaycastHit)(ref hitInfo)).normal;
		}
		if (wd.isGrounded)
		{
			if (((WheelHit)(ref wd.hit)).force < 0f)
			{
				((WheelHit)(ref wd.hit)).force = 0f;
			}
			wd.downforce = ((WheelHit)(ref wd.hit)).force;
		}
		else
		{
			wd.downforce = 0f;
		}
	}

	private void AdjustHitForces(int groundedWheels, float neutralForcePerWheel)
	{
		float num = neutralForcePerWheel * 0.25f;
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			if (!serverWheelData.isGrounded || !(serverWheelData.downforce < num))
			{
				continue;
			}
			if (groundedWheels == 1)
			{
				serverWheelData.downforce = num;
				continue;
			}
			float num2 = (num - serverWheelData.downforce) / (float)(groundedWheels - 1);
			serverWheelData.downforce = num;
			for (int j = 0; j < wheelData.Length; j++)
			{
				ServerWheelData serverWheelData2 = wheelData[j];
				if (serverWheelData2.isGrounded && serverWheelData2.downforce > num)
				{
					float num3 = Mathf.Min(num2, serverWheelData2.downforce - num);
					serverWheelData2.downforce -= num3;
				}
			}
		}
	}

	private void UpdateLocalFrame(ServerWheelData wd, float dt)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		if (!wd.isGrounded)
		{
			((WheelHit)(ref wd.hit)).point = wd.origin - wd.wheelColliderTransform.up * (wd.wheelCollider.suspensionDistance + wd.wheelCollider.radius);
			((WheelHit)(ref wd.hit)).normal = wd.wheelColliderTransform.up;
			((WheelHit)(ref wd.hit)).collider = null;
		}
		Vector3 pointVelocity = rBody.GetPointVelocity(((WheelHit)(ref wd.hit)).point);
		wd.velocity = pointVelocity - Vector3.Project(pointVelocity, ((WheelHit)(ref wd.hit)).normal);
		wd.localVelocity.y = Vector3.Dot(((WheelHit)(ref wd.hit)).forwardDir, wd.velocity);
		wd.localVelocity.x = Vector3.Dot(((WheelHit)(ref wd.hit)).sidewaysDir, wd.velocity);
		if (!wd.isGrounded)
		{
			wd.localRigForce = Vector2.zero;
			return;
		}
		float num = Mathf.InverseLerp(1f, 0.25f, ((Vector3)(ref wd.velocity)).sqrMagnitude);
		Vector2 val3 = default(Vector2);
		if (num > 0f)
		{
			float num2 = Vector3.Dot(Vector3.up, ((WheelHit)(ref wd.hit)).normal);
			Vector3 val2;
			if (num2 > 1E-06f)
			{
				Vector3 val = Vector3.up * wd.downforce / num2;
				val2 = val - Vector3.Project(val, ((WheelHit)(ref wd.hit)).normal);
			}
			else
			{
				val2 = Vector3.up * 100000f;
			}
			val3.y = Vector3.Dot(((WheelHit)(ref wd.hit)).forwardDir, val2);
			val3.x = Vector3.Dot(((WheelHit)(ref wd.hit)).sidewaysDir, val2);
			val3 *= num;
		}
		else
		{
			val3 = Vector2.zero;
		}
		Vector2 val4 = (0f - Mathf.Clamp(wd.downforce / (0f - Physics.gravity.y), 0f, wd.wheelCollider.sprungMass) * 0.5f) * wd.localVelocity / dt;
		wd.localRigForce = val4 + val3;
	}

	private void ComputeTyreForces(ServerWheelData wd, float speed, float maxDriveForce, float maxSpeed, float throttleInput, float brakeInput, float driveForceMultiplier)
	{
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		float absSpeed = Mathf.Abs(speed);
		if (vehicleSettings.tankSteering && brakeInput == 0f)
		{
			throttleInput = ((!wd.isLeftWheel) ? TankThrottleRight : TankThrottleLeft);
		}
		float num = (wd.wheel.powerWheel ? throttleInput : 0f);
		wd.hasThrottleInput = num != 0f;
		float num2 = vehicleSettings.maxDriveSlip;
		if (Mathf.Sign(num) != Mathf.Sign(wd.localVelocity.y))
		{
			num2 -= wd.localVelocity.y * Mathf.Sign(num);
		}
		float num3 = Mathf.Abs(num);
		float num4 = 0f - vehicleSettings.rollingResistance + num3 * (1f + vehicleSettings.rollingResistance) - brakeInput * (1f - vehicleSettings.rollingResistance);
		if (InSlowSpeedExitMode || num4 < 0f || maxDriveForce == 0f)
		{
			num4 *= -1f;
			wd.isBraking = true;
		}
		else
		{
			num4 *= Mathf.Sign(num);
			wd.isBraking = false;
		}
		float num6;
		if (wd.isBraking)
		{
			float num5 = Mathf.Clamp(car.GetMaxForwardSpeed() * vehicleSettings.brakeForceMultiplier, 10f * vehicleSettings.brakeForceMultiplier, 50f * vehicleSettings.brakeForceMultiplier);
			num5 += rBody.mass * 1.5f;
			num6 = num4 * num5;
		}
		else
		{
			num6 = ComputeDriveForce(speed, absSpeed, num4 * maxDriveForce, maxDriveForce, maxSpeed, driveForceMultiplier);
		}
		if (wd.isGrounded)
		{
			wd.tyreSlip.x = wd.localVelocity.x;
			wd.tyreSlip.y = wd.localVelocity.y - wd.angularVelocity * wd.wheelCollider.radius;
			float num7 = car.OnSurface switch
			{
				VehicleTerrainHandler.Surface.Road => 1f, 
				VehicleTerrainHandler.Surface.Ice => 0.25f, 
				VehicleTerrainHandler.Surface.Frictionless => 0f, 
				_ => 0.75f, 
			};
			float num8 = wd.wheel.tyreFriction * wd.downforce * num7;
			float num9 = 0f;
			if (!wd.isBraking)
			{
				num9 = Mathf.Min(Mathf.Abs(num6 * wd.tyreSlip.x) / num8, num2);
				if (num6 != 0f && num9 < 0.1f)
				{
					num9 = 0.1f;
				}
			}
			if (Mathf.Abs(wd.tyreSlip.y) < num9)
			{
				wd.tyreSlip.y = num9 * Mathf.Sign(wd.tyreSlip.y);
			}
			Vector2 val = (0f - num8) * ((Vector2)(ref wd.tyreSlip)).normalized;
			val.x = Mathf.Abs(val.x) * 1.5f;
			val.y = Mathf.Abs(val.y);
			wd.tyreForce.x = Mathf.Clamp(wd.localRigForce.x, 0f - val.x, val.x);
			if (wd.isBraking)
			{
				float num10 = Mathf.Min(val.y, num6);
				wd.tyreForce.y = Mathf.Clamp(wd.localRigForce.y, 0f - num10, num10);
			}
			else
			{
				wd.tyreForce.y = Mathf.Clamp(num6, 0f - val.y, val.y);
			}
		}
		else
		{
			wd.tyreSlip = Vector2.zero;
			wd.tyreForce = Vector2.zero;
		}
		if (wd.isGrounded)
		{
			float num11;
			if (wd.isBraking)
			{
				num11 = 0f;
			}
			else
			{
				float driveForceToMaxSlip = vehicleSettings.driveForceToMaxSlip;
				num11 = Mathf.Clamp01((Mathf.Abs(num6) - Mathf.Abs(wd.tyreForce.y)) / driveForceToMaxSlip) * num2 * Mathf.Sign(num6);
			}
			wd.angularVelocity = (wd.localVelocity.y + num11) / wd.wheelCollider.radius;
			return;
		}
		float num12 = 50f;
		float num13 = 10f;
		if (num > 0f)
		{
			wd.angularVelocity += num12 * num;
		}
		else
		{
			wd.angularVelocity -= num13;
		}
		wd.angularVelocity -= num12 * brakeInput;
		wd.angularVelocity = Mathf.Clamp(wd.angularVelocity, 0f, maxSpeed / wd.wheelCollider.radius);
	}

	private void ComputeTankSteeringThrottle(float throttleInput, float steerInput, float speed)
	{
		TankThrottleLeft = throttleInput;
		TankThrottleRight = throttleInput;
		float tankSteerInvert = GetTankSteerInvert(throttleInput, speed);
		if (throttleInput == 0f)
		{
			TankThrottleLeft = 0f - steerInput;
			TankThrottleRight = steerInput;
		}
		else if (steerInput > 0f)
		{
			TankThrottleLeft = Mathf.Lerp(throttleInput, -1f * tankSteerInvert, steerInput);
			TankThrottleRight = Mathf.Lerp(throttleInput, 1f * tankSteerInvert, steerInput);
		}
		else if (steerInput < 0f)
		{
			TankThrottleLeft = Mathf.Lerp(throttleInput, 1f * tankSteerInvert, 0f - steerInput);
			TankThrottleRight = Mathf.Lerp(throttleInput, -1f * tankSteerInvert, 0f - steerInput);
		}
	}

	private float ComputeDriveForce(float speed, float absSpeed, float demandedForce, float maxForce, float maxForwardSpeed, float driveForceMultiplier)
	{
		float num = ((speed >= 0f) ? maxForwardSpeed : (maxForwardSpeed * vehicleSettings.reversePercentSpeed));
		if (absSpeed < num)
		{
			if ((speed >= 0f || demandedForce <= 0f) && (speed <= 0f || demandedForce >= 0f))
			{
				maxForce = car.GetAdjustedDriveForce(absSpeed, maxForwardSpeed) * driveForceMultiplier;
			}
			return Mathf.Clamp(demandedForce, 0f - maxForce, maxForce);
		}
		float num2 = maxForce * Mathf.Max(1f - absSpeed / num, -1f) * Mathf.Sign(speed);
		if ((speed < 0f && demandedForce > 0f) || (speed > 0f && demandedForce < 0f))
		{
			num2 = Mathf.Clamp(num2 + demandedForce, 0f - maxForce, maxForce);
		}
		return num2;
	}

	private void ComputeOverallForces()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		DriveWheelVelocity = 0f;
		DriveWheelSlip = 0f;
		int num = 0;
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			if (serverWheelData.wheel.powerWheel)
			{
				DriveWheelVelocity += serverWheelData.angularVelocity;
				if (serverWheelData.isGrounded)
				{
					float num2 = ComputeCombinedSlip(serverWheelData.localVelocity, serverWheelData.tyreSlip);
					DriveWheelSlip += num2;
				}
				num++;
			}
		}
		if (num > 0)
		{
			DriveWheelVelocity /= num;
			DriveWheelSlip /= num;
		}
	}

	private static float ComputeCombinedSlip(Vector2 localVelocity, Vector2 tyreSlip)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float magnitude = ((Vector2)(ref localVelocity)).magnitude;
		if (magnitude > 0.01f)
		{
			float num = tyreSlip.x * localVelocity.x / magnitude;
			float y = tyreSlip.y;
			return Mathf.Sqrt(num * num + y * y);
		}
		return ((Vector2)(ref tyreSlip)).magnitude;
	}

	private void ApplyTyreForces(ServerWheelData wd)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		if (wd.isGrounded)
		{
			Vector3 val = ((WheelHit)(ref wd.hit)).forwardDir * wd.tyreForce.y;
			Vector3 val2 = ((WheelHit)(ref wd.hit)).sidewaysDir * wd.tyreForce.x;
			Vector3 sidewaysForceAppPoint = GetSidewaysForceAppPoint(wd, ((WheelHit)(ref wd.hit)).point);
			rBody.AddForceAtPosition(val, ((WheelHit)(ref wd.hit)).point, (ForceMode)0);
			rBody.AddForceAtPosition(val2, sidewaysForceAppPoint, (ForceMode)0);
		}
	}

	private Vector3 GetSidewaysForceAppPoint(ServerWheelData wd, Vector3 contactPoint)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = contactPoint + wd.wheelColliderTransform.up * vehicleSettings.antiRoll * wd.forceDistance;
		float num = (wd.wheel.steerWheel ? SteerAngle : 0f);
		if (num != 0f && Mathf.Sign(num) != Mathf.Sign(wd.tyreSlip.x))
		{
			val += wd.wheelColliderTransform.forward * midWheelPos * (vehicleSettings.handlingBias - 0.5f);
		}
		return val;
	}

	private float GetTankSteerInvert(float throttleInput, float speed)
	{
		float result = 1f;
		if (throttleInput < 0f && speed < 1.75f)
		{
			result = -1f;
		}
		else if (throttleInput == 0f && speed < -1f)
		{
			result = -1f;
		}
		else if (speed < -1f)
		{
			result = -1f;
		}
		return result;
	}
}


public interface ICar
{
	VehicleTerrainHandler.Surface OnSurface { get; }

	float GetThrottleInput();

	float GetBrakeInput();

	float GetSteerInput();

	bool GetSteerSpeedMod(float speed);

	float GetSteerMaxMult(float speed);

	float GetMaxForwardSpeed();

	float GetMaxDriveForce();

	float GetAdjustedDriveForce(float absSpeed, float topSpeed);

	float GetModifiedDrag();

	CarWheel[] GetWheels();

	float GetWheelsMidPos();
}


using UnityEngine;

private class ServerWheelData
{
	public CarWheel wheel;

	public Transform wheelColliderTransform;

	public WheelCollider wheelCollider;

	public bool isGrounded;

	public float downforce;

	public float forceDistance;

	public WheelHit hit;

	public Vector2 localRigForce;

	public Vector2 localVelocity;

	public float angularVelocity;

	public Vector3 origin;

	public Vector2 tyreForce;

	public Vector2 tyreSlip;

	public Vector3 velocity;

	public bool isBraking;

	public bool hasThrottleInput;

	public bool isFrontWheel;

	public bool isLeftWheel;
}


using UnityEngine;

public class CrushTrigger : TriggerHurt
{
	public bool includeNPCs = true;

	public bool requireCentreBelowPosition;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!includeNPCs && baseEntity.IsNpc)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	protected override bool CanHurt(BaseCombatEntity ent)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (requireCentreBelowPosition && ent.CenterPoint().y > ((Component)this).transform.position.y)
		{
			return false;
		}
		return base.CanHurt(ent);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DamageRenderer : MonoBehaviour, IClientComponent
{
	[Serializable]
	private struct DamageShowingRenderer
	{
		public Renderer renderer;

		public int[] indices;

		public DamageShowingRenderer(Renderer renderer, int[] indices)
		{
			this.renderer = renderer;
			this.indices = indices;
		}
	}

	[SerializeField]
	private List<Material> damageShowingMats;

	[SerializeField]
	private float maxDamageOpacity = 0.9f;

	[SerializeField]
	[HideInInspector]
	private List<DamageShowingRenderer> damageShowingRenderers;

	[HideInInspector]
	[SerializeField]
	private List<GlassPane> damageShowingGlassRenderers;
}


using System;
using UnityEngine;

[Serializable]
private struct DamageShowingRenderer
{
	public Renderer renderer;

	public int[] indices;

	public DamageShowingRenderer(Renderer renderer, int[] indices)
	{
		this.renderer = renderer;
		this.indices = indices;
	}
}


using UnityEngine;

public class DiverPropulsionVehicleAudio : MonoBehaviour
{
	[Header("Engine")]
	[SerializeField]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineStartFailSound;

	[SerializeField]
	private SoundDefinition engineLoopSound;

	[SerializeField]
	private AnimationCurve engineLoopPitchCurve;

	[SerializeField]
	private SoundDefinition engineActiveLoopDef;

	[SerializeField]
	[Header("Propeller")]
	private SoundDefinition propellerLoopSoundDef;

	[SerializeField]
	private AnimationCurve propellerPitchCurve;

	[SerializeField]
	private AnimationCurve propellerGainCurve;

	[Header("Water")]
	[SerializeField]
	private SoundDefinition waterMovementLoopDef;

	[SerializeField]
	private AnimationCurve waterMovementGainCurve;

	[SerializeField]
	private SoundDefinition waterSurfaceLoopDef;

	[SerializeField]
	private float surfaceWaterMovementStartDepth = 0.2f;

	[SerializeField]
	private float surfaceWaterMovementEndDepth = 2f;

	[SerializeField]
	private float waterMovementYSpeedScale = 0.2f;

	[SerializeField]
	private SoundDefinition waterEmergeSoundDef;

	[SerializeField]
	private SoundDefinition waterSubmergeSoundDef;
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public abstract class GroundVehicle : BaseVehicle, IEngineControllerUser, IEntity, TriggerHurtNotChild.IHurtTriggerUser
{
	[SerializeField]
	[Header("GroundVehicle")]
	public GroundVehicleAudio gvAudio;

	[SerializeField]
	private GameObjectRef fuelStoragePrefab;

	[SerializeField]
	public Transform waterloggedPoint;

	[SerializeField]
	public GameObjectRef collisionEffect;

	[SerializeField]
	public float engineStartupTime = 0.5f;

	[SerializeField]
	private float minCollisionDamageForce = 20000f;

	[SerializeField]
	private float maxCollisionDamageForce = 2500000f;

	[SerializeField]
	private float collisionDamageMultiplier = 1f;

	[SerializeField]
	private Rigidbody secondaryRigidbody;

	public VehicleEngineController<GroundVehicle> engineController;

	private Dictionary<BaseEntity, float> damageSinceLastTick = new Dictionary<BaseEntity, float>();

	private float nextCollisionDamageTime;

	private float dragMod;

	private float dragModDuration;

	private TimeSince timeSinceDragModSet;

	public Vector3 Velocity { get; protected set; }

	public abstract float DriveWheelVelocity { get; }

	public bool LightsAreOn => HasFlag(Flags.Reserved5);

	public VehicleEngineController<GroundVehicle>.EngineState CurEngineState => engineController.CurEngineState;

	public override void InitShared()
	{
		base.InitShared();
		CreateEngineController();
	}

	protected virtual void CreateEngineController()
	{
		engineController = new VehicleEngineController<GroundVehicle>(this, CreateFuelSystem(), base.isServer, engineStartupTime, waterloggedPoint);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			ServerFlagsChanged(old, next);
		}
	}

	public override float GetSpeed()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (IsStationary())
		{
			return 0f;
		}
		return Vector3.Dot(Velocity, ((Component)this).transform.forward);
	}

	public abstract float GetMaxForwardSpeed();

	public abstract float GetThrottleInput();

	public abstract float GetBrakeInput();

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (pusher.isMounted || pusher.IsSwimming())
		{
			return false;
		}
		return !pusher.IsStandingOnEntity(this, 8192);
	}

	protected virtual IFuelSystem CreateFuelSystem()
	{
		return new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		timeSinceDragModSet = default(TimeSince);
		timeSinceDragModSet = TimeSince.op_Implicit(float.MaxValue);
	}

	public abstract void OnEngineStartFailed();

	public abstract bool MeetsEngineRequirements();

	protected virtual void ServerFlagsChanged(Flags old, Flags next)
	{
	}

	protected void OnCollisionEnter(Collision collision)
	{
		if (base.isServer)
		{
			ProcessCollision(collision, rigidBody);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GroundVehicle.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (base.IsMovingOrOn)
			{
				Velocity = GetLocalVelocity();
			}
			else
			{
				Velocity = Vector3.zero;
			}
			if (LightsAreOn && !AnyMounted())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
			if (!(Time.time >= nextCollisionDamageTime))
			{
				return;
			}
			nextCollisionDamageTime = Time.time + 0.33f;
			foreach (KeyValuePair<BaseEntity, float> item in damageSinceLastTick)
			{
				DoCollisionDamage(item.Key, item.Value);
			}
			damageSinceLastTick.Clear();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !LightsAreOn);
		}
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return Mathf.Abs(GetSpeed()) * 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && !hurtEntity.IsDestroyed)
		{
			Vector3 val = hurtEntity.GetLocalVelocity() - Velocity;
			Vector3 val2 = ClosestPoint(((Component)hurtEntity).transform.position);
			Vector3 val3 = Mathf.Min(hurtEntity.RealisticMass, RealisticMass) * val;
			rigidBody.AddForceAtPosition(val3 * 1.25f, val2, (ForceMode)1);
			if ((Object)(object)secondaryRigidbody != (Object)null)
			{
				secondaryRigidbody.AddForceAtPosition(val3 * 1.25f, val2, (ForceMode)1);
			}
			QueueCollisionDamage(this, ((Vector3)(ref val3)).magnitude * 0.1f / Time.deltaTime);
			SetTempDrag(2.25f, 1f);
		}
	}

	private float QueueCollisionDamage(BaseEntity hitEntity, float forceMagnitude)
	{
		float num = Mathf.InverseLerp(minCollisionDamageForce, maxCollisionDamageForce, forceMagnitude);
		if (num > 0f)
		{
			float num2 = Mathf.Lerp(1f, 200f, num) * collisionDamageMultiplier;
			if (damageSinceLastTick.TryGetValue(hitEntity, out var value))
			{
				if (value < num2)
				{
					damageSinceLastTick[hitEntity] = num2;
				}
			}
			else
			{
				damageSinceLastTick[hitEntity] = num2;
			}
		}
		return num;
	}

	protected virtual void DoCollisionDamage(BaseEntity hitEntity, float damage)
	{
		Hurt(damage, DamageType.Collision, this, useProtection: false);
	}

	protected virtual void ProcessCollision(Collision collision, Rigidbody ourRigidbody)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || collision == null || (Object)(object)collision.gameObject == (Object)null || (Object)(object)collision.gameObject == (Object)null)
		{
			return;
		}
		ContactPoint contact = collision.GetContact(0);
		BaseEntity baseEntity = null;
		if ((Object)(object)((ContactPoint)(ref contact)).otherCollider.attachedRigidbody == (Object)(object)ourRigidbody)
		{
			baseEntity = ((ContactPoint)(ref contact)).otherCollider.ToBaseEntity();
		}
		else if ((Object)(object)((ContactPoint)(ref contact)).thisCollider.attachedRigidbody == (Object)(object)ourRigidbody)
		{
			baseEntity = ((ContactPoint)(ref contact)).thisCollider.ToBaseEntity();
		}
		if ((Object)(object)baseEntity != (Object)null)
		{
			Vector3 impulse = collision.impulse;
			impulse.y *= 0.5f;
			float num = ((Vector3)(ref impulse)).magnitude / Time.fixedDeltaTime;
			if (collision.gameObject.ToBaseEntity() is RidableHorse)
			{
				num *= 0.5f;
			}
			if (QueueCollisionDamage(baseEntity, num) > 0f)
			{
				TryShowCollisionFX(collision);
			}
		}
	}

	public override GameObjectRef GetCollisionFX()
	{
		return collisionEffect;
	}

	public virtual float GetModifiedDrag()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return (1f - Mathf.InverseLerp(0f, dragModDuration, TimeSince.op_Implicit(timeSinceDragModSet))) * dragMod;
	}

	public override IFuelSystem GetFuelSystem()
	{
		return engineController?.FuelSystem;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned)
		{
			GetFuelSystem()?.CheckNewChild(child);
		}
	}

	private void SetTempDrag(float drag, float duration)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		dragMod = Mathf.Clamp(drag, 0f, 1000f);
		timeSinceDragModSet = TimeSince.op_Implicit(0f);
		dragModDuration = duration;
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


using UnityEngine;

public abstract class GroundVehicleAudio : MonoBehaviour, IClientComponent
{
	[SerializeField]
	protected GroundVehicle groundVehicle;

	[SerializeField]
	[Header("Engine")]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineStartFailSound;

	[SerializeField]
	protected BlendedLoopEngineSound blendedEngineLoops;

	[SerializeField]
	private float wheelRatioMultiplier = 600f;

	[SerializeField]
	private float overallVolume = 1f;

	[Header("Water")]
	[SerializeField]
	private SoundDefinition waterSplashSoundDef;

	[SerializeField]
	private BlendedSoundLoops waterLoops;

	[SerializeField]
	private float waterSoundsMaxSpeed = 10f;

	[Header("Brakes")]
	[SerializeField]
	private SoundDefinition brakeSoundDef;

	[SerializeField]
	private SoundDefinition brakeStartSoundDef;

	[SerializeField]
	private SoundDefinition brakeStopSoundDef;

	[SerializeField]
	[Header("Lights")]
	protected SoundDefinition lightsToggleSound;
}


using UnityEngine;

public class AttackHeliDriverSeat : BaseVehicleSeat
{
	[SerializeField]
	private Sprite rocketCrosshair;

	[SerializeField]
	private Sprite incendRocketCrosshair;

	[SerializeField]
	private Sprite hvRocketCrosshair;

	[SerializeField]
	private Sprite reloadingCrosshair;

	[SerializeField]
	private GameObjectRef rocketHVItem;

	[SerializeField]
	private GameObjectRef rocketIncenItem;

	private AttackHelicopter _owner;

	private AttackHelicopter Owner
	{
		get
		{
			if ((Object)(object)_owner == (Object)null)
			{
				_owner = ((Component)this).GetComponentInParent<AttackHelicopter>();
			}
			return _owner;
		}
	}
}


using UnityEngine;

public class AttackHeliGunnerSeat : BaseVehicleSeat
{
	private AttackHelicopter _owner;

	private AttackHelicopter Owner
	{
		get
		{
			if ((Object)(object)_owner == (Object)null)
			{
				_owner = ((Component)this).GetComponentInParent<AttackHelicopter>();
			}
			return _owner;
		}
	}

	public override bool CanHoldItems()
	{
		if ((Object)(object)Owner != (Object)null)
		{
			return !Owner.GunnerIsInGunnerView;
		}
		return false;
	}

	public override Transform GetEyeOverride()
	{
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.gunnerEyePos;
		}
		return base.GetEyeOverride();
	}

	public override Vector3 EyePositionForPlayer(BasePlayer player, Quaternion lookRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetMounted() != (Object)(object)this)
		{
			return Vector3.zero;
		}
		return GetEyeOverride().position;
	}

	public override Vector3 EyeCenterForPlayer(BasePlayer player, Quaternion lookRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetMounted() != (Object)(object)this)
		{
			return Vector3.zero;
		}
		return GetEyeOverride().position;
	}

	public override Vector2 GetPitchClamp()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.turretPitchClamp;
		}
		return pitchClamp;
	}

	public override Vector2 GetYawClamp()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.turretYawClamp;
		}
		return yawClamp;
	}
}


using Oxide.Core;
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class AttackHeliPilotFlare : MonoBehaviour, SeekerTarget.ISeekerTargetOwner
{
	protected void Start()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.HIGH);
	}

	protected void OnDestroy()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
	}

	public void Init(Vector3 initialVelocity)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).GetComponent<Rigidbody>().velocity = initialVelocity;
	}

	public Vector3 CenterPoint()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public bool IsVisible(Vector3 from, float maxDistance = float.PositiveInfinity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.LineOfSight(from, CenterPoint(), 1218519041);
	}

	public bool InSafeZone()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckSphere<TriggerSafeZone>(CenterPoint(), 0.1f, 262144, (QueryTriggerInteraction)2);
	}

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public void OnEntityMessage(BaseEntity from, string msg)
	{
	}
}


using Rust.UI;
using UnityEngine;

public class AttackHeliUIDialog : UIDialog
{
	[Header("Attack Helicopter")]
	[SerializeField]
	private Material compassStripMat;

	[SerializeField]
	private Canvas mainCanvas;

	[SerializeField]
	private CanvasGroup gunCrosshair;

	[SerializeField]
	private CanvasGroup gunNoAmmoCrosshair;

	[SerializeField]
	private CanvasGroup gunCrosshairGhost;

	[SerializeField]
	private RectTransform gunCrosshairGhostRect;

	[SerializeField]
	private Canvas rocketCrosshairDefaultCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairDefaultRect;

	[SerializeField]
	private Canvas rocketCrosshairHVCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairHVRect;

	[SerializeField]
	private Canvas rocketCrosshairIncenCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairIncenRect;

	[SerializeField]
	private GameObjectRef rocketHVItem;

	[SerializeField]
	private GameObjectRef rocketIncenItem;

	[SerializeField]
	private CanvasGroup crosshairHitMarkerGroup;

	[SerializeField]
	private RectTransform zoomIndicator;

	[SerializeField]
	private RectTransform positionBox;

	[SerializeField]
	private RustText ammoTextGunMag;

	[SerializeField]
	private RustText ammoTextGunRest;

	[SerializeField]
	private RustText ammoTextRocketMag;

	[SerializeField]
	private RustText ammoTextRocketRest;

	[SerializeField]
	private RustText rangeText;

	[SerializeField]
	private float zoomIndicatorMinY;

	[SerializeField]
	private float zoomIndicatorMaxY;

	[SerializeField]
	private float positionBoxXMult;

	[SerializeField]
	private float positionBoxYMult;

	[SerializeField]
	private Animator damageWarning;
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using Rust;
using UnityEngine;

public abstract class BaseHelicopter : BaseVehicle, SeekerTarget.ISeekerTargetOwner
{
	[Serializable]
	protected class GroundEffect
	{
		public ParticleSystem effect;

		public Transform groundPoint;
	}

	public class HelicopterInputState
	{
		public float throttle;

		public float roll;

		public float yaw;

		public float pitch;

		public bool groundControl;

		public void Reset()
		{
			throttle = 0f;
			roll = 0f;
			yaw = 0f;
			pitch = 0f;
			groundControl = false;
		}
	}

	[SerializeField]
	[Header("Helicopter")]
	public float engineThrustMax;

	[SerializeField]
	public Vector3 torqueScale;

	[SerializeField]
	protected Transform com;

	[SerializeField]
	public GameObject[] killTriggers;

	[SerializeField]
	protected GroundEffect[] groundEffects;

	[SerializeField]
	public GameObjectRef serverGibs;

	[SerializeField]
	public GameObjectRef explosionEffect;

	[SerializeField]
	public GameObjectRef fireBall;

	[SerializeField]
	public GameObjectRef crashEffect;

	[SerializeField]
	[Tooltip("Lower values mean more lift is produced at high angles.")]
	[Range(0.1f, 0.95f)]
	public float liftDotMax = 0.75f;

	[Range(0.1f, 0.95f)]
	[SerializeField]
	public float altForceDotMin = 0.85f;

	[SerializeField]
	[Range(0.1f, 0.95f)]
	public float liftFraction = 0.25f;

	[SerializeField]
	public float thrustLerpSpeed = 1f;

	public const Flags Flag_InternalLights = Flags.Reserved6;

	public float currentThrottle;

	public float avgThrust;

	public float avgTerrainHeight;

	public HelicopterInputState currentInputState = new HelicopterInputState();

	public float lastPlayerInputTime;

	public float hoverForceScale = 0.99f;

	public Vector3 damageTorque;

	public float nextDamageTime;

	public float nextEffectTime;

	public float pendingImpactDamage;

	public bool autoHover { get; set; }

	public virtual bool ForceMovementHandling => false;

	public virtual float GetServiceCeiling()
	{
		return 1000f;
	}

	public virtual float GetMinimumAltitudeTerrain()
	{
		return 0f;
	}

	public override float MaxVelocity()
	{
		return 50f;
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.centerOfMass = com.localPosition;
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	internal override void DoServerDestroy()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.DoServerDestroy();
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			if (!autoHover)
			{
				PilotInput(inputState, player);
			}
		}
		else
		{
			PassengerInput(inputState, player);
		}
	}

	public bool ToggleAutoHover(BasePlayer player)
	{
		autoHover = !autoHover;
		if (autoHover && !IsEngineOn())
		{
			TryStartEngine(player);
		}
		return autoHover;
	}

	public virtual void PilotInput(InputState inputState, BasePlayer player)
	{
		currentInputState.Reset();
		currentInputState.throttle = (inputState.IsDown(BUTTON.FORWARD) ? 1f : 0f);
		currentInputState.throttle -= ((inputState.IsDown(BUTTON.BACKWARD) || inputState.IsDown(BUTTON.DUCK)) ? 1f : 0f);
		currentInputState.pitch = inputState.current.mouseDelta.y;
		currentInputState.roll = 0f - inputState.current.mouseDelta.x;
		currentInputState.yaw = (inputState.IsDown(BUTTON.RIGHT) ? 1f : 0f);
		currentInputState.yaw -= (inputState.IsDown(BUTTON.LEFT) ? 1f : 0f);
		currentInputState.pitch = MouseToBinary(currentInputState.pitch);
		currentInputState.roll = MouseToBinary(currentInputState.roll);
		lastPlayerInputTime = Time.time;
		static float MouseToBinary(float amount)
		{
			return Mathf.Clamp(amount, -1f, 1f);
		}
	}

	public virtual void PassengerInput(InputState inputState, BasePlayer player)
	{
	}

	public virtual void SetDefaultInputState()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		currentInputState.Reset();
		if (HasDriver())
		{
			float num = Vector3.Dot(Vector3.up, ((Component)this).transform.right);
			float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
			currentInputState.roll = ((num < 0f) ? 1f : 0f);
			currentInputState.roll -= ((num > 0f) ? 1f : 0f);
			if (num2 < -0f)
			{
				currentInputState.pitch = -1f;
			}
			else if (num2 > 0f)
			{
				currentInputState.pitch = 1f;
			}
		}
		else
		{
			currentInputState.throttle = -1f;
		}
	}

	public virtual bool IsEnginePowered()
	{
		return true;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseHelicopter.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (Time.time > lastPlayerInputTime + 0.5f)
			{
				SetDefaultInputState();
			}
			EnableGlobalBroadcast(IsEngineOn());
			if (IsEngineOn() || ForceMovementHandling)
			{
				MovementUpdate();
			}
			else if (!HasDriver() && TimeSince.op_Implicit(timeSinceLastPush) > 2f)
			{
				ApplyHandbrake();
			}
			SetFlag(Flags.Reserved6, TOD_Sky.Instance.IsNight);
			GameObject[] array = killTriggers;
			foreach (GameObject obj in array)
			{
				bool active = rigidBody.velocity.y < 0f;
				obj.SetActive(active);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !HasFlag(Flags.Reserved5));
		}
	}

	public virtual bool IsEngineOn()
	{
		return true;
	}

	protected virtual void TryStartEngine(BasePlayer player)
	{
	}

	protected abstract void ApplyHandbrake();

	public void ClearDamageTorque()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		SetDamageTorque(Vector3.zero);
	}

	public void SetDamageTorque(Vector3 newTorque)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		damageTorque = newTorque;
	}

	public void AddDamageTorque(Vector3 torqueToAdd)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		damageTorque += torqueToAdd;
	}

	public virtual void MovementUpdate()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		HelicopterInputState helicopterInputState = currentInputState;
		if (autoHover)
		{
			float num = 50f - ((Component)this).transform.position.y;
			helicopterInputState.throttle = Mathf.Clamp(num * 0.01f, -1f, 1f);
			helicopterInputState.pitch = 0f;
			helicopterInputState.roll = 0f;
			helicopterInputState.yaw = 0f;
		}
		if (helicopterInputState.groundControl)
		{
			currentThrottle = -0.75f;
		}
		else
		{
			currentThrottle = Mathf.Lerp(currentThrottle, helicopterInputState.throttle, 2f * Time.fixedDeltaTime);
			currentThrottle = Mathf.Clamp(currentThrottle, -0.8f, 1f);
			if (helicopterInputState.pitch != 0f || helicopterInputState.roll != 0f || helicopterInputState.yaw != 0f)
			{
				rigidBody.AddRelativeTorque(new Vector3(helicopterInputState.pitch * torqueScale.x, helicopterInputState.yaw * torqueScale.y, helicopterInputState.roll * torqueScale.z), (ForceMode)0);
			}
		}
		if (damageTorque != Vector3.zero)
		{
			rigidBody.AddRelativeTorque(new Vector3(damageTorque.x, damageTorque.y, damageTorque.z), (ForceMode)0);
		}
		avgThrust = Mathf.Lerp(avgThrust, engineThrustMax * currentThrottle, Time.fixedDeltaTime * thrustLerpSpeed);
		float num2 = Mathf.Clamp01(Vector3.Dot(((Component)this).transform.up, Vector3.up));
		float num3 = Mathf.InverseLerp(liftDotMax, 1f, num2);
		float serviceCeiling = GetServiceCeiling();
		float num4 = Mathf.Max(GetMinimumAltitudeTerrain(), TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position));
		avgTerrainHeight = Mathf.Lerp(avgTerrainHeight, num4, Time.deltaTime);
		float num5 = 1f - Mathf.InverseLerp(avgTerrainHeight + serviceCeiling - 20f, avgTerrainHeight + serviceCeiling, ((Component)this).transform.position.y);
		num3 *= num5;
		float num6 = 1f - Mathf.InverseLerp(altForceDotMin, 1f, num2);
		Vector3 val = Vector3.up * engineThrustMax * liftFraction * currentThrottle * num3;
		Vector3 val2 = ((Component)this).transform.up - Vector3.up;
		Vector3 val3 = ((Vector3)(ref val2)).normalized * engineThrustMax * currentThrottle * num6;
		float num7 = rigidBody.mass * (0f - Physics.gravity.y);
		rigidBody.AddForce(((Component)this).transform.up * num7 * num3 * hoverForceScale, (ForceMode)0);
		rigidBody.AddForce(val, (ForceMode)0);
		rigidBody.AddForce(val3, (ForceMode)0);
	}

	public void DelayedImpactDamage()
	{
		float num = explosionForceMultiplier;
		explosionForceMultiplier = 0f;
		Hurt(pendingImpactDamage * MaxHealth(), DamageType.Explosion, this, useProtection: false);
		pendingImpactDamage = 0f;
		explosionForceMultiplier = num;
	}

	public virtual bool CollisionDamageEnabled()
	{
		return true;
	}

	public void ProcessCollision(Collision collision)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || !CollisionDamageEnabled() || Time.time < nextDamageTime)
		{
			return;
		}
		Vector3 relativeVelocity = collision.relativeVelocity;
		float magnitude = ((Vector3)(ref relativeVelocity)).magnitude;
		if (Object.op_Implicit((Object)(object)collision.gameObject))
		{
			if (((1 << ((Component)collision.collider).gameObject.layer) & 0x48A18101) <= 0)
			{
				return;
			}
			BaseEntity entity = collision.GetEntity();
			if ((Object)(object)entity != (Object)null && (entity is Parachute || entity is RidableHorse || entity is MagnetCrane))
			{
				return;
			}
		}
		float num = Mathf.InverseLerp(7f, 30f, magnitude);
		if (!(num > 0f))
		{
			return;
		}
		pendingImpactDamage += Mathf.Max(num, 0.05f);
		if (Vector3.Dot(((Component)this).transform.up, Vector3.up) < 0.5f)
		{
			pendingImpactDamage *= 5f;
		}
		if (Time.time > nextEffectTime)
		{
			nextEffectTime = Time.time + 0.25f;
			if (crashEffect.isValid)
			{
				ContactPoint contact = collision.GetContact(0);
				Vector3 point = ((ContactPoint)(ref contact)).point;
				TryShowCollisionFX(point);
			}
		}
		Rigidbody obj = rigidBody;
		ContactPoint contact2 = collision.GetContact(0);
		Vector3 val = ((ContactPoint)(ref contact2)).normal * (1f + 3f * num);
		contact2 = collision.GetContact(0);
		obj.AddForceAtPosition(val, ((ContactPoint)(ref contact2)).point, (ForceMode)2);
		nextDamageTime = Time.time + 0.333f;
		((FacepunchBehaviour)this).Invoke((Action)DelayedImpactDamage, 0.015f);
	}

	public override GameObjectRef GetCollisionFX()
	{
		return crashEffect;
	}

	public void OnCollisionEnter(Collision collision)
	{
		ProcessCollision(collision);
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			base.OnDied(info);
			return;
		}
		if (explosionEffect.isValid)
		{
			Effect.server.Run(explosionEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
		}
		Vector3 val = rigidBody.velocity * 0.25f;
		List<ServerGib> list = null;
		if (serverGibs.isValid)
		{
			GameObject gibSource = serverGibs.Get().GetComponent<ServerGib>()._gibSource;
			list = ServerGib.CreateGibs(serverGibs.resourcePath, ((Component)this).gameObject, gibSource, val, 3f);
		}
		Vector3 val2 = CenterPoint();
		if (fireBall.isValid && !InSafeZone())
		{
			RaycastHit val3 = default(RaycastHit);
			for (int i = 0; i < 12; i++)
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(fireBall.resourcePath, val2, ((Component)this).transform.rotation);
				if (!Object.op_Implicit((Object)(object)baseEntity))
				{
					continue;
				}
				float num = 3f;
				float num2 = 10f;
				Vector3 onUnitSphere = Random.onUnitSphere;
				((Vector3)(ref onUnitSphere)).Normalize();
				float num3 = Random.Range(0.5f, 4f);
				bool num4 = Physics.Raycast(val2, onUnitSphere, ref val3, num3, 1218652417);
				Vector3 val4 = ((RaycastHit)(ref val3)).point;
				if (!num4)
				{
					val4 = val2 + onUnitSphere * num3;
				}
				val4 -= onUnitSphere * 0.5f;
				((Component)baseEntity).transform.position = val4;
				Collider component = ((Component)baseEntity).GetComponent<Collider>();
				baseEntity.Spawn();
				baseEntity.SetVelocity(val + onUnitSphere * Random.Range(num, num2));
				if (list == null)
				{
					continue;
				}
				foreach (ServerGib item in list)
				{
					Physics.IgnoreCollision(component, (Collider)(object)item.GetCollider(), true);
				}
			}
		}
		SeismicSensor.Notify(((Component)this).transform.position, 1);
		base.OnDied(info);
	}

	public virtual bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
protected class GroundEffect
{
	public ParticleSystem effect;

	public Transform groundPoint;
}


public class HelicopterInputState
{
	public float throttle;

	public float roll;

	public float yaw;

	public float pitch;

	public bool groundControl;

	public void Reset()
	{
		throttle = 0f;
		roll = 0f;
		yaw = 0f;
		pitch = 0f;
		groundControl = false;
	}
}


using System;
using UnityEngine;

public class CH47AIBrain : BaseAIBrain
{
	public class DropCrate : BasicAIState
	{
		private float nextDropTime;

		public DropCrate()
			: base(AIState.DropCrate)
		{
		}

		public override bool CanInterrupt()
		{
			if (base.CanInterrupt())
			{
				return !CanDrop();
			}
			return false;
		}

		public bool CanDrop()
		{
			if (Time.time > nextDropTime)
			{
				return (brain.GetBrainBaseEntity() as CH47HelicopterAIController).CanDropCrate();
			}
			return false;
		}

		public override float GetWeight()
		{
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			if (!CanDrop())
			{
				return 0f;
			}
			if (IsInState())
			{
				return 10000f;
			}
			if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Orbit && brain.CurrentState.TimeInState > 60f)
			{
				CH47DropZone closest = CH47DropZone.GetClosest(brain.mainInterestPoint);
				if (Object.op_Implicit((Object)(object)closest) && Vector3Ex.Distance2D(((Component)closest).transform.position, brain.mainInterestPoint) < 200f)
				{
					CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
					if ((Object)(object)component != (Object)null)
					{
						float num = Mathf.InverseLerp(300f, 600f, component.Age);
						return 1000f * num;
					}
				}
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.SetDropDoorOpen(open: true);
			obj.EnableFacingOverride(enabled: false);
			CH47DropZone closest = CH47DropZone.GetClosest(((Component)obj).transform.position);
			if ((Object)(object)closest == (Object)null)
			{
				nextDropTime = Time.time + 60f;
			}
			brain.mainInterestPoint = ((Component)closest).transform.position;
			obj.SetMoveTarget(brain.mainInterestPoint);
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			if (CanDrop() && Vector3Ex.Distance2D(brain.mainInterestPoint, ((Component)cH47HelicopterAIController).transform.position) < 5f)
			{
				Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
				if (((Vector3)(ref velocity)).magnitude < 5f)
				{
					cH47HelicopterAIController.DropCrate();
					nextDropTime = Time.time + 120f;
				}
			}
			return StateStatus.Running;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			(entity as CH47HelicopterAIController).SetDropDoorOpen(open: false);
			nextDropTime = Time.time + 60f;
			base.StateLeave(brain, entity);
		}
	}

	public class EgressState : BasicAIState
	{
		private bool killing;

		private bool egressAltitueAchieved;

		public EgressState()
			: base(AIState.Egress)
		{
		}

		public override bool CanInterrupt()
		{
			return false;
		}

		public override float GetWeight()
		{
			CH47HelicopterAIController cH47HelicopterAIController = brain.GetBrainBaseEntity() as CH47HelicopterAIController;
			if (cH47HelicopterAIController.OutOfCrates() && !cH47HelicopterAIController.ShouldLand())
			{
				return 10000f;
			}
			CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
			if ((Object)(object)component != (Object)null)
			{
				if (!(component.Age > 1800f))
				{
					return 0f;
				}
				return 10000f;
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			Transform transform = ((Component)obj).transform;
			Rigidbody rigidBody = obj.rigidBody;
			Vector3 velocity = rigidBody.velocity;
			Vector3 val;
			if (!(((Vector3)(ref velocity)).magnitude < 0.1f))
			{
				velocity = rigidBody.velocity;
				val = ((Vector3)(ref velocity)).normalized;
			}
			else
			{
				val = transform.forward;
			}
			Vector3 val2 = val;
			Vector3 val3 = Vector3.Cross(Vector3.Cross(transform.up, val2), Vector3.up);
			brain.mainInterestPoint = transform.position + val3 * 8000f;
			brain.mainInterestPoint.y = 100f;
			obj.SetMoveTarget(brain.mainInterestPoint);
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			if (killing)
			{
				return StateStatus.Running;
			}
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
			if (position.y < 85f && !egressAltitueAchieved)
			{
				CH47LandingZone closest = CH47LandingZone.GetClosest(position);
				if ((Object)(object)closest != (Object)null && Vector3Ex.Distance2D(((Component)closest).transform.position, position) < 20f)
				{
					float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(position, waves: false, volumes: false);
					waterOrTerrainSurface += 100f;
					Vector3 moveTarget = position;
					moveTarget.y = waterOrTerrainSurface;
					cH47HelicopterAIController.SetMoveTarget(moveTarget);
					return StateStatus.Running;
				}
			}
			egressAltitueAchieved = true;
			cH47HelicopterAIController.SetMoveTarget(brain.mainInterestPoint);
			if (base.TimeInState > 300f)
			{
				((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)cH47HelicopterAIController.DelayedKill, 2f);
				killing = true;
			}
			return StateStatus.Running;
		}
	}

	public class IdleState : BaseIdleState
	{
		public override float GetWeight()
		{
			return 0.1f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = cH47HelicopterAIController.GetPosition();
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			cH47HelicopterAIController.SetMoveTarget(position + ((Vector3)(ref velocity)).normalized * 10f);
			base.StateEnter(brain, entity);
		}
	}

	public class LandState : BasicAIState
	{
		private float landedForSeconds;

		private float lastLandtime;

		private float landingHeight = 20f;

		private float nextDismountTime;

		public LandState()
			: base(AIState.Land)
		{
		}

		public override float GetWeight()
		{
			if (!(brain.GetBrainBaseEntity() as CH47HelicopterAIController).ShouldLand())
			{
				return 0f;
			}
			float num = Time.time - lastLandtime;
			if (IsInState() && landedForSeconds < 12f)
			{
				return 1000f;
			}
			if (!IsInState() && num > 10f)
			{
				return 9000f;
			}
			return 0f;
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_0161: Unknown result type (might be due to invalid IL or missing references)
			//IL_016c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0181: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01da: Unknown result type (might be due to invalid IL or missing references)
			//IL_01df: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
			_ = ((Component)cH47HelicopterAIController).transform.forward;
			CH47LandingZone closest = CH47LandingZone.GetClosest(cH47HelicopterAIController.landingTarget);
			if (!Object.op_Implicit((Object)(object)closest))
			{
				return StateStatus.Error;
			}
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			float magnitude = ((Vector3)(ref velocity)).magnitude;
			float num = Vector3Ex.Distance2D(((Component)closest).transform.position, position);
			bool enabled = num < 40f;
			bool altitudeProtection = num > 15f && position.y < ((Component)closest).transform.position.y + 10f;
			cH47HelicopterAIController.EnableFacingOverride(enabled);
			cH47HelicopterAIController.SetAltitudeProtection(altitudeProtection);
			int num2;
			if (Mathf.Abs(((Component)closest).transform.position.y - position.y) < 3f && num <= 5f)
			{
				num2 = ((magnitude < 1f) ? 1 : 0);
				if (num2 != 0)
				{
					landedForSeconds += delta;
					if (lastLandtime == 0f)
					{
						lastLandtime = Time.time;
					}
				}
			}
			else
			{
				num2 = 0;
			}
			float num3 = 1f - Mathf.InverseLerp(0f, 7f, num);
			landingHeight -= 4f * num3 * Time.deltaTime;
			if (landingHeight < -5f)
			{
				landingHeight = -5f;
			}
			cH47HelicopterAIController.SetAimDirection(((Component)closest).transform.forward);
			Vector3 moveTarget = brain.mainInterestPoint + new Vector3(0f, landingHeight, 0f);
			if (num < 100f && num > 15f)
			{
				Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, position);
				RaycastHit val2 = default(RaycastHit);
				if (Physics.SphereCast(position, 15f, val, ref val2, num, 1218511105))
				{
					Vector3 val3 = Vector3.Cross(val, Vector3.up);
					moveTarget = ((RaycastHit)(ref val2)).point + val3 * 50f;
				}
			}
			cH47HelicopterAIController.SetMoveTarget(moveTarget);
			if (num2 != 0)
			{
				if (landedForSeconds > 1f && Time.time > nextDismountTime)
				{
					foreach (BaseVehicle.MountPointInfo mountPoint in cH47HelicopterAIController.mountPoints)
					{
						if (Object.op_Implicit((Object)(object)mountPoint.mountable) && mountPoint.mountable.AnyMounted())
						{
							nextDismountTime = Time.time + 0.5f;
							mountPoint.mountable.DismountAllPlayers();
							break;
						}
					}
				}
				if (landedForSeconds > 8f)
				{
					((Component)brain).GetComponent<CH47AIBrain>().ForceSetAge(float.PositiveInfinity);
				}
			}
			return StateStatus.Running;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			brain.mainInterestPoint = (entity as CH47HelicopterAIController).landingTarget;
			landingHeight = 15f;
			base.StateEnter(brain, entity);
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			obj.SetAltitudeProtection(on: true);
			obj.SetMinHoverHeight(30f);
			landedForSeconds = 0f;
			base.StateLeave(brain, entity);
		}

		public override bool CanInterrupt()
		{
			return true;
		}
	}

	public class OrbitState : BasicAIState
	{
		public OrbitState()
			: base(AIState.Orbit)
		{
		}

		public Vector3 GetOrbitCenter()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return brain.mainInterestPoint;
		}

		public override float GetWeight()
		{
			if (IsInState())
			{
				float num = 1f - Mathf.InverseLerp(120f, 180f, base.TimeInState);
				return 5f * num;
			}
			if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Patrol && brain.CurrentState is PatrolState patrolState && patrolState.AtPatrolDestination())
			{
				return 5f;
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: true);
			obj.InitiateAnger();
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			Vector3 orbitCenter = GetOrbitCenter();
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = cH47HelicopterAIController.GetPosition();
			Vector3 val = Vector3Ex.Direction2D(orbitCenter, position);
			Vector3 val2 = Vector3.Cross(Vector3.up, val);
			float num = ((Vector3.Dot(Vector3.Cross(((Component)cH47HelicopterAIController).transform.right, Vector3.up), val2) < 0f) ? (-1f) : 1f);
			float num2 = 75f;
			Vector3 val3 = -val + val2 * num * 0.6f;
			Vector3 normalized = ((Vector3)(ref val3)).normalized;
			Vector3 val4 = orbitCenter + normalized * num2;
			cH47HelicopterAIController.SetMoveTarget(val4);
			cH47HelicopterAIController.SetAimDirection(Vector3Ex.Direction2D(val4, position));
			base.StateThink(delta, brain, entity);
			return StateStatus.Running;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			obj.CancelAnger();
			base.StateLeave(brain, entity);
		}
	}

	public class PatrolState : BasePatrolState
	{
		protected float patrolApproachDist = 75f;

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			brain.mainInterestPoint = brain.PathFinder.GetRandomPatrolPoint();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			(entity as CH47HelicopterAIController).SetMoveTarget(brain.mainInterestPoint);
			return StateStatus.Running;
		}

		public bool AtPatrolDestination()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return Vector3Ex.Distance2D(GetDestination(), ((Component)brain).transform.position) < patrolApproachDist;
		}

		public Vector3 GetDestination()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return brain.mainInterestPoint;
		}

		public override bool CanInterrupt()
		{
			if (base.CanInterrupt())
			{
				return AtPatrolDestination();
			}
			return false;
		}

		public override float GetWeight()
		{
			if (IsInState())
			{
				if (AtPatrolDestination() && base.TimeInState > 2f)
				{
					return 0f;
				}
				return 3f;
			}
			float num = Mathf.InverseLerp(70f, 120f, TimeSinceState()) * 5f;
			return 1f + num;
		}
	}

	public override void AddStates()
	{
		base.AddStates();
		AddState(new IdleState());
		AddState(new PatrolState());
		AddState(new OrbitState());
		AddState(new EgressState());
		AddState(new DropCrate());
		AddState(new LandState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.FixedUpdate;
		base.PathFinder = new CH47PathFinder();
	}

	public void FixedUpdate()
	{
		if (!((Object)(object)base.baseEntity == (Object)null) && !base.baseEntity.isClient)
		{
			Think(Time.fixedDeltaTime);
		}
	}
}


using UnityEngine;

public class DropCrate : BasicAIState
{
	private float nextDropTime;

	public DropCrate()
		: base(AIState.DropCrate)
	{
	}

	public override bool CanInterrupt()
	{
		if (base.CanInterrupt())
		{
			return !CanDrop();
		}
		return false;
	}

	public bool CanDrop()
	{
		if (Time.time > nextDropTime)
		{
			return (brain.GetBrainBaseEntity() as CH47HelicopterAIController).CanDropCrate();
		}
		return false;
	}

	public override float GetWeight()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (!CanDrop())
		{
			return 0f;
		}
		if (IsInState())
		{
			return 10000f;
		}
		if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Orbit && brain.CurrentState.TimeInState > 60f)
		{
			CH47DropZone closest = CH47DropZone.GetClosest(brain.mainInterestPoint);
			if (Object.op_Implicit((Object)(object)closest) && Vector3Ex.Distance2D(((Component)closest).transform.position, brain.mainInterestPoint) < 200f)
			{
				CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
				if ((Object)(object)component != (Object)null)
				{
					float num = Mathf.InverseLerp(300f, 600f, component.Age);
					return 1000f * num;
				}
			}
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.SetDropDoorOpen(open: true);
		obj.EnableFacingOverride(enabled: false);
		CH47DropZone closest = CH47DropZone.GetClosest(((Component)obj).transform.position);
		if ((Object)(object)closest == (Object)null)
		{
			nextDropTime = Time.time + 60f;
		}
		brain.mainInterestPoint = ((Component)closest).transform.position;
		obj.SetMoveTarget(brain.mainInterestPoint);
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		if (CanDrop() && Vector3Ex.Distance2D(brain.mainInterestPoint, ((Component)cH47HelicopterAIController).transform.position) < 5f)
		{
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			if (((Vector3)(ref velocity)).magnitude < 5f)
			{
				cH47HelicopterAIController.DropCrate();
				nextDropTime = Time.time + 120f;
			}
		}
		return StateStatus.Running;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		(entity as CH47HelicopterAIController).SetDropDoorOpen(open: false);
		nextDropTime = Time.time + 60f;
		base.StateLeave(brain, entity);
	}
}


using System;
using UnityEngine;

public class EgressState : BasicAIState
{
	private bool killing;

	private bool egressAltitueAchieved;

	public EgressState()
		: base(AIState.Egress)
	{
	}

	public override bool CanInterrupt()
	{
		return false;
	}

	public override float GetWeight()
	{
		CH47HelicopterAIController cH47HelicopterAIController = brain.GetBrainBaseEntity() as CH47HelicopterAIController;
		if (cH47HelicopterAIController.OutOfCrates() && !cH47HelicopterAIController.ShouldLand())
		{
			return 10000f;
		}
		CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
		if ((Object)(object)component != (Object)null)
		{
			if (!(component.Age > 1800f))
			{
				return 0f;
			}
			return 10000f;
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		Transform transform = ((Component)obj).transform;
		Rigidbody rigidBody = obj.rigidBody;
		Vector3 velocity = rigidBody.velocity;
		Vector3 val;
		if (!(((Vector3)(ref velocity)).magnitude < 0.1f))
		{
			velocity = rigidBody.velocity;
			val = ((Vector3)(ref velocity)).normalized;
		}
		else
		{
			val = transform.forward;
		}
		Vector3 val2 = val;
		Vector3 val3 = Vector3.Cross(Vector3.Cross(transform.up, val2), Vector3.up);
		brain.mainInterestPoint = transform.position + val3 * 8000f;
		brain.mainInterestPoint.y = 100f;
		obj.SetMoveTarget(brain.mainInterestPoint);
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		if (killing)
		{
			return StateStatus.Running;
		}
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
		if (position.y < 85f && !egressAltitueAchieved)
		{
			CH47LandingZone closest = CH47LandingZone.GetClosest(position);
			if ((Object)(object)closest != (Object)null && Vector3Ex.Distance2D(((Component)closest).transform.position, position) < 20f)
			{
				float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(position, waves: false, volumes: false);
				waterOrTerrainSurface += 100f;
				Vector3 moveTarget = position;
				moveTarget.y = waterOrTerrainSurface;
				cH47HelicopterAIController.SetMoveTarget(moveTarget);
				return StateStatus.Running;
			}
		}
		egressAltitueAchieved = true;
		cH47HelicopterAIController.SetMoveTarget(brain.mainInterestPoint);
		if (base.TimeInState > 300f)
		{
			((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)cH47HelicopterAIController.DelayedKill, 2f);
			killing = true;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class IdleState : BaseIdleState
{
	public override float GetWeight()
	{
		return 0.1f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = cH47HelicopterAIController.GetPosition();
		Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
		cH47HelicopterAIController.SetMoveTarget(position + ((Vector3)(ref velocity)).normalized * 10f);
		base.StateEnter(brain, entity);
	}
}


using UnityEngine;

public class LandState : BasicAIState
{
	private float landedForSeconds;

	private float lastLandtime;

	private float landingHeight = 20f;

	private float nextDismountTime;

	public LandState()
		: base(AIState.Land)
	{
	}

	public override float GetWeight()
	{
		if (!(brain.GetBrainBaseEntity() as CH47HelicopterAIController).ShouldLand())
		{
			return 0f;
		}
		float num = Time.time - lastLandtime;
		if (IsInState() && landedForSeconds < 12f)
		{
			return 1000f;
		}
		if (!IsInState() && num > 10f)
		{
			return 9000f;
		}
		return 0f;
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
		_ = ((Component)cH47HelicopterAIController).transform.forward;
		CH47LandingZone closest = CH47LandingZone.GetClosest(cH47HelicopterAIController.landingTarget);
		if (!Object.op_Implicit((Object)(object)closest))
		{
			return StateStatus.Error;
		}
		Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
		float magnitude = ((Vector3)(ref velocity)).magnitude;
		float num = Vector3Ex.Distance2D(((Component)closest).transform.position, position);
		bool enabled = num < 40f;
		bool altitudeProtection = num > 15f && position.y < ((Component)closest).transform.position.y + 10f;
		cH47HelicopterAIController.EnableFacingOverride(enabled);
		cH47HelicopterAIController.SetAltitudeProtection(altitudeProtection);
		int num2;
		if (Mathf.Abs(((Component)closest).transform.position.y - position.y) < 3f && num <= 5f)
		{
			num2 = ((magnitude < 1f) ? 1 : 0);
			if (num2 != 0)
			{
				landedForSeconds += delta;
				if (lastLandtime == 0f)
				{
					lastLandtime = Time.time;
				}
			}
		}
		else
		{
			num2 = 0;
		}
		float num3 = 1f - Mathf.InverseLerp(0f, 7f, num);
		landingHeight -= 4f * num3 * Time.deltaTime;
		if (landingHeight < -5f)
		{
			landingHeight = -5f;
		}
		cH47HelicopterAIController.SetAimDirection(((Component)closest).transform.forward);
		Vector3 moveTarget = brain.mainInterestPoint + new Vector3(0f, landingHeight, 0f);
		if (num < 100f && num > 15f)
		{
			Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, position);
			RaycastHit val2 = default(RaycastHit);
			if (Physics.SphereCast(position, 15f, val, ref val2, num, 1218511105))
			{
				Vector3 val3 = Vector3.Cross(val, Vector3.up);
				moveTarget = ((RaycastHit)(ref val2)).point + val3 * 50f;
			}
		}
		cH47HelicopterAIController.SetMoveTarget(moveTarget);
		if (num2 != 0)
		{
			if (landedForSeconds > 1f && Time.time > nextDismountTime)
			{
				foreach (BaseVehicle.MountPointInfo mountPoint in cH47HelicopterAIController.mountPoints)
				{
					if (Object.op_Implicit((Object)(object)mountPoint.mountable) && mountPoint.mountable.AnyMounted())
					{
						nextDismountTime = Time.time + 0.5f;
						mountPoint.mountable.DismountAllPlayers();
						break;
					}
				}
			}
			if (landedForSeconds > 8f)
			{
				((Component)brain).GetComponent<CH47AIBrain>().ForceSetAge(float.PositiveInfinity);
			}
		}
		return StateStatus.Running;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		brain.mainInterestPoint = (entity as CH47HelicopterAIController).landingTarget;
		landingHeight = 15f;
		base.StateEnter(brain, entity);
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		obj.SetAltitudeProtection(on: true);
		obj.SetMinHoverHeight(30f);
		landedForSeconds = 0f;
		base.StateLeave(brain, entity);
	}

	public override bool CanInterrupt()
	{
		return true;
	}
}


using UnityEngine;

public class OrbitState : BasicAIState
{
	public OrbitState()
		: base(AIState.Orbit)
	{
	}

	public Vector3 GetOrbitCenter()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return brain.mainInterestPoint;
	}

	public override float GetWeight()
	{
		if (IsInState())
		{
			float num = 1f - Mathf.InverseLerp(120f, 180f, base.TimeInState);
			return 5f * num;
		}
		if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Patrol && brain.CurrentState is PatrolState patrolState && patrolState.AtPatrolDestination())
		{
			return 5f;
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: true);
		obj.InitiateAnger();
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 orbitCenter = GetOrbitCenter();
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = cH47HelicopterAIController.GetPosition();
		Vector3 val = Vector3Ex.Direction2D(orbitCenter, position);
		Vector3 val2 = Vector3.Cross(Vector3.up, val);
		float num = ((Vector3.Dot(Vector3.Cross(((Component)cH47HelicopterAIController).transform.right, Vector3.up), val2) < 0f) ? (-1f) : 1f);
		float num2 = 75f;
		Vector3 val3 = -val + val2 * num * 0.6f;
		Vector3 normalized = ((Vector3)(ref val3)).normalized;
		Vector3 val4 = orbitCenter + normalized * num2;
		cH47HelicopterAIController.SetMoveTarget(val4);
		cH47HelicopterAIController.SetAimDirection(Vector3Ex.Direction2D(val4, position));
		base.StateThink(delta, brain, entity);
		return StateStatus.Running;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		obj.CancelAnger();
		base.StateLeave(brain, entity);
	}
}


using UnityEngine;

public class PatrolState : BasePatrolState
{
	protected float patrolApproachDist = 75f;

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		brain.mainInterestPoint = brain.PathFinder.GetRandomPatrolPoint();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		(entity as CH47HelicopterAIController).SetMoveTarget(brain.mainInterestPoint);
		return StateStatus.Running;
	}

	public bool AtPatrolDestination()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(GetDestination(), ((Component)brain).transform.position) < patrolApproachDist;
	}

	public Vector3 GetDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return brain.mainInterestPoint;
	}

	public override bool CanInterrupt()
	{
		if (base.CanInterrupt())
		{
			return AtPatrolDestination();
		}
		return false;
	}

	public override float GetWeight()
	{
		if (IsInState())
		{
			if (AtPatrolDestination() && base.TimeInState > 2f)
			{
				return 0f;
			}
			return 3f;
		}
		float num = Mathf.InverseLerp(70f, 120f, TimeSinceState()) * 5f;
		return 1f + num;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class CH47DropZone : MonoBehaviour
{
	public float lastDropTime;

	public static List<CH47DropZone> dropZones = new List<CH47DropZone>();

	public void Awake()
	{
		if (!dropZones.Contains(this))
		{
			dropZones.Add(this);
		}
	}

	public static CH47DropZone GetClosest(Vector3 pos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		CH47DropZone result = null;
		foreach (CH47DropZone dropZone in dropZones)
		{
			float num2 = Vector3Ex.Distance2D(pos, ((Component)dropZone).transform.position);
			if (num2 < num)
			{
				num = num2;
				result = dropZone;
			}
		}
		return result;
	}

	public void OnDestroy()
	{
		if (dropZones.Contains(this))
		{
			dropZones.Remove(this);
		}
	}

	public float TimeSinceLastDrop()
	{
		return Time.time - lastDropTime;
	}

	public void Used()
	{
		lastDropTime = Time.time;
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.yellow;
		Gizmos.DrawSphere(((Component)this).transform.position, 5f);
	}
}


using Oxide.Core;
using UnityEngine;

public class CH47Helicopter : BaseHelicopter
{
	public GameObjectRef mapMarkerEntityPrefab;

	[Header("Sounds")]
	public SoundDefinition flightEngineSoundDef;

	public SoundDefinition flightThwopsSoundDef;

	public float rotorGainModSmoothing = 0.25f;

	public float engineGainMin = 0.5f;

	public float engineGainMax = 1f;

	public float thwopGainMin = 0.5f;

	public float thwopGainMax = 1f;

	public BaseEntity mapMarkerInstance;

	public override void ServerInit()
	{
		rigidBody.isKinematic = false;
		base.ServerInit();
		CreateMapMarker();
	}

	public void CreateMapMarker()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)mapMarkerInstance))
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		mapMarkerInstance = baseEntity;
	}

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

	protected override void ApplyHandbrake()
	{
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		return false;
	}
}


using System;
using Oxide.Core;
using Rust;
using UnityEngine;

public class CH47HelicopterAIController : CH47Helicopter
{
	public GameObjectRef scientistPrefab;

	public GameObjectRef dismountablePrefab;

	public GameObjectRef weakDismountablePrefab;

	public float maxTiltAngle = 0.3f;

	public float AiAltitudeForce = 10000f;

	public GameObjectRef lockedCratePrefab;

	public const Flags Flag_Damaged = Flags.Reserved9;

	public const Flags Flag_NearDeath = Flags.OnFire;

	public const Flags Flag_DropDoorOpen = Flags.Reserved8;

	public GameObject triggerHurt;

	public Vector3 landingTarget;

	public int numCrates = 1;

	private bool shouldLand;

	public bool aimDirOverride;

	public Vector3 _aimDirection = Vector3.forward;

	public Vector3 _moveTarget = Vector3.zero;

	public int lastAltitudeCheckFrame;

	public float altOverride;

	public float currentDesiredAltitude;

	private bool altitudeProtection = true;

	public float hoverHeight = 30f;

	public void DropCrate()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (numCrates > 0)
		{
			Vector3 pos = ((Component)this).transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				Interface.CallHook("OnHelicopterDropCrate", (object)this);
				((Component)baseEntity).SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

	public bool IsDropDoorOpen()
	{
		return HasFlag(Flags.Reserved8);
	}

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", (object)this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

	public bool ShouldLand()
	{
		return shouldLand;
	}

	public void SetLandingTarget(Vector3 target)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		shouldLand = true;
		landingTarget = target;
		numCrates = 0;
	}

	public void ClearLandingTarget()
	{
		shouldLand = false;
	}

	public void TriggeredEventSpawn()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float y = 30f;
		Vector3 val = Vector3Ex.Range(-1f, 1f);
		val.y = 0f;
		((Vector3)(ref val)).Normalize();
		val *= x * 1f;
		val.y = y;
		((Component)this).transform.position = val;
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (Interface.CallHook("CanUseHelicopter", (object)player, (object)this) == null)
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	public override void ServerInit()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)CheckSpawnScientists, 0.25f);
		SetMoveTarget(((Component)this).transform.position);
	}

	public void SpawnPassenger(Vector3 spawnPos, string prefabPath)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		HumanNPC component = ((Component)GameManager.server.CreateEntity(prefabPath, spawnPos, identity)).GetComponent<HumanNPC>();
		component.Spawn();
		AttemptMount(component);
		OnSpawnedHuman(component);
	}

	public void SpawnPassenger(Vector3 spawnPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		HumanNPC component = ((Component)GameManager.server.CreateEntity(dismountablePrefab.resourcePath, spawnPos, identity)).GetComponent<HumanNPC>();
		component.Spawn();
		AttemptMount(component);
		OnSpawnedHuman(component);
	}

	public void SpawnScientist(Vector3 spawnPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		HumanNPC component = ((Component)GameManager.server.CreateEntity(scientistPrefab.resourcePath, spawnPos, identity)).GetComponent<HumanNPC>();
		component.Spawn();
		AttemptMount(component);
		component.Brain.SetEnabled(flag: false);
		OnSpawnedHuman(component);
	}

	private void OnSpawnedHuman(HumanNPC human)
	{
		if (!((Object)(object)human == (Object)null) && (Object)(object)human.Brain != (Object)null && human.Brain.Senses != null)
		{
			human.Brain.Senses.ignoreTutorialPlayers = true;
		}
	}

	public void CheckSpawnScientists()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (ValidBounds.Test(this, ((Component)this).transform.position))
		{
			((FacepunchBehaviour)this).Invoke((Action)SpawnScientists, 2f);
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)CheckSpawnScientists, 2f);
		}
	}

	public void SpawnScientists()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		if (shouldLand)
		{
			float dropoffScale = CH47LandingZone.GetClosest(landingTarget).dropoffScale;
			int num = Mathf.FloorToInt((float)(mountPoints.Count - 2) * dropoffScale);
			for (int i = 0; i < num; i++)
			{
				Vector3 spawnPos = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
				SpawnPassenger(spawnPos, dismountablePrefab.resourcePath);
			}
			for (int j = 0; j < 1; j++)
			{
				Vector3 spawnPos2 = ((Component)this).transform.position - ((Component)this).transform.forward * 15f;
				SpawnPassenger(spawnPos2);
			}
		}
		else
		{
			for (int k = 0; k < 4; k++)
			{
				Vector3 spawnPos3 = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
				SpawnScientist(spawnPos3);
			}
			for (int l = 0; l < 1; l++)
			{
				Vector3 spawnPos4 = ((Component)this).transform.position - ((Component)this).transform.forward * 15f;
				SpawnScientist(spawnPos4);
			}
		}
	}

	public void EnableFacingOverride(bool enabled)
	{
		aimDirOverride = enabled;
	}

	public void SetMoveTarget(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_moveTarget = position;
	}

	public Vector3 GetMoveTarget()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _moveTarget;
	}

	public void SetAimDirection(Vector3 dir)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_aimDirection = dir;
	}

	public Vector3 GetAimDirectionOverride()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _aimDirection;
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
		InitiateAnger();
	}

	public void CancelAnger()
	{
		if (base.SecondsSinceAttacked > 120f)
		{
			UnHostile();
			((FacepunchBehaviour)this).CancelInvoke((Action)UnHostile);
		}
	}

	public void InitiateAnger()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)UnHostile);
		((FacepunchBehaviour)this).Invoke((Action)UnHostile, 120f);
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (!((Object)(object)mountPoint.mountable != (Object)null))
			{
				continue;
			}
			BasePlayer mounted = mountPoint.mountable.GetMounted();
			if (Object.op_Implicit((Object)(object)mounted))
			{
				ScientistNPC scientistNPC = mounted as ScientistNPC;
				if ((Object)(object)scientistNPC != (Object)null)
				{
					scientistNPC.Brain.SetEnabled(flag: true);
				}
			}
		}
	}

	public void UnHostile()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (!((Object)(object)mountPoint.mountable != (Object)null))
			{
				continue;
			}
			BasePlayer mounted = mountPoint.mountable.GetMounted();
			if (Object.op_Implicit((Object)(object)mounted))
			{
				ScientistNPC scientistNPC = mounted as ScientistNPC;
				if ((Object)(object)scientistNPC != (Object)null)
				{
					scientistNPC.Brain.SetEnabled(flag: false);
				}
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		if (Interface.CallHook("OnEntityDestroy", (object)this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnDied(info);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttack", (object)this, (object)info) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved9, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

	public void DelayedKill()
	{
		DismountAllPlayers();
		Kill();
	}

	public override void DismountAllPlayers()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if ((Object)(object)mountPoint.mountable != (Object)null)
			{
				BasePlayer mounted = mountPoint.mountable.GetMounted();
				if (Object.op_Implicit((Object)(object)mounted) && mounted.IsAlive())
				{
					mounted.Hurt(10000f, DamageType.Explosion, this, useProtection: false);
				}
			}
		}
	}

	public override void AdminKill()
	{
		DismountAllPlayers();
		base.AdminKill();
	}

	public void SetAltitudeProtection(bool on)
	{
		altitudeProtection = on;
	}

	public void CalculateDesiredAltitude()
	{
		CalculateOverrideAltitude();
		if (altOverride > currentDesiredAltitude)
		{
			currentDesiredAltitude = altOverride;
		}
		else
		{
			currentDesiredAltitude = Mathf.MoveTowards(currentDesiredAltitude, altOverride, Time.fixedDeltaTime * 5f);
		}
	}

	public void SetMinHoverHeight(float newHeight)
	{
		hoverHeight = newHeight;
	}

	public float CalculateOverrideAltitude()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		if (Time.frameCount == lastAltitudeCheckFrame)
		{
			return altOverride;
		}
		lastAltitudeCheckFrame = Time.frameCount;
		float y = GetMoveTarget().y;
		float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(GetMoveTarget(), waves: false, volumes: false);
		float num = Mathf.Max(y, waterOrTerrainSurface + hoverHeight);
		if (altitudeProtection)
		{
			Vector3 val = rigidBody.velocity;
			Vector3 val2;
			if (!(((Vector3)(ref val)).magnitude < 0.1f))
			{
				val = rigidBody.velocity;
				val2 = ((Vector3)(ref val)).normalized;
			}
			else
			{
				val2 = ((Component)this).transform.forward;
			}
			Vector3 val3 = val2;
			val = Vector3.Cross(Vector3.Cross(((Component)this).transform.up, val3), Vector3.up) + Vector3.down * 0.3f;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			RaycastHit val4 = default(RaycastHit);
			RaycastHit val5 = default(RaycastHit);
			if (Physics.SphereCast(((Component)this).transform.position - normalized * 20f, 20f, normalized, ref val4, 75f, 1218511105) && Physics.SphereCast(((RaycastHit)(ref val4)).point + Vector3.up * 200f, 20f, Vector3.down, ref val5, 200f, 1218511105))
			{
				num = ((RaycastHit)(ref val5)).point.y + hoverHeight;
			}
		}
		altOverride = num;
		return altOverride;
	}

	public override void SetDefaultInputState()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		currentInputState.Reset();
		Vector3 moveTarget = GetMoveTarget();
		Vector3 val = Vector3.Cross(((Component)this).transform.right, Vector3.up);
		Vector3 val2 = Vector3.Cross(Vector3.up, val);
		float num = 0f - Vector3.Dot(Vector3.up, ((Component)this).transform.right);
		float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
		float num3 = Vector3Ex.Distance2D(((Component)this).transform.position, moveTarget);
		float y = ((Component)this).transform.position.y;
		float num4 = currentDesiredAltitude;
		Vector3 val3 = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
		val3.y = num4;
		Vector3 val4 = Vector3Ex.Direction2D(moveTarget, ((Component)this).transform.position);
		float num5 = 0f - Vector3.Dot(val4, val2);
		float num6 = Vector3.Dot(val4, val);
		float num7 = Mathf.InverseLerp(0f, 25f, num3);
		if (num6 > 0f)
		{
			float num8 = Mathf.InverseLerp(0f - maxTiltAngle, 0f, num2);
			currentInputState.pitch = 1f * num6 * num8 * num7;
		}
		else
		{
			float num9 = 1f - Mathf.InverseLerp(0f, maxTiltAngle, num2);
			currentInputState.pitch = 1f * num6 * num9 * num7;
		}
		if (num5 > 0f)
		{
			float num10 = Mathf.InverseLerp(0f - maxTiltAngle, 0f, num);
			currentInputState.roll = 1f * num5 * num10 * num7;
		}
		else
		{
			float num11 = 1f - Mathf.InverseLerp(0f, maxTiltAngle, num);
			currentInputState.roll = 1f * num5 * num11 * num7;
		}
		float num12 = Mathf.Abs(num4 - y);
		float num13 = 1f - Mathf.InverseLerp(10f, 30f, num12);
		currentInputState.pitch *= num13;
		currentInputState.roll *= num13;
		float num14 = maxTiltAngle;
		float num15 = Mathf.InverseLerp(0f + Mathf.Abs(currentInputState.pitch) * num14, num14 + Mathf.Abs(currentInputState.pitch) * num14, Mathf.Abs(num2));
		currentInputState.pitch += num15 * ((num2 < 0f) ? (-1f) : 1f);
		float num16 = Mathf.InverseLerp(0f + Mathf.Abs(currentInputState.roll) * num14, num14 + Mathf.Abs(currentInputState.roll) * num14, Mathf.Abs(num));
		currentInputState.roll += num16 * ((num < 0f) ? (-1f) : 1f);
		if (aimDirOverride || num3 > 30f)
		{
			Vector3 val5 = (aimDirOverride ? GetAimDirectionOverride() : Vector3Ex.Direction2D(GetMoveTarget(), ((Component)this).transform.position));
			Vector3 val6 = (aimDirOverride ? GetAimDirectionOverride() : Vector3Ex.Direction2D(GetMoveTarget(), ((Component)this).transform.position));
			float num17 = Vector3.Dot(val2, val5);
			float num18 = Vector3.Angle(val, val6);
			float num19 = Mathf.InverseLerp(0f, 70f, Mathf.Abs(num18));
			currentInputState.yaw = ((num17 > 0f) ? 1f : 0f);
			currentInputState.yaw -= ((num17 < 0f) ? 1f : 0f);
			currentInputState.yaw *= num19;
		}
		float throttle = Mathf.InverseLerp(5f, 30f, num3);
		currentInputState.throttle = throttle;
	}

	public void MaintainAIAltutide()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + rigidBody.velocity;
		float num = currentDesiredAltitude;
		float y = val.y;
		float num2 = Mathf.Abs(num - y);
		bool flag = num > y;
		float num3 = Mathf.InverseLerp(0f, 10f, num2) * AiAltitudeForce * (flag ? 1f : (-1f));
		rigidBody.AddForce(Vector3.up * num3, (ForceMode)0);
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("CH47HeliAI.VehicleFixedUpdate", 0);
		try
		{
			hoverForceScale = 1f;
			base.VehicleFixedUpdate();
			SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
			CalculateDesiredAltitude();
			MaintainAIAltutide();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			foreach (MountPointInfo mountPoint in mountPoints)
			{
				if ((Object)(object)mountPoint.mountable != (Object)null)
				{
					BasePlayer mounted = mountPoint.mountable.GetMounted();
					if (Object.op_Implicit((Object)(object)mounted) && (Object)(object)((Component)mounted).transform != (Object)null && !mounted.IsDestroyed && !mounted.IsDead() && mounted.IsNpc)
					{
						mounted.Kill();
					}
				}
			}
		}
		base.DestroyShared();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class CH47LandingZone : MonoBehaviour
{
	public float lastDropTime;

	public static List<CH47LandingZone> landingZones = new List<CH47LandingZone>();

	public float dropoffScale = 1f;

	public static bool HasAnyLandingZones => !landingZones.IsNullOrEmpty();

	public void Awake()
	{
		if (!landingZones.Contains(this))
		{
			landingZones.Add(this);
		}
	}

	public static CH47LandingZone GetClosest(Vector3 pos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		CH47LandingZone result = null;
		foreach (CH47LandingZone landingZone in landingZones)
		{
			float num2 = Vector3Ex.Distance2D(pos, ((Component)landingZone).transform.position);
			if (num2 < num)
			{
				num = num2;
				result = landingZone;
			}
		}
		return result;
	}

	public void OnDestroy()
	{
		if (landingZones.Contains(this))
		{
			landingZones.Remove(this);
		}
	}

	public float TimeSinceLastDrop()
	{
		return Time.time - lastDropTime;
	}

	public void Used()
	{
		lastDropTime = Time.time;
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		Color magenta = Color.magenta;
		magenta.a = 0.25f;
		Gizmos.color = magenta;
		GizmosUtil.DrawCircleY(((Component)this).transform.position, 6f);
		magenta.a = 1f;
		Gizmos.color = magenta;
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, 6f);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class CH47PathFinder : BasePathFinder
{
	public List<Vector3> visitedPatrolPoints = new List<Vector3>();

	public override Vector3 GetRandomPatrolPoint()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		MonumentInfo monumentInfo = null;
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
		{
			int count = TerrainMeta.Path.Monuments.Count;
			int num = Random.Range(0, count);
			for (int i = 0; i < count; i++)
			{
				int num2 = i + num;
				if (num2 >= count)
				{
					num2 -= count;
				}
				MonumentInfo monumentInfo2 = TerrainMeta.Path.Monuments[num2];
				if (monumentInfo2.Type == MonumentType.Cave || monumentInfo2.Type == MonumentType.WaterWell || monumentInfo2.Tier == MonumentTier.Tier0 || monumentInfo2.IsSafeZone || (monumentInfo2.Tier & MonumentTier.Tier0) > (MonumentTier)0)
				{
					continue;
				}
				bool flag = false;
				foreach (Vector3 visitedPatrolPoint in visitedPatrolPoints)
				{
					if (Vector3Ex.Distance2D(((Component)monumentInfo2).transform.position, visitedPatrolPoint) < 100f)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					monumentInfo = monumentInfo2;
					break;
				}
			}
			if ((Object)(object)monumentInfo == (Object)null)
			{
				visitedPatrolPoints.Clear();
				monumentInfo = GetRandomValidMonumentInfo();
			}
		}
		if ((Object)(object)monumentInfo != (Object)null)
		{
			visitedPatrolPoints.Add(((Component)monumentInfo).transform.position);
			val = ((Component)monumentInfo).transform.position;
		}
		else
		{
			float x = TerrainMeta.Size.x;
			float y = 30f;
			val = Vector3Ex.Range(-1f, 1f);
			val.y = 0f;
			((Vector3)(ref val)).Normalize();
			val *= x * Random.Range(0f, 0.75f);
			val.y = y;
		}
		float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
		float num3 = waterOrTerrainSurface;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.SphereCast(val + new Vector3(0f, 200f, 0f), 20f, Vector3.down, ref val2, 300f, 1218511105))
		{
			num3 = Mathf.Max(((RaycastHit)(ref val2)).point.y, waterOrTerrainSurface);
		}
		val.y = num3 + 30f;
		return val;
	}

	private MonumentInfo GetRandomValidMonumentInfo()
	{
		int count = TerrainMeta.Path.Monuments.Count;
		int num = Random.Range(0, count);
		for (int i = 0; i < count; i++)
		{
			int num2 = i + num;
			if (num2 >= count)
			{
				num2 -= count;
			}
			MonumentInfo monumentInfo = TerrainMeta.Path.Monuments[num2];
			if (monumentInfo.Type != 0 && monumentInfo.Type != MonumentType.WaterWell && monumentInfo.Tier != MonumentTier.Tier0 && !monumentInfo.IsSafeZone)
			{
				return monumentInfo;
			}
		}
		return null;
	}
}


using UnityEngine;

public class CH47ReinforcementListener : BaseEntity
{
	public string listenString;

	public GameObjectRef heliPrefab;

	public float startDist = 300f;

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == listenString)
		{
			Call();
		}
	}

	public void Call()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		TryCall(heliPrefab.resourcePath, ((Component)this).transform.position, startDist);
	}

	public static bool TryCall(string resourcePath, Vector3 ourPos, float startDist)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController component = ((Component)GameManager.server.CreateEntity(resourcePath)).GetComponent<CH47HelicopterAIController>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			return false;
		}
		_ = TerrainMeta.Size;
		CH47LandingZone closest = CH47LandingZone.GetClosest(ourPos);
		if ((Object)(object)closest == (Object)null)
		{
			return false;
		}
		Vector3 zero = Vector3.zero;
		zero.y = ((Component)closest).transform.position.y;
		Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, zero);
		Vector3 position = ((Component)closest).transform.position + val * startDist;
		position.y = ((Component)closest).transform.position.y;
		((Component)component).transform.position = position;
		component.SetLandingTarget(((Component)closest).transform.position);
		component.Spawn();
		return true;
	}
}


using UnityEngine;

public class Minicopter : PlayerHelicopter
{
	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population;

	[SerializeField]
	private ParticleSystemContainer fxMediumDamage;

	[SerializeField]
	private ParticleSystemContainer fxHeavyDamage;

	[SerializeField]
	private SoundDefinition damagedMediumLoop;

	[SerializeField]
	private SoundDefinition damagedHeavyLoop;

	[SerializeField]
	private GameObject damageSoundTarget;
}


using UnityEngine;

public class MiniCopterAnimation : MonoBehaviour
{
	public void UpdateRotorSpeed(float newSpeed)
	{
	}

	private void Update()
	{
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

public class PlayerHeliSounds : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class FlightSoundLayer
	{
		public SoundDefinition loopDefinition;

		public SoundDefinition startDefinition;

		public SoundDefinition stopDefinition;

		public Transform targetParent;

		public float fadeTime = 0.25f;

		public float initialGain = 1f;

		public float gainRateUp = 5f;

		public float gainRateDown = 5f;

		public float gainInterpRate = 0.5f;

		public float initialPitch = 1f;

		public float pitchRateUp = 5f;

		public float pitchRateDown = 5f;

		public float pitchInterpRate = 0.5f;

		public bool returnToInitialWhenTurnedOff;

		public bool useUpDotPitchCurve;

		public AnimationCurve upDotPitchCurve;
	}

	[FormerlySerializedAs("miniCopter")]
	public PlayerHelicopter miniCopter;

	public GameObject soundAttachPoint;

	public List<FlightSoundLayer> flightSoundLayers = new List<FlightSoundLayer>();

	public SoundDefinition engineStartDef;

	public SoundDefinition engineLoopDef;

	public SoundDefinition engineStopDef;

	public SoundDefinition rotorLoopDef;

	public SoundDefinition radarWarningDef;

	public SoundDefinition radarLockDef;

	public SoundDefinition noAmmoDef;

	public SoundDefinition noFlaresDef;

	public SoundDefinition flaresReadyDef;

	public SoundDefinition flightControlMovementSoundDef;

	public GameObject flightControlSoundPosition;

	public float engineStartFadeOutTime = 1f;

	public float engineLoopFadeInTime = 0.7f;

	public float engineLoopFadeOutTime = 0.25f;

	public float engineStopFadeOutTime = 0.25f;

	public float rotorLoopFadeInTime = 0.7f;

	public float rotorLoopFadeOutTime = 0.25f;

	public float enginePitchInterpRate = 0.5f;

	public float rotorPitchInterpRate = 1f;

	public float rotorGainInterpRate = 0.5f;

	public float rotorStartStopPitchRateUp = 7f;

	public float rotorStartStopPitchRateDown = 9f;

	public float rotorStartStopGainRateUp = 5f;

	public float rotorStartStopGainRateDown = 4f;

	public AnimationCurve engineUpDotPitchCurve;

	public AnimationCurve rotorUpDotPitchCurve;

	public Animator animator;

	public SoundDefinition reloadStartSoundDef;

	public SoundDefinition reloadLoopSoundDef;

	public SoundDefinition reloadFinishSoundDef;
}


using System;
using UnityEngine;

[Serializable]
public class FlightSoundLayer
{
	public SoundDefinition loopDefinition;

	public SoundDefinition startDefinition;

	public SoundDefinition stopDefinition;

	public Transform targetParent;

	public float fadeTime = 0.25f;

	public float initialGain = 1f;

	public float gainRateUp = 5f;

	public float gainRateDown = 5f;

	public float gainInterpRate = 0.5f;

	public float initialPitch = 1f;

	public float pitchRateUp = 5f;

	public float pitchRateDown = 5f;

	public float pitchInterpRate = 0.5f;

	public bool returnToInitialWhenTurnedOff;

	public bool useUpDotPitchCurve;

	public AnimationCurve upDotPitchCurve;
}


using System;
using Rust;
using UnityEngine;

public class ScrapTransportHelicopter : PlayerHelicopter, TriggerHurtNotChild.IHurtTriggerUser
{
	[SerializeField]
	private Transform searchlightEye;

	[SerializeField]
	private BoxCollider parentTriggerCollider;

	[SerializeField]
	[Header("Damage Effects")]
	private ParticleSystemContainer tailDamageLight;

	[SerializeField]
	private ParticleSystemContainer tailDamageHeavy;

	[SerializeField]
	private ParticleSystemContainer mainEngineDamageLight;

	[SerializeField]
	private ParticleSystemContainer mainEngineDamageHeavy;

	[SerializeField]
	private ParticleSystemContainer cockpitSparks;

	[SerializeField]
	private Transform tailDamageLightEffects;

	[SerializeField]
	private Transform mainEngineDamageLightEffects;

	[SerializeField]
	private SoundDefinition damagedFireSoundDef;

	[SerializeField]
	private SoundDefinition damagedFireTailSoundDef;

	[SerializeField]
	private SoundDefinition damagedSparksSoundDef;

	[SerializeField]
	private float pilotRotorScale = 1.5f;

	[SerializeField]
	private float compassOffset;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population;

	public const string PASSENGER_ACHIEVEMENT = "RUST_AIR";

	public const int PASSENGER_ACHIEVEMENT_REQ_COUNT = 5;

	public override void ServerInit()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.inertiaTensor = new Vector3(19082f, 14356f, 7940f);
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (base.isServer)
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedNetworking, 0.15f);
		}
	}

	public void DelayedNetworking()
	{
		SendNetworkUpdate();
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!GameInfo.HasAchievements || !base.isServer || old.HasFlag(Flags.On) || !next.HasFlag(Flags.On) || !((Object)(object)GetDriver() != (Object)null))
		{
			return;
		}
		int num = 0;
		foreach (BaseEntity child in children)
		{
			if ((Object)(object)child.ToPlayer() != (Object)null)
			{
				num++;
			}
			if (child is BaseVehicleSeat baseVehicleSeat && (Object)(object)baseVehicleSeat.GetMounted() != (Object)null && (Object)(object)baseVehicleSeat.GetMounted() != (Object)(object)GetDriver())
			{
				num++;
			}
		}
		if (num >= 5)
		{
			GetDriver().GiveAchievement("RUST_AIR");
		}
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		return false;
	}
}


using UnityEngine;

public class ScrapTransportHelicopterWheelEffects : MonoBehaviour, IServerComponent
{
	public WheelCollider wheelCollider;

	public GameObjectRef impactEffect;

	public float minTimeBetweenEffects = 0.25f;

	public float minDistBetweenEffects = 0.1f;

	private bool wasGrounded;

	private float lastEffectPlayed;

	private Vector3 lastCollisionPos;

	public void Update()
	{
		bool isGrounded = wheelCollider.isGrounded;
		if (isGrounded && !wasGrounded)
		{
			DoImpactEffect();
		}
		wasGrounded = isGrounded;
	}

	private void DoImpactEffect()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (impactEffect.isValid && !(Time.time < lastEffectPlayed + minTimeBetweenEffects) && (!(Vector3.Distance(((Component)this).transform.position, lastCollisionPos) < minDistBetweenEffects) || lastEffectPlayed == 0f))
		{
			Effect.server.Run(impactEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up);
			lastEffectPlayed = Time.time;
			lastCollisionPos = ((Component)this).transform.position;
		}
	}
}


using UnityEngine;

public class AnimalRagdoll : Ragdoll
{
	public SkinnedMeshRenderer[] bodyRenderers;

	public SkinnedMeshRenderer[] hairRenderers;
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class BaseAnimalRagdoll : BaseCombatEntity
{
	[SerializeField]
	private Ragdoll Ragdoll;

	private EntityRef<BaseCombatEntity> linkedEntity;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		if (linkedEntity.IsValid(base.isServer))
		{
			info.msg.temporaryRagdoll.parentID = linkedEntity.uid;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.temporaryRagdoll != null)
		{
			Load(info.msg.temporaryRagdoll);
		}
	}

	private void Load(TemporaryRagdoll tempRagdoll)
	{
	}

	private void LateUpdate()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		BaseCombatEntity baseCombatEntity = linkedEntity.Get(base.isServer);
		if (base.isServer)
		{
			if ((Object)(object)baseCombatEntity == (Object)null || baseCombatEntity.IsDead())
			{
				Kill();
				return;
			}
			((Component)baseCombatEntity).transform.position = ((Component)this).transform.position;
			((Component)baseCombatEntity).transform.rotation = ((Component)this).transform.rotation;
			SendNetworkUpdateImmediate();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
		if ((Object)(object)val == (Object)null)
		{
			val = ((Component)this).gameObject.AddComponent<Rigidbody>();
			val.mass = 10f;
			val.drag = 0f;
			val.angularDrag = 0f;
		}
		val.useGravity = true;
		val.collisionDetectionMode = (CollisionDetectionMode)0;
		val.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
	}

	public void InitFromEnt(BaseCombatEntity ent)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		linkedEntity.Set(ent);
		ent.model.skeleton.CopyTo(model.skeleton);
		((Component)this).transform.SetPositionAndRotation(((Component)ent).transform.position, ((Component)ent).transform.rotation);
		Ragdoll.ServerInit();
		Vector3 worldVelocity = ent.GetWorldVelocity();
		foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
		{
			rigidbody.AddForce(worldVelocity, (ForceMode)2);
			rigidbody.drag = 0f;
		}
		((FacepunchBehaviour)this).Invoke((Action)StopRagdolling, 5f);
	}

	private void StopRagdolling()
	{
		linkedEntity.Get(serverside: true)?.SetFlag(Flags.Reserved12, b: false);
		Kill();
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		ProcessCollision(collision);
	}

	protected void OnCollisionEnter(Collision collision)
	{
		ProcessCollision(collision);
	}

	protected void ProcessCollision(Collision collision)
	{
		if (!base.isClient && collision != null && !((Object)(object)collision.gameObject == (Object)null) && !((Object)(object)collision.gameObject == (Object)null) && linkedEntity.Get(serverside: true) is IAnimalRagdollCollisionReceiver animalRagdollCollisionReceiver)
		{
			animalRagdollCollisionReceiver.OnRagdollCollisionEnter(collision);
		}
	}
}


using UnityEngine;

public interface IAnimalRagdollCollisionReceiver
{
	void OnRagdollCollisionEnter(Collision collision);
}


using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/Horse Breed", fileName = "newbreed.asset")]
public class HorseBreed : ScriptableObject
{
	public Phrase breedName;

	public Phrase breedDesc;

	public Sprite trophyHeadSprite;

	public Material[] materialOverrides;

	public float maxHealth = 1f;

	public float maxSpeed = 1f;

	public float staminaDrain = 1f;

	public float maxStamina = 1f;
}


using Facepunch;
using ProtoBuf;

public class HorseCorpse : LootableCorpse
{
	public int breedIndex;

	public Phrase lootPanelTitle;

	public override string playerName => lootPanelTitle.translated;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.horse = Pool.Get<Horse>();
		info.msg.horse.breedIndex = breedIndex;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.horse != null)
		{
			breedIndex = info.msg.horse.breedIndex;
		}
	}
}


using UnityEngine;

public class HorseLeadingRope : FakePhysicsRope
{
	public RidableHorse horse;

	public Vector2 minMaxLength;

	public Vector2 minMaxDistance;
}


using UnityEngine;

public class HorseRagdoll : AnimalRagdoll
{
	public GameObject mane;

	public GameObject woodArmor;

	public GameObject roadsignArmor;

	public HorseBreed overrideBreed;

	public GameObject singleSaddle;

	public GameObject doubleSaddle;

	public GameObjectRef breedSource;
}


using UnityEngine;

public class HorseSaddle : BaseVehicleSeat
{
	[SerializeField]
	private bool isDriver;

	[SerializeField]
	private Transform eyePosRef;

	private RidableHorse _owner;

	protected RidableHorse Owner
	{
		get
		{
			if ((Object)(object)_owner == (Object)null)
			{
				_owner = ((Component)this).GetComponentInParent<RidableHorse>();
			}
			return _owner;
		}
	}

	public override void VehicleFixedUpdate()
	{
	}

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			BaseVehicle baseVehicle = VehicleParent();
			if ((Object)(object)baseVehicle != (Object)null)
			{
				baseVehicle.PlayerMounted(mounted, this);
			}
		}
	}
}


public interface IHorseInputProvider
{
	float GetMoveInput();

	float GetSteerInput();
}


using UnityEngine;

public class AIHorseInputProvider : IHorseInputProvider
{
	private Transform playerTransform;

	private RidableHorse horse;

	private float followSpeed;

	private float stoppingDistance;

	private float turnChangeCooldown = 0.3f;

	private float turnCooldownTimer;

	private float currentSteerInput;

	public AIHorseInputProvider(RidableHorse horse, Transform playerTransform, float stoppingDistance)
	{
		this.horse = horse;
		this.playerTransform = playerTransform;
		this.stoppingDistance = stoppingDistance;
	}

	public float GetMoveInput()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = playerTransform.position - ((Component)horse).transform.position;
		val.y = 0f;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (horse.GetSpeed() > 2f)
		{
			return -1f;
		}
		if (magnitude > stoppingDistance)
		{
			return Mathf.Clamp(((Component)horse).transform.InverseTransformDirection(((Vector3)(ref val)).normalized).z, 0f, 1f);
		}
		return 0f;
	}

	public float GetSteerInput()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = playerTransform.position - ((Component)horse).transform.position;
		val.y = 0f;
		if (((Vector3)(ref val)).magnitude > stoppingDistance - 2f)
		{
			Vector3 val2 = Vector3.Cross(((Component)horse).transform.forward, ((Vector3)(ref val)).normalized);
			int num = 0;
			if (val2.y > 0.4f)
			{
				num = 1;
			}
			else if (val2.y < -0.4f)
			{
				num = -1;
			}
			Quaternion val3 = Quaternion.LookRotation(val);
			float num2 = Quaternion.Angle(((Component)horse).transform.rotation, val3);
			if (num2 > 160f && num2 < 180f)
			{
				num = -1;
			}
			if ((float)num != currentSteerInput && turnCooldownTimer <= 0f)
			{
				currentSteerInput = num;
				turnCooldownTimer = turnChangeCooldown;
			}
		}
		else if (currentSteerInput != 0f && turnCooldownTimer <= 0f)
		{
			currentSteerInput = 0f;
			turnCooldownTimer = turnChangeCooldown;
		}
		if (turnCooldownTimer > 0f)
		{
			turnCooldownTimer -= Time.fixedDeltaTime;
		}
		return currentSteerInput;
	}
}


public class PlayerHorseInputProvider : IHorseInputProvider
{
	public BasePlayer player;

	public PlayerHorseInputProvider(BasePlayer player)
	{
		this.player = player;
	}

	public float GetMoveInput()
	{
		float result = 0f;
		if (player.serverInput.IsDown(BUTTON.FORWARD))
		{
			result = 1f;
		}
		else if (player.serverInput.IsDown(BUTTON.BACKWARD))
		{
			result = -1f;
		}
		return result;
	}

	public float GetSteerInput()
	{
		float result = 0f;
		if (player.serverInput.IsDown(BUTTON.LEFT))
		{
			result = -1f;
		}
		else if (player.serverInput.IsDown(BUTTON.RIGHT))
		{
			result = 1f;
		}
		return result;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

[DefaultExecutionOrder(-1302)]
public class RidableHorseAnimation : EntityComponent<RidableHorse>, IClientComponent
{
	[SerializeField]
	private RidableHorse horse;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	public LegsAnimator legsAnimator;

	[Space]
	[SerializeField]
	private Transform backHipTransform;

	[SerializeField]
	private Vector3 skiddingHipPosition;

	[SerializeField]
	private Vector3 skiddingHipRotation;

	[Header("Head")]
	[Range(0f, 1f)]
	[SerializeField]
	private float headBlend = 1f;

	[ReadOnly]
	public float headSecondaryBlend = 1f;

	public Transform[] neckBones;

	public AnimationCurve rotationResponsivenessCurve;

	public float yawInertiaFactor = 15f;

	public float maxYawAngle = 10f;

	public Vector2 minMaxStiffness;

	public Vector2 minMaxDamping;

	public float headTurnSpeed = 3.5f;

	public Vector3 headLookOffset = Vector3.zero;

	[SerializeField]
	[Range(0f, 1f)]
	[Header("Spine")]
	private float spineBlend = 0.5f;

	[ReadOnly]
	public float spineSecondaryBlend = 1f;

	public Transform[] spineBones;

	public float spineTurnSpeed = 3.5f;

	public float spineYawInertiaFactor = 150f;

	[ReadOnly]
	[SerializeField]
	private Quaternion[] targetNeckRotations;

	[SerializeField]
	[ReadOnly]
	private Quaternion[] targetSpineRotations;

	[SerializeField]
	[ReadOnly]
	private Vector3[] localSpinePositions;

	[SerializeField]
	[ReadOnly]
	private Vector3 originalHipPosition;

	[ReadOnly]
	[SerializeField]
	private Quaternion originalHipRotation;

	public Vector3 spineOffset;

	private float HeadBlend => headBlend * headSecondaryBlend;

	private float SpineBlend => spineBlend * spineSecondaryBlend;
}


using UnityEngine;

public class RidableHorseAudio : FacepunchBehaviour, IClientComponent
{
	[SerializeField]
	private RidableHorse horse;

	[SerializeField]
	private Animator animator;

	[Space]
	[SerializeField]
	public SoundPlayer breathingSound;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDef;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDefWood;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDefRoadsign;

	[SerializeField]
	private AnimationCurve saddleMovementGainCurve;

	[SerializeField]
	[Space]
	private MaterialEffect footstepEffects;

	[SerializeField]
	private Transform[] feet;

	[Space]
	[SerializeField]
	private GameObjectRef swimmingSloshEffect;

	[SerializeField]
	private string BaseFolder;

	[Space]
	[SerializeField]
	private SoundDefinition skidLoopSoundDef;

	[SerializeField]
	private AnimationCurve skidLoopGainCurve;
}


using UnityEngine;

[DefaultExecutionOrder(-1300)]
public class RidableHorseSiegeHarness : EntityComponent<RidableHorse>, IClientComponent
{
	[SerializeField]
	private Transform[] targetBone;

	[SerializeField]
	private Transform[] constrainedBone;

	[SerializeField]
	private Vector3 rotationOffset;

	private void LookAtBone(int index)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (targetBone != null && constrainedBone != null)
		{
			Vector3 val = targetBone[index].position - constrainedBone[index].position;
			if (!(val == Vector3.zero))
			{
				Quaternion val2 = Quaternion.LookRotation(val);
				Quaternion val3 = Quaternion.Euler(rotationOffset);
				Quaternion rotation = val2 * val3;
				constrainedBone[index].rotation = rotation;
			}
		}
	}

	private void LateUpdate()
	{
		LookAtBone(0);
		LookAtBone(1);
	}
}


using UnityEngine;

public class SM_DisableHorseProceduralMotion : StateMachineBehaviour
{
}


using UnityEngine;

public class HumanFuelSystem : IFuelSystem
{
	private readonly bool isServer;

	private float percentFood;

	private EntityRef<BaseVehicle> vehilceRef;

	private float pendingFuel;

	public HumanFuelSystem(bool isServer, BaseVehicle owner, float percentFood)
	{
		this.isServer = isServer;
		this.percentFood = Mathf.Clamp01(percentFood);
		vehilceRef.Set(owner);
	}

	public bool HasValidInstance(bool isServer)
	{
		return vehilceRef.IsValid(isServer);
	}

	public NetworkableId GetInstanceID()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return vehilceRef.uid;
	}

	public void SetInstanceID(NetworkableId uid)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		vehilceRef.uid = uid;
	}

	private BaseVehicle GetVehilce()
	{
		BaseVehicle baseVehicle = vehilceRef.Get(isServer);
		if (baseVehicle.IsValid())
		{
			return baseVehicle;
		}
		return null;
	}

	public int GetFuelCapacity()
	{
		return 0;
	}

	public bool CheckNewChild(BaseEntity child)
	{
		return false;
	}

	public int GetFuelAmount()
	{
		if (TryGetHuman(out var driver))
		{
			float value = driver.metabolism.calories.value;
			float value2 = driver.metabolism.hydration.value;
			return Mathf.FloorToInt(value + value2);
		}
		return 0;
	}

	public float GetFuelFraction()
	{
		if (TryGetHuman(out var driver))
		{
			float num = driver.metabolism.calories.Fraction() * percentFood;
			float num2 = driver.metabolism.hydration.Fraction() * (1f - percentFood);
			return num + num2;
		}
		return 0f;
	}

	public bool HasFuel(bool forceCheck = false)
	{
		if (!TryGetHuman(out var driver))
		{
			return false;
		}
		if (percentFood == 0f)
		{
			return driver.metabolism.hydration.Fraction() > 0f;
		}
		if (percentFood == 1f)
		{
			return driver.metabolism.calories.Fraction() > 0f;
		}
		if (!(driver.metabolism.hydration.Fraction() > 0f))
		{
			return driver.metabolism.calories.Fraction() > 0f;
		}
		return true;
	}

	public int TryUseFuel(float seconds, float fuelUsedPerSecond)
	{
		if (!TryGetHuman(out var driver))
		{
			return 0;
		}
		pendingFuel += seconds + fuelUsedPerSecond;
		if (pendingFuel >= 1f)
		{
			MetabolismAttribute calories = driver.metabolism.calories;
			MetabolismAttribute hydration = driver.metabolism.hydration;
			float val = fuelUsedPerSecond * percentFood;
			float val2 = fuelUsedPerSecond * (1f - percentFood);
			float value = calories.value;
			calories.Subtract(val);
			pendingFuel -= Mathf.RoundToInt(value - calories.value);
			float value2 = hydration.value;
			hydration.Subtract(val2);
			pendingFuel -= Mathf.RoundToInt(value2 - hydration.value);
		}
		return 0;
	}

	public void LootFuel(BasePlayer player)
	{
	}

	public void AddFuel(int amount)
	{
	}

	public void RemoveFuel(int amount)
	{
	}

	public void FillFuel()
	{
	}

	private bool TryGetHuman(out BasePlayer driver)
	{
		driver = null;
		BaseVehicle vehilce = GetVehilce();
		if ((Object)(object)vehilce != (Object)null)
		{
			driver = vehilce.GetDriver();
		}
		return (Object)(object)driver != (Object)null;
	}
}


public interface IFuelSystem
{
	bool HasValidInstance(bool isServer);

	NetworkableId GetInstanceID();

	void SetInstanceID(NetworkableId uid);

	bool CheckNewChild(BaseEntity child);

	int GetFuelAmount();

	float GetFuelFraction();

	bool HasFuel(bool forceCheck = false);

	int TryUseFuel(float seconds, float fuelUsedPerSecond);

	int GetFuelCapacity();

	void LootFuel(BasePlayer player);

	void AddFuel(int amount);

	void RemoveFuel(int amount);

	void FillFuel();
}


public interface IMountable
{
}


using UnityEngine;

public class BaseMagnet : MonoBehaviour
{
	public BaseEntity entityOwner;

	public BaseEntity.Flags magnetFlag = BaseEntity.Flags.Reserved6;

	public TriggerMagnet magnetTrigger;

	public FixedJoint fixedJoint;

	public Rigidbody kinematicAttachmentBody;

	public float magnetForce;

	public Transform attachDepthPoint;

	public GameObjectRef attachEffect;

	public bool isMagnetOn;

	public GameObject colliderSource;

	private BasePlayer associatedPlayer;

	public bool HasConnectedObject()
	{
		if ((Object)(object)((Joint)fixedJoint).connectedBody != (Object)null)
		{
			return isMagnetOn;
		}
		return false;
	}

	public OBB GetConnectedOBB(float scale = 1f)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)((Joint)fixedJoint).connectedBody == (Object)null)
		{
			Debug.LogError((object)"BaseMagnet returning fake OBB because no connected body!");
			return new OBB(Vector3.zero, Vector3.one, Quaternion.identity);
		}
		BaseEntity component = ((Component)((Joint)fixedJoint).connectedBody).gameObject.GetComponent<BaseEntity>();
		Bounds bounds = component.bounds;
		((Bounds)(ref bounds)).extents = ((Bounds)(ref bounds)).extents * scale;
		return new OBB(((Component)component).transform.position, ((Component)component).transform.rotation, bounds);
	}

	public void SetCollisionsEnabled(GameObject other, bool wants)
	{
		Collider[] componentsInChildren = other.GetComponentsInChildren<Collider>();
		Collider[] componentsInChildren2 = colliderSource.GetComponentsInChildren<Collider>();
		Collider[] array = componentsInChildren;
		foreach (Collider val in array)
		{
			Collider[] array2 = componentsInChildren2;
			foreach (Collider val2 in array2)
			{
				Physics.IgnoreCollision(val, val2, !wants);
			}
		}
	}

	public virtual void SetMagnetEnabled(bool wantsOn, BasePlayer forPlayer)
	{
		if (isMagnetOn != wantsOn)
		{
			associatedPlayer = forPlayer;
			isMagnetOn = wantsOn;
			if (isMagnetOn)
			{
				OnMagnetEnabled();
			}
			else
			{
				OnMagnetDisabled();
			}
			if ((Object)(object)entityOwner != (Object)null)
			{
				entityOwner.SetFlag(magnetFlag, isMagnetOn);
			}
		}
	}

	public virtual void OnMagnetEnabled()
	{
	}

	public virtual void OnMagnetDisabled()
	{
		if (Object.op_Implicit((Object)(object)((Joint)fixedJoint).connectedBody))
		{
			SetCollisionsEnabled(((Component)((Joint)fixedJoint).connectedBody).gameObject, wants: true);
			Rigidbody connectedBody = ((Joint)fixedJoint).connectedBody;
			((Joint)fixedJoint).connectedBody = null;
			connectedBody.WakeUp();
		}
	}

	public bool IsMagnetOn()
	{
		return isMagnetOn;
	}

	public void MagnetThink(float delta)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		if (!isMagnetOn)
		{
			return;
		}
		Vector3 position = ((Component)magnetTrigger).transform.position;
		if (magnetTrigger.entityContents == null)
		{
			return;
		}
		OBB val = default(OBB);
		foreach (BaseEntity entityContent in magnetTrigger.entityContents)
		{
			if ((Object)(object)entityContent == (Object)null || !entityContent.syncPosition)
			{
				continue;
			}
			Rigidbody component = ((Component)entityContent).GetComponent<Rigidbody>();
			if ((Object)(object)component == (Object)null || component.isKinematic || entityContent.isClient)
			{
				continue;
			}
			((OBB)(ref val))..ctor(((Component)entityContent).transform.position, ((Component)entityContent).transform.rotation, entityContent.bounds);
			if (((OBB)(ref val)).Contains(attachDepthPoint.position))
			{
				MagnetLiftable component2 = ((Component)entityContent).GetComponent<MagnetLiftable>();
				if ((Object)(object)component2 != (Object)null)
				{
					if (component2.requireObjectOff && entityContent.IsOn())
					{
						continue;
					}
					component2.SetMagnetized(wantsOn: true, this, associatedPlayer);
					if ((Object)(object)((Joint)fixedJoint).connectedBody == (Object)null)
					{
						Effect.server.Run(attachEffect.resourcePath, attachDepthPoint.position, -attachDepthPoint.up);
						((Joint)fixedJoint).connectedBody = component;
						SetCollisionsEnabled(((Component)component).gameObject, wants: false);
						continue;
					}
				}
			}
			if ((Object)(object)((Joint)fixedJoint).connectedBody == (Object)null)
			{
				Vector3 position2 = ((Component)entityContent).transform.position;
				float num = Vector3.Distance(position2, position);
				Vector3 val2 = Vector3Ex.Direction(position, position2);
				float num2 = 1f / Mathf.Max(1f, num);
				component.AddForce(val2 * magnetForce * num2, (ForceMode)5);
			}
		}
	}
}


using UnityEngine;

public class IMagnetLiftable : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using UnityEngine;

public class MagnetCraneAudio : MonoBehaviour
{
	public MagnetCrane crane;

	[Header("Sound defs")]
	public SoundDefinition engineStartSoundDef;

	public SoundDefinition engineStopSoundDef;

	public BlendedLoopEngineSound engineLoops;

	public SoundDefinition cabinRotationStartDef;

	public SoundDefinition cabinRotationStopDef;

	public SoundDefinition cabinRotationLoopDef;

	private Sound cabinRotationLoop;

	public SoundDefinition turningLoopDef;

	private Sound turningLoop;

	public SoundDefinition trackMovementLoopDef;

	private Sound trackMovementLoop;

	private SoundModulation.Modulator trackGainMod;

	private SoundModulation.Modulator trackPitchMod;

	public SoundDefinition armMovementLoopDef;

	public SoundDefinition armMovementStartDef;

	public SoundDefinition armMovementStopDef;

	private Sound armMovementLoop01;

	private SoundModulation.Modulator armMovementLoop01PitchMod;

	public GameObject arm01SoundPosition;

	public GameObject arm02SoundPosition;

	private Sound armMovementLoop02;

	private SoundModulation.Modulator armMovementLoop02PitchMod;
}


using UnityEngine;

public class MagnetLiftable : EntityComponent<BaseEntity>
{
	public ItemAmount[] shredResources;

	public bool scaleScrapResourcesByHealth;

	public Vector3 shredDirection = Vector3.forward;

	public bool requireObjectOff;

	public BasePlayer associatedPlayer { get; private set; }

	public virtual void SetMagnetized(bool wantsOn, BaseMagnet magnetSource, BasePlayer player)
	{
		associatedPlayer = player;
	}
}


using UnityEngine;

public class TriggerMagnet : TriggerBase
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!baseEntity.syncPosition)
		{
			return null;
		}
		if (!Object.op_Implicit((Object)(object)((Component)baseEntity).GetComponent<MagnetLiftable>()))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;

public class MapMarkerMLRSRocket : MapMarker
{
	public RectTransform uiMarkerTransform;

	public override void ServerInit()
	{
		base.ServerInit();
		base.limitNetworking = true;
	}

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		return (ulong)player.userID == base.OwnerID;
	}
}


using UnityEngine;

public class MLRSAmmoIcon : MonoBehaviour
{
	[SerializeField]
	private GameObject fill;

	protected void Awake()
	{
		SetState(filled: false);
	}

	public void SetState(bool filled)
	{
		fill.SetActive(filled);
	}
}


using Rust.UI;
using UnityEngine;

public class MLRSAmmoUI : MonoBehaviour
{
	[SerializeField]
	private RustText ammoText;

	[SerializeField]
	private MLRSAmmoIcon[] ammoIcons;
}


using UnityEngine;

public class MLRSAudio : MonoBehaviour
{
	[SerializeField]
	private MLRS mlrs;

	[SerializeField]
	private Transform pitchTransform;

	[SerializeField]
	private Transform yawTransform;

	[SerializeField]
	private float pitchDeltaSmoothRate = 5f;

	[SerializeField]
	private float yawDeltaSmoothRate = 5f;

	[SerializeField]
	private float pitchDeltaThreshold = 0.5f;

	[SerializeField]
	private float yawDeltaThreshold = 0.5f;

	private float lastPitch;

	private float lastYaw;

	private float pitchDelta;

	private float yawDelta;

	public SoundDefinition turretMovementStartDef;

	public SoundDefinition turretMovementLoopDef;

	public SoundDefinition turretMovementStopDef;

	private Sound turretMovementLoop;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

public class MLRSMainUI : MonoBehaviour
{
	[SerializeField]
	private bool isFullscreen;

	[SerializeField]
	private GameObject noAimingModuleModeGO;

	[SerializeField]
	private GameObject activeModeGO;

	[SerializeField]
	private MLRSAmmoUI noAimingModuleAmmoUI;

	[SerializeField]
	private MLRSAmmoUI activeAmmoUI;

	[SerializeField]
	private MLRSVelocityUI velocityUI;

	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private RustText usernameText;

	[SerializeField]
	private TokenisedPhrase readyStatus;

	[SerializeField]
	private TokenisedPhrase realigningStatus;

	[SerializeField]
	private TokenisedPhrase firingStatus;

	[SerializeField]
	private RustText statusText;

	[SerializeField]
	private MapView mapView;

	[SerializeField]
	private ScrollRectEx mapScrollRect;

	[SerializeField]
	private ScrollRectZoom mapScrollRectZoom;

	[SerializeField]
	private RectTransform mapBaseRect;

	[SerializeField]
	private RectTransform minRangeCircle;

	[SerializeField]
	private RectTransform targetAimRect;

	[SerializeField]
	private RectTransform trueAimRect;

	[SerializeField]
	private UILineRenderer connectingLine;

	[SerializeField]
	private GameObject noTargetCirclePrefab;

	[SerializeField]
	private Transform noTargetCircleParent;

	[SerializeField]
	private SoundDefinition changeTargetSoundDef;

	[SerializeField]
	private SoundDefinition readyToFireSoundDef;
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class MLRSRocket : TimedExplosive, SamSite.ISamSiteTarget
{
	[SerializeField]
	private GameObjectRef mapMarkerPrefab;

	[SerializeField]
	private GameObjectRef launchBlastFXPrefab;

	[SerializeField]
	private GameObjectRef explosionGroundFXPrefab;

	[SerializeField]
	private ServerProjectile serverProjectile;

	private EntityRef mapMarkerInstanceRef;

	public static List<MLRSRocket> serverList = new List<MLRSRocket>();

	public SamSite.SamTargetType SAMTargetType => SamSite.targetTypeMissile;

	public override void ServerInit()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		serverList.Add(this);
		CreateMapMarker();
		Effect.server.Run(launchBlastFXPrefab.resourcePath, PivotPoint(), ((Component)this).transform.up, null, broadcast: true);
	}

	internal override void DoServerDestroy()
	{
		serverList.Remove(this);
		base.DoServerDestroy();
	}

	public override void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Explode(rayOrigin);
		if (Physics.Raycast(((RaycastHit)(ref info)).point + Vector3.up, Vector3.down, 4f, 1084293393, (QueryTriggerInteraction)1))
		{
			Effect.server.Run(explosionGroundFXPrefab.resourcePath, ((RaycastHit)(ref info)).point, Vector3.up, null, broadcast: true);
		}
	}

	private void CreateMapMarker()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = mapMarkerInstanceRef.Get(base.isServer);
		if (baseEntity.IsValid())
		{
			baseEntity.Kill();
		}
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(mapMarkerPrefab?.resourcePath, ((Component)this).transform.position, Quaternion.identity);
		baseEntity2.OwnerID = base.OwnerID;
		baseEntity2.Spawn();
		baseEntity2.SetParent(this, worldPositionStays: true);
		mapMarkerInstanceRef.Set(baseEntity2);
	}

	public bool IsValidSAMTarget(bool staticRespawn)
	{
		return !staticRespawn;
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return serverProjectile.CurrentVelocity;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!other.IsOnLayer((Layer)18))
		{
			return;
		}
		if (((Component)other).CompareTag("MLRSRocketTrigger"))
		{
			Explode();
			TimedExplosive componentInParent = ((Component)other).GetComponentInParent<TimedExplosive>();
			if ((Object)(object)componentInParent != (Object)null)
			{
				componentInParent.Explode();
			}
		}
		else if ((Object)(object)((Component)other).GetComponent<TriggerSafeZone>() != (Object)null)
		{
			Kill();
		}
	}
}


public class MLRSServerProjectile : ServerProjectile
{
	public override bool HasRangeLimit => false;

	protected override int mask => 1235954449;

	protected override bool IsAValidHit(BaseEntity hitEnt)
	{
		if (!base.IsAValidHit(hitEnt))
		{
			return false;
		}
		if (hitEnt.IsValid())
		{
			return !(hitEnt is MLRS);
		}
		return true;
	}
}


using UnityEngine;

public class MLRSUIDialog : UIDialog
{
	[SerializeField]
	private MLRSMainUI mainUI;

	[SerializeField]
	private TokenisedPhrase howToUsePhrase;

	[SerializeField]
	private float titleChangeInterval = 2f;
}


using Rust.UI;
using UnityEngine;

public class MLRSVelocityUI : MonoBehaviour
{
	[SerializeField]
	private RustText percentText;

	[SerializeField]
	private HudElement percentBar;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust.Modular;
using UnityEngine;

public abstract class BaseModularVehicle : GroundVehicle, IPrefabPreProcess, PlayerInventory.ICanMoveFrom
{
	[SerializeField]
	[Header("Modular Vehicle")]
	public List<ModularVehicleSocket> moduleSockets;

	[SerializeField]
	public Transform centreOfMassTransform;

	[SerializeField]
	public Transform waterSample;

	[SerializeField]
	public LODGroup lodGroup;

	public GameObjectRef keyEnterDialog;

	private float _mass = -1f;

	public const Flags FLAG_KINEMATIC = Flags.Reserved6;

	public Dictionary<BaseVehicleModule, Action> moduleAddActions = new Dictionary<BaseVehicleModule, Action>();

	public bool inEditableLocation;

	public bool prevEditable;

	public bool immuneToDecay;

	public Vector3 realLocalCOM;

	public Item AssociatedItemInstance;

	private bool disablePhysics;

	public Vector3 CentreOfMass => centreOfMassTransform.localPosition;

	public int NumAttachedModules => AttachedModuleEntities.Count;

	public bool HasAnyModules => AttachedModuleEntities.Count > 0;

	public List<BaseVehicleModule> AttachedModuleEntities { get; } = new List<BaseVehicleModule>();

	public int TotalSockets => moduleSockets.Count;

	public int NumFreeSockets
	{
		get
		{
			int num = 0;
			for (int i = 0; i < NumAttachedModules; i++)
			{
				num += AttachedModuleEntities[i].GetNumSocketsTaken();
			}
			return TotalSockets - num;
		}
	}

	private float Mass
	{
		get
		{
			if (base.isServer)
			{
				return rigidBody.mass;
			}
			return _mass;
		}
	}

	public float TotalMass { get; set; }

	public bool IsKinematic => HasFlag(Flags.Reserved6);

	public virtual bool IsLockable => false;

	public bool HasInited { get; private set; }

	public ItemDefinition AssociatedItemDef => repair.itemTarget;

	public bool IsEditableNow
	{
		get
		{
			if (base.isServer)
			{
				if (inEditableLocation)
				{
					return CouldBeEdited();
				}
				return false;
			}
			return false;
		}
	}

	public ModularVehicleInventory Inventory { get; set; }

	public override void InitShared()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		AddMass(Mass, CentreOfMass, ((Component)this).transform.position);
		HasInited = true;
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			attachedModuleEntity.RefreshConditionals(canGib: false);
		}
	}

	public virtual bool PlayerCanUseThis(BasePlayer player, ModularCarCodeLock.LockType lockType)
	{
		return true;
	}

	public bool TryDeduceSocketIndex(BaseVehicleModule addedModule, out int index)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (addedModule.FirstSocketIndex >= 0)
		{
			index = addedModule.FirstSocketIndex;
			return index >= 0;
		}
		index = -1;
		for (int i = 0; i < moduleSockets.Count; i++)
		{
			if (Vector3.SqrMagnitude(moduleSockets[i].WorldPosition - ((Component)addedModule).transform.position) < 0.1f)
			{
				index = i;
				return true;
			}
		}
		return false;
	}

	public void AddMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			Vector3 val = ((Component)this).transform.InverseTransformPoint(moduleWorldPos) + moduleCOM;
			if (TotalMass == 0f)
			{
				SetMass(moduleMass);
				SetCOM(val);
				return;
			}
			float num = TotalMass + moduleMass;
			Vector3 cOM = realLocalCOM * (TotalMass / num) + val * (moduleMass / num);
			SetMass(num);
			SetCOM(cOM);
		}
	}

	public void RemoveMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			float num = TotalMass - moduleMass;
			Vector3 val = ((Component)this).transform.InverseTransformPoint(moduleWorldPos) + moduleCOM;
			Vector3 cOM = (realLocalCOM - val * (moduleMass / TotalMass)) / (num / TotalMass);
			SetMass(num);
			SetCOM(cOM);
		}
	}

	public bool TryGetModuleAt(int socketIndex, out BaseVehicleModule result)
	{
		if (socketIndex < 0 || socketIndex >= moduleSockets.Count)
		{
			result = null;
			return false;
		}
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			int firstSocketIndex = attachedModuleEntity.FirstSocketIndex;
			int num = firstSocketIndex + attachedModuleEntity.GetNumSocketsTaken() - 1;
			if (firstSocketIndex <= socketIndex && num >= socketIndex)
			{
				result = attachedModuleEntity;
				return true;
			}
		}
		result = null;
		return false;
	}

	public ModularVehicleSocket GetSocket(int index)
	{
		if (index < 0 || index >= moduleSockets.Count)
		{
			return null;
		}
		return moduleSockets[index];
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.modularVehicle;
	}

	public override bool CanPushNow(BasePlayer pusher)
	{
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (!IsKinematic)
		{
			return !IsEditableNow;
		}
		return false;
	}

	public override void OnChildAdded(BaseEntity childEntity)
	{
		base.OnChildAdded(childEntity);
		BaseVehicleModule module = childEntity as BaseVehicleModule;
		if (module != null)
		{
			Action action = delegate
			{
				ModuleEntityAdded(module);
			};
			moduleAddActions[module] = action;
			((FacepunchBehaviour)module).Invoke(action, 0f);
		}
	}

	public override void OnChildRemoved(BaseEntity childEntity)
	{
		base.OnChildRemoved(childEntity);
		if (childEntity is BaseVehicleModule removedModule)
		{
			ModuleEntityRemoved(removedModule);
		}
	}

	public virtual void ModuleEntityAdded(BaseVehicleModule addedModule)
	{
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		if (AttachedModuleEntities.Contains(addedModule))
		{
			return;
		}
		if (base.isServer && ((Object)(object)this == (Object)null || IsDead() || base.IsDestroyed))
		{
			if ((Object)(object)addedModule != (Object)null && !addedModule.IsDestroyed)
			{
				addedModule.Kill();
			}
			return;
		}
		int index = -1;
		if (base.isServer && addedModule.AssociatedItemInstance != null)
		{
			index = addedModule.AssociatedItemInstance.position;
		}
		if (index == -1 && !TryDeduceSocketIndex(addedModule, out index))
		{
			string text = $"{((object)this).GetType().Name}: Couldn't get socket index from position ({((Component)addedModule).transform.position}).";
			for (int i = 0; i < moduleSockets.Count; i++)
			{
				text += $" Sqr dist to socket {i} at {moduleSockets[i].WorldPosition} is {Vector3.SqrMagnitude(moduleSockets[i].WorldPosition - ((Component)addedModule).transform.position)}.";
			}
			Debug.LogError((object)text, (Object)(object)((Component)addedModule).gameObject);
			return;
		}
		if (moduleAddActions.ContainsKey(addedModule))
		{
			moduleAddActions.Remove(addedModule);
		}
		AttachedModuleEntities.Add(addedModule);
		addedModule.ModuleAdded(this, index);
		AddMass(addedModule.Mass, addedModule.CentreOfMass, ((Component)addedModule).transform.position);
		if (base.isServer && !Inventory.TrySyncModuleInventory(addedModule, index))
		{
			Debug.LogError((object)$"{((object)this).GetType().Name}: Unable to add module {((Object)addedModule).name} to socket ({index}). Destroying it.", (Object)(object)((Component)this).gameObject);
			addedModule.Kill();
			AttachedModuleEntities.Remove(addedModule);
			return;
		}
		RefreshModulesExcept(addedModule);
		if (base.isServer)
		{
			UpdateMountFlags();
		}
	}

	public virtual void ModuleEntityRemoved(BaseVehicleModule removedModule)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (base.IsDestroyed)
		{
			return;
		}
		if (moduleAddActions.ContainsKey(removedModule))
		{
			((FacepunchBehaviour)removedModule).CancelInvoke(moduleAddActions[removedModule]);
			moduleAddActions.Remove(removedModule);
		}
		if (AttachedModuleEntities.Contains(removedModule))
		{
			RemoveMass(removedModule.Mass, removedModule.CentreOfMass, ((Component)removedModule).transform.position);
			AttachedModuleEntities.Remove(removedModule);
			removedModule.ModuleRemoved();
			RefreshModulesExcept(removedModule);
			if (base.isServer)
			{
				UpdateMountFlags();
			}
		}
	}

	public void RefreshModulesExcept(BaseVehicleModule ignoredModule)
	{
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			if ((Object)(object)attachedModuleEntity != (Object)(object)ignoredModule)
			{
				attachedModuleEntity.OtherVehicleModulesChanged();
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!disablePhysics)
		{
			rigidBody.isKinematic = false;
		}
		prevEditable = IsEditableNow;
		if (Inventory == null)
		{
			Inventory = new ModularVehicleInventory(this, AssociatedItemDef, giveUID: true);
		}
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		if (Inventory == null)
		{
			Inventory = new ModularVehicleInventory(this, AssociatedItemDef, giveUID: false);
		}
	}

	public override void PostServerLoad()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		if (Inventory != null)
		{
			ItemContainerId uID = Inventory.UID;
			if (!((ItemContainerId)(ref uID)).IsValid)
			{
				Inventory.GiveUIDs();
			}
		}
		SetFlag(Flags.Open, b: false);
	}

	public override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (Inventory != null)
		{
			Inventory.Dispose();
			Inventory = null;
		}
	}

	public override float MaxVelocity()
	{
		return Mathf.Max(GetMaxForwardSpeed() * 1.3f, 30f);
	}

	public abstract bool IsComplete();

	public bool CouldBeEdited()
	{
		if (!AnyMounted())
		{
			return !IsDead();
		}
		return false;
	}

	public void DisablePhysics()
	{
		disablePhysics = true;
		rigidBody.isKinematic = true;
	}

	public void EnablePhysics()
	{
		disablePhysics = false;
		rigidBody.isKinematic = false;
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("BaseModularVehicle.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (IsEditableNow != prevEditable)
			{
				SendNetworkUpdate();
				prevEditable = IsEditableNow;
			}
			SetFlag(Flags.Reserved6, rigidBody.isKinematic);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override bool MountEligable(BasePlayer player)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (!base.MountEligable(player))
		{
			return false;
		}
		if (IsDead())
		{
			return false;
		}
		if (HasDriver())
		{
			Vector3 velocity = base.Velocity;
			if (((Vector3)(ref velocity)).magnitude >= 2f)
			{
				return false;
			}
		}
		return true;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.modularVehicle = Pool.Get<ModularVehicle>();
		info.msg.modularVehicle.editable = IsEditableNow;
	}

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		BaseVehicleModule moduleForItem = GetModuleForItem(item);
		if ((Object)(object)moduleForItem != (Object)null)
		{
			object obj = Interface.CallHook("OnVehicleModuleMove", (object)moduleForItem, (object)this, (object)player);
			if (obj != null)
			{
				if (!(obj is bool))
				{
					return false;
				}
				return (bool)obj;
			}
			return moduleForItem.CanBeMovedNow();
		}
		return true;
	}

	protected abstract Vector3 GetCOMMultiplier();

	public virtual void ModuleHurt(BaseVehicleModule hurtModule, HitInfo info)
	{
		DoExplosionForce(info);
	}

	public abstract void ModuleReachedZeroHealth();

	public bool TryAddModule(Item moduleItem, int socketIndex)
	{
		if (!ModuleCanBeAdded(moduleItem, socketIndex, out var failureReason))
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": Can't add module: " + failureReason));
			return false;
		}
		bool num = Inventory.TryAddModuleItem(moduleItem, socketIndex);
		if (!num)
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": Couldn't add new item!"));
		}
		return num;
	}

	public bool TryAddModule(Item moduleItem)
	{
		ItemModVehicleModule component = ((Component)moduleItem.info).GetComponent<ItemModVehicleModule>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		int socketsTaken = component.socketsTaken;
		int num = Inventory.TryGetFreeSocket(socketsTaken);
		if (num < 0)
		{
			return false;
		}
		return TryAddModule(moduleItem, num);
	}

	public bool ModuleCanBeAdded(Item moduleItem, int socketIndex, out string failureReason)
	{
		if (!base.isServer)
		{
			failureReason = "Can only add modules on server";
			return false;
		}
		if (moduleItem == null)
		{
			failureReason = "Module item is null";
			return false;
		}
		if (moduleItem.info.category != ItemCategory.Component)
		{
			failureReason = "Not a component type item";
			return false;
		}
		ItemModVehicleModule component = ((Component)moduleItem.info).GetComponent<ItemModVehicleModule>();
		if ((Object)(object)component == (Object)null)
		{
			failureReason = "Not the right item module type";
			return false;
		}
		int socketsTaken = component.socketsTaken;
		if (socketIndex < 0)
		{
			socketIndex = Inventory.TryGetFreeSocket(socketsTaken);
		}
		if (!Inventory.SocketsAreFree(socketIndex, socketsTaken, moduleItem))
		{
			failureReason = "One or more desired sockets already in use";
			return false;
		}
		failureReason = string.Empty;
		return true;
	}

	public BaseVehicleModule CreatePhysicalModuleEntity(Item moduleItem, ItemModVehicleModule itemModModule, int socketIndex)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldPosition = moduleSockets[socketIndex].WorldPosition;
		Quaternion worldRotation = moduleSockets[socketIndex].WorldRotation;
		BaseVehicleModule baseVehicleModule = itemModModule.CreateModuleEntity(this, worldPosition, worldRotation);
		baseVehicleModule.AssociatedItemInstance = moduleItem;
		SetUpModule(baseVehicleModule, moduleItem);
		return baseVehicleModule;
	}

	public void SetUpModule(BaseVehicleModule moduleEntity, Item moduleItem)
	{
		moduleEntity.InitializeHealth(moduleItem.condition, moduleItem.maxCondition);
		if (moduleItem.condition < moduleItem.maxCondition)
		{
			moduleEntity.SendNetworkUpdate();
		}
	}

	public Item GetVehicleItem(ItemId itemUID)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		Item item = Inventory.ChassisContainer.FindItemByUID(itemUID);
		if (item == null)
		{
			item = Inventory.ModuleContainer.FindItemByUID(itemUID);
		}
		return item;
	}

	public BaseVehicleModule GetModuleForItem(Item item)
	{
		if (item == null)
		{
			return null;
		}
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			if (attachedModuleEntity.AssociatedItemInstance == item)
			{
				return attachedModuleEntity;
			}
		}
		return null;
	}

	public void SetMass(float mass)
	{
		TotalMass = mass;
		rigidBody.mass = TotalMass;
	}

	public void SetCOM(Vector3 com)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		realLocalCOM = com;
		rigidBody.centerOfMass = Vector3.Scale(realLocalCOM, GetCOMMultiplier());
	}
}


using UnityEngine;

[CreateAssetMenu(fileName = "Engine Audio Preset", menuName = "Scriptable Object/Vehicles/Engine Audio Preset")]
public class EngineAudioSet : ScriptableObject
{
	public BlendedEngineLoopDefinition[] engineAudioLoops;

	public int priority;

	public float idleRpm = 600f;

	public float gearUpRpm = 5000f;

	public float gearDownRpm = 2500f;

	public int numGears = 5;

	public float minRpm = 10f;

	public float maxRpm = 6000f;

	public float gearUpRpmRate = 5f;

	public float gearDownRpmRate = 6f;

	public SoundDefinition badPerformanceLoop;

	public BlendedEngineLoopDefinition GetEngineLoopDef(int numEngines)
	{
		int num = (numEngines - 1) % engineAudioLoops.Length;
		return engineAudioLoops[num];
	}
}


using UnityEngine;

public class GlassPane : BaseMonoBehaviour, IClientComponent
{
	public Renderer glassRendereer;

	[SerializeField]
	private BaseVehicleModule module;

	[SerializeField]
	private float showFullDamageAt = 0.75f;
}


using UnityEngine;

public class MagnetSnap
{
	private Transform snapLocation;

	private Vector3 prevSnapLocation;

	public MagnetSnap(Transform snapLocation)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		this.snapLocation = snapLocation;
		prevSnapLocation = snapLocation.position;
	}

	public void FixedUpdate(Transform target)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		PositionTarget(target);
		if (snapLocation.hasChanged)
		{
			prevSnapLocation = snapLocation.position;
			snapLocation.hasChanged = false;
		}
	}

	public void PositionTarget(Transform target)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)target == (Object)null))
		{
			Transform transform = ((Component)target).transform;
			Quaternion val = snapLocation.rotation;
			if (Vector3.Angle(transform.forward, snapLocation.forward) > 90f)
			{
				val *= Quaternion.Euler(0f, 180f, 0f);
			}
			if (transform.position != snapLocation.position)
			{
				transform.position += snapLocation.position - prevSnapLocation;
				transform.position = Vector3.MoveTowards(transform.position, snapLocation.position, 1f * Time.fixedDeltaTime);
			}
			if (transform.rotation != val)
			{
				transform.rotation = Quaternion.RotateTowards(transform.rotation, val, 40f * Time.fixedDeltaTime);
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class ModularCarCentralLockingSwitch : VehicleModuleButtonComponent
{
	public Transform centralLockingSwitch;

	public Vector3 switchOffPos;

	public Vector3 switchOnPos;

	public override void ServerUse(BasePlayer player, BaseVehicleModule parentModule)
	{
		if (parentModule.Vehicle is ModularCar modularCar)
		{
			modularCar.CarLock.ToggleCentralLocking();
		}
	}
}


using System;
using UnityEngine;

public class ModularCarChassisVisuals : VehicleChassisVisuals<ModularCar>, IClientComponent
{
	[Serializable]
	public class Steering
	{
		public Transform steerL;

		public Transform steerR;

		public LookAtTarget steerRodL;

		public LookAtTarget steerRodR;

		public LookAtTarget steeringArm;
	}

	[Serializable]
	public class LookAtTarget
	{
		public Transform aim;

		public Transform target;

		public Vector3 angleAdjust;
	}

	public Transform frontAxle;

	public Transform rearAxle;

	public Steering steering;

	public LookAtTarget transmission;
}


using System;
using UnityEngine;

[Serializable]
public class Steering
{
	public Transform steerL;

	public Transform steerR;

	public LookAtTarget steerRodL;

	public LookAtTarget steerRodR;

	public LookAtTarget steeringArm;
}


using System;
using UnityEngine;

[Serializable]
public class LookAtTarget
{
	public Transform aim;

	public Transform target;

	public Vector3 angleAdjust;
}


public interface IVehicleLockUser
{
	bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule);

	bool PlayerHasUnlockPermission(BasePlayer player);

	bool PlayerCanUseThis(BasePlayer player, ModularCarCodeLock.LockType lockType);

	void RemoveLock();
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

public class ModularCarCodeLock
{
	public enum LockType
	{
		Door,
		General
	}

	private readonly bool isServer;

	public readonly ModularCar owner;

	public const BaseEntity.Flags FLAG_CENTRAL_LOCKING = BaseEntity.Flags.Reserved2;

	public const BaseEntity.Flags FLAG_CODE_ENTRY_BLOCKED = BaseEntity.Flags.Reserved10;

	public const float LOCK_DESTROY_HEALTH = 0.2f;

	private List<ulong> whitelistPlayers = new List<ulong>();

	private int wrongCodes;

	private float lastWrongTime = float.NegativeInfinity;

	public bool HasALock
	{
		get
		{
			if (isServer)
			{
				return !string.IsNullOrEmpty(Code);
			}
			return false;
		}
	}

	public bool CentralLockingIsOn
	{
		get
		{
			if ((Object)(object)owner != (Object)null)
			{
				return owner.HasFlag(BaseEntity.Flags.Reserved2);
			}
			return false;
		}
	}

	public IList<ulong> WhitelistPlayers => whitelistPlayers.AsReadOnly();

	public string Code { get; private set; } = "";

	public ModularCarCodeLock(ModularCar owner, bool isServer)
	{
		this.owner = owner;
		this.isServer = isServer;
		if (isServer)
		{
			CheckEnableCentralLocking();
		}
	}

	public bool PlayerCanDestroyLock(BaseVehicleModule viaModule)
	{
		if (!HasALock)
		{
			return false;
		}
		return viaModule.healthFraction <= 0.2f;
	}

	public bool CodeEntryBlocked(BasePlayer player)
	{
		if (!HasALock)
		{
			return true;
		}
		if (HasLockPermission(player))
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null)
		{
			return owner.HasFlag(BaseEntity.Flags.Reserved10);
		}
		return false;
	}

	public void Load(BaseNetworkable.LoadInfo info)
	{
		Code = info.msg.modularCar.lockCode;
		if (Code == null)
		{
			Code = "";
		}
		whitelistPlayers.Clear();
		whitelistPlayers.AddRange(info.msg.modularCar.whitelistUsers);
	}

	public bool HasLockPermission(ulong steamId)
	{
		if (!HasALock)
		{
			return true;
		}
		return whitelistPlayers.Contains(steamId);
	}

	public bool HasLockPermission(BasePlayer player)
	{
		if (!player.IsValid() || player.IsDead())
		{
			return false;
		}
		object obj = Interface.CallHook("CanLock", (object)player, (object)owner, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return HasLockPermission(player.userID);
	}

	public bool PlayerCanUseThis(BasePlayer player, LockType lockType)
	{
		if (lockType == LockType.Door && !CentralLockingIsOn)
		{
			return true;
		}
		return HasLockPermission(player);
	}

	public void PostServerLoad()
	{
		owner.SetFlag(BaseEntity.Flags.Reserved10, b: false);
		CheckEnableCentralLocking();
	}

	public bool CanHaveALock()
	{
		object obj = Interface.CallHook("OnVehicleLockableCheck", (object)this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		if (!owner.IsDead())
		{
			return owner.HasDriverMountPoints();
		}
		return false;
	}

	public bool TryAddALock(string code, ulong userID)
	{
		if (!isServer)
		{
			return false;
		}
		if (owner.IsDead())
		{
			return false;
		}
		TrySetNewCode(code, userID);
		return HasALock;
	}

	public bool IsValidLockCode(string code)
	{
		if (code != null && code.Length == 4)
		{
			return StringEx.IsNumeric(code);
		}
		return false;
	}

	public bool TrySetNewCode(string newCode, ulong userID)
	{
		if (!IsValidLockCode(newCode))
		{
			return false;
		}
		Code = newCode;
		whitelistPlayers.Clear();
		whitelistPlayers.Add(userID);
		owner.SendNetworkUpdate();
		return true;
	}

	public void RemoveLock()
	{
		if (isServer && HasALock)
		{
			Code = "";
			owner.SendNetworkUpdate();
		}
	}

	public bool TryOpenWithCode(BasePlayer player, string codeEntered)
	{
		object obj = Interface.CallHook("CanUnlock", (object)player, (object)this, (object)codeEntered);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (CodeEntryBlocked(player))
		{
			return false;
		}
		if (!(codeEntered == Code))
		{
			if (Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, owner, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				player.ShowToast(GameTip.Styles.Red_Normal, CodeLock.blockwarning, false);
			}
			if ((float)wrongCodes >= CodeLock.maxFailedAttempts)
			{
				owner.SetFlag(BaseEntity.Flags.Reserved10, b: true);
				((FacepunchBehaviour)owner).Invoke((Action)ClearCodeEntryBlocked, CodeLock.lockoutCooldown);
			}
			lastWrongTime = Time.realtimeSinceStartup;
			return false;
		}
		if (TryAddPlayer(player.userID))
		{
			wrongCodes = 0;
		}
		owner.SendNetworkUpdate();
		return true;
	}

	private void ClearCodeEntryBlocked()
	{
		owner.SetFlag(BaseEntity.Flags.Reserved10, b: false);
		wrongCodes = 0;
	}

	public void CheckEnableCentralLocking()
	{
		if (CentralLockingIsOn)
		{
			return;
		}
		bool flag = false;
		foreach (BaseVehicleModule attachedModuleEntity in owner.AttachedModuleEntities)
		{
			if (attachedModuleEntity is VehicleModuleSeating vehicleModuleSeating && vehicleModuleSeating.HasADriverSeat() && vehicleModuleSeating.AnyMounted())
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			owner.SetFlag(BaseEntity.Flags.Reserved2, b: true);
		}
	}

	public void ToggleCentralLocking()
	{
		owner.SetFlag(BaseEntity.Flags.Reserved2, !CentralLockingIsOn);
	}

	public void Save(BaseNetworkable.SaveInfo info)
	{
		info.msg.modularCar.hasLock = HasALock;
		if (info.forDisk)
		{
			info.msg.modularCar.lockCode = Code;
		}
		info.msg.modularCar.whitelistUsers = Pool.Get<List<ulong>>();
		info.msg.modularCar.whitelistUsers.AddRange(whitelistPlayers);
	}

	public bool TryAddPlayer(ulong userID)
	{
		if (!whitelistPlayers.Contains(userID))
		{
			whitelistPlayers.Add(userID);
			return true;
		}
		return false;
	}

	public bool TryRemovePlayer(ulong userID)
	{
		return whitelistPlayers.Remove(userID);
	}
}


public enum LockType
{
	Door,
	General
}


using System;
using UnityEngine;

[Serializable]
public class ModularCarCodeLockVisuals : MonoBehaviour
{
	[SerializeField]
	private GameObject lockedVisuals;

	[SerializeField]
	private GameObject unlockedVisuals;

	[SerializeField]
	private GameObject blockedVisuals;

	[SerializeField]
	private GameObjectRef codelockEffectDenied;

	[SerializeField]
	private GameObjectRef codelockEffectShock;

	[SerializeField]
	private float xOffset = 0.91f;

	[SerializeField]
	private ParticleSystemContainer keycodeDestroyableFX;
}


using Rust;
using UnityEngine;

public class VehicleLiftOccupantTrigger : TriggerBase
{
	public ModularCar carOccupant { get; private set; }

	protected override void OnDisable()
	{
		if (!Application.isQuitting)
		{
			base.OnDisable();
			if ((Object)(object)carOccupant != (Object)null)
			{
				carOccupant = null;
			}
		}
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		if ((Object)(object)base.InterestedInObject(obj) == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null || baseEntity.isClient)
		{
			return null;
		}
		if (!(baseEntity is ModularCar))
		{
			return null;
		}
		return obj;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)carOccupant == (Object)null && ent.isServer)
		{
			carOccupant = (ModularCar)ent;
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (!((Object)(object)carOccupant == (Object)(object)ent))
		{
			return;
		}
		carOccupant = null;
		if (entityContents == null || entityContents.Count <= 0)
		{
			return;
		}
		foreach (BaseEntity entityContent in entityContents)
		{
			if ((Object)(object)entityContent != (Object)null)
			{
				carOccupant = (ModularCar)entityContent;
				break;
			}
		}
	}
}


using Rust.Modular;
using UnityEngine;

[CreateAssetMenu(fileName = "Modular Car Preset", menuName = "Scriptable Object/Vehicles/Modular Car Preset")]
public class ModularCarPresetConfig : ScriptableObject
{
	public ItemModVehicleModule[] socketItemDefs;
}


using System;
using Oxide.Core;
using UnityEngine;

public class ModularCarSeat : MouseSteerableSeat
{
	[SerializeField]
	public Vector3 leftFootIKPos;

	[SerializeField]
	public Vector3 rightFootIKPos;

	[SerializeField]
	private Vector3 leftHandIKPos;

	[SerializeField]
	private Vector3 rightHandIKPos;

	public float providesComfort;

	[NonSerialized]
	public VehicleModuleSeating associatedSeatingModule;

	public override bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (associatedSeatingModule.DoorsAreLockable)
		{
			ModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;
			if ((Object)(object)modularCar != (Object)null)
			{
				return modularCar.PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);
			}
		}
		return true;
	}

	public override float GetComfort()
	{
		return providesComfort;
	}
}


using UnityEngine;

public class ModularVehicleShopFront : ShopFront
{
	[SerializeField]
	public float maxUseDistance = 1.5f;

	public override bool CanBeLooted(BasePlayer player)
	{
		if (WithinUseDistance(player))
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public bool WithinUseDistance(BasePlayer player)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Distance(player.eyes.position) <= maxUseDistance;
	}
}


using UnityEngine;

public class CamperSeatConfig : MonoBehaviour
{
	public Transform[] SeatPositions;

	public Transform StovePosition;

	public Transform StoragePosition;
}


using UnityEngine;

public abstract class VehicleModuleButtonComponent : MonoBehaviour
{
	public string interactionColliderName = "MyCollider";

	public SoundDefinition pressSoundDef;

	public abstract void ServerUse(BasePlayer player, BaseVehicleModule parentModule);
}


using System;
using Oxide.Core;
using Rust;
using Rust.Modular;
using UnityEngine;

public class VehicleModuleEngine : VehicleModuleStorage
{
	[Serializable]
	public class Engine
	{
		[Header("Engine Stats")]
		public int engineKW;

		public float idleFuelPerSec = 0.25f;

		public float maxFuelPerSec = 0.25f;

		[Header("Engine Audio")]
		public EngineAudioSet audioSet;

		[Header("Engine FX")]
		public ParticleSystemContainer[] engineParticles;

		public ParticleSystem[] exhaustSmoke;

		public ParticleSystem[] exhaustBackfire;

		public float exhaustSmokeMinOpacity = 0.1f;

		public float exhaustSmokeMaxOpacity = 0.7f;

		public float exhaustSmokeChangeRate = 0.5f;
	}

	[SerializeField]
	public Engine engine;

	private const float FORCE_MULTIPLIER = 12.75f;

	private const float HEALTH_PERFORMANCE_FRACTION = 0.25f;

	private const float LOW_PERFORMANCE_THRESHOLD = 0.5f;

	private Sound badPerformanceLoop;

	private SoundModulation.Modulator badPerformancePitchModulator;

	private float prevSmokePercent;

	private const float MIN_FORCE_BIAS = 0.0002f;

	private const float MAX_FORCE_BIAS = 0.7f;

	public override bool HasAnEngine => true;

	public bool IsUsable { get; set; }

	public float PerformanceFractionAcceleration { get; set; }

	public float PerformanceFractionTopSpeed { get; set; }

	public float PerformanceFractionFuelEconomy { get; set; }

	public float OverallPerformanceFraction { get; set; }

	public bool AtLowPerformance => OverallPerformanceFraction <= 0.5f;

	public bool AtPeakPerformance => Mathf.Approximately(OverallPerformanceFraction, 1f);

	public int KW => engine.engineKW;

	public EngineAudioSet AudioSet => engine.audioSet;

	private bool EngineIsOn
	{
		get
		{
			if ((Object)(object)base.Car != (Object)null)
			{
				return base.Car.CurEngineState == VehicleEngineController<GroundVehicle>.EngineState.On;
			}
			return false;
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		RefreshPerformanceStats(GetContainer() as EngineStorage);
	}

	public override void OnEngineStateChanged(VehicleEngineController<GroundVehicle>.EngineState oldState, VehicleEngineController<GroundVehicle>.EngineState newState)
	{
		base.OnEngineStateChanged(oldState, newState);
		RefreshPerformanceStats(GetContainer() as EngineStorage);
	}

	public override float GetMaxDriveForce()
	{
		if (!IsUsable)
		{
			return 0f;
		}
		return (float)engine.engineKW * 12.75f * PerformanceFractionTopSpeed;
	}

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", (object)this, (object)engineStorage) == null)
		{
			if ((Object)(object)engineStorage == (Object)null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", (object)this, (object)engineStorage);
		}
	}

	public float GetPerformanceFraction(float statBoostPercent)
	{
		if (!IsUsable)
		{
			return 0f;
		}
		float num = Mathf.Lerp(0f, 0.25f, base.healthFraction);
		float num2 = ((base.healthFraction != 0f) ? (statBoostPercent * 0.75f) : 0f);
		return num + num2;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		RefreshPerformanceStats(GetContainer() as EngineStorage);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		return true;
	}

	public override void VehicleFixedUpdate()
	{
		if (!isSpawned || !base.IsOnAVehicle)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("VehicleModuleEngine.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (base.Vehicle.IsMovingOrOn && !((Object)(object)base.Car == (Object)null) && base.Car.CurEngineState == VehicleEngineController<GroundVehicle>.EngineState.On && IsUsable)
			{
				float num = Mathf.Lerp(engine.idleFuelPerSec, engine.maxFuelPerSec, Mathf.Abs(base.Car.GetThrottleInput()));
				num /= PerformanceFractionFuelEconomy;
				base.Car.TickFuel(num);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float maxDriveForce = GetMaxDriveForce();
		float num = Mathf.Lerp(0.0002f, 0.7f, PerformanceFractionAcceleration);
		float num2 = MathEx.BiasedLerp(1f - absSpeed / topSpeed, num);
		return maxDriveForce * num2;
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		if (!IsTransferProtected() && info.damageTypes.GetMajorityDamageType() != DamageType.Decay)
		{
			float num = info.damageTypes.Total();
			EngineStorage engineStorage = GetContainer() as EngineStorage;
			if ((Object)(object)engineStorage != (Object)null && num > 0f)
			{
				engineStorage.OnModuleDamaged(num);
			}
		}
	}

	public override void OnHealthChanged(float oldValue, float newValue)
	{
		base.OnHealthChanged(oldValue, newValue);
		if (base.isServer)
		{
			RefreshPerformanceStats(GetContainer() as EngineStorage);
		}
	}

	public override bool AdminFixUp(int tier)
	{
		if (!base.AdminFixUp(tier))
		{
			return false;
		}
		EngineStorage engineStorage = GetContainer() as EngineStorage;
		engineStorage.AdminAddParts(tier);
		RefreshPerformanceStats(engineStorage);
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
public class Engine
{
	[Header("Engine Stats")]
	public int engineKW;

	public float idleFuelPerSec = 0.25f;

	public float maxFuelPerSec = 0.25f;

	[Header("Engine Audio")]
	public EngineAudioSet audioSet;

	[Header("Engine FX")]
	public ParticleSystemContainer[] engineParticles;

	public ParticleSystem[] exhaustSmoke;

	public ParticleSystem[] exhaustBackfire;

	public float exhaustSmokeMinOpacity = 0.1f;

	public float exhaustSmokeMaxOpacity = 0.7f;

	public float exhaustSmokeChangeRate = 0.5f;
}


using System;
using Rust;
using UnityEngine;

[RequireComponent(typeof(Collider))]
public class TakeCollisionDamage : FacepunchBehaviour
{
	public interface ICanRestoreVelocity
	{
		void RestoreVelocity(Vector3 amount);
	}

	[SerializeField]
	private BaseCombatEntity entity;

	[SerializeField]
	private float minDamage = 1f;

	[SerializeField]
	private float maxDamage = 250f;

	[SerializeField]
	private float forceForAnyDamage = 20000f;

	[SerializeField]
	private float forceForMaxDamage = 1000000f;

	[SerializeField]
	private float velocityRestorePercent = 0.75f;

	private float pendingDamage;

	private bool IsServer => entity.isServer;

	private bool IsClient => entity.isClient;

	protected void OnCollisionEnter(Collision collision)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		if (IsClient || collision == null || (Object)(object)collision.gameObject == (Object)null || (Object)(object)collision.gameObject == (Object)null)
		{
			return;
		}
		Rigidbody rigidbody = collision.rigidbody;
		float num = (((Object)(object)rigidbody == (Object)null) ? 100f : rigidbody.mass);
		Vector3 relativeVelocity = collision.relativeVelocity;
		float num2 = ((Vector3)(ref relativeVelocity)).magnitude * (entity.RealisticMass + num) / Time.fixedDeltaTime;
		float num3 = Mathf.InverseLerp(forceForAnyDamage, forceForMaxDamage, num2);
		if (num3 > 0f)
		{
			pendingDamage = Mathf.Max(pendingDamage, Mathf.Lerp(minDamage, maxDamage, num3));
			if (pendingDamage > entity.Health() && collision.gameObject.ToBaseEntity() is ICanRestoreVelocity canRestoreVelocity)
			{
				canRestoreVelocity.RestoreVelocity(collision.relativeVelocity * velocityRestorePercent);
			}
			((FacepunchBehaviour)this).Invoke((Action)DoDamage, 0f);
		}
	}

	protected void OnDestroy()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)DoDamage);
	}

	private void DoDamage()
	{
		if (!((Object)(object)entity == (Object)null) && !entity.IsDead() && !entity.IsDestroyed && pendingDamage > 0f)
		{
			entity.Hurt(pendingDamage, DamageType.Collision, null, useProtection: false);
			pendingDamage = 0f;
		}
	}
}


using UnityEngine;

public interface ICanRestoreVelocity
{
	void RestoreVelocity(Vector3 amount);
}


using System;
using UnityEngine;

public class VehicleLight : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class LightRenderer
	{
		public Renderer renderer;

		public int matIndex;
	}

	public bool IsBrake;

	public GameObject toggleObject;

	public LightRenderer[] renderers;

	[ColorUsage(true, true)]
	public Color lightOnColour;

	[ColorUsage(true, true)]
	public Color brakesOnColour;

	public bool applyToTransmittance;

	public bool useLightOnColourForBrake;
}


using System;
using UnityEngine;

[Serializable]
public class LightRenderer
{
	public Renderer renderer;

	public int matIndex;
}


using UnityEngine;

public class SimpleSplineTranslator
{
	private WorldSpline spline;

	private WorldSplineData splineData;

	private float currentDistance;

	private float speed;

	private bool loop;

	private Vector3 offset;

	private int direction;

	public int Direction;

	public float Speed => speed;

	public Vector3 Offset => offset;

	public float CurrentDistance => currentDistance;

	public bool Loop => loop;

	public SimpleSplineTranslator(WorldSpline spline, float speed, int direction = 1, bool loop = false)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		this.spline = spline;
		this.speed = speed;
		this.loop = loop;
		this.direction = direction;
		splineData = spline.GetData();
		offset = Vector3.zero;
		currentDistance = ((direction == 1) ? 0f : splineData.Length);
	}

	public SimpleSplineTranslator()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		spline = null;
		splineData = null;
		speed = 0f;
		loop = false;
		direction = 1;
		offset = Vector3.zero;
		currentDistance = 0f;
	}

	public void Update(float deltaTime)
	{
		if ((Object)(object)spline == (Object)null)
		{
			Debug.LogError((object)"Can't traverse over a null spline. Please set the spline data first.");
			return;
		}
		float delta = speed * deltaTime;
		currentDistance = CalculateNextDistance(currentDistance, delta, direction);
	}

	public Vector3 PeekNextPosition(float delta = 0.1f, int dir = 1, bool getLocal = false)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)spline == (Object)null)
		{
			Debug.LogError((object)"Can't traverse over a null spline. Please set the spline data first.");
			return Vector3.zero;
		}
		float distance = CalculateNextDistance(currentDistance, delta, dir);
		Vector3 positionAtDistance = GetPositionAtDistance(distance, out var _);
		positionAtDistance += offset;
		if (!getLocal)
		{
			positionAtDistance = ((Component)spline).transform.TransformPoint(positionAtDistance);
		}
		return positionAtDistance;
	}

	public Vector3 PeekNextPositionFollowingDirection(float delta = 0.1f, bool getLocal = false)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return PeekNextPosition(delta, direction, getLocal);
	}

	public void GetCurrentPositionAndTangent(out Vector3 position, out Vector3 tangent, bool getLocal = false)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)spline == (Object)null)
		{
			Debug.LogError((object)"Can't traverse over a null spline. Please set the spline data first.");
			position = Vector3.zero;
			tangent = Vector3.zero;
			return;
		}
		position = GetPositionAtDistance(currentDistance, out tangent);
		position += offset;
		if (!getLocal)
		{
			position = ((Component)spline).transform.TransformPoint(position);
		}
	}

	private float CalculateNextDistance(float currentDistance, float delta, float dir)
	{
		float num = currentDistance + delta * dir;
		if (loop)
		{
			return num % splineData.Length;
		}
		return Mathf.Clamp(num, 0f, splineData.Length);
	}

	public float GetEnd()
	{
		if (direction == 1)
		{
			return splineData.Length;
		}
		return 0f;
	}

	public float GetStart()
	{
		if (direction == -1)
		{
			return splineData.Length;
		}
		return 0f;
	}

	public Vector3 GetPositionAtDistance(float distance, out Vector3 tangent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return splineData.GetPointAndTangentCubicHermite(distance, out tangent);
	}

	public SimpleSplineTranslator SetSpeed(float newSpeed)
	{
		speed = newSpeed;
		return this;
	}

	public SimpleSplineTranslator SetOffset(Vector3 offset)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		this.offset = offset;
		return this;
	}

	public SimpleSplineTranslator SetCurrentDistance(float distance)
	{
		currentDistance = Mathf.Clamp(distance, 0f, splineData.Length);
		return this;
	}

	public SimpleSplineTranslator CalculateStartingDistance()
	{
		currentDistance = GetStart();
		return this;
	}

	public SimpleSplineTranslator Reset()
	{
		currentDistance = 0f;
		return this;
	}

	public SimpleSplineTranslator SetSpline(WorldSpline spline)
	{
		this.spline = spline;
		splineData = spline.GetData();
		return this;
	}

	public SimpleSplineTranslator SetDirection(int direction)
	{
		this.direction = direction;
		return this;
	}

	public float GetCurrentDistance()
	{
		return currentDistance;
	}
}


public static class SimpleVehicleVisuals
{
}


using System;
using UnityEngine;

[Serializable]
public class SimpleCarVisualsController
{
	public enum RotationAxis
	{
		X,
		Z,
		Y
	}

	[Header("Simple Visuals Settings")]
	public float wheelLerpSpeed = 5f;

	public float wheelAngleMaximum = 40f;

	public float timeSinceLastUpdateMinimum = 0.5f;

	[Tooltip("Should the wheels be rotated on the Y axis?")]
	public RotationAxis rotateAxis = RotationAxis.Z;

	public RotationAxis steerAxis;

	public TimeSince timeSinceUpdated;

	public void Updated()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		timeSinceUpdated = TimeSince.op_Implicit(0f);
	}
}


public enum RotationAxis
{
	X,
	Z,
	Y
}


using UnityEngine;

public class MouseSteerableSeat : BaseVehicleSeat
{
	[SerializeField]
	private bool supportsMouseSteer;

	public const BUTTON MouseSteerButton = BUTTON.FIRE_THIRD;
}


using UnityEngine;

public class SnowmobileAudio : GroundVehicleAudio
{
	[Header("Engine")]
	[SerializeField]
	private EngineAudioSet engineAudioSet;

	[Header("Skis")]
	[SerializeField]
	private AnimationCurve skiGainCurve;

	[SerializeField]
	private SoundDefinition skiSlideSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideSnowSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideSandSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideGrassSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideWaterSoundDef;

	[Header("Movement")]
	[SerializeField]
	private AnimationCurve movementGainCurve;

	[SerializeField]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private SoundDefinition suspensionLurchSoundDef;

	[SerializeField]
	private float suspensionLurchMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionLurchMinTimeBetweenSounds = 0.25f;
}


using System;
using UnityEngine;

public class SnowmobileChassisVisuals : VehicleChassisVisuals<Snowmobile>, IClientComponent
{
	[Serializable]
	private class TreadRenderer
	{
		public Renderer renderer;

		public int materialIndex;
	}

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private SnowmobileAudio audioScript;

	[SerializeField]
	private TreadRenderer[] treadRenderers;

	[SerializeField]
	private float treadSpeedMultiplier = 0.01f;

	[SerializeField]
	private bool flipRightSkiExtension;

	[SerializeField]
	private Transform leftSki;

	[SerializeField]
	private Transform leftSkiPistonIn;

	[SerializeField]
	private Transform leftSkiPistonOut;

	[SerializeField]
	private Transform rightSki;

	[SerializeField]
	private Transform rightSkiPistonIn;

	[SerializeField]
	private Transform rightSkiPistonOut;

	[SerializeField]
	private float skiVisualAdjust;

	[SerializeField]
	private float treadVisualAdjust;

	[SerializeField]
	private float skiVisualMaxExtension;

	[SerializeField]
	private float treadVisualMaxExtension;

	[SerializeField]
	private float wheelSizeVisualMultiplier = 1f;
}


using System;
using UnityEngine;

[Serializable]
private class TreadRenderer
{
	public Renderer renderer;

	public int materialIndex;
}


using UnityEngine;

public class SoccerBall : BaseCombatEntity
{
	[Header("Soccer Ball")]
	[SerializeField]
	private Rigidbody rigidBody;

	[SerializeField]
	private float additionalForceMultiplier = 0.2f;

	[SerializeField]
	private float upForceMultiplier = 0.15f;

	[SerializeField]
	private DamageRenderer damageRenderer;

	[SerializeField]
	private float explosionForceMultiplier = 40f;

	[SerializeField]
	private float otherForceMultiplier = 10f;

	protected void OnCollisionEnter(Collision collision)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient)
		{
			Vector3 impulse = collision.impulse;
			if (((Vector3)(ref impulse)).magnitude > 0f && (Object)(object)collision.collider.attachedRigidbody != (Object)null && !((Component)(object)collision.collider.attachedRigidbody).HasComponent<SoccerBall>())
			{
				Vector3 val = rigidBody.position - collision.collider.attachedRigidbody.position;
				impulse = collision.impulse;
				float magnitude = ((Vector3)(ref impulse)).magnitude;
				rigidBody.AddForce(val * magnitude * additionalForceMultiplier + Vector3.up * magnitude * upForceMultiplier, (ForceMode)1);
			}
		}
	}

	public override void Hurt(HitInfo info)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		float num = 0f;
		float[] types = info.damageTypes.types;
		foreach (float num2 in types)
		{
			num = (((int)num2 != 16 && (int)num2 != 22) ? (num + num2 * otherForceMultiplier) : (num + num2 * explosionForceMultiplier));
		}
		if (num > 3f)
		{
			if (info.attackNormal != Vector3.zero)
			{
				rigidBody.AddForce(info.attackNormal * num, (ForceMode)1);
			}
			else
			{
				rigidBody.AddExplosionForce(num * 5f, info.HitPositionWorld, 0.25f, 0.25f);
			}
		}
		base.Hurt(info);
	}
}


using System.Collections.Generic;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class EntityFuelSystem : IFuelSystem
{
	public readonly bool isServer;

	private readonly bool editorGiveFreeFuel;

	private readonly uint fuelStorageID;

	public EntityRef<StorageContainer> fuelStorageInstance;

	public float nextFuelCheckTime;

	public bool cachedHasFuel;

	public float pendingFuel;

	public EntityFuelSystem(bool isServer, GameObjectRef fuelStoragePrefab, List<BaseEntity> children, bool editorGiveFreeFuel = true)
	{
		this.isServer = isServer;
		this.editorGiveFreeFuel = editorGiveFreeFuel;
		fuelStorageID = fuelStoragePrefab.GetEntity().prefabID;
		if (!isServer)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			CheckNewChild(child);
		}
	}

	public bool HasValidInstance(bool isServer)
	{
		return fuelStorageInstance.IsValid(isServer);
	}

	public NetworkableId GetInstanceID()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return fuelStorageInstance.uid;
	}

	public void SetInstanceID(NetworkableId uid)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		fuelStorageInstance.uid = uid;
	}

	public bool IsInFuelInteractionRange(BasePlayer player)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanCheckFuel", (object)this, (object)fuelContainer, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)fuelContainer != (Object)null)
		{
			float num = 0f;
			if (isServer)
			{
				num = 3f;
			}
			return fuelContainer.Distance(player.eyes.position) <= num;
		}
		return false;
	}

	public StorageContainer GetFuelContainer()
	{
		StorageContainer storageContainer = fuelStorageInstance.Get(isServer);
		if (storageContainer.IsValid())
		{
			return storageContainer;
		}
		return null;
	}

	public bool CheckNewChild(BaseEntity child)
	{
		if (child.prefabID == fuelStorageID)
		{
			if (child is StorageContainer storageContainer)
			{
				fuelStorageInstance.Set(storageContainer);
				storageContainer.inventory.onItemAddedRemoved = OnFuelAddedRemoved;
			}
			return true;
		}
		return false;
	}

	private void OnFuelAddedRemoved(Item arg1, bool arg2)
	{
		nextFuelCheckTime = 0f;
	}

	public Item GetFuelItem()
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("OnFuelItemCheck", (object)this, (object)fuelContainer);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if ((Object)(object)fuelContainer == (Object)null)
		{
			return null;
		}
		return fuelContainer.inventory.GetSlot(0);
	}

	public int GetFuelAmount()
	{
		Item fuelItem = GetFuelItem();
		object obj = Interface.CallHook("OnFuelAmountCheck", (object)this, (object)fuelItem);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelItem == null || fuelItem.amount < 1)
		{
			return 0;
		}
		return fuelItem.amount;
	}

	public float GetFuelFraction()
	{
		Item fuelItem = GetFuelItem();
		if (fuelItem == null || fuelItem.amount < 1)
		{
			return 0f;
		}
		return Mathf.Clamp01((float)fuelItem.amount / (float)fuelItem.MaxStackable());
	}

	public bool HasFuel(bool forceCheck = false)
	{
		if (Time.time > nextFuelCheckTime || forceCheck)
		{
			object obj = Interface.CallHook("OnFuelCheck", (object)this);
			if (obj is bool)
			{
				return (bool)obj;
			}
			cachedHasFuel = (float)GetFuelAmount() > 0f;
			nextFuelCheckTime = Time.time + Random.Range(1f, 2f);
		}
		return cachedHasFuel;
	}

	public int TryUseFuel(float seconds, float fuelUsedPerSecond)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanUseFuel", (object)this, (object)fuelContainer, (object)seconds, (object)fuelUsedPerSecond);
		if (obj is int)
		{
			return (int)obj;
		}
		if ((Object)(object)fuelContainer == (Object)null)
		{
			return 0;
		}
		Item slot = fuelContainer.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		pendingFuel += seconds * fuelUsedPerSecond;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, num, "fuel_system");
			pendingFuel -= num;
			return num;
		}
		return 0;
	}

	public void LootFuel(BasePlayer player)
	{
		if (IsInFuelInteractionRange(player))
		{
			GetFuelContainer().PlayerOpenLoot(player);
		}
	}

	public void AddFuel(int amount)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		if ((Object)(object)fuelContainer != (Object)null)
		{
			fuelContainer.inventory.AddItem(GetFuelContainer().allowedItem, Mathf.FloorToInt((float)amount), 0uL);
		}
	}

	public void RemoveFuel(int amount)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		if ((Object)(object)fuelContainer != (Object)null)
		{
			Item slot = fuelContainer.inventory.GetSlot(0);
			slot.UseItem(amount);
			Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, amount, "fuel_system");
		}
	}

	public void FillFuel()
	{
		StorageContainer fuelContainer = GetFuelContainer();
		if ((Object)(object)fuelContainer != (Object)null)
		{
			fuelContainer.inventory.AddItem(GetFuelContainer().allowedItem, GetFuelContainer().allowedItem.stackable, 0uL);
		}
	}

	public int GetFuelCapacity()
	{
		return GetFuelContainer().allowedItem.stackable;
	}
}


using UnityEngine;

public class SubmarineAudio : MonoBehaviour
{
	[Header("Engine")]
	[SerializeField]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineStartFailSound;

	[SerializeField]
	private SoundDefinition engineLoopSound;

	[SerializeField]
	private AnimationCurve engineLoopPitchCurve;

	[Header("Water")]
	[SerializeField]
	private SoundDefinition underwaterLoopDef;

	[SerializeField]
	private SoundDefinition underwaterMovementLoopDef;

	[SerializeField]
	private BlendedSoundLoops surfaceWaterLoops;

	[SerializeField]
	private float surfaceWaterSoundsMaxSpeed = 5f;

	[SerializeField]
	private SoundDefinition waterEmergeSoundDef;

	[SerializeField]
	private SoundDefinition waterSubmergeSoundDef;

	[SerializeField]
	[Header("Interior")]
	private SoundDefinition activeLoopDef;

	[SerializeField]
	private SoundDefinition footPedalSoundDef;

	[SerializeField]
	private Transform footPedalSoundPos;

	[SerializeField]
	private SoundDefinition steeringWheelSoundDef;

	[SerializeField]
	private Transform steeringWheelSoundPos;

	[SerializeField]
	private SoundDefinition heavyDamageSparksDef;

	[SerializeField]
	private Transform heavyDamageSparksPos;

	[SerializeField]
	private SoundDefinition flagRaise;

	[SerializeField]
	private SoundDefinition flagLower;

	[SerializeField]
	private GameObject dashboardAudioPoint;

	[Header("Other")]
	[SerializeField]
	private SoundDefinition climbOrDiveLoopSound;

	[SerializeField]
	private SoundDefinition torpedoFailedSound;
}


using Sonar;
using UnityEngine;

public class SubmarineDuo : BaseSubmarine
{
	[SerializeField]
	[Header("Duo Sub Seating & Controls")]
	private Transform steeringWheel;

	[SerializeField]
	private Transform steeringWheelLeftGrip;

	[SerializeField]
	private Transform steeringWheelRightGrip;

	[SerializeField]
	private Transform leftPedal;

	[SerializeField]
	private Transform rightPedal;

	[SerializeField]
	private Transform driverLeftFoot;

	[SerializeField]
	private Transform driverRightFoot;

	[SerializeField]
	private Transform mphNeedle;

	[SerializeField]
	private Transform fuelNeedle;

	[SerializeField]
	private Transform waterDepthNeedle;

	[SerializeField]
	private Transform ammoFlag;

	[SerializeField]
	private SonarSystem sonar;

	[SerializeField]
	private Transform torpedoTubeHatch;
}


using System;
using UnityEngine;

public class TowConfig : PrefabAttribute
{
	[Serializable]
	public struct Configuration
	{
		public Vector2 AngularLimitsX;

		public float AngularLimitY;

		public float AngularLimitZ;
	}

	private static readonly Configuration DefaultConfig = new Configuration
	{
		AngularLimitsX = new Vector2(-80f, 80f),
		AngularLimitY = 60f,
		AngularLimitZ = 55f
	};

	public Configuration Config = DefaultConfig;

	protected override Type GetIndexedType()
	{
		return typeof(TowConfig);
	}

	public Configuration Combine(TowConfig other)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Configuration result = default(Configuration);
		Configuration config = other.Config;
		result.AngularLimitsX = new Vector2(Mathf.Max(Config.AngularLimitsX.x, config.AngularLimitsX.x), Mathf.Min(Config.AngularLimitsX.y, config.AngularLimitsX.y));
		result.AngularLimitY = Mathf.Min(Config.AngularLimitY, config.AngularLimitY);
		result.AngularLimitZ = Mathf.Min(Config.AngularLimitZ, config.AngularLimitZ);
		return result;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Configuration
{
	public Vector2 AngularLimitsX;

	public float AngularLimitY;

	public float AngularLimitZ;
}


using UnityEngine;

public interface ITowing
{
	bool IsTowing { get; }

	bool IsTowingAllowed { get; }

	BaseEntity TowEntity { get; }

	Transform TowAnchor { get; }

	Rigidbody TowBody { get; }

	void OnTowAttach();

	void OnTowDetach();
}


public abstract class TowingAttachment
{
	public const BaseEntity.Flags Flag_IsTowing = BaseEntity.Flags.Reserved14;
}


using ConVar;
using UnityEngine;

public class TowingAttachment<TEntity> : TowingAttachment where TEntity : BaseEntity, ITowing
{
	private readonly TEntity _entity;

	private readonly TowConfig _towingConfig;

	private ConfigurableJoint _towingJoint;

	private EntityRef<BaseEntity> _otherEntity;

	private float _lastBreakingForce;

	private float _idealBreakingForce;

	public TowingAttachment(TEntity entity)
	{
		_entity = entity;
		_towingConfig = PrefabAttribute.server.Find<TowConfig>(_entity.prefabID);
	}

	public void FixedUpdate()
	{
		BaseEntity baseEntity = _otherEntity.Get(serverside: true);
		if (_entity.IsTowing && (!baseEntity.IsValid() || baseEntity.IsDestroyed || (Object)(object)_towingJoint == (Object)null))
		{
			Detach();
		}
		if (_entity.IsTowing)
		{
			MoveToNormalBreakForce();
		}
	}

	public void AttachTo<TTowableEntity>(TTowableEntity other) where TTowableEntity : ITowing
	{
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		if (_entity.IsTowing)
		{
			Detach();
		}
		if ((Object)(object)_towingJoint != (Object)null)
		{
			Object.Destroy((Object)(object)_towingJoint);
		}
		Rigidbody towBody = other.TowBody;
		BaseEntity towEntity = other.TowEntity;
		TowConfig towConfig = PrefabAttribute.server.Find<TowConfig>(towEntity.prefabID);
		if (towConfig == null)
		{
			Debug.LogError((object)"Attaching to towable without TowConfig", (Object)(object)towEntity);
			return;
		}
		TowConfig.Configuration configuration = _towingConfig.Combine(towConfig);
		_towingJoint = ((Component)_entity.TowBody).gameObject.AddComponent<ConfigurableJoint>();
		((Joint)_towingJoint).connectedBody = towBody;
		Matrix4x4 worldToLocalMatrix = ((Component)_entity.TowBody).transform.worldToLocalMatrix;
		((Joint)_towingJoint).autoConfigureConnectedAnchor = false;
		((Joint)_towingJoint).anchor = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(_entity.TowAnchor.position);
		ConfigurableJoint towingJoint = _towingJoint;
		Vector3 val = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyVector(((Component)towBody).transform.right);
		((Joint)towingJoint).axis = ((Vector3)(ref val)).normalized;
		ConfigurableJoint towingJoint2 = _towingJoint;
		val = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyVector(((Component)towBody).transform.up);
		towingJoint2.secondaryAxis = ((Vector3)(ref val)).normalized;
		_towingJoint.swapBodies = false;
		Matrix4x4 worldToLocalMatrix2 = ((Component)towBody).transform.worldToLocalMatrix;
		((Joint)_towingJoint).connectedAnchor = ((Matrix4x4)(ref worldToLocalMatrix2)).MultiplyPoint3x4(other.TowAnchor.position);
		_towingJoint.xMotion = (ConfigurableJointMotion)1;
		_towingJoint.yMotion = (ConfigurableJointMotion)1;
		_towingJoint.zMotion = (ConfigurableJointMotion)1;
		ConfigurableJoint towingJoint3 = _towingJoint;
		SoftJointLimitSpring linearLimitSpring = default(SoftJointLimitSpring);
		((SoftJointLimitSpring)(ref linearLimitSpring)).spring = 100000f;
		((SoftJointLimitSpring)(ref linearLimitSpring)).damper = 100f;
		towingJoint3.linearLimitSpring = linearLimitSpring;
		ConfigurableJoint towingJoint4 = _towingJoint;
		SoftJointLimit val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = 0.2f;
		towingJoint4.linearLimit = val2;
		((Joint)_towingJoint).enableCollision = true;
		_towingJoint.angularXMotion = (ConfigurableJointMotion)1;
		_towingJoint.angularYMotion = (ConfigurableJointMotion)1;
		_towingJoint.angularZMotion = (ConfigurableJointMotion)1;
		ConfigurableJoint towingJoint5 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitsX.x;
		towingJoint5.lowAngularXLimit = val2;
		ConfigurableJoint towingJoint6 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitsX.y;
		towingJoint6.highAngularXLimit = val2;
		ConfigurableJoint towingJoint7 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitY;
		towingJoint7.angularYLimit = val2;
		ConfigurableJoint towingJoint8 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitZ;
		towingJoint8.angularZLimit = val2;
		_towingJoint.targetRotation = Quaternion.identity;
		_towingJoint.projectionMode = (JointProjectionMode)1;
		((Joint)_towingJoint).breakForce = 1E+20f;
		_lastBreakingForce = ((Joint)_towingJoint).breakForce;
		float num = Mathf.Min(_entity.TowBody.isKinematic ? 10000f : _entity.TowBody.mass, towBody.isKinematic ? 10000f : towBody.mass);
		_idealBreakingForce = num * Physics.towingmaxlinearaccelfromjoint;
		_otherEntity.Set(towEntity);
		_entity.SetFlag(BaseEntity.Flags.Reserved14, b: true);
		towEntity.SetFlag(BaseEntity.Flags.Reserved14, b: true);
		_entity.OnTowAttach();
		other.OnTowAttach();
	}

	public void Detach()
	{
		if ((Object)(object)_towingJoint != (Object)null)
		{
			Object.Destroy((Object)(object)_towingJoint);
		}
		_entity.SetFlag(BaseEntity.Flags.Reserved14, b: false);
		BaseEntity baseEntity = _otherEntity.Get(serverside: true);
		bool num = (Object)(object)baseEntity == (Object)null;
		if (!num)
		{
			baseEntity.SetFlag(BaseEntity.Flags.Reserved14, b: false);
		}
		_otherEntity = default(EntityRef<BaseEntity>);
		_entity.OnTowDetach();
		if (!num && baseEntity is ITowing towing)
		{
			towing.OnTowDetach();
		}
	}

	private void MoveToNormalBreakForce()
	{
		if (Mathf.Approximately(_lastBreakingForce, _idealBreakingForce))
		{
			if (!_towingJoint.swapBodies)
			{
				_towingJoint.swapBodies = true;
			}
		}
		else
		{
			float num = Mathf.Lerp(((Joint)_towingJoint).breakForce, _idealBreakingForce, Time.fixedDeltaTime * 10f);
			((Joint)_towingJoint).breakForce = num;
			_lastBreakingForce = num;
		}
	}
}


public class TowingJointBreakDebug : FacepunchBehaviour
{
}


using UnityEngine;

public class TowingVisuals : FacepunchBehaviour, IClientComponent
{
	public GameObject visualPrefab;

	public Transform centralAnchor;

	public Transform[] visualAnchors;

	public Transform[] leadPoints;

	public TransformLineRenderer transformLineRenderer;
}


using UnityEngine;

public class TriggerEntityType<TEntity> : TriggerBase where TEntity : BaseEntity
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!(baseEntity is TEntity))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


public class TriggerTowing : TriggerEntityType<BaseSiegeWeapon>
{
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class CompleteTrain : IDisposable
{
	private enum ShuntState
	{
		None,
		Forwards,
		Backwards
	}

	public enum StaticCollisionState
	{
		Free,
		StaticColliding,
		StayingStill
	}

	private Vector3 unloaderPos;

	public float trackSpeed;

	private float prevTrackSpeed;

	public List<TrainCar> trainCars;

	public TriggerTrainCollisions frontCollisionTrigger;

	public TriggerTrainCollisions rearCollisionTrigger;

	public bool ranUpdateTick;

	public bool disposed;

	public const float IMPACT_ENERGY_FRACTION = 0.75f;

	public const float MIN_COLLISION_FORCE = 70000f;

	public float lastMovingTime = float.MinValue;

	public const float SLEEP_SPEED = 0.1f;

	public const float SLEEP_DELAY = 10f;

	public TimeSince timeSinceLastChange;

	private bool isShunting;

	private TimeSince timeSinceShuntStart;

	private const float MAX_SHUNT_TIME = 20f;

	private const float SHUNT_SPEED = 4f;

	private const float SHUNT_SPEED_CHANGE_RATE = 10f;

	private Action<CoalingTower.ActionAttemptStatus> shuntEndCallback;

	private float shuntDistance;

	private Vector3 shuntDirection;

	private Vector2 shuntStartPos2D = Vector2.zero;

	private Vector2 shuntTargetPos2D = Vector2.zero;

	private TrainCar shuntTarget;

	public StaticCollisionState staticCollidingAtFront;

	private HashSet<GameObject> monitoredStaticContentF = new HashSet<GameObject>();

	public StaticCollisionState staticCollidingAtRear;

	private HashSet<GameObject> monitoredStaticContentR = new HashSet<GameObject>();

	public Dictionary<Rigidbody, float> prevTrackSpeeds = new Dictionary<Rigidbody, float>();

	public TrainCar PrimaryTrainCar { get; set; }

	public bool TrainIsReversing => (Object)(object)PrimaryTrainCar != (Object)(object)trainCars[0];

	public float TotalForces { get; set; }

	public float TotalMass { get; set; }

	public int NumTrainCars => trainCars.Count;

	public int LinedUpToUnload { get; private set; } = -1;

	public bool IsLinedUpToUnload => LinedUpToUnload >= 0;

	public CompleteTrain(TrainCar trainCar)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		List<TrainCar> list = Pool.Get<List<TrainCar>>();
		list.Add(trainCar);
		Init(list);
	}

	public CompleteTrain(List<TrainCar> allTrainCars)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Init(allTrainCars);
	}

	private void Init(List<TrainCar> allTrainCars)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		trainCars = allTrainCars;
		timeSinceLastChange = TimeSince.op_Implicit(0f);
		lastMovingTime = Time.time;
		float num = 0f;
		PrimaryTrainCar = trainCars[0];
		for (int i = 0; i < trainCars.Count; i++)
		{
			TrainCar trainCar = trainCars[i];
			if (trainCar.completeTrain != null)
			{
				trainCar.savedTrackSpeed = trainCar.GetTrackSpeed();
			}
		}
		for (int j = 0; j < trainCars.Count; j++)
		{
			TrainCar trainCar2 = trainCars[j];
			if (trainCar2.completeTrain != this)
			{
				trainCar2.SetNewCompleteTrain(this);
				num = ((!trainCar2.IsCoupledBackwards()) ? (num + trainCar2.savedTrackSpeed) : (num - trainCar2.savedTrackSpeed));
			}
		}
		num = (trackSpeed = num / (float)trainCars.Count);
		prevTrackSpeed = trackSpeed;
		ParamsTick();
	}

	~CompleteTrain()
	{
		Cleanup();
	}

	public void Dispose()
	{
		Cleanup();
		System.GC.SuppressFinalize(this);
	}

	private void Cleanup()
	{
		if (!disposed)
		{
			EndShunting(CoalingTower.ActionAttemptStatus.GenericError);
			disposed = true;
			Pool.FreeUnmanaged<TrainCar>(ref trainCars);
		}
	}

	public void RemoveTrainCar(TrainCar trainCar)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		if (disposed)
		{
			return;
		}
		if (trainCars.Count <= 1)
		{
			Debug.LogWarning((object)(GetType().Name + ": Can't remove car from CompleteTrain of length one."));
			return;
		}
		int num = IndexOf(trainCar);
		bool flag = ((num != 0) ? trainCars[0].IsCoupledBackwards() : trainCars[1].IsCoupledBackwards());
		trainCars.RemoveAt(num);
		timeSinceLastChange = TimeSince.op_Implicit(0f);
		LinedUpToUnload = -1;
		if (trainCars[0].IsCoupledBackwards() != flag)
		{
			trackSpeed *= -1f;
		}
	}

	public float GetTrackSpeedFor(TrainCar trainCar)
	{
		if (disposed)
		{
			return 0f;
		}
		if (trainCars.IndexOf(trainCar) < 0)
		{
			Debug.LogError((object)(GetType().Name + ": Train car not found in the trainCars list."));
			return 0f;
		}
		if (trainCar.IsCoupledBackwards())
		{
			return 0f - trackSpeed;
		}
		return trackSpeed;
	}

	public float GetPrevTrackSpeedFor(TrainCar trainCar)
	{
		if (trainCars.IndexOf(trainCar) < 0)
		{
			Debug.LogError((object)(GetType().Name + ": Train car not found in the trainCars list."));
			return 0f;
		}
		if (trainCar.IsCoupledBackwards())
		{
			return 0f - prevTrackSpeed;
		}
		return prevTrackSpeed;
	}

	public void UpdateTick(float dt)
	{
		if (ranUpdateTick || disposed)
		{
			return;
		}
		ranUpdateTick = true;
		if (IsAllAsleep() && !HasAnyEnginesOn() && !HasAnyCollisions() && !isShunting)
		{
			trackSpeed = 0f;
			return;
		}
		ParamsTick();
		MovementTick(dt);
		LinedUpToUnload = CheckLinedUpToUnload(out unloaderPos);
		if (!disposed)
		{
			if (Mathf.Abs(trackSpeed) > 0.1f)
			{
				lastMovingTime = Time.time;
			}
			if (!HasAnyEnginesOn() && !HasAnyCollisions() && Time.time > lastMovingTime + 10f)
			{
				trackSpeed = 0f;
				SleepAll();
			}
		}
	}

	public bool IncludesAnEngine()
	{
		if (disposed)
		{
			return false;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.CarType == TrainCar.TrainCarType.Engine)
			{
				return true;
			}
		}
		return false;
	}

	protected bool HasAnyCollisions()
	{
		if (!frontCollisionTrigger.HasAnyContents)
		{
			return rearCollisionTrigger.HasAnyContents;
		}
		return true;
	}

	private bool HasAnyEnginesOn()
	{
		if (disposed)
		{
			return false;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.CarType == TrainCar.TrainCarType.Engine && trainCar.IsOn())
			{
				return true;
			}
		}
		return false;
	}

	private bool IsAllAsleep()
	{
		if (disposed)
		{
			return true;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (!trainCar.rigidBody.IsSleeping())
			{
				return false;
			}
		}
		return true;
	}

	private void SleepAll()
	{
		if (disposed)
		{
			return;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			trainCar.rigidBody.Sleep();
		}
	}

	public bool TryShuntCarTo(Vector3 shuntDirection, float shuntDistance, TrainCar shuntTarget, Action<CoalingTower.ActionAttemptStatus> shuntEndCallback, out CoalingTower.ActionAttemptStatus status)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (disposed)
		{
			status = CoalingTower.ActionAttemptStatus.NoTrainCar;
			return false;
		}
		if (isShunting)
		{
			status = CoalingTower.ActionAttemptStatus.AlreadyShunting;
			return false;
		}
		if (Mathf.Abs(trackSpeed) > 0.1f)
		{
			status = CoalingTower.ActionAttemptStatus.TrainIsMoving;
			return false;
		}
		if (HasThrottleInput())
		{
			status = CoalingTower.ActionAttemptStatus.TrainHasThrottle;
			return false;
		}
		this.shuntDirection = shuntDirection;
		this.shuntDistance = shuntDistance;
		this.shuntTarget = shuntTarget;
		timeSinceShuntStart = TimeSince.op_Implicit(0f);
		shuntStartPos2D.x = ((Component)shuntTarget).transform.position.x;
		shuntStartPos2D.y = ((Component)shuntTarget).transform.position.z;
		isShunting = true;
		this.shuntEndCallback = shuntEndCallback;
		status = CoalingTower.ActionAttemptStatus.NoError;
		return true;
	}

	private void EndShunting(CoalingTower.ActionAttemptStatus status)
	{
		isShunting = false;
		if (shuntEndCallback != null)
		{
			shuntEndCallback(status);
			shuntEndCallback = null;
		}
		shuntTarget = null;
	}

	public bool ContainsOnly(TrainCar trainCar)
	{
		if (disposed)
		{
			return false;
		}
		if (trainCars.Count == 1)
		{
			return (Object)(object)trainCars[0] == (Object)(object)trainCar;
		}
		return false;
	}

	public int IndexOf(TrainCar trainCar)
	{
		if (disposed)
		{
			return -1;
		}
		return trainCars.IndexOf(trainCar);
	}

	public bool TryGetAdjacentTrainCar(TrainCar trainCar, bool next, Vector3 forwardDir, out TrainCar result)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		int num = trainCars.IndexOf(trainCar);
		Vector3 val = ((!trainCars[num].IsCoupledBackwards()) ? ((Component)trainCar).transform.forward : (-((Component)trainCar).transform.forward));
		if (Vector3.Dot(val, forwardDir) < 0f)
		{
			next = !next;
		}
		if (num >= 0)
		{
			num = ((!next) ? (num - 1) : (num + 1));
			if (num >= 0 && num < trainCars.Count)
			{
				result = trainCars[num];
				return true;
			}
		}
		result = null;
		return false;
	}

	private void ParamsTick()
	{
		TotalForces = 0f;
		TotalMass = 0f;
		int num = 0;
		float num2 = 0f;
		for (int i = 0; i < trainCars.Count; i++)
		{
			TrainCar trainCar = trainCars[i];
			if (trainCar.rigidBody.mass > num2)
			{
				num2 = trainCar.rigidBody.mass;
				num = i;
			}
		}
		bool flag = false;
		for (int j = 0; j < trainCars.Count; j++)
		{
			TrainCar trainCar2 = trainCars[j];
			float forces = trainCar2.GetForces();
			TotalForces += (trainCar2.IsCoupledBackwards() ? (0f - forces) : forces);
			flag |= trainCar2.HasThrottleInput();
			if (j == num)
			{
				TotalMass += trainCar2.rigidBody.mass;
			}
			else
			{
				TotalMass += trainCar2.rigidBody.mass * 0.4f;
			}
		}
		if (isShunting && flag)
		{
			EndShunting(CoalingTower.ActionAttemptStatus.TrainHasThrottle);
		}
		if (trainCars.Count == 1)
		{
			frontCollisionTrigger = trainCars[0].FrontCollisionTrigger;
			rearCollisionTrigger = trainCars[0].RearCollisionTrigger;
		}
		else
		{
			frontCollisionTrigger = (trainCars[0].coupling.IsRearCoupled ? trainCars[0].FrontCollisionTrigger : trainCars[0].RearCollisionTrigger);
			rearCollisionTrigger = (trainCars[trainCars.Count - 1].coupling.IsRearCoupled ? trainCars[trainCars.Count - 1].FrontCollisionTrigger : trainCars[trainCars.Count - 1].RearCollisionTrigger);
		}
	}

	private void MovementTick(float dt)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		prevTrackSpeed = trackSpeed;
		if (!isShunting)
		{
			trackSpeed += TotalForces * dt / TotalMass;
		}
		else
		{
			bool flag = Vector3.Dot(shuntDirection, ((Component)PrimaryTrainCar).transform.forward) >= 0f;
			if (PrimaryTrainCar.IsCoupledBackwards())
			{
				flag = !flag;
			}
			if ((Object)(object)shuntTarget == (Object)null || shuntTarget.IsDead() || shuntTarget.IsDestroyed)
			{
				EndShunting(CoalingTower.ActionAttemptStatus.NoTrainCar);
			}
			else
			{
				float num = 4f;
				shuntTargetPos2D.x = ((Component)shuntTarget).transform.position.x;
				shuntTargetPos2D.y = ((Component)shuntTarget).transform.position.z;
				float num2 = shuntDistance - Vector3.Distance(Vector2.op_Implicit(shuntStartPos2D), Vector2.op_Implicit(shuntTargetPos2D));
				if (num2 < 2f)
				{
					float num3 = Mathf.InverseLerp(0f, 2f, num2);
					num *= Mathf.Lerp(0.1f, 1f, num3);
				}
				trackSpeed = Mathf.MoveTowards(trackSpeed, flag ? num : (0f - num), dt * 10f);
				if (TimeSince.op_Implicit(timeSinceShuntStart) > 20f || num2 <= 0f)
				{
					EndShunting(CoalingTower.ActionAttemptStatus.NoError);
					trackSpeed = 0f;
				}
			}
		}
		float num4 = trainCars[0].rigidBody.drag;
		if (IsLinedUpToUnload)
		{
			float num5 = Mathf.Abs(trackSpeed);
			if (num5 > 1f)
			{
				TrainCarUnloadable trainCarUnloadable = trainCars[LinedUpToUnload] as TrainCarUnloadable;
				if ((Object)(object)trainCarUnloadable != (Object)null)
				{
					float num6 = trainCarUnloadable.MinDistToUnloadingArea(unloaderPos);
					float num7 = Mathf.InverseLerp(2f, 0f, num6);
					if (num5 < 2f)
					{
						float num8 = (num5 - 1f) / 1f;
						num7 *= num8;
					}
					num4 = Mathf.Lerp(num4, 3.5f, num7);
				}
			}
		}
		if (trackSpeed > 0f)
		{
			trackSpeed -= num4 * 4f * dt;
			if (trackSpeed < 0f)
			{
				trackSpeed = 0f;
			}
		}
		else if (trackSpeed < 0f)
		{
			trackSpeed += num4 * 4f * dt;
			if (trackSpeed > 0f)
			{
				trackSpeed = 0f;
			}
		}
		float num9 = trackSpeed;
		trackSpeed = ApplyCollisionsToTrackSpeed(trackSpeed, TotalMass, dt);
		if (isShunting && trackSpeed != num9)
		{
			EndShunting(CoalingTower.ActionAttemptStatus.GenericError);
		}
		if (disposed)
		{
			return;
		}
		trackSpeed = Mathf.Clamp(trackSpeed, 0f - (TrainCar.TRAINCAR_MAX_SPEED - 1f), TrainCar.TRAINCAR_MAX_SPEED - 1f);
		if (trackSpeed > 0f)
		{
			PrimaryTrainCar = trainCars[0];
		}
		else if (trackSpeed < 0f)
		{
			PrimaryTrainCar = trainCars[trainCars.Count - 1];
		}
		else if (TotalForces > 0f)
		{
			PrimaryTrainCar = trainCars[0];
		}
		else if (TotalForces < 0f)
		{
			PrimaryTrainCar = trainCars[trainCars.Count - 1];
		}
		else
		{
			PrimaryTrainCar = trainCars[0];
		}
		if (trackSpeed == 0f && TotalForces == 0f)
		{
			return;
		}
		PrimaryTrainCar.FrontTrainCarTick(GetTrackSelection(), dt);
		if (trainCars.Count <= 1)
		{
			return;
		}
		if ((Object)(object)PrimaryTrainCar == (Object)(object)trainCars[0])
		{
			for (int i = 1; i < trainCars.Count; i++)
			{
				MoveOtherTrainCar(trainCars[i], trainCars[i - 1]);
			}
			return;
		}
		for (int num10 = trainCars.Count - 2; num10 >= 0; num10--)
		{
			MoveOtherTrainCar(trainCars[num10], trainCars[num10 + 1]);
		}
	}

	private void MoveOtherTrainCar(TrainCar trainCar, TrainCar prevTrainCar)
	{
		TrainTrackSpline frontTrackSection = prevTrainCar.FrontTrackSection;
		float frontWheelSplineDist = prevTrainCar.FrontWheelSplineDist;
		float num = 0f;
		TrainCoupling coupledTo = trainCar.coupling.frontCoupling.CoupledTo;
		TrainCoupling coupledTo2 = trainCar.coupling.rearCoupling.CoupledTo;
		if (coupledTo == prevTrainCar.coupling.frontCoupling)
		{
			num += trainCar.DistFrontWheelToFrontCoupling;
			num += prevTrainCar.DistFrontWheelToFrontCoupling;
		}
		else if (coupledTo2 == prevTrainCar.coupling.rearCoupling)
		{
			num -= trainCar.DistFrontWheelToBackCoupling;
			num -= prevTrainCar.DistFrontWheelToBackCoupling;
		}
		else if (coupledTo == prevTrainCar.coupling.rearCoupling)
		{
			num += trainCar.DistFrontWheelToFrontCoupling;
			num += prevTrainCar.DistFrontWheelToBackCoupling;
		}
		else if (coupledTo2 == prevTrainCar.coupling.frontCoupling)
		{
			num -= trainCar.DistFrontWheelToBackCoupling;
			num -= prevTrainCar.DistFrontWheelToFrontCoupling;
		}
		else
		{
			Debug.LogError((object)(GetType().Name + ": Uncoupled!"));
		}
		trainCar.OtherTrainCarTick(frontTrackSection, frontWheelSplineDist, 0f - num);
	}

	public void ResetUpdateTick()
	{
		ranUpdateTick = false;
	}

	public bool Matches(List<TrainCar> listToCompare)
	{
		if (disposed)
		{
			return false;
		}
		if (listToCompare.Count != trainCars.Count)
		{
			return false;
		}
		for (int i = 0; i < listToCompare.Count; i++)
		{
			if ((Object)(object)trainCars[i] != (Object)(object)listToCompare[i])
			{
				return false;
			}
		}
		return true;
	}

	public void ReduceSpeedBy(float velChange)
	{
		prevTrackSpeed = trackSpeed;
		if (trackSpeed > 0f)
		{
			trackSpeed = Mathf.Max(0f, trackSpeed - velChange);
		}
		else if (trackSpeed < 0f)
		{
			trackSpeed = Mathf.Min(0f, trackSpeed + velChange);
		}
	}

	public bool AnyPlayersOnTrain()
	{
		if (disposed)
		{
			return false;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.AnyPlayersOnTrainCar())
			{
				return true;
			}
		}
		return false;
	}

	private int CheckLinedUpToUnload(out Vector3 unloaderPos)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (disposed)
		{
			unloaderPos = Vector3.zero;
			return -1;
		}
		for (int i = 0; i < trainCars.Count; i++)
		{
			TrainCar trainCar = trainCars[i];
			if (CoalingTower.IsUnderAnUnloader(trainCar, out var isLinedUp, out unloaderPos))
			{
				trainCar.SetFlag(BaseEntity.Flags.Reserved4, isLinedUp);
				if (isLinedUp)
				{
					return i;
				}
			}
		}
		unloaderPos = Vector3.zero;
		return -1;
	}

	public bool GetIsCoupledBackwards(TrainCar trainCar)
	{
		if (disposed)
		{
			return false;
		}
		return GetIsCoupledBackwards(trainCars.IndexOf(trainCar));
	}

	private bool GetIsCoupledBackwards(int trainCarIndex)
	{
		if (disposed || trainCars.Count == 1 || trainCarIndex < 0 || trainCarIndex > trainCars.Count - 1)
		{
			return false;
		}
		TrainCar trainCar = trainCars[trainCarIndex];
		if (trainCarIndex == 0)
		{
			return trainCar.coupling.IsFrontCoupled;
		}
		TrainCoupling coupledTo = trainCar.coupling.frontCoupling.CoupledTo;
		if (coupledTo != null)
		{
			return (Object)(object)coupledTo.owner != (Object)(object)trainCars[trainCarIndex - 1];
		}
		return true;
	}

	private bool HasThrottleInput()
	{
		for (int i = 0; i < trainCars.Count; i++)
		{
			if (trainCars[i].HasThrottleInput())
			{
				return true;
			}
		}
		return false;
	}

	private TrainTrackSpline.TrackSelection GetTrackSelection()
	{
		TrainTrackSpline.TrackSelection result = TrainTrackSpline.TrackSelection.Default;
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.localTrackSelection == TrainTrackSpline.TrackSelection.Default)
			{
				continue;
			}
			if (trainCar.IsCoupledBackwards() != PrimaryTrainCar.IsCoupledBackwards())
			{
				if (trainCar.localTrackSelection == TrainTrackSpline.TrackSelection.Left)
				{
					return TrainTrackSpline.TrackSelection.Right;
				}
				if (trainCar.localTrackSelection == TrainTrackSpline.TrackSelection.Right)
				{
					return TrainTrackSpline.TrackSelection.Left;
				}
			}
			return trainCar.localTrackSelection;
		}
		return result;
	}

	public void FreeStaticCollision()
	{
		staticCollidingAtFront = StaticCollisionState.Free;
		staticCollidingAtRear = StaticCollisionState.Free;
	}

	private float ApplyCollisionsToTrackSpeed(float trackSpeed, float totalMass, float deltaTime)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		TrainCar owner = frontCollisionTrigger.owner;
		Vector3 forwardVector = (owner.IsCoupledBackwards() ? (-((Component)owner).transform.forward) : ((Component)owner).transform.forward);
		trackSpeed = ApplyCollisions(trackSpeed, owner, forwardVector, atOurFront: true, frontCollisionTrigger, totalMass, ref staticCollidingAtFront, staticCollidingAtRear, deltaTime);
		if (disposed)
		{
			return trackSpeed;
		}
		owner = rearCollisionTrigger.owner;
		forwardVector = (owner.IsCoupledBackwards() ? (-((Component)owner).transform.forward) : ((Component)owner).transform.forward);
		trackSpeed = ApplyCollisions(trackSpeed, owner, forwardVector, atOurFront: false, rearCollisionTrigger, totalMass, ref staticCollidingAtRear, staticCollidingAtFront, deltaTime);
		if (disposed)
		{
			return trackSpeed;
		}
		Rigidbody val = null;
		foreach (KeyValuePair<Rigidbody, float> prevTrackSpeed in prevTrackSpeeds)
		{
			if ((Object)(object)prevTrackSpeed.Key == (Object)null || (!frontCollisionTrigger.otherRigidbodyContents.Contains(prevTrackSpeed.Key) && !rearCollisionTrigger.otherRigidbodyContents.Contains(prevTrackSpeed.Key)))
			{
				val = prevTrackSpeed.Key;
				break;
			}
		}
		if ((Object)(object)val != (Object)null)
		{
			prevTrackSpeeds.Remove(val);
		}
		return trackSpeed;
	}

	private float ApplyCollisions(float trackSpeed, TrainCar ourTrainCar, Vector3 forwardVector, bool atOurFront, TriggerTrainCollisions trigger, float ourTotalMass, ref StaticCollisionState wasStaticColliding, StaticCollisionState otherEndStaticColliding, float deltaTime)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = forwardVector * trackSpeed;
		bool flag = trigger.HasAnyStaticContents;
		if (atOurFront && ourTrainCar.FrontAtEndOfLine)
		{
			flag = true;
		}
		else if (!atOurFront && ourTrainCar.RearAtEndOfLine)
		{
			flag = true;
		}
		float num = (flag ? (((Vector3)(ref val)).magnitude * Mathf.Clamp(ourTotalMass, 1f, 13000f)) : 0f);
		trackSpeed = HandleStaticCollisions(flag, atOurFront, trackSpeed, ref wasStaticColliding, trigger);
		if (!flag && otherEndStaticColliding == StaticCollisionState.Free)
		{
			foreach (TrainCar trainContent in trigger.trainContents)
			{
				Vector3 val2 = ((Component)trainContent).transform.forward * trainContent.GetPrevTrackSpeed();
				trackSpeed = HandleTrainCollision(atOurFront, forwardVector, trackSpeed, ((Component)ourTrainCar).transform, trainContent, deltaTime, ref wasStaticColliding);
				num += Vector3.Magnitude(val2 - val) * Mathf.Clamp(trainContent.rigidBody.mass, 1f, 13000f);
			}
			foreach (Rigidbody otherRigidbodyContent in trigger.otherRigidbodyContents)
			{
				trackSpeed = HandleRigidbodyCollision(atOurFront, trackSpeed, forwardVector, ourTotalMass, otherRigidbodyContent, otherRigidbodyContent.velocity, otherRigidbodyContent.mass, deltaTime, calcSecondaryForces: true);
				num += Vector3.Magnitude(otherRigidbodyContent.velocity - val) * Mathf.Clamp(otherRigidbodyContent.mass, 1f, 13000f);
			}
		}
		if (num >= 70000f && TimeSince.op_Implicit(timeSinceLastChange) > 1f && trigger.owner.ApplyCollisionDamage(num) > 5f)
		{
			foreach (Collider colliderContent in trigger.colliderContents)
			{
				Vector3 contactPoint = colliderContent.ClosestPointOnBounds(((Component)trigger.owner).transform.position);
				trigger.owner.TryShowCollisionFX(contactPoint, trigger.owner.collisionEffect);
			}
		}
		return trackSpeed;
	}

	private float HandleStaticCollisions(bool staticColliding, bool front, float trackSpeed, ref StaticCollisionState wasStaticColliding, TriggerTrainCollisions trigger = null)
	{
		float num = (front ? (-5f) : 5f);
		if (staticColliding && (front ? (trackSpeed > num) : (trackSpeed < num)))
		{
			trackSpeed = num;
			wasStaticColliding = StaticCollisionState.StaticColliding;
			HashSet<GameObject> hashSet = (front ? monitoredStaticContentF : monitoredStaticContentR);
			hashSet.Clear();
			if ((Object)(object)trigger != (Object)null)
			{
				foreach (GameObject staticContent in trigger.staticContents)
				{
					hashSet.Add(staticContent);
				}
			}
		}
		else if (wasStaticColliding == StaticCollisionState.StaticColliding)
		{
			trackSpeed = 0f;
			wasStaticColliding = StaticCollisionState.StayingStill;
		}
		else if (wasStaticColliding == StaticCollisionState.StayingStill)
		{
			bool flag = (front ? (trackSpeed > 0.01f) : (trackSpeed < -0.01f));
			bool flag2 = false;
			if (!flag)
			{
				flag2 = (front ? (trackSpeed < -0.01f) : (trackSpeed > 0.01f));
			}
			if (flag)
			{
				HashSet<GameObject> hashSet2 = (front ? monitoredStaticContentF : monitoredStaticContentR);
				if (hashSet2.Count > 0)
				{
					bool flag3 = true;
					foreach (GameObject item in hashSet2)
					{
						if ((Object)(object)item != (Object)null)
						{
							flag3 = false;
							break;
						}
					}
					if (flag3)
					{
						flag = false;
					}
				}
			}
			if (flag)
			{
				trackSpeed = 0f;
			}
			else if (flag2)
			{
				wasStaticColliding = StaticCollisionState.Free;
			}
		}
		else if (front)
		{
			monitoredStaticContentF.Clear();
		}
		else
		{
			monitoredStaticContentR.Clear();
		}
		return trackSpeed;
	}

	private float HandleTrainCollision(bool front, Vector3 forwardVector, float trackSpeed, Transform ourTransform, TrainCar theirTrain, float deltaTime, ref StaticCollisionState wasStaticColliding)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = (front ? forwardVector : (-forwardVector));
		float num = Vector3.Angle(val, ((Component)theirTrain).transform.forward);
		Vector3 val2 = ((Component)theirTrain).transform.position - ourTransform.position;
		float num2 = Vector3.Dot(val, ((Vector3)(ref val2)).normalized);
		if ((num > 40f && num < 140f) || Mathf.Abs(num2) < 0.95f)
		{
			trackSpeed = (front ? (-0.5f) : 0.5f);
		}
		else
		{
			List<CompleteTrain> prevTrains = Pool.Get<List<CompleteTrain>>();
			float totalPushingMass = GetTotalPushingMass(val, forwardVector, ref prevTrains);
			trackSpeed = ((!(totalPushingMass < 0f)) ? HandleRigidbodyCollision(front, trackSpeed, forwardVector, TotalMass, theirTrain.rigidBody, theirTrain.GetLocalVelocityServer(), totalPushingMass, deltaTime, calcSecondaryForces: false) : HandleStaticCollisions(staticColliding: true, front, trackSpeed, ref wasStaticColliding));
			prevTrains.Clear();
			float nextTrainTrackSpeed;
			float num3 = GetTotalPushingForces(val, forwardVector, ref prevTrains, out nextTrainTrackSpeed);
			if (!front)
			{
				num3 *= -1f;
			}
			if ((front && num3 <= 0f) || (!front && num3 >= 0f))
			{
				float num4 = Mathf.Max(trackSpeed + 2f, nextTrainTrackSpeed + 2f);
				float num5 = Mathf.Min(trackSpeed - 2f, nextTrainTrackSpeed - 2f);
				trackSpeed += num3 / TotalMass * deltaTime;
				trackSpeed = Mathf.Clamp(trackSpeed, num5, num4);
			}
			Pool.FreeUnmanaged<CompleteTrain>(ref prevTrains);
		}
		return trackSpeed;
	}

	private float HandleRigidbodyCollision(bool atOurFront, float trackSpeed, Vector3 forwardVector, float ourTotalMass, Rigidbody theirRB, Vector3 theirVelocity, float theirTotalMass, float deltaTime, bool calcSecondaryForces)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		if (theirTotalMass < 500f)
		{
			return trackSpeed;
		}
		float num = Vector3.Dot(forwardVector, theirVelocity);
		float num2 = trackSpeed - num;
		if ((atOurFront && num2 <= 0f) || (!atOurFront && num2 >= 0f))
		{
			return trackSpeed;
		}
		float num3 = num2 / deltaTime * theirTotalMass * 0.75f;
		if (calcSecondaryForces)
		{
			if (prevTrackSpeeds.ContainsKey(theirRB))
			{
				float num4 = num2 / deltaTime * ourTotalMass * 0.75f / theirTotalMass * deltaTime;
				float num5 = prevTrackSpeeds[theirRB] - num;
				num3 -= Mathf.Clamp((num5 - num4) * ourTotalMass, 0f, 1000000f);
				prevTrackSpeeds[theirRB] = num;
			}
			else if (num != 0f)
			{
				prevTrackSpeeds.Add(theirRB, num);
			}
		}
		float num6 = num3 / ourTotalMass * deltaTime;
		num6 = Mathf.Clamp(num6, 0f - Mathf.Abs(num - trackSpeed) - 0.5f, Mathf.Abs(num - trackSpeed) + 0.5f);
		trackSpeed -= num6;
		return trackSpeed;
	}

	private float GetTotalPushingMass(Vector3 pushDirection, Vector3 ourForward, ref List<CompleteTrain> prevTrains)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		if (prevTrains.Count > 0)
		{
			if (prevTrains.Contains(this))
			{
				if (Global.developer > 1 || Application.isEditor)
				{
					Debug.LogWarning((object)"GetTotalPushingMass: Recursive loop detected. Bailing out.");
				}
				return 0f;
			}
			num += TotalMass;
		}
		prevTrains.Add(this);
		bool flag = Vector3.Dot(ourForward, pushDirection) >= 0f;
		if ((flag ? staticCollidingAtFront : staticCollidingAtRear) != 0)
		{
			return -1f;
		}
		TriggerTrainCollisions triggerTrainCollisions = (flag ? frontCollisionTrigger : rearCollisionTrigger);
		foreach (TrainCar trainContent in triggerTrainCollisions.trainContents)
		{
			if (trainContent.completeTrain != this)
			{
				Vector3 ourForward2 = (trainContent.IsCoupledBackwards() ? (-((Component)trainContent).transform.forward) : ((Component)trainContent).transform.forward);
				float totalPushingMass = trainContent.completeTrain.GetTotalPushingMass(pushDirection, ourForward2, ref prevTrains);
				if (totalPushingMass < 0f)
				{
					return -1f;
				}
				num += totalPushingMass;
			}
		}
		foreach (Rigidbody otherRigidbodyContent in triggerTrainCollisions.otherRigidbodyContents)
		{
			num += otherRigidbodyContent.mass;
		}
		return num;
	}

	private float GetTotalPushingForces(Vector3 pushDirection, Vector3 ourForward, ref List<CompleteTrain> prevTrains, out float nextTrainTrackSpeed)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		nextTrainTrackSpeed = 0f;
		if (prevTrains.Count > 0)
		{
			if (prevTrains.Contains(this))
			{
				if (Global.developer > 1 || Application.isEditor)
				{
					Debug.LogWarning((object)"GetTotalPushingForces: Recursive loop detected. Bailing out.");
				}
				return 0f;
			}
			num += TotalForces;
		}
		prevTrains.Add(this);
		bool num2 = Vector3.Dot(ourForward, pushDirection) >= 0f;
		TriggerTrainCollisions triggerTrainCollisions = (num2 ? frontCollisionTrigger : rearCollisionTrigger);
		if (!num2)
		{
			num *= -1f;
		}
		foreach (TrainCar trainContent in triggerTrainCollisions.trainContents)
		{
			if (trainContent.completeTrain != this)
			{
				Vector3 ourForward2 = (trainContent.IsCoupledBackwards() ? (-((Component)trainContent).transform.forward) : ((Component)trainContent).transform.forward);
				num += trainContent.completeTrain.GetTotalPushingForces(pushDirection, ourForward2, ref prevTrains, out var _);
				if (nextTrainTrackSpeed == 0f)
				{
					nextTrainTrackSpeed = trainContent.completeTrain.trackSpeed;
				}
			}
		}
		return num;
	}
}


private enum ShuntState
{
	None,
	Forwards,
	Backwards
}


public enum StaticCollisionState
{
	Free,
	StaticColliding,
	StayingStill
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class EngineDamageOverTime
{
	private struct RecentDamage
	{
		public readonly float time;

		public readonly float amount;

		public RecentDamage(float time, float amount)
		{
			this.time = time;
			this.amount = amount;
		}
	}

	private readonly List<RecentDamage> recentDamage = new List<RecentDamage>();

	private readonly float maxSeconds;

	private readonly float triggerDamage;

	private readonly Action trigger;

	public EngineDamageOverTime(float triggerDamage, float maxSeconds, Action trigger)
	{
		this.triggerDamage = triggerDamage;
		this.maxSeconds = maxSeconds;
		this.trigger = trigger;
	}

	public void TakeDamage(float amount)
	{
		recentDamage.Add(new RecentDamage(Time.time, amount));
		if (GetRecentDamage() > triggerDamage)
		{
			trigger();
			recentDamage.Clear();
		}
	}

	private float GetRecentDamage()
	{
		float num = 0f;
		int num2;
		for (num2 = this.recentDamage.Count - 1; num2 >= 0; num2--)
		{
			RecentDamage recentDamage = this.recentDamage[num2];
			if (Time.time > recentDamage.time + maxSeconds)
			{
				break;
			}
			num += recentDamage.amount;
		}
		if (num2 > 0)
		{
			this.recentDamage.RemoveRange(0, num2 + 1);
		}
		return num;
	}
}


private struct RecentDamage
{
	public readonly float time;

	public readonly float amount;

	public RecentDamage(float time, float amount)
	{
		this.time = time;
		this.amount = amount;
	}
}


using System;
using ConVar;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class HittableByTrains : EntityComponent<BaseCombatEntity>, ITrainCollidable, TrainTrackSpline.ITrainTrackUser, IOnParentDestroying, IOnParentSpawning
{
	[SerializeField]
	private float trainDamagePerMPS = 10f;

	[SerializeField]
	private float barricadeDamageMultiplier = 0.002f;

	[SerializeField]
	private float minVelToDestroy = 6f;

	[SerializeField]
	private float velReduction = 10f;

	[SerializeField]
	private GameObjectRef barricadeDamageEffect;

	private TrainCar hitTrain;

	private TriggerTrainCollisions hitTrainTrigger;

	private TrainTrackSpline track;

	public Vector3 Position => ((Component)this).transform.position;

	public float FrontWheelSplineDist { get; private set; }

	public TrainCar.TrainCarType CarType => TrainCar.TrainCarType.Other;

	public bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger)
	{
		bool result = false;
		if (base.baseEntity.isServer)
		{
			float num = Mathf.Abs(train.GetTrackSpeed());
			SetHitTrain(train, trainTrigger);
			if (num < minVelToDestroy && !vehicle.cinematictrains)
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)PushForceTick, 0f, 0.25f, 0.025f);
			}
			else
			{
				result = true;
				((FacepunchBehaviour)this).Invoke((Action)DestroyThisBarrier, 0f);
			}
		}
		return result;
	}

	public bool EqualNetID(BaseNetworkable other)
	{
		return base.baseEntity.EqualNetID(other);
	}

	public Vector3 GetWorldVelocity()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return base.baseEntity.GetWorldVelocity();
	}

	public void OnParentSpawning()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (TrainTrackSpline.TryFindTrackNear(((Component)this).transform.position, 5f, out var splineResult, out var distResult))
		{
			track = splineResult;
			FrontWheelSplineDist = distResult;
			track.RegisterTrackUser(this);
		}
	}

	public void OnParentDestroying()
	{
		if ((Object)(object)track != (Object)null)
		{
			track.DeregisterTrackUser(this);
		}
	}

	private void SetHitTrain(TrainCar train, TriggerTrainCollisions trainTrigger)
	{
		hitTrain = train;
		hitTrainTrigger = trainTrigger;
	}

	private void ClearHitTrain()
	{
		SetHitTrain(null, null);
	}

	private void DestroyThisBarrier()
	{
		if (base.baseEntity.IsDead() || base.baseEntity.IsDestroyed)
		{
			return;
		}
		if ((Object)(object)hitTrain != (Object)null)
		{
			hitTrain.completeTrain.ReduceSpeedBy(velReduction);
			if (vehicle.cinematictrains)
			{
				hitTrain.Hurt(9999f, DamageType.Collision, base.baseEntity, useProtection: false);
			}
			else
			{
				float amount = Mathf.Abs(hitTrain.GetTrackSpeed()) * trainDamagePerMPS;
				hitTrain.Hurt(amount, DamageType.Collision, base.baseEntity, useProtection: false);
			}
		}
		ClearHitTrain();
		base.baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
	}

	private void PushForceTick()
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)hitTrain == (Object)null || (Object)(object)hitTrainTrigger == (Object)null || hitTrain.IsDead() || hitTrain.IsDestroyed || base.baseEntity.IsDead() || !hitTrain.IsOn())
		{
			ClearHitTrain();
			((FacepunchBehaviour)this).CancelInvoke((Action)PushForceTick);
			return;
		}
		bool flag = true;
		Bounds bounds = hitTrainTrigger.triggerCollider.bounds;
		if (!((Bounds)(ref bounds)).Intersects(base.baseEntity.bounds))
		{
			Vector3 val = ((hitTrainTrigger.location != 0) ? hitTrainTrigger.owner.GetRearOfTrainPos() : hitTrainTrigger.owner.GetFrontOfTrainPos());
			flag = Vector3.SqrMagnitude(((Component)this).transform.position + ((Bounds)(ref base.baseEntity.bounds)).ClosestPoint(val - ((Component)this).transform.position) - val) < 2f;
		}
		if (flag)
		{
			float num = hitTrainTrigger.owner.completeTrain.TotalForces;
			if (hitTrainTrigger.location == TriggerTrainCollisions.Location.Rear)
			{
				num *= -1f;
			}
			num = Mathf.Max(0f, num);
			base.baseEntity.Hurt(num * barricadeDamageMultiplier, DamageType.Generic, hitTrain);
			if (base.baseEntity.IsDead())
			{
				hitTrain.completeTrain.FreeStaticCollision();
			}
		}
		else
		{
			ClearHitTrain();
			((FacepunchBehaviour)this).CancelInvoke((Action)PushForceTick);
		}
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		bool flag = base.baseEntity.lastAttacker is TrainCar;
		info.msg.simpleInt = Pool.Get<SimpleInt>();
		info.msg.simpleInt.value = (flag ? 1 : 0);
	}
}


public interface ITrainCollidable
{
	bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger);

	bool EqualNetID(BaseNetworkable other);
}


using UnityEngine;

public class LocomotiveExtraVisuals : MonoBehaviour
{
	[SerializeField]
	[Header("Gauges")]
	private TrainEngine trainEngine;

	[SerializeField]
	private Transform needleA;

	[SerializeField]
	private Transform needleB;

	[SerializeField]
	private Transform needleC;

	[SerializeField]
	private float maxAngle = 240f;

	[SerializeField]
	private float speedoMoveSpeed = 75f;

	[SerializeField]
	private float pressureMoveSpeed = 25f;

	[SerializeField]
	private float fanAcceleration = 50f;

	[SerializeField]
	private float fanMaxSpeed = 1000f;

	[SerializeField]
	private float speedoMax = 80f;

	[Header("Fans")]
	[SerializeField]
	private Transform[] engineFans;
}


using UnityEngine;

public class MountableParentCombatEntity : BaseCombatEntity
{
	private BaseMountable mountable;

	private BaseMountable Mountable
	{
		get
		{
			if ((Object)(object)mountable == (Object)null)
			{
				mountable = ((Component)this).GetComponentInParent<BaseMountable>();
			}
			return mountable;
		}
	}
}


using UnityEngine;

public class TrainCarAudio : MonoBehaviour
{
	[Header("Train Car Audio")]
	[SerializeField]
	private TrainCar trainCar;

	[SerializeField]
	private SoundDefinition movementStartDef;

	[SerializeField]
	private SoundDefinition movementStopDef;

	[SerializeField]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private AnimationCurve movementLoopGainCurve;

	[SerializeField]
	private float movementChangeOneshotDebounce = 1f;

	private Sound movementLoop;

	private SoundModulation.Modulator movementLoopGain;

	[SerializeField]
	private SoundDefinition turnLoopDef;

	private Sound turnLoop;

	[SerializeField]
	private SoundDefinition trackClatterLoopDef;

	[SerializeField]
	private AnimationCurve trackClatterGainCurve;

	[SerializeField]
	private AnimationCurve trackClatterPitchCurve;

	private Sound trackClatterLoop;

	private SoundModulation.Modulator trackClatterGain;

	private SoundModulation.Modulator trackClatterPitch;
}


using System;
using UnityEngine;

public class TrainCarFuelHatches : MonoBehaviour
{
	[SerializeField]
	private TrainCar owner;

	[SerializeField]
	private float animSpeed = 1f;

	[SerializeField]
	private Transform hatch1Col;

	[SerializeField]
	private Transform hatch1Vis;

	[SerializeField]
	private Transform hatch2Col;

	[SerializeField]
	private Transform hatch2Vis;

	[SerializeField]
	private Transform hatch3Col;

	[SerializeField]
	private Transform hatch3Vis;

	private const float closedXAngle = 0f;

	private const float openXAngle = -145f;

	[SerializeField]
	private SoundDefinition hatchOpenSoundDef;

	[SerializeField]
	private SoundDefinition hatchCloseSoundDef;

	private Vector3 _angles = Vector3.zero;

	private float _hatchLerp;

	private bool opening;

	private bool openingQueued;

	private bool isMoving;

	public void LinedUpStateChanged(bool linedUp)
	{
		openingQueued = linedUp;
		if (!isMoving)
		{
			opening = linedUp;
			_ = opening;
			isMoving = true;
			InvokeHandler.InvokeRepeating((Behaviour)(object)this, (Action)MoveTick, 0f, 0f);
		}
	}

	private void MoveTick()
	{
		if (opening)
		{
			_hatchLerp += Time.deltaTime * animSpeed;
			if (_hatchLerp >= 1f)
			{
				EndMove();
			}
			else
			{
				SetAngleOnAll(_hatchLerp, closing: false);
			}
		}
		else
		{
			_hatchLerp += Time.deltaTime * animSpeed;
			if (_hatchLerp >= 1f)
			{
				EndMove();
			}
			else
			{
				SetAngleOnAll(_hatchLerp, closing: true);
			}
		}
	}

	private void EndMove()
	{
		_hatchLerp = 0f;
		if (openingQueued == opening)
		{
			InvokeHandler.CancelInvoke((Behaviour)(object)this, (Action)MoveTick);
			isMoving = false;
		}
		else
		{
			opening = openingQueued;
		}
	}

	private void SetAngleOnAll(float lerpT, bool closing)
	{
		float angle;
		float angle2;
		float angle3;
		if (closing)
		{
			angle = LeanTween.easeOutBounce(-145f, 0f, Mathf.Clamp01(_hatchLerp * 1.15f));
			angle2 = LeanTween.easeOutBounce(-145f, 0f, _hatchLerp);
			angle3 = LeanTween.easeOutBounce(-145f, 0f, Mathf.Clamp01(_hatchLerp * 1.25f));
		}
		else
		{
			angle = LeanTween.easeOutBounce(0f, -145f, Mathf.Clamp01(_hatchLerp * 1.15f));
			angle2 = LeanTween.easeOutBounce(0f, -145f, _hatchLerp);
			angle3 = LeanTween.easeOutBounce(0f, -145f, Mathf.Clamp01(_hatchLerp * 1.25f));
		}
		SetAngle(hatch1Col, angle);
		SetAngle(hatch2Col, angle2);
		SetAngle(hatch3Col, angle3);
	}

	private void SetAngle(Transform transform, float angle)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		_angles.x = angle;
		transform.localEulerAngles = _angles;
	}
}


using System;
using Rust;
using UnityEngine;

public class TrainCarUnloadableLoot : TrainCarUnloadable
{
	[Serializable]
	public class LootCrateSet
	{
		public GameObjectRef[] crates;
	}

	[SerializeField]
	private LootCrateSet[] lootLayouts;

	[SerializeField]
	private Transform[] lootPositions;

	public override void Spawn()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (Application.isLoadingSave)
		{
			return;
		}
		int num = Random.Range(0, lootLayouts.Length);
		for (int i = 0; i < lootLayouts[num].crates.Length; i++)
		{
			GameObjectRef gameObjectRef = lootLayouts[num].crates[i];
			BaseEntity baseEntity = GameManager.server.CreateEntity(gameObjectRef.resourcePath, lootPositions[i].localPosition, lootPositions[i].localRotation);
			if ((Object)(object)baseEntity != (Object)null)
			{
				baseEntity.Spawn();
				baseEntity.SetParent(this);
			}
		}
	}
}


using System;

[Serializable]
public class LootCrateSet
{
	public GameObjectRef[] crates;
}


using Oxide.Core;
using UnityEngine;

public class TrainCoupling
{
	public readonly TrainCar owner;

	public readonly bool isFrontCoupling;

	public readonly TrainCouplingController controller;

	public readonly Transform couplingPoint;

	public readonly Transform couplingPivot;

	public readonly BaseEntity.Flags flag;

	public readonly bool isValid;

	public TimeSince timeSinceCouplingBlock;

	public bool IsCoupled => owner.HasFlag(flag);

	public bool IsUncoupled => !owner.HasFlag(flag);

	public TrainCoupling CoupledTo { get; private set; }

	public TrainCoupling(TrainCar owner, bool isFrontCoupling, TrainCouplingController controller)
		: this(owner, isFrontCoupling, controller, null, null, BaseEntity.Flags.Placeholder)
	{
	}

	public TrainCoupling(TrainCar owner, bool isFrontCoupling, TrainCouplingController controller, Transform couplingPoint, Transform couplingPivot, BaseEntity.Flags flag)
	{
		this.owner = owner;
		this.isFrontCoupling = isFrontCoupling;
		this.controller = controller;
		this.couplingPoint = couplingPoint;
		this.couplingPivot = couplingPivot;
		this.flag = flag;
		isValid = (Object)(object)couplingPoint != (Object)null;
	}

	public bool IsCoupledTo(TrainCar them)
	{
		if (CoupledTo != null)
		{
			return (Object)(object)CoupledTo.owner == (Object)(object)them;
		}
		return false;
	}

	public bool IsCoupledTo(TrainCoupling them)
	{
		if (CoupledTo != null)
		{
			return CoupledTo == them;
		}
		return false;
	}

	public bool TryCouple(TrainCoupling theirCoupling, bool reflect)
	{
		if (!isValid)
		{
			return false;
		}
		if (CoupledTo == theirCoupling)
		{
			return true;
		}
		if (IsCoupled)
		{
			return false;
		}
		object obj = Interface.CallHook("CanTrainCarCouple", (object)owner, (object)theirCoupling.owner);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (reflect && !theirCoupling.TryCouple(this, reflect: false))
		{
			return false;
		}
		CoupledTo = theirCoupling;
		owner.SetFlag(flag, b: true, recursive: false, networkupdate: false);
		owner.SendNetworkUpdate();
		return true;
	}

	public void Uncouple(bool reflect)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!IsUncoupled)
		{
			if (reflect && CoupledTo != null)
			{
				CoupledTo.Uncouple(reflect: false);
			}
			CoupledTo = null;
			owner.SetFlag(flag, b: false, recursive: false, networkupdate: false);
			owner.SendNetworkUpdate();
			timeSinceCouplingBlock = TimeSince.op_Implicit(0f);
		}
	}

	public TrainCoupling GetOppositeCoupling()
	{
		if (!isFrontCoupling)
		{
			return controller.frontCoupling;
		}
		return controller.rearCoupling;
	}

	public bool TryGetCoupledToID(out NetworkableId id)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (CoupledTo != null && (Object)(object)CoupledTo.owner != (Object)null && CoupledTo.owner.IsValid())
		{
			id = CoupledTo.owner.net.ID;
			return true;
		}
		id = default(NetworkableId);
		return false;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TrainCouplingController
{
	public const BaseEntity.Flags Flag_CouplingFront = BaseEntity.Flags.Reserved2;

	public const BaseEntity.Flags Flag_CouplingRear = BaseEntity.Flags.Reserved3;

	public readonly TrainCoupling frontCoupling;

	public readonly TrainCoupling rearCoupling;

	private readonly TrainCar owner;

	[ServerVar(Help = "Maximum difference in velocity for train cars to couple")]
	public static float max_couple_speed = 9f;

	public bool IsCoupled
	{
		get
		{
			if (!IsFrontCoupled)
			{
				return IsRearCoupled;
			}
			return true;
		}
	}

	public bool IsFrontCoupled => owner.HasFlag(BaseEntity.Flags.Reserved2);

	public bool IsRearCoupled => owner.HasFlag(BaseEntity.Flags.Reserved3);

	public TrainCouplingController(TrainCar owner)
	{
		this.owner = owner;
		frontCoupling = new TrainCoupling(owner, isFrontCoupling: true, this, owner.frontCoupling, owner.frontCouplingPivot, BaseEntity.Flags.Reserved2);
		rearCoupling = new TrainCoupling(owner, isFrontCoupling: false, this, owner.rearCoupling, owner.rearCouplingPivot, BaseEntity.Flags.Reserved3);
	}

	public bool IsCoupledTo(TrainCar them)
	{
		if (!frontCoupling.IsCoupledTo(them))
		{
			return rearCoupling.IsCoupledTo(them);
		}
		return true;
	}

	public bool TryCouple(TrainCar them, TriggerTrainCollisions.Location ourLocation)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		TrainCoupling trainCoupling = ((ourLocation == TriggerTrainCollisions.Location.Front) ? frontCoupling : rearCoupling);
		if (!trainCoupling.isValid)
		{
			return false;
		}
		if (trainCoupling.IsCoupled)
		{
			return false;
		}
		if (TimeSince.op_Implicit(trainCoupling.timeSinceCouplingBlock) < 1.5f)
		{
			return false;
		}
		if ((Object)(object)them == (Object)(object)owner)
		{
			return false;
		}
		float num = Vector3.Angle(((Component)owner).transform.forward, ((Component)them).transform.forward);
		if (num > 25f && num < 155f)
		{
			return false;
		}
		bool num2 = num < 90f;
		TrainCoupling trainCoupling2 = ((!num2) ? ((ourLocation == TriggerTrainCollisions.Location.Front) ? them.coupling.frontCoupling : them.coupling.rearCoupling) : ((ourLocation == TriggerTrainCollisions.Location.Front) ? them.coupling.rearCoupling : them.coupling.frontCoupling));
		float num3 = them.GetTrackSpeed();
		if (!num2)
		{
			num3 = 0f - num3;
		}
		if (Mathf.Abs(num3 - owner.GetTrackSpeed()) > max_couple_speed)
		{
			trainCoupling.timeSinceCouplingBlock = TimeSince.op_Implicit(0f);
			trainCoupling2.timeSinceCouplingBlock = TimeSince.op_Implicit(0f);
			return false;
		}
		if (!trainCoupling2.isValid)
		{
			return false;
		}
		if (Vector3.SqrMagnitude(trainCoupling.couplingPoint.position - trainCoupling2.couplingPoint.position) > 0.5f)
		{
			return false;
		}
		TrainTrackSpline frontTrackSection = owner.FrontTrackSection;
		TrainTrackSpline frontTrackSection2 = them.FrontTrackSection;
		if ((Object)(object)frontTrackSection2 != (Object)(object)frontTrackSection && !frontTrackSection.HasConnectedTrack(frontTrackSection2))
		{
			return false;
		}
		return trainCoupling.TryCouple(trainCoupling2, reflect: true);
	}

	public void Uncouple(bool front)
	{
		if (front)
		{
			frontCoupling.Uncouple(reflect: true);
		}
		else
		{
			rearCoupling.Uncouple(reflect: true);
		}
	}

	public void GetAll(ref List<TrainCar> result)
	{
		result.Add(owner);
		TrainCoupling coupledTo = rearCoupling.CoupledTo;
		while (coupledTo != null && coupledTo.IsCoupled && !result.Contains(coupledTo.owner))
		{
			result.Insert(0, coupledTo.owner);
			coupledTo = coupledTo.GetOppositeCoupling();
			coupledTo = coupledTo.CoupledTo;
		}
		TrainCoupling coupledTo2 = frontCoupling.CoupledTo;
		while (coupledTo2 != null && coupledTo2.IsCoupled && !result.Contains(coupledTo2.owner))
		{
			result.Add(coupledTo2.owner);
			coupledTo2 = coupledTo2.GetOppositeCoupling();
			coupledTo2 = coupledTo2.CoupledTo;
		}
	}
}


using System;
using UnityEngine;

public class TrainEngineAudio : TrainCarAudio
{
	[Serializable]
	public class EngineReflection
	{
		public Vector3 direction;

		public Vector3 offset;

		public SoundDefinition soundDef;

		public Sound sound;

		public SoundModulation.Modulator pitchMod;

		public SoundModulation.Modulator gainMod;

		public float distance = 20f;
	}

	[SerializeField]
	private TrainEngine trainEngine;

	[SerializeField]
	private Transform cockpitSoundPosition;

	[SerializeField]
	private Transform hornSoundPosition;

	[Header("Engine")]
	[SerializeField]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineActiveLoopDef;

	[SerializeField]
	private AnimationCurve engineActiveLoopPitchCurve;

	[SerializeField]
	private float engineActiveLoopChangeSpeed = 0.2f;

	private Sound engineActiveLoop;

	private SoundModulation.Modulator engineActiveLoopPitch;

	[SerializeField]
	private BlendedLoopEngineSound engineLoops;

	[SerializeField]
	private EngineReflection[] engineReflections;

	[SerializeField]
	private LayerMask reflectionLayerMask;

	[SerializeField]
	private float reflectionMaxDistance = 20f;

	[SerializeField]
	private float reflectionGainChangeSpeed = 10f;

	[SerializeField]
	private float reflectionPositionChangeSpeed = 10f;

	[SerializeField]
	private float reflectionRayOffset = 0.5f;

	[SerializeField]
	[Header("Horn")]
	private SoundDefinition hornLoop;

	[SerializeField]
	private SoundDefinition hornStart;

	[SerializeField]
	[Header("Other")]
	private SoundDefinition lightsToggleSound;

	[SerializeField]
	private SoundDefinition proximityAlertDef;

	private Sound proximityAlertSound;

	[SerializeField]
	private SoundDefinition damagedLoopDef;

	private Sound damagedLoop;

	[SerializeField]
	private SoundDefinition changeThrottleDef;

	[SerializeField]
	private SoundDefinition changeCouplingDef;

	[SerializeField]
	private SoundDefinition unloadableStartDef;

	[SerializeField]
	private SoundDefinition unloadableEndDef;

	[SerializeField]
	private GameObject bellObject;

	[SerializeField]
	private SoundDefinition bellRingDef;

	[SerializeField]
	private SoundPlayer brakeSound;
}


using System;
using UnityEngine;

[Serializable]
public class EngineReflection
{
	public Vector3 direction;

	public Vector3 offset;

	public SoundDefinition soundDef;

	public Sound sound;

	public SoundModulation.Modulator pitchMod;

	public SoundModulation.Modulator gainMod;

	public float distance = 20f;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class TrainTrackSpline : WorldSpline
{
	public enum TrackSelection
	{
		Default,
		Left,
		Right
	}

	public enum TrackPosition
	{
		Next,
		Prev
	}

	public enum TrackOrientation
	{
		Same,
		Reverse
	}

	public class ConnectedTrackInfo
	{
		public readonly TrainTrackSpline track;

		public readonly TrackOrientation orientation;

		public readonly float angle;

		public ConnectedTrackInfo(TrainTrackSpline track, TrackOrientation orientation, float angle)
		{
			this.track = track;
			this.orientation = orientation;
			this.angle = angle;
		}
	}

	public enum DistanceType
	{
		SplineDistance,
		WorldDistance
	}

	public interface ITrainTrackUser
	{
		Vector3 Position { get; }

		float FrontWheelSplineDist { get; }

		TrainCar.TrainCarType CarType { get; }

		Vector3 GetWorldVelocity();
	}

	public struct MoveRequest
	{
		public delegate MoveResult SplineAction(MoveResult result, MoveRequest request, TrainTrackSpline spline, float splineLength);

		public float distAlongSpline;

		public float maxMoveDist;

		public SplineAction onSpline;

		public TrackRequest trackRequest;

		public float totalDistMoved;

		public float ProjectEndDist(bool facingForward)
		{
			if (!facingForward)
			{
				return distAlongSpline - maxMoveDist;
			}
			return distAlongSpline + maxMoveDist;
		}

		public MoveRequest(float distAlongSpline, float maxMoveDist, SplineAction onSpline, TrackRequest trackRequest)
		{
			this.distAlongSpline = distAlongSpline;
			this.maxMoveDist = maxMoveDist;
			this.onSpline = onSpline;
			this.trackRequest = trackRequest;
			totalDistMoved = 0f;
		}
	}

	public struct TrackRequest
	{
		public TrackSelection trackSelection;

		public TrainTrackSpline preferredAltA;

		public TrainTrackSpline preferredAltB;

		public TrackRequest(TrackSelection trackSelection, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
		{
			this.trackSelection = trackSelection;
			this.preferredAltA = preferredAltA;
			this.preferredAltB = preferredAltB;
		}
	}

	public struct MoveResult
	{
		public TrainTrackSpline spline;

		public float distAlongSpline;

		public bool atEndOfLine;

		public TrainSignal signal;

		public float totalDistMoved;
	}

	[Tooltip("Is this track spline part of a train station?")]
	public bool isStation;

	[Tooltip("Can above-ground trains spawn here?")]
	public bool aboveGroundSpawn;

	public int hierarchy;

	public static List<TrainTrackSpline> SidingSplines = new List<TrainTrackSpline>();

	public readonly List<ConnectedTrackInfo> nextTracks = new List<ConnectedTrackInfo>();

	public int straightestNextIndex;

	public readonly List<ConnectedTrackInfo> prevTracks = new List<ConnectedTrackInfo>();

	public int straightestPrevIndex;

	[NonSerialized]
	public HashSet<ITrainTrackUser> trackUsers = new HashSet<ITrainTrackUser>();

	[NonSerialized]
	public HashSet<TrainSignal> signals = new HashSet<TrainSignal>();

	public bool HasNextTrack => nextTracks.Count > 0;

	public bool HasPrevTrack => prevTracks.Count > 0;

	public void SetAll(Vector3[] points, Vector3[] tangents, TrainTrackSpline sourceSpline)
	{
		base.points = points;
		base.tangents = tangents;
		lutInterval = sourceSpline.lutInterval;
		isStation = sourceSpline.isStation;
		aboveGroundSpawn = sourceSpline.aboveGroundSpawn;
		hierarchy = sourceSpline.hierarchy;
	}

	public MoveResult MoveAlongSpline(float prevSplineDist, Vector3 askerForward, float distMoved, TrackRequest tReq = default(TrackRequest), MoveRequest.SplineAction onSpline = null)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		MoveRequest request = new MoveRequest(prevSplineDist, distMoved, onSpline, tReq);
		bool facingForward = IsForward(askerForward, prevSplineDist);
		return MoveAlongSpline(request, facingForward, 0f);
	}

	private MoveResult MoveAlongSpline(MoveRequest request, bool facingForward, float prevDistMoved)
	{
		MoveResult moveResult = default(MoveResult);
		moveResult.totalDistMoved = prevDistMoved;
		MoveResult result = moveResult;
		WorldSplineData data = GetData();
		result.distAlongSpline = request.ProjectEndDist(facingForward);
		if (request.onSpline != null)
		{
			result = request.onSpline(result, request, this, data.Length);
		}
		result.spline = this;
		if (result.distAlongSpline < 0f)
		{
			result.totalDistMoved += request.distAlongSpline;
			result = MoveToPrevSpline(result, request, facingForward);
		}
		else if (result.distAlongSpline > data.Length)
		{
			result.totalDistMoved += data.Length - request.distAlongSpline;
			result = MoveToNextSpline(result, request, facingForward, data.Length);
		}
		else
		{
			result.totalDistMoved += Mathf.Abs(result.distAlongSpline - request.distAlongSpline);
		}
		return result;
	}

	private MoveResult MoveToNextSpline(MoveResult result, MoveRequest request, bool facingForward, float splineLength)
	{
		if (HasNextTrack)
		{
			ConnectedTrackInfo trackSelection = GetTrackSelection(nextTracks, straightestNextIndex, nextTrack: true, facingForward, request.trackRequest);
			request.maxMoveDist = (facingForward ? (result.distAlongSpline - splineLength) : (0f - (result.distAlongSpline - splineLength)));
			if (trackSelection.orientation == TrackOrientation.Same)
			{
				request.distAlongSpline = 0f;
			}
			else
			{
				request.distAlongSpline = trackSelection.track.GetLength();
				facingForward = !facingForward;
			}
			return trackSelection.track.MoveAlongSpline(request, facingForward, result.totalDistMoved);
		}
		result.atEndOfLine = true;
		result.distAlongSpline = splineLength;
		return result;
	}

	private MoveResult MoveToPrevSpline(MoveResult result, MoveRequest request, bool facingForward)
	{
		if (HasPrevTrack)
		{
			ConnectedTrackInfo trackSelection = GetTrackSelection(prevTracks, straightestPrevIndex, nextTrack: false, facingForward, request.trackRequest);
			request.maxMoveDist = (facingForward ? result.distAlongSpline : (0f - result.distAlongSpline));
			if (trackSelection.orientation == TrackOrientation.Same)
			{
				request.distAlongSpline = trackSelection.track.GetLength();
			}
			else
			{
				request.distAlongSpline = 0f;
				facingForward = !facingForward;
			}
			return trackSelection.track.MoveAlongSpline(request, facingForward, result.totalDistMoved);
		}
		result.atEndOfLine = true;
		result.distAlongSpline = 0f;
		return result;
	}

	public float GetDistance(Vector3 position, float maxError, out float minSplineDist)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		WorldSplineData data = GetData();
		float num = maxError * maxError;
		Vector3 val = ((Component)this).transform.InverseTransformPoint(position);
		float num2 = float.MaxValue;
		minSplineDist = 0f;
		int num3 = 0;
		int num4 = data.LUTValues.Count;
		if (data.Length > 40f)
		{
			for (int i = 0; (float)i < data.Length + 10f; i += 10)
			{
				float num5 = Vector3.SqrMagnitude(data.GetPointCubicHermite(i) - val);
				if (num5 < num2)
				{
					num2 = num5;
					minSplineDist = i;
				}
			}
			num3 = Mathf.FloorToInt(Mathf.Max(0f, minSplineDist - 10f + 1f));
			num4 = Mathf.CeilToInt(Mathf.Min((float)data.LUTValues.Count, minSplineDist + 10f - 1f));
		}
		for (int j = num3; j < num4; j++)
		{
			WorldSplineData.LUTEntry lUTEntry = data.LUTValues[j];
			for (int k = 0; k < lUTEntry.points.Count; k++)
			{
				WorldSplineData.LUTEntry.LUTPoint lUTPoint = lUTEntry.points[k];
				float num6 = Vector3.SqrMagnitude(lUTPoint.pos - val);
				if (num6 < num2)
				{
					num2 = num6;
					minSplineDist = lUTPoint.distance;
					if (num6 < num)
					{
						break;
					}
				}
			}
		}
		return Mathf.Sqrt(num2);
	}

	public float GetLength()
	{
		return GetData().Length;
	}

	public Vector3 GetPosition(float distance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return GetPointCubicHermiteWorld(distance);
	}

	public Vector3 GetPositionAndTangent(float distance, Vector3 askerForward, out Vector3 tangent)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pointAndTangentCubicHermiteWorld = GetPointAndTangentCubicHermiteWorld(distance, out tangent);
		if (Vector3.Dot(askerForward, tangent) < 0f)
		{
			tangent = -tangent;
		}
		return pointAndTangentCubicHermiteWorld;
	}

	public void AddTrackConnection(TrainTrackSpline track, TrackPosition p, TrackOrientation o)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		List<ConnectedTrackInfo> list = ((p == TrackPosition.Next) ? nextTracks : prevTracks);
		for (int i = 0; i < list.Count; i++)
		{
			if ((Object)(object)list[i].track == (Object)(object)track)
			{
				return;
			}
		}
		Vector3 val = ((p == TrackPosition.Next) ? points[points.Length - 2] : points[0]);
		Vector3 val2 = ((p == TrackPosition.Next) ? points[points.Length - 1] : points[1]);
		Vector3 val3 = ((Component)this).transform.TransformPoint(val2) - ((Component)this).transform.TransformPoint(val);
		Vector3 initialVector = GetInitialVector(track, p, o);
		float num = Vector3.SignedAngle(val3, initialVector, Vector3.up);
		int j;
		for (j = 0; j < list.Count && !(list[j].angle > num); j++)
		{
		}
		list.Insert(j, new ConnectedTrackInfo(track, o, num));
		int num2 = int.MaxValue;
		for (int k = 0; k < list.Count; k++)
		{
			num2 = Mathf.Min(num2, list[k].track.hierarchy);
		}
		float num3 = float.MaxValue;
		int num4 = 0;
		for (int l = 0; l < list.Count; l++)
		{
			ConnectedTrackInfo connectedTrackInfo = list[l];
			if (connectedTrackInfo.track.hierarchy > num2)
			{
				continue;
			}
			float num5 = Mathf.Abs(connectedTrackInfo.angle);
			if (num5 < num3)
			{
				num3 = num5;
				num4 = l;
				if (num3 == 0f)
				{
					break;
				}
			}
		}
		if (p == TrackPosition.Next)
		{
			straightestNextIndex = num4;
		}
		else
		{
			straightestPrevIndex = num4;
		}
	}

	public void RegisterTrackUser(ITrainTrackUser user)
	{
		trackUsers.Add(user);
	}

	public void DeregisterTrackUser(ITrainTrackUser user)
	{
		if (user != null)
		{
			trackUsers.Remove(user);
		}
	}

	public void RegisterSignal(TrainSignal signal)
	{
		signals.Add(signal);
	}

	public void DeregisterSignal(TrainSignal signal)
	{
		if (!((Object)(object)signal == (Object)null))
		{
			signals.Remove(signal);
		}
	}

	public bool IsForward(Vector3 askerForward, float askerSplineDist)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		WorldSplineData data = GetData();
		Vector3 tangentCubicHermiteWorld = GetTangentCubicHermiteWorld(askerSplineDist, data);
		return Vector3.Dot(askerForward, tangentCubicHermiteWorld) >= 0f;
	}

	public bool HasValidHazardWithin(TrainCar asker, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, float trackSpeed, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 askerForward = ((trackSpeed >= 0f) ? ((Component)asker).transform.forward : (-((Component)asker).transform.forward));
		bool movingForward = IsForward(askerForward, askerSplineDist);
		return HasValidHazardWithin(asker, askerForward, askerSplineDist, minHazardDist, maxHazardDist, trackSelection, movingForward, preferredAltA, preferredAltB);
	}

	public bool HasValidHazardWithin(ITrainTrackUser asker, Vector3 askerForward, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, bool movingForward, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		WorldSplineData data = GetData();
		foreach (ITrainTrackUser trackUser in trackUsers)
		{
			if (trackUser == asker)
			{
				continue;
			}
			Vector3 val = trackUser.Position - asker.Position;
			if (!(Vector3.Dot(askerForward, val) >= 0f))
			{
				continue;
			}
			float magnitude = ((Vector3)(ref val)).magnitude;
			if (magnitude > minHazardDist && magnitude < maxHazardDist)
			{
				Vector3 worldVelocity = trackUser.GetWorldVelocity();
				if (((Vector3)(ref worldVelocity)).sqrMagnitude < 4f || Vector3.Dot(worldVelocity, val) < 0f)
				{
					return true;
				}
			}
		}
		float num = (movingForward ? (askerSplineDist + minHazardDist) : (askerSplineDist - minHazardDist));
		float num2 = (movingForward ? (askerSplineDist + maxHazardDist) : (askerSplineDist - maxHazardDist));
		if (num2 < 0f)
		{
			if (HasPrevTrack)
			{
				ConnectedTrackInfo connectedTrackInfo = GetTrackSelection(request: new TrackRequest(trackSelection, preferredAltA, preferredAltB), trackOptions: prevTracks, straightestIndex: straightestPrevIndex, nextTrack: false, trainForward: movingForward);
				if (connectedTrackInfo.orientation == TrackOrientation.Same)
				{
					askerSplineDist = connectedTrackInfo.track.GetLength();
				}
				else
				{
					askerSplineDist = 0f;
					movingForward = !movingForward;
				}
				float minHazardDist2 = Mathf.Max(0f - num, 0f);
				float maxHazardDist2 = 0f - num2;
				return connectedTrackInfo.track.HasValidHazardWithin(asker, askerForward, askerSplineDist, minHazardDist2, maxHazardDist2, trackSelection, movingForward, preferredAltA, preferredAltB);
			}
		}
		else if (num2 > data.Length && HasNextTrack)
		{
			ConnectedTrackInfo connectedTrackInfo2 = GetTrackSelection(request: new TrackRequest(trackSelection, preferredAltA, preferredAltB), trackOptions: nextTracks, straightestIndex: straightestNextIndex, nextTrack: true, trainForward: movingForward);
			if (connectedTrackInfo2.orientation == TrackOrientation.Same)
			{
				askerSplineDist = 0f;
			}
			else
			{
				askerSplineDist = connectedTrackInfo2.track.GetLength();
				movingForward = !movingForward;
			}
			float minHazardDist3 = Mathf.Max(num - data.Length, 0f);
			float maxHazardDist3 = num2 - data.Length;
			return connectedTrackInfo2.track.HasValidHazardWithin(asker, askerForward, askerSplineDist, minHazardDist3, maxHazardDist3, trackSelection, movingForward, preferredAltA, preferredAltB);
		}
		return false;
	}

	public bool HasAnyUsers()
	{
		return trackUsers.Count > 0;
	}

	public bool HasAnyUsersOfType(TrainCar.TrainCarType carType)
	{
		foreach (ITrainTrackUser trackUser in trackUsers)
		{
			if (trackUser.CarType == carType)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasConnectedTrack(TrainTrackSpline tts)
	{
		if (!HasConnectedNextTrack(tts))
		{
			return HasConnectedPrevTrack(tts);
		}
		return true;
	}

	public bool HasConnectedNextTrack(TrainTrackSpline tts)
	{
		foreach (ConnectedTrackInfo nextTrack in nextTracks)
		{
			if ((Object)(object)nextTrack.track == (Object)(object)tts)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasConnectedPrevTrack(TrainTrackSpline tts)
	{
		foreach (ConnectedTrackInfo prevTrack in prevTracks)
		{
			if ((Object)(object)prevTrack.track == (Object)(object)tts)
			{
				return true;
			}
		}
		return false;
	}

	public static Vector3 GetInitialVector(TrainTrackSpline track, TrackPosition p, TrackOrientation o)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val;
		Vector3 val2;
		if (p == TrackPosition.Next)
		{
			if (o == TrackOrientation.Reverse)
			{
				val = track.points[track.points.Length - 1];
				val2 = track.points[track.points.Length - 2];
			}
			else
			{
				val = track.points[0];
				val2 = track.points[1];
			}
		}
		else if (o == TrackOrientation.Reverse)
		{
			val = track.points[1];
			val2 = track.points[0];
		}
		else
		{
			val = track.points[track.points.Length - 2];
			val2 = track.points[track.points.Length - 1];
		}
		return ((Component)track).transform.TransformPoint(val2) - ((Component)track).transform.TransformPoint(val);
	}

	protected override void OnDrawGizmosSelected()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		base.OnDrawGizmosSelected();
		for (int i = 0; i < nextTracks.Count; i++)
		{
			Color splineColour = Color.white;
			if (straightestNextIndex != i && nextTracks.Count > 1)
			{
				if (i == 0)
				{
					splineColour = Color.green;
				}
				else if (i == nextTracks.Count - 1)
				{
					splineColour = Color.yellow;
				}
			}
			WorldSpline.DrawSplineGizmo(nextTracks[i].track, splineColour);
		}
		for (int j = 0; j < prevTracks.Count; j++)
		{
			Color splineColour2 = Color.white;
			if (straightestPrevIndex != j && prevTracks.Count > 1)
			{
				if (j == 0)
				{
					splineColour2 = Color.green;
				}
				else if (j == nextTracks.Count - 1)
				{
					splineColour2 = Color.yellow;
				}
			}
			WorldSpline.DrawSplineGizmo(prevTracks[j].track, splineColour2);
		}
	}

	public ConnectedTrackInfo GetTrackSelection(List<ConnectedTrackInfo> trackOptions, int straightestIndex, bool nextTrack, bool trainForward, TrackRequest request)
	{
		if (trackOptions.Count == 1)
		{
			return trackOptions[0];
		}
		foreach (ConnectedTrackInfo trackOption in trackOptions)
		{
			if ((Object)(object)trackOption.track == (Object)(object)request.preferredAltA || (Object)(object)trackOption.track == (Object)(object)request.preferredAltB)
			{
				return trackOption;
			}
		}
		bool flag = nextTrack ^ trainForward;
		switch (request.trackSelection)
		{
		case TrackSelection.Left:
			if (!flag)
			{
				return trackOptions[0];
			}
			return trackOptions[trackOptions.Count - 1];
		case TrackSelection.Right:
			if (!flag)
			{
				return trackOptions[trackOptions.Count - 1];
			}
			return trackOptions[0];
		default:
			return trackOptions[straightestIndex];
		}
	}

	public static bool TryFindTrackNear(Vector3 pos, float maxDist, out TrainTrackSpline splineResult, out float distResult)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		splineResult = null;
		distResult = 0f;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(pos, maxDist, list, 65536, (QueryTriggerInteraction)1);
		if (list.Count > 0)
		{
			List<TrainTrackSpline> list2 = Pool.Get<List<TrainTrackSpline>>();
			float num = float.MaxValue;
			foreach (Collider item in list)
			{
				((Component)item).GetComponentsInParent<TrainTrackSpline>(false, list2);
				if (list2.Count <= 0)
				{
					continue;
				}
				foreach (TrainTrackSpline item2 in list2)
				{
					float minSplineDist;
					float distance = item2.GetDistance(pos, 1f, out minSplineDist);
					if (distance < num)
					{
						num = distance;
						distResult = minSplineDist;
						splineResult = item2;
					}
				}
			}
			Pool.FreeUnmanaged<TrainTrackSpline>(ref list2);
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return (Object)(object)splineResult != (Object)null;
	}
}


public enum TrackSelection
{
	Default,
	Left,
	Right
}


public enum TrackPosition
{
	Next,
	Prev
}


public enum TrackOrientation
{
	Same,
	Reverse
}


public class ConnectedTrackInfo
{
	public readonly TrainTrackSpline track;

	public readonly TrackOrientation orientation;

	public readonly float angle;

	public ConnectedTrackInfo(TrainTrackSpline track, TrackOrientation orientation, float angle)
	{
		this.track = track;
		this.orientation = orientation;
		this.angle = angle;
	}
}


public enum DistanceType
{
	SplineDistance,
	WorldDistance
}


using UnityEngine;

public interface ITrainTrackUser
{
	Vector3 Position { get; }

	float FrontWheelSplineDist { get; }

	TrainCar.TrainCarType CarType { get; }

	Vector3 GetWorldVelocity();
}


public struct MoveRequest
{
	public delegate MoveResult SplineAction(MoveResult result, MoveRequest request, TrainTrackSpline spline, float splineLength);

	public float distAlongSpline;

	public float maxMoveDist;

	public SplineAction onSpline;

	public TrackRequest trackRequest;

	public float totalDistMoved;

	public float ProjectEndDist(bool facingForward)
	{
		if (!facingForward)
		{
			return distAlongSpline - maxMoveDist;
		}
		return distAlongSpline + maxMoveDist;
	}

	public MoveRequest(float distAlongSpline, float maxMoveDist, SplineAction onSpline, TrackRequest trackRequest)
	{
		this.distAlongSpline = distAlongSpline;
		this.maxMoveDist = maxMoveDist;
		this.onSpline = onSpline;
		this.trackRequest = trackRequest;
		totalDistMoved = 0f;
	}
}


public delegate MoveResult SplineAction(MoveResult result, MoveRequest request, TrainTrackSpline spline, float splineLength);


public struct TrackRequest
{
	public TrackSelection trackSelection;

	public TrainTrackSpline preferredAltA;

	public TrainTrackSpline preferredAltB;

	public TrackRequest(TrackSelection trackSelection, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
	{
		this.trackSelection = trackSelection;
		this.preferredAltA = preferredAltA;
		this.preferredAltB = preferredAltB;
	}
}


public struct MoveResult
{
	public TrainTrackSpline spline;

	public float distAlongSpline;

	public bool atEndOfLine;

	public TrainSignal signal;

	public float totalDistMoved;
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Scriptable Object/Vehicles/Train Wagon Loot Data", fileName = "Train Wagon Loot Data")]
public class TrainWagonLootData : ScriptableObject
{
	[Serializable]
	public class LootOption
	{
		public bool showsFX = true;

		public ItemDefinition lootItem;

		[FormerlySerializedAs("lootAmount")]
		public int maxLootAmount;

		public int minLootAmount;

		public Material lootMaterial;

		public float spawnWeighting = 1f;

		public Color fxTint;

		[FormerlySerializedAs("indoorFXTint")]
		public Color particleFXTint;
	}

	[SerializeField]
	private LootOption[] oreOptions;

	[ReadOnly]
	[SerializeField]
	private LootOption lootWagonContent;

	[SerializeField]
	private LootOption fuelWagonContent;

	private static TrainWagonLootData _instance;

	private const int LOOT_WAGON_INDEX = 1000;

	private const int FUEL_WAGON_INDEX = 1001;

	public static TrainWagonLootData instance
	{
		get
		{
			if ((Object)(object)_instance == (Object)null)
			{
				_instance = Resources.Load<TrainWagonLootData>("Train Wagon Loot Data");
			}
			return _instance;
		}
	}

	public LootOption GetLootOption(TrainCarUnloadable.WagonType wagonType, out int index)
	{
		switch (wagonType)
		{
		case TrainCarUnloadable.WagonType.Lootboxes:
			index = 1000;
			return lootWagonContent;
		case TrainCarUnloadable.WagonType.Fuel:
			index = 1001;
			return fuelWagonContent;
		default:
		{
			float num = 0f;
			LootOption[] array = oreOptions;
			foreach (LootOption lootOption in array)
			{
				num += lootOption.spawnWeighting;
			}
			float num2 = Random.value * num;
			for (index = 0; index < oreOptions.Length; index++)
			{
				if ((num2 -= oreOptions[index].spawnWeighting) < 0f)
				{
					return oreOptions[index];
				}
			}
			return oreOptions[index];
		}
		}
	}

	public bool TryGetLootFromIndex(int index, out LootOption lootOption)
	{
		switch (index)
		{
		case 1000:
			lootOption = lootWagonContent;
			return true;
		case 1001:
			lootOption = fuelWagonContent;
			return true;
		default:
			index = Mathf.Clamp(index, 0, oreOptions.Length - 1);
			lootOption = oreOptions[index];
			return true;
		}
	}

	public bool TryGetIndexFromLoot(LootOption lootOption, out int index)
	{
		if (lootOption == lootWagonContent)
		{
			index = 1000;
			return true;
		}
		if (lootOption == fuelWagonContent)
		{
			index = 1001;
			return true;
		}
		for (index = 0; index < oreOptions.Length; index++)
		{
			if (oreOptions[index] == lootOption)
			{
				return true;
			}
		}
		index = -1;
		return false;
	}

	public static float GetOrePercent(int lootTypeIndex, StorageContainer sc)
	{
		if (instance.TryGetLootFromIndex(lootTypeIndex, out var lootOption))
		{
			return GetOrePercent(lootOption, sc);
		}
		return 0f;
	}

	public static void SetOrePercent(int lootTypeIndex, StorageContainer sc, float percent)
	{
		if (instance.TryGetLootFromIndex(lootTypeIndex, out var lootOption))
		{
			SetOrePercent(lootOption, sc, percent);
		}
	}

	public static float GetOrePercent(LootOption lootOption, StorageContainer sc)
	{
		float result = 0f;
		if (sc.IsValid())
		{
			int maxLootAmount = lootOption.maxLootAmount;
			result = (((float)maxLootAmount != 0f) ? Mathf.Clamp01((float)sc.inventory.GetAmount(lootOption.lootItem.itemid, onlyUsableAmounts: false) / (float)maxLootAmount) : 0f);
		}
		return result;
	}

	public static void SetOrePercent(LootOption lootOption, StorageContainer sc, float percent)
	{
		if (!sc.IsValid())
		{
			return;
		}
		int maxLootAmount = lootOption.maxLootAmount;
		if ((float)maxLootAmount > 0f)
		{
			Item item = sc.inventory.FindItemByItemID(lootOption.lootItem.itemid);
			if (item != null)
			{
				item.amount = Mathf.Max(Mathf.RoundToInt((float)maxLootAmount * percent), 1);
			}
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[Serializable]
public class LootOption
{
	public bool showsFX = true;

	public ItemDefinition lootItem;

	[FormerlySerializedAs("lootAmount")]
	public int maxLootAmount;

	public int minLootAmount;

	public Material lootMaterial;

	public float spawnWeighting = 1f;

	public Color fxTint;

	[FormerlySerializedAs("indoorFXTint")]
	public Color particleFXTint;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerTrainCollisions : TriggerBase
{
	public enum Location
	{
		Front,
		Rear
	}

	public Collider triggerCollider;

	public Location location;

	public TrainCar owner;

	[NonSerialized]
	public HashSet<GameObject> staticContents = new HashSet<GameObject>();

	[NonSerialized]
	public HashSet<TrainCar> trainContents = new HashSet<TrainCar>();

	[NonSerialized]
	public HashSet<Rigidbody> otherRigidbodyContents = new HashSet<Rigidbody>();

	[NonSerialized]
	public HashSet<Collider> colliderContents = new HashSet<Collider>();

	private const float TICK_RATE = 0.2f;

	public bool HasAnyStaticContents => staticContents.Count > 0;

	public bool HasAnyTrainContents => trainContents.Count > 0;

	public bool HasAnyOtherRigidbodyContents => otherRigidbodyContents.Count > 0;

	public bool HasAnyNonStaticContents
	{
		get
		{
			if (!HasAnyTrainContents)
			{
				return HasAnyOtherRigidbodyContents;
			}
			return true;
		}
	}

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		if (!owner.isServer)
		{
			return;
		}
		base.OnObjectAdded(obj, col);
		if ((Object)(object)obj != (Object)null)
		{
			BaseEntity baseEntity = obj.ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				Vector3 val = ((Component)baseEntity).transform.position + ((Component)baseEntity).transform.rotation * Vector3.Scale(obj.transform.lossyScale, ((Bounds)(ref baseEntity.bounds)).center);
				Bounds bounds = triggerCollider.bounds;
				Vector3 center = ((Bounds)(ref bounds)).center;
				Vector3 val2 = val - center;
				bool flag = Vector3.Dot(((Component)owner).transform.forward, val2) > 0f;
				if ((location == Location.Front && !flag) || (location == Location.Rear && flag))
				{
					return;
				}
			}
		}
		if ((Object)(object)obj != (Object)null)
		{
			Rigidbody componentInParent = obj.GetComponentInParent<Rigidbody>();
			if ((Object)(object)componentInParent != (Object)null)
			{
				TrainCar componentInParent2 = obj.GetComponentInParent<TrainCar>();
				if ((Object)(object)componentInParent2 != (Object)null && (Object)(object)componentInParent2 != (Object)(object)owner)
				{
					trainContents.Add(componentInParent2);
					if (owner.coupling != null)
					{
						owner.coupling.TryCouple(componentInParent2, location);
					}
					((FacepunchBehaviour)this).InvokeRepeating((Action)TrainContentsTick, 0.2f, 0.2f);
				}
				else
				{
					otherRigidbodyContents.Add(componentInParent);
				}
			}
			else
			{
				ITrainCollidable componentInParent3 = obj.GetComponentInParent<ITrainCollidable>();
				if (componentInParent3 == null)
				{
					if (!obj.CompareTag("Railway"))
					{
						staticContents.Add(obj);
					}
				}
				else if (!componentInParent3.EqualNetID(owner) && !componentInParent3.CustomCollision(owner, this))
				{
					staticContents.Add(obj);
				}
			}
		}
		if ((Object)(object)col != (Object)null)
		{
			colliderContents.Add(col);
		}
	}

	internal override void OnObjectRemoved(GameObject obj)
	{
		if (!owner.isServer || (Object)(object)obj == (Object)null)
		{
			return;
		}
		Collider[] components = obj.GetComponents<Collider>();
		foreach (Collider item in components)
		{
			colliderContents.Remove(item);
		}
		if (!staticContents.Remove(obj))
		{
			TrainCar componentInParent = obj.GetComponentInParent<TrainCar>();
			if ((Object)(object)componentInParent != (Object)null && (Object)(object)componentInParent != (Object)(object)owner)
			{
				if (!HasAnotherColliderFor<TrainCar>(componentInParent))
				{
					trainContents.Remove(componentInParent);
					if (trainContents == null || trainContents.Count == 0)
					{
						((FacepunchBehaviour)this).CancelInvoke((Action)TrainContentsTick);
					}
				}
			}
			else
			{
				Rigidbody componentInParent2 = obj.GetComponentInParent<Rigidbody>();
				if (!HasAnotherColliderFor<Rigidbody>(componentInParent2))
				{
					otherRigidbodyContents.Remove(componentInParent2);
				}
			}
		}
		base.OnObjectRemoved(obj);
		bool HasAnotherColliderFor<T>(T component) where T : Component
		{
			foreach (Collider colliderContent in colliderContents)
			{
				if ((Object)(object)colliderContent != (Object)null && (Object)(object)((Component)colliderContent).GetComponentInParent<T>() == (Object)(object)component)
				{
					return true;
				}
			}
			return false;
		}
	}

	private void TrainContentsTick()
	{
		if (trainContents == null)
		{
			return;
		}
		foreach (TrainCar trainContent in trainContents)
		{
			if (trainContent.IsValid() && !trainContent.IsDestroyed && owner.coupling != null)
			{
				owner.coupling.TryCouple(trainContent, location);
			}
		}
	}
}


public enum Location
{
	Front,
	Rear
}


using System;
using UnityEngine;

[Serializable]
public class VisualCarWheel : CarWheel
{
	public Transform visualWheel;

	public Transform visualWheelSteering;

	public bool visualPowerWheel = true;

	public ParticleSystem snowFX;

	public ParticleSystem sandFX;

	public ParticleSystem dirtFX;

	public ParticleSystem asphaltFX;

	public ParticleSystem waterFX;

	public ParticleSystem snowSpinFX;

	public ParticleSystem sandSpinFX;

	public ParticleSystem dirtSpinFX;

	public ParticleSystem asphaltSpinFX;
}


using UnityEngine;

public abstract class VehicleChassisVisuals<T> : MonoBehaviour where T : BaseEntity, VehicleChassisVisuals<T>.IClientWheelUser
{
	public interface IClientWheelUser
	{
		Vector3 Velocity { get; }

		float DriveWheelVelocity { get; }

		float SteerAngle { get; }

		float MaxSteerAngle { get; }

		float GetThrottleInput();
	}
}


using UnityEngine;

public interface IClientWheelUser
{
	Vector3 Velocity { get; }

	float DriveWheelVelocity { get; }

	float SteerAngle { get; }

	float MaxSteerAngle { get; }

	float GetThrottleInput();
}


using System;
using Rust;

public interface IEngineControllerUser : IEntity
{
	bool HasFlag(BaseEntity.Flags f);

	bool IsDead();

	void SetFlag(BaseEntity.Flags f, bool b, bool recursive = false, bool networkupdate = true);

	void Invoke(Action action, float time);

	void CancelInvoke(Action action);

	void OnEngineStartFailed();

	bool MeetsEngineRequirements();
}


using System;
using Oxide.Core;
using UnityEngine;

public class VehicleEngineController<TOwner> where TOwner : BaseMountable, IEngineControllerUser
{
	public enum EngineState
	{
		Off,
		Starting,
		On
	}

	public readonly TOwner owner;

	private readonly bool isServer;

	public readonly float engineStartupTime;

	public readonly Transform waterloggedPoint;

	public readonly BaseEntity.Flags engineStartingFlag;

	public EngineState CurEngineState
	{
		get
		{
			if (owner.HasFlag(engineStartingFlag))
			{
				return EngineState.Starting;
			}
			if (owner.HasFlag(BaseEntity.Flags.On))
			{
				return EngineState.On;
			}
			return EngineState.Off;
		}
	}

	public bool IsOn => CurEngineState == EngineState.On;

	public bool IsOff => CurEngineState == EngineState.Off;

	public bool IsStarting => CurEngineState == EngineState.Starting;

	public bool IsStartingOrOn => CurEngineState != EngineState.Off;

	public IFuelSystem FuelSystem { get; private set; }

	public VehicleEngineController(TOwner owner, IFuelSystem fuelSystem, bool isServer, float engineStartupTime, Transform waterloggedPoint = null, BaseEntity.Flags engineStartingFlag = BaseEntity.Flags.Reserved1)
	{
		FuelSystem = fuelSystem;
		this.owner = owner;
		this.isServer = isServer;
		this.engineStartupTime = engineStartupTime;
		this.waterloggedPoint = waterloggedPoint;
		this.engineStartingFlag = engineStartingFlag;
	}

	public EngineState EngineStateFrom(BaseEntity.Flags flags)
	{
		if (flags.HasFlag(engineStartingFlag))
		{
			return EngineState.Starting;
		}
		if (flags.HasFlag(BaseEntity.Flags.On))
		{
			return EngineState.On;
		}
		return EngineState.Off;
	}

	public bool IsWaterlogged()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)waterloggedPoint != (Object)null)
		{
			return WaterLevel.Test(waterloggedPoint.position, waves: true, volumes: true, owner);
		}
		return false;
	}

	public void TryStartEngine(BasePlayer player)
	{
		if (isServer && !owner.IsDead() && !IsStartingOrOn && player.net != null)
		{
			if (!CanRunEngine())
			{
				owner.OnEngineStartFailed();
			}
			else if (Interface.CallHook("OnEngineStart", (object)((VehicleEngineController<>)(object)this).owner, (object)player) == null)
			{
				owner.SetFlag(engineStartingFlag, b: true);
				owner.SetFlag(BaseEntity.Flags.On, b: false);
				((FacepunchBehaviour)owner).Invoke((Action)FinishStartingEngine, engineStartupTime);
				Interface.CallHook("OnEngineStarted", (object)((VehicleEngineController<>)(object)this).owner, (object)player);
			}
		}
	}

	public void FinishStartingEngine()
	{
		if (isServer && !owner.IsDead() && !IsOn)
		{
			owner.SetFlag(BaseEntity.Flags.On, b: true);
			owner.SetFlag(engineStartingFlag, b: false);
			Interface.CallHook("OnEngineStartFinished", (object)((VehicleEngineController<>)(object)this).owner);
		}
	}

	public void StopEngine()
	{
		if (isServer && !IsOff && Interface.CallHook("OnEngineStop", (object)((VehicleEngineController<>)(object)this).owner) == null)
		{
			CancelEngineStart();
			owner.SetFlag(BaseEntity.Flags.On, b: false);
			owner.SetFlag(engineStartingFlag, b: false);
			Interface.CallHook("OnEngineStopped", (object)((VehicleEngineController<>)(object)this).owner);
		}
	}

	public void CheckEngineState()
	{
		if (IsStartingOrOn && !CanRunEngine())
		{
			StopEngine();
		}
	}

	public bool CanRunEngine()
	{
		if (owner.MeetsEngineRequirements() && FuelSystem.HasFuel() && !IsWaterlogged())
		{
			return !owner.IsDead();
		}
		return false;
	}

	public int TickFuel(float fuelPerSecond)
	{
		if (IsOn)
		{
			return FuelSystem.TryUseFuel(Time.fixedDeltaTime, fuelPerSecond);
		}
		return 0;
	}

	public void UseFuel(int amount)
	{
		FuelSystem.RemoveFuel(amount);
	}

	public void CancelEngineStart()
	{
		if (CurEngineState == EngineState.Starting)
		{
			((FacepunchBehaviour)owner).CancelInvoke((Action)FinishStartingEngine);
		}
	}
}


public enum EngineState
{
	Off,
	Starting,
	On
}


using UnityEngine;

public class VehicleTerrainHandler
{
	public enum Surface
	{
		Default,
		Road,
		Snow,
		Ice,
		Sand,
		Frictionless
	}

	public string CurGroundPhysicsMatName;

	public Surface OnSurface;

	public bool IsGrounded;

	public float RayLength = 1.5f;

	private readonly string[] TerrainRoad = new string[5] { "rock", "concrete", "gravel", "metal", "path" };

	private const float SECONDS_BETWEEN_TERRAIN_SAMPLE = 0.25f;

	private TimeSince timeSinceTerrainCheck;

	private readonly BaseVehicle vehicle;

	public bool IsOnSnowOrIce
	{
		get
		{
			if (OnSurface != Surface.Snow)
			{
				return OnSurface == Surface.Ice;
			}
			return true;
		}
	}

	public VehicleTerrainHandler(BaseVehicle vehicle)
	{
		this.vehicle = vehicle;
	}

	public void FixedUpdate()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!vehicle.IsStationary() && TimeSince.op_Implicit(timeSinceTerrainCheck) > 0.25f)
		{
			DoTerrainCheck();
		}
	}

	private void DoTerrainCheck()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		timeSinceTerrainCheck = TimeSince.op_Implicit(Random.Range(-0.025f, 0.025f));
		Transform transform = ((Component)vehicle).transform;
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(transform.position + transform.up * 0.5f, -transform.up, ref val, RayLength, 161546241, (QueryTriggerInteraction)1))
		{
			CurGroundPhysicsMatName = ((RaycastHit)(ref val)).collider.GetMaterialAt(((RaycastHit)(ref val)).point).GetNameLower();
			if (GetOnRoad(CurGroundPhysicsMatName))
			{
				OnSurface = Surface.Road;
			}
			else if (CurGroundPhysicsMatName == "snow")
			{
				if (((Component)((RaycastHit)(ref val)).collider).CompareTag("TreatSnowAsIce"))
				{
					OnSurface = Surface.Ice;
				}
				else
				{
					OnSurface = Surface.Snow;
				}
			}
			else if (CurGroundPhysicsMatName == "sand")
			{
				OnSurface = Surface.Sand;
			}
			else if (CurGroundPhysicsMatName.Contains("zero friction"))
			{
				OnSurface = Surface.Frictionless;
			}
			else
			{
				OnSurface = Surface.Default;
			}
			IsGrounded = true;
		}
		else
		{
			CurGroundPhysicsMatName = "concrete";
			OnSurface = Surface.Default;
			IsGrounded = false;
		}
	}

	private bool GetOnRoad(string physicMat)
	{
		for (int i = 0; i < TerrainRoad.Length; i++)
		{
			if (TerrainRoad[i] == physicMat)
			{
				return true;
			}
		}
		return false;
	}
}


public enum Surface
{
	Default,
	Road,
	Snow,
	Ice,
	Sand,
	Frictionless
}


public interface IPoolVehicle
{
	void OnPoolDestroyed();

	void WakeUp();
}


public class DeployGuide : BaseMonoBehaviour
{
	public static DeployGuide current;
}


using UnityEngine;

public class DeployGuideRenderer : MonoBehaviour
{
	public BaseEntity Prefab;
}


using System;
using System.Linq;
using ConVar;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class DroppedItem : WorldItem, IContainerSounds, Hopper.IHopperTarget
{
	public enum DropReasonEnum
	{
		Unknown,
		Player,
		Death,
		Loot
	}

	public class DroppedItemUnderwaterQueue : PersistentObjectWorkQueue<DroppedItem>
	{
		protected override void RunJob(DroppedItem entity)
		{
			if ((Object)(object)entity != (Object)null)
			{
				entity.CheckUnderwaterStatus(canSplash: true);
			}
		}
	}

	[Header("DroppedItem")]
	public GameObjectRef itemModel;

	public GameObjectRef splashEffect;

	[ServerVar(Help = "How many milliseconds to spend on updating underwater drag levels")]
	public static float underwater_drag_budget_ms = 0.1f;

	private const Flags FLAG_STUCK = Flags.Reserved1;

	private const Flags FLAG_UNDERWATER = Flags.Reserved2;

	public const Flags FLAG_HOPPERANIMATING = Flags.Reserved3;

	private int originalLayer = -1;

	[NonSerialized]
	public DropReasonEnum DropReason;

	[NonSerialized]
	public ulong DroppedBy;

	[NonSerialized]
	public DateTime DroppedTime;

	[NonSerialized]
	public bool NeverCombine;

	private Rigidbody rB;

	private CollisionDetectionMode originalCollisionMode;

	private Vector3 prevLocalPos;

	private const float SLEEP_CHECK_FREQUENCY = 11f;

	private const float AIR_DRAG = 0.1f;

	private const float UNDERWATER_DRAG = 7f;

	private bool hasLastPos;

	private Vector3 lastGoodColliderCentre;

	private Vector3 lastGoodPos;

	private Quaternion lastGoodRot;

	private Action cachedSleepCheck;

	private float maxBoundsExtent;

	private readonly Vector3 smallVerticalOffset = new Vector3(0f, 0.05f, 0f);

	public static DroppedItemUnderwaterQueue underwaterStatusQueue = new DroppedItemUnderwaterQueue();

	private TimeSince lastUnderwaterFlowImpulse;

	public Collider childCollider { get; private set; }

	private bool StuckInSomething => HasFlag(Flags.Reserved1);

	public SoundDefinition OpenSound
	{
		get
		{
			if (item == null)
			{
				return null;
			}
			ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
			if ((Object)(object)component == (Object)null)
			{
				return null;
			}
			return component.openSound;
		}
	}

	public SoundDefinition CloseSound
	{
		get
		{
			if (item == null)
			{
				return null;
			}
			ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
			if ((Object)(object)component == (Object)null)
			{
				return null;
			}
			return component.closeSound;
		}
	}

	public Rigidbody Rigidbody => rB;

	public int NumberOfItemsToTransfer => 1 + ((item.contents != null) ? item.contents.itemList.Count() : 0);

	public float EndPositionToleranceMultiplier => 1f;

	public bool IsSleeping
	{
		get
		{
			if ((Object)(object)rB != (Object)null)
			{
				return rB.IsSleeping();
			}
			return false;
		}
	}

	public BaseEntity ToEntity => this;

	protected override bool CanBePickedUp => !HasFlag(Flags.Reserved3);

	public void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 itemFallbackPosition)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (item == null || itemContainer == null)
		{
			return;
		}
		if (item.contents != null && item.IsBackpack())
		{
			int capacity = item.contents.capacity;
			for (int i = 0; i < capacity; i++)
			{
				if (item.contents != null)
				{
					Item slot = item.contents.GetSlot(i);
					if (slot != null && !slot.MoveToContainer(itemContainer))
					{
						slot.DropAndTossUpwards(itemFallbackPosition);
					}
				}
			}
		}
		if (item != null)
		{
			if (item.MoveToContainer(itemContainer))
			{
				RemoveItem();
			}
			else
			{
				CancelHopper();
			}
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (GetDespawnDuration() < float.PositiveInfinity)
		{
			((FacepunchBehaviour)this).Invoke((Action)IdleDestroy, GetDespawnDuration());
		}
		ReceiveCollisionMessages(b: true);
		prevLocalPos = ((Component)this).transform.localPosition;
		((PersistentObjectWorkQueue<DroppedItem>)underwaterStatusQueue).Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		((PersistentObjectWorkQueue<DroppedItem>)underwaterStatusQueue).Remove(this);
	}

	public virtual float GetDespawnDuration()
	{
		return item?.GetDespawnDuration() ?? Server.itemdespawn;
	}

	public void IdleDestroy()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		Interface.CallHook("OnItemDespawn", (object)item);
		Analytics.Azure.OnItemDespawn(this, item, (int)DropReason, DroppedBy);
		if (item != null)
		{
			BuriedItems.Instance.Register(item, ((Component)this).transform.position);
		}
		DestroyItem();
		Kill();
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (item != null && item.MaxStackable() > 1)
		{
			DroppedItem droppedItem = hitEntity as DroppedItem;
			if (!((Object)(object)droppedItem == (Object)null) && droppedItem.item != null && !((Object)(object)droppedItem.item.info != (Object)(object)item.info) && droppedItem.item.skin == item.skin)
			{
				droppedItem.OnDroppedOn(this);
			}
		}
	}

	public void OnDroppedOn(DroppedItem di)
	{
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", (object)this, (object)di) != null || (Object)(object)di.item.info != (Object)(object)item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if ((Object)(object)di.item.info != (Object)null)
		{
			if (di.item.info.amountType == ItemDefinition.AmountType.Genetics)
			{
				int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
				int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
				if (num != num2)
				{
					return;
				}
			}
			if (((Object)(object)((Component)di.item.info).GetComponent<ItemModSign>() != (Object)null && (Object)(object)ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != (Object)null) || ((Object)(object)item.info != (Object)null && (Object)(object)((Component)item.info).GetComponent<ItemModSign>() != (Object)null && (Object)(object)ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != (Object)null))
			{
				return;
			}
		}
		if (Item.BlockStackFoodItem(item, di.item))
		{
			return;
		}
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.MaxStackable() && num3 != 0)
		{
			Interface.CallHook("OnDroppedItemCombined", (object)this);
			if (di.DropReason == DropReasonEnum.Player)
			{
				DropReason = DropReasonEnum.Player;
			}
			di.item.MigrateItemOwnership(item, di.item.amount);
			di.DestroyItem();
			di.Kill();
			int worldModelIndex = item.info.GetWorldModelIndex(item.amount);
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				((FacepunchBehaviour)this).Invoke((Action)IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			int worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);
			if (worldModelIndex != worldModelIndex2)
			{
				item.Drop(((Component)this).transform.position, Vector3.zero, ((Component)this).transform.rotation);
			}
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		if ((Object)(object)newParent != (Object)null && (Object)(object)newParent != (Object)(object)oldParent)
		{
			OnParented();
		}
		else if ((Object)(object)newParent == (Object)null && (Object)(object)oldParent != (Object)null)
		{
			OnUnparented();
		}
	}

	internal override void OnParentRemoved()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rB == (Object)null)
		{
			base.OnParentRemoved();
			return;
		}
		Vector3 val = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		SetParent(null);
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val + Vector3.up * 2f, Vector3.down, ref val2, 2f, 161546240) && val.y < ((RaycastHit)(ref val2)).point.y)
		{
			val += Vector3.up * 1.5f;
		}
		((Component)this).transform.position = val;
		((Component)this).transform.rotation = rotation;
		Unstick();
		if (GetDespawnDuration() < float.PositiveInfinity)
		{
			((FacepunchBehaviour)this).Invoke((Action)IdleDestroy, GetDespawnDuration());
		}
	}

	public void StickIn()
	{
		SetFlag(Flags.Reserved1, b: true);
	}

	public void Unstick()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	private void SleepCheck()
	{
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (!HasParent() || StuckInSomething)
		{
			return;
		}
		if (rB.isKinematic)
		{
			if (maxBoundsExtent == 0f)
			{
				float num;
				if (!((Object)(object)childCollider != (Object)null))
				{
					num = Vector3Ex.Max(((Bounds)(ref bounds)).extents);
				}
				else
				{
					Bounds val = childCollider.bounds;
					num = Vector3Ex.Max(((Bounds)(ref val)).extents);
				}
				maxBoundsExtent = num;
			}
			if (!GamePhysics.Trace(new Ray(CenterPoint(), Vector3.down), 0f, out var _, maxBoundsExtent + 0.1f, -928830719, (QueryTriggerInteraction)1, this))
			{
				BecomeActive();
			}
		}
		else if (Vector3.SqrMagnitude(((Component)this).transform.localPosition - prevLocalPos) < 0.075f)
		{
			BecomeInactive();
		}
		prevLocalPos = ((Component)this).transform.localPosition;
	}

	private void OnPhysicsNeighbourChanged()
	{
		if (!StuckInSomething)
		{
			BecomeActive();
		}
	}

	public override void OnPositionalNetworkUpdate()
	{
		base.OnPositionalNetworkUpdate();
		if (!HasFlag(Flags.Reserved3))
		{
			CheckValidPosition();
		}
	}

	protected override bool ShouldUpdateNetworkPosition()
	{
		if (syncPosition)
		{
			return !rB.isKinematic;
		}
		return false;
	}

	private void CheckValidPosition()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)rB != (Object)null) || !((Object)(object)childCollider != (Object)null))
		{
			return;
		}
		Bounds val = childCollider.bounds;
		Vector3 val2 = ((Bounds)(ref val)).center + smallVerticalOffset;
		Vector3 val3 = val2 - lastGoodColliderCentre;
		Ray ray = default(Ray);
		((Ray)(ref ray))..ctor(lastGoodColliderCentre, ((Vector3)(ref val3)).normalized);
		if (hasLastPos && GamePhysics.Trace(ray, 0f, out var _, ((Vector3)(ref val3)).magnitude, 1218511105, (QueryTriggerInteraction)1, this))
		{
			((Component)this).transform.position = lastGoodPos + smallVerticalOffset;
			((Component)this).transform.rotation = lastGoodRot;
			if (!rB.isKinematic)
			{
				rB.velocity = Vector3.zero;
				rB.angularVelocity = Vector3.zero;
			}
			Physics.SyncTransforms();
		}
		else
		{
			lastGoodColliderCentre = val2;
			lastGoodPos = ((Component)this).transform.position;
			lastGoodRot = ((Component)this).transform.rotation;
			hasLastPos = true;
		}
	}

	public void PrepareForHopper()
	{
		SetFlag(Flags.Reserved3, b: true);
		if ((Object)(object)childCollider != (Object)null)
		{
			childCollider.enabled = false;
		}
	}

	public void HopperCancelled()
	{
		SetFlag(Flags.Reserved3, b: false);
		if ((Object)(object)childCollider != (Object)null)
		{
			childCollider.enabled = true;
		}
	}

	public void CancelHopper()
	{
		SetFlag(Flags.Reserved3, b: false);
		if ((Object)(object)Rigidbody != (Object)null)
		{
			Rigidbody.useGravity = true;
		}
		if ((Object)(object)childCollider != (Object)null)
		{
			childCollider.enabled = true;
		}
	}

	private void OnUnparented()
	{
		if (cachedSleepCheck != null)
		{
			((FacepunchBehaviour)this).CancelInvoke(cachedSleepCheck);
		}
	}

	private void OnParented()
	{
		if ((Object)(object)childCollider == (Object)null)
		{
			return;
		}
		if (Object.op_Implicit((Object)(object)childCollider))
		{
			childCollider.enabled = false;
			((FacepunchBehaviour)this).Invoke((Action)EnableCollider, 0.1f);
		}
		if (base.isServer && !StuckInSomething)
		{
			if (cachedSleepCheck == null)
			{
				cachedSleepCheck = SleepCheck;
			}
			((FacepunchBehaviour)this).InvokeRandomized(cachedSleepCheck, 5.5f, 11f, Random.Range(-1.1f, 1.1f));
		}
	}

	public override void PostInitShared()
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		base.PostInitShared();
		GameObject val = null;
		if (item != null && item.GetWorldModel().isValid)
		{
			val = base.gameManager.CreatePrefab(item.GetWorldModel().resourcePath, ((Component)this).transform);
			val.transform.localScale = item.GetWorldModel().Get().transform.localScale;
		}
		else
		{
			val = base.gameManager.CreatePrefab(itemModel.resourcePath, ((Component)this).transform);
		}
		val.transform.localPosition = Vector3.zero;
		val.transform.localRotation = Quaternion.identity;
		val.SetLayerRecursive(((Component)this).gameObject.layer);
		childCollider = val.GetComponentInChildren<Collider>();
		if (Object.op_Implicit((Object)(object)childCollider))
		{
			childCollider.enabled = false;
			if (HasParent())
			{
				OnParented();
			}
			else
			{
				childCollider.enabled = true;
			}
			originalLayer = ((Component)childCollider).gameObject.layer;
		}
		if (base.isServer)
		{
			float angularDrag = 0.1f;
			rB = ((Component)this).gameObject.AddComponent<Rigidbody>();
			UpdateItemMass();
			rB.drag = 0.1f;
			rB.angularDrag = angularDrag;
			rB.interpolation = (RigidbodyInterpolation)0;
			rB.collisionDetectionMode = (CollisionDetectionMode)3;
			originalCollisionMode = rB.collisionDetectionMode;
			rB.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
			CheckValidPosition();
			CheckUnderwaterStatus(canSplash: false);
			UpdateUnderwaterDrag();
		}
		if (item != null)
		{
			PhysicsEffects component = ((Component)this).gameObject.GetComponent<PhysicsEffects>();
			if ((Object)(object)component != (Object)null)
			{
				component.entity = this;
				if ((Object)(object)item.info.physImpactSoundDef != (Object)null)
				{
					component.physImpactSoundDef = item.info.physImpactSoundDef;
				}
			}
			Buoyancy component2 = val.GetComponent<Buoyancy>();
			if ((Object)(object)component2 != (Object)null && base.isServer)
			{
				component2.rigidBody = rB;
			}
		}
		val.SetActive(true);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!old.HasFlag(Flags.Reserved1) && next.HasFlag(Flags.Reserved1))
		{
			BecomeInactive();
		}
		else if (old.HasFlag(Flags.Reserved1) && !next.HasFlag(Flags.Reserved1))
		{
			BecomeActive();
		}
		if (base.isServer && old.HasFlag(Flags.Reserved2) != next.HasFlag(Flags.Reserved2))
		{
			UpdateUnderwaterDrag();
		}
	}

	private void BecomeActive()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			rB.isKinematic = false;
			rB.collisionDetectionMode = originalCollisionMode;
			rB.WakeUp();
			if (HasParent())
			{
				Rigidbody component = ((Component)GetParentEntity()).GetComponent<Rigidbody>();
				if ((Object)(object)component != (Object)null)
				{
					rB.velocity = component.velocity;
					rB.angularVelocity = component.angularVelocity;
				}
			}
			prevLocalPos = ((Component)this).transform.localPosition;
		}
		if ((Object)(object)childCollider != (Object)null)
		{
			((Component)childCollider).gameObject.layer = originalLayer;
		}
	}

	private void BecomeInactive()
	{
		if (base.isServer)
		{
			rB.collisionDetectionMode = (CollisionDetectionMode)0;
			rB.isKinematic = true;
		}
		if ((Object)(object)childCollider != (Object)null)
		{
			((Component)childCollider).gameObject.layer = 19;
		}
	}

	private void EnableCollider()
	{
		if (Object.op_Implicit((Object)(object)childCollider))
		{
			childCollider.enabled = true;
		}
	}

	public void UpdateItemMass()
	{
		if ((Object)(object)rB == (Object)null)
		{
			rB = ((Component)this).GetComponent<Rigidbody>();
		}
		if ((Object)(object)rB == (Object)null || item == null || item.contents?.itemList == null)
		{
			return;
		}
		float num = item.info.GetWorldModelMass();
		ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
		if ((Object)(object)component != (Object)null)
		{
			_ = component.worldWeightScale;
		}
		foreach (Item item in item.contents.itemList)
		{
			num += item.info.GetWorldModelMass() * component.worldWeightScale;
		}
		if ((Object)(object)component != (Object)null && component.maxWeight > 0f)
		{
			num = Mathf.Min(component.maxWeight, num);
		}
		rB.mass = num;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved3, b: false);
	}

	public override bool ShouldInheritNetworkGroup()
	{
		return false;
	}

	private void CheckUnderwaterStatus(bool canSplash)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		bool flag = WaterLevel.Test(((Component)this).transform.position, waves: false, volumes: true, this);
		if (canSplash && flag && !HasFlag(Flags.Reserved2) && splashEffect.isValid)
		{
			Effect.server.Run(splashEffect.resourcePath, ((Component)this).transform.position, Vector3.zero);
		}
		SetFlag(Flags.Reserved2, flag);
		if (flag && (Object)(object)rB != (Object)null && !rB.IsSleeping() && TimeSince.op_Implicit(lastUnderwaterFlowImpulse) > 1f)
		{
			lastUnderwaterFlowImpulse = TimeSince.op_Implicit(0f - Random.Range(0f, 1f));
			rB.AddForceAtPosition(Random.onUnitSphere, ((Component)this).transform.position + Random.onUnitSphere * 3f, (ForceMode)1);
		}
	}

	private void UpdateUnderwaterDrag()
	{
		if ((Object)(object)rB != (Object)null)
		{
			rB.drag = (HasFlag(Flags.Reserved2) ? 7f : 0.1f);
		}
	}
}


public enum DropReasonEnum
{
	Unknown,
	Player,
	Death,
	Loot
}


using UnityEngine;

public class DroppedItemUnderwaterQueue : PersistentObjectWorkQueue<DroppedItem>
{
	protected override void RunJob(DroppedItem entity)
	{
		if ((Object)(object)entity != (Object)null)
		{
			entity.CheckUnderwaterStatus(canSplash: true);
		}
	}
}


using Rust;

public class ItemPickup : DroppedItem
{
	public ItemDefinition itemDef;

	public int amount = 1;

	public ulong skinOverride;

	public override float GetDespawnDuration()
	{
		return float.PositiveInfinity;
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			Item item = ItemManager.Create(itemDef, amount, skinOverride);
			InitializeItem(item);
			item.SetWorldEntity(this);
		}
	}

	internal override void DoServerDestroy()
	{
		if (item != null)
		{
			item.Remove();
			item = null;
		}
		base.DoServerDestroy();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		IdleDestroy();
	}

	public override void TryApplyOwnershipOnPickup(BasePlayer player, Item item)
	{
		item.SetItemOwnership(player, ItemOwnershipPhrases.LootedPhrase);
	}
}


using UnityEngine;

public class ANDSwitch : IOEntity
{
	private int input1Amount;

	private int input2Amount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		if (input1Amount == 0 || input2Amount == 0)
		{
			return false;
		}
		if (input1Amount == input2Amount)
		{
			return inputIndex == 0;
		}
		int num = ((input1Amount <= input2Amount) ? 1 : 0);
		return inputIndex == num;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (input1Amount <= 0 || input2Amount <= 0)
		{
			return 0;
		}
		return Mathf.Max(input1Amount, input2Amount);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		switch (slot)
		{
		case 0:
			input1Amount = inputAmount;
			break;
		case 1:
			input2Amount = inputAmount;
			break;
		}
		int num = ((input1Amount > 0 && input2Amount > 0) ? (input1Amount + input2Amount) : 0);
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 && input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
		base.UpdateFromInput(inputAmount, slot);
	}
}


public interface ISubscribable
{
	bool AddSubscription(ulong steamId);

	bool RemoveSubscription(ulong steamId);

	bool HasSubscription(ulong steamId);
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class StorageMonitor : AppIOEntity
{
	public readonly Action<Item, bool> _onItemAddedRemoved;

	private readonly Action<Item, int> _onItemAddedToStack;

	private readonly Action<Item, int> _onItemRemovedFromStack;

	private readonly Action _resetSwitchHandler;

	private double _lastPowerOnUpdate;

	public override AppEntityType Type => (AppEntityType)3;

	public override bool Value
	{
		get
		{
			return IsOn();
		}
		set
		{
		}
	}

	public StorageMonitor()
	{
		_onItemAddedRemoved = OnItemAddedRemoved;
		_onItemAddedToStack = OnItemAddedToStack;
		_onItemRemovedFromStack = OnItemRemovedFromStack;
		_resetSwitchHandler = ResetSwitch;
	}

	internal override void FillEntityPayload(AppEntityPayload payload)
	{
		base.FillEntityPayload(payload);
		StorageContainer storageContainer = GetStorageContainer();
		ContainerIOEntity containerIOEntity = GetContainerIOEntity();
		if (((Object)(object)storageContainer == (Object)null && (Object)(object)containerIOEntity == (Object)null) || !HasFlag(Flags.Reserved8))
		{
			return;
		}
		payload.items = Pool.Get<List<Item>>();
		ItemContainer inventory = GetInventory();
		if (inventory == null)
		{
			return;
		}
		foreach (Item item in inventory.itemList)
		{
			Item val = Pool.Get<Item>();
			val.itemId = (item.IsBlueprint() ? item.blueprintTargetDef.itemid : item.info.itemid);
			val.quantity = item.amount;
			val.itemIsBlueprint = item.IsBlueprint();
			payload.items.Add(val);
		}
		payload.capacity = inventory.capacity;
		if ((Object)(object)storageContainer != (Object)null && storageContainer is BuildingPrivlidge buildingPrivlidge)
		{
			payload.hasProtection = true;
			float protectedMinutes = buildingPrivlidge.GetProtectedMinutes();
			if (protectedMinutes > 0f)
			{
				payload.protectionExpiry = (uint)DateTimeOffset.UtcNow.AddMinutes(protectedMinutes).ToUnixTimeSeconds();
			}
		}
	}

	public override void Init()
	{
		base.Init();
		ItemContainer inventory = GetInventory();
		if (inventory != null)
		{
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, _onItemAddedRemoved);
			inventory.onItemAddedToStack = (Action<Item, int>)Delegate.Combine(inventory.onItemAddedToStack, _onItemAddedToStack);
			inventory.onItemRemovedFromStack = (Action<Item, int>)Delegate.Combine(inventory.onItemRemovedFromStack, _onItemRemovedFromStack);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		ItemContainer inventory = GetInventory();
		if (inventory != null)
		{
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Remove(inventory.onItemAddedRemoved, _onItemAddedRemoved);
			inventory.onItemAddedToStack = (Action<Item, int>)Delegate.Remove(inventory.onItemAddedToStack, _onItemAddedToStack);
			inventory.onItemRemovedFromStack = (Action<Item, int>)Delegate.Remove(inventory.onItemRemovedFromStack, _onItemRemovedFromStack);
		}
	}

	private StorageContainer GetStorageContainer()
	{
		return GetParentEntity() as StorageContainer;
	}

	private ContainerIOEntity GetContainerIOEntity()
	{
		return GetParentEntity() as ContainerIOEntity;
	}

	private ItemContainer GetInventory()
	{
		StorageContainer storageContainer = GetStorageContainer();
		ContainerIOEntity containerIOEntity = GetContainerIOEntity();
		if ((Object)(object)storageContainer == (Object)null && (Object)(object)containerIOEntity != (Object)null && containerIOEntity.inventory != null)
		{
			return containerIOEntity.inventory;
		}
		if ((Object)(object)storageContainer != (Object)null && storageContainer.inventory != null && (Object)(object)containerIOEntity == (Object)null)
		{
			return storageContainer.inventory;
		}
		return null;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		switch (outputSlot)
		{
		case 0:
			if (!IsOn())
			{
				return 0;
			}
			return Mathf.Min(1, GetCurrentEnergy());
		case 1:
		{
			int num = GetCurrentEnergy();
			if (!IsOn())
			{
				return num;
			}
			return num - 1;
		}
		default:
			return 0;
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		bool flag = HasFlag(Flags.Reserved8);
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputSlot == 0)
		{
			bool num = inputAmount >= ConsumptionAmount();
			double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
			if (num && !flag && _lastPowerOnUpdate < realtimeSinceStartup - 1.0)
			{
				_lastPowerOnUpdate = realtimeSinceStartup;
				BroadcastValueChange();
			}
		}
	}

	private void OnItemAddedRemoved(Item item, bool added)
	{
		OnContainerChanged();
	}

	private void OnItemAddedToStack(Item item, int amount)
	{
		OnContainerChanged();
	}

	private void OnItemRemovedFromStack(Item item, int amount)
	{
		OnContainerChanged();
	}

	public void OnContainerChanged()
	{
		if (HasFlag(Flags.Reserved8))
		{
			((FacepunchBehaviour)this).Invoke(_resetSwitchHandler, 0.5f);
			if (!IsOn())
			{
				SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
				SendNetworkUpdate_Flags();
				MarkDirty();
				BroadcastValueChange();
			}
		}
	}

	private void ResetSwitch()
	{
		SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		MarkDirty();
		BroadcastValueChange();
	}
}


using System;
using UnityEngine;

public static class DigitalClockEx
{
	public static TimeSpan ToTimeSpan(this float value)
	{
		int num = Mathf.RoundToInt(value * 60f);
		int hours = num / 60;
		int minutes = num % 60;
		return new TimeSpan(hours, minutes, 0);
	}

	public static float ToFloat(this TimeSpan timeSpan)
	{
		int hours = timeSpan.Hours;
		float num = (float)timeSpan.Minutes / 60f;
		return (float)hours + num;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class DoorManipulator : IOEntity
{
	public enum DoorEffect
	{
		Close,
		Open,
		Toggle
	}

	public EntityRef entityRef;

	public Door targetDoor;

	public DoorEffect powerAction;

	private bool toggle = true;

	public virtual bool CanPairWithLockedDoors()
	{
		return true;
	}

	public override void Init()
	{
		base.Init();
		SetupInitialDoorConnection();
	}

	public virtual void SetupInitialDoorConnection()
	{
		if ((Object)(object)targetDoor == (Object)null && !entityRef.IsValid(serverside: true))
		{
			SetTargetDoor(FindDoor(CanPairWithLockedDoors()));
		}
		if ((Object)(object)targetDoor != (Object)null && !entityRef.IsValid(serverside: true))
		{
			entityRef.Set(targetDoor);
		}
		if (entityRef.IsValid(serverside: true) && (Object)(object)targetDoor == (Object)null)
		{
			SetTargetDoor(((Component)entityRef.Get(serverside: true)).GetComponent<Door>());
		}
	}

	public virtual void SetTargetDoor(Door newTargetDoor)
	{
		Door door = targetDoor;
		targetDoor = newTargetDoor;
		SetFlag(Flags.On, (Object)(object)targetDoor != (Object)null);
		entityRef.Set(newTargetDoor);
		if ((Object)(object)door != (Object)(object)targetDoor && (Object)(object)targetDoor != (Object)null)
		{
			DoAction(powerAction);
		}
	}

	public virtual Door FindDoor(bool allowLocked = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		List<Door> list = Pool.Get<List<Door>>();
		Vis.Entities(((Component)this).transform.position, 1f, list, 2097152, (QueryTriggerInteraction)1);
		Door result = null;
		float num = float.PositiveInfinity;
		foreach (Door item in list)
		{
			if (!item.isServer)
			{
				continue;
			}
			if (!allowLocked)
			{
				BaseLock baseLock = item.GetSlot(Slot.Lock) as BaseLock;
				if ((Object)(object)baseLock != (Object)null && baseLock.IsLocked())
				{
					continue;
				}
			}
			if (!item.IsOnMovingObject())
			{
				float num2 = Vector3.Distance(((Component)item).transform.position, ((Component)this).transform.position);
				if (num2 < num)
				{
					result = item;
					num = num2;
				}
			}
		}
		Pool.FreeUnmanaged<Door>(ref list);
		return result;
	}

	public virtual void DoActionDoorMissing()
	{
		SetTargetDoor(FindDoor(CanPairWithLockedDoors()));
	}

	public virtual void DoAction(DoorEffect action)
	{
		bool flag = IsPowered();
		if ((Object)(object)targetDoor == (Object)null)
		{
			DoActionDoorMissing();
		}
		if (!((Object)(object)targetDoor != (Object)null))
		{
			return;
		}
		if (targetDoor.IsBusy())
		{
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				DoAction(action);
			}, 1f);
		}
		else if (action == DoorEffect.Open)
		{
			if (flag)
			{
				if (!targetDoor.IsOpen())
				{
					targetDoor.SetOpen(open: true);
				}
			}
			else if (targetDoor.IsOpen())
			{
				targetDoor.SetOpen(open: false);
			}
		}
		else if (action == DoorEffect.Close)
		{
			if (flag)
			{
				if (targetDoor.IsOpen())
				{
					targetDoor.SetOpen(open: false);
				}
			}
			else if (!targetDoor.IsOpen())
			{
				targetDoor.SetOpen(open: true);
			}
		}
		else if (action == DoorEffect.Toggle)
		{
			if (flag && toggle)
			{
				targetDoor.SetOpen(!targetDoor.IsOpen());
				toggle = false;
			}
			else if (!toggle)
			{
				toggle = true;
			}
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		DoAction(powerAction);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity.genericEntRef1 = entityRef.uid;
		info.msg.ioEntity.genericInt1 = (int)powerAction;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			entityRef.uid = info.msg.ioEntity.genericEntRef1;
			powerAction = (DoorEffect)info.msg.ioEntity.genericInt1;
		}
	}
}


public enum DoorEffect
{
	Close,
	Open,
	Toggle
}


using System;

public class DummySwitch : IOEntity
{
	public string listenString = "";

	public string listenStringOff = "";

	public float duration = -1f;

	public override bool WantsPower(int inputIndex)
	{
		return IsOn();
	}

	public override void ResetIOState()
	{
		SetFlag(Flags.On, b: false);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsOn())
		{
			return 0;
		}
		return GetCurrentEnergy();
	}

	public void SetOn(bool wantsOn)
	{
		SetFlag(Flags.On, wantsOn);
		MarkDirty();
		if (IsOn() && duration != -1f)
		{
			((FacepunchBehaviour)this).Invoke((Action)SetOff, duration);
		}
	}

	public void SetOff()
	{
		SetOn(wantsOn: false);
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == listenString)
		{
			if (IsOn())
			{
				SetOn(wantsOn: false);
			}
			SetOn(wantsOn: true);
		}
		else if (msg == listenStringOff && listenStringOff != "" && IsOn())
		{
			SetOn(wantsOn: false);
		}
	}
}


using UnityEngine;

public class ElectricFurnaceIO : IOEntity, IIndustrialStorage
{
	public int PowerConsumption = 3;

	public ItemContainer Container => GetParentOven().inventory;

	public BaseEntity IndustrialEntity => this;

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if ((Object)(object)GetParentEntity() == (Object)null)
		{
			return 0;
		}
		if (!GetParentEntity().IsOn())
		{
			return 0;
		}
		return PowerConsumption;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		ElectricOven parentOven = GetParentOven();
		if (!((Object)(object)parentOven == (Object)null))
		{
			if (inputAmount > 0)
			{
				parentOven.StartCooking();
			}
			else
			{
				parentOven.StopCooking();
			}
		}
	}

	private ElectricOven GetParentOven()
	{
		return GetParentEntity() as ElectricOven;
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i(1, 2);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i(3, 5);
	}

	public void OnStorageItemTransferBegin()
	{
	}

	public void OnStorageItemTransferEnd()
	{
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ElectricGenerator : IOEntity
{
	public float electricAmount = 8f;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int MaximalPowerOutput()
	{
		return Mathf.FloorToInt(electricAmount);
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetCurrentEnergy()
	{
		return (int)electricAmount;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return GetCurrentEnergy();
	}

	public override void UpdateOutputs()
	{
		currentEnergy = GetCurrentEnergy();
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().UpdateFromInput(currentEnergy, iOSlot.connectedToSlot);
			}
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		((FacepunchBehaviour)this).Invoke((Action)ForcePuzzleReset, 4f);
	}

	private void ForcePuzzleReset()
	{
		PuzzleReset component = ((Component)this).GetComponent<PuzzleReset>();
		if ((Object)(object)component != (Object)null)
		{
			component.DoReset();
			component.ResetTimer();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			return;
		}
		PuzzleReset component = ((Component)this).GetComponent<PuzzleReset>();
		if (Object.op_Implicit((Object)(object)component))
		{
			info.msg.puzzleReset = Pool.Get<PuzzleReset>();
			info.msg.puzzleReset.playerBlocksReset = component.playersBlockReset;
			if ((Object)(object)component.playerDetectionOrigin != (Object)null)
			{
				info.msg.puzzleReset.playerDetectionOrigin = component.playerDetectionOrigin.position;
			}
			info.msg.puzzleReset.playerDetectionRadius = component.playerDetectionRadius;
			info.msg.puzzleReset.scaleWithServerPopulation = component.scaleWithServerPopulation;
			info.msg.puzzleReset.timeBetweenResets = component.timeBetweenResets;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (!info.fromDisk || info.msg.puzzleReset == null)
		{
			return;
		}
		PuzzleReset component = ((Component)this).GetComponent<PuzzleReset>();
		if ((Object)(object)component != (Object)null)
		{
			component.playersBlockReset = info.msg.puzzleReset.playerBlocksReset;
			if ((Object)(object)component.playerDetectionOrigin != (Object)null)
			{
				component.playerDetectionOrigin.position = info.msg.puzzleReset.playerDetectionOrigin;
			}
			component.playerDetectionRadius = info.msg.puzzleReset.playerDetectionRadius;
			component.scaleWithServerPopulation = info.msg.puzzleReset.scaleWithServerPopulation;
			component.timeBetweenResets = info.msg.puzzleReset.timeBetweenResets;
			component.ResetTimer();
		}
	}
}


public class ElevatorIOEntity : IOEntity
{
	public int Consumption = 5;

	public override int ConsumptionAmount()
	{
		return Consumption;
	}
}


using System;
using UnityEngine;

public class FluidSwitch : ElectricSwitch
{
	private Flags Flag_PumpPowered = Flags.Reserved6;

	public Animator PumpAnimator;

	private bool pumpEnabled;

	private int lastToggleInput;

	public override bool IsGravitySource => true;

	protected override bool DisregardGravityRestrictionsOnLiquid => HasFlag(Flag_PumpPowered);

	public override void ResetState()
	{
		base.ResetState();
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		if (inputSlot == 1 && lastToggleInput != inputAmount)
		{
			lastToggleInput = inputAmount;
			SetSwitch(inputAmount > 0);
		}
		if (inputSlot == 2)
		{
			bool num = pumpEnabled;
			pumpEnabled = inputAmount > 0;
			if (num != pumpEnabled)
			{
				lastPassthroughEnergy = -1;
				SetFlag(Flag_PumpPowered, pumpEnabled);
				SendChangedToRoot(forceUpdate: true);
			}
		}
	}

	public override void SetSwitch(bool wantsOn)
	{
		base.SetSwitch(wantsOn);
		((FacepunchBehaviour)this).Invoke((Action)DelayedSendChanged, IOEntity.responsetime * 2f);
	}

	private void DelayedSendChanged()
	{
		SendChangedToRoot(forceUpdate: true);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot == 0)
		{
			if (!IsOn())
			{
				return 0;
			}
			return GetCurrentEnergy();
		}
		return 0;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement = false)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (!forPlacement && !IsOn())
		{
			return false;
		}
		return base.AllowLiquidPassthrough(fromSource, sourceWorldPosition);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class Fridge : ContainerIOEntity, IFoodSpoilModifier
{
	public ItemCategory OnlyAcceptCategory = ItemCategory.All;

	public List<ItemDefinition> IncludedItems = new List<ItemDefinition>();

	public int PowerConsumption = 5;

	[Range(0f, 1f)]
	public float PoweredFoodSpoilageRateMultiplier = 0.1f;

	public float GetSpoilMultiplier(Item arg)
	{
		if (IsPowered())
		{
			return PoweredFoodSpoilageRateMultiplier;
		}
		return 1f;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.canAcceptItem = CanAcceptItem;
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		if (OnlyAcceptCategory == ItemCategory.All)
		{
			return true;
		}
		if (item.info.category != OnlyAcceptCategory)
		{
			return IsItemInAcceptedList(item);
		}
		return true;
	}

	private bool IsItemInAcceptedList(Item item)
	{
		foreach (ItemDefinition includedItem in IncludedItems)
		{
			if ((Object)(object)item.info == (Object)(object)includedItem)
			{
				return true;
			}
		}
		return false;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	private bool CanOpenLootPanel(BasePlayer player)
	{
		if (!CanBeLooted(player))
		{
			return false;
		}
		BaseLock @lock = GetLock();
		if ((Object)(object)@lock != (Object)null && !@lock.OnTryToOpen(player))
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
			return false;
		}
		return true;
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (!CanOpenLootPanel(player))
		{
			return false;
		}
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if ((Object)(object)GetSlot(Slot.Lock) != (Object)null)
		{
			pickupErrorToFormat = (format: PickupErrors.ItemHasLock, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}
}


public class FuseBox : IOEntity
{
	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		SetFlag(Flags.On, IsPowered());
	}
}


using UnityEngine;

public class ORSwitch : IOEntity
{
	private int input1Amount;

	private int input2Amount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		if (IsFlickering())
		{
			return true;
		}
		if (input1Amount == 0 && input2Amount == 0)
		{
			return false;
		}
		if (input1Amount == input2Amount)
		{
			return inputIndex == 0;
		}
		int num = ((input1Amount <= input2Amount) ? 1 : 0);
		return inputIndex == num;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int num = Mathf.Max(input1Amount, input2Amount);
		return Mathf.Max(0, num);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		if (IsConnectedTo(this, slot, IOEntity.backtracking))
		{
			inputAmount = 0;
		}
		switch (slot)
		{
		case 0:
			input1Amount = inputAmount;
			break;
		case 1:
			input2Amount = inputAmount;
			break;
		}
		int num = input1Amount + input2Amount;
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
		base.UpdateFromInput(inputAmount, slot);
	}
}


public class PanelLight : SimpleLight
{
}


public class PressButton_TrainTunnel : PressButton
{
}


public class SimpleLight : IOEntity
{
	public override void ResetIOState()
	{
		base.ResetIOState();
		if (IsOn())
		{
			SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		bool num = IsOn();
		bool flag = IsPowered();
		if (num != flag)
		{
			SetFlag(Flags.On, flag, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}
}


using UnityEngine;

public class Splitter : IOEntity
{
	public override bool BlockFluidDraining => true;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot < 0 || outputSlot >= outputs.Length)
		{
			return 0;
		}
		IOEntity iOEntity = outputs[outputSlot].connectedTo.Get();
		if ((Object)(object)iOEntity == (Object)null || iOEntity.IsDestroyed)
		{
			return 0;
		}
		int num = ((cachedOutputsUsed == 0) ? 1 : cachedOutputsUsed);
		int num2 = GetCurrentEnergy();
		int num3 = num2 / num;
		int num4 = 0;
		for (int i = 0; i < outputs.Length; i++)
		{
			if (!((Object)(object)outputs[i].connectedTo.Get() != (Object)null) || outputs[i].connectedTo.Get().IsDestroyed)
			{
				continue;
			}
			if (outputSlot == i)
			{
				if (num4 < num2 % num)
				{
					return num3 + 1;
				}
				return num3;
			}
			num4++;
		}
		return 0;
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public override void OnCircuitChanged(bool forceUpdate)
	{
		MarkDirtyForceUpdateOutputs();
	}
}


using System;
using UnityEngine;

public class XORSwitch : IOEntity
{
	private int input1Amount;

	private int input2Amount;

	private bool input1Set;

	private bool input2Set;

	private bool firstRun = true;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		if (input1Amount != 0)
		{
			return input2Amount == 0;
		}
		return true;
	}

	public override void ResetState()
	{
		base.ResetState();
		input1Set = false;
		input2Set = false;
		firstRun = true;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if ((HasFlag(Flags.Reserved1) && !input1Set) || (HasFlag(Flags.Reserved2) && !input2Set))
		{
			return 0;
		}
		if (input1Amount > 0 && input2Amount > 0)
		{
			return 0;
		}
		int num = Mathf.Max(input1Amount, input2Amount);
		return Mathf.Max(0, num);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		if (inputAmount > 0 && IsConnectedTo(this, slot, IOEntity.backtracking))
		{
			inputAmount = 0;
			SetFlag(Flags.Reserved7, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved7, b: false);
		}
		switch (slot)
		{
		case 0:
			input1Set = true;
			input1Amount = inputAmount;
			break;
		case 1:
			input2Set = true;
			input2Amount = inputAmount;
			break;
		}
		if (firstRun)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdateFlags))
			{
				((FacepunchBehaviour)this).Invoke((Action)UpdateFlags, 0.1f);
			}
		}
		else
		{
			UpdateFlags();
		}
		firstRun = false;
		base.UpdateFromInput(inputAmount, slot);
	}

	private void UpdateFlags()
	{
		int num = ((input1Amount <= 0 || input2Amount <= 0) ? Mathf.Max(input1Amount, input2Amount) : 0);
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class Hopper : IndustrialEntity, IIndustrialStorage
{
	public enum MountType
	{
		Flat,
		Barrel
	}

	private struct HopperMove : IEqualityComparer<HopperMove>
	{
		public IHopperTarget Target;

		public TimeSince Duration;

		public bool Equals(HopperMove x, HopperMove y)
		{
			return object.Equals(x.Target, y.Target);
		}

		public int GetHashCode(HopperMove obj)
		{
			return HashCode.Combine(obj.Target);
		}
	}

	[BurstCompile]
	private struct FillRaycastJob : IJobParallelFor
	{
		[ReadOnly]
		public NativeArray<Vector3> points;

		public NativeArray<RaycastCommand> commands;

		public Vector3 originPoint;

		public int layerMask;

		public void Execute(int index)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = points[index];
			if (!(val == Vector3.zero))
			{
				ref NativeArray<RaycastCommand> reference = ref commands;
				Vector3 val2 = originPoint - val;
				reference[index] = new RaycastCommand(val, ((Vector3)(ref val2)).normalized, Vector3.Distance(val, originPoint), layerMask, 1);
			}
		}
	}

	public class HopperAnimationWorkQueue : PersistentObjectWorkQueue<Hopper>
	{
		protected override void RunJob(Hopper entity)
		{
			entity.MovingItemsTick();
		}
	}

	public interface IHopperTarget
	{
		BaseEntity ToEntity { get; }

		Rigidbody Rigidbody { get; }

		int NumberOfItemsToTransfer { get; }

		float EndPositionToleranceMultiplier { get; }

		void PrepareForHopper();

		void HopperCancelled();

		void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 fallbackWorldPos);
	}

	public TriggerEnterTimer ItemTrigger;

	public Transform ItemMoveTarget;

	public float ItemMoveSpeed = 2f;

	public AnimationCurve ItemHeightChangeSpeed;

	private const float MoveRate = 1f / 60f;

	public AnimationCurve ItemHeightCurve;

	public AnimationCurve ItemSpeedMultiplierCurve;

	public AnimationCurve ItemRotationSpeed;

	public GameObjectRef BloodSpray;

	public bool DebugMode;

	public const Flags MovingItems = Flags.Reserved1;

	public const Flags StandardMount = Flags.Reserved2;

	public const Flags BarrelMount = Flags.Reserved3;

	public Transform RaycastOriginPoint;

	private Action queueScanAction;

	private HashSet<HopperMove> movingItems = new HashSet<HopperMove>();

	private BaseEntity _cachedParent;

	private ItemContainer cachedContainer;

	private Predicate<HopperMove> cachedCheckNull;

	private Predicate<HopperMove> cachedRemove;

	private IHopperTarget matchCheck;

	public static HopperAnimationWorkQueue WorkQueue = new HopperAnimationWorkQueue();

	public BaseEntity cachedParent
	{
		get
		{
			if ((Object)(object)_cachedParent == (Object)null)
			{
				_cachedParent = GetParentEntity();
			}
			return _cachedParent;
		}
	}

	public ItemContainer Container
	{
		get
		{
			if (cachedContainer == null)
			{
				cachedContainer = (cachedParent as StorageContainer)?.inventory;
			}
			return cachedContainer;
		}
	}

	public BaseEntity IndustrialEntity => this;

	public override int ConsumptionAmount()
	{
		return 8;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		return 8;
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public void OnStorageItemTransferBegin()
	{
	}

	public void OnStorageItemTransferEnd()
	{
	}

	private void ScanForItemsTick()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		if (ItemTrigger.HasAnyEntityContents && TimeSince.op_Implicit(ItemTrigger.EnterTime) > 0.5f)
		{
			Vector3 position = RaycastOriginPoint.position;
			int num = 128;
			NativeArray<RaycastCommand> val = default(NativeArray<RaycastCommand>);
			val..ctor(num, (Allocator)3, (NativeArrayOptions)1);
			NativeArray<RaycastHit> val2 = default(NativeArray<RaycastHit>);
			val2..ctor(num, (Allocator)3, (NativeArrayOptions)1);
			NativeArray<Vector3> points = default(NativeArray<Vector3>);
			points..ctor(num, (Allocator)3, (NativeArrayOptions)1);
			List<IHopperTarget> list = Pool.Get<List<IHopperTarget>>();
			int num2 = 0;
			int count = movingItems.Count;
			foreach (BaseEntity entityContent in ItemTrigger.entityContents)
			{
				if (entityContent is IHopperTarget hopperTarget && hopperTarget.ToEntity.isServer)
				{
					if (entityContent is DroppedItem droppedItem && !droppedItem.HasFlag(Flags.Reserved3) && Container.QuickIndustrialPreCheck(droppedItem.item, new Vector2i(0, Container.capacity - 1), count, out var _))
					{
						Vector3 val3 = ((Component)droppedItem).transform.position;
						if ((Object)(object)droppedItem.childCollider != (Object)null)
						{
							Bounds val4 = droppedItem.childCollider.bounds;
							val3 = ((Bounds)(ref val4)).center;
						}
						points[num2++] = val3;
						list.Add(hopperTarget);
					}
					else if (entityContent is BaseCorpse baseCorpse && !baseCorpse.HasFlag(Flags.Reserved1))
					{
						Vector3 position2 = ((Component)baseCorpse).transform.position;
						points[num2++] = position2;
						list.Add(hopperTarget);
					}
				}
				if (list.Count == num)
				{
					break;
				}
			}
			FillRaycastJob fillRaycastJob = default(FillRaycastJob);
			fillRaycastJob.originPoint = position;
			fillRaycastJob.points = points;
			fillRaycastJob.commands = val;
			fillRaycastJob.layerMask = 2097152;
			JobHandle val5 = IJobParallelForExtensions.Schedule<FillRaycastJob>(fillRaycastJob, num2, 6, default(JobHandle));
			val5 = RaycastCommand.ScheduleBatch(val, val2, 1, 1, val5);
			((JobHandle)(ref val5)).Complete();
			for (int i = 0; i < num2; i++)
			{
				RaycastHit val6 = val2[i];
				IHopperTarget hopperTarget2 = list[i];
				if ((Object)(object)((RaycastHit)(ref val6)).collider == (Object)null && movingItems.Add(new HopperMove
				{
					Target = hopperTarget2,
					Duration = TimeSince.op_Implicit(0f)
				}))
				{
					hopperTarget2.PrepareForHopper();
					if ((Object)(object)hopperTarget2.Rigidbody != (Object)null)
					{
						hopperTarget2.Rigidbody.useGravity = false;
						hopperTarget2.Rigidbody.velocity = Vector3.zero;
						hopperTarget2.Rigidbody.angularVelocity = Vector3.zero;
					}
					if (Server.hopperAnimationBudgetMs <= 0f)
					{
						IntakeItem(hopperTarget2);
					}
					break;
				}
			}
			val.Dispose();
			val2.Dispose();
			points.Dispose();
			Pool.FreeUnmanaged<IHopperTarget>(ref list);
		}
		SetFlag(Flags.Reserved1, movingItems.Count > 0);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			bool flag = next.HasFlag(Flags.Reserved8) || DebugMode;
			if (!((FacepunchBehaviour)this).IsInvoking(queueScanAction) && flag)
			{
				((FacepunchBehaviour)this).InvokeRepeating(queueScanAction, 0.5f, 0.5f);
			}
			else if (((FacepunchBehaviour)this).IsInvoking(queueScanAction) && !flag)
			{
				((FacepunchBehaviour)this).CancelInvoke(queueScanAction);
			}
			bool flag2 = next.HasFlag(Flags.Reserved1);
			if (!((PersistentObjectWorkQueue<Hopper>)WorkQueue).Contains(this) && flag2)
			{
				((PersistentObjectWorkQueue<Hopper>)WorkQueue).Add(this);
			}
			else if (((PersistentObjectWorkQueue<Hopper>)WorkQueue).Contains(this) && !flag2)
			{
				((PersistentObjectWorkQueue<Hopper>)WorkQueue).Remove(this);
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		queueScanAction = QueueScan;
		if (DebugMode)
		{
			OnFlagsChanged(flags, flags);
		}
	}

	internal override void DoServerDestroy()
	{
		if (HasFlag(Flags.Reserved1))
		{
			ResetAllMovingItems();
		}
		base.DoServerDestroy();
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		if (HasFlag(Flags.Reserved1))
		{
			ResetAllMovingItems();
		}
		base.OnPickedUp(createdItem, player);
	}

	private void ResetAllMovingItems()
	{
		((PersistentObjectWorkQueue<Hopper>)WorkQueue).Remove(this);
		SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
		Rigidbody val = default(Rigidbody);
		foreach (HopperMove movingItem in movingItems)
		{
			if (movingItem.Target != null && (Object)(object)movingItem.Target.ToEntity != (Object)null)
			{
				if (((Component)movingItem.Target.ToEntity).TryGetComponent<Rigidbody>(ref val))
				{
					val.useGravity = true;
				}
				movingItem.Target.HopperCancelled();
			}
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		MountType mountType = MountType.Flat;
		if ((Object)(object)newParent != (Object)null && newParent is BoxStorage boxStorage)
		{
			mountType = boxStorage.HopperMountType;
		}
		SetFlag(Flags.Reserved3, mountType == MountType.Barrel);
		SetFlag(Flags.Reserved2, mountType == MountType.Flat);
	}

	private void QueueScan()
	{
		((ObjectWorkQueue<IndustrialEntity>)global::IndustrialEntity.Queue).Add((IndustrialEntity)this);
	}

	protected override void RunJob()
	{
		base.RunJob();
		if (IsPowered() || DebugMode)
		{
			ScanForItemsTick();
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (inputSlot == 0)
		{
			bool b = inputAmount >= ConsumptionAmount() && inputAmount > 0;
			SetFlag(Flags.Reserved8, b);
			currentEnergy = inputAmount;
			ensureOutputsUpdated = true;
			MarkDirty();
		}
	}

	private void MovingItemsTick()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		if (movingItems.Count == 0)
		{
			return;
		}
		if (cachedCheckNull == null)
		{
			cachedCheckNull = CheckNull;
		}
		movingItems.RemoveWhere(cachedCheckNull);
		PooledList<IHopperTarget> val = Pool.Get<PooledList<IHopperTarget>>();
		try
		{
			float num = ItemMoveSpeed * (1f / 60f * Time.timeScale);
			Vector3 position = ItemMoveTarget.position;
			Quaternion rotation = ItemMoveTarget.rotation;
			foreach (HopperMove movingItem in movingItems)
			{
				if (movingItem.Target != null && !((Object)(object)movingItem.Target.ToEntity == (Object)null))
				{
					Vector3 position2 = ((Component)movingItem.Target.ToEntity).transform.position;
					Quaternion rotation2 = ((Component)movingItem.Target.ToEntity).transform.rotation;
					float num2 = Mathf.Clamp01(Vector3.Distance(position2, Vector3Ex.WithY(position, position2.y)) / 3f);
					float num3 = ItemHeightCurve.Evaluate(num2);
					float num4 = ItemSpeedMultiplierCurve.Evaluate(1f - num2);
					Vector3 val2 = Vector3.MoveTowards(position2, position, num * num4);
					val2.y = Mathf.MoveTowards(val2.y, position.y + num3, Time.deltaTime * ItemHeightChangeSpeed.Evaluate(1f - num2));
					Quaternion val3 = Quaternion.RotateTowards(rotation2, rotation, Time.deltaTime * ItemRotationSpeed.Evaluate(1f - num2));
					((Component)movingItem.Target.ToEntity).transform.SetPositionAndRotation(val2, val3);
					if ((Object)(object)movingItem.Target.Rigidbody != (Object)null)
					{
						movingItem.Target.Rigidbody.velocity = Vector3.zero;
						movingItem.Target.Rigidbody.angularVelocity = Vector3.zero;
					}
					float num5 = 0.015f * movingItem.Target.EndPositionToleranceMultiplier;
					Vector3 val4 = val2 - position;
					if (((Vector3)(ref val4)).sqrMagnitude < num5 * num5)
					{
						((List<IHopperTarget>)(object)val).Add(movingItem.Target);
					}
				}
			}
			foreach (HopperMove movingItem2 in movingItems)
			{
				if (TimeSince.op_Implicit(movingItem2.Duration) > 5f)
				{
					((List<IHopperTarget>)(object)val).Add(movingItem2.Target);
				}
			}
			foreach (IHopperTarget item in (List<IHopperTarget>)(object)val)
			{
				IntakeItem(item);
			}
			if (movingItems.Count == 0)
			{
				SetFlag(Flags.Reserved1, b: false);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		static bool CheckNull(HopperMove obj)
		{
			if (obj.Target != null)
			{
				return (Object)(object)obj.Target.ToEntity == (Object)null;
			}
			return true;
		}
	}

	private bool Match(HopperMove obj)
	{
		return obj.Target == matchCheck;
	}

	private void IntakeItem(IHopperTarget targetItem)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (cachedRemove == null)
		{
			cachedRemove = Match;
		}
		matchCheck = targetItem;
		movingItems.RemoveWhere(cachedRemove);
		if (BloodSpray.isValid && targetItem.ToEntity is BaseCorpse)
		{
			Effect.server.Run(BloodSpray.resourcePath, ((Component)this).transform.position);
		}
		targetItem.TransferAllItemsToContainer(Container, ItemMoveTarget.position);
	}
}


public enum MountType
{
	Flat,
	Barrel
}


using System;
using System.Collections.Generic;

private struct HopperMove : IEqualityComparer<HopperMove>
{
	public IHopperTarget Target;

	public TimeSince Duration;

	public bool Equals(HopperMove x, HopperMove y)
	{
		return object.Equals(x.Target, y.Target);
	}

	public int GetHashCode(HopperMove obj)
	{
		return HashCode.Combine(obj.Target);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
private struct FillRaycastJob : IJobParallelFor
{
	[ReadOnly]
	public NativeArray<Vector3> points;

	public NativeArray<RaycastCommand> commands;

	public Vector3 originPoint;

	public int layerMask;

	public void Execute(int index)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = points[index];
		if (!(val == Vector3.zero))
		{
			ref NativeArray<RaycastCommand> reference = ref commands;
			Vector3 val2 = originPoint - val;
			reference[index] = new RaycastCommand(val, ((Vector3)(ref val2)).normalized, Vector3.Distance(val, originPoint), layerMask, 1);
		}
	}
}


public class HopperAnimationWorkQueue : PersistentObjectWorkQueue<Hopper>
{
	protected override void RunJob(Hopper entity)
	{
		entity.MovingItemsTick();
	}
}


using UnityEngine;

public interface IHopperTarget
{
	BaseEntity ToEntity { get; }

	Rigidbody Rigidbody { get; }

	int NumberOfItemsToTransfer { get; }

	float EndPositionToleranceMultiplier { get; }

	void PrepareForHopper();

	void HopperCancelled();

	void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 fallbackWorldPos);
}


using UnityEngine;

public class IndustrialEntity : IOEntity
{
	public class IndustrialProcessQueue : ObjectWorkQueue<IndustrialEntity>
	{
		protected override void RunJob(IndustrialEntity job)
		{
			if ((Object)(object)job != (Object)null)
			{
				job.RunJob();
			}
		}
	}

	public static IndustrialProcessQueue Queue = new IndustrialProcessQueue();

	protected virtual void RunJob()
	{
	}
}


using UnityEngine;

public class IndustrialProcessQueue : ObjectWorkQueue<IndustrialEntity>
{
	protected override void RunJob(IndustrialEntity job)
	{
		if ((Object)(object)job != (Object)null)
		{
			job.RunJob();
		}
	}
}


public interface IIndustrialStorage
{
	ItemContainer Container { get; }

	BaseEntity IndustrialEntity { get; }

	Vector2i InputSlotRange(int slotIndex);

	Vector2i OutputSlotRange(int slotIndex);

	void OnStorageItemTransferBegin();

	void OnStorageItemTransferEnd();
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class IndustrialFilterBuffer : MonoBehaviour
{
	public RustText ItemName;

	public Image ItemIcon;

	public GameObject BlueprintRoot;

	public RustSlider BufferSlider;

	public RustText BufferProgressText;
}


using Rust.UI;
using UnityEngine;

public class IndustrialFilterDialog : UIDialog
{
	public GameObjectRef ItemPrefab;

	public Transform ItemParent;

	public GameObject ItemSearchParent;

	public ItemSearchEntry ItemSearchEntryPrefab;

	public GameObject NoItemsPrompt;

	public Dropdown FilterModeDropdown;

	public GameObject[] FilterModeExplanations;

	public GameObject FilterModeBlocker;

	public RustText FilterCountText;

	public GameObject BufferRoot;

	public GameObjectRef BufferItemPrefab;

	public Transform BufferTransform;

	public RustButton PasteButton;

	public GameObject[] RegularCopyPasteButtons;

	public GameObject[] JsonCopyPasteButtons;

	public bool closeWhenClicked;

	public int count = 20;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class IndustrialFilterItemIcon : MonoBehaviour
{
	public Image ItemIcon;

	public RustText ItemName;

	public RustInput MaxInput;

	public RustInput BufferInput;

	public RustInput MinInput;

	public GameObject BlueprintIcon;

	public GameObject InverseModeBlocker;
}


using UnityEngine;

public class IndustrialStorageAdaptor : IndustrialEntity, IIndustrialStorage
{
	public GameObject GreenLight;

	public GameObject RedLight;

	public BaseEntity _cachedParent;

	public ItemContainer cachedContainer;

	public BaseEntity cachedParent
	{
		get
		{
			if ((Object)(object)_cachedParent == (Object)null)
			{
				_cachedParent = GetParentEntity();
			}
			return _cachedParent;
		}
	}

	public ItemContainer Container
	{
		get
		{
			if (cachedContainer == null)
			{
				cachedContainer = (cachedParent as StorageContainer)?.inventory;
				if (cachedContainer == null)
				{
					cachedContainer = (cachedParent as ContainerIOEntity)?.inventory;
				}
			}
			return cachedContainer;
		}
	}

	public BaseEntity IndustrialEntity => this;

	public override void ServerInit()
	{
		base.ServerInit();
		_cachedParent = null;
		cachedContainer = null;
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedParent != (Object)null)
		{
			if (cachedParent is IIndustrialStorage industrialStorage)
			{
				return industrialStorage.InputSlotRange(slotIndex);
			}
			if (cachedParent is Locker locker)
			{
				Vector3 localPosition = ((Component)this).transform.localPosition;
				return locker.GetIndustrialSlotRange(localPosition);
			}
		}
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedParent != (Object)null)
		{
			if (cachedParent is IIndustrialStorage industrialStorage)
			{
				return industrialStorage.OutputSlotRange(slotIndex);
			}
			if (cachedParent is Locker locker)
			{
				Vector3 localPosition = ((Component)this).transform.localPosition;
				return locker.GetIndustrialSlotRange(localPosition);
			}
		}
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public void OnStorageItemTransferBegin()
	{
		if ((Object)(object)cachedParent != (Object)null)
		{
			if (cachedParent is VendingMachine vendingMachine)
			{
				vendingMachine.OnIndustrialItemTransferBegins();
			}
			else if (cachedParent is Locker locker)
			{
				locker.OnIndustrialItemTransferBegin();
			}
		}
	}

	public void OnStorageItemTransferEnd()
	{
		if ((Object)(object)cachedParent != (Object)null)
		{
			if (cachedParent is VendingMachine vendingMachine)
			{
				vendingMachine.OnIndustrialItemTransferEnds();
			}
			else if (cachedParent is Locker locker)
			{
				locker.OnIndustrialItemTransferEnd();
			}
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		if ((Object)(object)newParent != (Object)null)
		{
			cachedContainer = null;
		}
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public void ClientNotifyItemAddRemoved(bool add)
	{
		if (add)
		{
			GreenLight.SetActive(false);
			GreenLight.SetActive(true);
		}
		else
		{
			RedLight.SetActive(false);
			RedLight.SetActive(true);
		}
	}
}


using System;
using UnityEngine;

[RequireComponent(typeof(IOEntity))]
public class IOEntityMovementChecker : FacepunchBehaviour
{
	private IOEntity ioEntity;

	private Vector3 prevPos;

	private const float MAX_MOVE = 0.05f;

	private const float MAX_MOVE_SQR = 0.0025000002f;

	protected void Awake()
	{
		ioEntity = ((Component)this).GetComponent<IOEntity>();
	}

	protected void OnEnable()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckPosition, Random.Range(0f, 0.25f), 0.25f);
	}

	protected void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CheckPosition);
	}

	private void CheckPosition()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (!ioEntity.isClient && Vector3.SqrMagnitude(((Component)this).transform.position - prevPos) > 0.0025000002f)
		{
			prevPos = ((Component)this).transform.position;
			if (ioEntity.HasConnections())
			{
				ioEntity.SendChangedToRoot(forceUpdate: true);
				ioEntity.ClearConnections();
			}
		}
	}
}


using UnityEngine;

public class IOHandle : MonoBehaviour
{
}


public enum IOHandlePriority
{
	Normal,
	Low,
	High
}


public class IOManager : SingletonComponent<IOManager>
{
}


using UnityEngine;

public class ProgressDoor : IOEntity
{
	public float storedEnergy;

	public float energyForOpen = 1f;

	public float secondsToClose = 1f;

	public float openProgress;

	public override void ResetIOState()
	{
		storedEnergy = 0f;
		UpdateProgress();
	}

	public override float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot = 0)
	{
		if (inputAmount > 0f)
		{
			AddEnergy(inputAmount);
			if (storedEnergy == energyForOpen)
			{
				return inputAmount;
			}
			return 0f;
		}
		NoEnergy();
		return inputAmount;
	}

	public virtual void NoEnergy()
	{
	}

	public virtual void AddEnergy(float amount)
	{
		if (!(amount <= 0f))
		{
			storedEnergy += amount;
			storedEnergy = Mathf.Clamp(storedEnergy, 0f, energyForOpen);
		}
	}

	public virtual void UpdateProgress()
	{
		SendNetworkUpdate();
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class SlidingProgressDoor : ProgressDoor
{
	public Vector3 openPosition;

	public Vector3 closedPosition;

	public GameObject doorObject;

	public TriggerVehiclePush vehiclePhysBox;

	private float lastEnergyTime;

	private float lastServerUpdateTime;

	public override void Spawn()
	{
		base.Spawn();
		((FacepunchBehaviour)this).InvokeRepeating((Action)ServerUpdate, 0f, 0.1f);
		if ((Object)(object)vehiclePhysBox != (Object)null)
		{
			((Component)vehiclePhysBox).gameObject.SetActive(false);
		}
	}

	public override void NoEnergy()
	{
		base.NoEnergy();
	}

	public override void AddEnergy(float amount)
	{
		lastEnergyTime = Time.time;
		base.AddEnergy(amount);
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}

	public void ServerUpdate()
	{
		if (!base.isServer)
		{
			return;
		}
		if (lastServerUpdateTime == 0f)
		{
			lastServerUpdateTime = Time.realtimeSinceStartup;
		}
		float num = Time.realtimeSinceStartup - lastServerUpdateTime;
		lastServerUpdateTime = Time.realtimeSinceStartup;
		if (Time.time > lastEnergyTime + 0.333f)
		{
			float num2 = energyForOpen * num / secondsToClose;
			float num3 = Mathf.Min(storedEnergy, num2);
			if ((Object)(object)vehiclePhysBox != (Object)null)
			{
				((Component)vehiclePhysBox).gameObject.SetActive(num3 > 0f && storedEnergy > 0f);
				if (((Component)vehiclePhysBox).gameObject.activeSelf && vehiclePhysBox.ContentsCount > 0)
				{
					num3 = 0f;
				}
			}
			storedEnergy -= num3;
			storedEnergy = Mathf.Clamp(storedEnergy, 0f, energyForOpen);
			if (num3 > 0f)
			{
				IOSlot[] array = outputs;
				foreach (IOSlot iOSlot in array)
				{
					if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
					{
						iOSlot.connectedTo.Get().IOInput(this, ioType, 0f - num3, iOSlot.connectedToSlot);
					}
				}
			}
		}
		UpdateProgress();
	}

	public override void UpdateProgress()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localPosition = doorObject.transform.localPosition;
		float num = storedEnergy / energyForOpen;
		Vector3 val = Vector3.Lerp(closedPosition, openPosition, num);
		doorObject.transform.localPosition = val;
		if (base.isServer)
		{
			bool flag = Vector3.Distance(localPosition, val) > 0.01f;
			SetFlag(Flags.Reserved1, flag);
			if (flag)
			{
				SendNetworkUpdate();
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.sphereEntity;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.sphereEntity = Pool.Get<SphereEntity>();
		info.msg.sphereEntity.radius = storedEnergy;
	}
}


using System;
using UnityEngine;

public class NoPlayersIOReset : FacepunchBehaviour
{
	[SerializeField]
	private IOEntity[] entitiesToReset;

	[SerializeField]
	private float radius;

	[SerializeField]
	private float timeBetweenChecks;

	protected void OnEnable()
	{
		((FacepunchBehaviour)this).InvokeRandomized((Action)Check, timeBetweenChecks, timeBetweenChecks, timeBetweenChecks * 0.1f);
	}

	protected void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Check);
	}

	private void Check()
	{
		if (!PuzzleReset.AnyPlayersWithinDistance(((Component)this).transform, radius))
		{
			Reset();
		}
	}

	private void Reset()
	{
		IOEntity[] array = entitiesToReset;
		foreach (IOEntity iOEntity in array)
		{
			if (iOEntity.IsValid() && iOEntity.isServer)
			{
				iOEntity.ResetIOState();
				iOEntity.MarkDirty();
			}
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public class PuzzleReset : FacepunchBehaviour
{
	public SpawnGroup[] respawnGroups;

	public IOEntity[] resetEnts;

	public GameObject[] resetObjects;

	public bool playersBlockReset;

	public bool CheckSleepingAIZForPlayers;

	public float playerDetectionRadius;

	public Transform playerDetectionOrigin;

	public bool ignoreAboveGroundPlayers;

	public float timeBetweenResets = 30f;

	public bool scaleWithServerPopulation;

	[HideInInspector]
	public Vector3[] resetPositions;

	public bool broadcastResetMessage;

	public Phrase resetPhrase;

	private AIInformationZone zone;

	public float resetTimeElapsed;

	private float resetTickTime = 10f;

	public float GetResetSpacing()
	{
		return timeBetweenResets * (scaleWithServerPopulation ? (1f - SpawnHandler.PlayerLerp(Spawn.min_rate, Spawn.max_rate)) : 1f);
	}

	public void Start()
	{
		if (timeBetweenResets != float.PositiveInfinity)
		{
			ResetTimer();
		}
	}

	public void ResetTimer()
	{
		resetTimeElapsed = 0f;
		((FacepunchBehaviour)this).CancelInvoke((Action)ResetTick);
		((FacepunchBehaviour)this).InvokeRandomized((Action)ResetTick, Random.Range(0f, 1f), resetTickTime, 0.5f);
	}

	public bool PassesResetCheck()
	{
		if (playersBlockReset)
		{
			if (CheckSleepingAIZForPlayers)
			{
				return AIZSleeping();
			}
			return !PlayersWithinDistance();
		}
		return true;
	}

	private bool AIZSleeping()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)zone != (Object)null)
		{
			if (!zone.PointInside(((Component)this).transform.position))
			{
				zone = AIInformationZone.GetForPoint(((Component)this).transform.position);
			}
		}
		else
		{
			zone = AIInformationZone.GetForPoint(((Component)this).transform.position);
		}
		if ((Object)(object)zone == (Object)null)
		{
			return false;
		}
		return zone.Sleeping;
	}

	private bool PlayersWithinDistance()
	{
		return AnyPlayersWithinDistance(playerDetectionOrigin, playerDetectionRadius, ignoreAboveGroundPlayers);
	}

	public static bool AnyPlayersWithinDistance(Transform origin, float radius, bool ignoreAboveGroundPlayers = false)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!current.IsSleeping() && current.IsAlive() && Vector3.Distance(((Component)current).transform.position, origin.position) < radius && (!ignoreAboveGroundPlayers || current.IsUnderground()))
				{
					return true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}

	public void ResetTick()
	{
		if (PassesResetCheck())
		{
			resetTimeElapsed += resetTickTime;
		}
		if (resetTimeElapsed > GetResetSpacing())
		{
			resetTimeElapsed = 0f;
			DoReset();
		}
	}

	public void CleanupSleepers()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)playerDetectionOrigin == (Object)null || BasePlayer.sleepingPlayerList == null)
		{
			return;
		}
		for (int num = BasePlayer.sleepingPlayerList.Count - 1; num >= 0; num--)
		{
			BasePlayer basePlayer = BasePlayer.sleepingPlayerList[num];
			if (!((Object)(object)basePlayer == (Object)null) && basePlayer.IsSleeping() && Vector3.Distance(((Component)basePlayer).transform.position, playerDetectionOrigin.position) <= playerDetectionRadius && (!ignoreAboveGroundPlayers || basePlayer.IsUnderground()))
			{
				basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
			}
		}
	}

	public void DoReset()
	{
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		CleanupSleepers();
		IOEntity component = ((Component)this).GetComponent<IOEntity>();
		if ((Object)(object)component != (Object)null)
		{
			ResetIOEntRecursive(component, Time.frameCount);
			component.MarkDirty();
		}
		else if (resetPositions != null)
		{
			Vector3[] array = resetPositions;
			foreach (Vector3 val in array)
			{
				Vector3 position = ((Component)this).transform.TransformPoint(val);
				List<IOEntity> list = Pool.Get<List<IOEntity>>();
				Vis.Entities(position, 0.5f, list, 1235288065, (QueryTriggerInteraction)1);
				foreach (IOEntity item in list)
				{
					if (item.IsRootEntity() && item.isServer)
					{
						ResetIOEntRecursive(item, Time.frameCount);
						item.MarkDirty();
					}
				}
				Pool.FreeUnmanaged<IOEntity>(ref list);
			}
		}
		List<SpawnGroup> list2 = Pool.Get<List<SpawnGroup>>();
		Vis.Components<SpawnGroup>(((Component)this).transform.position, 1f, list2, 262144, (QueryTriggerInteraction)2);
		foreach (SpawnGroup item2 in list2)
		{
			if (!((Object)(object)item2 == (Object)null))
			{
				item2.Clear();
				item2.DelayedSpawn();
			}
		}
		Pool.FreeUnmanaged<SpawnGroup>(ref list2);
		GameObject[] array2 = resetObjects;
		foreach (GameObject val2 in array2)
		{
			if ((Object)(object)val2 != (Object)null)
			{
				val2.SendMessage("OnPuzzleReset", (SendMessageOptions)1);
			}
		}
		if (!broadcastResetMessage)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator3 = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator3.MoveNext())
			{
				BasePlayer current3 = enumerator3.Current;
				if (!current3.IsNpc && current3.IsConnected && !current3.IsInTutorial)
				{
					current3.ShowToast(GameTip.Styles.Server_Event, resetPhrase, false);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator3/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void ResetIOEntRecursive(IOEntity target, int resetIndex)
	{
		if (target.lastResetIndex == resetIndex)
		{
			return;
		}
		target.lastResetIndex = resetIndex;
		target.ResetIOState();
		IOEntity.IOSlot[] outputs = target.outputs;
		foreach (IOEntity.IOSlot iOSlot in outputs)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null && (Object)(object)iOSlot.connectedTo.Get() != (Object)(object)target)
			{
				ResetIOEntRecursive(iOSlot.connectedTo.Get(), resetIndex);
			}
		}
	}
}


public class FrequencyConfig : IOConfig<IRFObject>
{
}


using UnityEngine;

public interface IRFObject
{
	Vector3 GetPosition();

	float GetMaxRange();

	void RFSignalUpdate(bool on);

	int GetFrequency();
}


using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class RFManager
{
	private static readonly Dictionary<int, HashSet<IRFObject>> _listeners = new Dictionary<int, HashSet<IRFObject>>();

	private static readonly Dictionary<int, HashSet<IRFObject>> _broadcasters = new Dictionary<int, HashSet<IRFObject>>();

	private static readonly Dictionary<int, bool> _isFrequencyBroadcasting = new Dictionary<int, bool>();

	public static int minFreq = 1;

	public static int maxFreq = 999999;

	private static int reserveRangeMin = 4760;

	private static int reserveRangeMax = 4790;

	public static Phrase reservedFrequencyPhrase = new Phrase("rf.reservedfrequency", "Channels {0} to {1} are restricted");

	public static int ClampFrequency(int freq)
	{
		return Mathf.Clamp(freq, minFreq, maxFreq);
	}

	public static HashSet<IRFObject> GetListenerSet(int frequency)
	{
		frequency = ClampFrequency(frequency);
		if (!_listeners.TryGetValue(frequency, out var value))
		{
			value = new HashSet<IRFObject>();
			_listeners[frequency] = value;
		}
		return value;
	}

	public static HashSet<IRFObject> GetBroadcasterSet(int frequency)
	{
		frequency = ClampFrequency(frequency);
		if (!_broadcasters.TryGetValue(frequency, out var value))
		{
			value = new HashSet<IRFObject>();
			_broadcasters[frequency] = value;
		}
		return value;
	}

	public static void AddListener(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfListenerAdd", (object)obj, (object)frequency) == null && GetListenerSet(frequency).Add(obj))
		{
			bool value;
			bool on = _isFrequencyBroadcasting.TryGetValue(frequency, out value) && value;
			obj.RFSignalUpdate(on);
			Interface.CallHook("OnRfListenerAdded", (object)obj, (object)frequency);
		}
	}

	public static void RemoveListener(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfListenerRemove", (object)obj, (object)frequency) == null && GetListenerSet(frequency).Remove(obj))
		{
			obj.RFSignalUpdate(on: false);
			Interface.CallHook("OnRfListenerRemoved", (object)obj, (object)frequency);
		}
	}

	public static void AddBroadcaster(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfBroadcasterAdd", (object)obj, (object)frequency) != null)
		{
			return;
		}
		HashSet<IRFObject> broadcasterSet = GetBroadcasterSet(frequency);
		if (broadcasterSet.RemoveWhere((IRFObject b) => b == null || !b.IsValidEntityReference()) > 0)
		{
			Debug.LogWarning((object)$"Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.");
		}
		if (broadcasterSet.Add(obj))
		{
			Interface.CallHook("OnRfBroadcasterAdded", (object)obj, (object)frequency);
			if (!_isFrequencyBroadcasting.TryGetValue(frequency, out var value) || !value)
			{
				_isFrequencyBroadcasting[frequency] = true;
				UpdateListenersForFrequency(frequency, isBroadcasting: true);
			}
		}
	}

	public static void RemoveBroadcaster(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfBroadcasterRemove", (object)obj, (object)frequency) != null)
		{
			return;
		}
		HashSet<IRFObject> broadcasterSet = GetBroadcasterSet(frequency);
		if (broadcasterSet.RemoveWhere((IRFObject b) => b == null || !b.IsValidEntityReference()) > 0)
		{
			Debug.LogWarning((object)$"Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.");
		}
		if (broadcasterSet.Remove(obj))
		{
			Interface.CallHook("OnRfBroadcasterRemoved", (object)obj, (object)frequency);
			if (broadcasterSet.Count == 0)
			{
				_isFrequencyBroadcasting[frequency] = false;
				UpdateListenersForFrequency(frequency, isBroadcasting: false);
			}
		}
	}

	private static void UpdateListenersForFrequency(int frequency, bool isBroadcasting)
	{
		HashSet<IRFObject> listenerSet = GetListenerSet(frequency);
		listenerSet.RemoveWhere((IRFObject l) => l == null || !l.IsValidEntityReference());
		foreach (IRFObject item in listenerSet)
		{
			item.RFSignalUpdate(isBroadcasting);
		}
	}

	public static bool IsReserved(int frequency)
	{
		if (frequency >= reserveRangeMin && frequency <= reserveRangeMax)
		{
			return true;
		}
		return false;
	}

	public static void ReserveErrorPrint(BasePlayer player)
	{
		player.ShowToast(GameTip.Styles.Error, reservedFrequencyPhrase, false, reserveRangeMin.ToString(), reserveRangeMax.ToString());
	}

	public static void ChangeFrequency(int oldFrequency, int newFrequency, IRFObject obj, bool isListener, bool isOn = true)
	{
		newFrequency = ClampFrequency(newFrequency);
		if (isListener)
		{
			RemoveListener(oldFrequency, obj);
			if (isOn)
			{
				AddListener(newFrequency, obj);
			}
		}
		else
		{
			RemoveBroadcaster(oldFrequency, obj);
			if (isOn)
			{
				AddBroadcaster(newFrequency, obj);
			}
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class BaseHuntEvent : BaseEntity
{
	public GameObjectRef[] HuntablePrefab;

	protected List<string> HuntableResourcePathCached;

	public AudioSource huntStartSound;

	public override void ServerInit()
	{
		base.ServerInit();
		HuntableResourcePathCached = new List<string>();
		for (int i = 0; i < HuntablePrefab.Length; i++)
		{
			HuntableResourcePathCached.Add(HuntablePrefab[i].resourcePath);
		}
	}
}


using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class CargoPlane : BaseEntity
{
	public GameObjectRef prefabDrop;

	public SpawnFilter filter;

	public Vector3 startPos;

	public Vector3 endPos;

	public float secondsToTake;

	public float secondsTaken;

	public bool dropped;

	public Vector3 dropPosition = Vector3.zero;

	public override void ServerInit()
	{
		base.ServerInit();
		Initialize();
	}

	public override void PostServerLoad()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		if (dropPosition == Vector3.zero)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (dropPosition == Vector3.zero)
		{
			dropPosition = RandomDropPosition();
		}
		UpdateDropPosition(dropPosition);
	}

	public void InitDropPosition(Vector3 newDropPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		dropPosition = newDropPosition;
		dropPosition.y = 0f;
	}

	public Vector3 RandomDropPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		float num = 100f;
		float x = TerrainMeta.Size.x;
		do
		{
			zero = Vector3Ex.Range(0f - x / 3f, x / 3f);
		}
		while (filter.GetFactor(zero) == 0f && (num -= 1f) > 0f);
		zero.y = 0f;
		return zero;
	}

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float y = TerrainMeta.HighestPoint.y + 250f;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		((Vector3)(ref startPos)).Normalize();
		startPos *= x * 2f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 50f;
		secondsToTake *= Random.Range(0.95f, 1.05f);
		((Component)this).transform.position = startPos;
		((Component)this).transform.rotation = Quaternion.LookRotation(endPos - startPos);
		dropPosition = newDropPosition;
		Interface.CallHook("OnAirdrop", (object)this, (object)newDropPosition);
	}

	private void Update()
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		secondsTaken += Time.deltaTime;
		float num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
		if (!dropped && num >= 0.5f)
		{
			dropped = true;
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, ((Component)this).transform.position);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.globalBroadcast = true;
				baseEntity.Spawn();
				Interface.CallHook("OnSupplyDropDropped", (object)baseEntity, (object)this);
			}
		}
		((Component)this).transform.position = Vector3.Lerp(startPos, endPos, num);
		((Component)this).transform.hasChanged = true;
		if (num >= 1f)
		{
			Kill();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (base.isServer && info.forDisk)
		{
			info.msg.cargoPlane = Pool.Get<CargoPlane>();
			info.msg.cargoPlane.startPos = startPos;
			info.msg.cargoPlane.endPos = endPos;
			info.msg.cargoPlane.secondsToTake = secondsToTake;
			info.msg.cargoPlane.secondsTaken = secondsTaken;
			info.msg.cargoPlane.dropped = dropped;
			info.msg.cargoPlane.dropPosition = dropPosition;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (base.isServer && info.fromDisk && info.msg.cargoPlane != null)
		{
			startPos = info.msg.cargoPlane.startPos;
			endPos = info.msg.cargoPlane.endPos;
			secondsToTake = info.msg.cargoPlane.secondsToTake;
			secondsTaken = info.msg.cargoPlane.secondsTaken;
			dropped = info.msg.cargoPlane.dropped;
			dropPosition = info.msg.cargoPlane.dropPosition;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class RoadBradleys : TriggeredEvent
{
	private List<BradleyAPC> spawnedAPCs = new List<BradleyAPC>();

	public static int StaticBradleyCount;

	public int GetNumBradleys()
	{
		CleanList();
		return spawnedAPCs.Count;
	}

	public int GetDesiredNumber()
	{
		return Mathf.CeilToInt((float)World.Size / 1000f) * 2;
	}

	private void CleanList()
	{
		for (int num = spawnedAPCs.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)spawnedAPCs[num] == (Object)null)
			{
				spawnedAPCs.RemoveAt(num);
			}
		}
	}

	public override void RunEvent()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		int numBradleys = GetNumBradleys();
		int num = GetDesiredNumber() - numBradleys;
		if (num <= 0 || (Object)(object)TerrainMeta.Path == (Object)null || TerrainMeta.Path.Roads.Count == 0)
		{
			return;
		}
		Debug.Log((object)"[event] assets/prefabs/npc/m2bradley/bradleyapc.prefab");
		Debug.Log((object)("Spawning :" + num + "Bradleys"));
		for (int i = 0; i < num; i++)
		{
			Vector3 zero = Vector3.zero;
			PathList pathList = TerrainMeta.Path.Roads[Random.Range(0, TerrainMeta.Path.Roads.Count)];
			zero = pathList.Path.Points[Random.Range(0, pathList.Path.Points.Length)];
			BradleyAPC bradleyAPC = BradleyAPC.SpawnRoadDrivingBradley(zero, Quaternion.identity);
			if (Object.op_Implicit((Object)(object)bradleyAPC))
			{
				spawnedAPCs.Add(bradleyAPC);
				continue;
			}
			Vector3 val = zero;
			Debug.Log((object)("Failed to spawn bradley at: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString()));
		}
		StaticBradleyCount = spawnedAPCs.Count;
	}

	public override void Kill()
	{
		base.Kill();
		foreach (BradleyAPC spawnedAPC in spawnedAPCs)
		{
			spawnedAPC.Kill();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using ConVar;
using Rust;
using UnityEngine;

public class EventSchedule : BaseMonoBehaviour
{
	[Tooltip("The minimum amount of hours between events")]
	public float minimumHoursBetween = 12f;

	[Tooltip("The maximum amount of hours between events")]
	public float maxmumHoursBetween = 24f;

	[Tooltip("ID to reference this event via convars")]
	public string Key;

	public static HashSet<EventSchedule> allEvents = new HashSet<EventSchedule>();

	public static HashSet<EventSchedule> enabledEvents = new HashSet<EventSchedule>();

	public float hoursRemaining;

	public long lastRun;

	[ServerVar(Name = "triggerevent")]
	public static void TriggerEvent(Arg arg)
	{
		string eventName = arg.GetString(0, "");
		string[] source = enabledEvents.Select((EventSchedule x) => x.GetName().ToLower()).ToArray();
		string[] array = (from x in source
			where StringEx.Contains(x, eventName, CompareOptions.IgnoreCase)
			select x.ToLower()).ToArray();
		if (string.IsNullOrEmpty(eventName) || array.Length == 0)
		{
			arg.ReplyWith("Unknown event - event list:\n\n" + string.Join("\n", source.Select(Path.GetFileNameWithoutExtension).ToArray()));
			return;
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(x, eventName, StringComparison.OrdinalIgnoreCase) == 0);
			if (text != null)
			{
				array[0] = text;
			}
		}
		foreach (EventSchedule enabledEvent in enabledEvents)
		{
			if (enabledEvent.GetName() == array[0])
			{
				enabledEvent.Trigger();
				arg.ReplyWith("Triggered " + enabledEvent.GetName());
			}
		}
	}

	[ServerVar(Name = "killallevents")]
	public static void KillAllEvents()
	{
		foreach (EventSchedule enabledEvent in enabledEvents)
		{
			TriggeredEvent[] components = ((Component)enabledEvent).GetComponents<TriggeredEvent>();
			for (int i = 0; i < components.Length; i++)
			{
				components[i].Kill();
			}
		}
	}

	public string GetName()
	{
		return Path.GetFileNameWithoutExtension(((Object)this).name);
	}

	private void Awake()
	{
		allEvents.Add(this);
		Events.UpdateScheduleFromConVars(this);
	}

	private void OnDestroy()
	{
		allEvents.Remove(this);
	}

	private void OnEnable()
	{
		hoursRemaining = Random.Range(minimumHoursBetween, maxmumHoursBetween);
		((FacepunchBehaviour)this).InvokeRepeating((Action)RunSchedule, 1f, 1f);
		enabledEvents.Add(this);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			enabledEvents.Remove(this);
			((FacepunchBehaviour)this).CancelInvoke((Action)RunSchedule);
		}
	}

	public virtual void RunSchedule()
	{
		if (!Application.isLoading && ConVar.Server.events)
		{
			CountHours();
			if (!(hoursRemaining > 0f))
			{
				Trigger();
			}
		}
	}

	private void Trigger()
	{
		hoursRemaining = Random.Range(minimumHoursBetween, maxmumHoursBetween);
		TriggeredEvent[] components = ((Component)this).GetComponents<TriggeredEvent>();
		if (components.Length != 0)
		{
			TriggeredEvent triggeredEvent = components[Random.Range(0, components.Length)];
			if (!((Object)(object)triggeredEvent == (Object)null))
			{
				triggeredEvent.RunEvent();
			}
		}
	}

	private void CountHours()
	{
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			if (lastRun != 0L)
			{
				hoursRemaining -= (float)TOD_Sky.Instance.Cycle.DateTime.Subtract(DateTime.FromBinary(lastRun)).TotalSeconds / 60f / 60f;
			}
			lastRun = TOD_Sky.Instance.Cycle.DateTime.ToBinary();
		}
	}
}


using UnityEngine;

public class EventScheduleWipeOffset : EventSchedule
{
	[ServerVar(Name = "event_hours_before_wipe")]
	public static float hoursBeforeWipeRealtime = 24f;

	public override void RunSchedule()
	{
		if (!((Object)(object)WipeTimer.serverinstance == (Object)null) && !(WipeTimer.serverinstance.GetTimeSpanUntilWipe().TotalHours > (double)hoursBeforeWipeRealtime))
		{
			base.RunSchedule();
		}
	}
}


using UnityEngine;

public class TriggeredEvent : MonoBehaviour
{
	public virtual void RunEvent()
	{
	}

	public virtual void Kill()
	{
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class TriggeredEventPrefab : TriggeredEvent
{
	public GameObjectRef targetPrefab;

	public bool shouldBroadcastSpawn;

	public Phrase spawnPhrase;

	public BaseEntity spawnedEntity;

	public override void RunEvent()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnEventTrigger", (object)this) != null)
		{
			return;
		}
		Debug.Log((object)("[event] " + targetPrefab.resourcePath));
		BaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);
		if (!Object.op_Implicit((Object)(object)baseEntity))
		{
			return;
		}
		((Component)baseEntity).SendMessage("TriggeredEventSpawn", (SendMessageOptions)1);
		baseEntity.Spawn();
		spawnedEntity = baseEntity;
		if (!shouldBroadcastSpawn)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (Object.op_Implicit((Object)(object)current) && current.IsConnected && !current.IsInTutorial)
				{
					current.ShowToast(GameTip.Styles.Server_Event, spawnPhrase, false);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public override void Kill()
	{
		if (!((Object)(object)spawnedEntity == (Object)null))
		{
			base.Kill();
			spawnedEntity.Kill();
			spawnedEntity = null;
			Debug.Log((object)("Killed " + ((Object)this).name));
		}
	}
}


using System;
using UnityEngine;

public class TravellingVendorEvent : TriggeredEvent
{
	public Phrase spawnPhrase;

	public static TravellingVendor currentVendor = null;

	public static float dontSpawnHoursBeforeWipe = 24f;

	public override void RunEvent()
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)currentVendor != (Object)null || (Object)(object)TerrainMeta.Path == (Object)null || TerrainMeta.Path.Roads.Count == 0 || !TravellingVendor.should_spawn || RoadBradleys.StaticBradleyCount > 0)
		{
			return;
		}
		TravellingVendor travellingVendor = TravellingVendor.SpawnTravellingVendorForEvent();
		if (Object.op_Implicit((Object)(object)travellingVendor))
		{
			Debug.Log((object)"[event] assets/prefabs/npc/travelling vendor/travellingvendor.prefab");
			currentVendor = travellingVendor;
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if (Object.op_Implicit((Object)(object)current) && current.IsConnected && !current.IsInTutorial)
					{
						current.ShowToast(GameTip.Styles.Server_Event, spawnPhrase, false);
					}
				}
				return;
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		Debug.Log((object)"Failed to spawn travelling vendor.");
	}

	private bool HoursCheck()
	{
		if (WipeTimer.serverinstance.GetTimeSpanUntilWipe().TotalHours > (double)dontSpawnHoursBeforeWipe)
		{
			return true;
		}
		return false;
	}
}


using System;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using CompanionServer;
using CompanionServer.Handlers;
using ConVar;
using Development.Attributes;
using Facepunch;
using Facepunch.Network;
using Facepunch.Network.Raknet;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Facepunch.Utility;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Ai;
using Rust.UI;
using UnityEngine;
using UnityEngine.AI;

[ResetStaticFields]
public class Bootstrap : SingletonComponent<Bootstrap>
{
	internal static bool bootstrapInitRun;

	public static bool isErrored;

	public Phrase currentLoadingPhrase;

	public CanvasGroup BootstrapUiCanvas;

	public GameObject errorPanel;

	public RustText errorText;

	public RustText statusText;

	private Phrase openingBundles = new Phrase("bootstrap.openingbundles", "Opening Bundles");

	private static string lastWrittenValue;

	public static bool needsSetup => !bootstrapInitRun;

	public static bool isPresent
	{
		get
		{
			if (bootstrapInitRun)
			{
				return true;
			}
			if (Object.FindObjectsOfType<GameSetup>().Count() > 0)
			{
				return true;
			}
			return false;
		}
	}

	public static void RunDefaults()
	{
		Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
		Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;
		Application.targetFrameRate = 256;
		Time.fixedDeltaTime = 0.0625f;
		Time.maximumDeltaTime = 0.125f;
	}

	public static void Init_Tier0()
	{
		RunDefaults();
		GameSetup.RunOnce = true;
		bootstrapInitRun = true;
		Index.Initialize(ConsoleGen.All);
		Index.Reset();
		UnityButtons.Register();
		Output.Install();
		Pool.ResizeBuffer<NetRead>(16384);
		Pool.ResizeBuffer<NetWrite>(16384);
		Pool.ResizeBuffer<Networkable>(65536);
		Pool.ResizeBuffer<EntityLink>(65536);
		Pool.ResizeBuffer<EventRecord>(16384);
		Pool.ResizeBuffer<SellOrder>(2048);
		Pool.FillBuffer<Networkable>();
		Pool.FillBuffer<EntityLink>();
		if (CommandLine.HasSwitch("-nonetworkthread"))
		{
			BaseNetwork.Multithreading = false;
		}
		SteamNetworking.SetDebugFunction();
		if (CommandLine.HasSwitch("-swnet"))
		{
			NetworkInitSteamworks(enableSteamDatagramRelay: false);
		}
		else if (CommandLine.HasSwitch("-sdrnet"))
		{
			NetworkInitSteamworks(enableSteamDatagramRelay: true);
		}
		else if (CommandLine.HasSwitch("-raknet"))
		{
			NetworkInitRaknet();
		}
		else
		{
			NetworkInitRaknet();
		}
		if (!Application.isEditor)
		{
			string text = CommandLine.Full.Replace(CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", "RCONPASSWORD")), "******");
			WriteToLog("Command Line: " + text);
		}
		Interface.Initialize();
		int parentProcessId = CommandLine.GetSwitchInt("-parent-pid", 0);
		if (parentProcessId != 0)
		{
			try
			{
				SynchronizationContext syncContext = SynchronizationContext.Current;
				Process processById = Process.GetProcessById(parentProcessId);
				processById.EnableRaisingEvents = true;
				processById.Exited += delegate
				{
					syncContext.Post(delegate
					{
						//IL_001a: Unknown result type (might be due to invalid IL or missing references)
						WriteToLog($"Parent process ID {parentProcessId} exited. Exiting the server now...");
						ConsoleSystem.Run(Option.Server, "quit", Array.Empty<object>());
					}, null);
				};
				WriteToLog($"Watching parent process ID {parentProcessId}...");
			}
			catch (ArgumentException)
			{
				WriteToLog($"Parent process ID {parentProcessId} has exited during boot! Exiting now...");
				Application.Quit();
			}
		}
		UnityHookHandler.EnsureCreated();
	}

	public static void Init_Systems()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Expected O, but got Unknown
		Global.Init();
		Translate.Init();
		Integration val = new Integration();
		val.OnManifestUpdated += CpuAffinity.Apply;
		Application.Initialize((BaseIntegration)val);
		Performance.GetMemoryUsage = () => SystemInfoEx.systemMemoryUsed;
	}

	public static void Init_Config()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		ConsoleNetwork.Init();
		ConsoleSystem.UpdateValuesFromCommandLine();
		ConsoleSystem.Run(Option.Server, "server.readcfg", Array.Empty<object>());
		ServerUsers.Load();
		if (string.IsNullOrEmpty(ConVar.Server.server_id))
		{
			ConVar.Server.server_id = Guid.NewGuid().ToString("N");
			ConsoleSystem.Run(Option.Server, "server.writecfg", Array.Empty<object>());
		}
		if (CommandLine.HasSwitch("-disable-server-occlusion"))
		{
			ServerOcclusion.OcclusionEnabled = false;
			ServerOcclusion.OcclusionIncludeRocks = false;
		}
		if (CommandLine.HasSwitch("-disable-server-occlusion-rocks"))
		{
			ServerOcclusion.OcclusionIncludeRocks = false;
		}
		HttpManager.UpdateMaxConnections();
		if (!RuntimeProfiler.runtime_profiling_persist)
		{
			RuntimeProfiler.Disable();
		}
	}

	public static void NetworkInitRaknet()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Expected O, but got Unknown
		Net.sv = (Server)new Server();
	}

	public static void NetworkInitSteamworks(bool enableSteamDatagramRelay)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		Net.sv = (Server)new Server(enableSteamDatagramRelay);
	}

	private IEnumerator Start()
	{
		WriteToLog("Bootstrap Startup");
		EarlyInitialize();
		BenchmarkTimer.Enabled = CommandLine.Full.Contains("+autobench");
		Stopwatch timer = BenchmarkTimer.Get("bootstrap");
		timer?.Start();
		if (!Application.isEditor)
		{
			BuildInfo current = BuildInfo.Current;
			if ((current.Scm.Branch == null || !(current.Scm.Branch == "experimental/release")) && !(current.Scm.Branch == "release"))
			{
				ExceptionReporter.InitializeFromUrl("https://0654eb77d1e04d6babad83201b6b6b95:d2098f1d15834cae90501548bd5dbd0d@sentry.io/1836389");
			}
			else
			{
				ExceptionReporter.InitializeFromUrl("https://83df169465e84da091c1a3cd2fbffeee:3671b903f9a840ecb68411cf946ab9b6@sentry.io/51080");
			}
			bool num = CommandLine.Full.Contains("-official") || CommandLine.Full.Contains("-server.official") || CommandLine.Full.Contains("+official") || CommandLine.Full.Contains("+server.official");
			bool flag = CommandLine.Full.Contains("-stats") || CommandLine.Full.Contains("-server.stats") || CommandLine.Full.Contains("+stats") || CommandLine.Full.Contains("+server.stats");
			ExceptionReporter.Disabled = !(num && flag);
		}
		Scope val;
		Scope val2;
		if (AssetBundleBackend.Enabled)
		{
			AssetBundleBackend newBackend = new AssetBundleBackend();
			val = BenchmarkTimer.Measure("bootstrap;bundles");
			try
			{
				yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(openingBundles));
				newBackend.Load("Bundles/Bundles");
				FileSystem.Backend = (FileSystemBackend)(object)newBackend;
			}
			finally
			{
				((IDisposable)(Scope)(ref val)/*cast due to .constrained prefix*/).Dispose();
			}
			val = default(Scope);
			if (FileSystem.Backend.isError)
			{
				ThrowError(FileSystem.Backend.loadingError);
				yield break;
			}
			val2 = BenchmarkTimer.Measure("bootstrap;bundlesindex");
			try
			{
				newBackend.BuildFileIndex();
			}
			finally
			{
				((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
			}
			while (true)
			{
				if (FileSystem.Backend.isError)
				{
					ThrowError(FileSystem.Backend.loadingError);
					yield break;
				}
				float assetSceneProgress = newBackend.GetAssetSceneProgress("AssetScene-bootstrap");
				if (assetSceneProgress >= 1f)
				{
					break;
				}
				yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit($"Loading Menu Prefabs {assetSceneProgress * 100f:0.0}%")));
			}
		}
		if (FileSystem.Backend.isError)
		{
			ThrowError(FileSystem.Backend.loadingError);
			yield break;
		}
		if (!Application.isEditor)
		{
			WriteToLog(SystemInfoGeneralText.currentInfo);
		}
		Texture.SetGlobalAnisotropicFilteringLimits(1, 16);
		QualitySettings.streamingMipmapsActive = false;
		QualitySettings.streamingMipmapsActive = false;
		if (isErrored)
		{
			yield break;
		}
		val = BenchmarkTimer.Measure("bootstrap;gamemanifest");
		try
		{
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Loading Game Manifest")));
			GameManifest.Load();
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("DONE!")));
		}
		finally
		{
			((IDisposable)(Scope)(ref val)/*cast due to .constrained prefix*/).Dispose();
		}
		val = default(Scope);
		val = BenchmarkTimer.Measure("bootstrap;selfcheck");
		try
		{
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Running Self Check")));
			SelfCheck.Run();
		}
		finally
		{
			((IDisposable)(Scope)(ref val)/*cast due to .constrained prefix*/).Dispose();
		}
		val = default(Scope);
		if (isErrored)
		{
			yield break;
		}
		yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Bootstrap Tier0")));
		val2 = BenchmarkTimer.Measure("bootstrap;tier0");
		try
		{
			Init_Tier0();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		val2 = BenchmarkTimer.Measure("bootstrap;commandlinevalues");
		try
		{
			ConsoleSystem.UpdateValuesFromCommandLine();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Bootstrap Systems")));
		val2 = BenchmarkTimer.Measure("bootstrap;init_systems");
		try
		{
			Init_Systems();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Bootstrap Config")));
		val2 = BenchmarkTimer.Measure("bootstrap;init_config");
		try
		{
			Init_Config();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		val2 = BenchmarkTimer.Measure("bootstrap;commandlinevalues2");
		try
		{
			ConsoleSystem.UpdateValuesFromCommandLine();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		if (!isErrored)
		{
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Loading Items")));
			val2 = BenchmarkTimer.Measure("bootstrap;itemmanager");
			try
			{
				ItemManager.Initialize();
			}
			finally
			{
				((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
			}
			if (!isErrored)
			{
				yield return ((MonoBehaviour)this).StartCoroutine(DedicatedServerStartup());
				timer?.Stop();
				GameManager.Destroy(((Component)this).gameObject);
			}
		}
	}

	private IEnumerator DedicatedServerStartup()
	{
		Application.isLoading = true;
		Application.backgroundLoadingPriority = (ThreadPriority)4;
		WriteToLog("Skinnable Warmup");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		GameManifest.LoadAssets();
		WriteToLog("Initializing Nexus");
		yield return ((MonoBehaviour)this).StartCoroutine(StartNexusServer());
		WriteToLog("Loading Scene");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		Physics.defaultSolverIterations = 3;
		int @int = PlayerPrefs.GetInt("UnityGraphicsQuality");
		QualitySettings.SetQualityLevel(0);
		PlayerPrefs.SetInt("UnityGraphicsQuality", @int);
		Object.DontDestroyOnLoad((Object)(object)((Component)this).gameObject);
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/server_console.prefab"));
		StartupShared();
		World.InitSize(ConVar.Server.worldsize);
		World.InitSeed(ConVar.Server.seed);
		World.InitSalt(ConVar.Server.salt);
		World.Url = ConVar.Server.levelurl;
		World.Transfer = ConVar.Server.leveltransfer;
		yield return LevelManager.LoadLevelAsync(ConVar.Server.level);
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return ((MonoBehaviour)this).StartCoroutine(FileSystem_Warmup.Run(WriteToLog, "Asset Warmup ({0}/{1})"));
		yield return ((MonoBehaviour)this).StartCoroutine(StartServer(!CommandLine.HasSwitch("-skipload"), "", allowOutOfDateSaves: false));
		if (!Object.op_Implicit((Object)(object)Object.FindObjectOfType<Performance>()))
		{
			Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/performance.prefab"));
		}
		Rust.GC.Collect();
		Application.isLoading = false;
	}

	private static void EnsureRootFolderCreated()
	{
		try
		{
			Directory.CreateDirectory(ConVar.Server.rootFolder);
		}
		catch (Exception arg)
		{
			Debug.LogWarning((object)$"Failed to automatically create the save directory: {ConVar.Server.rootFolder}\n\n{arg}");
		}
	}

	public static IEnumerator StartNexusServer()
	{
		EnsureRootFolderCreated();
		yield return NexusServer.Initialize();
		if (NexusServer.FailedToStart)
		{
			Debug.LogError((object)"Nexus server failed to start, terminating");
			Application.Quit();
		}
	}

	public static IEnumerator StartServer(bool doLoad, string saveFileOverride, bool allowOutOfDateSaves)
	{
		float timeScale = Time.timeScale;
		if (ConVar.Time.pausewhileloading)
		{
			Time.timeScale = 0f;
		}
		RCon.Initialize();
		BaseEntity.Query.Server = new BaseEntity.Query.EntityTree(8096f);
		EnsureRootFolderCreated();
		if (Object.op_Implicit((Object)(object)SingletonComponent<WorldSetup>.Instance))
		{
			yield return ((MonoBehaviour)SingletonComponent<WorldSetup>.Instance).StartCoroutine(SingletonComponent<WorldSetup>.Instance.InitCoroutine());
		}
		if (Object.op_Implicit((Object)(object)SingletonComponent<DynamicNavMesh>.Instance) && ((Behaviour)SingletonComponent<DynamicNavMesh>.Instance).enabled && !AiManager.nav_disable)
		{
			yield return ((MonoBehaviour)SingletonComponent<DynamicNavMesh>.Instance).StartCoroutine(SingletonComponent<DynamicNavMesh>.Instance.UpdateNavMeshAndWait());
		}
		if (Object.op_Implicit((Object)(object)SingletonComponent<AiManager>.Instance) && ((Behaviour)SingletonComponent<AiManager>.Instance).enabled)
		{
			SingletonComponent<AiManager>.Instance.Initialize();
			if (!AiManager.nav_disable && AI.npc_enable && (Object)(object)TerrainMeta.Path != (Object)null)
			{
				foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
				{
					if (monument.HasNavmesh)
					{
						yield return ((MonoBehaviour)monument).StartCoroutine(monument.GetMonumentNavMesh().UpdateNavMeshAndWait());
					}
				}
				if (Object.op_Implicit((Object)(object)TerrainMeta.Path) && World.SpawnedPrefabs.TryGetValue("Dungeon", out var value))
				{
					DungeonNavmesh dungeonNavmesh = new GameObject("DungeonGridNavMesh").AddComponent<DungeonNavmesh>();
					dungeonNavmesh.NavMeshCollectGeometry = (NavMeshCollectGeometry)1;
					dungeonNavmesh.LayerMask = LayerMask.op_Implicit(65537);
					yield return ((MonoBehaviour)dungeonNavmesh).StartCoroutine(dungeonNavmesh.UpdateNavMeshAndWait(value));
				}
				else
				{
					Debug.LogWarning((object)"Failed to find DungeonGridRoot, NOT generating Dungeon navmesh");
				}
				if (Object.op_Implicit((Object)(object)TerrainMeta.Path) && World.SpawnedPrefabs.TryGetValue("DungeonBase", out var value2))
				{
					DungeonNavmesh dungeonNavmesh2 = new GameObject("DungeonBaseNavMesh").AddComponent<DungeonNavmesh>();
					dungeonNavmesh2.NavmeshResolutionModifier = 0.3f;
					dungeonNavmesh2.NavMeshCollectGeometry = (NavMeshCollectGeometry)1;
					dungeonNavmesh2.LayerMask = LayerMask.op_Implicit(65537);
					yield return ((MonoBehaviour)dungeonNavmesh2).StartCoroutine(dungeonNavmesh2.UpdateNavMeshAndWait(value2));
				}
				else
				{
					Debug.LogWarning((object)"Failed to find DungeonBaseRoot , NOT generating Dungeon navmesh");
				}
				GenerateDungeonBase.SetupAI();
			}
		}
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/shared.prefab"));
		GameObject val = GameManager.server.CreatePrefab("assets/bundled/prefabs/system/server.prefab");
		Object.DontDestroyOnLoad((Object)(object)val);
		ServerMgr serverMgr = val.GetComponent<ServerMgr>();
		bool saveWasLoaded = serverMgr.Initialize(doLoad, saveFileOverride, allowOutOfDateSaves);
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.InitializeEntityLinks();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.InitializeEntitySupports();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.InitializeEntityConditionals();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.GetSaveCache();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		BaseGameMode.CreateGameMode();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		MissionManifest.Get();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		if (Clan.enabled)
		{
			ClanManager clanManager = ClanManager.ServerInstance;
			if ((Object)(object)clanManager == (Object)null)
			{
				Debug.LogError((object)"ClanManager was not spawned!");
				Application.Quit();
				yield break;
			}
			Task initializeTask = clanManager.Initialize();
			yield return (object)new WaitUntil((Func<bool>)(() => initializeTask.IsCompleted));
			initializeTask.Wait();
			clanManager.LoadClanInfoForSleepers();
		}
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		if (ServerOcclusion.OcclusionEnabled)
		{
			ServerOcclusion.SetupGrid();
		}
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		if (NexusServer.Started)
		{
			NexusServer.UploadMapImage();
			if (saveWasLoaded)
			{
				NexusServer.RestoreUnsavedState();
			}
			NexusServer.ZoneClient.StartListening();
		}
		if (ConVar.Server.autoUploadMap)
		{
			Task uploadTask = MapUploader.UploadMap();
			while (!uploadTask.IsCompleted)
			{
				yield return null;
			}
			if (!uploadTask.IsCompletedSuccessfully)
			{
				Debug.LogError((object)"Failed to upload map file:");
				Debug.LogException((Exception)uploadTask.Exception);
			}
		}
		serverMgr.OpenConnection();
		CompanionServer.Server.Initialize();
		if (ConVar.Server.autoUploadMapImages && Map.ImageData != null)
		{
			MapUploader.UploadMapImage(Map.ImageData);
		}
		Scope val2 = BenchmarkTimer.Measure("Boombox.LoadStations");
		try
		{
			BoomBox.LoadStations();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		RustEmojiLibrary.FindAllServerEmoji();
		if (ConVar.Time.pausewhileloading)
		{
			Time.timeScale = timeScale;
		}
		WriteToLog("Server startup complete");
		Application.isServerStarted = true;
	}

	private void StartupShared()
	{
		Interface.CallHook("InitLogging");
		ItemManager.Initialize();
	}

	public bool RetrySteam()
	{
		if (!CommandLine.HasSwitch("-nosteam"))
		{
			return !PlatformService.Initialize((IPlatformHooks)(object)RustPlatformHooks.Instance);
		}
		return true;
	}

	public void ThrowError(string error)
	{
		isErrored = true;
	}

	public void ClearError()
	{
		isErrored = false;
	}

	public void ThrowSteamError()
	{
		isErrored = true;
	}

	public void ExitGame()
	{
		Debug.Log((object)"Exiting due to Exit Game button on bootstrap error panel");
		Application.Quit();
	}

	public static IEnumerator LoadingUpdate(Phrase phrase)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Bootstrap>.Instance))
		{
			SingletonComponent<Bootstrap>.Instance.currentLoadingPhrase = phrase;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
		}
	}

	public static void WriteToLog(string str)
	{
		if (!(lastWrittenValue == str))
		{
			DebugEx.Log((object)str, (StackTraceLogType)0);
			lastWrittenValue = str;
		}
	}

	private static void EarlyInitialize()
	{
	}
}


using System;
using System.Runtime.InteropServices;
using Facepunch;
using UnityEngine;

public static class SelfCheck
{
	public static bool Run()
	{
		if (FileSystem.Backend.isError)
		{
			return Failed("Asset Bundle Error: " + FileSystem.Backend.loadingError);
		}
		if ((Object)(object)FileSystem.Load<GameManifest>("Assets/manifest.asset", true) == (Object)null)
		{
			return Failed("Couldn't load game manifest - verify your game content!");
		}
		if (!TestRustNative())
		{
			return false;
		}
		if (CommandLine.HasSwitch("-force-feature-level-9-3"))
		{
			return Failed("Invalid command line argument: -force-feature-level-9-3");
		}
		if (CommandLine.HasSwitch("-force-feature-level-10-0"))
		{
			return Failed("Invalid command line argument: -force-feature-level-10-0");
		}
		if (CommandLine.HasSwitch("-force-feature-level-10-1"))
		{
			return Failed("Invalid command line argument: -force-feature-level-10-1");
		}
		return true;
	}

	private static bool Failed(string Message)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Bootstrap>.Instance))
		{
			SingletonComponent<Bootstrap>.Instance.currentLoadingPhrase = null;
			SingletonComponent<Bootstrap>.Instance.ThrowError(Message);
		}
		Debug.LogError((object)("SelfCheck Failed: " + Message));
		return false;
	}

	private static bool TestRustNative()
	{
		try
		{
			if (!RustNative_VersionCheck(5))
			{
				return Failed("RustNative is wrong version!");
			}
		}
		catch (DllNotFoundException ex)
		{
			return Failed("RustNative library couldn't load! " + ex.Message);
		}
		return true;
	}

	[DllImport("RustNative")]
	private static extern bool RustNative_VersionCheck(int version);
}


using UnityEngine;

public class BuildingBlockedGuide : MonoBehaviour
{
	public Mesh BoxMesh;

	public Mesh SphereMesh;

	public Mesh CapsuleMesh;

	public MeshRenderer Renderer;

	public MeshFilter Filter;

	public Collider LargestVolume;

	public float OverrideEnableDistance;
}


using ConVar;
using Development.Attributes;
using UnityEngine;
using UnityEngine.AI;

[ResetStaticFields]
public abstract class BuildingManager
{
	public class Building
	{
		public uint ID;

		public ListHashSet<BuildingPrivlidge> buildingPrivileges = new ListHashSet<BuildingPrivlidge>();

		public ListHashSet<BuildingBlock> buildingBlocks = new ListHashSet<BuildingBlock>();

		public ListHashSet<DecayEntity> decayEntities = new ListHashSet<DecayEntity>();

		public ListHashSet<Door> doors = new ListHashSet<Door>();

		public NavMeshObstacle buildingNavMeshObstacle;

		public ListHashSet<NavMeshObstacle> navmeshCarvers;

		public bool isNavMeshCarvingDirty;

		public bool isNavMeshCarveOptimized;

		public bool IsEmpty()
		{
			if (HasBuildingPrivileges())
			{
				return false;
			}
			if (HasBuildingBlocks())
			{
				return false;
			}
			if (HasDecayEntities())
			{
				return false;
			}
			return true;
		}

		public BuildingPrivlidge GetDominatingBuildingPrivilege()
		{
			BuildingPrivlidge buildingPrivlidge = null;
			if (HasBuildingPrivileges())
			{
				for (int i = 0; i < buildingPrivileges.Count; i++)
				{
					BuildingPrivlidge buildingPrivlidge2 = buildingPrivileges[i];
					if (!((Object)(object)buildingPrivlidge2 == (Object)null) && buildingPrivlidge2.IsOlderThan(buildingPrivlidge))
					{
						buildingPrivlidge = buildingPrivlidge2;
					}
				}
			}
			return buildingPrivlidge;
		}

		public bool HasBuildingPrivileges()
		{
			if (buildingPrivileges != null)
			{
				return buildingPrivileges.Count > 0;
			}
			return false;
		}

		public bool HasBuildingBlocks()
		{
			if (buildingBlocks != null)
			{
				return buildingBlocks.Count > 0;
			}
			return false;
		}

		public bool HasDecayEntities()
		{
			if (decayEntities != null)
			{
				return decayEntities.Count > 0;
			}
			return false;
		}

		public void AddBuildingPrivilege(BuildingPrivlidge ent)
		{
			if (!((Object)(object)ent == (Object)null) && !buildingPrivileges.Contains(ent))
			{
				buildingPrivileges.Add(ent);
			}
		}

		public void RemoveBuildingPrivilege(BuildingPrivlidge ent)
		{
			if (!((Object)(object)ent == (Object)null))
			{
				buildingPrivileges.Remove(ent);
			}
		}

		public void AddBuildingBlock(BuildingBlock ent)
		{
			if ((Object)(object)ent == (Object)null || buildingBlocks.Contains(ent))
			{
				return;
			}
			buildingBlocks.Add(ent);
			if (!AI.nav_carve_use_building_optimization)
			{
				return;
			}
			NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
			if ((Object)(object)component != (Object)null)
			{
				isNavMeshCarvingDirty = true;
				if (navmeshCarvers == null)
				{
					navmeshCarvers = new ListHashSet<NavMeshObstacle>();
				}
				navmeshCarvers.Add(component);
			}
		}

		public void RemoveBuildingBlock(BuildingBlock ent)
		{
			if ((Object)(object)ent == (Object)null)
			{
				return;
			}
			buildingBlocks.Remove(ent);
			if (!AI.nav_carve_use_building_optimization || navmeshCarvers == null)
			{
				return;
			}
			NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
			if (!((Object)(object)component != (Object)null))
			{
				return;
			}
			navmeshCarvers.Remove(component);
			if (navmeshCarvers.Count == 0)
			{
				navmeshCarvers = null;
			}
			isNavMeshCarvingDirty = true;
			if (navmeshCarvers == null)
			{
				Building building = ent.GetBuilding();
				if (building != null)
				{
					int ticks = 2;
					server.UpdateNavMeshCarver(building, ref ticks, 0);
				}
			}
		}

		public void AddDecayEntity(DecayEntity ent)
		{
			if (!((Object)(object)ent == (Object)null))
			{
				if (!decayEntities.Contains(ent))
				{
					decayEntities.Add(ent);
				}
				if (ent is Door door && !doors.Contains(door))
				{
					doors.Add(ent as Door);
				}
			}
		}

		public void RemoveDecayEntity(DecayEntity ent)
		{
			if (!((Object)(object)ent == (Object)null))
			{
				decayEntities.Remove(ent);
				if (ent is Door door)
				{
					doors.Remove(door);
				}
			}
		}

		public void Add(DecayEntity ent)
		{
			AddDecayEntity(ent);
			AddBuildingBlock(ent as BuildingBlock);
			AddBuildingPrivilege(ent as BuildingPrivlidge);
		}

		public void Remove(DecayEntity ent)
		{
			RemoveDecayEntity(ent);
			RemoveBuildingBlock(ent as BuildingBlock);
			RemoveBuildingPrivilege(ent as BuildingPrivlidge);
		}

		public void Dirty()
		{
			BuildingPrivlidge dominatingBuildingPrivilege = GetDominatingBuildingPrivilege();
			if ((Object)(object)dominatingBuildingPrivilege != (Object)null)
			{
				dominatingBuildingPrivilege.BuildingDirty();
			}
		}
	}

	public static ServerBuildingManager server = new ServerBuildingManager();

	public ListHashSet<DecayEntity> decayEntities = new ListHashSet<DecayEntity>();

	public ListDictionary<uint, Building> buildingDictionary = new ListDictionary<uint, Building>();

	public Building GetBuilding(uint buildingID)
	{
		Building result = null;
		buildingDictionary.TryGetValue(buildingID, ref result);
		return result;
	}

	public void Add(DecayEntity ent)
	{
		if (ent.buildingID == 0)
		{
			if (!decayEntities.Contains(ent))
			{
				decayEntities.Add(ent);
			}
			return;
		}
		Building building = GetBuilding(ent.buildingID);
		if (building == null)
		{
			building = CreateBuilding(ent.buildingID);
			buildingDictionary.Add(ent.buildingID, building);
		}
		building.Add(ent);
		building.Dirty();
	}

	public void Remove(DecayEntity ent)
	{
		if (ent.buildingID == 0)
		{
			decayEntities.Remove(ent);
			return;
		}
		Building building = GetBuilding(ent.buildingID);
		if (building != null)
		{
			building.Remove(ent);
			if (building.IsEmpty())
			{
				buildingDictionary.Remove(ent.buildingID);
				DisposeBuilding(ref building);
			}
			else
			{
				building.Dirty();
			}
		}
	}

	public void Clear()
	{
		buildingDictionary.Clear();
	}

	protected abstract Building CreateBuilding(uint id);

	protected abstract void DisposeBuilding(ref Building building);
}


using ConVar;
using UnityEngine;
using UnityEngine.AI;

public class Building
{
	public uint ID;

	public ListHashSet<BuildingPrivlidge> buildingPrivileges = new ListHashSet<BuildingPrivlidge>();

	public ListHashSet<BuildingBlock> buildingBlocks = new ListHashSet<BuildingBlock>();

	public ListHashSet<DecayEntity> decayEntities = new ListHashSet<DecayEntity>();

	public ListHashSet<Door> doors = new ListHashSet<Door>();

	public NavMeshObstacle buildingNavMeshObstacle;

	public ListHashSet<NavMeshObstacle> navmeshCarvers;

	public bool isNavMeshCarvingDirty;

	public bool isNavMeshCarveOptimized;

	public bool IsEmpty()
	{
		if (HasBuildingPrivileges())
		{
			return false;
		}
		if (HasBuildingBlocks())
		{
			return false;
		}
		if (HasDecayEntities())
		{
			return false;
		}
		return true;
	}

	public BuildingPrivlidge GetDominatingBuildingPrivilege()
	{
		BuildingPrivlidge buildingPrivlidge = null;
		if (HasBuildingPrivileges())
		{
			for (int i = 0; i < buildingPrivileges.Count; i++)
			{
				BuildingPrivlidge buildingPrivlidge2 = buildingPrivileges[i];
				if (!((Object)(object)buildingPrivlidge2 == (Object)null) && buildingPrivlidge2.IsOlderThan(buildingPrivlidge))
				{
					buildingPrivlidge = buildingPrivlidge2;
				}
			}
		}
		return buildingPrivlidge;
	}

	public bool HasBuildingPrivileges()
	{
		if (buildingPrivileges != null)
		{
			return buildingPrivileges.Count > 0;
		}
		return false;
	}

	public bool HasBuildingBlocks()
	{
		if (buildingBlocks != null)
		{
			return buildingBlocks.Count > 0;
		}
		return false;
	}

	public bool HasDecayEntities()
	{
		if (decayEntities != null)
		{
			return decayEntities.Count > 0;
		}
		return false;
	}

	public void AddBuildingPrivilege(BuildingPrivlidge ent)
	{
		if (!((Object)(object)ent == (Object)null) && !buildingPrivileges.Contains(ent))
		{
			buildingPrivileges.Add(ent);
		}
	}

	public void RemoveBuildingPrivilege(BuildingPrivlidge ent)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			buildingPrivileges.Remove(ent);
		}
	}

	public void AddBuildingBlock(BuildingBlock ent)
	{
		if ((Object)(object)ent == (Object)null || buildingBlocks.Contains(ent))
		{
			return;
		}
		buildingBlocks.Add(ent);
		if (!AI.nav_carve_use_building_optimization)
		{
			return;
		}
		NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
		if ((Object)(object)component != (Object)null)
		{
			isNavMeshCarvingDirty = true;
			if (navmeshCarvers == null)
			{
				navmeshCarvers = new ListHashSet<NavMeshObstacle>();
			}
			navmeshCarvers.Add(component);
		}
	}

	public void RemoveBuildingBlock(BuildingBlock ent)
	{
		if ((Object)(object)ent == (Object)null)
		{
			return;
		}
		buildingBlocks.Remove(ent);
		if (!AI.nav_carve_use_building_optimization || navmeshCarvers == null)
		{
			return;
		}
		NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
		if (!((Object)(object)component != (Object)null))
		{
			return;
		}
		navmeshCarvers.Remove(component);
		if (navmeshCarvers.Count == 0)
		{
			navmeshCarvers = null;
		}
		isNavMeshCarvingDirty = true;
		if (navmeshCarvers == null)
		{
			Building building = ent.GetBuilding();
			if (building != null)
			{
				int ticks = 2;
				server.UpdateNavMeshCarver(building, ref ticks, 0);
			}
		}
	}

	public void AddDecayEntity(DecayEntity ent)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			if (!decayEntities.Contains(ent))
			{
				decayEntities.Add(ent);
			}
			if (ent is Door door && !doors.Contains(door))
			{
				doors.Add(ent as Door);
			}
		}
	}

	public void RemoveDecayEntity(DecayEntity ent)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			decayEntities.Remove(ent);
			if (ent is Door door)
			{
				doors.Remove(door);
			}
		}
	}

	public void Add(DecayEntity ent)
	{
		AddDecayEntity(ent);
		AddBuildingBlock(ent as BuildingBlock);
		AddBuildingPrivilege(ent as BuildingPrivlidge);
	}

	public void Remove(DecayEntity ent)
	{
		RemoveDecayEntity(ent);
		RemoveBuildingBlock(ent as BuildingBlock);
		RemoveBuildingPrivilege(ent as BuildingPrivlidge);
	}

	public void Dirty()
	{
		BuildingPrivlidge dominatingBuildingPrivilege = GetDominatingBuildingPrivilege();
		if ((Object)(object)dominatingBuildingPrivilege != (Object)null)
		{
			dominatingBuildingPrivilege.BuildingDirty();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using UnityEngine;
using UnityEngine.AI;

public class ServerBuildingManager : BuildingManager
{
	private int decayTickBuildingIndex;

	private int decayTickEntityIndex;

	private int decayTickWorldIndex;

	private int navmeshCarveTickBuildingIndex;

	private uint maxBuildingID;

	public void CheckSplit(DecayEntity ent)
	{
		if (ent.buildingID != 0)
		{
			Building building = ent.GetBuilding();
			if (building != null && ShouldSplit(building))
			{
				Split(building);
			}
		}
	}

	private bool ShouldSplit(Building building)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (building.HasBuildingBlocks())
		{
			building.buildingBlocks[0].EntityLinkBroadcast();
			Enumerator<BuildingBlock> enumerator = building.buildingBlocks.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					if (!enumerator.Current.ReceivedEntityLinkBroadcast())
					{
						return true;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		return false;
	}

	private void Split(Building oldBuilding)
	{
		List<Building> list = Pool.Get<List<Building>>();
		Building largestSplit = null;
		while (oldBuilding.HasBuildingBlocks())
		{
			BuildingBlock buildingBlock = oldBuilding.buildingBlocks[0];
			uint newID = BuildingManager.server.NewBuildingID();
			Interface.CallHook("OnBuildingSplit", (object)oldBuilding, (object)newID);
			buildingBlock.EntityLinkBroadcast(delegate(BuildingBlock b)
			{
				b.AttachToBuilding(newID);
			});
			Building building = BuildingManager.server.GetBuilding(newID);
			if (building != null)
			{
				list.Add(building);
			}
		}
		int num = 0;
		foreach (Building item in list)
		{
			if (item.buildingBlocks.Count > num)
			{
				num = item.buildingBlocks.Count;
				largestSplit = item;
			}
		}
		SplitEntities<BuildingPrivlidge>(oldBuilding.buildingPrivileges, largestSplit);
		SplitEntities<DecayEntity>(oldBuilding.decayEntities, largestSplit);
		if (AI.nav_carve_use_building_optimization)
		{
			oldBuilding.isNavMeshCarvingDirty = true;
			int ticks = 2;
			UpdateNavMeshCarver(oldBuilding, ref ticks, 0);
		}
		Pool.FreeUnmanaged<Building>(ref list);
	}

	private static void SplitEntities<T>(ListHashSet<T> input, Building largestSplit) where T : DecayEntity
	{
		List<T> list = Pool.Get<List<T>>();
		list.AddRange((IEnumerable<T>)input);
		foreach (T item in list)
		{
			BuildingBlock nearbyBuildingBlock = item.GetNearbyBuildingBlock();
			uint num = ((item is ContainerCorpse || item.GetParentEntity() is ContainerCorpse) ? largestSplit.ID : 0u);
			item.AttachToBuilding(Object.op_Implicit((Object)(object)nearbyBuildingBlock) ? nearbyBuildingBlock.buildingID : num);
		}
		Pool.FreeUnmanaged<T>(ref list);
	}

	public void CheckMerge(DecayEntity ent)
	{
		if (ent.buildingID == 0)
		{
			return;
		}
		Building building = ent.GetBuilding();
		if (building == null)
		{
			return;
		}
		ent.EntityLinkMessage(delegate(BuildingBlock b)
		{
			if (b.buildingID != building.ID)
			{
				Building building2 = b.GetBuilding();
				if (building2 != null)
				{
					Merge(building, building2);
				}
			}
		});
		if (AI.nav_carve_use_building_optimization)
		{
			building.isNavMeshCarvingDirty = true;
			int ticks = 2;
			UpdateNavMeshCarver(building, ref ticks, 0);
		}
	}

	private void Merge(Building building1, Building building2)
	{
		Interface.CallHook("OnBuildingMerge", (object)this, (object)building1, (object)building2);
		while (building2.HasDecayEntities())
		{
			building2.decayEntities[0].AttachToBuilding(building1.ID);
		}
		if (AI.nav_carve_use_building_optimization)
		{
			building1.isNavMeshCarvingDirty = true;
			building2.isNavMeshCarvingDirty = true;
			int ticks = 3;
			UpdateNavMeshCarver(building1, ref ticks, 0);
			UpdateNavMeshCarver(building1, ref ticks, 0);
		}
	}

	public void Cycle()
	{
		TimeWarning val = TimeWarning.New("StabilityCheckQueue", 0);
		try
		{
			((ObjectWorkQueue<StabilityEntity>)StabilityEntity.stabilityCheckQueue).RunQueue((double)Stability.stabilityqueue);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("UpdateSurroundingsQueue", 0);
		try
		{
			((ObjectWorkQueue<Bounds>)StabilityEntity.updateSurroundingsQueue).RunQueue((double)Stability.surroundingsqueue);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("UpdateSkinQueue", 0);
		try
		{
			((ObjectWorkQueue<BuildingBlock>)BuildingBlock.updateSkinQueueServer).RunQueue(1.0);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("BuildingDecayTick", 0);
		try
		{
			int num = 5;
			BufferList<Building> values = buildingDictionary.Values;
			for (int i = decayTickBuildingIndex; i < values.Count; i++)
			{
				if (num <= 0)
				{
					break;
				}
				BufferList<DecayEntity> values2 = values[i].decayEntities.Values;
				for (int j = decayTickEntityIndex; j < values2.Count; j++)
				{
					if (num <= 0)
					{
						break;
					}
					values2[j].DecayTick();
					num--;
					if (num <= 0)
					{
						decayTickBuildingIndex = i;
						decayTickEntityIndex = j;
					}
				}
				if (num > 0)
				{
					decayTickEntityIndex = 0;
				}
			}
			if (num > 0)
			{
				decayTickBuildingIndex = 0;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("WorldDecayTick", 0);
		try
		{
			int num2 = 5;
			BufferList<DecayEntity> values3 = decayEntities.Values;
			for (int k = decayTickWorldIndex; k < values3.Count; k++)
			{
				if (num2 <= 0)
				{
					break;
				}
				values3[k].DecayTick();
				num2--;
				if (num2 <= 0)
				{
					decayTickWorldIndex = k;
				}
			}
			if (num2 > 0)
			{
				decayTickWorldIndex = 0;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (!AI.nav_carve_use_building_optimization)
		{
			return;
		}
		val = TimeWarning.New("NavMeshCarving", 0);
		try
		{
			int ticks = 5;
			BufferList<Building> values4 = buildingDictionary.Values;
			for (int l = navmeshCarveTickBuildingIndex; l < values4.Count; l++)
			{
				if (ticks <= 0)
				{
					break;
				}
				Building building = values4[l];
				UpdateNavMeshCarver(building, ref ticks, l);
			}
			if (ticks > 0)
			{
				navmeshCarveTickBuildingIndex = 0;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void UpdateNavMeshCarver(Building building, ref int ticks, int i)
	{
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.nav_carve_use_building_optimization || (!building.isNavMeshCarveOptimized && building.navmeshCarvers.Count < AI.nav_carve_min_building_blocks_to_apply_optimization) || !building.isNavMeshCarvingDirty)
		{
			return;
		}
		building.isNavMeshCarvingDirty = false;
		if (building.navmeshCarvers == null)
		{
			if ((Object)(object)building.buildingNavMeshObstacle != (Object)null)
			{
				Object.Destroy((Object)(object)((Component)building.buildingNavMeshObstacle).gameObject);
				building.buildingNavMeshObstacle = null;
				building.isNavMeshCarveOptimized = false;
			}
			return;
		}
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor((float)World.Size, (float)World.Size, (float)World.Size);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor((float)(0L - (long)World.Size), (float)(0L - (long)World.Size), (float)(0L - (long)World.Size));
		int count = building.navmeshCarvers.Count;
		if (count > 0)
		{
			for (int j = 0; j < count; j++)
			{
				NavMeshObstacle val3 = building.navmeshCarvers[j];
				if (((Behaviour)val3).enabled)
				{
					((Behaviour)val3).enabled = false;
				}
				for (int k = 0; k < 3; k++)
				{
					Vector3 position = ((Component)val3).transform.position;
					if (((Vector3)(ref position))[k] < ((Vector3)(ref val))[k])
					{
						int num = k;
						position = ((Component)val3).transform.position;
						((Vector3)(ref val))[num] = ((Vector3)(ref position))[k];
					}
					position = ((Component)val3).transform.position;
					if (((Vector3)(ref position))[k] > ((Vector3)(ref val2))[k])
					{
						int num2 = k;
						position = ((Component)val3).transform.position;
						((Vector3)(ref val2))[num2] = ((Vector3)(ref position))[k];
					}
				}
			}
			Vector3 val4 = (val2 + val) * 0.5f;
			Vector3 zero = Vector3.zero;
			float num3 = Mathf.Abs(val4.x - val.x);
			float num4 = Mathf.Abs(val4.y - val.y);
			float num5 = Mathf.Abs(val4.z - val.z);
			float num6 = Mathf.Abs(val2.x - val4.x);
			float num7 = Mathf.Abs(val2.y - val4.y);
			float num8 = Mathf.Abs(val2.z - val4.z);
			zero.x = Mathf.Max((num3 > num6) ? num3 : num6, AI.nav_carve_min_base_size);
			zero.y = Mathf.Max((num4 > num7) ? num4 : num7, AI.nav_carve_min_base_size);
			zero.z = Mathf.Max((num5 > num8) ? num5 : num8, AI.nav_carve_min_base_size);
			zero = ((count >= 10) ? (zero * (AI.nav_carve_size_multiplier - 1f)) : (zero * AI.nav_carve_size_multiplier));
			if (building.navmeshCarvers.Count > 0)
			{
				if ((Object)(object)building.buildingNavMeshObstacle == (Object)null)
				{
					building.buildingNavMeshObstacle = new GameObject($"Building ({building.ID}) NavMesh Carver").AddComponent<NavMeshObstacle>();
					((Behaviour)building.buildingNavMeshObstacle).enabled = false;
					building.buildingNavMeshObstacle.carving = true;
					building.buildingNavMeshObstacle.shape = (NavMeshObstacleShape)1;
					building.buildingNavMeshObstacle.height = AI.nav_carve_height;
					building.isNavMeshCarveOptimized = true;
				}
				if ((Object)(object)building.buildingNavMeshObstacle != (Object)null)
				{
					((Component)building.buildingNavMeshObstacle).transform.position = val4;
					building.buildingNavMeshObstacle.size = zero;
					if (!((Behaviour)building.buildingNavMeshObstacle).enabled)
					{
						((Behaviour)building.buildingNavMeshObstacle).enabled = true;
					}
				}
			}
		}
		else if ((Object)(object)building.buildingNavMeshObstacle != (Object)null)
		{
			Object.Destroy((Object)(object)((Component)building.buildingNavMeshObstacle).gameObject);
			building.buildingNavMeshObstacle = null;
			building.isNavMeshCarveOptimized = false;
		}
		ticks--;
		if (ticks <= 0)
		{
			navmeshCarveTickBuildingIndex = i;
		}
	}

	public uint NewBuildingID()
	{
		return ++maxBuildingID;
	}

	public void LoadBuildingID(uint id)
	{
		maxBuildingID = Mathx.Max(maxBuildingID, id);
	}

	protected override Building CreateBuilding(uint id)
	{
		return new Building
		{
			ID = id
		};
	}

	protected override void DisposeBuilding(ref Building building)
	{
		building = null;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using Facepunch;
using UnityEngine;

public sealed class ClanAsyncResult<T> : IPooled
{
	private readonly List<Action<T>> _callbacks = new List<Action<T>>(4);

	private readonly Stopwatch _sinceStarted = new Stopwatch();

	private bool _isComplete;

	private T _result;

	public bool IsStarted => _sinceStarted.IsRunning;

	public float Elapsed => (float)_sinceStarted.Elapsed.TotalSeconds;

	public bool IsComplete => _isComplete;

	public void Start()
	{
		_sinceStarted.Restart();
	}

	public bool TrySetResult(T result)
	{
		if (_isComplete)
		{
			return false;
		}
		_result = result;
		_isComplete = true;
		_sinceStarted.Stop();
		foreach (Action<T> callback in _callbacks)
		{
			try
			{
				callback(_result);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		_callbacks.Clear();
		return true;
	}

	public void OnComplete(Action<T> callback)
	{
		if (callback == null)
		{
			throw new ArgumentNullException("callback");
		}
		if (_isComplete)
		{
			try
			{
				callback(_result);
				return;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				return;
			}
		}
		_callbacks.Add(callback);
	}

	private void Reset()
	{
		_callbacks.Clear();
		_sinceStarted.Reset();
		_isComplete = false;
		_result = default(T);
	}

	void IPooled.EnterPool()
	{
		Reset();
	}

	void IPooled.LeavePool()
	{
		Reset();
	}
}


using System;
using System.Collections.Generic;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using ProtoBuf;
using UnityEngine;

public class ClanChangeTracker : IClanChangeSink
{
	private struct ClanChangedEvent
	{
		public long ClanId;

		public ClanDataSource DataSources;
	}

	private struct ClanDisbandedEvent
	{
		public long ClanId;
	}

	private struct InvitationCreatedEvent
	{
		public ulong SteamId;

		public long ClanId;
	}

	private struct MembershipChangedEvent
	{
		public ulong SteamId;

		public long ClanId;
	}

	private struct ChatMessageEvent
	{
		public long ClanId;

		public ClanChatEntry Message;
	}

	private class ChatMessageEventComparer : IComparer<ChatMessageEvent>
	{
		public static readonly ChatMessageEventComparer Instance = new ChatMessageEventComparer();

		public int Compare(ChatMessageEvent x, ChatMessageEvent y)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			return x.Message.Time.CompareTo(y.Message.Time);
		}
	}

	private readonly ClanManager _clanManager;

	private readonly List<ClanChangedEvent> _clanChangedEvents = new List<ClanChangedEvent>();

	private readonly List<ClanDisbandedEvent> _clanDisbandedEvents = new List<ClanDisbandedEvent>();

	private readonly List<InvitationCreatedEvent> _invitationCreatedEvents = new List<InvitationCreatedEvent>();

	private readonly List<MembershipChangedEvent> _membershipChangedEvents = new List<MembershipChangedEvent>();

	private readonly List<ChatMessageEvent> _chatMessageEvents = new List<ChatMessageEvent>();

	public ClanChangeTracker(ClanManager clanManager)
	{
		_clanManager = clanManager;
	}

	public void HandleEvents()
	{
		lock (_clanChangedEvents)
		{
			foreach (ClanChangedEvent clanChangedEvent in _clanChangedEvents)
			{
				HandleClanChanged(clanChangedEvent);
			}
			_clanChangedEvents.Clear();
		}
		lock (_clanDisbandedEvents)
		{
			foreach (ClanDisbandedEvent clanDisbandedEvent in _clanDisbandedEvents)
			{
				HandleClanDisbanded(clanDisbandedEvent);
			}
			_clanDisbandedEvents.Clear();
		}
		lock (_invitationCreatedEvents)
		{
			foreach (InvitationCreatedEvent invitationCreatedEvent in _invitationCreatedEvents)
			{
				HandleInvitationCreated(invitationCreatedEvent);
			}
			_invitationCreatedEvents.Clear();
		}
		lock (_membershipChangedEvents)
		{
			foreach (MembershipChangedEvent membershipChangedEvent in _membershipChangedEvents)
			{
				HandleMembershipChanged(membershipChangedEvent);
			}
			_membershipChangedEvents.Clear();
		}
		lock (_chatMessageEvents)
		{
			foreach (ChatMessageEvent chatMessageEvent in _chatMessageEvents)
			{
				HandleChatMessageEvent(chatMessageEvent);
			}
			_chatMessageEvents.Clear();
		}
	}

	private void HandleClanChanged(in ClanChangedEvent data)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		IClan clan = default(IClan);
		if (_clanManager.Backend.TryGet(data.ClanId, ref clan))
		{
			_clanManager.SendClanChanged(clan);
			AppBroadcast val = Pool.Get<AppBroadcast>();
			val.clanChanged = Pool.Get<AppClanChanged>();
			val.clanChanged.clanInfo = clan.ToProto();
			CompanionServer.Server.Broadcast(new ClanTarget(data.ClanId), val);
		}
		if (((Enum)data.DataSources).HasFlag((Enum)(object)(ClanDataSource)16))
		{
			_clanManager.ClanMemberConnectionsChanged(data.ClanId);
		}
	}

	private void HandleClanDisbanded(in ClanDisbandedEvent data)
	{
	}

	private void HandleInvitationCreated(in InvitationCreatedEvent data)
	{
		_clanManager.SendClanInvitation(data.SteamId, data.ClanId);
	}

	private void HandleMembershipChanged(in MembershipChangedEvent data)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(data.SteamId);
		if ((Object)(object)basePlayer == (Object)null)
		{
			basePlayer = BasePlayer.FindSleeping(data.SteamId);
		}
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.clanId = data.ClanId;
			basePlayer.SendNetworkUpdateImmediate();
			if (basePlayer.IsConnected)
			{
				_clanManager.ClientRPC(RpcTarget.Player("Client_CurrentClanChanged", basePlayer));
			}
			IClan serverClan = default(IClan);
			if (_clanManager.Backend.TryGet(basePlayer.clanId, ref serverClan))
			{
				basePlayer.serverClan = serverClan;
			}
			else
			{
				basePlayer.LoadClanInfo();
			}
		}
	}

	private void HandleChatMessageEvent(in ChatMessageEvent data)
	{
		if (_clanManager.TryGetClanMemberConnections(data.ClanId, out var connections) && connections.Count > 0)
		{
			string nameColor = Chat.GetNameColor(data.Message.SteamId);
			ConsoleNetwork.SendClientCommand(connections, "chat.add2", 5, data.Message.SteamId, data.Message.Message, data.Message.Name, nameColor, 1f);
		}
		AppBroadcast val = Pool.Get<AppBroadcast>();
		val.clanMessage = Pool.Get<AppNewClanMessage>();
		val.clanMessage.clanId = data.ClanId;
		val.clanMessage.message = Pool.Get<AppClanMessage>();
		val.clanMessage.message.steamId = data.Message.SteamId;
		val.clanMessage.message.name = data.Message.Name;
		val.clanMessage.message.message = data.Message.Message;
		val.clanMessage.message.time = data.Message.Time;
		CompanionServer.Server.Broadcast(new ClanTarget(data.ClanId), val);
	}

	public void ClanChanged(long clanId, ClanDataSource dataSources)
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Expected I4, but got Unknown
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		lock (_clanChangedEvents)
		{
			int num = List.FindIndexWith<ClanChangedEvent, long>((IReadOnlyList<ClanChangedEvent>)_clanChangedEvents, (Func<ClanChangedEvent, long>)((ClanChangedEvent e) => e.ClanId), clanId, (IEqualityComparer<long>)null);
			if (num < 0)
			{
				_clanChangedEvents.Add(new ClanChangedEvent
				{
					ClanId = clanId,
					DataSources = dataSources
				});
			}
			else
			{
				ClanChangedEvent value = _clanChangedEvents[num];
				ref ClanDataSource dataSources2 = ref value.DataSources;
				dataSources2 |= dataSources;
				_clanChangedEvents[num] = value;
			}
		}
	}

	public void ClanDisbanded(long clanId)
	{
		lock (_clanDisbandedEvents)
		{
			_clanDisbandedEvents.Add(new ClanDisbandedEvent
			{
				ClanId = clanId
			});
		}
	}

	public void InvitationCreated(ulong steamId, long clanId)
	{
		lock (_invitationCreatedEvents)
		{
			_invitationCreatedEvents.Add(new InvitationCreatedEvent
			{
				SteamId = steamId,
				ClanId = clanId
			});
		}
	}

	public void MembershipChanged(ulong steamId, long? clanId)
	{
		lock (_membershipChangedEvents)
		{
			_membershipChangedEvents.Add(new MembershipChangedEvent
			{
				SteamId = steamId,
				ClanId = clanId.GetValueOrDefault()
			});
		}
	}

	public void ClanChatMessage(long clanId, ClanChatEntry entry)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		lock (_chatMessageEvents)
		{
			ChatMessageEvent chatMessageEvent = default(ChatMessageEvent);
			chatMessageEvent.ClanId = clanId;
			chatMessageEvent.Message = entry;
			ChatMessageEvent item = chatMessageEvent;
			int num = _chatMessageEvents.BinarySearch(item, ChatMessageEventComparer.Instance);
			_chatMessageEvents.Insert((num >= 0) ? num : (~num), item);
		}
	}
}


private struct ClanChangedEvent
{
	public long ClanId;

	public ClanDataSource DataSources;
}


private struct ClanDisbandedEvent
{
	public long ClanId;
}


private struct InvitationCreatedEvent
{
	public ulong SteamId;

	public long ClanId;
}


private struct MembershipChangedEvent
{
	public ulong SteamId;

	public long ClanId;
}


private struct ChatMessageEvent
{
	public long ClanId;

	public ClanChatEntry Message;
}


using System.Collections.Generic;

private class ChatMessageEventComparer : IComparer<ChatMessageEvent>
{
	public static readonly ChatMessageEventComparer Instance = new ChatMessageEventComparer();

	public int Compare(ChatMessageEvent x, ChatMessageEvent y)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return x.Message.Time.CompareTo(y.Message.Time);
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public static class ClanInfoExtensions
{
	public static ClanInfo ToProto(this IClan clan)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if (clan == null)
		{
			return null;
		}
		ClanInfo val = Pool.Get<ClanInfo>();
		val.clanId = clan.ClanId;
		val.name = clan.Name;
		val.created = clan.Created;
		val.creator = clan.Creator;
		val.motd = clan.Motd;
		val.motdTimestamp = clan.MotdTimestamp;
		val.motdAuthor = clan.MotdAuthor;
		val.logo = clan.Logo;
		val.color = ColorEx.ToInt32(clan.Color);
		val.maxMemberCount = clan.MaxMemberCount;
		val.score = clan.Score;
		val.roles = Pool.Get<List<Role>>();
		foreach (ClanRole role in clan.Roles)
		{
			val.roles.Add(role.ToProto());
		}
		val.members = Pool.Get<List<Member>>();
		foreach (ClanMember member in clan.Members)
		{
			val.members.Add(member.ToProto());
		}
		val.invites = Pool.Get<List<Invite>>();
		foreach (ClanInvite invite in clan.Invites)
		{
			val.invites.Add(invite.ToProto());
		}
		return val;
	}

	private static Role ToProto(this ClanRole role)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		bool flag = role.Rank == 1;
		Role obj = Pool.Get<Role>();
		obj.roleId = role.RoleId;
		obj.rank = role.Rank;
		obj.name = role.Name;
		obj.canSetMotd = flag || role.CanSetMotd;
		obj.canSetLogo = flag || role.CanSetLogo;
		obj.canInvite = flag || role.CanInvite;
		obj.canKick = flag || role.CanKick;
		obj.canPromote = flag || role.CanPromote;
		obj.canDemote = flag || role.CanDemote;
		obj.canSetPlayerNotes = flag || role.CanSetPlayerNotes;
		obj.canAccessLogs = flag || role.CanAccessLogs;
		obj.canAccessScoreEvents = flag || role.CanAccessScoreEvents;
		return obj;
	}

	public static ClanRole FromProto(this Role proto)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		ClanRole result = default(ClanRole);
		result.RoleId = proto.roleId;
		result.Rank = proto.rank;
		result.Name = proto.name;
		result.CanSetMotd = proto.canSetMotd;
		result.CanSetLogo = proto.canSetLogo;
		result.CanInvite = proto.canInvite;
		result.CanKick = proto.canKick;
		result.CanPromote = proto.canPromote;
		result.CanDemote = proto.canDemote;
		result.CanSetPlayerNotes = proto.canSetPlayerNotes;
		result.CanAccessLogs = proto.canAccessLogs;
		result.CanAccessScoreEvents = proto.canAccessScoreEvents;
		return result;
	}

	private static Member ToProto(this ClanMember member)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Member obj = Pool.Get<Member>();
		obj.steamId = member.SteamId;
		obj.roleId = member.RoleId;
		obj.joined = member.Joined;
		obj.lastSeen = member.LastSeen;
		obj.notes = member.Notes;
		obj.online = (NexusServer.Started ? NexusServer.IsOnline(member.SteamId) : ServerPlayers.IsOnline(member.SteamId));
		return obj;
	}

	private static Invite ToProto(this ClanInvite invite)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Invite obj = Pool.Get<Invite>();
		obj.steamId = invite.SteamId;
		obj.recruiter = invite.Recruiter;
		obj.timestamp = invite.Timestamp;
		return obj;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public static class ClanInvitationExtensions
{
	public static ClanInvitations ToProto(this List<ClanInvitation> invitations)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		List<Invitation> list = Pool.Get<List<Invitation>>();
		foreach (ClanInvitation invitation in invitations)
		{
			list.Add(invitation.ToProto());
		}
		ClanInvitations obj = Pool.Get<ClanInvitations>();
		obj.invitations = list;
		return obj;
	}

	public static Invitation ToProto(this ClanInvitation invitation)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Invitation obj = Pool.Get<Invitation>();
		obj.clanId = invitation.ClanId;
		obj.recruiter = invitation.Recruiter;
		obj.timestamp = invitation.Timestamp;
		return obj;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public static class ClanLeaderboardExtensions
{
	public static ClanLeaderboard ToProto(this List<ClanLeaderboardEntry> leaderboard)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		List<Entry> list = Pool.Get<List<Entry>>();
		foreach (ClanLeaderboardEntry item in leaderboard)
		{
			list.Add(item.ToProto());
		}
		ClanLeaderboard obj = Pool.Get<ClanLeaderboard>();
		obj.entries = list;
		return obj;
	}

	public static Entry ToProto(this ClanLeaderboardEntry entry)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Entry obj = Pool.Get<Entry>();
		obj.clanId = entry.ClanId;
		obj.name = entry.Name;
		obj.score = entry.Score;
		return obj;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public static class ClanLogExtensions
{
	public static ClanLog ToProto(this ClanLogs clanLogs)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		List<Entry> list = Pool.Get<List<Entry>>();
		foreach (ClanLogEntry entry in clanLogs.Entries)
		{
			Entry val = Pool.Get<Entry>();
			val.timestamp = entry.Timestamp;
			val.eventKey = entry.EventKey;
			val.arg1 = entry.Arg1;
			val.arg2 = entry.Arg2;
			val.arg3 = entry.Arg3;
			val.arg4 = entry.Arg4;
			list.Add(val);
		}
		ClanLog obj = Pool.Get<ClanLog>();
		obj.clanId = clanLogs.ClanId;
		obj.logEntries = list;
		return obj;
	}

	public static ClanScoreEvents ToProto(this ClanScoreEvents clanScoreEvents)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected I4, but got Unknown
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		List<Entry> list = Pool.Get<List<Entry>>();
		foreach (ClanScoreEvent scoreEvent in clanScoreEvents.ScoreEvents)
		{
			Entry val = Pool.Get<Entry>();
			val.timestamp = scoreEvent.Timestamp;
			val.type = (int)scoreEvent.Type;
			val.score = scoreEvent.Score;
			val.multiplier = scoreEvent.Multiplier;
			val.steamId = scoreEvent.SteamId.GetValueOrDefault();
			val.otherSteamId = scoreEvent.OtherSteamId.GetValueOrDefault();
			val.otherClanId = scoreEvent.OtherClanId.GetValueOrDefault();
			val.arg1 = scoreEvent.Arg1;
			val.arg2 = scoreEvent.Arg2;
			list.Add(val);
		}
		ClanScoreEvents obj = Pool.Get<ClanScoreEvents>();
		obj.clanId = clanScoreEvents.ClanId;
		obj.scoreEvents = list;
		return obj;
	}
}


using UnityEngine;

public struct ClanMetadata
{
	public long ClanId;

	public string Name;

	public int Members;

	public Color32 Color;
}


using System;
using System.Collections.Generic;
using CompanionServer;
using ConVar;
using Facepunch;
using UnityEngine;

public static class ClanPushNotifications
{
	public static async void SendClanAnnouncement(IClan clan, long previousTimestamp, ulong ignorePlayer)
	{
		if (ClanUtility.Timestamp() - previousTimestamp < 300000)
		{
			return;
		}
		try
		{
			List<ulong> steamIds = Pool.Get<List<ulong>>();
			foreach (ClanMember member in clan.Members)
			{
				if (member.SteamId != ignorePlayer)
				{
					steamIds.Add(member.SteamId);
				}
			}
			Dictionary<string, string> dictionary = Util.TryGetServerPairingData();
			if (dictionary != null)
			{
				dictionary.Add("type", "clan");
				dictionary.Add("fromId", ignorePlayer.ToString("G"));
				await NotificationList.SendNotificationTo(steamIds, NotificationChannel.ClanAnnouncement, "[" + clan.Name + "] Announcement was updated", ConVar.Server.hostname, dictionary);
			}
			Pool.FreeUnmanaged<ulong>(ref steamIds);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}
}


public class ClientIOLineParent : FacepunchBehaviour
{
	public AnimatedBuildingBlock parentEntity;

	public string boneName;

	public bool ignoreForPlugConnections;
}


using UnityEngine;

public class ClientIOLineParentClampedBounds : ClientIOLineParent
{
	public Bounds ClampedLocalBounds;

	public Transform BoundsRelativeTo;

	private OBB clampedObb;
}


using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;

public class Climate : SingletonComponent<Climate>
{
	[Serializable]
	public class ClimateParameters
	{
		public AnimationCurve Temperature;

		[Horizontal(4, -1)]
		public Float4 AerialDensity;

		[Horizontal(4, -1)]
		public Float4 FogDensity;

		[Horizontal(4, -1)]
		public Color4 FogColorGrad;

		[Horizontal(4, -1)]
		public Float4 FogAmbientIntensity = Float4.One();

		[Range(0f, 1f)]
		[Horizontal(4, -1)]
		public Float4 FogAmbientSaturation = Float4.One();

		[Horizontal(4, -1)]
		public Float4 FogLightBoost = Float4.One();

		public float BiomeWeightExponent = 1f;

		public float FogHeightFalloff = 0.02f;
	}

	[Serializable]
	public class WeatherParameters
	{
		[Range(0f, 1f)]
		public float ClearChance = 1f;

		[Range(0f, 1f)]
		public float DustChance;

		[Range(0f, 1f)]
		public float FogChance;

		[Range(0f, 1f)]
		public float OvercastChance;

		[Range(0f, 1f)]
		public float StormChance;

		[Range(0f, 1f)]
		public float RainChance;
	}

	public class Value4<T>
	{
		public T Dawn;

		public T Noon;

		public T Dusk;

		public T Night;

		public float FindBlendParameters(TOD_Sky sky, out T src, out T dst)
		{
			float num = Mathf.Abs(sky.SunriseTime - sky.Cycle.Hour);
			float num2 = Mathf.Abs(sky.SunsetTime - sky.Cycle.Hour);
			float num3 = (180f - sky.SunZenith) / 180f;
			float num4 = 1f / 9f;
			if (num < num2)
			{
				if (num3 < 0.5f)
				{
					src = Night;
					dst = Dawn;
					return Mathf.InverseLerp(0.5f - num4, 0.5f, num3);
				}
				src = Dawn;
				dst = Noon;
				return Mathf.InverseLerp(0.5f, 0.5f + num4, num3);
			}
			if (num3 > 0.5f)
			{
				src = Noon;
				dst = Dusk;
				return Mathf.InverseLerp(0.5f + num4, 0.5f, num3);
			}
			src = Dusk;
			dst = Night;
			return Mathf.InverseLerp(0.5f, 0.5f - num4, num3);
		}
	}

	[Serializable]
	public class Float4 : Value4<float>
	{
		public static Float4 One()
		{
			return new Float4
			{
				Dawn = 1f,
				Dusk = 1f,
				Noon = 1f,
				Night = 1f
			};
		}
	}

	[Serializable]
	public class Color4 : Value4<Color>
	{
	}

	[Serializable]
	public class Texture2D4 : Value4<Texture2D>
	{
	}

	private const float fadeAngle = 20f;

	private const float defaultTemp = 15f;

	private const int weatherDurationHours = 18;

	private const int weatherFadeHours = 6;

	public float BiomeFogShoreDistanceFalloff = -25f;

	[Range(0f, 1f)]
	public float BlendingSpeed = 1f;

	public float FogDarknessDistance = 200f;

	public bool DebugLUTBlending;

	public WeatherParameters Weather;

	public WeatherPreset[] WeatherPresets;

	public ClimateParameters Arid;

	public ClimateParameters Temperate;

	public ClimateParameters Tundra;

	public ClimateParameters Arctic;

	public ClimateParameters Jungle;

	public float UndergroundFogDensity;

	public Color UndergroundFogColor = Color.black;

	public VolumeCloudsConfig[] DefaultCloudConfigs;

	public VolumeCloudsCirrusConfig[] DefaultCirrusConfigs;

	public VolumeCloudsConfig[] AllCloudConfigs;

	public Dictionary<WeatherPresetType, WeatherPreset[]> presetLookup;

	private ClimateParameters[] climateLookup;

	public float WeatherStateBlend { get; set; }

	public uint WeatherSeedPrevious { get; set; }

	public uint WeatherSeedTarget { get; set; }

	public uint WeatherSeedNext { get; set; }

	public WeatherPreset WeatherStatePrevious { get; set; }

	public WeatherPreset WeatherStateTarget { get; set; }

	public WeatherPreset WeatherStateNext { get; set; }

	public WeatherPreset WeatherState { get; set; }

	public WeatherPreset WeatherClampsMin { get; private set; }

	public WeatherPreset WeatherClampsMax { get; private set; }

	public WeatherPreset WeatherOverrides { get; set; }

	public LegacyWeatherState Overrides { get; set; }

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
		WeatherState = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherClampsMin = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherClampsMax = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherOverrides = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherState.Reset();
		WeatherClampsMin.Reset();
		WeatherClampsMax.Reset();
		WeatherOverrides.Reset();
		Overrides = new LegacyWeatherState(WeatherOverrides);
	}

	protected override void OnDestroy()
	{
		if (!Application.isQuitting)
		{
			((SingletonComponent)this).OnDestroy();
			if ((Object)(object)WeatherState != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherState);
			}
			if ((Object)(object)WeatherClampsMin != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherClampsMin);
			}
			if ((Object)(object)WeatherClampsMax != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherClampsMax);
			}
			if ((Object)(object)WeatherOverrides != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherOverrides);
			}
		}
	}

	private void GetPresetVCloudConfigs(WeatherPreset preset, uint seed, out VolumeCloudsConfig cfg, out VolumeCloudsCirrusConfig cfgCirrus, out VolumeCloudsRadialWeatherLayerConfig cfgStorm)
	{
		if (preset.VolumeCloudsConfigs != null && preset.VolumeCloudsConfigs.Length != 0)
		{
			cfg = preset.VolumeCloudsConfigs[SeedRandom.Range(seed, 0, preset.VolumeCloudsConfigs.Length)];
		}
		else if (DefaultCloudConfigs.Length == 0)
		{
			Debug.LogError((object)"Current weather profile has no cloud config, and default cloud config list is empty!  This shouldn't be so");
			cfg = null;
		}
		else
		{
			cfg = DefaultCloudConfigs[SeedRandom.Range(seed, 0, DefaultCloudConfigs.Length)];
		}
		if (preset.VolumeCloudsCirrusConfigs != null && preset.VolumeCloudsCirrusConfigs.Length != 0)
		{
			cfgCirrus = preset.VolumeCloudsCirrusConfigs[SeedRandom.Range(seed, 0, preset.VolumeCloudsCirrusConfigs.Length)];
		}
		else if (DefaultCirrusConfigs.Length == 0)
		{
			Debug.LogError((object)"Current weather profile has no cirrus cloud config, and default cirrus cloud config list is empty!  This shouldn't be so");
			cfgCirrus = null;
		}
		else
		{
			cfgCirrus = DefaultCirrusConfigs[SeedRandom.Range(seed, 0, DefaultCirrusConfigs.Length)];
		}
		if (preset.VolumeCloudsStormLayers != null && preset.VolumeCloudsStormLayers.Length != 0)
		{
			cfgStorm = preset.VolumeCloudsStormLayers[SeedRandom.Range(seed, 0, preset.VolumeCloudsStormLayers.Length)];
		}
		else
		{
			cfgStorm = null;
		}
	}

	public void Update()
	{
		if (!Application.isReceiving && !Application.isLoading && Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			TOD_Sky instance = TOD_Sky.Instance;
			long num = World.Seed + instance.Cycle.Ticks;
			long num2 = 648000000000L;
			long num3 = 216000000000L;
			long num4 = num / num2;
			WeatherStateBlend = Mathf.InverseLerp(0f, (float)num3, (float)(num % num2));
			uint seed = (WeatherSeedPrevious = GetSeedFromLong(num4));
			WeatherStatePrevious = GetWeatherPreset(seed);
			seed = (WeatherSeedTarget = GetSeedFromLong(num4 + 1));
			WeatherStateTarget = GetWeatherPreset(seed);
			seed = (WeatherSeedNext = GetSeedFromLong(num4 + 2));
			WeatherStateNext = GetWeatherPreset(seed);
			WeatherState.Fade(WeatherStatePrevious, WeatherStateTarget, WeatherStateBlend);
			WeatherState.Override(WeatherOverrides);
		}
	}

	private static bool Initialized()
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStatePrevious))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStateTarget))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStateNext))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherState))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherClampsMin))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherOverrides))
		{
			return false;
		}
		return true;
	}

	public static float GetClouds(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Clouds.Coverage;
	}

	public static float GetFog(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Atmosphere.Fogginess;
	}

	public static float GetWind(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Wind;
	}

	public static float GetThunder(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		float thunder = SingletonComponent<Climate>.Instance.WeatherOverrides.Thunder;
		if (thunder >= 0f)
		{
			return thunder;
		}
		float thunder2 = SingletonComponent<Climate>.Instance.WeatherState.Thunder;
		float thunder3 = SingletonComponent<Climate>.Instance.WeatherStatePrevious.Thunder;
		float thunder4 = SingletonComponent<Climate>.Instance.WeatherStateTarget.Thunder;
		if (thunder3 > 0f && thunder2 > 0.5f * thunder3)
		{
			return thunder2;
		}
		if (thunder4 > 0f && thunder2 > 0.5f * thunder4)
		{
			return thunder2;
		}
		return 0f;
	}

	public static float GetRainbow(Vector3 position)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance) || !instance.IsDay || instance.LerpValue < 1f)
		{
			return 0f;
		}
		if (GetFog(position) > 0.25f)
		{
			return 0f;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 3) : 0f);
		if (num <= 0f)
		{
			return 0f;
		}
		float rainbow = SingletonComponent<Climate>.Instance.WeatherOverrides.Rainbow;
		if (rainbow >= 0f)
		{
			return rainbow * num;
		}
		if (SingletonComponent<Climate>.Instance.WeatherState.Rainbow <= 0f)
		{
			return 0f;
		}
		if (SingletonComponent<Climate>.Instance.WeatherStateTarget.Rainbow > 0f)
		{
			return 0f;
		}
		float rainbow2 = SingletonComponent<Climate>.Instance.WeatherStatePrevious.Rainbow;
		float num2 = SeedRandom.Value(SingletonComponent<Climate>.Instance.WeatherSeedPrevious);
		if (rainbow2 < num2)
		{
			return 0f;
		}
		return num;
	}

	public static float GetAurora(Vector3 position)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance) || !instance.IsNight || instance.LerpValue > 0f)
		{
			return 0f;
		}
		if (GetClouds(position) > 0.1f)
		{
			return 0f;
		}
		if (GetFog(position) > 0.1f)
		{
			return 0f;
		}
		if (!Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap))
		{
			return 0f;
		}
		return TerrainMeta.BiomeMap.GetBiome(position, 8);
	}

	public static float GetRain(Vector3 position)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 1) : 0f);
		float num2 = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 8) : 0f);
		return SingletonComponent<Climate>.Instance.WeatherState.Rain * Mathf.Lerp(1f, 0.5f, num) * (1f - num2);
	}

	public static float GetSnow(Vector3 position)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 8) : 0f);
		return SingletonComponent<Climate>.Instance.WeatherState.Rain * num;
	}

	public static float GetTemperature(Vector3 position)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 15f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance))
		{
			return 15f;
		}
		ClimateParameters src;
		ClimateParameters dst;
		float num = SingletonComponent<Climate>.Instance.FindBlendParameters(position, out src, out dst);
		if (src == null || dst == null)
		{
			return 15f;
		}
		float hour = instance.Cycle.Hour;
		float num2 = src.Temperature.Evaluate(hour);
		float num3 = dst.Temperature.Evaluate(hour);
		return Mathf.Lerp(num2, num3, num);
	}

	private uint GetSeedFromLong(long val)
	{
		uint result = (uint)((val % uint.MaxValue + uint.MaxValue) % uint.MaxValue);
		SeedRandom.Wanghash(ref result);
		SeedRandom.Wanghash(ref result);
		SeedRandom.Wanghash(ref result);
		return result;
	}

	private WeatherPreset GetWeatherPreset(uint seed)
	{
		float num = Weather.ClearChance + Weather.DustChance + Weather.FogChance + Weather.OvercastChance + Weather.StormChance + Weather.RainChance;
		float num2 = SeedRandom.Range(ref seed, 0f, num);
		if (num2 < Weather.RainChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Rain);
		}
		if (num2 < Weather.RainChance + Weather.StormChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Storm);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Overcast);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance + Weather.FogChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Fog);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance + Weather.FogChance + Weather.DustChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Dust);
		}
		return GetWeatherPreset(seed, WeatherPresetType.Clear);
	}

	private WeatherPreset GetWeatherPreset(uint seed, WeatherPresetType type)
	{
		if (presetLookup == null)
		{
			presetLookup = new Dictionary<WeatherPresetType, WeatherPreset[]>();
		}
		if (!presetLookup.TryGetValue(type, out var value))
		{
			presetLookup.Add(type, value = CacheWeatherPresets(type));
		}
		return value.GetRandom(ref seed);
	}

	public WeatherPreset[] CacheWeatherPresets(WeatherPresetType type)
	{
		return WeatherPresets.Where((WeatherPreset x) => x.Type == type).ToArray();
	}

	private float FindBlendParameters(Vector3 pos, out ClimateParameters src, out ClimateParameters dst)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		if (climateLookup == null)
		{
			climateLookup = new ClimateParameters[5] { Arid, Temperate, Tundra, Arctic, Jungle };
		}
		if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
		{
			src = Temperate;
			dst = Temperate;
			return 0.5f;
		}
		int biomeMaxType = TerrainMeta.BiomeMap.GetBiomeMaxType(pos);
		int biomeMaxType2 = TerrainMeta.BiomeMap.GetBiomeMaxType(pos, ~biomeMaxType);
		src = climateLookup[TerrainBiome.TypeToIndex(biomeMaxType)];
		dst = climateLookup[TerrainBiome.TypeToIndex(biomeMaxType2)];
		return TerrainMeta.BiomeMap.GetBiome(pos, biomeMaxType2);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ClimateParameters
{
	public AnimationCurve Temperature;

	[Horizontal(4, -1)]
	public Float4 AerialDensity;

	[Horizontal(4, -1)]
	public Float4 FogDensity;

	[Horizontal(4, -1)]
	public Color4 FogColorGrad;

	[Horizontal(4, -1)]
	public Float4 FogAmbientIntensity = Float4.One();

	[Range(0f, 1f)]
	[Horizontal(4, -1)]
	public Float4 FogAmbientSaturation = Float4.One();

	[Horizontal(4, -1)]
	public Float4 FogLightBoost = Float4.One();

	public float BiomeWeightExponent = 1f;

	public float FogHeightFalloff = 0.02f;
}


using System;
using UnityEngine;

[Serializable]
public class WeatherParameters
{
	[Range(0f, 1f)]
	public float ClearChance = 1f;

	[Range(0f, 1f)]
	public float DustChance;

	[Range(0f, 1f)]
	public float FogChance;

	[Range(0f, 1f)]
	public float OvercastChance;

	[Range(0f, 1f)]
	public float StormChance;

	[Range(0f, 1f)]
	public float RainChance;
}


using UnityEngine;

public class Value4<T>
{
	public T Dawn;

	public T Noon;

	public T Dusk;

	public T Night;

	public float FindBlendParameters(TOD_Sky sky, out T src, out T dst)
	{
		float num = Mathf.Abs(sky.SunriseTime - sky.Cycle.Hour);
		float num2 = Mathf.Abs(sky.SunsetTime - sky.Cycle.Hour);
		float num3 = (180f - sky.SunZenith) / 180f;
		float num4 = 1f / 9f;
		if (num < num2)
		{
			if (num3 < 0.5f)
			{
				src = Night;
				dst = Dawn;
				return Mathf.InverseLerp(0.5f - num4, 0.5f, num3);
			}
			src = Dawn;
			dst = Noon;
			return Mathf.InverseLerp(0.5f, 0.5f + num4, num3);
		}
		if (num3 > 0.5f)
		{
			src = Noon;
			dst = Dusk;
			return Mathf.InverseLerp(0.5f + num4, 0.5f, num3);
		}
		src = Dusk;
		dst = Night;
		return Mathf.InverseLerp(0.5f, 0.5f - num4, num3);
	}
}


using System;

[Serializable]
public class Float4 : Value4<float>
{
	public static Float4 One()
	{
		return new Float4
		{
			Dawn = 1f,
			Dusk = 1f,
			Noon = 1f,
			Night = 1f
		};
	}
}


using System;
using UnityEngine;

[Serializable]
public class Color4 : Value4<Color>
{
}


using System;
using UnityEngine;

[Serializable]
public class Texture2D4 : Value4<Texture2D>
{
}


using System;
using UnityEngine;

public class ColliderInfo : MonoBehaviour
{
	[Flags]
	public enum Flags
	{
		Usable = 1,
		Shootable = 2,
		Melee = 4,
		Opaque = 8,
		Airflow = 0x10,
		OnlyBlockBuildingBlock = 0x20,
		Monument = 0x40,
		Tunnels = 0x80,
		AllowBuildInsideMesh = 0x100
	}

	public const Flags FlagsNone = (Flags)0;

	public const Flags FlagsEverything = (Flags)(-1);

	public const Flags FlagsDefault = Flags.Usable | Flags.Shootable | Flags.Melee | Flags.Opaque;

	[InspectorFlags]
	public Flags flags = Flags.Usable | Flags.Shootable | Flags.Melee | Flags.Opaque;

	public bool HasFlag(Flags f)
	{
		return (flags & f) == f;
	}

	public void SetFlag(Flags f, bool b)
	{
		if (b)
		{
			flags |= f;
		}
		else
		{
			flags &= ~f;
		}
	}

	public bool Filter(HitTest info)
	{
		switch (info.type)
		{
		case HitTest.Type.MeleeAttack:
			if ((flags & Flags.Melee) == 0)
			{
				return false;
			}
			break;
		case HitTest.Type.ProjectileEffect:
		case HitTest.Type.Projectile:
			if ((flags & Flags.Shootable) == 0)
			{
				return false;
			}
			break;
		case HitTest.Type.Use:
			if ((flags & Flags.Usable) == 0)
			{
				return false;
			}
			break;
		}
		return true;
	}
}


using System;

[Flags]
public enum Flags
{
	Usable = 1,
	Shootable = 2,
	Melee = 4,
	Opaque = 8,
	Airflow = 0x10,
	OnlyBlockBuildingBlock = 0x20,
	Monument = 0x40,
	Tunnels = 0x80,
	AllowBuildInsideMesh = 0x100
}


public class ColliderInfo_Pipe : ColliderInfo
{
	public int OutputSlotIndex;

	public IOEntity ParentEntity;
}


using UnityEngine;

public class ConditionalGibbable : MonoBehaviour
{
	[ReadOnly]
	public int id;
}


using UnityEngine;

public class CreateEffect : MonoBehaviour
{
	public GameObjectRef EffectToCreate;

	public void OnEnable()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Effect.client.Run(EffectToCreate.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up, ((Component)this).transform.forward);
	}
}


