using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using VacuumBreather;

public class BaseBoat : BaseVehicle
{
	[Header("Boat")]
	public float engineThrust = 10f;

	public float steeringScale = 0.1f;

	public Transform thrustPoint;

	public Transform centerOfMass;

	public Buoyancy buoyancy;

	public bool preventDecayIndoors = true;

	[Header("Correction Forces")]
	public bool applyCorrectionForces = true;

	public Transform[] planeFitPoints;

	public Vector3 inAirPID;

	public float inAirDesiredPitch = -15f;

	public Vector3 wavePID;

	public MinMax correctionRange;

	public float correctionSpringForce;

	public float correctionSpringDamping;

	private Vector3[] worldAnchors;

	private PidQuaternionController pidController;

	[ServerVar]
	public static bool generate_paths = true;

	[ServerVar]
	public static bool do_shore_drift = true;

	public static int secondsUntilShoreDrift = 7200;

	public static int secondsBetweenShoreDrift = 120;

	[Help("Shore drift speed in metres per second")]
	[ServerVar]
	public static float drift_speed = 1f;

	[NonSerialized]
	public float gasPedal;

	[NonSerialized]
	public float steering;

	private TimeSince shoreDriftTimer;

	private string lastDriftCheckStatus = "Never checked";

	protected virtual bool AllowKinematicDrift => false;

	protected virtual bool SkipBoatForcedUpdate => false;

	[Help("Seconds until boat starts drifting to shore if there's nobody around")]
	[ServerVar]
	public static int seconds_until_shore_drift(Arg arg)
	{
		secondsUntilShoreDrift = arg.GetInt(0, secondsUntilShoreDrift);
		UpdateShoreDriftInvokeOnAll();
		return secondsUntilShoreDrift;
	}

	[ServerVar]
	[Help("Seconds between shore drift teleport ticks")]
	public static int seconds_between_shore_drift(Arg arg)
	{
		secondsBetweenShoreDrift = arg.GetInt(0, secondsBetweenShoreDrift);
		UpdateShoreDriftInvokeOnAll();
		return secondsBetweenShoreDrift;
	}

	public bool InDryDock()
	{
		return (Object)(object)GetParentEntity() != (Object)null;
	}

	public override float MaxVelocity()
	{
		return 25f;
	}

	public override void ServerInit()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.isKinematic = false;
		if ((Object)(object)rigidBody == (Object)null)
		{
			Debug.LogWarning((object)"Boat rigidbody null");
			return;
		}
		if ((Object)(object)centerOfMass == (Object)null)
		{
			Debug.LogWarning((object)"boat COM null");
			return;
		}
		rigidBody.centerOfMass = centerOfMass.localPosition;
		if (planeFitPoints == null || planeFitPoints.Length != 3)
		{
			Debug.LogWarning((object)"Boats require 3 plane fit points");
			return;
		}
		worldAnchors = (Vector3[])(object)new Vector3[3];
		pidController = new PidQuaternionController(wavePID.x, wavePID.y, wavePID.z);
		if (Application.isLoadingSave)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
			return;
		}
		shoreDriftTimer = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, (float)secondsUntilShoreDrift, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			DriverInput(inputState, player);
		}
	}

	public virtual void DriverInput(InputState inputState, BasePlayer player)
	{
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			gasPedal = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			gasPedal = -0.5f;
		}
		else
		{
			gasPedal = 0f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			steering = 1f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			steering = -1f;
		}
		else
		{
			steering = 0f;
		}
	}

	public void OnPoolDestroyed()
	{
		Kill(DestroyMode.Gib);
	}

	public void WakeUp()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
			rigidBody.AddForce(Vector3.up * 0.1f, (ForceMode)1);
		}
	}

	protected override void OnServerWake()
	{
		if ((Object)(object)buoyancy != (Object)null)
		{
			buoyancy.Wake();
		}
	}

	public virtual bool EngineOn()
	{
		if (HasDriver())
		{
			return !IsFlipped();
		}
		return false;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseBoat.VehicleFixedUpdate", 0);
		try
		{
			if (!EngineOn())
			{
				gasPedal = 0f;
				steering = 0f;
			}
			base.VehicleFixedUpdate();
			if (!SkipBoatForcedUpdate)
			{
				ApplyCorrectionForces();
				bool flag = WaterLevel.Test(thrustPoint.position, waves: true, volumes: true, this);
				if (gasPedal != 0f && flag && buoyancy.submergedFraction > 0.3f)
				{
					Vector3 val2 = ((Component)this).transform.forward + ((Component)this).transform.right * steering * steeringScale;
					Vector3 val3 = ((Vector3)(ref val2)).normalized * gasPedal * engineThrust;
					rigidBody.AddForceAtPosition(val3, thrustPoint.position, (ForceMode)0);
				}
				if (AnyMounted() && IsFlipped())
				{
					DismountAllPlayers();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected void ApplyCorrectionForces()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0310: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		if (applyCorrectionForces && planeFitPoints != null && planeFitPoints.Length == 3 && HasDriver() && !(buoyancy.submergedFraction < 0.5f))
		{
			Matrix4x4 val = Matrix4x4.TRS(((Component)this).transform.position, Quaternion.Euler(0f, ((Component)this).transform.eulerAngles.y, 0f), Vector3.one);
			for (int i = 0; i < planeFitPoints.Length; i++)
			{
				Vector3 val2 = ((Matrix4x4)(ref val)).MultiplyPoint(planeFitPoints[i].localPosition);
				val2.y = WaterLevel.GetWaterSurface(val2, waves: true, volumes: false);
				worldAnchors[i] = val2;
			}
			Plane val3 = default(Plane);
			((Plane)(ref val3))..ctor(worldAnchors[0], worldAnchors[1], worldAnchors[2]);
			Vector3 normal = ((Plane)(ref val3)).normal;
			Vector3 val4 = Vector3.Normalize(worldAnchors[2] - worldAnchors[1]);
			Quaternion desiredOrientation = Quaternion.LookRotation(Vector3.Cross(normal, val4), normal);
			float y = planeFitPoints[0].localPosition.y;
			float num = (worldAnchors[0].y + worldAnchors[1].y + worldAnchors[2].y) / 3f - y;
			float y2 = ((Component)this).transform.position.y;
			float num2 = num - y2;
			Vector3 velocity = rigidBody.velocity;
			if (y2 > num + correctionRange.x && y2 < num + correctionRange.y)
			{
				float num3 = num2 * correctionSpringForce;
				float num4 = (0f - velocity.y) * correctionSpringDamping;
				rigidBody.AddForce(0f, num3 + num4, 0f, (ForceMode)0);
			}
			if (y2 > num + correctionRange.y)
			{
				desiredOrientation = Quaternion.Euler(inAirDesiredPitch, ((Component)this).transform.eulerAngles.y, 0f);
				pidController.Kp = inAirPID.x;
				pidController.Ki = inAirPID.y;
				pidController.Kd = inAirPID.z;
				Vector3 val5 = pidController.ComputeRequiredAngularAcceleration(((Component)this).transform.rotation, desiredOrientation, rigidBody.angularVelocity, Time.fixedDeltaTime);
				rigidBody.AddTorque(val5, (ForceMode)5);
			}
			else if (y2 > num + correctionRange.x)
			{
				pidController.Kp = wavePID.x;
				pidController.Ki = wavePID.y;
				pidController.Kd = wavePID.z;
				Vector3 val6 = pidController.ComputeRequiredAngularAcceleration(((Component)this).transform.rotation, desiredOrientation, rigidBody.angularVelocity, Time.fixedDeltaTime);
				val6.y = 0f;
				rigidBody.AddTorque(val6, (ForceMode)5);
			}
		}
	}

	public static void WaterVehicleDecay(BaseCombatEntity entity, float decayTickRate, float timeSinceLastUsed, float outsideDecayMinutes, float deepWaterDecayMinutes, float decayStartDelayMinutes, bool preventDecayIndoors)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (entity.healthFraction != 0f && !(timeSinceLastUsed < 60f * decayStartDelayMinutes))
		{
			float overallWaterDepth = WaterLevel.GetOverallWaterDepth(((Component)entity).transform.position, waves: true, volumes: false);
			float num = outsideDecayMinutes;
			if (preventDecayIndoors && !entity.IsOutside())
			{
				num = float.PositiveInfinity;
			}
			if (overallWaterDepth > 12f)
			{
				float num2 = Mathf.InverseLerp(12f, 16f, overallWaterDepth);
				float num3 = Mathf.Lerp(0.1f, 1f, num2);
				num = Mathf.Min(num, deepWaterDecayMinutes / num3);
			}
			if (!float.IsPositiveInfinity(num))
			{
				float num4 = decayTickRate / 60f / num;
				entity.Hurt(entity.MaxHealth() * num4, DamageType.Decay, entity, useProtection: false);
			}
		}
	}

	private void CheckDriftToShore()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		if (!do_shore_drift)
		{
			return;
		}
		if (TimeSince.op_Implicit(shoreDriftTimer) < (float)secondsUntilShoreDrift - 1f)
		{
			lastDriftCheckStatus = "Was too soon";
			return;
		}
		if (!AllowKinematicDrift && rigidBody.isKinematic)
		{
			lastDriftCheckStatus = "Was kinematic";
			return;
		}
		if (IsOn())
		{
			lastDriftCheckStatus = "Was on";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (AnyPlayersOnBoat())
		{
			lastDriftCheckStatus = "Players were on boat";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (HasParent())
		{
			lastDriftCheckStatus = "Was parented";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (IsDead())
		{
			lastDriftCheckStatus = "Is dead";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (WaterFactor() < 0.1f)
		{
			lastDriftCheckStatus = "Not in water";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if ((Object)(object)TerrainTexturing.Instance == (Object)null)
		{
			lastDriftCheckStatus = "No terrain tex";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (BaseNetworkable.HasConnections(((Component)this).transform.position))
		{
			lastDriftCheckStatus = "Players were nearby";
			return;
		}
		float num = bounds.MaxExtent() + 2f;
		float num2 = drift_speed * (float)secondsBetweenShoreDrift;
		(Vector3 shoreDir, float shoreDist) coarseVectorToShore = TerrainTexturing.Instance.GetCoarseVectorToShore(((Component)this).transform.position);
		Vector3 item = coarseVectorToShore.shoreDir;
		float item2 = coarseVectorToShore.shoreDist;
		float num3 = 2f * num;
		if (item2 < num3)
		{
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			lastDriftCheckStatus = "Was near shore already";
			return;
		}
		float maxDistance = num2 - num;
		Vector3 val = ((Component)this).transform.position + ((Bounds)(ref bounds)).center + item * (num + 1f);
		Vector3 val2 = ((Component)this).transform.position + ((Bounds)(ref bounds)).center + item * num2;
		Ray ray = new Ray(val, item);
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(ray, num, list, maxDistance, 1235583233, (QueryTriggerInteraction)1, this);
		if (list.Count > 0)
		{
			foreach (RaycastHit item3 in list)
			{
				RaycastHit current = item3;
				if ((Object)(object)((RaycastHit)(ref current)).collider != (Object)null)
				{
					BaseEntity baseEntity = ((RaycastHit)(ref current)).collider.ToBaseEntity();
					if ((Object)(object)baseEntity != (Object)null && baseEntity.HasEntityInParents(this))
					{
						continue;
					}
				}
				if (((RaycastHit)(ref current)).distance <= num3)
				{
					lastDriftCheckStatus = $"Was blocked by {((Object)((RaycastHit)(ref current)).transform).name} at {((RaycastHit)(ref current)).transform.position}";
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return;
				}
				val2 = ((RaycastHit)(ref current)).point - item * num3;
				val2.y = ((Component)this).transform.position.y + ((Bounds)(ref bounds)).center.y;
				break;
			}
		}
		Vector3 position = ((Component)this).transform.position;
		((Component)this).transform.position = val2 - ((Bounds)(ref bounds)).center;
		rigidBody.velocity = Vector3.zero;
		rigidBody.angularVelocity = Vector3.zero;
		lastDriftCheckStatus = $"Drifted {Vector3.Distance(position, ((Component)this).transform.position):F0}m";
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		((FacepunchBehaviour)this).Invoke((Action)GoToSleep, 0f);
	}

	private void GoToSleep()
	{
		rigidBody.Sleep();
	}

	public virtual bool AnyPlayersOnBoat()
	{
		return AnyMounted();
	}

	public string GetDriftStatus()
	{
		return lastDriftCheckStatus;
	}

	public static void UpdateShoreDriftInvokeOnAll()
	{
		BaseBoat[] array = Util.FindAll<BaseBoat>();
		foreach (BaseBoat baseBoat in array)
		{
			if (baseBoat.IsValid())
			{
				baseBoat.UpdateShoreDriftInvoke();
			}
		}
	}

	private void UpdateShoreDriftInvoke()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Max(0f, (float)secondsUntilShoreDrift - TimeSince.op_Implicit(shoreDriftTimer));
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, num, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.baseBoat = Pool.Get<BaseBoat>();
		info.msg.baseBoat.shoreDriftTimerValue = TimeSince.op_Implicit(shoreDriftTimer);
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.baseBoat != null && base.isServer)
		{
			shoreDriftTimer = TimeSince.op_Implicit(info.msg.baseBoat.shoreDriftTimerValue);
		}
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		info = WaterLevel.GetWaterInfo(player.eyes.position, waves: true, volumes: true);
		if (!info.isValid)
		{
			return 0f;
		}
		return 1f;
	}

	public static List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnBoatPathGenerate");
		if (obj is List<Vector3>)
		{
			return (List<Vector3>)obj;
		}
		float x = TerrainMeta.Size.x;
		float num = x * 2f * MathF.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		List<Vector3> list = new List<Vector3>();
		float num4 = x;
		float num5 = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num6 = (float)i / (float)num3 * 360f;
			list.Add(new Vector3(Mathf.Sin(num6 * (MathF.PI / 180f)) * num4, num5, Mathf.Cos(num6 * (MathF.PI / 180f)) * num4));
		}
		float num7 = 4f;
		float num8 = 200f;
		bool flag = true;
		RaycastHit val9 = default(RaycastHit);
		for (int j = 0; j < AI.ocean_patrol_path_iterations && flag; j++)
		{
			flag = false;
			for (int k = 0; k < num3; k++)
			{
				Vector3 val = list[k];
				int index = ((k == 0) ? (num3 - 1) : (k - 1));
				int index2 = ((k != num3 - 1) ? (k + 1) : 0);
				Vector3 val2 = list[index2];
				Vector3 val3 = list[index];
				Vector3 val4 = val;
				Vector3 val5 = Vector3.zero - val;
				Vector3 normalized = ((Vector3)(ref val5)).normalized;
				Vector3 val6 = val + normalized * num7;
				if (Vector3.Distance(val6, val2) > num8 || Vector3.Distance(val6, val3) > num8)
				{
					continue;
				}
				bool flag2 = true;
				int num9 = 16;
				for (int l = 0; l < num9; l++)
				{
					float num10 = (float)l / (float)num9 * 360f;
					val5 = new Vector3(Mathf.Sin(num10 * (MathF.PI / 180f)), num5, Mathf.Cos(num10 * (MathF.PI / 180f)));
					Vector3 normalized2 = ((Vector3)(ref val5)).normalized;
					Vector3 val7 = val6 + normalized2 * 1f;
					Vector3 val8 = normalized;
					if (val7 != Vector3.zero)
					{
						val5 = val7 - val6;
						val8 = ((Vector3)(ref val5)).normalized;
					}
					if (Physics.SphereCast(val4, 3f, val8, ref val9, minDistanceFromShore, 1084293377))
					{
						flag2 = false;
						break;
					}
				}
				if (flag2)
				{
					flag = true;
					list[k] = val6;
				}
			}
		}
		if (flag)
		{
			Debug.LogWarning((object)"Failed to generate ocean patrol path");
			return null;
		}
		List<int> list2 = new List<int>();
		LineUtility.Simplify(list, 5f, list2);
		List<Vector3> list3 = list;
		list = new List<Vector3>();
		foreach (int item in list2)
		{
			list.Add(list3[item]);
		}
		Debug.Log((object)("Generated ocean patrol path with node count: " + list.Count));
		return list;
	}
}


using System;
using ConVar;
using UnityEngine;
using UnityEngine.Serialization;

public class Buoyancy : ListComponent<Buoyancy>, IServerComponent, IPrefabPreProcess
{
	public enum Priority
	{
		High,
		Low
	}

	[Serializable]
	private struct BuoyancyPointData
	{
		[ReadOnly]
		public Vector3 localPosition;

		[ReadOnly]
		public Vector3 rootToPoint;

		[NonSerialized]
		public Vector3 position;
	}

	public BuoyancyPoint[] points;

	public GameObjectRef[] waterImpacts;

	public Rigidbody rigidBody;

	public float buoyancyScale = 1f;

	public bool scaleForceWithMass;

	public bool doEffects = true;

	public float flowMovementScale = 1f;

	public float requiredSubmergedFraction = 0.5f;

	public bool useUnderwaterDrag;

	[Range(0f, 3f)]
	public float underwaterDrag = 2f;

	[Tooltip("How much this object will pay attention to the wave system, 0 = flat water, 1 = full waves (default 1)")]
	[FormerlySerializedAs("flatWaterLerp")]
	[Range(0f, 1f)]
	public float wavesEffect = 1f;

	public Action<bool> SubmergedChanged;

	public BaseEntity forEntity;

	[NonSerialized]
	public float submergedFraction;

	[SerializeField]
	[ReadOnly]
	private BuoyancyPointData[] pointData;

	private bool initedPointArrays;

	private Vector2[] pointPositionArray;

	private Vector2[] pointPositionUVArray;

	private float[] pointShoreDistanceArray;

	private float[] pointTerrainHeightArray;

	private float[] pointWaterHeightArray;

	private float defaultDrag;

	private float defaultAngularDrag;

	private float timeInWater;

	[NonSerialized]
	public float? ArtificialHeight;

	private BaseVehicle forVehicle;

	private bool hasLocalPlayers;

	private bool hadLocalPlayers;

	public float timeOutOfWater { get; private set; }

	public bool InWater => submergedFraction > requiredSubmergedFraction;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public Priority BuoyancyPriority { get; set; }

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!Application.isPlaying || serverside)
		{
			SavePointData(forced: false);
		}
	}

	public void SavePointData(bool forced)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		if (points == null || points.Length == 0)
		{
			Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)this).gameObject.AddComponent<Rigidbody>();
			}
			GameObject val2 = new GameObject("BuoyancyPoint");
			val2.transform.parent = ((Component)val).gameObject.transform;
			val2.transform.localPosition = val.centerOfMass;
			BuoyancyPoint buoyancyPoint = val2.AddComponent<BuoyancyPoint>();
			buoyancyPoint.buoyancyForce = val.mass * (0f - Physics.gravity.y);
			buoyancyPoint.buoyancyForce *= 1.32f;
			buoyancyPoint.size = 0.2f;
			points = new BuoyancyPoint[1];
			points[0] = buoyancyPoint;
		}
		if (pointData == null || pointData.Length != points.Length || forced)
		{
			pointData = new BuoyancyPointData[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Transform transform = ((Component)points[i]).transform;
				pointData[i].localPosition = transform.localPosition;
				pointData[i].rootToPoint = ((Component)this).transform.InverseTransformPoint(transform.position);
			}
		}
	}

	public static string DefaultWaterImpact()
	{
		return "assets/bundled/prefabs/fx/impacts/physics/water-enter-exit.prefab";
	}

	private void Awake()
	{
		forVehicle = forEntity as BaseVehicle;
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckSleepState, 0.5f, 5f, 1f);
	}

	public void Sleep()
	{
		if (((Object)(object)forEntity == (Object)null || !forEntity.BuoyancySleep(InWater)) && (Object)(object)rigidBody != (Object)null)
		{
			rigidBody.Sleep();
		}
		((Behaviour)this).enabled = false;
	}

	public void Wake()
	{
		if (((Object)(object)forEntity == (Object)null || !forEntity.BuoyancyWake()) && (Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
		}
		((Behaviour)this).enabled = true;
	}

	public void CheckSleepState()
	{
		if ((Object)(object)((Component)this).transform == (Object)null || (Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		hasLocalPlayers = HasLocalPlayers();
		bool flag = rigidBody.IsSleeping() || rigidBody.isKinematic;
		bool flag2 = flag || (!hasLocalPlayers && timeInWater > 6f);
		if ((Object)(object)forVehicle != (Object)null && forVehicle.IsOn())
		{
			flag2 = false;
		}
		if (((Behaviour)this).enabled && flag2)
		{
			((FacepunchBehaviour)this).Invoke((Action)Sleep, 0f);
			return;
		}
		if (!((Behaviour)this).enabled && hasLocalPlayers && !hadLocalPlayers)
		{
			DoCycle(forced: true);
		}
		bool flag3 = !flag || ShouldWake(hasLocalPlayers);
		if (!((Behaviour)this).enabled && flag3)
		{
			((FacepunchBehaviour)this).Invoke((Action)Wake, 0f);
		}
		hadLocalPlayers = hasLocalPlayers;
	}

	public void LowPriorityCheck(bool forceHighPriority)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		Priority buoyancyPriority = BuoyancyPriority;
		Priority priority = buoyancyPriority;
		if (forceHighPriority)
		{
			priority = Priority.High;
		}
		else
		{
			Vector3 position = ((Component)this).transform.position;
			priority = ((!BaseNetworkable.HasCloseConnections(position, Server.lowPriorityBuoyancyRange)) ? Priority.Low : Priority.High);
			if (priority == Priority.Low && priority != buoyancyPriority)
			{
				Vector3 val = Vector3Ex.WithY(((Component)this).transform.TransformPoint(Vector3.forward * 2f), position.y);
				Rigidbody obj = rigidBody;
				Vector3 val2 = val - rigidBody.position;
				obj.rotation = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
			}
		}
		if (priority != buoyancyPriority)
		{
			rigidBody.velocity = Vector3.zero;
			rigidBody.angularVelocity = Vector3.zero;
			BuoyancyPriority = priority;
		}
	}

	public bool ShouldWake()
	{
		return ShouldWake(HasLocalPlayers());
	}

	public bool ShouldWake(bool hasLocalPlayers)
	{
		if (hasLocalPlayers)
		{
			return submergedFraction > 0f;
		}
		return false;
	}

	private bool HasLocalPlayers()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return BaseNetworkable.HasCloseConnections(((Component)this).transform.position, 100f);
	}

	protected void DoCycle(bool forced = false)
	{
		if (!((Behaviour)this).enabled && !forced)
		{
			return;
		}
		bool num = submergedFraction > 0f;
		BuoyancyFixedUpdate();
		bool flag = submergedFraction > 0f;
		if (num == flag)
		{
			return;
		}
		if (useUnderwaterDrag && (Object)(object)rigidBody != (Object)null)
		{
			if (flag)
			{
				defaultDrag = rigidBody.drag;
				defaultAngularDrag = rigidBody.angularDrag;
				rigidBody.drag = underwaterDrag;
				rigidBody.angularDrag = underwaterDrag;
			}
			else
			{
				rigidBody.drag = defaultDrag;
				rigidBody.angularDrag = defaultAngularDrag;
			}
		}
		if (SubmergedChanged != null)
		{
			SubmergedChanged(flag);
		}
	}

	public static void Cycle()
	{
		bool autoSyncTransforms = Physics.autoSyncTransforms;
		try
		{
			Physics.autoSyncTransforms = false;
			Buoyancy[] buffer = ListComponent<Buoyancy>.InstanceList.Values.Buffer;
			int count = ListComponent<Buoyancy>.InstanceList.Count;
			for (int i = 0; i < count; i++)
			{
				buffer[i].DoCycle();
			}
		}
		finally
		{
			if (autoSyncTransforms)
			{
				Physics.SyncTransforms();
			}
			Physics.autoSyncTransforms = autoSyncTransforms;
		}
	}

	private Vector3 GetFlowDirection(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return WaterLevel.GetWaterFlowDirection(worldPos);
	}

	public void BuoyancyFixedUpdate()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0442: Unknown result type (might be due to invalid IL or missing references)
		//IL_0444: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		if (buoyancyScale == 0f)
		{
			((FacepunchBehaviour)this).Invoke((Action)Sleep, 0f);
			return;
		}
		if (BuoyancyPriority == Priority.Low)
		{
			WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(((Component)this).transform.position, waves: true, volumes: true, forEntity);
			Vector3 position = rigidBody.position;
			if (position.y < waterInfo.surfaceLevel)
			{
				rigidBody.position = new Vector3(position.x, waterInfo.surfaceLevel, position.z);
			}
			return;
		}
		if (!initedPointArrays)
		{
			InitPointArrays();
		}
		float time = Time.time;
		float x = TerrainMeta.Position.x;
		float z = TerrainMeta.Position.z;
		float x2 = TerrainMeta.OneOverSize.x;
		float z2 = TerrainMeta.OneOverSize.z;
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		for (int i = 0; i < pointData.Length; i++)
		{
			Vector3 val = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(pointData[i].rootToPoint);
			pointData[i].position = val;
			float num = (val.x - x) * x2;
			float num2 = (val.z - z) * z2;
			pointPositionArray[i] = new Vector2(val.x, val.z);
			pointPositionUVArray[i] = new Vector2(num, num2);
		}
		WaterSystem.GetHeightArray(pointPositionArray, pointPositionUVArray, pointShoreDistanceArray, pointTerrainHeightArray, pointWaterHeightArray);
		bool flag = wavesEffect < 1f;
		int num3 = 0;
		Vector3 accumForce = default(Vector3);
		Vector3 val2 = default(Vector3);
		for (int j = 0; j < points.Length; j++)
		{
			BuoyancyPoint buoyancyPoint = points[j];
			Vector3 pos = pointData[j].position;
			Vector3 localPosition = pointData[j].localPosition;
			Vector2 posUV = pointPositionUVArray[j];
			float terrainHeight = pointTerrainHeightArray[j];
			float num4 = pointWaterHeightArray[j];
			if (ArtificialHeight.HasValue)
			{
				num4 = ArtificialHeight.Value;
			}
			else if (flag)
			{
				num4 = Mathf.Lerp(0f, num4, wavesEffect);
			}
			bool doDeepwaterChecks = !ArtificialHeight.HasValue;
			WaterLevel.WaterInfo waterInfo2 = WaterLevel.GetBuoyancyWaterInfo(pos, posUV, terrainHeight, num4, doDeepwaterChecks, forEntity);
			if (flag && waterInfo2.isValid)
			{
				waterInfo2.currentDepth = Mathf.Lerp(waterInfo2.currentDepth, waterInfo2.surfaceLevel - pos.y, wavesEffect);
			}
			bool flag2 = false;
			if (pos.y < waterInfo2.surfaceLevel && waterInfo2.isValid)
			{
				flag2 = true;
				num3++;
				float currentDepth = waterInfo2.currentDepth;
				float num5 = Mathf.InverseLerp(0f, buoyancyPoint.size, currentDepth);
				float num6 = 1f + Mathf.PerlinNoise(buoyancyPoint.randomOffset + time * buoyancyPoint.waveFrequency, 0f) * buoyancyPoint.waveScale;
				float num7 = buoyancyPoint.buoyancyForce * buoyancyScale;
				if (scaleForceWithMass)
				{
					num7 *= rigidBody.mass;
				}
				((Vector3)(ref accumForce))..ctor(0f, num6 * num5 * num7, 0f);
				AccumulateFlowForce(ref accumForce, in pos, in waterInfo2, Mathf.Abs(pointShoreDistanceArray[j]), num7);
				rigidBody.AddForceAtPosition(accumForce, pos, (ForceMode)0);
			}
			if (buoyancyPoint.doSplashEffects && ((!buoyancyPoint.wasSubmergedLastFrame && flag2) || (!flag2 && buoyancyPoint.wasSubmergedLastFrame)) && doEffects)
			{
				Vector3 relativePointVelocity = rigidBody.GetRelativePointVelocity(localPosition);
				if (((Vector3)(ref relativePointVelocity)).magnitude > 1f)
				{
					string strName = ((waterImpacts != null && waterImpacts.Length != 0 && waterImpacts[0].isValid) ? waterImpacts[0].resourcePath : DefaultWaterImpact());
					((Vector3)(ref val2))..ctor(Random.Range(-0.25f, 0.25f), 0f, Random.Range(-0.25f, 0.25f));
					Effect.server.Run(strName, pos + val2, Vector3.up);
					buoyancyPoint.nexSplashTime = Time.time + 0.25f;
				}
			}
			buoyancyPoint.wasSubmergedLastFrame = flag2;
		}
		if (points.Length != 0)
		{
			submergedFraction = (float)num3 / (float)points.Length;
		}
		if (InWater)
		{
			timeInWater += Time.fixedDeltaTime;
			timeOutOfWater = 0f;
		}
		else
		{
			timeOutOfWater += Time.fixedDeltaTime;
			timeInWater = 0f;
		}
	}

	public void AccumulateFlowForce(ref Vector3 accumForce, in Vector3 pos, in WaterLevel.WaterInfo waterInfo, float shoreDistance, float scaledBuoyancyForce)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		if ((waterInfo.topology & 0x10000) == 0)
		{
			float num = Mathf.Clamp01(Mathf.InverseLerp(60f, 0f, shoreDistance));
			if (!(num <= Mathf.Epsilon))
			{
				num = Mathf.Pow(num, 0.5f);
				Vector3 flowDirection = GetFlowDirection(pos);
				scaledBuoyancyForce *= 0.025f * num;
				accumForce.x += flowDirection.x * scaledBuoyancyForce * flowMovementScale;
				accumForce.z += flowDirection.z * scaledBuoyancyForce * flowMovementScale;
			}
		}
	}

	private void InitPointArrays()
	{
		pointPositionArray = (Vector2[])(object)new Vector2[points.Length];
		pointPositionUVArray = (Vector2[])(object)new Vector2[points.Length];
		pointShoreDistanceArray = new float[points.Length];
		pointTerrainHeightArray = new float[points.Length];
		pointWaterHeightArray = new float[points.Length];
		initedPointArrays = true;
	}
}


public enum Priority
{
	High,
	Low
}


using System;
using UnityEngine;

[Serializable]
private struct BuoyancyPointData
{
	[ReadOnly]
	public Vector3 localPosition;

	[ReadOnly]
	public Vector3 rootToPoint;

	[NonSerialized]
	public Vector3 position;
}


using System;
using UnityEngine;

public class BuoyancyPoint : MonoBehaviour
{
	public float buoyancyForce = 10f;

	public float size = 0.1f;

	public float waveScale = 0.2f;

	public float waveFrequency = 1f;

	public bool doSplashEffects = true;

	[NonSerialized]
	public float randomOffset;

	[NonSerialized]
	public bool wasSubmergedLastFrame;

	[NonSerialized]
	public float nexSplashTime;

	private static readonly Color gizmoColour = new Color(1f, 0f, 0f, 0.25f);

	public void Start()
	{
		randomOffset = Random.Range(0f, 20f);
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = gizmoColour;
		Gizmos.DrawSphere(((Component)this).transform.position, size * 0.5f);
	}
}


using UnityEngine;

public class KayakSeat : BaseVehicleSeat
{
	public ItemDefinition PaddleItem;

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		if ((Object)(object)VehicleParent() != (Object)null)
		{
			VehicleParent().OnPlayerMounted();
		}
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		if ((Object)(object)VehicleParent() != (Object)null)
		{
			VehicleParent().OnPlayerDismounted(player);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class RHIBAIController : FacepunchBehaviour
{
	public List<Vector3> nodes = new List<Vector3>();

	[ContextMenu("Calculate Path")]
	public void SetupPatrolPath()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float num = x * 2f * MathF.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		nodes = new List<Vector3>();
		float num4 = x;
		float num5 = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num6 = (float)i / (float)num3 * 360f;
			nodes.Add(new Vector3(Mathf.Sin(num6 * (MathF.PI / 180f)) * num4, num5, Mathf.Cos(num6 * (MathF.PI / 180f)) * num4));
		}
		float num7 = 2f;
		float num8 = 200f;
		float num9 = 150f;
		float num10 = 8f;
		bool flag = true;
		int num11 = 1;
		float num12 = 20f;
		Vector3[] array = (Vector3[])(object)new Vector3[5]
		{
			new Vector3(0f, 0f, 0f),
			new Vector3(num12, 0f, 0f),
			new Vector3(0f - num12, 0f, 0f),
			new Vector3(0f, 0f, num12),
			new Vector3(0f, 0f, 0f - num12)
		};
		RaycastHit val9 = default(RaycastHit);
		while (flag)
		{
			Debug.Log((object)("Loop # :" + num11));
			num11++;
			flag = false;
			for (int j = 0; j < num3; j++)
			{
				Vector3 val = nodes[j];
				int index = ((j == 0) ? (num3 - 1) : (j - 1));
				int index2 = ((j != num3 - 1) ? (j + 1) : 0);
				Vector3 val2 = nodes[index2];
				Vector3 val3 = nodes[index];
				Vector3 val4 = val;
				Vector3 val5 = Vector3.zero - val;
				Vector3 normalized = ((Vector3)(ref val5)).normalized;
				Vector3 val6 = val + normalized * num7;
				if (Vector3.Distance(val6, val2) > num8 || Vector3.Distance(val6, val3) > num8)
				{
					continue;
				}
				bool flag2 = true;
				for (int k = 0; k < array.Length; k++)
				{
					Vector3 val7 = val6 + array[k];
					if (GetWaterDepth(val7) < num10)
					{
						flag2 = false;
					}
					Vector3 val8 = normalized;
					if (val7 != Vector3.zero)
					{
						val5 = val7 - val4;
						val8 = ((Vector3)(ref val5)).normalized;
					}
					if (Physics.Raycast(val4, val8, ref val9, num9, 1218511105))
					{
						flag2 = false;
					}
				}
				if (flag2)
				{
					flag = true;
					nodes[j] = val6;
				}
			}
		}
		List<int> list = new List<int>();
		LineUtility.Simplify(nodes, 15f, list);
		List<Vector3> list2 = nodes;
		nodes = new List<Vector3>();
		foreach (int item in list)
		{
			nodes.Add(list2[item]);
		}
	}

	public float GetWaterDepth(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (!Physics.Raycast(pos, Vector3.down, ref val, 100f, 8388608))
		{
			return 100f;
		}
		return ((RaycastHit)(ref val)).distance;
	}

	public void OnDrawGizmosSelected()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.Path.OceanPatrolClose != null)
		{
			for (int i = 0; i < TerrainMeta.Path.OceanPatrolClose.Count; i++)
			{
				Vector3 val = TerrainMeta.Path.OceanPatrolClose[i];
				Gizmos.color = Color.green;
				Gizmos.DrawSphere(val, 3f);
				Vector3 val2 = ((i + 1 == TerrainMeta.Path.OceanPatrolClose.Count) ? TerrainMeta.Path.OceanPatrolClose[0] : TerrainMeta.Path.OceanPatrolClose[i + 1]);
				Gizmos.DrawLine(val, val2);
			}
		}
	}
}


using UnityEngine;

public class TugboatInteriorSoundTrigger : MonoBehaviour, IClientComponent
{
	public TugboatSounds tugboatSounds;

	public bool bridge;
}


using UnityEngine;

public class TugboatSounds : MonoBehaviour, IClientComponent
{
	[SerializeField]
	private Tugboat tugboat;

	[SerializeField]
	private float roughHalfWidth = 5f;

	[SerializeField]
	private float roughHalfLength = 10f;

	private float soundCullDistanceSq;

	[SerializeField]
	[Header("Engine")]
	private SoundDefinition engineLoopDef;

	private Sound engineLoop;

	private SoundModulation.Modulator engineGainMod;

	private SoundModulation.Modulator enginePitchMod;

	[SerializeField]
	private SoundDefinition engineStartDef;

	[SerializeField]
	private SoundDefinition engineStartBridgeDef;

	[SerializeField]
	private SoundDefinition engineStopDef;

	[SerializeField]
	private SoundDefinition engineStopBridgeDef;

	[SerializeField]
	private float engineGainChangeRate = 1f;

	[SerializeField]
	private float enginePitchChangeRate = 0.5f;

	[SerializeField]
	private Transform engineTransform;

	[SerializeField]
	private Transform bridgeControlsTransform;

	[SerializeField]
	[Header("Water")]
	private SoundDefinition waterIdleDef;

	[SerializeField]
	private SoundDefinition waterSideMovementSlowDef;

	[SerializeField]
	private SoundDefinition waterSideMovementFastDef;

	[SerializeField]
	private SoundDefinition waterSternMovementDef;

	[SerializeField]
	private SoundDefinition waterInteriorIdleDef;

	[SerializeField]
	private SoundDefinition waterInteriorDef;

	[SerializeField]
	private AnimationCurve waterMovementGainCurve;

	[SerializeField]
	private float waterMovementGainChangeRate = 0.5f;

	[SerializeField]
	private AnimationCurve waterDistanceGainCurve;

	private Sound leftWaterSound;

	private SoundModulation.Modulator leftWaterGainMod;

	private Sound rightWaterSound;

	private SoundModulation.Modulator rightWaterGainMod;

	private Sound sternWaterSound;

	private SoundModulation.Modulator sternWaterGainMod;

	[SerializeField]
	private Transform wakeTransform;

	[SerializeField]
	private Vector3 sideSoundLineStern;

	[SerializeField]
	private Vector3 sideSoundLineBow;

	[SerializeField]
	[Header("Ambient")]
	private SoundDefinition ambientActiveLoopDef;

	private Sound ambientActiveSound;

	[SerializeField]
	private SoundDefinition hullGroanDef;

	[SerializeField]
	private float hullGroanCooldown = 1f;

	private float lastHullGroan;

	[SerializeField]
	private SoundDefinition chainRattleDef;

	[SerializeField]
	private float chainRattleCooldown = 1f;

	[SerializeField]
	private Transform[] chainRattleLocations;

	[SerializeField]
	private float chainRattleAngleDeltaThreshold = 1f;

	private float lastChainRattle;

	[SerializeField]
	[Header("Horn")]
	private SoundDefinition hornLoop;

	[SerializeField]
	private SoundDefinition hornStart;

	[SerializeField]
	private SoundDefinition hornStop;

	[Tooltip("The maximum amount of time a looped horn can last. If 0s then this is ignored.")]
	[Min(0f)]
	[SerializeField]
	private float maxHornTime;

	[Tooltip("Used for rate limiting. This defines the maximum number of horn spams that can be invoked one after another.")]
	[SerializeField]
	[Min(0f)]
	private int hornTokenCapacity = 3;

	[SerializeField]
	[Min(0f)]
	[Tooltip("Used for rate limiting. This defines how quickly a new token regenerates, permitting another horn honk.")]
	private float hornTokenRegenerationTime = 1f;

	private Line leftSoundLine;

	private Line rightSoundLine;

	[Header("Runtime")]
	public bool engineOn;

	public bool throttleOn;

	public bool inWater = true;
}


using System;
using UnityEngine;

[Serializable]
public class CarSettings
{
	[Header("Vehicle Setup")]
	[Range(0f, 1f)]
	public float rollingResistance = 0.05f;

	[Range(0f, 1f)]
	public float antiRoll;

	public bool canSleep = true;

	[Header("Wheels")]
	public bool tankSteering;

	[Range(0f, 50f)]
	public float maxSteerAngle = 35f;

	public bool steeringAssist = true;

	[Range(0f, 1f)]
	public float steeringAssistRatio = 0.5f;

	public bool steeringLimit;

	[Range(0f, 50f)]
	public float minSteerLimitAngle = 6f;

	[Range(10f, 50f)]
	public float minSteerLimitSpeed = 30f;

	[Range(0f, 1f)]
	public float rearWheelSteer = 1f;

	public float steerMinLerpSpeed = 75f;

	public float steerMaxLerpSpeed = 150f;

	public float steerReturnLerpSpeed = 200f;

	public bool retainLerpSpeed;

	[Header("Motor")]
	public float maxDriveSlip = 4f;

	public float driveForceToMaxSlip = 1000f;

	public float reversePercentSpeed = 0.3f;

	[Header("Brakes")]
	public float brakeForceMultiplier = 1000f;

	public bool disableHandbrakes;

	[Header("Front/Rear Vehicle Balance")]
	[Range(0f, 1f)]
	public float handlingBias = 0.5f;
}


using System;
using UnityEngine;

[Serializable]
public class CarWheel
{
	public WheelCollider wheelCollider;

	[Range(0.0001f, 3f)]
	public float tyreFriction = 1f;

	public bool steerWheel;

	public bool brakeWheel = true;

	public bool powerWheel = true;
}


using System;
using ConVar;
using UnityEngine;

public class CarPhysics<TCar> where TCar : BaseVehicle, CarPhysics<TCar>.ICar
{
	public interface ICar
	{
		VehicleTerrainHandler.Surface OnSurface { get; }

		float GetThrottleInput();

		float GetBrakeInput();

		float GetSteerInput();

		bool GetSteerSpeedMod(float speed);

		float GetSteerMaxMult(float speed);

		float GetMaxForwardSpeed();

		float GetMaxDriveForce();

		float GetAdjustedDriveForce(float absSpeed, float topSpeed);

		float GetModifiedDrag();

		CarWheel[] GetWheels();

		float GetWheelsMidPos();
	}

	private class ServerWheelData
	{
		public CarWheel wheel;

		public Transform wheelColliderTransform;

		public WheelCollider wheelCollider;

		public bool isGrounded;

		public float downforce;

		public float forceDistance;

		public WheelHit hit;

		public Vector2 localRigForce;

		public Vector2 localVelocity;

		public float angularVelocity;

		public Vector3 origin;

		public Vector2 tyreForce;

		public Vector2 tyreSlip;

		public Vector3 velocity;

		public bool isBraking;

		public bool hasThrottleInput;

		public bool isFrontWheel;

		public bool isLeftWheel;
	}

	private readonly ServerWheelData[] wheelData;

	private readonly TCar car;

	private readonly Transform transform;

	private readonly Rigidbody rBody;

	private readonly CarSettings vehicleSettings;

	private float speedAngle;

	private bool wasSleeping = true;

	private bool hasDriver;

	private bool hadDriver;

	private float steerLerpSpeed;

	public float lastMovingTime = float.MinValue;

	private WheelFrictionCurve zeroFriction;

	private Vector3 prevLocalCOM;

	private readonly float midWheelPos;

	private const bool WHEEL_HIT_CORRECTION = true;

	private const float SLEEP_SPEED = 0.25f;

	private const float SLEEP_DELAY = 10f;

	private const float AIR_DRAG = 0.25f;

	private const float DEFAULT_GROUND_GRIP = 0.75f;

	private const float ROAD_GROUND_GRIP = 1f;

	private const float ICE_GROUND_GRIP = 0.25f;

	private bool slowSpeedExitFlag;

	private const float SLOW_SPEED_EXIT_SPEED = 4f;

	public TimeSince timeSinceWaterCheck;

	public float DriveWheelVelocity { get; private set; }

	public float DriveWheelSlip { get; private set; }

	public float SteerAngle { get; private set; }

	public float TankThrottleLeft { get; private set; }

	public float TankThrottleRight { get; private set; }

	private bool InSlowSpeedExitMode
	{
		get
		{
			if (!hasDriver)
			{
				return slowSpeedExitFlag;
			}
			return false;
		}
	}

	public CarPhysics(TCar car, Transform transform, Rigidbody rBody, CarSettings vehicleSettings)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		WheelFrictionCurve val = default(WheelFrictionCurve);
		((WheelFrictionCurve)(ref val)).stiffness = 0f;
		zeroFriction = val;
		Transform transform2 = transform;
		base..ctor();
		CarPhysics<TCar> carPhysics = this;
		this.car = car;
		this.transform = transform2;
		this.rBody = rBody;
		this.vehicleSettings = vehicleSettings;
		timeSinceWaterCheck = default(TimeSince);
		timeSinceWaterCheck = TimeSince.op_Implicit(float.MaxValue);
		prevLocalCOM = rBody.centerOfMass;
		CarWheel[] wheels = car.GetWheels();
		wheelData = new ServerWheelData[wheels.Length];
		for (int i = 0; i < wheelData.Length; i++)
		{
			wheelData[i] = AddWheel(wheels[i]);
		}
		midWheelPos = car.GetWheelsMidPos();
		wheelData[0].wheel.wheelCollider.ConfigureVehicleSubsteps(1000f, 1, 1);
		lastMovingTime = Time.realtimeSinceStartup;
		ServerWheelData AddWheel(CarWheel wheel)
		{
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			ServerWheelData obj = new ServerWheelData
			{
				wheelCollider = wheel.wheelCollider,
				wheelColliderTransform = ((Component)wheel.wheelCollider).transform,
				forceDistance = GetWheelForceDistance(wheel.wheelCollider),
				wheel = wheel
			};
			obj.wheelCollider.sidewaysFriction = zeroFriction;
			obj.wheelCollider.forwardFriction = zeroFriction;
			Vector3 val2 = transform2.InverseTransformPoint(((Component)wheel.wheelCollider).transform.position);
			obj.isFrontWheel = val2.z > 0f;
			obj.isLeftWheel = val2.x < 0f;
			return obj;
		}
	}

	public void FixedUpdate(float dt, float speed)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("CarPhysics.FixedUpdate", 0);
		try
		{
			if (rBody.centerOfMass != prevLocalCOM)
			{
				COMChanged();
			}
			float num = Mathf.Abs(speed);
			hasDriver = car.HasDriver();
			if (!hasDriver && hadDriver)
			{
				if (num <= 4f)
				{
					slowSpeedExitFlag = true;
				}
			}
			else if (hasDriver && !hadDriver)
			{
				slowSpeedExitFlag = false;
			}
			if ((hasDriver || !vehicleSettings.canSleep) && rBody.IsSleeping())
			{
				rBody.WakeUp();
			}
			Vector3 val2;
			if (!rBody.IsSleeping())
			{
				if ((!wasSleeping || rBody.isKinematic) && !(num > 0.25f))
				{
					val2 = rBody.angularVelocity;
					if (!(Mathf.Abs(((Vector3)(ref val2)).magnitude) > 0.25f))
					{
						goto IL_0103;
					}
				}
				lastMovingTime = Time.time;
				goto IL_0103;
			}
			wasSleeping = true;
			goto IL_05ed;
			IL_0103:
			bool flag = vehicleSettings.canSleep && !hasDriver && Time.time > lastMovingTime + 10f;
			if (flag && (car.GetParentEntity() as BaseVehicle).IsValid())
			{
				flag = false;
			}
			if (flag)
			{
				for (int i = 0; i < wheelData.Length; i++)
				{
					ServerWheelData serverWheelData = wheelData[i];
					serverWheelData.wheelCollider.motorTorque = 0f;
					serverWheelData.wheelCollider.brakeTorque = 0f;
					serverWheelData.wheelCollider.steerAngle = 0f;
					if (vehicle.disable_wheels_when_sleeping)
					{
						((Collider)serverWheelData.wheelCollider).enabled = false;
					}
				}
				rBody.Sleep();
				goto IL_05dd;
			}
			speedAngle = Vector3.Angle(rBody.velocity, transform.forward) * Mathf.Sign(Vector3.Dot(rBody.velocity, transform.right));
			float maxDriveForce = car.GetMaxDriveForce();
			float maxForwardSpeed = car.GetMaxForwardSpeed();
			float num2 = (car.IsOn() ? car.GetThrottleInput() : 0f);
			float steerInput = car.GetSteerInput();
			float brakeInput = (InSlowSpeedExitMode ? 1f : car.GetBrakeInput());
			float num3 = 1f;
			if (num < 3f)
			{
				num3 = 2.75f;
			}
			else if (num < 9f)
			{
				float num4 = Mathf.InverseLerp(9f, 3f, num);
				num3 = Mathf.Lerp(1f, 2.75f, num4);
			}
			maxDriveForce *= num3;
			ComputeSteerAngle(num2, steerInput, dt, speed);
			if (TimeSince.op_Implicit(timeSinceWaterCheck) > 0.25f)
			{
				float num5 = car.WaterFactor();
				float num6 = 0f;
				if (car.FindTrigger<TriggerVehicleDrag>(out var result))
				{
					num6 = result.vehicleDrag;
				}
				float num7 = ((num2 != 0f) ? 0f : 0.25f);
				float num8 = Mathf.Max(num5, num6);
				num8 = Mathf.Max(num8, car.GetModifiedDrag());
				rBody.drag = Mathf.Max(num7, num8);
				rBody.angularDrag = num8 * 0.5f;
				timeSinceWaterCheck = TimeSince.op_Implicit(0f);
			}
			int num9 = 0;
			float num10 = 0f;
			int num11;
			if (!vehicleSettings.disableHandbrakes)
			{
				if (!hasDriver)
				{
					val2 = rBody.velocity;
					if (((Vector3)(ref val2)).magnitude < 2.5f && TimeSince.op_Implicit(car.timeSinceLastPush) > 2f)
					{
						num11 = ((car.OnSurface != VehicleTerrainHandler.Surface.Frictionless) ? 1 : 0);
						goto IL_0412;
					}
				}
				num11 = 0;
			}
			else
			{
				num11 = 0;
			}
			goto IL_0412;
			IL_0412:
			bool flag2 = (byte)num11 != 0;
			bool flag3 = !vehicleSettings.disableHandbrakes && !flag2 && num2 == 0f && num < 0.2f && TimeSince.op_Implicit(car.timeSinceLastPush) > 2f && car.OnSurface != VehicleTerrainHandler.Surface.Frictionless;
			for (int j = 0; j < wheelData.Length; j++)
			{
				ServerWheelData serverWheelData2 = wheelData[j];
				if (!((Collider)serverWheelData2.wheelCollider).enabled)
				{
					((Collider)serverWheelData2.wheelCollider).enabled = true;
					serverWheelData2.wheelCollider.ConfigureVehicleSubsteps(1000f, 1, 1);
				}
				serverWheelData2.wheelCollider.motorTorque = 1E-05f;
				if (flag2)
				{
					serverWheelData2.wheelCollider.brakeTorque = 10000f;
				}
				else if (flag3)
				{
					serverWheelData2.wheelCollider.brakeTorque = 1000f;
				}
				else
				{
					serverWheelData2.wheelCollider.brakeTorque = 0f;
				}
				if (serverWheelData2.wheel.steerWheel)
				{
					serverWheelData2.wheel.wheelCollider.steerAngle = (serverWheelData2.isFrontWheel ? SteerAngle : (vehicleSettings.rearWheelSteer * (0f - SteerAngle)));
				}
				UpdateSuspension(serverWheelData2);
				if (serverWheelData2.isGrounded)
				{
					num9++;
					num10 += wheelData[j].downforce;
				}
			}
			AdjustHitForces(num9, num10 / (float)num9);
			for (int k = 0; k < wheelData.Length; k++)
			{
				ServerWheelData wd = wheelData[k];
				UpdateLocalFrame(wd, dt);
				ComputeTyreForces(wd, speed, maxDriveForce, maxForwardSpeed, num2, brakeInput, num3);
				ApplyTyreForces(wd);
			}
			ComputeOverallForces();
			goto IL_05dd;
			IL_05ed:
			hadDriver = hasDriver;
			return;
			IL_05dd:
			wasSleeping = false;
			goto IL_05ed;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsGrounded()
	{
		int num = 0;
		for (int i = 0; i < wheelData.Length; i++)
		{
			if (wheelData[i].isGrounded)
			{
				num++;
			}
			if (num >= Mathf.FloorToInt((float)wheelData.Length * 0.5f))
			{
				return true;
			}
		}
		return false;
	}

	public bool IsWheelGrounded(int index)
	{
		if (index < 0 || index >= wheelData.Length)
		{
			return false;
		}
		return wheelData[index].isGrounded;
	}

	public bool HasHandbrake()
	{
		for (int i = 0; i < wheelData.Length; i++)
		{
			if (wheelData[i].wheelCollider.brakeTorque != 10000f)
			{
				return false;
			}
		}
		return true;
	}

	private void COMChanged()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			serverWheelData.forceDistance = GetWheelForceDistance(serverWheelData.wheel.wheelCollider);
		}
		prevLocalCOM = rBody.centerOfMass;
	}

	private void ComputeSteerAngle(float throttleInput, float steerInput, float dt, float speed)
	{
		if (vehicleSettings.tankSteering)
		{
			SteerAngle = 0f;
			ComputeTankSteeringThrottle(throttleInput, steerInput, speed);
			return;
		}
		float num = vehicleSettings.maxSteerAngle * steerInput;
		float num2 = Mathf.InverseLerp(0f, vehicleSettings.minSteerLimitSpeed, speed);
		if (vehicleSettings.steeringLimit)
		{
			float num3 = vehicleSettings.maxSteerAngle * car.GetSteerMaxMult(speed);
			float num4 = vehicleSettings.minSteerLimitAngle * car.GetSteerMaxMult(speed);
			float num5 = Mathf.Lerp(num3, num4, num2);
			num = Mathf.Clamp(num, 0f - num5, num5);
		}
		float num6 = 0f;
		if (vehicleSettings.steeringAssist)
		{
			float num7 = Mathf.InverseLerp(0.1f, 3f, speed);
			num6 = speedAngle * vehicleSettings.steeringAssistRatio * num7 * Mathf.InverseLerp(2f, 3f, Mathf.Abs(speedAngle));
		}
		float num8 = Mathf.Clamp(num + num6, 0f - vehicleSettings.maxSteerAngle, vehicleSettings.maxSteerAngle);
		if (SteerAngle == num8)
		{
			steerLerpSpeed = 0f;
			return;
		}
		float num9 = Mathf.Abs(SteerAngle / num8);
		float num10 = 1f - num2 * 0.7f;
		bool steerSpeedMod = car.GetSteerSpeedMod(speed);
		if ((SteerAngle == 0f || Mathf.Sign(num8) == Mathf.Sign(SteerAngle)) && Mathf.Abs(num8) > Mathf.Abs(SteerAngle))
		{
			float num11 = SteerAngle / vehicleSettings.maxSteerAngle;
			float num12 = vehicleSettings.steerMinLerpSpeed;
			if (steerSpeedMod)
			{
				num12 *= 1.8f;
			}
			float num13 = Mathf.Lerp(num12 * num10, vehicleSettings.steerMaxLerpSpeed * num10, num11 * num11);
			if (Mathf.Abs(num8) > Mathf.Abs(SteerAngle) && num9 > 0.85f)
			{
				num13 = Mathf.Lerp(num13, 0f, num9);
			}
			if (!vehicleSettings.retainLerpSpeed || num13 > steerLerpSpeed)
			{
				steerLerpSpeed = num13;
			}
		}
		else
		{
			float num14 = vehicleSettings.steerReturnLerpSpeed;
			if (num8 != 0f && Mathf.Sign(num8) != Mathf.Sign(SteerAngle))
			{
				num14 *= 1.33f;
			}
			if (steerSpeedMod)
			{
				num14 *= 1.5f;
			}
			steerLerpSpeed = num14 * num10;
		}
		if (steerSpeedMod)
		{
			steerLerpSpeed *= 1.2f;
		}
		SteerAngle = Mathf.MoveTowards(SteerAngle, num8, dt * steerLerpSpeed);
	}

	private float GetWheelForceDistance(WheelCollider col)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		return rBody.centerOfMass.y - transform.InverseTransformPoint(((Component)col).transform.position).y + col.radius + (1f - col.suspensionSpring.targetPosition) * col.suspensionDistance;
	}

	private void UpdateSuspension(ServerWheelData wd)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		wd.isGrounded = wd.wheelCollider.GetGroundHit(ref wd.hit);
		wd.origin = wd.wheelColliderTransform.TransformPoint(wd.wheelCollider.center);
		if (wd.isGrounded && GamePhysics.Trace(new Ray(wd.origin, -wd.wheelColliderTransform.up), 0f, out var hitInfo, wd.wheelCollider.suspensionDistance + wd.wheelCollider.radius, 1235321089, (QueryTriggerInteraction)1))
		{
			((WheelHit)(ref wd.hit)).point = ((RaycastHit)(ref hitInfo)).point;
			((WheelHit)(ref wd.hit)).normal = ((RaycastHit)(ref hitInfo)).normal;
		}
		if (wd.isGrounded)
		{
			if (((WheelHit)(ref wd.hit)).force < 0f)
			{
				((WheelHit)(ref wd.hit)).force = 0f;
			}
			wd.downforce = ((WheelHit)(ref wd.hit)).force;
		}
		else
		{
			wd.downforce = 0f;
		}
	}

	private void AdjustHitForces(int groundedWheels, float neutralForcePerWheel)
	{
		float num = neutralForcePerWheel * 0.25f;
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			if (!serverWheelData.isGrounded || !(serverWheelData.downforce < num))
			{
				continue;
			}
			if (groundedWheels == 1)
			{
				serverWheelData.downforce = num;
				continue;
			}
			float num2 = (num - serverWheelData.downforce) / (float)(groundedWheels - 1);
			serverWheelData.downforce = num;
			for (int j = 0; j < wheelData.Length; j++)
			{
				ServerWheelData serverWheelData2 = wheelData[j];
				if (serverWheelData2.isGrounded && serverWheelData2.downforce > num)
				{
					float num3 = Mathf.Min(num2, serverWheelData2.downforce - num);
					serverWheelData2.downforce -= num3;
				}
			}
		}
	}

	private void UpdateLocalFrame(ServerWheelData wd, float dt)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		if (!wd.isGrounded)
		{
			((WheelHit)(ref wd.hit)).point = wd.origin - wd.wheelColliderTransform.up * (wd.wheelCollider.suspensionDistance + wd.wheelCollider.radius);
			((WheelHit)(ref wd.hit)).normal = wd.wheelColliderTransform.up;
			((WheelHit)(ref wd.hit)).collider = null;
		}
		Vector3 pointVelocity = rBody.GetPointVelocity(((WheelHit)(ref wd.hit)).point);
		wd.velocity = pointVelocity - Vector3.Project(pointVelocity, ((WheelHit)(ref wd.hit)).normal);
		wd.localVelocity.y = Vector3.Dot(((WheelHit)(ref wd.hit)).forwardDir, wd.velocity);
		wd.localVelocity.x = Vector3.Dot(((WheelHit)(ref wd.hit)).sidewaysDir, wd.velocity);
		if (!wd.isGrounded)
		{
			wd.localRigForce = Vector2.zero;
			return;
		}
		float num = Mathf.InverseLerp(1f, 0.25f, ((Vector3)(ref wd.velocity)).sqrMagnitude);
		Vector2 val3 = default(Vector2);
		if (num > 0f)
		{
			float num2 = Vector3.Dot(Vector3.up, ((WheelHit)(ref wd.hit)).normal);
			Vector3 val2;
			if (num2 > 1E-06f)
			{
				Vector3 val = Vector3.up * wd.downforce / num2;
				val2 = val - Vector3.Project(val, ((WheelHit)(ref wd.hit)).normal);
			}
			else
			{
				val2 = Vector3.up * 100000f;
			}
			val3.y = Vector3.Dot(((WheelHit)(ref wd.hit)).forwardDir, val2);
			val3.x = Vector3.Dot(((WheelHit)(ref wd.hit)).sidewaysDir, val2);
			val3 *= num;
		}
		else
		{
			val3 = Vector2.zero;
		}
		Vector2 val4 = (0f - Mathf.Clamp(wd.downforce / (0f - Physics.gravity.y), 0f, wd.wheelCollider.sprungMass) * 0.5f) * wd.localVelocity / dt;
		wd.localRigForce = val4 + val3;
	}

	private void ComputeTyreForces(ServerWheelData wd, float speed, float maxDriveForce, float maxSpeed, float throttleInput, float brakeInput, float driveForceMultiplier)
	{
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		float absSpeed = Mathf.Abs(speed);
		if (vehicleSettings.tankSteering && brakeInput == 0f)
		{
			throttleInput = ((!wd.isLeftWheel) ? TankThrottleRight : TankThrottleLeft);
		}
		float num = (wd.wheel.powerWheel ? throttleInput : 0f);
		wd.hasThrottleInput = num != 0f;
		float num2 = vehicleSettings.maxDriveSlip;
		if (Mathf.Sign(num) != Mathf.Sign(wd.localVelocity.y))
		{
			num2 -= wd.localVelocity.y * Mathf.Sign(num);
		}
		float num3 = Mathf.Abs(num);
		float num4 = 0f - vehicleSettings.rollingResistance + num3 * (1f + vehicleSettings.rollingResistance) - brakeInput * (1f - vehicleSettings.rollingResistance);
		if (InSlowSpeedExitMode || num4 < 0f || maxDriveForce == 0f)
		{
			num4 *= -1f;
			wd.isBraking = true;
		}
		else
		{
			num4 *= Mathf.Sign(num);
			wd.isBraking = false;
		}
		float num6;
		if (wd.isBraking)
		{
			float num5 = Mathf.Clamp(car.GetMaxForwardSpeed() * vehicleSettings.brakeForceMultiplier, 10f * vehicleSettings.brakeForceMultiplier, 50f * vehicleSettings.brakeForceMultiplier);
			num5 += rBody.mass * 1.5f;
			num6 = num4 * num5;
		}
		else
		{
			num6 = ComputeDriveForce(speed, absSpeed, num4 * maxDriveForce, maxDriveForce, maxSpeed, driveForceMultiplier);
		}
		if (wd.isGrounded)
		{
			wd.tyreSlip.x = wd.localVelocity.x;
			wd.tyreSlip.y = wd.localVelocity.y - wd.angularVelocity * wd.wheelCollider.radius;
			float num7 = car.OnSurface switch
			{
				VehicleTerrainHandler.Surface.Road => 1f, 
				VehicleTerrainHandler.Surface.Ice => 0.25f, 
				VehicleTerrainHandler.Surface.Frictionless => 0f, 
				_ => 0.75f, 
			};
			float num8 = wd.wheel.tyreFriction * wd.downforce * num7;
			float num9 = 0f;
			if (!wd.isBraking)
			{
				num9 = Mathf.Min(Mathf.Abs(num6 * wd.tyreSlip.x) / num8, num2);
				if (num6 != 0f && num9 < 0.1f)
				{
					num9 = 0.1f;
				}
			}
			if (Mathf.Abs(wd.tyreSlip.y) < num9)
			{
				wd.tyreSlip.y = num9 * Mathf.Sign(wd.tyreSlip.y);
			}
			Vector2 val = (0f - num8) * ((Vector2)(ref wd.tyreSlip)).normalized;
			val.x = Mathf.Abs(val.x) * 1.5f;
			val.y = Mathf.Abs(val.y);
			wd.tyreForce.x = Mathf.Clamp(wd.localRigForce.x, 0f - val.x, val.x);
			if (wd.isBraking)
			{
				float num10 = Mathf.Min(val.y, num6);
				wd.tyreForce.y = Mathf.Clamp(wd.localRigForce.y, 0f - num10, num10);
			}
			else
			{
				wd.tyreForce.y = Mathf.Clamp(num6, 0f - val.y, val.y);
			}
		}
		else
		{
			wd.tyreSlip = Vector2.zero;
			wd.tyreForce = Vector2.zero;
		}
		if (wd.isGrounded)
		{
			float num11;
			if (wd.isBraking)
			{
				num11 = 0f;
			}
			else
			{
				float driveForceToMaxSlip = vehicleSettings.driveForceToMaxSlip;
				num11 = Mathf.Clamp01((Mathf.Abs(num6) - Mathf.Abs(wd.tyreForce.y)) / driveForceToMaxSlip) * num2 * Mathf.Sign(num6);
			}
			wd.angularVelocity = (wd.localVelocity.y + num11) / wd.wheelCollider.radius;
			return;
		}
		float num12 = 50f;
		float num13 = 10f;
		if (num > 0f)
		{
			wd.angularVelocity += num12 * num;
		}
		else
		{
			wd.angularVelocity -= num13;
		}
		wd.angularVelocity -= num12 * brakeInput;
		wd.angularVelocity = Mathf.Clamp(wd.angularVelocity, 0f, maxSpeed / wd.wheelCollider.radius);
	}

	private void ComputeTankSteeringThrottle(float throttleInput, float steerInput, float speed)
	{
		TankThrottleLeft = throttleInput;
		TankThrottleRight = throttleInput;
		float tankSteerInvert = GetTankSteerInvert(throttleInput, speed);
		if (throttleInput == 0f)
		{
			TankThrottleLeft = 0f - steerInput;
			TankThrottleRight = steerInput;
		}
		else if (steerInput > 0f)
		{
			TankThrottleLeft = Mathf.Lerp(throttleInput, -1f * tankSteerInvert, steerInput);
			TankThrottleRight = Mathf.Lerp(throttleInput, 1f * tankSteerInvert, steerInput);
		}
		else if (steerInput < 0f)
		{
			TankThrottleLeft = Mathf.Lerp(throttleInput, 1f * tankSteerInvert, 0f - steerInput);
			TankThrottleRight = Mathf.Lerp(throttleInput, -1f * tankSteerInvert, 0f - steerInput);
		}
	}

	private float ComputeDriveForce(float speed, float absSpeed, float demandedForce, float maxForce, float maxForwardSpeed, float driveForceMultiplier)
	{
		float num = ((speed >= 0f) ? maxForwardSpeed : (maxForwardSpeed * vehicleSettings.reversePercentSpeed));
		if (absSpeed < num)
		{
			if ((speed >= 0f || demandedForce <= 0f) && (speed <= 0f || demandedForce >= 0f))
			{
				maxForce = car.GetAdjustedDriveForce(absSpeed, maxForwardSpeed) * driveForceMultiplier;
			}
			return Mathf.Clamp(demandedForce, 0f - maxForce, maxForce);
		}
		float num2 = maxForce * Mathf.Max(1f - absSpeed / num, -1f) * Mathf.Sign(speed);
		if ((speed < 0f && demandedForce > 0f) || (speed > 0f && demandedForce < 0f))
		{
			num2 = Mathf.Clamp(num2 + demandedForce, 0f - maxForce, maxForce);
		}
		return num2;
	}

	private void ComputeOverallForces()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		DriveWheelVelocity = 0f;
		DriveWheelSlip = 0f;
		int num = 0;
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			if (serverWheelData.wheel.powerWheel)
			{
				DriveWheelVelocity += serverWheelData.angularVelocity;
				if (serverWheelData.isGrounded)
				{
					float num2 = ComputeCombinedSlip(serverWheelData.localVelocity, serverWheelData.tyreSlip);
					DriveWheelSlip += num2;
				}
				num++;
			}
		}
		if (num > 0)
		{
			DriveWheelVelocity /= num;
			DriveWheelSlip /= num;
		}
	}

	private static float ComputeCombinedSlip(Vector2 localVelocity, Vector2 tyreSlip)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float magnitude = ((Vector2)(ref localVelocity)).magnitude;
		if (magnitude > 0.01f)
		{
			float num = tyreSlip.x * localVelocity.x / magnitude;
			float y = tyreSlip.y;
			return Mathf.Sqrt(num * num + y * y);
		}
		return ((Vector2)(ref tyreSlip)).magnitude;
	}

	private void ApplyTyreForces(ServerWheelData wd)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		if (wd.isGrounded)
		{
			Vector3 val = ((WheelHit)(ref wd.hit)).forwardDir * wd.tyreForce.y;
			Vector3 val2 = ((WheelHit)(ref wd.hit)).sidewaysDir * wd.tyreForce.x;
			Vector3 sidewaysForceAppPoint = GetSidewaysForceAppPoint(wd, ((WheelHit)(ref wd.hit)).point);
			rBody.AddForceAtPosition(val, ((WheelHit)(ref wd.hit)).point, (ForceMode)0);
			rBody.AddForceAtPosition(val2, sidewaysForceAppPoint, (ForceMode)0);
		}
	}

	private Vector3 GetSidewaysForceAppPoint(ServerWheelData wd, Vector3 contactPoint)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = contactPoint + wd.wheelColliderTransform.up * vehicleSettings.antiRoll * wd.forceDistance;
		float num = (wd.wheel.steerWheel ? SteerAngle : 0f);
		if (num != 0f && Mathf.Sign(num) != Mathf.Sign(wd.tyreSlip.x))
		{
			val += wd.wheelColliderTransform.forward * midWheelPos * (vehicleSettings.handlingBias - 0.5f);
		}
		return val;
	}

	private float GetTankSteerInvert(float throttleInput, float speed)
	{
		float result = 1f;
		if (throttleInput < 0f && speed < 1.75f)
		{
			result = -1f;
		}
		else if (throttleInput == 0f && speed < -1f)
		{
			result = -1f;
		}
		else if (speed < -1f)
		{
			result = -1f;
		}
		return result;
	}
}


public interface ICar
{
	VehicleTerrainHandler.Surface OnSurface { get; }

	float GetThrottleInput();

	float GetBrakeInput();

	float GetSteerInput();

	bool GetSteerSpeedMod(float speed);

	float GetSteerMaxMult(float speed);

	float GetMaxForwardSpeed();

	float GetMaxDriveForce();

	float GetAdjustedDriveForce(float absSpeed, float topSpeed);

	float GetModifiedDrag();

	CarWheel[] GetWheels();

	float GetWheelsMidPos();
}


using UnityEngine;

private class ServerWheelData
{
	public CarWheel wheel;

	public Transform wheelColliderTransform;

	public WheelCollider wheelCollider;

	public bool isGrounded;

	public float downforce;

	public float forceDistance;

	public WheelHit hit;

	public Vector2 localRigForce;

	public Vector2 localVelocity;

	public float angularVelocity;

	public Vector3 origin;

	public Vector2 tyreForce;

	public Vector2 tyreSlip;

	public Vector3 velocity;

	public bool isBraking;

	public bool hasThrottleInput;

	public bool isFrontWheel;

	public bool isLeftWheel;
}


using UnityEngine;

public class CrushTrigger : TriggerHurt
{
	public bool includeNPCs = true;

	public bool requireCentreBelowPosition;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!includeNPCs && baseEntity.IsNpc)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	protected override bool CanHurt(BaseCombatEntity ent)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (requireCentreBelowPosition && ent.CenterPoint().y > ((Component)this).transform.position.y)
		{
			return false;
		}
		return base.CanHurt(ent);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DamageRenderer : MonoBehaviour, IClientComponent
{
	[Serializable]
	private struct DamageShowingRenderer
	{
		public Renderer renderer;

		public int[] indices;

		public DamageShowingRenderer(Renderer renderer, int[] indices)
		{
			this.renderer = renderer;
			this.indices = indices;
		}
	}

	[SerializeField]
	private List<Material> damageShowingMats;

	[SerializeField]
	private float maxDamageOpacity = 0.9f;

	[SerializeField]
	[HideInInspector]
	private List<DamageShowingRenderer> damageShowingRenderers;

	[SerializeField]
	[HideInInspector]
	private List<GlassPane> damageShowingGlassRenderers;
}


using System;
using UnityEngine;

[Serializable]
private struct DamageShowingRenderer
{
	public Renderer renderer;

	public int[] indices;

	public DamageShowingRenderer(Renderer renderer, int[] indices)
	{
		this.renderer = renderer;
		this.indices = indices;
	}
}


using UnityEngine;

public class DiverPropulsionVehicleAudio : MonoBehaviour
{
	[SerializeField]
	[Header("Engine")]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineStartFailSound;

	[SerializeField]
	private SoundDefinition engineLoopSound;

	[SerializeField]
	private AnimationCurve engineLoopPitchCurve;

	[SerializeField]
	private SoundDefinition engineActiveLoopDef;

	[Header("Propeller")]
	[SerializeField]
	private SoundDefinition propellerLoopSoundDef;

	[SerializeField]
	private AnimationCurve propellerPitchCurve;

	[SerializeField]
	private AnimationCurve propellerGainCurve;

	[SerializeField]
	[Header("Water")]
	private SoundDefinition waterMovementLoopDef;

	[SerializeField]
	private AnimationCurve waterMovementGainCurve;

	[SerializeField]
	private SoundDefinition waterSurfaceLoopDef;

	[SerializeField]
	private float surfaceWaterMovementStartDepth = 0.2f;

	[SerializeField]
	private float surfaceWaterMovementEndDepth = 2f;

	[SerializeField]
	private float waterMovementYSpeedScale = 0.2f;

	[SerializeField]
	private SoundDefinition waterEmergeSoundDef;

	[SerializeField]
	private SoundDefinition waterSubmergeSoundDef;
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public abstract class GroundVehicle : BaseVehicle, IEngineControllerUser, IEntity, TriggerHurtNotChild.IHurtTriggerUser
{
	[Header("GroundVehicle")]
	[SerializeField]
	public GroundVehicleAudio gvAudio;

	[SerializeField]
	private GameObjectRef fuelStoragePrefab;

	[SerializeField]
	public Transform waterloggedPoint;

	[SerializeField]
	public GameObjectRef collisionEffect;

	[SerializeField]
	public float engineStartupTime = 0.5f;

	[SerializeField]
	private float minCollisionDamageForce = 20000f;

	[SerializeField]
	private float maxCollisionDamageForce = 2500000f;

	[SerializeField]
	private float collisionDamageMultiplier = 1f;

	[SerializeField]
	private Rigidbody secondaryRigidbody;

	public VehicleEngineController<GroundVehicle> engineController;

	private Dictionary<BaseEntity, float> damageSinceLastTick = new Dictionary<BaseEntity, float>();

	private float nextCollisionDamageTime;

	private float dragMod;

	private float dragModDuration;

	private TimeSince timeSinceDragModSet;

	public Vector3 Velocity { get; protected set; }

	public abstract float DriveWheelVelocity { get; }

	public bool LightsAreOn => HasFlag(Flags.Reserved5);

	public VehicleEngineController<GroundVehicle>.EngineState CurEngineState => engineController.CurEngineState;

	public override void InitShared()
	{
		base.InitShared();
		CreateEngineController();
	}

	protected virtual void CreateEngineController()
	{
		engineController = new VehicleEngineController<GroundVehicle>(this, CreateFuelSystem(), base.isServer, engineStartupTime, waterloggedPoint);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			ServerFlagsChanged(old, next);
		}
	}

	public override float GetSpeed()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (IsStationary())
		{
			return 0f;
		}
		return Vector3.Dot(Velocity, ((Component)this).transform.forward);
	}

	public abstract float GetMaxForwardSpeed();

	public abstract float GetThrottleInput();

	public abstract float GetBrakeInput();

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (pusher.isMounted || pusher.IsSwimming())
		{
			return false;
		}
		return !pusher.IsStandingOnEntity(this, 8192);
	}

	protected virtual IFuelSystem CreateFuelSystem()
	{
		return new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		timeSinceDragModSet = default(TimeSince);
		timeSinceDragModSet = TimeSince.op_Implicit(float.MaxValue);
	}

	public abstract void OnEngineStartFailed();

	public abstract bool MeetsEngineRequirements();

	protected virtual void ServerFlagsChanged(Flags old, Flags next)
	{
	}

	protected void OnCollisionEnter(Collision collision)
	{
		if (base.isServer)
		{
			ProcessCollision(collision, rigidBody);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GroundVehicle.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (base.IsMovingOrOn)
			{
				Velocity = GetLocalVelocity();
			}
			else
			{
				Velocity = Vector3.zero;
			}
			if (LightsAreOn && !AnyMounted())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
			if (!(Time.time >= nextCollisionDamageTime))
			{
				return;
			}
			nextCollisionDamageTime = Time.time + 0.33f;
			foreach (KeyValuePair<BaseEntity, float> item in damageSinceLastTick)
			{
				DoCollisionDamage(item.Key, item.Value);
			}
			damageSinceLastTick.Clear();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !LightsAreOn);
		}
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return Mathf.Abs(GetSpeed()) * 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && !hurtEntity.IsDestroyed)
		{
			Vector3 val = hurtEntity.GetLocalVelocity() - Velocity;
			Vector3 val2 = ClosestPoint(((Component)hurtEntity).transform.position);
			Vector3 val3 = Mathf.Min(hurtEntity.RealisticMass, RealisticMass) * val;
			rigidBody.AddForceAtPosition(val3 * 1.25f, val2, (ForceMode)1);
			if ((Object)(object)secondaryRigidbody != (Object)null)
			{
				secondaryRigidbody.AddForceAtPosition(val3 * 1.25f, val2, (ForceMode)1);
			}
			QueueCollisionDamage(this, ((Vector3)(ref val3)).magnitude * 0.1f / Time.deltaTime);
			SetTempDrag(2.25f, 1f);
		}
	}

	private float QueueCollisionDamage(BaseEntity hitEntity, float forceMagnitude)
	{
		float num = Mathf.InverseLerp(minCollisionDamageForce, maxCollisionDamageForce, forceMagnitude);
		if (num > 0f)
		{
			float num2 = Mathf.Lerp(1f, 200f, num) * collisionDamageMultiplier;
			if (damageSinceLastTick.TryGetValue(hitEntity, out var value))
			{
				if (value < num2)
				{
					damageSinceLastTick[hitEntity] = num2;
				}
			}
			else
			{
				damageSinceLastTick[hitEntity] = num2;
			}
		}
		return num;
	}

	protected virtual void DoCollisionDamage(BaseEntity hitEntity, float damage)
	{
		Hurt(damage, DamageType.Collision, this, useProtection: false);
	}

	protected virtual void ProcessCollision(Collision collision, Rigidbody ourRigidbody)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || collision == null || (Object)(object)collision.gameObject == (Object)null || (Object)(object)collision.gameObject == (Object)null)
		{
			return;
		}
		ContactPoint contact = collision.GetContact(0);
		BaseEntity baseEntity = null;
		if ((Object)(object)((ContactPoint)(ref contact)).otherCollider.attachedRigidbody == (Object)(object)ourRigidbody)
		{
			baseEntity = ((ContactPoint)(ref contact)).otherCollider.ToBaseEntity();
		}
		else if ((Object)(object)((ContactPoint)(ref contact)).thisCollider.attachedRigidbody == (Object)(object)ourRigidbody)
		{
			baseEntity = ((ContactPoint)(ref contact)).thisCollider.ToBaseEntity();
		}
		if ((Object)(object)baseEntity != (Object)null)
		{
			Vector3 impulse = collision.impulse;
			impulse.y *= 0.5f;
			float num = ((Vector3)(ref impulse)).magnitude / Time.fixedDeltaTime;
			if (collision.gameObject.ToBaseEntity() is RidableHorse)
			{
				num *= 0.5f;
			}
			if (QueueCollisionDamage(baseEntity, num) > 0f)
			{
				TryShowCollisionFX(collision);
			}
		}
	}

	public override GameObjectRef GetCollisionFX()
	{
		return collisionEffect;
	}

	public virtual float GetModifiedDrag()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return (1f - Mathf.InverseLerp(0f, dragModDuration, TimeSince.op_Implicit(timeSinceDragModSet))) * dragMod;
	}

	public override IFuelSystem GetFuelSystem()
	{
		return engineController?.FuelSystem;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned)
		{
			GetFuelSystem()?.CheckNewChild(child);
		}
	}

	private void SetTempDrag(float drag, float duration)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		dragMod = Mathf.Clamp(drag, 0f, 1000f);
		timeSinceDragModSet = TimeSince.op_Implicit(0f);
		dragModDuration = duration;
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


using UnityEngine;

public abstract class GroundVehicleAudio : MonoBehaviour, IClientComponent
{
	[SerializeField]
	protected GroundVehicle groundVehicle;

	[Header("Engine")]
	[SerializeField]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineStartFailSound;

	[SerializeField]
	protected BlendedLoopEngineSound blendedEngineLoops;

	[SerializeField]
	private float wheelRatioMultiplier = 600f;

	[SerializeField]
	private float overallVolume = 1f;

	[Header("Water")]
	[SerializeField]
	private SoundDefinition waterSplashSoundDef;

	[SerializeField]
	private BlendedSoundLoops waterLoops;

	[SerializeField]
	private float waterSoundsMaxSpeed = 10f;

	[Header("Brakes")]
	[SerializeField]
	private SoundDefinition brakeSoundDef;

	[SerializeField]
	private SoundDefinition brakeStartSoundDef;

	[SerializeField]
	private SoundDefinition brakeStopSoundDef;

	[SerializeField]
	[Header("Lights")]
	protected SoundDefinition lightsToggleSound;
}


using UnityEngine;

public class AttackHeliDriverSeat : BaseVehicleSeat
{
	[SerializeField]
	private Sprite rocketCrosshair;

	[SerializeField]
	private Sprite incendRocketCrosshair;

	[SerializeField]
	private Sprite hvRocketCrosshair;

	[SerializeField]
	private Sprite reloadingCrosshair;

	[SerializeField]
	private GameObjectRef rocketHVItem;

	[SerializeField]
	private GameObjectRef rocketIncenItem;

	private AttackHelicopter _owner;

	private AttackHelicopter Owner
	{
		get
		{
			if ((Object)(object)_owner == (Object)null)
			{
				_owner = ((Component)this).GetComponentInParent<AttackHelicopter>();
			}
			return _owner;
		}
	}
}


using UnityEngine;

public class AttackHeliGunnerSeat : BaseVehicleSeat
{
	private AttackHelicopter _owner;

	private AttackHelicopter Owner
	{
		get
		{
			if ((Object)(object)_owner == (Object)null)
			{
				_owner = ((Component)this).GetComponentInParent<AttackHelicopter>();
			}
			return _owner;
		}
	}

	public override bool CanHoldItems()
	{
		if ((Object)(object)Owner != (Object)null)
		{
			return !Owner.GunnerIsInGunnerView;
		}
		return false;
	}

	public override Transform GetEyeOverride()
	{
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.gunnerEyePos;
		}
		return base.GetEyeOverride();
	}

	public override Vector3 EyePositionForPlayer(BasePlayer player, Quaternion lookRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetMounted() != (Object)(object)this)
		{
			return Vector3.zero;
		}
		return GetEyeOverride().position;
	}

	public override Vector3 EyeCenterForPlayer(BasePlayer player, Quaternion lookRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetMounted() != (Object)(object)this)
		{
			return Vector3.zero;
		}
		return GetEyeOverride().position;
	}

	public override Vector2 GetPitchClamp()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.turretPitchClamp;
		}
		return pitchClamp;
	}

	public override Vector2 GetYawClamp()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.turretYawClamp;
		}
		return yawClamp;
	}
}


using Oxide.Core;
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class AttackHeliPilotFlare : MonoBehaviour, SeekerTarget.ISeekerTargetOwner
{
	protected void Start()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.HIGH);
	}

	protected void OnDestroy()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
	}

	public void Init(Vector3 initialVelocity)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).GetComponent<Rigidbody>().velocity = initialVelocity;
	}

	public Vector3 CenterPoint()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public bool IsVisible(Vector3 from, float maxDistance = float.PositiveInfinity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.LineOfSight(from, CenterPoint(), 1218519041);
	}

	public bool InSafeZone()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckSphere<TriggerSafeZone>(CenterPoint(), 0.1f, 262144, (QueryTriggerInteraction)2);
	}

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public void OnEntityMessage(BaseEntity from, string msg)
	{
	}
}


using Rust.UI;
using UnityEngine;

public class AttackHeliUIDialog : UIDialog
{
	[Header("Attack Helicopter")]
	[SerializeField]
	private Material compassStripMat;

	[SerializeField]
	private Canvas mainCanvas;

	[SerializeField]
	private CanvasGroup gunCrosshair;

	[SerializeField]
	private CanvasGroup gunNoAmmoCrosshair;

	[SerializeField]
	private CanvasGroup gunCrosshairGhost;

	[SerializeField]
	private RectTransform gunCrosshairGhostRect;

	[SerializeField]
	private Canvas rocketCrosshairDefaultCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairDefaultRect;

	[SerializeField]
	private Canvas rocketCrosshairHVCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairHVRect;

	[SerializeField]
	private Canvas rocketCrosshairIncenCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairIncenRect;

	[SerializeField]
	private GameObjectRef rocketHVItem;

	[SerializeField]
	private GameObjectRef rocketIncenItem;

	[SerializeField]
	private CanvasGroup crosshairHitMarkerGroup;

	[SerializeField]
	private RectTransform zoomIndicator;

	[SerializeField]
	private RectTransform positionBox;

	[SerializeField]
	private RustText ammoTextGunMag;

	[SerializeField]
	private RustText ammoTextGunRest;

	[SerializeField]
	private RustText ammoTextRocketMag;

	[SerializeField]
	private RustText ammoTextRocketRest;

	[SerializeField]
	private RustText rangeText;

	[SerializeField]
	private float zoomIndicatorMinY;

	[SerializeField]
	private float zoomIndicatorMaxY;

	[SerializeField]
	private float positionBoxXMult;

	[SerializeField]
	private float positionBoxYMult;

	[SerializeField]
	private Animator damageWarning;
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using Rust;
using UnityEngine;

public abstract class BaseHelicopter : BaseVehicle, SeekerTarget.ISeekerTargetOwner
{
	[Serializable]
	protected class GroundEffect
	{
		public ParticleSystem effect;

		public Transform groundPoint;
	}

	public class HelicopterInputState
	{
		public float throttle;

		public float roll;

		public float yaw;

		public float pitch;

		public bool groundControl;

		public void Reset()
		{
			throttle = 0f;
			roll = 0f;
			yaw = 0f;
			pitch = 0f;
			groundControl = false;
		}
	}

	[Header("Helicopter")]
	[SerializeField]
	public float engineThrustMax;

	[SerializeField]
	public Vector3 torqueScale;

	[SerializeField]
	protected Transform com;

	[SerializeField]
	public GameObject[] killTriggers;

	[SerializeField]
	protected GroundEffect[] groundEffects;

	[SerializeField]
	public GameObjectRef serverGibs;

	[SerializeField]
	public GameObjectRef explosionEffect;

	[SerializeField]
	public GameObjectRef fireBall;

	[SerializeField]
	public GameObjectRef crashEffect;

	[Range(0.1f, 0.95f)]
	[SerializeField]
	[Tooltip("Lower values mean more lift is produced at high angles.")]
	public float liftDotMax = 0.75f;

	[SerializeField]
	[Range(0.1f, 0.95f)]
	public float altForceDotMin = 0.85f;

	[Range(0.1f, 0.95f)]
	[SerializeField]
	public float liftFraction = 0.25f;

	[SerializeField]
	public float thrustLerpSpeed = 1f;

	public const Flags Flag_InternalLights = Flags.Reserved6;

	public float currentThrottle;

	public float avgThrust;

	public float avgTerrainHeight;

	public HelicopterInputState currentInputState = new HelicopterInputState();

	public float lastPlayerInputTime;

	public float hoverForceScale = 0.99f;

	public Vector3 damageTorque;

	public float nextDamageTime;

	public float nextEffectTime;

	public float pendingImpactDamage;

	public bool autoHover { get; set; }

	public virtual bool ForceMovementHandling => false;

	public virtual float GetServiceCeiling()
	{
		return 1000f;
	}

	public virtual float GetMinimumAltitudeTerrain()
	{
		return 0f;
	}

	public override float MaxVelocity()
	{
		return 50f;
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.centerOfMass = com.localPosition;
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	internal override void DoServerDestroy()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.DoServerDestroy();
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			if (!autoHover)
			{
				PilotInput(inputState, player);
			}
		}
		else
		{
			PassengerInput(inputState, player);
		}
	}

	public bool ToggleAutoHover(BasePlayer player)
	{
		autoHover = !autoHover;
		if (autoHover && !IsEngineOn())
		{
			TryStartEngine(player);
		}
		return autoHover;
	}

	public virtual void PilotInput(InputState inputState, BasePlayer player)
	{
		currentInputState.Reset();
		currentInputState.throttle = (inputState.IsDown(BUTTON.FORWARD) ? 1f : 0f);
		currentInputState.throttle -= ((inputState.IsDown(BUTTON.BACKWARD) || inputState.IsDown(BUTTON.DUCK)) ? 1f : 0f);
		currentInputState.pitch = inputState.current.mouseDelta.y;
		currentInputState.roll = 0f - inputState.current.mouseDelta.x;
		currentInputState.yaw = (inputState.IsDown(BUTTON.RIGHT) ? 1f : 0f);
		currentInputState.yaw -= (inputState.IsDown(BUTTON.LEFT) ? 1f : 0f);
		currentInputState.pitch = MouseToBinary(currentInputState.pitch);
		currentInputState.roll = MouseToBinary(currentInputState.roll);
		lastPlayerInputTime = Time.time;
		static float MouseToBinary(float amount)
		{
			return Mathf.Clamp(amount, -1f, 1f);
		}
	}

	public virtual void PassengerInput(InputState inputState, BasePlayer player)
	{
	}

	public virtual void SetDefaultInputState()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		currentInputState.Reset();
		if (HasDriver())
		{
			float num = Vector3.Dot(Vector3.up, ((Component)this).transform.right);
			float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
			currentInputState.roll = ((num < 0f) ? 1f : 0f);
			currentInputState.roll -= ((num > 0f) ? 1f : 0f);
			if (num2 < -0f)
			{
				currentInputState.pitch = -1f;
			}
			else if (num2 > 0f)
			{
				currentInputState.pitch = 1f;
			}
		}
		else
		{
			currentInputState.throttle = -1f;
		}
	}

	public virtual bool IsEnginePowered()
	{
		return true;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseHelicopter.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (Time.time > lastPlayerInputTime + 0.5f)
			{
				SetDefaultInputState();
			}
			EnableGlobalBroadcast(IsEngineOn());
			if (IsEngineOn() || ForceMovementHandling)
			{
				MovementUpdate();
			}
			else if (!HasDriver() && TimeSince.op_Implicit(timeSinceLastPush) > 2f)
			{
				ApplyHandbrake();
			}
			SetFlag(Flags.Reserved6, TOD_Sky.Instance.IsNight);
			GameObject[] array = killTriggers;
			foreach (GameObject obj in array)
			{
				bool active = rigidBody.velocity.y < 0f;
				obj.SetActive(active);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !HasFlag(Flags.Reserved5));
		}
	}

	public virtual bool IsEngineOn()
	{
		return true;
	}

	protected virtual void TryStartEngine(BasePlayer player)
	{
	}

	protected abstract void ApplyHandbrake();

	public void ClearDamageTorque()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		SetDamageTorque(Vector3.zero);
	}

	public void SetDamageTorque(Vector3 newTorque)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		damageTorque = newTorque;
	}

	public void AddDamageTorque(Vector3 torqueToAdd)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		damageTorque += torqueToAdd;
	}

	public virtual void MovementUpdate()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		HelicopterInputState helicopterInputState = currentInputState;
		if (autoHover)
		{
			float num = 50f - ((Component)this).transform.position.y;
			helicopterInputState.throttle = Mathf.Clamp(num * 0.01f, -1f, 1f);
			helicopterInputState.pitch = 0f;
			helicopterInputState.roll = 0f;
			helicopterInputState.yaw = 0f;
		}
		if (helicopterInputState.groundControl)
		{
			currentThrottle = -0.75f;
		}
		else
		{
			currentThrottle = Mathf.Lerp(currentThrottle, helicopterInputState.throttle, 2f * Time.fixedDeltaTime);
			currentThrottle = Mathf.Clamp(currentThrottle, -0.8f, 1f);
			if (helicopterInputState.pitch != 0f || helicopterInputState.roll != 0f || helicopterInputState.yaw != 0f)
			{
				rigidBody.AddRelativeTorque(new Vector3(helicopterInputState.pitch * torqueScale.x, helicopterInputState.yaw * torqueScale.y, helicopterInputState.roll * torqueScale.z), (ForceMode)0);
			}
		}
		if (damageTorque != Vector3.zero)
		{
			rigidBody.AddRelativeTorque(new Vector3(damageTorque.x, damageTorque.y, damageTorque.z), (ForceMode)0);
		}
		avgThrust = Mathf.Lerp(avgThrust, engineThrustMax * currentThrottle, Time.fixedDeltaTime * thrustLerpSpeed);
		float num2 = Mathf.Clamp01(Vector3.Dot(((Component)this).transform.up, Vector3.up));
		float num3 = Mathf.InverseLerp(liftDotMax, 1f, num2);
		float serviceCeiling = GetServiceCeiling();
		float num4 = Mathf.Max(GetMinimumAltitudeTerrain(), TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position));
		avgTerrainHeight = Mathf.Lerp(avgTerrainHeight, num4, Time.deltaTime);
		float num5 = 1f - Mathf.InverseLerp(avgTerrainHeight + serviceCeiling - 20f, avgTerrainHeight + serviceCeiling, ((Component)this).transform.position.y);
		num3 *= num5;
		float num6 = 1f - Mathf.InverseLerp(altForceDotMin, 1f, num2);
		Vector3 val = Vector3.up * engineThrustMax * liftFraction * currentThrottle * num3;
		Vector3 val2 = ((Component)this).transform.up - Vector3.up;
		Vector3 val3 = ((Vector3)(ref val2)).normalized * engineThrustMax * currentThrottle * num6;
		float num7 = rigidBody.mass * (0f - Physics.gravity.y);
		rigidBody.AddForce(((Component)this).transform.up * num7 * num3 * hoverForceScale, (ForceMode)0);
		rigidBody.AddForce(val, (ForceMode)0);
		rigidBody.AddForce(val3, (ForceMode)0);
	}

	public void DelayedImpactDamage()
	{
		float num = explosionForceMultiplier;
		explosionForceMultiplier = 0f;
		Hurt(pendingImpactDamage * MaxHealth(), DamageType.Explosion, this, useProtection: false);
		pendingImpactDamage = 0f;
		explosionForceMultiplier = num;
	}

	public virtual bool CollisionDamageEnabled()
	{
		return true;
	}

	public void ProcessCollision(Collision collision)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || !CollisionDamageEnabled() || Time.time < nextDamageTime)
		{
			return;
		}
		Vector3 relativeVelocity = collision.relativeVelocity;
		float magnitude = ((Vector3)(ref relativeVelocity)).magnitude;
		if (Object.op_Implicit((Object)(object)collision.gameObject))
		{
			if (((1 << ((Component)collision.collider).gameObject.layer) & 0x48A18101) <= 0)
			{
				return;
			}
			BaseEntity entity = collision.GetEntity();
			if ((Object)(object)entity != (Object)null && (entity is Parachute || entity is RidableHorse || entity is MagnetCrane))
			{
				return;
			}
		}
		float num = Mathf.InverseLerp(7f, 30f, magnitude);
		if (!(num > 0f))
		{
			return;
		}
		pendingImpactDamage += Mathf.Max(num, 0.05f);
		if (Vector3.Dot(((Component)this).transform.up, Vector3.up) < 0.5f)
		{
			pendingImpactDamage *= 5f;
		}
		if (Time.time > nextEffectTime)
		{
			nextEffectTime = Time.time + 0.25f;
			if (crashEffect.isValid)
			{
				ContactPoint contact = collision.GetContact(0);
				Vector3 point = ((ContactPoint)(ref contact)).point;
				TryShowCollisionFX(point);
			}
		}
		Rigidbody obj = rigidBody;
		ContactPoint contact2 = collision.GetContact(0);
		Vector3 val = ((ContactPoint)(ref contact2)).normal * (1f + 3f * num);
		contact2 = collision.GetContact(0);
		obj.AddForceAtPosition(val, ((ContactPoint)(ref contact2)).point, (ForceMode)2);
		nextDamageTime = Time.time + 0.333f;
		((FacepunchBehaviour)this).Invoke((Action)DelayedImpactDamage, 0.015f);
	}

	public override GameObjectRef GetCollisionFX()
	{
		return crashEffect;
	}

	public void OnCollisionEnter(Collision collision)
	{
		ProcessCollision(collision);
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			base.OnDied(info);
			return;
		}
		if (explosionEffect.isValid)
		{
			Effect.server.Run(explosionEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
		}
		Vector3 val = rigidBody.velocity * 0.25f;
		List<ServerGib> list = null;
		if (serverGibs.isValid)
		{
			GameObject gibSource = serverGibs.Get().GetComponent<ServerGib>()._gibSource;
			list = ServerGib.CreateGibs(serverGibs.resourcePath, ((Component)this).gameObject, gibSource, val, 3f);
		}
		Vector3 val2 = CenterPoint();
		if (fireBall.isValid && !InSafeZone())
		{
			RaycastHit val3 = default(RaycastHit);
			for (int i = 0; i < 12; i++)
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(fireBall.resourcePath, val2, ((Component)this).transform.rotation);
				if (!Object.op_Implicit((Object)(object)baseEntity))
				{
					continue;
				}
				float num = 3f;
				float num2 = 10f;
				Vector3 onUnitSphere = Random.onUnitSphere;
				((Vector3)(ref onUnitSphere)).Normalize();
				float num3 = Random.Range(0.5f, 4f);
				bool num4 = Physics.Raycast(val2, onUnitSphere, ref val3, num3, 1218652417);
				Vector3 val4 = ((RaycastHit)(ref val3)).point;
				if (!num4)
				{
					val4 = val2 + onUnitSphere * num3;
				}
				val4 -= onUnitSphere * 0.5f;
				((Component)baseEntity).transform.position = val4;
				Collider component = ((Component)baseEntity).GetComponent<Collider>();
				baseEntity.Spawn();
				baseEntity.SetVelocity(val + onUnitSphere * Random.Range(num, num2));
				if (list == null)
				{
					continue;
				}
				foreach (ServerGib item in list)
				{
					Physics.IgnoreCollision(component, (Collider)(object)item.GetCollider(), true);
				}
			}
		}
		SeismicSensor.Notify(((Component)this).transform.position, 1);
		base.OnDied(info);
	}

	public virtual bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
protected class GroundEffect
{
	public ParticleSystem effect;

	public Transform groundPoint;
}


public class HelicopterInputState
{
	public float throttle;

	public float roll;

	public float yaw;

	public float pitch;

	public bool groundControl;

	public void Reset()
	{
		throttle = 0f;
		roll = 0f;
		yaw = 0f;
		pitch = 0f;
		groundControl = false;
	}
}


using System;
using UnityEngine;

public class CH47AIBrain : BaseAIBrain
{
	public class DropCrate : BasicAIState
	{
		private float nextDropTime;

		public DropCrate()
			: base(AIState.DropCrate)
		{
		}

		public override bool CanInterrupt()
		{
			if (base.CanInterrupt())
			{
				return !CanDrop();
			}
			return false;
		}

		public bool CanDrop()
		{
			if (Time.time > nextDropTime)
			{
				return (brain.GetBrainBaseEntity() as CH47HelicopterAIController).CanDropCrate();
			}
			return false;
		}

		public override float GetWeight()
		{
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			if (!CanDrop())
			{
				return 0f;
			}
			if (IsInState())
			{
				return 10000f;
			}
			if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Orbit && brain.CurrentState.TimeInState > 60f)
			{
				CH47DropZone closest = CH47DropZone.GetClosest(brain.mainInterestPoint);
				if (Object.op_Implicit((Object)(object)closest) && Vector3Ex.Distance2D(((Component)closest).transform.position, brain.mainInterestPoint) < 200f)
				{
					CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
					if ((Object)(object)component != (Object)null)
					{
						float num = Mathf.InverseLerp(300f, 600f, component.Age);
						return 1000f * num;
					}
				}
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.SetDropDoorOpen(open: true);
			obj.EnableFacingOverride(enabled: false);
			CH47DropZone closest = CH47DropZone.GetClosest(((Component)obj).transform.position);
			if ((Object)(object)closest == (Object)null)
			{
				nextDropTime = Time.time + 60f;
			}
			brain.mainInterestPoint = ((Component)closest).transform.position;
			obj.SetMoveTarget(brain.mainInterestPoint);
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			if (CanDrop() && Vector3Ex.Distance2D(brain.mainInterestPoint, ((Component)cH47HelicopterAIController).transform.position) < 5f)
			{
				Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
				if (((Vector3)(ref velocity)).magnitude < 5f)
				{
					cH47HelicopterAIController.DropCrate();
					nextDropTime = Time.time + 120f;
				}
			}
			return StateStatus.Running;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			(entity as CH47HelicopterAIController).SetDropDoorOpen(open: false);
			nextDropTime = Time.time + 60f;
			base.StateLeave(brain, entity);
		}
	}

	public class EgressState : BasicAIState
	{
		private bool killing;

		private bool egressAltitueAchieved;

		public EgressState()
			: base(AIState.Egress)
		{
		}

		public override bool CanInterrupt()
		{
			return false;
		}

		public override float GetWeight()
		{
			CH47HelicopterAIController cH47HelicopterAIController = brain.GetBrainBaseEntity() as CH47HelicopterAIController;
			if (cH47HelicopterAIController.OutOfCrates() && !cH47HelicopterAIController.ShouldLand())
			{
				return 10000f;
			}
			CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
			if ((Object)(object)component != (Object)null)
			{
				if (!(component.Age > 1800f))
				{
					return 0f;
				}
				return 10000f;
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			Transform transform = ((Component)obj).transform;
			Rigidbody rigidBody = obj.rigidBody;
			Vector3 velocity = rigidBody.velocity;
			Vector3 val;
			if (!(((Vector3)(ref velocity)).magnitude < 0.1f))
			{
				velocity = rigidBody.velocity;
				val = ((Vector3)(ref velocity)).normalized;
			}
			else
			{
				val = transform.forward;
			}
			Vector3 val2 = val;
			Vector3 val3 = Vector3.Cross(Vector3.Cross(transform.up, val2), Vector3.up);
			brain.mainInterestPoint = transform.position + val3 * 8000f;
			brain.mainInterestPoint.y = 100f;
			obj.SetMoveTarget(brain.mainInterestPoint);
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			if (killing)
			{
				return StateStatus.Running;
			}
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
			if (position.y < 85f && !egressAltitueAchieved)
			{
				CH47LandingZone closest = CH47LandingZone.GetClosest(position);
				if ((Object)(object)closest != (Object)null && Vector3Ex.Distance2D(((Component)closest).transform.position, position) < 20f)
				{
					float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(position, waves: false, volumes: false);
					waterOrTerrainSurface += 100f;
					Vector3 moveTarget = position;
					moveTarget.y = waterOrTerrainSurface;
					cH47HelicopterAIController.SetMoveTarget(moveTarget);
					return StateStatus.Running;
				}
			}
			egressAltitueAchieved = true;
			cH47HelicopterAIController.SetMoveTarget(brain.mainInterestPoint);
			if (base.TimeInState > 300f)
			{
				((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)cH47HelicopterAIController.DelayedKill, 2f);
				killing = true;
			}
			return StateStatus.Running;
		}
	}

	public class IdleState : BaseIdleState
	{
		public override float GetWeight()
		{
			return 0.1f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = cH47HelicopterAIController.GetPosition();
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			cH47HelicopterAIController.SetMoveTarget(position + ((Vector3)(ref velocity)).normalized * 10f);
			base.StateEnter(brain, entity);
		}
	}

	public class LandState : BasicAIState
	{
		private float landedForSeconds;

		private float lastLandtime;

		private float landingHeight = 20f;

		private float nextDismountTime;

		public LandState()
			: base(AIState.Land)
		{
		}

		public override float GetWeight()
		{
			if (!(brain.GetBrainBaseEntity() as CH47HelicopterAIController).ShouldLand())
			{
				return 0f;
			}
			float num = Time.time - lastLandtime;
			if (IsInState() && landedForSeconds < 12f)
			{
				return 1000f;
			}
			if (!IsInState() && num > 10f)
			{
				return 9000f;
			}
			return 0f;
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_0161: Unknown result type (might be due to invalid IL or missing references)
			//IL_016c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0181: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01da: Unknown result type (might be due to invalid IL or missing references)
			//IL_01df: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
			_ = ((Component)cH47HelicopterAIController).transform.forward;
			CH47LandingZone closest = CH47LandingZone.GetClosest(cH47HelicopterAIController.landingTarget);
			if (!Object.op_Implicit((Object)(object)closest))
			{
				return StateStatus.Error;
			}
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			float magnitude = ((Vector3)(ref velocity)).magnitude;
			float num = Vector3Ex.Distance2D(((Component)closest).transform.position, position);
			bool enabled = num < 40f;
			bool altitudeProtection = num > 15f && position.y < ((Component)closest).transform.position.y + 10f;
			cH47HelicopterAIController.EnableFacingOverride(enabled);
			cH47HelicopterAIController.SetAltitudeProtection(altitudeProtection);
			int num2;
			if (Mathf.Abs(((Component)closest).transform.position.y - position.y) < 3f && num <= 5f)
			{
				num2 = ((magnitude < 1f) ? 1 : 0);
				if (num2 != 0)
				{
					landedForSeconds += delta;
					if (lastLandtime == 0f)
					{
						lastLandtime = Time.time;
					}
				}
			}
			else
			{
				num2 = 0;
			}
			float num3 = 1f - Mathf.InverseLerp(0f, 7f, num);
			landingHeight -= 4f * num3 * Time.deltaTime;
			if (landingHeight < -5f)
			{
				landingHeight = -5f;
			}
			cH47HelicopterAIController.SetAimDirection(((Component)closest).transform.forward);
			Vector3 moveTarget = brain.mainInterestPoint + new Vector3(0f, landingHeight, 0f);
			if (num < 100f && num > 15f)
			{
				Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, position);
				RaycastHit val2 = default(RaycastHit);
				if (Physics.SphereCast(position, 15f, val, ref val2, num, 1218511105))
				{
					Vector3 val3 = Vector3.Cross(val, Vector3.up);
					moveTarget = ((RaycastHit)(ref val2)).point + val3 * 50f;
				}
			}
			cH47HelicopterAIController.SetMoveTarget(moveTarget);
			if (num2 != 0)
			{
				if (landedForSeconds > 1f && Time.time > nextDismountTime)
				{
					foreach (BaseVehicle.MountPointInfo mountPoint in cH47HelicopterAIController.mountPoints)
					{
						if (Object.op_Implicit((Object)(object)mountPoint.mountable) && mountPoint.mountable.AnyMounted())
						{
							nextDismountTime = Time.time + 0.5f;
							mountPoint.mountable.DismountAllPlayers();
							break;
						}
					}
				}
				if (landedForSeconds > 8f)
				{
					((Component)brain).GetComponent<CH47AIBrain>().ForceSetAge(float.PositiveInfinity);
				}
			}
			return StateStatus.Running;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			brain.mainInterestPoint = (entity as CH47HelicopterAIController).landingTarget;
			landingHeight = 15f;
			base.StateEnter(brain, entity);
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			obj.SetAltitudeProtection(on: true);
			obj.SetMinHoverHeight(30f);
			landedForSeconds = 0f;
			base.StateLeave(brain, entity);
		}

		public override bool CanInterrupt()
		{
			return true;
		}
	}

	public class OrbitState : BasicAIState
	{
		public OrbitState()
			: base(AIState.Orbit)
		{
		}

		public Vector3 GetOrbitCenter()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return brain.mainInterestPoint;
		}

		public override float GetWeight()
		{
			if (IsInState())
			{
				float num = 1f - Mathf.InverseLerp(120f, 180f, base.TimeInState);
				return 5f * num;
			}
			if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Patrol && brain.CurrentState is PatrolState patrolState && patrolState.AtPatrolDestination())
			{
				return 5f;
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: true);
			obj.InitiateAnger();
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			Vector3 orbitCenter = GetOrbitCenter();
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = cH47HelicopterAIController.GetPosition();
			Vector3 val = Vector3Ex.Direction2D(orbitCenter, position);
			Vector3 val2 = Vector3.Cross(Vector3.up, val);
			float num = ((Vector3.Dot(Vector3.Cross(((Component)cH47HelicopterAIController).transform.right, Vector3.up), val2) < 0f) ? (-1f) : 1f);
			float num2 = 75f;
			Vector3 val3 = -val + val2 * num * 0.6f;
			Vector3 normalized = ((Vector3)(ref val3)).normalized;
			Vector3 val4 = orbitCenter + normalized * num2;
			cH47HelicopterAIController.SetMoveTarget(val4);
			cH47HelicopterAIController.SetAimDirection(Vector3Ex.Direction2D(val4, position));
			base.StateThink(delta, brain, entity);
			return StateStatus.Running;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			obj.CancelAnger();
			base.StateLeave(brain, entity);
		}
	}

	public class PatrolState : BasePatrolState
	{
		protected float patrolApproachDist = 75f;

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			brain.mainInterestPoint = brain.PathFinder.GetRandomPatrolPoint();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			(entity as CH47HelicopterAIController).SetMoveTarget(brain.mainInterestPoint);
			return StateStatus.Running;
		}

		public bool AtPatrolDestination()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return Vector3Ex.Distance2D(GetDestination(), ((Component)brain).transform.position) < patrolApproachDist;
		}

		public Vector3 GetDestination()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return brain.mainInterestPoint;
		}

		public override bool CanInterrupt()
		{
			if (base.CanInterrupt())
			{
				return AtPatrolDestination();
			}
			return false;
		}

		public override float GetWeight()
		{
			if (IsInState())
			{
				if (AtPatrolDestination() && base.TimeInState > 2f)
				{
					return 0f;
				}
				return 3f;
			}
			float num = Mathf.InverseLerp(70f, 120f, TimeSinceState()) * 5f;
			return 1f + num;
		}
	}

	public override void AddStates()
	{
		base.AddStates();
		AddState(new IdleState());
		AddState(new PatrolState());
		AddState(new OrbitState());
		AddState(new EgressState());
		AddState(new DropCrate());
		AddState(new LandState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.FixedUpdate;
		base.PathFinder = new CH47PathFinder();
	}

	public void FixedUpdate()
	{
		if (!((Object)(object)base.baseEntity == (Object)null) && !base.baseEntity.isClient)
		{
			Think(Time.fixedDeltaTime);
		}
	}
}


using UnityEngine;

public class DropCrate : BasicAIState
{
	private float nextDropTime;

	public DropCrate()
		: base(AIState.DropCrate)
	{
	}

	public override bool CanInterrupt()
	{
		if (base.CanInterrupt())
		{
			return !CanDrop();
		}
		return false;
	}

	public bool CanDrop()
	{
		if (Time.time > nextDropTime)
		{
			return (brain.GetBrainBaseEntity() as CH47HelicopterAIController).CanDropCrate();
		}
		return false;
	}

	public override float GetWeight()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (!CanDrop())
		{
			return 0f;
		}
		if (IsInState())
		{
			return 10000f;
		}
		if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Orbit && brain.CurrentState.TimeInState > 60f)
		{
			CH47DropZone closest = CH47DropZone.GetClosest(brain.mainInterestPoint);
			if (Object.op_Implicit((Object)(object)closest) && Vector3Ex.Distance2D(((Component)closest).transform.position, brain.mainInterestPoint) < 200f)
			{
				CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
				if ((Object)(object)component != (Object)null)
				{
					float num = Mathf.InverseLerp(300f, 600f, component.Age);
					return 1000f * num;
				}
			}
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.SetDropDoorOpen(open: true);
		obj.EnableFacingOverride(enabled: false);
		CH47DropZone closest = CH47DropZone.GetClosest(((Component)obj).transform.position);
		if ((Object)(object)closest == (Object)null)
		{
			nextDropTime = Time.time + 60f;
		}
		brain.mainInterestPoint = ((Component)closest).transform.position;
		obj.SetMoveTarget(brain.mainInterestPoint);
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		if (CanDrop() && Vector3Ex.Distance2D(brain.mainInterestPoint, ((Component)cH47HelicopterAIController).transform.position) < 5f)
		{
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			if (((Vector3)(ref velocity)).magnitude < 5f)
			{
				cH47HelicopterAIController.DropCrate();
				nextDropTime = Time.time + 120f;
			}
		}
		return StateStatus.Running;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		(entity as CH47HelicopterAIController).SetDropDoorOpen(open: false);
		nextDropTime = Time.time + 60f;
		base.StateLeave(brain, entity);
	}
}


using System;
using UnityEngine;

public class EgressState : BasicAIState
{
	private bool killing;

	private bool egressAltitueAchieved;

	public EgressState()
		: base(AIState.Egress)
	{
	}

	public override bool CanInterrupt()
	{
		return false;
	}

	public override float GetWeight()
	{
		CH47HelicopterAIController cH47HelicopterAIController = brain.GetBrainBaseEntity() as CH47HelicopterAIController;
		if (cH47HelicopterAIController.OutOfCrates() && !cH47HelicopterAIController.ShouldLand())
		{
			return 10000f;
		}
		CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
		if ((Object)(object)component != (Object)null)
		{
			if (!(component.Age > 1800f))
			{
				return 0f;
			}
			return 10000f;
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		Transform transform = ((Component)obj).transform;
		Rigidbody rigidBody = obj.rigidBody;
		Vector3 velocity = rigidBody.velocity;
		Vector3 val;
		if (!(((Vector3)(ref velocity)).magnitude < 0.1f))
		{
			velocity = rigidBody.velocity;
			val = ((Vector3)(ref velocity)).normalized;
		}
		else
		{
			val = transform.forward;
		}
		Vector3 val2 = val;
		Vector3 val3 = Vector3.Cross(Vector3.Cross(transform.up, val2), Vector3.up);
		brain.mainInterestPoint = transform.position + val3 * 8000f;
		brain.mainInterestPoint.y = 100f;
		obj.SetMoveTarget(brain.mainInterestPoint);
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		if (killing)
		{
			return StateStatus.Running;
		}
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
		if (position.y < 85f && !egressAltitueAchieved)
		{
			CH47LandingZone closest = CH47LandingZone.GetClosest(position);
			if ((Object)(object)closest != (Object)null && Vector3Ex.Distance2D(((Component)closest).transform.position, position) < 20f)
			{
				float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(position, waves: false, volumes: false);
				waterOrTerrainSurface += 100f;
				Vector3 moveTarget = position;
				moveTarget.y = waterOrTerrainSurface;
				cH47HelicopterAIController.SetMoveTarget(moveTarget);
				return StateStatus.Running;
			}
		}
		egressAltitueAchieved = true;
		cH47HelicopterAIController.SetMoveTarget(brain.mainInterestPoint);
		if (base.TimeInState > 300f)
		{
			((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)cH47HelicopterAIController.DelayedKill, 2f);
			killing = true;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class IdleState : BaseIdleState
{
	public override float GetWeight()
	{
		return 0.1f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = cH47HelicopterAIController.GetPosition();
		Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
		cH47HelicopterAIController.SetMoveTarget(position + ((Vector3)(ref velocity)).normalized * 10f);
		base.StateEnter(brain, entity);
	}
}


using UnityEngine;

public class LandState : BasicAIState
{
	private float landedForSeconds;

	private float lastLandtime;

	private float landingHeight = 20f;

	private float nextDismountTime;

	public LandState()
		: base(AIState.Land)
	{
	}

	public override float GetWeight()
	{
		if (!(brain.GetBrainBaseEntity() as CH47HelicopterAIController).ShouldLand())
		{
			return 0f;
		}
		float num = Time.time - lastLandtime;
		if (IsInState() && landedForSeconds < 12f)
		{
			return 1000f;
		}
		if (!IsInState() && num > 10f)
		{
			return 9000f;
		}
		return 0f;
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
		_ = ((Component)cH47HelicopterAIController).transform.forward;
		CH47LandingZone closest = CH47LandingZone.GetClosest(cH47HelicopterAIController.landingTarget);
		if (!Object.op_Implicit((Object)(object)closest))
		{
			return StateStatus.Error;
		}
		Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
		float magnitude = ((Vector3)(ref velocity)).magnitude;
		float num = Vector3Ex.Distance2D(((Component)closest).transform.position, position);
		bool enabled = num < 40f;
		bool altitudeProtection = num > 15f && position.y < ((Component)closest).transform.position.y + 10f;
		cH47HelicopterAIController.EnableFacingOverride(enabled);
		cH47HelicopterAIController.SetAltitudeProtection(altitudeProtection);
		int num2;
		if (Mathf.Abs(((Component)closest).transform.position.y - position.y) < 3f && num <= 5f)
		{
			num2 = ((magnitude < 1f) ? 1 : 0);
			if (num2 != 0)
			{
				landedForSeconds += delta;
				if (lastLandtime == 0f)
				{
					lastLandtime = Time.time;
				}
			}
		}
		else
		{
			num2 = 0;
		}
		float num3 = 1f - Mathf.InverseLerp(0f, 7f, num);
		landingHeight -= 4f * num3 * Time.deltaTime;
		if (landingHeight < -5f)
		{
			landingHeight = -5f;
		}
		cH47HelicopterAIController.SetAimDirection(((Component)closest).transform.forward);
		Vector3 moveTarget = brain.mainInterestPoint + new Vector3(0f, landingHeight, 0f);
		if (num < 100f && num > 15f)
		{
			Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, position);
			RaycastHit val2 = default(RaycastHit);
			if (Physics.SphereCast(position, 15f, val, ref val2, num, 1218511105))
			{
				Vector3 val3 = Vector3.Cross(val, Vector3.up);
				moveTarget = ((RaycastHit)(ref val2)).point + val3 * 50f;
			}
		}
		cH47HelicopterAIController.SetMoveTarget(moveTarget);
		if (num2 != 0)
		{
			if (landedForSeconds > 1f && Time.time > nextDismountTime)
			{
				foreach (BaseVehicle.MountPointInfo mountPoint in cH47HelicopterAIController.mountPoints)
				{
					if (Object.op_Implicit((Object)(object)mountPoint.mountable) && mountPoint.mountable.AnyMounted())
					{
						nextDismountTime = Time.time + 0.5f;
						mountPoint.mountable.DismountAllPlayers();
						break;
					}
				}
			}
			if (landedForSeconds > 8f)
			{
				((Component)brain).GetComponent<CH47AIBrain>().ForceSetAge(float.PositiveInfinity);
			}
		}
		return StateStatus.Running;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		brain.mainInterestPoint = (entity as CH47HelicopterAIController).landingTarget;
		landingHeight = 15f;
		base.StateEnter(brain, entity);
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		obj.SetAltitudeProtection(on: true);
		obj.SetMinHoverHeight(30f);
		landedForSeconds = 0f;
		base.StateLeave(brain, entity);
	}

	public override bool CanInterrupt()
	{
		return true;
	}
}


using UnityEngine;

public class OrbitState : BasicAIState
{
	public OrbitState()
		: base(AIState.Orbit)
	{
	}

	public Vector3 GetOrbitCenter()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return brain.mainInterestPoint;
	}

	public override float GetWeight()
	{
		if (IsInState())
		{
			float num = 1f - Mathf.InverseLerp(120f, 180f, base.TimeInState);
			return 5f * num;
		}
		if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Patrol && brain.CurrentState is PatrolState patrolState && patrolState.AtPatrolDestination())
		{
			return 5f;
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: true);
		obj.InitiateAnger();
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 orbitCenter = GetOrbitCenter();
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = cH47HelicopterAIController.GetPosition();
		Vector3 val = Vector3Ex.Direction2D(orbitCenter, position);
		Vector3 val2 = Vector3.Cross(Vector3.up, val);
		float num = ((Vector3.Dot(Vector3.Cross(((Component)cH47HelicopterAIController).transform.right, Vector3.up), val2) < 0f) ? (-1f) : 1f);
		float num2 = 75f;
		Vector3 val3 = -val + val2 * num * 0.6f;
		Vector3 normalized = ((Vector3)(ref val3)).normalized;
		Vector3 val4 = orbitCenter + normalized * num2;
		cH47HelicopterAIController.SetMoveTarget(val4);
		cH47HelicopterAIController.SetAimDirection(Vector3Ex.Direction2D(val4, position));
		base.StateThink(delta, brain, entity);
		return StateStatus.Running;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		obj.CancelAnger();
		base.StateLeave(brain, entity);
	}
}


using UnityEngine;

public class PatrolState : BasePatrolState
{
	protected float patrolApproachDist = 75f;

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		brain.mainInterestPoint = brain.PathFinder.GetRandomPatrolPoint();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		(entity as CH47HelicopterAIController).SetMoveTarget(brain.mainInterestPoint);
		return StateStatus.Running;
	}

	public bool AtPatrolDestination()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(GetDestination(), ((Component)brain).transform.position) < patrolApproachDist;
	}

	public Vector3 GetDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return brain.mainInterestPoint;
	}

	public override bool CanInterrupt()
	{
		if (base.CanInterrupt())
		{
			return AtPatrolDestination();
		}
		return false;
	}

	public override float GetWeight()
	{
		if (IsInState())
		{
			if (AtPatrolDestination() && base.TimeInState > 2f)
			{
				return 0f;
			}
			return 3f;
		}
		float num = Mathf.InverseLerp(70f, 120f, TimeSinceState()) * 5f;
		return 1f + num;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class CH47DropZone : MonoBehaviour
{
	public float lastDropTime;

	public static List<CH47DropZone> dropZones = new List<CH47DropZone>();

	public void Awake()
	{
		if (!dropZones.Contains(this))
		{
			dropZones.Add(this);
		}
	}

	public static CH47DropZone GetClosest(Vector3 pos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		CH47DropZone result = null;
		foreach (CH47DropZone dropZone in dropZones)
		{
			float num2 = Vector3Ex.Distance2D(pos, ((Component)dropZone).transform.position);
			if (num2 < num)
			{
				num = num2;
				result = dropZone;
			}
		}
		return result;
	}

	public void OnDestroy()
	{
		if (dropZones.Contains(this))
		{
			dropZones.Remove(this);
		}
	}

	public float TimeSinceLastDrop()
	{
		return Time.time - lastDropTime;
	}

	public void Used()
	{
		lastDropTime = Time.time;
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.yellow;
		Gizmos.DrawSphere(((Component)this).transform.position, 5f);
	}
}


using Oxide.Core;
using UnityEngine;

public class CH47Helicopter : BaseHelicopter
{
	public GameObjectRef mapMarkerEntityPrefab;

	[Header("Sounds")]
	public SoundDefinition flightEngineSoundDef;

	public SoundDefinition flightThwopsSoundDef;

	public float rotorGainModSmoothing = 0.25f;

	public float engineGainMin = 0.5f;

	public float engineGainMax = 1f;

	public float thwopGainMin = 0.5f;

	public float thwopGainMax = 1f;

	public BaseEntity mapMarkerInstance;

	public override void ServerInit()
	{
		rigidBody.isKinematic = false;
		base.ServerInit();
		CreateMapMarker();
	}

	public void CreateMapMarker()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)mapMarkerInstance))
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		mapMarkerInstance = baseEntity;
	}

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

	protected override void ApplyHandbrake()
	{
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		return false;
	}
}


using System;
using Oxide.Core;
using Rust;
using UnityEngine;

public class CH47HelicopterAIController : CH47Helicopter
{
	public GameObjectRef scientistPrefab;

	public GameObjectRef dismountablePrefab;

	public GameObjectRef weakDismountablePrefab;

	public float maxTiltAngle = 0.3f;

	public float AiAltitudeForce = 10000f;

	public GameObjectRef lockedCratePrefab;

	public const Flags Flag_Damaged = Flags.Reserved9;

	public const Flags Flag_NearDeath = Flags.OnFire;

	public const Flags Flag_DropDoorOpen = Flags.Reserved8;

	public GameObject triggerHurt;

	public Vector3 landingTarget;

	public int numCrates = 1;

	private bool shouldLand;

	public bool aimDirOverride;

	public Vector3 _aimDirection = Vector3.forward;

	public Vector3 _moveTarget = Vector3.zero;

	public int lastAltitudeCheckFrame;

	public float altOverride;

	public float currentDesiredAltitude;

	private bool altitudeProtection = true;

	public float hoverHeight = 30f;

	public void DropCrate()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (numCrates > 0)
		{
			Vector3 pos = ((Component)this).transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				Interface.CallHook("OnHelicopterDropCrate", (object)this);
				((Component)baseEntity).SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

	public bool IsDropDoorOpen()
	{
		return HasFlag(Flags.Reserved8);
	}

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", (object)this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

	public bool ShouldLand()
	{
		return shouldLand;
	}

	public void SetLandingTarget(Vector3 target)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		shouldLand = true;
		landingTarget = target;
		numCrates = 0;
	}

	public void ClearLandingTarget()
	{
		shouldLand = false;
	}

	public void TriggeredEventSpawn()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float y = 30f;
		Vector3 val = Vector3Ex.Range(-1f, 1f);
		val.y = 0f;
		((Vector3)(ref val)).Normalize();
		val *= x * 1f;
		val.y = y;
		((Component)this).transform.position = val;
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (Interface.CallHook("CanUseHelicopter", (object)player, (object)this) == null)
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	public override void ServerInit()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)CheckSpawnScientists, 0.25f);
		SetMoveTarget(((Component)this).transform.position);
	}

	public void SpawnPassenger(Vector3 spawnPos, string prefabPath)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		HumanNPC component = ((Component)GameManager.server.CreateEntity(prefabPath, spawnPos, identity)).GetComponent<HumanNPC>();
		component.Spawn();
		AttemptMount(component);
		OnSpawnedHuman(component);
	}

	public void SpawnPassenger(Vector3 spawnPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		HumanNPC component = ((Component)GameManager.server.CreateEntity(dismountablePrefab.resourcePath, spawnPos, identity)).GetComponent<HumanNPC>();
		component.Spawn();
		AttemptMount(component);
		OnSpawnedHuman(component);
	}

	public void SpawnScientist(Vector3 spawnPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		HumanNPC component = ((Component)GameManager.server.CreateEntity(scientistPrefab.resourcePath, spawnPos, identity)).GetComponent<HumanNPC>();
		component.Spawn();
		AttemptMount(component);
		component.Brain.SetEnabled(flag: false);
		OnSpawnedHuman(component);
	}

	private void OnSpawnedHuman(HumanNPC human)
	{
		if (!((Object)(object)human == (Object)null) && (Object)(object)human.Brain != (Object)null && human.Brain.Senses != null)
		{
			human.Brain.Senses.ignoreTutorialPlayers = true;
		}
	}

	public void CheckSpawnScientists()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (ValidBounds.Test(this, ((Component)this).transform.position))
		{
			((FacepunchBehaviour)this).Invoke((Action)SpawnScientists, 2f);
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)CheckSpawnScientists, 2f);
		}
	}

	public void SpawnScientists()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		if (shouldLand)
		{
			float dropoffScale = CH47LandingZone.GetClosest(landingTarget).dropoffScale;
			int num = Mathf.FloorToInt((float)(mountPoints.Count - 2) * dropoffScale);
			for (int i = 0; i < num; i++)
			{
				Vector3 spawnPos = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
				SpawnPassenger(spawnPos, dismountablePrefab.resourcePath);
			}
			for (int j = 0; j < 1; j++)
			{
				Vector3 spawnPos2 = ((Component)this).transform.position - ((Component)this).transform.forward * 15f;
				SpawnPassenger(spawnPos2);
			}
		}
		else
		{
			for (int k = 0; k < 4; k++)
			{
				Vector3 spawnPos3 = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
				SpawnScientist(spawnPos3);
			}
			for (int l = 0; l < 1; l++)
			{
				Vector3 spawnPos4 = ((Component)this).transform.position - ((Component)this).transform.forward * 15f;
				SpawnScientist(spawnPos4);
			}
		}
	}

	public void EnableFacingOverride(bool enabled)
	{
		aimDirOverride = enabled;
	}

	public void SetMoveTarget(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_moveTarget = position;
	}

	public Vector3 GetMoveTarget()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _moveTarget;
	}

	public void SetAimDirection(Vector3 dir)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_aimDirection = dir;
	}

	public Vector3 GetAimDirectionOverride()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _aimDirection;
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
		InitiateAnger();
	}

	public void CancelAnger()
	{
		if (base.SecondsSinceAttacked > 120f)
		{
			UnHostile();
			((FacepunchBehaviour)this).CancelInvoke((Action)UnHostile);
		}
	}

	public void InitiateAnger()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)UnHostile);
		((FacepunchBehaviour)this).Invoke((Action)UnHostile, 120f);
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (!((Object)(object)mountPoint.mountable != (Object)null))
			{
				continue;
			}
			BasePlayer mounted = mountPoint.mountable.GetMounted();
			if (Object.op_Implicit((Object)(object)mounted))
			{
				ScientistNPC scientistNPC = mounted as ScientistNPC;
				if ((Object)(object)scientistNPC != (Object)null)
				{
					scientistNPC.Brain.SetEnabled(flag: true);
				}
			}
		}
	}

	public void UnHostile()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (!((Object)(object)mountPoint.mountable != (Object)null))
			{
				continue;
			}
			BasePlayer mounted = mountPoint.mountable.GetMounted();
			if (Object.op_Implicit((Object)(object)mounted))
			{
				ScientistNPC scientistNPC = mounted as ScientistNPC;
				if ((Object)(object)scientistNPC != (Object)null)
				{
					scientistNPC.Brain.SetEnabled(flag: false);
				}
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		if (Interface.CallHook("OnEntityDestroy", (object)this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnDied(info);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttack", (object)this, (object)info) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved9, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

	public void DelayedKill()
	{
		DismountAllPlayers();
		Kill();
	}

	public override void DismountAllPlayers()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if ((Object)(object)mountPoint.mountable != (Object)null)
			{
				BasePlayer mounted = mountPoint.mountable.GetMounted();
				if (Object.op_Implicit((Object)(object)mounted) && mounted.IsAlive())
				{
					mounted.Hurt(10000f, DamageType.Explosion, this, useProtection: false);
				}
			}
		}
	}

	public override void AdminKill()
	{
		DismountAllPlayers();
		base.AdminKill();
	}

	public void SetAltitudeProtection(bool on)
	{
		altitudeProtection = on;
	}

	public void CalculateDesiredAltitude()
	{
		CalculateOverrideAltitude();
		if (altOverride > currentDesiredAltitude)
		{
			currentDesiredAltitude = altOverride;
		}
		else
		{
			currentDesiredAltitude = Mathf.MoveTowards(currentDesiredAltitude, altOverride, Time.fixedDeltaTime * 5f);
		}
	}

	public void SetMinHoverHeight(float newHeight)
	{
		hoverHeight = newHeight;
	}

	public float CalculateOverrideAltitude()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		if (Time.frameCount == lastAltitudeCheckFrame)
		{
			return altOverride;
		}
		lastAltitudeCheckFrame = Time.frameCount;
		float y = GetMoveTarget().y;
		float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(GetMoveTarget(), waves: false, volumes: false);
		float num = Mathf.Max(y, waterOrTerrainSurface + hoverHeight);
		if (altitudeProtection)
		{
			Vector3 val = rigidBody.velocity;
			Vector3 val2;
			if (!(((Vector3)(ref val)).magnitude < 0.1f))
			{
				val = rigidBody.velocity;
				val2 = ((Vector3)(ref val)).normalized;
			}
			else
			{
				val2 = ((Component)this).transform.forward;
			}
			Vector3 val3 = val2;
			val = Vector3.Cross(Vector3.Cross(((Component)this).transform.up, val3), Vector3.up) + Vector3.down * 0.3f;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			RaycastHit val4 = default(RaycastHit);
			RaycastHit val5 = default(RaycastHit);
			if (Physics.SphereCast(((Component)this).transform.position - normalized * 20f, 20f, normalized, ref val4, 75f, 1218511105) && Physics.SphereCast(((RaycastHit)(ref val4)).point + Vector3.up * 200f, 20f, Vector3.down, ref val5, 200f, 1218511105))
			{
				num = ((RaycastHit)(ref val5)).point.y + hoverHeight;
			}
		}
		altOverride = num;
		return altOverride;
	}

	public override void SetDefaultInputState()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		currentInputState.Reset();
		Vector3 moveTarget = GetMoveTarget();
		Vector3 val = Vector3.Cross(((Component)this).transform.right, Vector3.up);
		Vector3 val2 = Vector3.Cross(Vector3.up, val);
		float num = 0f - Vector3.Dot(Vector3.up, ((Component)this).transform.right);
		float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
		float num3 = Vector3Ex.Distance2D(((Component)this).transform.position, moveTarget);
		float y = ((Component)this).transform.position.y;
		float num4 = currentDesiredAltitude;
		Vector3 val3 = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
		val3.y = num4;
		Vector3 val4 = Vector3Ex.Direction2D(moveTarget, ((Component)this).transform.position);
		float num5 = 0f - Vector3.Dot(val4, val2);
		float num6 = Vector3.Dot(val4, val);
		float num7 = Mathf.InverseLerp(0f, 25f, num3);
		if (num6 > 0f)
		{
			float num8 = Mathf.InverseLerp(0f - maxTiltAngle, 0f, num2);
			currentInputState.pitch = 1f * num6 * num8 * num7;
		}
		else
		{
			float num9 = 1f - Mathf.InverseLerp(0f, maxTiltAngle, num2);
			currentInputState.pitch = 1f * num6 * num9 * num7;
		}
		if (num5 > 0f)
		{
			float num10 = Mathf.InverseLerp(0f - maxTiltAngle, 0f, num);
			currentInputState.roll = 1f * num5 * num10 * num7;
		}
		else
		{
			float num11 = 1f - Mathf.InverseLerp(0f, maxTiltAngle, num);
			currentInputState.roll = 1f * num5 * num11 * num7;
		}
		float num12 = Mathf.Abs(num4 - y);
		float num13 = 1f - Mathf.InverseLerp(10f, 30f, num12);
		currentInputState.pitch *= num13;
		currentInputState.roll *= num13;
		float num14 = maxTiltAngle;
		float num15 = Mathf.InverseLerp(0f + Mathf.Abs(currentInputState.pitch) * num14, num14 + Mathf.Abs(currentInputState.pitch) * num14, Mathf.Abs(num2));
		currentInputState.pitch += num15 * ((num2 < 0f) ? (-1f) : 1f);
		float num16 = Mathf.InverseLerp(0f + Mathf.Abs(currentInputState.roll) * num14, num14 + Mathf.Abs(currentInputState.roll) * num14, Mathf.Abs(num));
		currentInputState.roll += num16 * ((num < 0f) ? (-1f) : 1f);
		if (aimDirOverride || num3 > 30f)
		{
			Vector3 val5 = (aimDirOverride ? GetAimDirectionOverride() : Vector3Ex.Direction2D(GetMoveTarget(), ((Component)this).transform.position));
			Vector3 val6 = (aimDirOverride ? GetAimDirectionOverride() : Vector3Ex.Direction2D(GetMoveTarget(), ((Component)this).transform.position));
			float num17 = Vector3.Dot(val2, val5);
			float num18 = Vector3.Angle(val, val6);
			float num19 = Mathf.InverseLerp(0f, 70f, Mathf.Abs(num18));
			currentInputState.yaw = ((num17 > 0f) ? 1f : 0f);
			currentInputState.yaw -= ((num17 < 0f) ? 1f : 0f);
			currentInputState.yaw *= num19;
		}
		float throttle = Mathf.InverseLerp(5f, 30f, num3);
		currentInputState.throttle = throttle;
	}

	public void MaintainAIAltutide()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + rigidBody.velocity;
		float num = currentDesiredAltitude;
		float y = val.y;
		float num2 = Mathf.Abs(num - y);
		bool flag = num > y;
		float num3 = Mathf.InverseLerp(0f, 10f, num2) * AiAltitudeForce * (flag ? 1f : (-1f));
		rigidBody.AddForce(Vector3.up * num3, (ForceMode)0);
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("CH47HeliAI.VehicleFixedUpdate", 0);
		try
		{
			hoverForceScale = 1f;
			base.VehicleFixedUpdate();
			SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
			CalculateDesiredAltitude();
			MaintainAIAltutide();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			foreach (MountPointInfo mountPoint in mountPoints)
			{
				if ((Object)(object)mountPoint.mountable != (Object)null)
				{
					BasePlayer mounted = mountPoint.mountable.GetMounted();
					if (Object.op_Implicit((Object)(object)mounted) && (Object)(object)((Component)mounted).transform != (Object)null && !mounted.IsDestroyed && !mounted.IsDead() && mounted.IsNpc)
					{
						mounted.Kill();
					}
				}
			}
		}
		base.DestroyShared();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class CH47LandingZone : MonoBehaviour
{
	public float lastDropTime;

	public static List<CH47LandingZone> landingZones = new List<CH47LandingZone>();

	public float dropoffScale = 1f;

	public static bool HasAnyLandingZones => !landingZones.IsNullOrEmpty();

	public void Awake()
	{
		if (!landingZones.Contains(this))
		{
			landingZones.Add(this);
		}
	}

	public static CH47LandingZone GetClosest(Vector3 pos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		CH47LandingZone result = null;
		foreach (CH47LandingZone landingZone in landingZones)
		{
			float num2 = Vector3Ex.Distance2D(pos, ((Component)landingZone).transform.position);
			if (num2 < num)
			{
				num = num2;
				result = landingZone;
			}
		}
		return result;
	}

	public void OnDestroy()
	{
		if (landingZones.Contains(this))
		{
			landingZones.Remove(this);
		}
	}

	public float TimeSinceLastDrop()
	{
		return Time.time - lastDropTime;
	}

	public void Used()
	{
		lastDropTime = Time.time;
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		Color magenta = Color.magenta;
		magenta.a = 0.25f;
		Gizmos.color = magenta;
		GizmosUtil.DrawCircleY(((Component)this).transform.position, 6f);
		magenta.a = 1f;
		Gizmos.color = magenta;
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, 6f);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class CH47PathFinder : BasePathFinder
{
	public List<Vector3> visitedPatrolPoints = new List<Vector3>();

	public override Vector3 GetRandomPatrolPoint()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		MonumentInfo monumentInfo = null;
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
		{
			int count = TerrainMeta.Path.Monuments.Count;
			int num = Random.Range(0, count);
			for (int i = 0; i < count; i++)
			{
				int num2 = i + num;
				if (num2 >= count)
				{
					num2 -= count;
				}
				MonumentInfo monumentInfo2 = TerrainMeta.Path.Monuments[num2];
				if (monumentInfo2.Type == MonumentType.Cave || monumentInfo2.Type == MonumentType.WaterWell || monumentInfo2.Tier == MonumentTier.Tier0 || monumentInfo2.IsSafeZone || (monumentInfo2.Tier & MonumentTier.Tier0) > (MonumentTier)0)
				{
					continue;
				}
				bool flag = false;
				foreach (Vector3 visitedPatrolPoint in visitedPatrolPoints)
				{
					if (Vector3Ex.Distance2D(((Component)monumentInfo2).transform.position, visitedPatrolPoint) < 100f)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					monumentInfo = monumentInfo2;
					break;
				}
			}
			if ((Object)(object)monumentInfo == (Object)null)
			{
				visitedPatrolPoints.Clear();
				monumentInfo = GetRandomValidMonumentInfo();
			}
		}
		if ((Object)(object)monumentInfo != (Object)null)
		{
			visitedPatrolPoints.Add(((Component)monumentInfo).transform.position);
			val = ((Component)monumentInfo).transform.position;
		}
		else
		{
			float x = TerrainMeta.Size.x;
			float y = 30f;
			val = Vector3Ex.Range(-1f, 1f);
			val.y = 0f;
			((Vector3)(ref val)).Normalize();
			val *= x * Random.Range(0f, 0.75f);
			val.y = y;
		}
		float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
		float num3 = waterOrTerrainSurface;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.SphereCast(val + new Vector3(0f, 200f, 0f), 20f, Vector3.down, ref val2, 300f, 1218511105))
		{
			num3 = Mathf.Max(((RaycastHit)(ref val2)).point.y, waterOrTerrainSurface);
		}
		val.y = num3 + 30f;
		return val;
	}

	private MonumentInfo GetRandomValidMonumentInfo()
	{
		int count = TerrainMeta.Path.Monuments.Count;
		int num = Random.Range(0, count);
		for (int i = 0; i < count; i++)
		{
			int num2 = i + num;
			if (num2 >= count)
			{
				num2 -= count;
			}
			MonumentInfo monumentInfo = TerrainMeta.Path.Monuments[num2];
			if (monumentInfo.Type != 0 && monumentInfo.Type != MonumentType.WaterWell && monumentInfo.Tier != MonumentTier.Tier0 && !monumentInfo.IsSafeZone)
			{
				return monumentInfo;
			}
		}
		return null;
	}
}


using UnityEngine;

public class CH47ReinforcementListener : BaseEntity
{
	public string listenString;

	public GameObjectRef heliPrefab;

	public float startDist = 300f;

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == listenString)
		{
			Call();
		}
	}

	public void Call()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		TryCall(heliPrefab.resourcePath, ((Component)this).transform.position, startDist);
	}

	public static bool TryCall(string resourcePath, Vector3 ourPos, float startDist)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController component = ((Component)GameManager.server.CreateEntity(resourcePath)).GetComponent<CH47HelicopterAIController>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			return false;
		}
		_ = TerrainMeta.Size;
		CH47LandingZone closest = CH47LandingZone.GetClosest(ourPos);
		if ((Object)(object)closest == (Object)null)
		{
			return false;
		}
		Vector3 zero = Vector3.zero;
		zero.y = ((Component)closest).transform.position.y;
		Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, zero);
		Vector3 position = ((Component)closest).transform.position + val * startDist;
		position.y = ((Component)closest).transform.position.y;
		((Component)component).transform.position = position;
		component.SetLandingTarget(((Component)closest).transform.position);
		component.Spawn();
		return true;
	}
}


public class Minicopter : PlayerHelicopter
{
	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population;
}


using UnityEngine;

public class MiniCopterAnimation : MonoBehaviour
{
	public void UpdateRotorSpeed(float newSpeed)
	{
	}

	private void Update()
	{
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

public class PlayerHeliSounds : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class FlightSoundLayer
	{
		public SoundDefinition loopDefinition;

		public SoundDefinition startDefinition;

		public SoundDefinition stopDefinition;

		public Transform targetParent;

		public float fadeTime = 0.25f;

		public float initialGain = 1f;

		public float gainRateUp = 5f;

		public float gainRateDown = 5f;

		public float gainInterpRate = 0.5f;

		public float initialPitch = 1f;

		public float pitchRateUp = 5f;

		public float pitchRateDown = 5f;

		public float pitchInterpRate = 0.5f;

		public bool returnToInitialWhenTurnedOff;

		public bool useUpDotPitchCurve;

		public AnimationCurve upDotPitchCurve;
	}

	[FormerlySerializedAs("miniCopter")]
	public PlayerHelicopter miniCopter;

	public GameObject soundAttachPoint;

	public List<FlightSoundLayer> flightSoundLayers = new List<FlightSoundLayer>();

	public SoundDefinition engineStartDef;

	public SoundDefinition engineLoopDef;

	public SoundDefinition engineStopDef;

	public SoundDefinition rotorLoopDef;

	public SoundDefinition radarWarningDef;

	public SoundDefinition radarLockDef;

	public SoundDefinition noAmmoDef;

	public SoundDefinition noFlaresDef;

	public SoundDefinition flaresReadyDef;

	public SoundDefinition flightControlMovementSoundDef;

	public GameObject flightControlSoundPosition;

	public float engineStartFadeOutTime = 1f;

	public float engineLoopFadeInTime = 0.7f;

	public float engineLoopFadeOutTime = 0.25f;

	public float engineStopFadeOutTime = 0.25f;

	public float rotorLoopFadeInTime = 0.7f;

	public float rotorLoopFadeOutTime = 0.25f;

	public float enginePitchInterpRate = 0.5f;

	public float rotorPitchInterpRate = 1f;

	public float rotorGainInterpRate = 0.5f;

	public float rotorStartStopPitchRateUp = 7f;

	public float rotorStartStopPitchRateDown = 9f;

	public float rotorStartStopGainRateUp = 5f;

	public float rotorStartStopGainRateDown = 4f;

	public AnimationCurve engineUpDotPitchCurve;

	public AnimationCurve rotorUpDotPitchCurve;

	public Animator animator;

	public SoundDefinition reloadStartSoundDef;

	public SoundDefinition reloadLoopSoundDef;

	public SoundDefinition reloadFinishSoundDef;
}


using System;
using UnityEngine;

[Serializable]
public class FlightSoundLayer
{
	public SoundDefinition loopDefinition;

	public SoundDefinition startDefinition;

	public SoundDefinition stopDefinition;

	public Transform targetParent;

	public float fadeTime = 0.25f;

	public float initialGain = 1f;

	public float gainRateUp = 5f;

	public float gainRateDown = 5f;

	public float gainInterpRate = 0.5f;

	public float initialPitch = 1f;

	public float pitchRateUp = 5f;

	public float pitchRateDown = 5f;

	public float pitchInterpRate = 0.5f;

	public bool returnToInitialWhenTurnedOff;

	public bool useUpDotPitchCurve;

	public AnimationCurve upDotPitchCurve;
}


using System;
using Rust;
using UnityEngine;

public class ScrapTransportHelicopter : PlayerHelicopter, TriggerHurtNotChild.IHurtTriggerUser
{
	[SerializeField]
	private Transform searchlightEye;

	[SerializeField]
	private BoxCollider parentTriggerCollider;

	[Header("Damage Effects")]
	[SerializeField]
	private ParticleSystemContainer tailDamageLight;

	[SerializeField]
	private ParticleSystemContainer tailDamageHeavy;

	[SerializeField]
	private ParticleSystemContainer mainEngineDamageLight;

	[SerializeField]
	private ParticleSystemContainer mainEngineDamageHeavy;

	[SerializeField]
	private ParticleSystemContainer cockpitSparks;

	[SerializeField]
	private Transform tailDamageLightEffects;

	[SerializeField]
	private Transform mainEngineDamageLightEffects;

	[SerializeField]
	private SoundDefinition damagedFireSoundDef;

	[SerializeField]
	private SoundDefinition damagedFireTailSoundDef;

	[SerializeField]
	private SoundDefinition damagedSparksSoundDef;

	[SerializeField]
	private float pilotRotorScale = 1.5f;

	[SerializeField]
	private float compassOffset;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population;

	public const string PASSENGER_ACHIEVEMENT = "RUST_AIR";

	public const int PASSENGER_ACHIEVEMENT_REQ_COUNT = 5;

	public override void ServerInit()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.inertiaTensor = new Vector3(19082f, 14356f, 7940f);
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (base.isServer)
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedNetworking, 0.15f);
		}
	}

	public void DelayedNetworking()
	{
		SendNetworkUpdate();
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!GameInfo.HasAchievements || !base.isServer || old.HasFlag(Flags.On) || !next.HasFlag(Flags.On) || !((Object)(object)GetDriver() != (Object)null))
		{
			return;
		}
		int num = 0;
		foreach (BaseEntity child in children)
		{
			if ((Object)(object)child.ToPlayer() != (Object)null)
			{
				num++;
			}
			if (child is BaseVehicleSeat baseVehicleSeat && (Object)(object)baseVehicleSeat.GetMounted() != (Object)null && (Object)(object)baseVehicleSeat.GetMounted() != (Object)(object)GetDriver())
			{
				num++;
			}
		}
		if (num >= 5)
		{
			GetDriver().GiveAchievement("RUST_AIR");
		}
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		return false;
	}
}


using UnityEngine;

public class ScrapTransportHelicopterWheelEffects : MonoBehaviour, IServerComponent
{
	public WheelCollider wheelCollider;

	public GameObjectRef impactEffect;

	public float minTimeBetweenEffects = 0.25f;

	public float minDistBetweenEffects = 0.1f;

	private bool wasGrounded;

	private float lastEffectPlayed;

	private Vector3 lastCollisionPos;

	public void Update()
	{
		bool isGrounded = wheelCollider.isGrounded;
		if (isGrounded && !wasGrounded)
		{
			DoImpactEffect();
		}
		wasGrounded = isGrounded;
	}

	private void DoImpactEffect()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (impactEffect.isValid && !(Time.time < lastEffectPlayed + minTimeBetweenEffects) && (!(Vector3.Distance(((Component)this).transform.position, lastCollisionPos) < minDistBetweenEffects) || lastEffectPlayed == 0f))
		{
			Effect.server.Run(impactEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up);
			lastEffectPlayed = Time.time;
			lastCollisionPos = ((Component)this).transform.position;
		}
	}
}


using UnityEngine;

public class AnimalRagdoll : Ragdoll
{
	public SkinnedMeshRenderer[] bodyRenderers;

	public SkinnedMeshRenderer[] hairRenderers;
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class BaseAnimalRagdoll : BaseCombatEntity
{
	[SerializeField]
	private Ragdoll Ragdoll;

	private EntityRef<BaseCombatEntity> linkedEntity;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		if (linkedEntity.IsValid(base.isServer))
		{
			info.msg.temporaryRagdoll.parentID = linkedEntity.uid;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.temporaryRagdoll != null)
		{
			Load(info.msg.temporaryRagdoll);
		}
	}

	private void Load(TemporaryRagdoll tempRagdoll)
	{
	}

	private void LateUpdate()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		BaseCombatEntity baseCombatEntity = linkedEntity.Get(base.isServer);
		if (base.isServer)
		{
			if ((Object)(object)baseCombatEntity == (Object)null || baseCombatEntity.IsDead())
			{
				Kill();
				return;
			}
			((Component)baseCombatEntity).transform.position = ((Component)this).transform.position;
			((Component)baseCombatEntity).transform.rotation = ((Component)this).transform.rotation;
			SendNetworkUpdateImmediate();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
		if ((Object)(object)val == (Object)null)
		{
			val = ((Component)this).gameObject.AddComponent<Rigidbody>();
			val.mass = 10f;
			val.drag = 0f;
			val.angularDrag = 0f;
		}
		val.useGravity = true;
		val.collisionDetectionMode = (CollisionDetectionMode)0;
		val.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
	}

	public void InitFromEnt(BaseCombatEntity ent)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		linkedEntity.Set(ent);
		ent.model.skeleton.CopyTo(model.skeleton);
		((Component)this).transform.SetPositionAndRotation(((Component)ent).transform.position, ((Component)ent).transform.rotation);
		Ragdoll.ServerInit();
		Vector3 worldVelocity = ent.GetWorldVelocity();
		foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
		{
			rigidbody.AddForce(worldVelocity, (ForceMode)2);
			rigidbody.drag = 0f;
		}
		((FacepunchBehaviour)this).Invoke((Action)StopRagdolling, 5f);
	}

	private void StopRagdolling()
	{
		linkedEntity.Get(serverside: true)?.SetFlag(Flags.Reserved12, b: false);
		Kill();
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		ProcessCollision(collision);
	}

	protected void OnCollisionEnter(Collision collision)
	{
		ProcessCollision(collision);
	}

	protected void ProcessCollision(Collision collision)
	{
		if (!base.isClient && collision != null && !((Object)(object)collision.gameObject == (Object)null) && !((Object)(object)collision.gameObject == (Object)null) && linkedEntity.Get(serverside: true) is IAnimalRagdollCollisionReceiver animalRagdollCollisionReceiver)
		{
			animalRagdollCollisionReceiver.OnRagdollCollisionEnter(collision);
		}
	}
}


using UnityEngine;

public interface IAnimalRagdollCollisionReceiver
{
	void OnRagdollCollisionEnter(Collision collision);
}


using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/Horse Breed", fileName = "newbreed.asset")]
public class HorseBreed : ScriptableObject
{
	public Phrase breedName;

	public Phrase breedDesc;

	public Sprite trophyHeadSprite;

	public Material[] materialOverrides;

	public float maxHealth = 1f;

	public float maxSpeed = 1f;

	public float staminaDrain = 1f;

	public float maxStamina = 1f;
}


using Facepunch;
using ProtoBuf;

public class HorseCorpse : LootableCorpse
{
	public int breedIndex;

	public Phrase lootPanelTitle;

	public override string playerName => lootPanelTitle.translated;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.horse = Pool.Get<Horse>();
		info.msg.horse.breedIndex = breedIndex;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.horse != null)
		{
			breedIndex = info.msg.horse.breedIndex;
		}
	}
}


using UnityEngine;

public class HorseLeadingRope : FakePhysicsRope
{
	public RidableHorse horse;

	public Vector2 minMaxLength;

	public Vector2 minMaxDistance;
}


using UnityEngine;

public class HorseRagdoll : AnimalRagdoll
{
	public GameObject mane;

	public GameObject woodArmor;

	public GameObject roadsignArmor;

	public HorseBreed overrideBreed;

	public GameObject singleSaddle;

	public GameObject doubleSaddle;

	public GameObjectRef breedSource;
}


using UnityEngine;

public class HorseSaddle : BaseVehicleSeat
{
	[SerializeField]
	private bool isDriver;

	[SerializeField]
	private Transform eyePosRef;

	private RidableHorse _owner;

	protected RidableHorse Owner
	{
		get
		{
			if ((Object)(object)_owner == (Object)null)
			{
				_owner = ((Component)this).GetComponentInParent<RidableHorse>();
			}
			return _owner;
		}
	}

	public override void VehicleFixedUpdate()
	{
	}

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			BaseVehicle baseVehicle = VehicleParent();
			if ((Object)(object)baseVehicle != (Object)null)
			{
				baseVehicle.PlayerMounted(mounted, this);
			}
		}
	}
}


public interface IHorseInputProvider
{
	float GetMoveInput();

	float GetSteerInput();
}


using UnityEngine;

public class AIHorseInputProvider : IHorseInputProvider
{
	private Transform playerTransform;

	private RidableHorse horse;

	private float followSpeed;

	private float stoppingDistance;

	private float turnChangeCooldown = 0.3f;

	private float turnCooldownTimer;

	private float currentSteerInput;

	public AIHorseInputProvider(RidableHorse horse, Transform playerTransform, float stoppingDistance)
	{
		this.horse = horse;
		this.playerTransform = playerTransform;
		this.stoppingDistance = stoppingDistance;
	}

	public float GetMoveInput()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = playerTransform.position - ((Component)horse).transform.position;
		val.y = 0f;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (horse.GetSpeed() > 2f)
		{
			return -1f;
		}
		if (magnitude > stoppingDistance)
		{
			return Mathf.Clamp(((Component)horse).transform.InverseTransformDirection(((Vector3)(ref val)).normalized).z, 0f, 1f);
		}
		return 0f;
	}

	public float GetSteerInput()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = playerTransform.position - ((Component)horse).transform.position;
		val.y = 0f;
		if (((Vector3)(ref val)).magnitude > stoppingDistance - 2f)
		{
			Vector3 val2 = Vector3.Cross(((Component)horse).transform.forward, ((Vector3)(ref val)).normalized);
			int num = 0;
			if (val2.y > 0.4f)
			{
				num = 1;
			}
			else if (val2.y < -0.4f)
			{
				num = -1;
			}
			Quaternion val3 = Quaternion.LookRotation(val);
			float num2 = Quaternion.Angle(((Component)horse).transform.rotation, val3);
			if (num2 > 160f && num2 < 180f)
			{
				num = -1;
			}
			if ((float)num != currentSteerInput && turnCooldownTimer <= 0f)
			{
				currentSteerInput = num;
				turnCooldownTimer = turnChangeCooldown;
			}
		}
		else if (currentSteerInput != 0f && turnCooldownTimer <= 0f)
		{
			currentSteerInput = 0f;
			turnCooldownTimer = turnChangeCooldown;
		}
		if (turnCooldownTimer > 0f)
		{
			turnCooldownTimer -= Time.fixedDeltaTime;
		}
		return currentSteerInput;
	}
}


public class PlayerHorseInputProvider : IHorseInputProvider
{
	public BasePlayer player;

	public PlayerHorseInputProvider(BasePlayer player)
	{
		this.player = player;
	}

	public float GetMoveInput()
	{
		float result = 0f;
		if (player.serverInput.IsDown(BUTTON.FORWARD))
		{
			result = 1f;
		}
		else if (player.serverInput.IsDown(BUTTON.BACKWARD))
		{
			result = -1f;
		}
		return result;
	}

	public float GetSteerInput()
	{
		float result = 0f;
		if (player.serverInput.IsDown(BUTTON.LEFT))
		{
			result = -1f;
		}
		else if (player.serverInput.IsDown(BUTTON.RIGHT))
		{
			result = 1f;
		}
		return result;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

[DefaultExecutionOrder(-1302)]
public class RidableHorseAnimation : EntityComponent<RidableHorse>, IClientComponent
{
	[SerializeField]
	private RidableHorse horse;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	public LegsAnimator legsAnimator;

	[SerializeField]
	[Space]
	private Transform backHipTransform;

	[SerializeField]
	private Vector3 skiddingHipPosition;

	[SerializeField]
	private Vector3 skiddingHipRotation;

	[Range(0f, 1f)]
	[Header("Head")]
	[SerializeField]
	private float headBlend = 1f;

	[ReadOnly]
	public float headSecondaryBlend = 1f;

	public Transform[] neckBones;

	public AnimationCurve rotationResponsivenessCurve;

	public float yawInertiaFactor = 15f;

	public float maxYawAngle = 10f;

	public Vector2 minMaxStiffness;

	public Vector2 minMaxDamping;

	public float headTurnSpeed = 3.5f;

	public Vector3 headLookOffset = Vector3.zero;

	[SerializeField]
	[Header("Spine")]
	[Range(0f, 1f)]
	private float spineBlend = 0.5f;

	[ReadOnly]
	public float spineSecondaryBlend = 1f;

	public Transform[] spineBones;

	public float spineTurnSpeed = 3.5f;

	public float spineYawInertiaFactor = 150f;

	[SerializeField]
	[ReadOnly]
	private Quaternion[] targetNeckRotations;

	[SerializeField]
	[ReadOnly]
	private Quaternion[] targetSpineRotations;

	[SerializeField]
	[ReadOnly]
	private Vector3[] localSpinePositions;

	[SerializeField]
	[ReadOnly]
	private Vector3 originalHipPosition;

	[ReadOnly]
	[SerializeField]
	private Quaternion originalHipRotation;

	public Vector3 spineOffset;

	private float HeadBlend => headBlend * headSecondaryBlend;

	private float SpineBlend => spineBlend * spineSecondaryBlend;
}


using UnityEngine;

public class RidableHorseAudio : FacepunchBehaviour, IClientComponent
{
	[SerializeField]
	private RidableHorse horse;

	[SerializeField]
	private Animator animator;

	[Space]
	[SerializeField]
	public SoundPlayer breathingSound;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDef;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDefWood;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDefRoadsign;

	[SerializeField]
	private AnimationCurve saddleMovementGainCurve;

	[SerializeField]
	[Space]
	private MaterialEffect footstepEffects;

	[SerializeField]
	private Transform[] feet;

	[SerializeField]
	[Space]
	private GameObjectRef swimmingSloshEffect;

	[SerializeField]
	private string BaseFolder;

	[SerializeField]
	[Space]
	private SoundDefinition skidLoopSoundDef;

	[SerializeField]
	private AnimationCurve skidLoopGainCurve;
}


using UnityEngine;

[DefaultExecutionOrder(-1300)]
public class RidableHorseSiegeHarness : EntityComponent<RidableHorse>, IClientComponent
{
	[SerializeField]
	private Transform[] targetBone;

	[SerializeField]
	private Transform[] constrainedBone;

	[SerializeField]
	private Vector3 rotationOffset;

	private void LookAtBone(int index)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (targetBone != null && constrainedBone != null)
		{
			Vector3 val = targetBone[index].position - constrainedBone[index].position;
			if (!(val == Vector3.zero))
			{
				Quaternion val2 = Quaternion.LookRotation(val);
				Quaternion val3 = Quaternion.Euler(rotationOffset);
				Quaternion rotation = val2 * val3;
				constrainedBone[index].rotation = rotation;
			}
		}
	}

	private void LateUpdate()
	{
		LookAtBone(0);
		LookAtBone(1);
	}
}


using UnityEngine;

public class SM_DisableHorseProceduralMotion : StateMachineBehaviour
{
}


using UnityEngine;

public class HumanFuelSystem : IFuelSystem
{
	private readonly bool isServer;

	private float percentFood;

	private EntityRef<BaseVehicle> vehilceRef;

	private float pendingFuel;

	public HumanFuelSystem(bool isServer, BaseVehicle owner, float percentFood)
	{
		this.isServer = isServer;
		this.percentFood = Mathf.Clamp01(percentFood);
		vehilceRef.Set(owner);
	}

	public bool HasValidInstance(bool isServer)
	{
		return vehilceRef.IsValid(isServer);
	}

	public NetworkableId GetInstanceID()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return vehilceRef.uid;
	}

	public void SetInstanceID(NetworkableId uid)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		vehilceRef.uid = uid;
	}

	private BaseVehicle GetVehilce()
	{
		BaseVehicle baseVehicle = vehilceRef.Get(isServer);
		if (baseVehicle.IsValid())
		{
			return baseVehicle;
		}
		return null;
	}

	public int GetFuelCapacity()
	{
		return 0;
	}

	public bool CheckNewChild(BaseEntity child)
	{
		return false;
	}

	public int GetFuelAmount()
	{
		if (TryGetHuman(out var driver))
		{
			float value = driver.metabolism.calories.value;
			float value2 = driver.metabolism.hydration.value;
			return Mathf.FloorToInt(value + value2);
		}
		return 0;
	}

	public float GetFuelFraction()
	{
		if (TryGetHuman(out var driver))
		{
			float num = driver.metabolism.calories.Fraction() * percentFood;
			float num2 = driver.metabolism.hydration.Fraction() * (1f - percentFood);
			return num + num2;
		}
		return 0f;
	}

	public bool HasFuel(bool forceCheck = false)
	{
		if (!TryGetHuman(out var driver))
		{
			return false;
		}
		if (percentFood == 0f)
		{
			return driver.metabolism.hydration.Fraction() > 0f;
		}
		if (percentFood == 1f)
		{
			return driver.metabolism.calories.Fraction() > 0f;
		}
		if (!(driver.metabolism.hydration.Fraction() > 0f))
		{
			return driver.metabolism.calories.Fraction() > 0f;
		}
		return true;
	}

	public int TryUseFuel(float seconds, float fuelUsedPerSecond)
	{
		if (!TryGetHuman(out var driver))
		{
			return 0;
		}
		pendingFuel += seconds + fuelUsedPerSecond;
		if (pendingFuel >= 1f)
		{
			MetabolismAttribute calories = driver.metabolism.calories;
			MetabolismAttribute hydration = driver.metabolism.hydration;
			float val = fuelUsedPerSecond * percentFood;
			float val2 = fuelUsedPerSecond * (1f - percentFood);
			float value = calories.value;
			calories.Subtract(val);
			pendingFuel -= Mathf.RoundToInt(value - calories.value);
			float value2 = hydration.value;
			hydration.Subtract(val2);
			pendingFuel -= Mathf.RoundToInt(value2 - hydration.value);
		}
		return 0;
	}

	public void LootFuel(BasePlayer player)
	{
	}

	public void AddFuel(int amount)
	{
	}

	public void RemoveFuel(int amount)
	{
	}

	public void FillFuel()
	{
	}

	private bool TryGetHuman(out BasePlayer driver)
	{
		driver = null;
		BaseVehicle vehilce = GetVehilce();
		if ((Object)(object)vehilce != (Object)null)
		{
			driver = vehilce.GetDriver();
		}
		return (Object)(object)driver != (Object)null;
	}
}


public interface IFuelSystem
{
	bool HasValidInstance(bool isServer);

	NetworkableId GetInstanceID();

	void SetInstanceID(NetworkableId uid);

	bool CheckNewChild(BaseEntity child);

	int GetFuelAmount();

	float GetFuelFraction();

	bool HasFuel(bool forceCheck = false);

	int TryUseFuel(float seconds, float fuelUsedPerSecond);

	int GetFuelCapacity();

	void LootFuel(BasePlayer player);

	void AddFuel(int amount);

	void RemoveFuel(int amount);

	void FillFuel();
}


public interface IMountable
{
}


using UnityEngine;

public class BaseMagnet : MonoBehaviour
{
	public BaseEntity entityOwner;

	public BaseEntity.Flags magnetFlag = BaseEntity.Flags.Reserved6;

	public TriggerMagnet magnetTrigger;

	public FixedJoint fixedJoint;

	public Rigidbody kinematicAttachmentBody;

	public float magnetForce;

	public Transform attachDepthPoint;

	public GameObjectRef attachEffect;

	public bool isMagnetOn;

	public GameObject colliderSource;

	private BasePlayer associatedPlayer;

	public bool HasConnectedObject()
	{
		if ((Object)(object)((Joint)fixedJoint).connectedBody != (Object)null)
		{
			return isMagnetOn;
		}
		return false;
	}

	public OBB GetConnectedOBB(float scale = 1f)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)((Joint)fixedJoint).connectedBody == (Object)null)
		{
			Debug.LogError((object)"BaseMagnet returning fake OBB because no connected body!");
			return new OBB(Vector3.zero, Vector3.one, Quaternion.identity);
		}
		BaseEntity component = ((Component)((Joint)fixedJoint).connectedBody).gameObject.GetComponent<BaseEntity>();
		Bounds bounds = component.bounds;
		((Bounds)(ref bounds)).extents = ((Bounds)(ref bounds)).extents * scale;
		return new OBB(((Component)component).transform.position, ((Component)component).transform.rotation, bounds);
	}

	public void SetCollisionsEnabled(GameObject other, bool wants)
	{
		Collider[] componentsInChildren = other.GetComponentsInChildren<Collider>();
		Collider[] componentsInChildren2 = colliderSource.GetComponentsInChildren<Collider>();
		Collider[] array = componentsInChildren;
		foreach (Collider val in array)
		{
			Collider[] array2 = componentsInChildren2;
			foreach (Collider val2 in array2)
			{
				Physics.IgnoreCollision(val, val2, !wants);
			}
		}
	}

	public virtual void SetMagnetEnabled(bool wantsOn, BasePlayer forPlayer)
	{
		if (isMagnetOn != wantsOn)
		{
			associatedPlayer = forPlayer;
			isMagnetOn = wantsOn;
			if (isMagnetOn)
			{
				OnMagnetEnabled();
			}
			else
			{
				OnMagnetDisabled();
			}
			if ((Object)(object)entityOwner != (Object)null)
			{
				entityOwner.SetFlag(magnetFlag, isMagnetOn);
			}
		}
	}

	public virtual void OnMagnetEnabled()
	{
	}

	public virtual void OnMagnetDisabled()
	{
		if (Object.op_Implicit((Object)(object)((Joint)fixedJoint).connectedBody))
		{
			SetCollisionsEnabled(((Component)((Joint)fixedJoint).connectedBody).gameObject, wants: true);
			Rigidbody connectedBody = ((Joint)fixedJoint).connectedBody;
			((Joint)fixedJoint).connectedBody = null;
			connectedBody.WakeUp();
		}
	}

	public bool IsMagnetOn()
	{
		return isMagnetOn;
	}

	public void MagnetThink(float delta)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		if (!isMagnetOn)
		{
			return;
		}
		Vector3 position = ((Component)magnetTrigger).transform.position;
		if (magnetTrigger.entityContents == null)
		{
			return;
		}
		OBB val = default(OBB);
		foreach (BaseEntity entityContent in magnetTrigger.entityContents)
		{
			if ((Object)(object)entityContent == (Object)null || !entityContent.syncPosition)
			{
				continue;
			}
			Rigidbody component = ((Component)entityContent).GetComponent<Rigidbody>();
			if ((Object)(object)component == (Object)null || component.isKinematic || entityContent.isClient)
			{
				continue;
			}
			((OBB)(ref val))..ctor(((Component)entityContent).transform.position, ((Component)entityContent).transform.rotation, entityContent.bounds);
			if (((OBB)(ref val)).Contains(attachDepthPoint.position))
			{
				MagnetLiftable component2 = ((Component)entityContent).GetComponent<MagnetLiftable>();
				if ((Object)(object)component2 != (Object)null)
				{
					if (component2.requireObjectOff && entityContent.IsOn())
					{
						continue;
					}
					component2.SetMagnetized(wantsOn: true, this, associatedPlayer);
					if ((Object)(object)((Joint)fixedJoint).connectedBody == (Object)null)
					{
						Effect.server.Run(attachEffect.resourcePath, attachDepthPoint.position, -attachDepthPoint.up);
						((Joint)fixedJoint).connectedBody = component;
						SetCollisionsEnabled(((Component)component).gameObject, wants: false);
						continue;
					}
				}
			}
			if ((Object)(object)((Joint)fixedJoint).connectedBody == (Object)null)
			{
				Vector3 position2 = ((Component)entityContent).transform.position;
				float num = Vector3.Distance(position2, position);
				Vector3 val2 = Vector3Ex.Direction(position, position2);
				float num2 = 1f / Mathf.Max(1f, num);
				component.AddForce(val2 * magnetForce * num2, (ForceMode)5);
			}
		}
	}
}


using UnityEngine;

public class IMagnetLiftable : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using UnityEngine;

public class MagnetCraneAudio : MonoBehaviour
{
	public MagnetCrane crane;

	[Header("Sound defs")]
	public SoundDefinition engineStartSoundDef;

	public SoundDefinition engineStopSoundDef;

	public BlendedLoopEngineSound engineLoops;

	public SoundDefinition cabinRotationStartDef;

	public SoundDefinition cabinRotationStopDef;

	public SoundDefinition cabinRotationLoopDef;

	private Sound cabinRotationLoop;

	public SoundDefinition turningLoopDef;

	private Sound turningLoop;

	public SoundDefinition trackMovementLoopDef;

	private Sound trackMovementLoop;

	private SoundModulation.Modulator trackGainMod;

	private SoundModulation.Modulator trackPitchMod;

	public SoundDefinition armMovementLoopDef;

	public SoundDefinition armMovementStartDef;

	public SoundDefinition armMovementStopDef;

	private Sound armMovementLoop01;

	private SoundModulation.Modulator armMovementLoop01PitchMod;

	public GameObject arm01SoundPosition;

	public GameObject arm02SoundPosition;

	private Sound armMovementLoop02;

	private SoundModulation.Modulator armMovementLoop02PitchMod;
}


using UnityEngine;

public class MagnetLiftable : EntityComponent<BaseEntity>
{
	public ItemAmount[] shredResources;

	public bool scaleScrapResourcesByHealth;

	public Vector3 shredDirection = Vector3.forward;

	public bool requireObjectOff;

	public BasePlayer associatedPlayer { get; private set; }

	public virtual void SetMagnetized(bool wantsOn, BaseMagnet magnetSource, BasePlayer player)
	{
		associatedPlayer = player;
	}
}


using UnityEngine;

public class TriggerMagnet : TriggerBase
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!baseEntity.syncPosition)
		{
			return null;
		}
		if (!Object.op_Implicit((Object)(object)((Component)baseEntity).GetComponent<MagnetLiftable>()))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;

public class MapMarkerMLRSRocket : MapMarker
{
	public RectTransform uiMarkerTransform;

	public override void ServerInit()
	{
		base.ServerInit();
		base.limitNetworking = true;
	}

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		return (ulong)player.userID == base.OwnerID;
	}
}


using UnityEngine;

public class MLRSAmmoIcon : MonoBehaviour
{
	[SerializeField]
	private GameObject fill;

	protected void Awake()
	{
		SetState(filled: false);
	}

	public void SetState(bool filled)
	{
		fill.SetActive(filled);
	}
}


using Rust.UI;
using UnityEngine;

public class MLRSAmmoUI : MonoBehaviour
{
	[SerializeField]
	private RustText ammoText;

	[SerializeField]
	private MLRSAmmoIcon[] ammoIcons;
}


using UnityEngine;

public class MLRSAudio : MonoBehaviour
{
	[SerializeField]
	private MLRS mlrs;

	[SerializeField]
	private Transform pitchTransform;

	[SerializeField]
	private Transform yawTransform;

	[SerializeField]
	private float pitchDeltaSmoothRate = 5f;

	[SerializeField]
	private float yawDeltaSmoothRate = 5f;

	[SerializeField]
	private float pitchDeltaThreshold = 0.5f;

	[SerializeField]
	private float yawDeltaThreshold = 0.5f;

	private float lastPitch;

	private float lastYaw;

	private float pitchDelta;

	private float yawDelta;

	public SoundDefinition turretMovementStartDef;

	public SoundDefinition turretMovementLoopDef;

	public SoundDefinition turretMovementStopDef;

	private Sound turretMovementLoop;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

public class MLRSMainUI : MonoBehaviour
{
	[SerializeField]
	private bool isFullscreen;

	[SerializeField]
	private GameObject noAimingModuleModeGO;

	[SerializeField]
	private GameObject activeModeGO;

	[SerializeField]
	private MLRSAmmoUI noAimingModuleAmmoUI;

	[SerializeField]
	private MLRSAmmoUI activeAmmoUI;

	[SerializeField]
	private MLRSVelocityUI velocityUI;

	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private RustText usernameText;

	[SerializeField]
	private TokenisedPhrase readyStatus;

	[SerializeField]
	private TokenisedPhrase realigningStatus;

	[SerializeField]
	private TokenisedPhrase firingStatus;

	[SerializeField]
	private RustText statusText;

	[SerializeField]
	private MapView mapView;

	[SerializeField]
	private ScrollRectEx mapScrollRect;

	[SerializeField]
	private ScrollRectZoom mapScrollRectZoom;

	[SerializeField]
	private RectTransform mapBaseRect;

	[SerializeField]
	private RectTransform minRangeCircle;

	[SerializeField]
	private RectTransform targetAimRect;

	[SerializeField]
	private RectTransform trueAimRect;

	[SerializeField]
	private UILineRenderer connectingLine;

	[SerializeField]
	private GameObject noTargetCirclePrefab;

	[SerializeField]
	private Transform noTargetCircleParent;

	[SerializeField]
	private SoundDefinition changeTargetSoundDef;

	[SerializeField]
	private SoundDefinition readyToFireSoundDef;
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class MLRSRocket : TimedExplosive, SamSite.ISamSiteTarget
{
	[SerializeField]
	private GameObjectRef mapMarkerPrefab;

	[SerializeField]
	private GameObjectRef launchBlastFXPrefab;

	[SerializeField]
	private GameObjectRef explosionGroundFXPrefab;

	[SerializeField]
	private ServerProjectile serverProjectile;

	private EntityRef mapMarkerInstanceRef;

	public static List<MLRSRocket> serverList = new List<MLRSRocket>();

	public SamSite.SamTargetType SAMTargetType => SamSite.targetTypeMissile;

	public override void ServerInit()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		serverList.Add(this);
		CreateMapMarker();
		Effect.server.Run(launchBlastFXPrefab.resourcePath, PivotPoint(), ((Component)this).transform.up, null, broadcast: true);
	}

	internal override void DoServerDestroy()
	{
		serverList.Remove(this);
		base.DoServerDestroy();
	}

	public override void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Explode(rayOrigin);
		if (Physics.Raycast(((RaycastHit)(ref info)).point + Vector3.up, Vector3.down, 4f, 1084293393, (QueryTriggerInteraction)1))
		{
			Effect.server.Run(explosionGroundFXPrefab.resourcePath, ((RaycastHit)(ref info)).point, Vector3.up, null, broadcast: true);
		}
	}

	private void CreateMapMarker()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = mapMarkerInstanceRef.Get(base.isServer);
		if (baseEntity.IsValid())
		{
			baseEntity.Kill();
		}
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(mapMarkerPrefab?.resourcePath, ((Component)this).transform.position, Quaternion.identity);
		baseEntity2.OwnerID = base.OwnerID;
		baseEntity2.Spawn();
		baseEntity2.SetParent(this, worldPositionStays: true);
		mapMarkerInstanceRef.Set(baseEntity2);
	}

	public bool IsValidSAMTarget(bool staticRespawn)
	{
		return !staticRespawn;
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return serverProjectile.CurrentVelocity;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!other.IsOnLayer((Layer)18))
		{
			return;
		}
		if (((Component)other).CompareTag("MLRSRocketTrigger"))
		{
			Explode();
			TimedExplosive componentInParent = ((Component)other).GetComponentInParent<TimedExplosive>();
			if ((Object)(object)componentInParent != (Object)null)
			{
				componentInParent.Explode();
			}
		}
		else if ((Object)(object)((Component)other).GetComponent<TriggerSafeZone>() != (Object)null)
		{
			Kill();
		}
	}
}


public class MLRSServerProjectile : ServerProjectile
{
	public override bool HasRangeLimit => false;

	protected override int mask => 1235954449;

	protected override bool IsAValidHit(BaseEntity hitEnt)
	{
		if (!base.IsAValidHit(hitEnt))
		{
			return false;
		}
		if (hitEnt.IsValid())
		{
			return !(hitEnt is MLRS);
		}
		return true;
	}
}


using UnityEngine;

public class MLRSUIDialog : UIDialog
{
	[SerializeField]
	private MLRSMainUI mainUI;

	[SerializeField]
	private TokenisedPhrase howToUsePhrase;

	[SerializeField]
	private float titleChangeInterval = 2f;
}


using Rust.UI;
using UnityEngine;

public class MLRSVelocityUI : MonoBehaviour
{
	[SerializeField]
	private RustText percentText;

	[SerializeField]
	private HudElement percentBar;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust.Modular;
using UnityEngine;

public abstract class BaseModularVehicle : GroundVehicle, IPrefabPreProcess, PlayerInventory.ICanMoveFrom
{
	[Header("Modular Vehicle")]
	[SerializeField]
	public List<ModularVehicleSocket> moduleSockets;

	[SerializeField]
	public Transform centreOfMassTransform;

	[SerializeField]
	public Transform waterSample;

	[SerializeField]
	public LODGroup lodGroup;

	public GameObjectRef keyEnterDialog;

	private float _mass = -1f;

	public const Flags FLAG_KINEMATIC = Flags.Reserved6;

	public Dictionary<BaseVehicleModule, Action> moduleAddActions = new Dictionary<BaseVehicleModule, Action>();

	public bool inEditableLocation;

	public bool prevEditable;

	public bool immuneToDecay;

	public Vector3 realLocalCOM;

	public Item AssociatedItemInstance;

	private bool disablePhysics;

	public Vector3 CentreOfMass => centreOfMassTransform.localPosition;

	public int NumAttachedModules => AttachedModuleEntities.Count;

	public bool HasAnyModules => AttachedModuleEntities.Count > 0;

	public List<BaseVehicleModule> AttachedModuleEntities { get; } = new List<BaseVehicleModule>();

	public int TotalSockets => moduleSockets.Count;

	public int NumFreeSockets
	{
		get
		{
			int num = 0;
			for (int i = 0; i < NumAttachedModules; i++)
			{
				num += AttachedModuleEntities[i].GetNumSocketsTaken();
			}
			return TotalSockets - num;
		}
	}

	private float Mass
	{
		get
		{
			if (base.isServer)
			{
				return rigidBody.mass;
			}
			return _mass;
		}
	}

	public float TotalMass { get; set; }

	public bool IsKinematic => HasFlag(Flags.Reserved6);

	public virtual bool IsLockable => false;

	public bool HasInited { get; private set; }

	public ItemDefinition AssociatedItemDef => repair.itemTarget;

	public bool IsEditableNow
	{
		get
		{
			if (base.isServer)
			{
				if (inEditableLocation)
				{
					return CouldBeEdited();
				}
				return false;
			}
			return false;
		}
	}

	public ModularVehicleInventory Inventory { get; set; }

	public override void InitShared()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		AddMass(Mass, CentreOfMass, ((Component)this).transform.position);
		HasInited = true;
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			attachedModuleEntity.RefreshConditionals(canGib: false);
		}
	}

	public virtual bool PlayerCanUseThis(BasePlayer player, ModularCarCodeLock.LockType lockType)
	{
		return true;
	}

	public bool TryDeduceSocketIndex(BaseVehicleModule addedModule, out int index)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (addedModule.FirstSocketIndex >= 0)
		{
			index = addedModule.FirstSocketIndex;
			return index >= 0;
		}
		index = -1;
		for (int i = 0; i < moduleSockets.Count; i++)
		{
			if (Vector3.SqrMagnitude(moduleSockets[i].WorldPosition - ((Component)addedModule).transform.position) < 0.1f)
			{
				index = i;
				return true;
			}
		}
		return false;
	}

	public void AddMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			Vector3 val = ((Component)this).transform.InverseTransformPoint(moduleWorldPos) + moduleCOM;
			if (TotalMass == 0f)
			{
				SetMass(moduleMass);
				SetCOM(val);
				return;
			}
			float num = TotalMass + moduleMass;
			Vector3 cOM = realLocalCOM * (TotalMass / num) + val * (moduleMass / num);
			SetMass(num);
			SetCOM(cOM);
		}
	}

	public void RemoveMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			float num = TotalMass - moduleMass;
			Vector3 val = ((Component)this).transform.InverseTransformPoint(moduleWorldPos) + moduleCOM;
			Vector3 cOM = (realLocalCOM - val * (moduleMass / TotalMass)) / (num / TotalMass);
			SetMass(num);
			SetCOM(cOM);
		}
	}

	public bool TryGetModuleAt(int socketIndex, out BaseVehicleModule result)
	{
		if (socketIndex < 0 || socketIndex >= moduleSockets.Count)
		{
			result = null;
			return false;
		}
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			int firstSocketIndex = attachedModuleEntity.FirstSocketIndex;
			int num = firstSocketIndex + attachedModuleEntity.GetNumSocketsTaken() - 1;
			if (firstSocketIndex <= socketIndex && num >= socketIndex)
			{
				result = attachedModuleEntity;
				return true;
			}
		}
		result = null;
		return false;
	}

	public ModularVehicleSocket GetSocket(int index)
	{
		if (index < 0 || index >= moduleSockets.Count)
		{
			return null;
		}
		return moduleSockets[index];
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.modularVehicle;
	}

	public override bool CanPushNow(BasePlayer pusher)
	{
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (!IsKinematic)
		{
			return !IsEditableNow;
		}
		return false;
	}

	public override void OnChildAdded(BaseEntity childEntity)
	{
		base.OnChildAdded(childEntity);
		BaseVehicleModule module = childEntity as BaseVehicleModule;
		if (module != null)
		{
			Action action = delegate
			{
				ModuleEntityAdded(module);
			};
			moduleAddActions[module] = action;
			((FacepunchBehaviour)module).Invoke(action, 0f);
		}
	}

	public override void OnChildRemoved(BaseEntity childEntity)
	{
		base.OnChildRemoved(childEntity);
		if (childEntity is BaseVehicleModule removedModule)
		{
			ModuleEntityRemoved(removedModule);
		}
	}

	public virtual void ModuleEntityAdded(BaseVehicleModule addedModule)
	{
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		if (AttachedModuleEntities.Contains(addedModule))
		{
			return;
		}
		if (base.isServer && ((Object)(object)this == (Object)null || IsDead() || base.IsDestroyed))
		{
			if ((Object)(object)addedModule != (Object)null && !addedModule.IsDestroyed)
			{
				addedModule.Kill();
			}
			return;
		}
		int index = -1;
		if (base.isServer && addedModule.AssociatedItemInstance != null)
		{
			index = addedModule.AssociatedItemInstance.position;
		}
		if (index == -1 && !TryDeduceSocketIndex(addedModule, out index))
		{
			string text = $"{((object)this).GetType().Name}: Couldn't get socket index from position ({((Component)addedModule).transform.position}).";
			for (int i = 0; i < moduleSockets.Count; i++)
			{
				text += $" Sqr dist to socket {i} at {moduleSockets[i].WorldPosition} is {Vector3.SqrMagnitude(moduleSockets[i].WorldPosition - ((Component)addedModule).transform.position)}.";
			}
			Debug.LogError((object)text, (Object)(object)((Component)addedModule).gameObject);
			return;
		}
		if (moduleAddActions.ContainsKey(addedModule))
		{
			moduleAddActions.Remove(addedModule);
		}
		AttachedModuleEntities.Add(addedModule);
		addedModule.ModuleAdded(this, index);
		AddMass(addedModule.Mass, addedModule.CentreOfMass, ((Component)addedModule).transform.position);
		if (base.isServer && !Inventory.TrySyncModuleInventory(addedModule, index))
		{
			Debug.LogError((object)$"{((object)this).GetType().Name}: Unable to add module {((Object)addedModule).name} to socket ({index}). Destroying it.", (Object)(object)((Component)this).gameObject);
			addedModule.Kill();
			AttachedModuleEntities.Remove(addedModule);
			return;
		}
		RefreshModulesExcept(addedModule);
		if (base.isServer)
		{
			UpdateMountFlags();
		}
	}

	public virtual void ModuleEntityRemoved(BaseVehicleModule removedModule)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (base.IsDestroyed)
		{
			return;
		}
		if (moduleAddActions.ContainsKey(removedModule))
		{
			((FacepunchBehaviour)removedModule).CancelInvoke(moduleAddActions[removedModule]);
			moduleAddActions.Remove(removedModule);
		}
		if (AttachedModuleEntities.Contains(removedModule))
		{
			RemoveMass(removedModule.Mass, removedModule.CentreOfMass, ((Component)removedModule).transform.position);
			AttachedModuleEntities.Remove(removedModule);
			removedModule.ModuleRemoved();
			RefreshModulesExcept(removedModule);
			if (base.isServer)
			{
				UpdateMountFlags();
			}
		}
	}

	public void RefreshModulesExcept(BaseVehicleModule ignoredModule)
	{
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			if ((Object)(object)attachedModuleEntity != (Object)(object)ignoredModule)
			{
				attachedModuleEntity.OtherVehicleModulesChanged();
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!disablePhysics)
		{
			rigidBody.isKinematic = false;
		}
		prevEditable = IsEditableNow;
		if (Inventory == null)
		{
			Inventory = new ModularVehicleInventory(this, AssociatedItemDef, giveUID: true);
		}
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		if (Inventory == null)
		{
			Inventory = new ModularVehicleInventory(this, AssociatedItemDef, giveUID: false);
		}
	}

	public override void PostServerLoad()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		if (Inventory != null)
		{
			ItemContainerId uID = Inventory.UID;
			if (!((ItemContainerId)(ref uID)).IsValid)
			{
				Inventory.GiveUIDs();
			}
		}
		SetFlag(Flags.Open, b: false);
	}

	public override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (Inventory != null)
		{
			Inventory.Dispose();
			Inventory = null;
		}
	}

	public override float MaxVelocity()
	{
		return Mathf.Max(GetMaxForwardSpeed() * 1.3f, 30f);
	}

	public abstract bool IsComplete();

	public bool CouldBeEdited()
	{
		if (!AnyMounted())
		{
			return !IsDead();
		}
		return false;
	}

	public void DisablePhysics()
	{
		disablePhysics = true;
		rigidBody.isKinematic = true;
	}

	public void EnablePhysics()
	{
		disablePhysics = false;
		rigidBody.isKinematic = false;
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("BaseModularVehicle.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (IsEditableNow != prevEditable)
			{
				SendNetworkUpdate();
				prevEditable = IsEditableNow;
			}
			SetFlag(Flags.Reserved6, rigidBody.isKinematic);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override bool MountEligable(BasePlayer player)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (!base.MountEligable(player))
		{
			return false;
		}
		if (IsDead())
		{
			return false;
		}
		if (HasDriver())
		{
			Vector3 velocity = base.Velocity;
			if (((Vector3)(ref velocity)).magnitude >= 2f)
			{
				return false;
			}
		}
		return true;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.modularVehicle = Pool.Get<ModularVehicle>();
		info.msg.modularVehicle.editable = IsEditableNow;
	}

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		BaseVehicleModule moduleForItem = GetModuleForItem(item);
		if ((Object)(object)moduleForItem != (Object)null)
		{
			object obj = Interface.CallHook("OnVehicleModuleMove", (object)moduleForItem, (object)this, (object)player);
			if (obj != null)
			{
				if (!(obj is bool))
				{
					return false;
				}
				return (bool)obj;
			}
			return moduleForItem.CanBeMovedNow();
		}
		return true;
	}

	protected abstract Vector3 GetCOMMultiplier();

	public virtual void ModuleHurt(BaseVehicleModule hurtModule, HitInfo info)
	{
		DoExplosionForce(info);
	}

	public abstract void ModuleReachedZeroHealth();

	public bool TryAddModule(Item moduleItem, int socketIndex)
	{
		if (!ModuleCanBeAdded(moduleItem, socketIndex, out var failureReason))
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": Can't add module: " + failureReason));
			return false;
		}
		bool num = Inventory.TryAddModuleItem(moduleItem, socketIndex);
		if (!num)
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": Couldn't add new item!"));
		}
		return num;
	}

	public bool TryAddModule(Item moduleItem)
	{
		ItemModVehicleModule component = ((Component)moduleItem.info).GetComponent<ItemModVehicleModule>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		int socketsTaken = component.socketsTaken;
		int num = Inventory.TryGetFreeSocket(socketsTaken);
		if (num < 0)
		{
			return false;
		}
		return TryAddModule(moduleItem, num);
	}

	public bool ModuleCanBeAdded(Item moduleItem, int socketIndex, out string failureReason)
	{
		if (!base.isServer)
		{
			failureReason = "Can only add modules on server";
			return false;
		}
		if (moduleItem == null)
		{
			failureReason = "Module item is null";
			return false;
		}
		if (moduleItem.info.category != ItemCategory.Component)
		{
			failureReason = "Not a component type item";
			return false;
		}
		ItemModVehicleModule component = ((Component)moduleItem.info).GetComponent<ItemModVehicleModule>();
		if ((Object)(object)component == (Object)null)
		{
			failureReason = "Not the right item module type";
			return false;
		}
		int socketsTaken = component.socketsTaken;
		if (socketIndex < 0)
		{
			socketIndex = Inventory.TryGetFreeSocket(socketsTaken);
		}
		if (!Inventory.SocketsAreFree(socketIndex, socketsTaken, moduleItem))
		{
			failureReason = "One or more desired sockets already in use";
			return false;
		}
		failureReason = string.Empty;
		return true;
	}

	public BaseVehicleModule CreatePhysicalModuleEntity(Item moduleItem, ItemModVehicleModule itemModModule, int socketIndex)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldPosition = moduleSockets[socketIndex].WorldPosition;
		Quaternion worldRotation = moduleSockets[socketIndex].WorldRotation;
		BaseVehicleModule baseVehicleModule = itemModModule.CreateModuleEntity(this, worldPosition, worldRotation);
		baseVehicleModule.AssociatedItemInstance = moduleItem;
		SetUpModule(baseVehicleModule, moduleItem);
		return baseVehicleModule;
	}

	public void SetUpModule(BaseVehicleModule moduleEntity, Item moduleItem)
	{
		moduleEntity.InitializeHealth(moduleItem.condition, moduleItem.maxCondition);
		if (moduleItem.condition < moduleItem.maxCondition)
		{
			moduleEntity.SendNetworkUpdate();
		}
	}

	public Item GetVehicleItem(ItemId itemUID)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		Item item = Inventory.ChassisContainer.FindItemByUID(itemUID);
		if (item == null)
		{
			item = Inventory.ModuleContainer.FindItemByUID(itemUID);
		}
		return item;
	}

	public BaseVehicleModule GetModuleForItem(Item item)
	{
		if (item == null)
		{
			return null;
		}
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			if (attachedModuleEntity.AssociatedItemInstance == item)
			{
				return attachedModuleEntity;
			}
		}
		return null;
	}

	public void SetMass(float mass)
	{
		TotalMass = mass;
		rigidBody.mass = TotalMass;
	}

	public void SetCOM(Vector3 com)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		realLocalCOM = com;
		rigidBody.centerOfMass = Vector3.Scale(realLocalCOM, GetCOMMultiplier());
	}
}


using UnityEngine;

[CreateAssetMenu(fileName = "Engine Audio Preset", menuName = "Scriptable Object/Vehicles/Engine Audio Preset")]
public class EngineAudioSet : ScriptableObject
{
	public BlendedEngineLoopDefinition[] engineAudioLoops;

	public int priority;

	public float idleRpm = 600f;

	public float gearUpRpm = 5000f;

	public float gearDownRpm = 2500f;

	public int numGears = 5;

	public float minRpm = 10f;

	public float maxRpm = 6000f;

	public float gearUpRpmRate = 5f;

	public float gearDownRpmRate = 6f;

	public SoundDefinition badPerformanceLoop;

	public BlendedEngineLoopDefinition GetEngineLoopDef(int numEngines)
	{
		int num = (numEngines - 1) % engineAudioLoops.Length;
		return engineAudioLoops[num];
	}
}


using UnityEngine;

public class GlassPane : BaseMonoBehaviour, IClientComponent
{
	public Renderer glassRendereer;

	[SerializeField]
	private BaseVehicleModule module;

	[SerializeField]
	private float showFullDamageAt = 0.75f;
}


using UnityEngine;

public class MagnetSnap
{
	private Transform snapLocation;

	private Vector3 prevSnapLocation;

	public MagnetSnap(Transform snapLocation)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		this.snapLocation = snapLocation;
		prevSnapLocation = snapLocation.position;
	}

	public void FixedUpdate(Transform target)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		PositionTarget(target);
		if (snapLocation.hasChanged)
		{
			prevSnapLocation = snapLocation.position;
			snapLocation.hasChanged = false;
		}
	}

	public void PositionTarget(Transform target)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)target == (Object)null))
		{
			Transform transform = ((Component)target).transform;
			Quaternion val = snapLocation.rotation;
			if (Vector3.Angle(transform.forward, snapLocation.forward) > 90f)
			{
				val *= Quaternion.Euler(0f, 180f, 0f);
			}
			if (transform.position != snapLocation.position)
			{
				transform.position += snapLocation.position - prevSnapLocation;
				transform.position = Vector3.MoveTowards(transform.position, snapLocation.position, 1f * Time.fixedDeltaTime);
			}
			if (transform.rotation != val)
			{
				transform.rotation = Quaternion.RotateTowards(transform.rotation, val, 40f * Time.fixedDeltaTime);
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class ModularCarCentralLockingSwitch : VehicleModuleButtonComponent
{
	public Transform centralLockingSwitch;

	public Vector3 switchOffPos;

	public Vector3 switchOnPos;

	public override void ServerUse(BasePlayer player, BaseVehicleModule parentModule)
	{
		if (parentModule.Vehicle is ModularCar modularCar)
		{
			modularCar.CarLock.ToggleCentralLocking();
		}
	}
}


using System;
using UnityEngine;

public class ModularCarChassisVisuals : VehicleChassisVisuals<ModularCar>, IClientComponent
{
	[Serializable]
	public class Steering
	{
		public Transform steerL;

		public Transform steerR;

		public LookAtTarget steerRodL;

		public LookAtTarget steerRodR;

		public LookAtTarget steeringArm;
	}

	[Serializable]
	public class LookAtTarget
	{
		public Transform aim;

		public Transform target;

		public Vector3 angleAdjust;
	}

	public Transform frontAxle;

	public Transform rearAxle;

	public Steering steering;

	public LookAtTarget transmission;
}


using System;
using UnityEngine;

[Serializable]
public class Steering
{
	public Transform steerL;

	public Transform steerR;

	public LookAtTarget steerRodL;

	public LookAtTarget steerRodR;

	public LookAtTarget steeringArm;
}


using System;
using UnityEngine;

[Serializable]
public class LookAtTarget
{
	public Transform aim;

	public Transform target;

	public Vector3 angleAdjust;
}


public interface IVehicleLockUser
{
	bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule);

	bool PlayerHasUnlockPermission(BasePlayer player);

	bool PlayerCanUseThis(BasePlayer player, ModularCarCodeLock.LockType lockType);

	void RemoveLock();
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

public class ModularCarCodeLock
{
	public enum LockType
	{
		Door,
		General
	}

	private readonly bool isServer;

	public readonly ModularCar owner;

	public const BaseEntity.Flags FLAG_CENTRAL_LOCKING = BaseEntity.Flags.Reserved2;

	public const BaseEntity.Flags FLAG_CODE_ENTRY_BLOCKED = BaseEntity.Flags.Reserved10;

	public const float LOCK_DESTROY_HEALTH = 0.2f;

	private List<ulong> whitelistPlayers = new List<ulong>();

	private int wrongCodes;

	private float lastWrongTime = float.NegativeInfinity;

	public bool HasALock
	{
		get
		{
			if (isServer)
			{
				return !string.IsNullOrEmpty(Code);
			}
			return false;
		}
	}

	public bool CentralLockingIsOn
	{
		get
		{
			if ((Object)(object)owner != (Object)null)
			{
				return owner.HasFlag(BaseEntity.Flags.Reserved2);
			}
			return false;
		}
	}

	public IList<ulong> WhitelistPlayers => whitelistPlayers.AsReadOnly();

	public string Code { get; private set; } = "";

	public ModularCarCodeLock(ModularCar owner, bool isServer)
	{
		this.owner = owner;
		this.isServer = isServer;
		if (isServer)
		{
			CheckEnableCentralLocking();
		}
	}

	public bool PlayerCanDestroyLock(BaseVehicleModule viaModule)
	{
		if (!HasALock)
		{
			return false;
		}
		return viaModule.healthFraction <= 0.2f;
	}

	public bool CodeEntryBlocked(BasePlayer player)
	{
		if (!HasALock)
		{
			return true;
		}
		if (HasLockPermission(player))
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null)
		{
			return owner.HasFlag(BaseEntity.Flags.Reserved10);
		}
		return false;
	}

	public void Load(BaseNetworkable.LoadInfo info)
	{
		Code = info.msg.modularCar.lockCode;
		if (Code == null)
		{
			Code = "";
		}
		whitelistPlayers.Clear();
		whitelistPlayers.AddRange(info.msg.modularCar.whitelistUsers);
	}

	public bool HasLockPermission(ulong steamId)
	{
		if (!HasALock)
		{
			return true;
		}
		return whitelistPlayers.Contains(steamId);
	}

	public bool HasLockPermission(BasePlayer player)
	{
		if (!player.IsValid() || player.IsDead())
		{
			return false;
		}
		object obj = Interface.CallHook("CanLock", (object)player, (object)owner, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return HasLockPermission(player.userID);
	}

	public bool PlayerCanUseThis(BasePlayer player, LockType lockType)
	{
		if (lockType == LockType.Door && !CentralLockingIsOn)
		{
			return true;
		}
		return HasLockPermission(player);
	}

	public void PostServerLoad()
	{
		owner.SetFlag(BaseEntity.Flags.Reserved10, b: false);
		CheckEnableCentralLocking();
	}

	public bool CanHaveALock()
	{
		object obj = Interface.CallHook("OnVehicleLockableCheck", (object)this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		if (!owner.IsDead())
		{
			return owner.HasDriverMountPoints();
		}
		return false;
	}

	public bool TryAddALock(string code, ulong userID)
	{
		if (!isServer)
		{
			return false;
		}
		if (owner.IsDead())
		{
			return false;
		}
		TrySetNewCode(code, userID);
		return HasALock;
	}

	public bool IsValidLockCode(string code)
	{
		if (code != null && code.Length == 4)
		{
			return StringEx.IsNumeric(code);
		}
		return false;
	}

	public bool TrySetNewCode(string newCode, ulong userID)
	{
		if (!IsValidLockCode(newCode))
		{
			return false;
		}
		Code = newCode;
		whitelistPlayers.Clear();
		whitelistPlayers.Add(userID);
		owner.SendNetworkUpdate();
		return true;
	}

	public void RemoveLock()
	{
		if (isServer && HasALock)
		{
			Code = "";
			owner.SendNetworkUpdate();
		}
	}

	public bool TryOpenWithCode(BasePlayer player, string codeEntered)
	{
		object obj = Interface.CallHook("CanUnlock", (object)player, (object)this, (object)codeEntered);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (CodeEntryBlocked(player))
		{
			return false;
		}
		if (!(codeEntered == Code))
		{
			if (Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, owner, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				player.ShowToast(GameTip.Styles.Red_Normal, CodeLock.blockwarning, false);
			}
			if ((float)wrongCodes >= CodeLock.maxFailedAttempts)
			{
				owner.SetFlag(BaseEntity.Flags.Reserved10, b: true);
				((FacepunchBehaviour)owner).Invoke((Action)ClearCodeEntryBlocked, CodeLock.lockoutCooldown);
			}
			lastWrongTime = Time.realtimeSinceStartup;
			return false;
		}
		if (TryAddPlayer(player.userID))
		{
			wrongCodes = 0;
		}
		owner.SendNetworkUpdate();
		return true;
	}

	private void ClearCodeEntryBlocked()
	{
		owner.SetFlag(BaseEntity.Flags.Reserved10, b: false);
		wrongCodes = 0;
	}

	public void CheckEnableCentralLocking()
	{
		if (CentralLockingIsOn)
		{
			return;
		}
		bool flag = false;
		foreach (BaseVehicleModule attachedModuleEntity in owner.AttachedModuleEntities)
		{
			if (attachedModuleEntity is VehicleModuleSeating vehicleModuleSeating && vehicleModuleSeating.HasADriverSeat() && vehicleModuleSeating.AnyMounted())
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			owner.SetFlag(BaseEntity.Flags.Reserved2, b: true);
		}
	}

	public void ToggleCentralLocking()
	{
		owner.SetFlag(BaseEntity.Flags.Reserved2, !CentralLockingIsOn);
	}

	public void Save(BaseNetworkable.SaveInfo info)
	{
		info.msg.modularCar.hasLock = HasALock;
		if (info.forDisk)
		{
			info.msg.modularCar.lockCode = Code;
		}
		info.msg.modularCar.whitelistUsers = Pool.Get<List<ulong>>();
		info.msg.modularCar.whitelistUsers.AddRange(whitelistPlayers);
	}

	public bool TryAddPlayer(ulong userID)
	{
		if (!whitelistPlayers.Contains(userID))
		{
			whitelistPlayers.Add(userID);
			return true;
		}
		return false;
	}

	public bool TryRemovePlayer(ulong userID)
	{
		return whitelistPlayers.Remove(userID);
	}
}


public enum LockType
{
	Door,
	General
}


using System;
using UnityEngine;

[Serializable]
public class ModularCarCodeLockVisuals : MonoBehaviour
{
	[SerializeField]
	private GameObject lockedVisuals;

	[SerializeField]
	private GameObject unlockedVisuals;

	[SerializeField]
	private GameObject blockedVisuals;

	[SerializeField]
	private GameObjectRef codelockEffectDenied;

	[SerializeField]
	private GameObjectRef codelockEffectShock;

	[SerializeField]
	private float xOffset = 0.91f;

	[SerializeField]
	private ParticleSystemContainer keycodeDestroyableFX;
}


using Rust;
using UnityEngine;

public class VehicleLiftOccupantTrigger : TriggerBase
{
	public ModularCar carOccupant { get; private set; }

	protected override void OnDisable()
	{
		if (!Application.isQuitting)
		{
			base.OnDisable();
			if ((Object)(object)carOccupant != (Object)null)
			{
				carOccupant = null;
			}
		}
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		if ((Object)(object)base.InterestedInObject(obj) == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null || baseEntity.isClient)
		{
			return null;
		}
		if (!(baseEntity is ModularCar))
		{
			return null;
		}
		return obj;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)carOccupant == (Object)null && ent.isServer)
		{
			carOccupant = (ModularCar)ent;
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (!((Object)(object)carOccupant == (Object)(object)ent))
		{
			return;
		}
		carOccupant = null;
		if (entityContents == null || entityContents.Count <= 0)
		{
			return;
		}
		foreach (BaseEntity entityContent in entityContents)
		{
			if ((Object)(object)entityContent != (Object)null)
			{
				carOccupant = (ModularCar)entityContent;
				break;
			}
		}
	}
}


using Rust.Modular;
using UnityEngine;

[CreateAssetMenu(fileName = "Modular Car Preset", menuName = "Scriptable Object/Vehicles/Modular Car Preset")]
public class ModularCarPresetConfig : ScriptableObject
{
	public ItemModVehicleModule[] socketItemDefs;
}


using System;
using Oxide.Core;
using UnityEngine;

public class ModularCarSeat : MouseSteerableSeat
{
	[SerializeField]
	public Vector3 leftFootIKPos;

	[SerializeField]
	public Vector3 rightFootIKPos;

	[SerializeField]
	private Vector3 leftHandIKPos;

	[SerializeField]
	private Vector3 rightHandIKPos;

	public float providesComfort;

	[NonSerialized]
	public VehicleModuleSeating associatedSeatingModule;

	public override bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (associatedSeatingModule.DoorsAreLockable)
		{
			ModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;
			if ((Object)(object)modularCar != (Object)null)
			{
				return modularCar.PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);
			}
		}
		return true;
	}

	public override float GetComfort()
	{
		return providesComfort;
	}
}


using UnityEngine;

public class ModularVehicleShopFront : ShopFront
{
	[SerializeField]
	public float maxUseDistance = 1.5f;

	public override bool CanBeLooted(BasePlayer player)
	{
		if (WithinUseDistance(player))
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public bool WithinUseDistance(BasePlayer player)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Distance(player.eyes.position) <= maxUseDistance;
	}
}


using UnityEngine;

public class CamperSeatConfig : MonoBehaviour
{
	public Transform[] SeatPositions;

	public Transform StovePosition;

	public Transform StoragePosition;
}


using UnityEngine;

public abstract class VehicleModuleButtonComponent : MonoBehaviour
{
	public string interactionColliderName = "MyCollider";

	public SoundDefinition pressSoundDef;

	public abstract void ServerUse(BasePlayer player, BaseVehicleModule parentModule);
}


using System;
using Oxide.Core;
using Rust;
using Rust.Modular;
using UnityEngine;

public class VehicleModuleEngine : VehicleModuleStorage
{
	[Serializable]
	public class Engine
	{
		[Header("Engine Stats")]
		public int engineKW;

		public float idleFuelPerSec = 0.25f;

		public float maxFuelPerSec = 0.25f;

		[Header("Engine Audio")]
		public EngineAudioSet audioSet;

		[Header("Engine FX")]
		public ParticleSystemContainer[] engineParticles;

		public ParticleSystem[] exhaustSmoke;

		public ParticleSystem[] exhaustBackfire;

		public float exhaustSmokeMinOpacity = 0.1f;

		public float exhaustSmokeMaxOpacity = 0.7f;

		public float exhaustSmokeChangeRate = 0.5f;
	}

	[SerializeField]
	public Engine engine;

	private const float FORCE_MULTIPLIER = 12.75f;

	private const float HEALTH_PERFORMANCE_FRACTION = 0.25f;

	private const float LOW_PERFORMANCE_THRESHOLD = 0.5f;

	private Sound badPerformanceLoop;

	private SoundModulation.Modulator badPerformancePitchModulator;

	private float prevSmokePercent;

	private const float MIN_FORCE_BIAS = 0.0002f;

	private const float MAX_FORCE_BIAS = 0.7f;

	public override bool HasAnEngine => true;

	public bool IsUsable { get; set; }

	public float PerformanceFractionAcceleration { get; set; }

	public float PerformanceFractionTopSpeed { get; set; }

	public float PerformanceFractionFuelEconomy { get; set; }

	public float OverallPerformanceFraction { get; set; }

	public bool AtLowPerformance => OverallPerformanceFraction <= 0.5f;

	public bool AtPeakPerformance => Mathf.Approximately(OverallPerformanceFraction, 1f);

	public int KW => engine.engineKW;

	public EngineAudioSet AudioSet => engine.audioSet;

	private bool EngineIsOn
	{
		get
		{
			if ((Object)(object)base.Car != (Object)null)
			{
				return base.Car.CurEngineState == VehicleEngineController<GroundVehicle>.EngineState.On;
			}
			return false;
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		RefreshPerformanceStats(GetContainer() as EngineStorage);
	}

	public override void OnEngineStateChanged(VehicleEngineController<GroundVehicle>.EngineState oldState, VehicleEngineController<GroundVehicle>.EngineState newState)
	{
		base.OnEngineStateChanged(oldState, newState);
		RefreshPerformanceStats(GetContainer() as EngineStorage);
	}

	public override float GetMaxDriveForce()
	{
		if (!IsUsable)
		{
			return 0f;
		}
		return (float)engine.engineKW * 12.75f * PerformanceFractionTopSpeed;
	}

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", (object)this, (object)engineStorage) == null)
		{
			if ((Object)(object)engineStorage == (Object)null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", (object)this, (object)engineStorage);
		}
	}

	public float GetPerformanceFraction(float statBoostPercent)
	{
		if (!IsUsable)
		{
			return 0f;
		}
		float num = Mathf.Lerp(0f, 0.25f, base.healthFraction);
		float num2 = ((base.healthFraction != 0f) ? (statBoostPercent * 0.75f) : 0f);
		return num + num2;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		RefreshPerformanceStats(GetContainer() as EngineStorage);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		return true;
	}

	public override void VehicleFixedUpdate()
	{
		if (!isSpawned || !base.IsOnAVehicle)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("VehicleModuleEngine.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (base.Vehicle.IsMovingOrOn && !((Object)(object)base.Car == (Object)null) && base.Car.CurEngineState == VehicleEngineController<GroundVehicle>.EngineState.On && IsUsable)
			{
				float num = Mathf.Lerp(engine.idleFuelPerSec, engine.maxFuelPerSec, Mathf.Abs(base.Car.GetThrottleInput()));
				num /= PerformanceFractionFuelEconomy;
				base.Car.TickFuel(num);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float maxDriveForce = GetMaxDriveForce();
		float num = Mathf.Lerp(0.0002f, 0.7f, PerformanceFractionAcceleration);
		float num2 = MathEx.BiasedLerp(1f - absSpeed / topSpeed, num);
		return maxDriveForce * num2;
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		if (!IsTransferProtected() && info.damageTypes.GetMajorityDamageType() != DamageType.Decay)
		{
			float num = info.damageTypes.Total();
			EngineStorage engineStorage = GetContainer() as EngineStorage;
			if ((Object)(object)engineStorage != (Object)null && num > 0f)
			{
				engineStorage.OnModuleDamaged(num);
			}
		}
	}

	public override void OnHealthChanged(float oldValue, float newValue)
	{
		base.OnHealthChanged(oldValue, newValue);
		if (base.isServer)
		{
			RefreshPerformanceStats(GetContainer() as EngineStorage);
		}
	}

	public override bool AdminFixUp(int tier)
	{
		if (!base.AdminFixUp(tier))
		{
			return false;
		}
		EngineStorage engineStorage = GetContainer() as EngineStorage;
		engineStorage.AdminAddParts(tier);
		RefreshPerformanceStats(engineStorage);
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
public class Engine
{
	[Header("Engine Stats")]
	public int engineKW;

	public float idleFuelPerSec = 0.25f;

	public float maxFuelPerSec = 0.25f;

	[Header("Engine Audio")]
	public EngineAudioSet audioSet;

	[Header("Engine FX")]
	public ParticleSystemContainer[] engineParticles;

	public ParticleSystem[] exhaustSmoke;

	public ParticleSystem[] exhaustBackfire;

	public float exhaustSmokeMinOpacity = 0.1f;

	public float exhaustSmokeMaxOpacity = 0.7f;

	public float exhaustSmokeChangeRate = 0.5f;
}


using System;
using Rust;
using UnityEngine;

[RequireComponent(typeof(Collider))]
public class TakeCollisionDamage : FacepunchBehaviour
{
	public interface ICanRestoreVelocity
	{
		void RestoreVelocity(Vector3 amount);
	}

	[SerializeField]
	private BaseCombatEntity entity;

	[SerializeField]
	private float minDamage = 1f;

	[SerializeField]
	private float maxDamage = 250f;

	[SerializeField]
	private float forceForAnyDamage = 20000f;

	[SerializeField]
	private float forceForMaxDamage = 1000000f;

	[SerializeField]
	private float velocityRestorePercent = 0.75f;

	private float pendingDamage;

	private bool IsServer => entity.isServer;

	private bool IsClient => entity.isClient;

	protected void OnCollisionEnter(Collision collision)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		if (IsClient || collision == null || (Object)(object)collision.gameObject == (Object)null || (Object)(object)collision.gameObject == (Object)null)
		{
			return;
		}
		Rigidbody rigidbody = collision.rigidbody;
		float num = (((Object)(object)rigidbody == (Object)null) ? 100f : rigidbody.mass);
		Vector3 relativeVelocity = collision.relativeVelocity;
		float num2 = ((Vector3)(ref relativeVelocity)).magnitude * (entity.RealisticMass + num) / Time.fixedDeltaTime;
		float num3 = Mathf.InverseLerp(forceForAnyDamage, forceForMaxDamage, num2);
		if (num3 > 0f)
		{
			pendingDamage = Mathf.Max(pendingDamage, Mathf.Lerp(minDamage, maxDamage, num3));
			if (pendingDamage > entity.Health() && collision.gameObject.ToBaseEntity() is ICanRestoreVelocity canRestoreVelocity)
			{
				canRestoreVelocity.RestoreVelocity(collision.relativeVelocity * velocityRestorePercent);
			}
			((FacepunchBehaviour)this).Invoke((Action)DoDamage, 0f);
		}
	}

	protected void OnDestroy()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)DoDamage);
	}

	private void DoDamage()
	{
		if (!((Object)(object)entity == (Object)null) && !entity.IsDead() && !entity.IsDestroyed && pendingDamage > 0f)
		{
			entity.Hurt(pendingDamage, DamageType.Collision, null, useProtection: false);
			pendingDamage = 0f;
		}
	}
}


using UnityEngine;

public interface ICanRestoreVelocity
{
	void RestoreVelocity(Vector3 amount);
}


using System;
using UnityEngine;

public class VehicleLight : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class LightRenderer
	{
		public Renderer renderer;

		public int matIndex;
	}

	public bool IsBrake;

	public GameObject toggleObject;

	public LightRenderer[] renderers;

	[ColorUsage(true, true)]
	public Color lightOnColour;

	[ColorUsage(true, true)]
	public Color brakesOnColour;

	public bool applyToTransmittance;

	public bool useLightOnColourForBrake;
}


using System;
using UnityEngine;

[Serializable]
public class LightRenderer
{
	public Renderer renderer;

	public int matIndex;
}


using UnityEngine;

public class SimpleSplineTranslator
{
	private WorldSpline spline;

	private WorldSplineData splineData;

	private float currentDistance;

	private float speed;

	private bool loop;

	private Vector3 offset;

	private int direction;

	public int Direction;

	public float Speed => speed;

	public Vector3 Offset => offset;

	public float CurrentDistance => currentDistance;

	public bool Loop => loop;

	public SimpleSplineTranslator(WorldSpline spline, float speed, int direction = 1, bool loop = false)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		this.spline = spline;
		this.speed = speed;
		this.loop = loop;
		this.direction = direction;
		splineData = spline.GetData();
		offset = Vector3.zero;
		currentDistance = ((direction == 1) ? 0f : splineData.Length);
	}

	public SimpleSplineTranslator()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		spline = null;
		splineData = null;
		speed = 0f;
		loop = false;
		direction = 1;
		offset = Vector3.zero;
		currentDistance = 0f;
	}

	public void Update(float deltaTime)
	{
		if ((Object)(object)spline == (Object)null)
		{
			Debug.LogError((object)"Can't traverse over a null spline. Please set the spline data first.");
			return;
		}
		float delta = speed * deltaTime;
		currentDistance = CalculateNextDistance(currentDistance, delta, direction);
	}

	public Vector3 PeekNextPosition(float delta = 0.1f, int dir = 1, bool getLocal = false)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)spline == (Object)null)
		{
			Debug.LogError((object)"Can't traverse over a null spline. Please set the spline data first.");
			return Vector3.zero;
		}
		float distance = CalculateNextDistance(currentDistance, delta, dir);
		Vector3 positionAtDistance = GetPositionAtDistance(distance, out var _);
		positionAtDistance += offset;
		if (!getLocal)
		{
			positionAtDistance = ((Component)spline).transform.TransformPoint(positionAtDistance);
		}
		return positionAtDistance;
	}

	public Vector3 PeekNextPositionFollowingDirection(float delta = 0.1f, bool getLocal = false)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return PeekNextPosition(delta, direction, getLocal);
	}

	public void GetCurrentPositionAndTangent(out Vector3 position, out Vector3 tangent, bool getLocal = false)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)spline == (Object)null)
		{
			Debug.LogError((object)"Can't traverse over a null spline. Please set the spline data first.");
			position = Vector3.zero;
			tangent = Vector3.zero;
			return;
		}
		position = GetPositionAtDistance(currentDistance, out tangent);
		position += offset;
		if (!getLocal)
		{
			position = ((Component)spline).transform.TransformPoint(position);
		}
	}

	private float CalculateNextDistance(float currentDistance, float delta, float dir)
	{
		float num = currentDistance + delta * dir;
		if (loop)
		{
			return num % splineData.Length;
		}
		return Mathf.Clamp(num, 0f, splineData.Length);
	}

	public float GetEnd()
	{
		if (direction == 1)
		{
			return splineData.Length;
		}
		return 0f;
	}

	public float GetStart()
	{
		if (direction == -1)
		{
			return splineData.Length;
		}
		return 0f;
	}

	public Vector3 GetPositionAtDistance(float distance, out Vector3 tangent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return splineData.GetPointAndTangentCubicHermite(distance, out tangent);
	}

	public SimpleSplineTranslator SetSpeed(float newSpeed)
	{
		speed = newSpeed;
		return this;
	}

	public SimpleSplineTranslator SetOffset(Vector3 offset)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		this.offset = offset;
		return this;
	}

	public SimpleSplineTranslator SetCurrentDistance(float distance)
	{
		currentDistance = Mathf.Clamp(distance, 0f, splineData.Length);
		return this;
	}

	public SimpleSplineTranslator CalculateStartingDistance()
	{
		currentDistance = GetStart();
		return this;
	}

	public SimpleSplineTranslator Reset()
	{
		currentDistance = 0f;
		return this;
	}

	public SimpleSplineTranslator SetSpline(WorldSpline spline)
	{
		this.spline = spline;
		splineData = spline.GetData();
		return this;
	}

	public SimpleSplineTranslator SetDirection(int direction)
	{
		this.direction = direction;
		return this;
	}

	public float GetCurrentDistance()
	{
		return currentDistance;
	}
}


public static class SimpleVehicleVisuals
{
}


using System;
using UnityEngine;

[Serializable]
public class SimpleCarVisualsController
{
	public enum RotationAxis
	{
		X,
		Z,
		Y
	}

	[Header("Simple Visuals Settings")]
	public float wheelLerpSpeed = 5f;

	public float wheelAngleMaximum = 40f;

	public float timeSinceLastUpdateMinimum = 0.5f;

	[Tooltip("Should the wheels be rotated on the Y axis?")]
	public RotationAxis rotateAxis = RotationAxis.Z;

	public RotationAxis steerAxis;

	public TimeSince timeSinceUpdated;

	public void Updated()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		timeSinceUpdated = TimeSince.op_Implicit(0f);
	}
}


public enum RotationAxis
{
	X,
	Z,
	Y
}


using UnityEngine;

public class MouseSteerableSeat : BaseVehicleSeat
{
	[SerializeField]
	private bool supportsMouseSteer;

	public const BUTTON MouseSteerButton = BUTTON.FIRE_THIRD;
}


using UnityEngine;

public class SnowmobileAudio : GroundVehicleAudio
{
	[SerializeField]
	[Header("Engine")]
	private EngineAudioSet engineAudioSet;

	[SerializeField]
	[Header("Skis")]
	private AnimationCurve skiGainCurve;

	[SerializeField]
	private SoundDefinition skiSlideSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideSnowSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideSandSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideGrassSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideWaterSoundDef;

	[Header("Movement")]
	[SerializeField]
	private AnimationCurve movementGainCurve;

	[SerializeField]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private SoundDefinition suspensionLurchSoundDef;

	[SerializeField]
	private float suspensionLurchMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionLurchMinTimeBetweenSounds = 0.25f;
}


using System;
using UnityEngine;

public class SnowmobileChassisVisuals : VehicleChassisVisuals<Snowmobile>, IClientComponent
{
	[Serializable]
	private class TreadRenderer
	{
		public Renderer renderer;

		public int materialIndex;
	}

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private SnowmobileAudio audioScript;

	[SerializeField]
	private TreadRenderer[] treadRenderers;

	[SerializeField]
	private float treadSpeedMultiplier = 0.01f;

	[SerializeField]
	private bool flipRightSkiExtension;

	[SerializeField]
	private Transform leftSki;

	[SerializeField]
	private Transform leftSkiPistonIn;

	[SerializeField]
	private Transform leftSkiPistonOut;

	[SerializeField]
	private Transform rightSki;

	[SerializeField]
	private Transform rightSkiPistonIn;

	[SerializeField]
	private Transform rightSkiPistonOut;

	[SerializeField]
	private float skiVisualAdjust;

	[SerializeField]
	private float treadVisualAdjust;

	[SerializeField]
	private float skiVisualMaxExtension;

	[SerializeField]
	private float treadVisualMaxExtension;

	[SerializeField]
	private float wheelSizeVisualMultiplier = 1f;
}


using System;
using UnityEngine;

[Serializable]
private class TreadRenderer
{
	public Renderer renderer;

	public int materialIndex;
}


using UnityEngine;

public class SoccerBall : BaseCombatEntity
{
	[Header("Soccer Ball")]
	[SerializeField]
	private Rigidbody rigidBody;

	[SerializeField]
	private float additionalForceMultiplier = 0.2f;

	[SerializeField]
	private float upForceMultiplier = 0.15f;

	[SerializeField]
	private DamageRenderer damageRenderer;

	[SerializeField]
	private float explosionForceMultiplier = 40f;

	[SerializeField]
	private float otherForceMultiplier = 10f;

	protected void OnCollisionEnter(Collision collision)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient)
		{
			Vector3 impulse = collision.impulse;
			if (((Vector3)(ref impulse)).magnitude > 0f && (Object)(object)collision.collider.attachedRigidbody != (Object)null && !((Component)(object)collision.collider.attachedRigidbody).HasComponent<SoccerBall>())
			{
				Vector3 val = rigidBody.position - collision.collider.attachedRigidbody.position;
				impulse = collision.impulse;
				float magnitude = ((Vector3)(ref impulse)).magnitude;
				rigidBody.AddForce(val * magnitude * additionalForceMultiplier + Vector3.up * magnitude * upForceMultiplier, (ForceMode)1);
			}
		}
	}

	public override void Hurt(HitInfo info)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		float num = 0f;
		float[] types = info.damageTypes.types;
		foreach (float num2 in types)
		{
			num = (((int)num2 != 16 && (int)num2 != 22) ? (num + num2 * otherForceMultiplier) : (num + num2 * explosionForceMultiplier));
		}
		if (num > 3f)
		{
			if (info.attackNormal != Vector3.zero)
			{
				rigidBody.AddForce(info.attackNormal * num, (ForceMode)1);
			}
			else
			{
				rigidBody.AddExplosionForce(num * 5f, info.HitPositionWorld, 0.25f, 0.25f);
			}
		}
		base.Hurt(info);
	}
}


using System.Collections.Generic;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class EntityFuelSystem : IFuelSystem
{
	public readonly bool isServer;

	private readonly bool editorGiveFreeFuel;

	private readonly uint fuelStorageID;

	public EntityRef<StorageContainer> fuelStorageInstance;

	public float nextFuelCheckTime;

	public bool cachedHasFuel;

	public float pendingFuel;

	public EntityFuelSystem(bool isServer, GameObjectRef fuelStoragePrefab, List<BaseEntity> children, bool editorGiveFreeFuel = true)
	{
		this.isServer = isServer;
		this.editorGiveFreeFuel = editorGiveFreeFuel;
		fuelStorageID = fuelStoragePrefab.GetEntity().prefabID;
		if (!isServer)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			CheckNewChild(child);
		}
	}

	public bool HasValidInstance(bool isServer)
	{
		return fuelStorageInstance.IsValid(isServer);
	}

	public NetworkableId GetInstanceID()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return fuelStorageInstance.uid;
	}

	public void SetInstanceID(NetworkableId uid)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		fuelStorageInstance.uid = uid;
	}

	public bool IsInFuelInteractionRange(BasePlayer player)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanCheckFuel", (object)this, (object)fuelContainer, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)fuelContainer != (Object)null)
		{
			float num = 0f;
			if (isServer)
			{
				num = 3f;
			}
			return fuelContainer.Distance(player.eyes.position) <= num;
		}
		return false;
	}

	public StorageContainer GetFuelContainer()
	{
		StorageContainer storageContainer = fuelStorageInstance.Get(isServer);
		if (storageContainer.IsValid())
		{
			return storageContainer;
		}
		return null;
	}

	public bool CheckNewChild(BaseEntity child)
	{
		if (child.prefabID == fuelStorageID)
		{
			if (child is StorageContainer storageContainer)
			{
				fuelStorageInstance.Set(storageContainer);
				storageContainer.inventory.onItemAddedRemoved = OnFuelAddedRemoved;
			}
			return true;
		}
		return false;
	}

	private void OnFuelAddedRemoved(Item arg1, bool arg2)
	{
		nextFuelCheckTime = 0f;
	}

	public Item GetFuelItem()
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("OnFuelItemCheck", (object)this, (object)fuelContainer);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if ((Object)(object)fuelContainer == (Object)null)
		{
			return null;
		}
		return fuelContainer.inventory.GetSlot(0);
	}

	public int GetFuelAmount()
	{
		Item fuelItem = GetFuelItem();
		object obj = Interface.CallHook("OnFuelAmountCheck", (object)this, (object)fuelItem);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelItem == null || fuelItem.amount < 1)
		{
			return 0;
		}
		return fuelItem.amount;
	}

	public float GetFuelFraction()
	{
		Item fuelItem = GetFuelItem();
		if (fuelItem == null || fuelItem.amount < 1)
		{
			return 0f;
		}
		return Mathf.Clamp01((float)fuelItem.amount / (float)fuelItem.MaxStackable());
	}

	public bool HasFuel(bool forceCheck = false)
	{
		if (Time.time > nextFuelCheckTime || forceCheck)
		{
			object obj = Interface.CallHook("OnFuelCheck", (object)this);
			if (obj is bool)
			{
				return (bool)obj;
			}
			cachedHasFuel = (float)GetFuelAmount() > 0f;
			nextFuelCheckTime = Time.time + Random.Range(1f, 2f);
		}
		return cachedHasFuel;
	}

	public int TryUseFuel(float seconds, float fuelUsedPerSecond)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanUseFuel", (object)this, (object)fuelContainer, (object)seconds, (object)fuelUsedPerSecond);
		if (obj is int)
		{
			return (int)obj;
		}
		if ((Object)(object)fuelContainer == (Object)null)
		{
			return 0;
		}
		Item slot = fuelContainer.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		pendingFuel += seconds * fuelUsedPerSecond;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, num, "fuel_system");
			pendingFuel -= num;
			return num;
		}
		return 0;
	}

	public void LootFuel(BasePlayer player)
	{
		if (IsInFuelInteractionRange(player))
		{
			GetFuelContainer().PlayerOpenLoot(player);
		}
	}

	public void AddFuel(int amount)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		if ((Object)(object)fuelContainer != (Object)null)
		{
			fuelContainer.inventory.AddItem(GetFuelContainer().allowedItem, Mathf.FloorToInt((float)amount), 0uL);
		}
	}

	public void RemoveFuel(int amount)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		if ((Object)(object)fuelContainer != (Object)null)
		{
			Item slot = fuelContainer.inventory.GetSlot(0);
			slot.UseItem(amount);
			Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, amount, "fuel_system");
		}
	}

	public void FillFuel()
	{
		StorageContainer fuelContainer = GetFuelContainer();
		if ((Object)(object)fuelContainer != (Object)null)
		{
			fuelContainer.inventory.AddItem(GetFuelContainer().allowedItem, GetFuelContainer().allowedItem.stackable, 0uL);
		}
	}

	public int GetFuelCapacity()
	{
		return GetFuelContainer().allowedItem.stackable;
	}
}


using UnityEngine;

public class SubmarineAudio : MonoBehaviour
{
	[Header("Engine")]
	[SerializeField]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineStartFailSound;

	[SerializeField]
	private SoundDefinition engineLoopSound;

	[SerializeField]
	private AnimationCurve engineLoopPitchCurve;

	[SerializeField]
	[Header("Water")]
	private SoundDefinition underwaterLoopDef;

	[SerializeField]
	private SoundDefinition underwaterMovementLoopDef;

	[SerializeField]
	private BlendedSoundLoops surfaceWaterLoops;

	[SerializeField]
	private float surfaceWaterSoundsMaxSpeed = 5f;

	[SerializeField]
	private SoundDefinition waterEmergeSoundDef;

	[SerializeField]
	private SoundDefinition waterSubmergeSoundDef;

	[Header("Interior")]
	[SerializeField]
	private SoundDefinition activeLoopDef;

	[SerializeField]
	private SoundDefinition footPedalSoundDef;

	[SerializeField]
	private Transform footPedalSoundPos;

	[SerializeField]
	private SoundDefinition steeringWheelSoundDef;

	[SerializeField]
	private Transform steeringWheelSoundPos;

	[SerializeField]
	private SoundDefinition heavyDamageSparksDef;

	[SerializeField]
	private Transform heavyDamageSparksPos;

	[SerializeField]
	private SoundDefinition flagRaise;

	[SerializeField]
	private SoundDefinition flagLower;

	[SerializeField]
	private GameObject dashboardAudioPoint;

	[Header("Other")]
	[SerializeField]
	private SoundDefinition climbOrDiveLoopSound;

	[SerializeField]
	private SoundDefinition torpedoFailedSound;
}


using Sonar;
using UnityEngine;

public class SubmarineDuo : BaseSubmarine
{
	[Header("Duo Sub Seating & Controls")]
	[SerializeField]
	private Transform steeringWheel;

	[SerializeField]
	private Transform steeringWheelLeftGrip;

	[SerializeField]
	private Transform steeringWheelRightGrip;

	[SerializeField]
	private Transform leftPedal;

	[SerializeField]
	private Transform rightPedal;

	[SerializeField]
	private Transform driverLeftFoot;

	[SerializeField]
	private Transform driverRightFoot;

	[SerializeField]
	private Transform mphNeedle;

	[SerializeField]
	private Transform fuelNeedle;

	[SerializeField]
	private Transform waterDepthNeedle;

	[SerializeField]
	private Transform ammoFlag;

	[SerializeField]
	private SonarSystem sonar;

	[SerializeField]
	private Transform torpedoTubeHatch;
}


using System;
using UnityEngine;

public class TowConfig : PrefabAttribute
{
	[Serializable]
	public struct Configuration
	{
		public Vector2 AngularLimitsX;

		public float AngularLimitY;

		public float AngularLimitZ;
	}

	private static readonly Configuration DefaultConfig = new Configuration
	{
		AngularLimitsX = new Vector2(-80f, 80f),
		AngularLimitY = 60f,
		AngularLimitZ = 55f
	};

	public Configuration Config = DefaultConfig;

	protected override Type GetIndexedType()
	{
		return typeof(TowConfig);
	}

	public Configuration Combine(TowConfig other)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Configuration result = default(Configuration);
		Configuration config = other.Config;
		result.AngularLimitsX = new Vector2(Mathf.Max(Config.AngularLimitsX.x, config.AngularLimitsX.x), Mathf.Min(Config.AngularLimitsX.y, config.AngularLimitsX.y));
		result.AngularLimitY = Mathf.Min(Config.AngularLimitY, config.AngularLimitY);
		result.AngularLimitZ = Mathf.Min(Config.AngularLimitZ, config.AngularLimitZ);
		return result;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Configuration
{
	public Vector2 AngularLimitsX;

	public float AngularLimitY;

	public float AngularLimitZ;
}


using UnityEngine;

public interface ITowing
{
	bool IsTowing { get; }

	bool IsTowingAllowed { get; }

	BaseEntity TowEntity { get; }

	Transform TowAnchor { get; }

	Rigidbody TowBody { get; }

	void OnTowAttach();

	void OnTowDetach();
}


public abstract class TowingAttachment
{
	public const BaseEntity.Flags Flag_IsTowing = BaseEntity.Flags.Reserved14;
}


using ConVar;
using UnityEngine;

public class TowingAttachment<TEntity> : TowingAttachment where TEntity : BaseEntity, ITowing
{
	private readonly TEntity _entity;

	private readonly TowConfig _towingConfig;

	private ConfigurableJoint _towingJoint;

	private EntityRef<BaseEntity> _otherEntity;

	private float _lastBreakingForce;

	private float _idealBreakingForce;

	public TowingAttachment(TEntity entity)
	{
		_entity = entity;
		_towingConfig = PrefabAttribute.server.Find<TowConfig>(_entity.prefabID);
	}

	public void FixedUpdate()
	{
		BaseEntity baseEntity = _otherEntity.Get(serverside: true);
		if (_entity.IsTowing && (!baseEntity.IsValid() || baseEntity.IsDestroyed || (Object)(object)_towingJoint == (Object)null))
		{
			Detach();
		}
		if (_entity.IsTowing)
		{
			MoveToNormalBreakForce();
		}
	}

	public void AttachTo<TTowableEntity>(TTowableEntity other) where TTowableEntity : ITowing
	{
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		if (_entity.IsTowing)
		{
			Detach();
		}
		if ((Object)(object)_towingJoint != (Object)null)
		{
			Object.Destroy((Object)(object)_towingJoint);
		}
		Rigidbody towBody = other.TowBody;
		BaseEntity towEntity = other.TowEntity;
		TowConfig towConfig = PrefabAttribute.server.Find<TowConfig>(towEntity.prefabID);
		if (towConfig == null)
		{
			Debug.LogError((object)"Attaching to towable without TowConfig", (Object)(object)towEntity);
			return;
		}
		TowConfig.Configuration configuration = _towingConfig.Combine(towConfig);
		_towingJoint = ((Component)_entity.TowBody).gameObject.AddComponent<ConfigurableJoint>();
		((Joint)_towingJoint).connectedBody = towBody;
		Matrix4x4 worldToLocalMatrix = ((Component)_entity.TowBody).transform.worldToLocalMatrix;
		((Joint)_towingJoint).autoConfigureConnectedAnchor = false;
		((Joint)_towingJoint).anchor = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(_entity.TowAnchor.position);
		ConfigurableJoint towingJoint = _towingJoint;
		Vector3 val = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyVector(((Component)towBody).transform.right);
		((Joint)towingJoint).axis = ((Vector3)(ref val)).normalized;
		ConfigurableJoint towingJoint2 = _towingJoint;
		val = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyVector(((Component)towBody).transform.up);
		towingJoint2.secondaryAxis = ((Vector3)(ref val)).normalized;
		_towingJoint.swapBodies = false;
		Matrix4x4 worldToLocalMatrix2 = ((Component)towBody).transform.worldToLocalMatrix;
		((Joint)_towingJoint).connectedAnchor = ((Matrix4x4)(ref worldToLocalMatrix2)).MultiplyPoint3x4(other.TowAnchor.position);
		_towingJoint.xMotion = (ConfigurableJointMotion)1;
		_towingJoint.yMotion = (ConfigurableJointMotion)1;
		_towingJoint.zMotion = (ConfigurableJointMotion)1;
		ConfigurableJoint towingJoint3 = _towingJoint;
		SoftJointLimitSpring linearLimitSpring = default(SoftJointLimitSpring);
		((SoftJointLimitSpring)(ref linearLimitSpring)).spring = 100000f;
		((SoftJointLimitSpring)(ref linearLimitSpring)).damper = 100f;
		towingJoint3.linearLimitSpring = linearLimitSpring;
		ConfigurableJoint towingJoint4 = _towingJoint;
		SoftJointLimit val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = 0.2f;
		towingJoint4.linearLimit = val2;
		((Joint)_towingJoint).enableCollision = true;
		_towingJoint.angularXMotion = (ConfigurableJointMotion)1;
		_towingJoint.angularYMotion = (ConfigurableJointMotion)1;
		_towingJoint.angularZMotion = (ConfigurableJointMotion)1;
		ConfigurableJoint towingJoint5 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitsX.x;
		towingJoint5.lowAngularXLimit = val2;
		ConfigurableJoint towingJoint6 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitsX.y;
		towingJoint6.highAngularXLimit = val2;
		ConfigurableJoint towingJoint7 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitY;
		towingJoint7.angularYLimit = val2;
		ConfigurableJoint towingJoint8 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitZ;
		towingJoint8.angularZLimit = val2;
		_towingJoint.targetRotation = Quaternion.identity;
		_towingJoint.projectionMode = (JointProjectionMode)1;
		((Joint)_towingJoint).breakForce = 1E+20f;
		_lastBreakingForce = ((Joint)_towingJoint).breakForce;
		float num = Mathf.Min(_entity.TowBody.isKinematic ? 10000f : _entity.TowBody.mass, towBody.isKinematic ? 10000f : towBody.mass);
		_idealBreakingForce = num * Physics.towingmaxlinearaccelfromjoint;
		_otherEntity.Set(towEntity);
		_entity.SetFlag(BaseEntity.Flags.Reserved14, b: true);
		towEntity.SetFlag(BaseEntity.Flags.Reserved14, b: true);
		_entity.OnTowAttach();
		other.OnTowAttach();
	}

	public void Detach()
	{
		if ((Object)(object)_towingJoint != (Object)null)
		{
			Object.Destroy((Object)(object)_towingJoint);
		}
		_entity.SetFlag(BaseEntity.Flags.Reserved14, b: false);
		BaseEntity baseEntity = _otherEntity.Get(serverside: true);
		bool num = (Object)(object)baseEntity == (Object)null;
		if (!num)
		{
			baseEntity.SetFlag(BaseEntity.Flags.Reserved14, b: false);
		}
		_otherEntity = default(EntityRef<BaseEntity>);
		_entity.OnTowDetach();
		if (!num && baseEntity is ITowing towing)
		{
			towing.OnTowDetach();
		}
	}

	private void MoveToNormalBreakForce()
	{
		if (Mathf.Approximately(_lastBreakingForce, _idealBreakingForce))
		{
			if (!_towingJoint.swapBodies)
			{
				_towingJoint.swapBodies = true;
			}
		}
		else
		{
			float num = Mathf.Lerp(((Joint)_towingJoint).breakForce, _idealBreakingForce, Time.fixedDeltaTime * 10f);
			((Joint)_towingJoint).breakForce = num;
			_lastBreakingForce = num;
		}
	}
}


public class TowingJointBreakDebug : FacepunchBehaviour
{
}


using UnityEngine;

public class TowingVisuals : FacepunchBehaviour, IClientComponent
{
	public GameObject visualPrefab;

	public Transform centralAnchor;

	public Transform[] visualAnchors;

	public Transform[] leadPoints;

	public TransformLineRenderer transformLineRenderer;
}


using UnityEngine;

public class TriggerEntityType<TEntity> : TriggerBase where TEntity : BaseEntity
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!(baseEntity is TEntity))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


public class TriggerTowing : TriggerEntityType<BaseSiegeWeapon>
{
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class CompleteTrain : IDisposable
{
	private enum ShuntState
	{
		None,
		Forwards,
		Backwards
	}

	public enum StaticCollisionState
	{
		Free,
		StaticColliding,
		StayingStill
	}

	private Vector3 unloaderPos;

	public float trackSpeed;

	private float prevTrackSpeed;

	public List<TrainCar> trainCars;

	public TriggerTrainCollisions frontCollisionTrigger;

	public TriggerTrainCollisions rearCollisionTrigger;

	public bool ranUpdateTick;

	public bool disposed;

	public const float IMPACT_ENERGY_FRACTION = 0.75f;

	public const float MIN_COLLISION_FORCE = 70000f;

	public float lastMovingTime = float.MinValue;

	public const float SLEEP_SPEED = 0.1f;

	public const float SLEEP_DELAY = 10f;

	public TimeSince timeSinceLastChange;

	private bool isShunting;

	private TimeSince timeSinceShuntStart;

	private const float MAX_SHUNT_TIME = 20f;

	private const float SHUNT_SPEED = 4f;

	private const float SHUNT_SPEED_CHANGE_RATE = 10f;

	private Action<CoalingTower.ActionAttemptStatus> shuntEndCallback;

	private float shuntDistance;

	private Vector3 shuntDirection;

	private Vector2 shuntStartPos2D = Vector2.zero;

	private Vector2 shuntTargetPos2D = Vector2.zero;

	private TrainCar shuntTarget;

	public StaticCollisionState staticCollidingAtFront;

	private HashSet<GameObject> monitoredStaticContentF = new HashSet<GameObject>();

	public StaticCollisionState staticCollidingAtRear;

	private HashSet<GameObject> monitoredStaticContentR = new HashSet<GameObject>();

	public Dictionary<Rigidbody, float> prevTrackSpeeds = new Dictionary<Rigidbody, float>();

	public TrainCar PrimaryTrainCar { get; set; }

	public bool TrainIsReversing => (Object)(object)PrimaryTrainCar != (Object)(object)trainCars[0];

	public float TotalForces { get; set; }

	public float TotalMass { get; set; }

	public int NumTrainCars => trainCars.Count;

	public int LinedUpToUnload { get; private set; } = -1;

	public bool IsLinedUpToUnload => LinedUpToUnload >= 0;

	public CompleteTrain(TrainCar trainCar)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		List<TrainCar> list = Pool.Get<List<TrainCar>>();
		list.Add(trainCar);
		Init(list);
	}

	public CompleteTrain(List<TrainCar> allTrainCars)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Init(allTrainCars);
	}

	private void Init(List<TrainCar> allTrainCars)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		trainCars = allTrainCars;
		timeSinceLastChange = TimeSince.op_Implicit(0f);
		lastMovingTime = Time.time;
		float num = 0f;
		PrimaryTrainCar = trainCars[0];
		for (int i = 0; i < trainCars.Count; i++)
		{
			TrainCar trainCar = trainCars[i];
			if (trainCar.completeTrain != null)
			{
				trainCar.savedTrackSpeed = trainCar.GetTrackSpeed();
			}
		}
		for (int j = 0; j < trainCars.Count; j++)
		{
			TrainCar trainCar2 = trainCars[j];
			if (trainCar2.completeTrain != this)
			{
				trainCar2.SetNewCompleteTrain(this);
				num = ((!trainCar2.IsCoupledBackwards()) ? (num + trainCar2.savedTrackSpeed) : (num - trainCar2.savedTrackSpeed));
			}
		}
		num = (trackSpeed = num / (float)trainCars.Count);
		prevTrackSpeed = trackSpeed;
		ParamsTick();
	}

	~CompleteTrain()
	{
		Cleanup();
	}

	public void Dispose()
	{
		Cleanup();
		System.GC.SuppressFinalize(this);
	}

	private void Cleanup()
	{
		if (!disposed)
		{
			EndShunting(CoalingTower.ActionAttemptStatus.GenericError);
			disposed = true;
			Pool.FreeUnmanaged<TrainCar>(ref trainCars);
		}
	}

	public void RemoveTrainCar(TrainCar trainCar)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		if (disposed)
		{
			return;
		}
		if (trainCars.Count <= 1)
		{
			Debug.LogWarning((object)(GetType().Name + ": Can't remove car from CompleteTrain of length one."));
			return;
		}
		int num = IndexOf(trainCar);
		bool flag = ((num != 0) ? trainCars[0].IsCoupledBackwards() : trainCars[1].IsCoupledBackwards());
		trainCars.RemoveAt(num);
		timeSinceLastChange = TimeSince.op_Implicit(0f);
		LinedUpToUnload = -1;
		if (trainCars[0].IsCoupledBackwards() != flag)
		{
			trackSpeed *= -1f;
		}
	}

	public float GetTrackSpeedFor(TrainCar trainCar)
	{
		if (disposed)
		{
			return 0f;
		}
		if (trainCars.IndexOf(trainCar) < 0)
		{
			Debug.LogError((object)(GetType().Name + ": Train car not found in the trainCars list."));
			return 0f;
		}
		if (trainCar.IsCoupledBackwards())
		{
			return 0f - trackSpeed;
		}
		return trackSpeed;
	}

	public float GetPrevTrackSpeedFor(TrainCar trainCar)
	{
		if (trainCars.IndexOf(trainCar) < 0)
		{
			Debug.LogError((object)(GetType().Name + ": Train car not found in the trainCars list."));
			return 0f;
		}
		if (trainCar.IsCoupledBackwards())
		{
			return 0f - prevTrackSpeed;
		}
		return prevTrackSpeed;
	}

	public void UpdateTick(float dt)
	{
		if (ranUpdateTick || disposed)
		{
			return;
		}
		ranUpdateTick = true;
		if (IsAllAsleep() && !HasAnyEnginesOn() && !HasAnyCollisions() && !isShunting)
		{
			trackSpeed = 0f;
			return;
		}
		ParamsTick();
		MovementTick(dt);
		LinedUpToUnload = CheckLinedUpToUnload(out unloaderPos);
		if (!disposed)
		{
			if (Mathf.Abs(trackSpeed) > 0.1f)
			{
				lastMovingTime = Time.time;
			}
			if (!HasAnyEnginesOn() && !HasAnyCollisions() && Time.time > lastMovingTime + 10f)
			{
				trackSpeed = 0f;
				SleepAll();
			}
		}
	}

	public bool IncludesAnEngine()
	{
		if (disposed)
		{
			return false;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.CarType == TrainCar.TrainCarType.Engine)
			{
				return true;
			}
		}
		return false;
	}

	protected bool HasAnyCollisions()
	{
		if (!frontCollisionTrigger.HasAnyContents)
		{
			return rearCollisionTrigger.HasAnyContents;
		}
		return true;
	}

	private bool HasAnyEnginesOn()
	{
		if (disposed)
		{
			return false;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.CarType == TrainCar.TrainCarType.Engine && trainCar.IsOn())
			{
				return true;
			}
		}
		return false;
	}

	private bool IsAllAsleep()
	{
		if (disposed)
		{
			return true;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (!trainCar.rigidBody.IsSleeping())
			{
				return false;
			}
		}
		return true;
	}

	private void SleepAll()
	{
		if (disposed)
		{
			return;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			trainCar.rigidBody.Sleep();
		}
	}

	public bool TryShuntCarTo(Vector3 shuntDirection, float shuntDistance, TrainCar shuntTarget, Action<CoalingTower.ActionAttemptStatus> shuntEndCallback, out CoalingTower.ActionAttemptStatus status)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (disposed)
		{
			status = CoalingTower.ActionAttemptStatus.NoTrainCar;
			return false;
		}
		if (isShunting)
		{
			status = CoalingTower.ActionAttemptStatus.AlreadyShunting;
			return false;
		}
		if (Mathf.Abs(trackSpeed) > 0.1f)
		{
			status = CoalingTower.ActionAttemptStatus.TrainIsMoving;
			return false;
		}
		if (HasThrottleInput())
		{
			status = CoalingTower.ActionAttemptStatus.TrainHasThrottle;
			return false;
		}
		this.shuntDirection = shuntDirection;
		this.shuntDistance = shuntDistance;
		this.shuntTarget = shuntTarget;
		timeSinceShuntStart = TimeSince.op_Implicit(0f);
		shuntStartPos2D.x = ((Component)shuntTarget).transform.position.x;
		shuntStartPos2D.y = ((Component)shuntTarget).transform.position.z;
		isShunting = true;
		this.shuntEndCallback = shuntEndCallback;
		status = CoalingTower.ActionAttemptStatus.NoError;
		return true;
	}

	private void EndShunting(CoalingTower.ActionAttemptStatus status)
	{
		isShunting = false;
		if (shuntEndCallback != null)
		{
			shuntEndCallback(status);
			shuntEndCallback = null;
		}
		shuntTarget = null;
	}

	public bool ContainsOnly(TrainCar trainCar)
	{
		if (disposed)
		{
			return false;
		}
		if (trainCars.Count == 1)
		{
			return (Object)(object)trainCars[0] == (Object)(object)trainCar;
		}
		return false;
	}

	public int IndexOf(TrainCar trainCar)
	{
		if (disposed)
		{
			return -1;
		}
		return trainCars.IndexOf(trainCar);
	}

	public bool TryGetAdjacentTrainCar(TrainCar trainCar, bool next, Vector3 forwardDir, out TrainCar result)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		int num = trainCars.IndexOf(trainCar);
		Vector3 val = ((!trainCars[num].IsCoupledBackwards()) ? ((Component)trainCar).transform.forward : (-((Component)trainCar).transform.forward));
		if (Vector3.Dot(val, forwardDir) < 0f)
		{
			next = !next;
		}
		if (num >= 0)
		{
			num = ((!next) ? (num - 1) : (num + 1));
			if (num >= 0 && num < trainCars.Count)
			{
				result = trainCars[num];
				return true;
			}
		}
		result = null;
		return false;
	}

	private void ParamsTick()
	{
		TotalForces = 0f;
		TotalMass = 0f;
		int num = 0;
		float num2 = 0f;
		for (int i = 0; i < trainCars.Count; i++)
		{
			TrainCar trainCar = trainCars[i];
			if (trainCar.rigidBody.mass > num2)
			{
				num2 = trainCar.rigidBody.mass;
				num = i;
			}
		}
		bool flag = false;
		for (int j = 0; j < trainCars.Count; j++)
		{
			TrainCar trainCar2 = trainCars[j];
			float forces = trainCar2.GetForces();
			TotalForces += (trainCar2.IsCoupledBackwards() ? (0f - forces) : forces);
			flag |= trainCar2.HasThrottleInput();
			if (j == num)
			{
				TotalMass += trainCar2.rigidBody.mass;
			}
			else
			{
				TotalMass += trainCar2.rigidBody.mass * 0.4f;
			}
		}
		if (isShunting && flag)
		{
			EndShunting(CoalingTower.ActionAttemptStatus.TrainHasThrottle);
		}
		if (trainCars.Count == 1)
		{
			frontCollisionTrigger = trainCars[0].FrontCollisionTrigger;
			rearCollisionTrigger = trainCars[0].RearCollisionTrigger;
		}
		else
		{
			frontCollisionTrigger = (trainCars[0].coupling.IsRearCoupled ? trainCars[0].FrontCollisionTrigger : trainCars[0].RearCollisionTrigger);
			rearCollisionTrigger = (trainCars[trainCars.Count - 1].coupling.IsRearCoupled ? trainCars[trainCars.Count - 1].FrontCollisionTrigger : trainCars[trainCars.Count - 1].RearCollisionTrigger);
		}
	}

	private void MovementTick(float dt)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		prevTrackSpeed = trackSpeed;
		if (!isShunting)
		{
			trackSpeed += TotalForces * dt / TotalMass;
		}
		else
		{
			bool flag = Vector3.Dot(shuntDirection, ((Component)PrimaryTrainCar).transform.forward) >= 0f;
			if (PrimaryTrainCar.IsCoupledBackwards())
			{
				flag = !flag;
			}
			if ((Object)(object)shuntTarget == (Object)null || shuntTarget.IsDead() || shuntTarget.IsDestroyed)
			{
				EndShunting(CoalingTower.ActionAttemptStatus.NoTrainCar);
			}
			else
			{
				float num = 4f;
				shuntTargetPos2D.x = ((Component)shuntTarget).transform.position.x;
				shuntTargetPos2D.y = ((Component)shuntTarget).transform.position.z;
				float num2 = shuntDistance - Vector3.Distance(Vector2.op_Implicit(shuntStartPos2D), Vector2.op_Implicit(shuntTargetPos2D));
				if (num2 < 2f)
				{
					float num3 = Mathf.InverseLerp(0f, 2f, num2);
					num *= Mathf.Lerp(0.1f, 1f, num3);
				}
				trackSpeed = Mathf.MoveTowards(trackSpeed, flag ? num : (0f - num), dt * 10f);
				if (TimeSince.op_Implicit(timeSinceShuntStart) > 20f || num2 <= 0f)
				{
					EndShunting(CoalingTower.ActionAttemptStatus.NoError);
					trackSpeed = 0f;
				}
			}
		}
		float num4 = trainCars[0].rigidBody.drag;
		if (IsLinedUpToUnload)
		{
			float num5 = Mathf.Abs(trackSpeed);
			if (num5 > 1f)
			{
				TrainCarUnloadable trainCarUnloadable = trainCars[LinedUpToUnload] as TrainCarUnloadable;
				if ((Object)(object)trainCarUnloadable != (Object)null)
				{
					float num6 = trainCarUnloadable.MinDistToUnloadingArea(unloaderPos);
					float num7 = Mathf.InverseLerp(2f, 0f, num6);
					if (num5 < 2f)
					{
						float num8 = (num5 - 1f) / 1f;
						num7 *= num8;
					}
					num4 = Mathf.Lerp(num4, 3.5f, num7);
				}
			}
		}
		if (trackSpeed > 0f)
		{
			trackSpeed -= num4 * 4f * dt;
			if (trackSpeed < 0f)
			{
				trackSpeed = 0f;
			}
		}
		else if (trackSpeed < 0f)
		{
			trackSpeed += num4 * 4f * dt;
			if (trackSpeed > 0f)
			{
				trackSpeed = 0f;
			}
		}
		float num9 = trackSpeed;
		trackSpeed = ApplyCollisionsToTrackSpeed(trackSpeed, TotalMass, dt);
		if (isShunting && trackSpeed != num9)
		{
			EndShunting(CoalingTower.ActionAttemptStatus.GenericError);
		}
		if (disposed)
		{
			return;
		}
		trackSpeed = Mathf.Clamp(trackSpeed, 0f - (TrainCar.TRAINCAR_MAX_SPEED - 1f), TrainCar.TRAINCAR_MAX_SPEED - 1f);
		if (trackSpeed > 0f)
		{
			PrimaryTrainCar = trainCars[0];
		}
		else if (trackSpeed < 0f)
		{
			PrimaryTrainCar = trainCars[trainCars.Count - 1];
		}
		else if (TotalForces > 0f)
		{
			PrimaryTrainCar = trainCars[0];
		}
		else if (TotalForces < 0f)
		{
			PrimaryTrainCar = trainCars[trainCars.Count - 1];
		}
		else
		{
			PrimaryTrainCar = trainCars[0];
		}
		if (trackSpeed == 0f && TotalForces == 0f)
		{
			return;
		}
		PrimaryTrainCar.FrontTrainCarTick(GetTrackSelection(), dt);
		if (trainCars.Count <= 1)
		{
			return;
		}
		if ((Object)(object)PrimaryTrainCar == (Object)(object)trainCars[0])
		{
			for (int i = 1; i < trainCars.Count; i++)
			{
				MoveOtherTrainCar(trainCars[i], trainCars[i - 1]);
			}
			return;
		}
		for (int num10 = trainCars.Count - 2; num10 >= 0; num10--)
		{
			MoveOtherTrainCar(trainCars[num10], trainCars[num10 + 1]);
		}
	}

	private void MoveOtherTrainCar(TrainCar trainCar, TrainCar prevTrainCar)
	{
		TrainTrackSpline frontTrackSection = prevTrainCar.FrontTrackSection;
		float frontWheelSplineDist = prevTrainCar.FrontWheelSplineDist;
		float num = 0f;
		TrainCoupling coupledTo = trainCar.coupling.frontCoupling.CoupledTo;
		TrainCoupling coupledTo2 = trainCar.coupling.rearCoupling.CoupledTo;
		if (coupledTo == prevTrainCar.coupling.frontCoupling)
		{
			num += trainCar.DistFrontWheelToFrontCoupling;
			num += prevTrainCar.DistFrontWheelToFrontCoupling;
		}
		else if (coupledTo2 == prevTrainCar.coupling.rearCoupling)
		{
			num -= trainCar.DistFrontWheelToBackCoupling;
			num -= prevTrainCar.DistFrontWheelToBackCoupling;
		}
		else if (coupledTo == prevTrainCar.coupling.rearCoupling)
		{
			num += trainCar.DistFrontWheelToFrontCoupling;
			num += prevTrainCar.DistFrontWheelToBackCoupling;
		}
		else if (coupledTo2 == prevTrainCar.coupling.frontCoupling)
		{
			num -= trainCar.DistFrontWheelToBackCoupling;
			num -= prevTrainCar.DistFrontWheelToFrontCoupling;
		}
		else
		{
			Debug.LogError((object)(GetType().Name + ": Uncoupled!"));
		}
		trainCar.OtherTrainCarTick(frontTrackSection, frontWheelSplineDist, 0f - num);
	}

	public void ResetUpdateTick()
	{
		ranUpdateTick = false;
	}

	public bool Matches(List<TrainCar> listToCompare)
	{
		if (disposed)
		{
			return false;
		}
		if (listToCompare.Count != trainCars.Count)
		{
			return false;
		}
		for (int i = 0; i < listToCompare.Count; i++)
		{
			if ((Object)(object)trainCars[i] != (Object)(object)listToCompare[i])
			{
				return false;
			}
		}
		return true;
	}

	public void ReduceSpeedBy(float velChange)
	{
		prevTrackSpeed = trackSpeed;
		if (trackSpeed > 0f)
		{
			trackSpeed = Mathf.Max(0f, trackSpeed - velChange);
		}
		else if (trackSpeed < 0f)
		{
			trackSpeed = Mathf.Min(0f, trackSpeed + velChange);
		}
	}

	public bool AnyPlayersOnTrain()
	{
		if (disposed)
		{
			return false;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.AnyPlayersOnTrainCar())
			{
				return true;
			}
		}
		return false;
	}

	private int CheckLinedUpToUnload(out Vector3 unloaderPos)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (disposed)
		{
			unloaderPos = Vector3.zero;
			return -1;
		}
		for (int i = 0; i < trainCars.Count; i++)
		{
			TrainCar trainCar = trainCars[i];
			if (CoalingTower.IsUnderAnUnloader(trainCar, out var isLinedUp, out unloaderPos))
			{
				trainCar.SetFlag(BaseEntity.Flags.Reserved4, isLinedUp);
				if (isLinedUp)
				{
					return i;
				}
			}
		}
		unloaderPos = Vector3.zero;
		return -1;
	}

	public bool GetIsCoupledBackwards(TrainCar trainCar)
	{
		if (disposed)
		{
			return false;
		}
		return GetIsCoupledBackwards(trainCars.IndexOf(trainCar));
	}

	private bool GetIsCoupledBackwards(int trainCarIndex)
	{
		if (disposed || trainCars.Count == 1 || trainCarIndex < 0 || trainCarIndex > trainCars.Count - 1)
		{
			return false;
		}
		TrainCar trainCar = trainCars[trainCarIndex];
		if (trainCarIndex == 0)
		{
			return trainCar.coupling.IsFrontCoupled;
		}
		TrainCoupling coupledTo = trainCar.coupling.frontCoupling.CoupledTo;
		if (coupledTo != null)
		{
			return (Object)(object)coupledTo.owner != (Object)(object)trainCars[trainCarIndex - 1];
		}
		return true;
	}

	private bool HasThrottleInput()
	{
		for (int i = 0; i < trainCars.Count; i++)
		{
			if (trainCars[i].HasThrottleInput())
			{
				return true;
			}
		}
		return false;
	}

	private TrainTrackSpline.TrackSelection GetTrackSelection()
	{
		TrainTrackSpline.TrackSelection result = TrainTrackSpline.TrackSelection.Default;
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.localTrackSelection == TrainTrackSpline.TrackSelection.Default)
			{
				continue;
			}
			if (trainCar.IsCoupledBackwards() != PrimaryTrainCar.IsCoupledBackwards())
			{
				if (trainCar.localTrackSelection == TrainTrackSpline.TrackSelection.Left)
				{
					return TrainTrackSpline.TrackSelection.Right;
				}
				if (trainCar.localTrackSelection == TrainTrackSpline.TrackSelection.Right)
				{
					return TrainTrackSpline.TrackSelection.Left;
				}
			}
			return trainCar.localTrackSelection;
		}
		return result;
	}

	public void FreeStaticCollision()
	{
		staticCollidingAtFront = StaticCollisionState.Free;
		staticCollidingAtRear = StaticCollisionState.Free;
	}

	private float ApplyCollisionsToTrackSpeed(float trackSpeed, float totalMass, float deltaTime)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		TrainCar owner = frontCollisionTrigger.owner;
		Vector3 forwardVector = (owner.IsCoupledBackwards() ? (-((Component)owner).transform.forward) : ((Component)owner).transform.forward);
		trackSpeed = ApplyCollisions(trackSpeed, owner, forwardVector, atOurFront: true, frontCollisionTrigger, totalMass, ref staticCollidingAtFront, staticCollidingAtRear, deltaTime);
		if (disposed)
		{
			return trackSpeed;
		}
		owner = rearCollisionTrigger.owner;
		forwardVector = (owner.IsCoupledBackwards() ? (-((Component)owner).transform.forward) : ((Component)owner).transform.forward);
		trackSpeed = ApplyCollisions(trackSpeed, owner, forwardVector, atOurFront: false, rearCollisionTrigger, totalMass, ref staticCollidingAtRear, staticCollidingAtFront, deltaTime);
		if (disposed)
		{
			return trackSpeed;
		}
		Rigidbody val = null;
		foreach (KeyValuePair<Rigidbody, float> prevTrackSpeed in prevTrackSpeeds)
		{
			if ((Object)(object)prevTrackSpeed.Key == (Object)null || (!frontCollisionTrigger.otherRigidbodyContents.Contains(prevTrackSpeed.Key) && !rearCollisionTrigger.otherRigidbodyContents.Contains(prevTrackSpeed.Key)))
			{
				val = prevTrackSpeed.Key;
				break;
			}
		}
		if ((Object)(object)val != (Object)null)
		{
			prevTrackSpeeds.Remove(val);
		}
		return trackSpeed;
	}

	private float ApplyCollisions(float trackSpeed, TrainCar ourTrainCar, Vector3 forwardVector, bool atOurFront, TriggerTrainCollisions trigger, float ourTotalMass, ref StaticCollisionState wasStaticColliding, StaticCollisionState otherEndStaticColliding, float deltaTime)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = forwardVector * trackSpeed;
		bool flag = trigger.HasAnyStaticContents;
		if (atOurFront && ourTrainCar.FrontAtEndOfLine)
		{
			flag = true;
		}
		else if (!atOurFront && ourTrainCar.RearAtEndOfLine)
		{
			flag = true;
		}
		float num = (flag ? (((Vector3)(ref val)).magnitude * Mathf.Clamp(ourTotalMass, 1f, 13000f)) : 0f);
		trackSpeed = HandleStaticCollisions(flag, atOurFront, trackSpeed, ref wasStaticColliding, trigger);
		if (!flag && otherEndStaticColliding == StaticCollisionState.Free)
		{
			foreach (TrainCar trainContent in trigger.trainContents)
			{
				Vector3 val2 = ((Component)trainContent).transform.forward * trainContent.GetPrevTrackSpeed();
				trackSpeed = HandleTrainCollision(atOurFront, forwardVector, trackSpeed, ((Component)ourTrainCar).transform, trainContent, deltaTime, ref wasStaticColliding);
				num += Vector3.Magnitude(val2 - val) * Mathf.Clamp(trainContent.rigidBody.mass, 1f, 13000f);
			}
			foreach (Rigidbody otherRigidbodyContent in trigger.otherRigidbodyContents)
			{
				trackSpeed = HandleRigidbodyCollision(atOurFront, trackSpeed, forwardVector, ourTotalMass, otherRigidbodyContent, otherRigidbodyContent.velocity, otherRigidbodyContent.mass, deltaTime, calcSecondaryForces: true);
				num += Vector3.Magnitude(otherRigidbodyContent.velocity - val) * Mathf.Clamp(otherRigidbodyContent.mass, 1f, 13000f);
			}
		}
		if (num >= 70000f && TimeSince.op_Implicit(timeSinceLastChange) > 1f && trigger.owner.ApplyCollisionDamage(num) > 5f)
		{
			foreach (Collider colliderContent in trigger.colliderContents)
			{
				Vector3 contactPoint = colliderContent.ClosestPointOnBounds(((Component)trigger.owner).transform.position);
				trigger.owner.TryShowCollisionFX(contactPoint, trigger.owner.collisionEffect);
			}
		}
		return trackSpeed;
	}

	private float HandleStaticCollisions(bool staticColliding, bool front, float trackSpeed, ref StaticCollisionState wasStaticColliding, TriggerTrainCollisions trigger = null)
	{
		float num = (front ? (-5f) : 5f);
		if (staticColliding && (front ? (trackSpeed > num) : (trackSpeed < num)))
		{
			trackSpeed = num;
			wasStaticColliding = StaticCollisionState.StaticColliding;
			HashSet<GameObject> hashSet = (front ? monitoredStaticContentF : monitoredStaticContentR);
			hashSet.Clear();
			if ((Object)(object)trigger != (Object)null)
			{
				foreach (GameObject staticContent in trigger.staticContents)
				{
					hashSet.Add(staticContent);
				}
			}
		}
		else if (wasStaticColliding == StaticCollisionState.StaticColliding)
		{
			trackSpeed = 0f;
			wasStaticColliding = StaticCollisionState.StayingStill;
		}
		else if (wasStaticColliding == StaticCollisionState.StayingStill)
		{
			bool flag = (front ? (trackSpeed > 0.01f) : (trackSpeed < -0.01f));
			bool flag2 = false;
			if (!flag)
			{
				flag2 = (front ? (trackSpeed < -0.01f) : (trackSpeed > 0.01f));
			}
			if (flag)
			{
				HashSet<GameObject> hashSet2 = (front ? monitoredStaticContentF : monitoredStaticContentR);
				if (hashSet2.Count > 0)
				{
					bool flag3 = true;
					foreach (GameObject item in hashSet2)
					{
						if ((Object)(object)item != (Object)null)
						{
							flag3 = false;
							break;
						}
					}
					if (flag3)
					{
						flag = false;
					}
				}
			}
			if (flag)
			{
				trackSpeed = 0f;
			}
			else if (flag2)
			{
				wasStaticColliding = StaticCollisionState.Free;
			}
		}
		else if (front)
		{
			monitoredStaticContentF.Clear();
		}
		else
		{
			monitoredStaticContentR.Clear();
		}
		return trackSpeed;
	}

	private float HandleTrainCollision(bool front, Vector3 forwardVector, float trackSpeed, Transform ourTransform, TrainCar theirTrain, float deltaTime, ref StaticCollisionState wasStaticColliding)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = (front ? forwardVector : (-forwardVector));
		float num = Vector3.Angle(val, ((Component)theirTrain).transform.forward);
		Vector3 val2 = ((Component)theirTrain).transform.position - ourTransform.position;
		float num2 = Vector3.Dot(val, ((Vector3)(ref val2)).normalized);
		if ((num > 40f && num < 140f) || Mathf.Abs(num2) < 0.95f)
		{
			trackSpeed = (front ? (-0.5f) : 0.5f);
		}
		else
		{
			List<CompleteTrain> prevTrains = Pool.Get<List<CompleteTrain>>();
			float totalPushingMass = GetTotalPushingMass(val, forwardVector, ref prevTrains);
			trackSpeed = ((!(totalPushingMass < 0f)) ? HandleRigidbodyCollision(front, trackSpeed, forwardVector, TotalMass, theirTrain.rigidBody, theirTrain.GetLocalVelocityServer(), totalPushingMass, deltaTime, calcSecondaryForces: false) : HandleStaticCollisions(staticColliding: true, front, trackSpeed, ref wasStaticColliding));
			prevTrains.Clear();
			float nextTrainTrackSpeed;
			float num3 = GetTotalPushingForces(val, forwardVector, ref prevTrains, out nextTrainTrackSpeed);
			if (!front)
			{
				num3 *= -1f;
			}
			if ((front && num3 <= 0f) || (!front && num3 >= 0f))
			{
				float num4 = Mathf.Max(trackSpeed + 2f, nextTrainTrackSpeed + 2f);
				float num5 = Mathf.Min(trackSpeed - 2f, nextTrainTrackSpeed - 2f);
				trackSpeed += num3 / TotalMass * deltaTime;
				trackSpeed = Mathf.Clamp(trackSpeed, num5, num4);
			}
			Pool.FreeUnmanaged<CompleteTrain>(ref prevTrains);
		}
		return trackSpeed;
	}

	private float HandleRigidbodyCollision(bool atOurFront, float trackSpeed, Vector3 forwardVector, float ourTotalMass, Rigidbody theirRB, Vector3 theirVelocity, float theirTotalMass, float deltaTime, bool calcSecondaryForces)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		if (theirTotalMass < 500f)
		{
			return trackSpeed;
		}
		float num = Vector3.Dot(forwardVector, theirVelocity);
		float num2 = trackSpeed - num;
		if ((atOurFront && num2 <= 0f) || (!atOurFront && num2 >= 0f))
		{
			return trackSpeed;
		}
		float num3 = num2 / deltaTime * theirTotalMass * 0.75f;
		if (calcSecondaryForces)
		{
			if (prevTrackSpeeds.ContainsKey(theirRB))
			{
				float num4 = num2 / deltaTime * ourTotalMass * 0.75f / theirTotalMass * deltaTime;
				float num5 = prevTrackSpeeds[theirRB] - num;
				num3 -= Mathf.Clamp((num5 - num4) * ourTotalMass, 0f, 1000000f);
				prevTrackSpeeds[theirRB] = num;
			}
			else if (num != 0f)
			{
				prevTrackSpeeds.Add(theirRB, num);
			}
		}
		float num6 = num3 / ourTotalMass * deltaTime;
		num6 = Mathf.Clamp(num6, 0f - Mathf.Abs(num - trackSpeed) - 0.5f, Mathf.Abs(num - trackSpeed) + 0.5f);
		trackSpeed -= num6;
		return trackSpeed;
	}

	private float GetTotalPushingMass(Vector3 pushDirection, Vector3 ourForward, ref List<CompleteTrain> prevTrains)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		if (prevTrains.Count > 0)
		{
			if (prevTrains.Contains(this))
			{
				if (Global.developer > 1 || Application.isEditor)
				{
					Debug.LogWarning((object)"GetTotalPushingMass: Recursive loop detected. Bailing out.");
				}
				return 0f;
			}
			num += TotalMass;
		}
		prevTrains.Add(this);
		bool flag = Vector3.Dot(ourForward, pushDirection) >= 0f;
		if ((flag ? staticCollidingAtFront : staticCollidingAtRear) != 0)
		{
			return -1f;
		}
		TriggerTrainCollisions triggerTrainCollisions = (flag ? frontCollisionTrigger : rearCollisionTrigger);
		foreach (TrainCar trainContent in triggerTrainCollisions.trainContents)
		{
			if (trainContent.completeTrain != this)
			{
				Vector3 ourForward2 = (trainContent.IsCoupledBackwards() ? (-((Component)trainContent).transform.forward) : ((Component)trainContent).transform.forward);
				float totalPushingMass = trainContent.completeTrain.GetTotalPushingMass(pushDirection, ourForward2, ref prevTrains);
				if (totalPushingMass < 0f)
				{
					return -1f;
				}
				num += totalPushingMass;
			}
		}
		foreach (Rigidbody otherRigidbodyContent in triggerTrainCollisions.otherRigidbodyContents)
		{
			num += otherRigidbodyContent.mass;
		}
		return num;
	}

	private float GetTotalPushingForces(Vector3 pushDirection, Vector3 ourForward, ref List<CompleteTrain> prevTrains, out float nextTrainTrackSpeed)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		nextTrainTrackSpeed = 0f;
		if (prevTrains.Count > 0)
		{
			if (prevTrains.Contains(this))
			{
				if (Global.developer > 1 || Application.isEditor)
				{
					Debug.LogWarning((object)"GetTotalPushingForces: Recursive loop detected. Bailing out.");
				}
				return 0f;
			}
			num += TotalForces;
		}
		prevTrains.Add(this);
		bool num2 = Vector3.Dot(ourForward, pushDirection) >= 0f;
		TriggerTrainCollisions triggerTrainCollisions = (num2 ? frontCollisionTrigger : rearCollisionTrigger);
		if (!num2)
		{
			num *= -1f;
		}
		foreach (TrainCar trainContent in triggerTrainCollisions.trainContents)
		{
			if (trainContent.completeTrain != this)
			{
				Vector3 ourForward2 = (trainContent.IsCoupledBackwards() ? (-((Component)trainContent).transform.forward) : ((Component)trainContent).transform.forward);
				num += trainContent.completeTrain.GetTotalPushingForces(pushDirection, ourForward2, ref prevTrains, out var _);
				if (nextTrainTrackSpeed == 0f)
				{
					nextTrainTrackSpeed = trainContent.completeTrain.trackSpeed;
				}
			}
		}
		return num;
	}
}


private enum ShuntState
{
	None,
	Forwards,
	Backwards
}


public enum StaticCollisionState
{
	Free,
	StaticColliding,
	StayingStill
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class EngineDamageOverTime
{
	private struct RecentDamage
	{
		public readonly float time;

		public readonly float amount;

		public RecentDamage(float time, float amount)
		{
			this.time = time;
			this.amount = amount;
		}
	}

	private readonly List<RecentDamage> recentDamage = new List<RecentDamage>();

	private readonly float maxSeconds;

	private readonly float triggerDamage;

	private readonly Action trigger;

	public EngineDamageOverTime(float triggerDamage, float maxSeconds, Action trigger)
	{
		this.triggerDamage = triggerDamage;
		this.maxSeconds = maxSeconds;
		this.trigger = trigger;
	}

	public void TakeDamage(float amount)
	{
		recentDamage.Add(new RecentDamage(Time.time, amount));
		if (GetRecentDamage() > triggerDamage)
		{
			trigger();
			recentDamage.Clear();
		}
	}

	private float GetRecentDamage()
	{
		float num = 0f;
		int num2;
		for (num2 = this.recentDamage.Count - 1; num2 >= 0; num2--)
		{
			RecentDamage recentDamage = this.recentDamage[num2];
			if (Time.time > recentDamage.time + maxSeconds)
			{
				break;
			}
			num += recentDamage.amount;
		}
		if (num2 > 0)
		{
			this.recentDamage.RemoveRange(0, num2 + 1);
		}
		return num;
	}
}


private struct RecentDamage
{
	public readonly float time;

	public readonly float amount;

	public RecentDamage(float time, float amount)
	{
		this.time = time;
		this.amount = amount;
	}
}


using System;
using ConVar;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class HittableByTrains : EntityComponent<BaseCombatEntity>, ITrainCollidable, TrainTrackSpline.ITrainTrackUser, IOnParentDestroying, IOnParentSpawning
{
	[SerializeField]
	private float trainDamagePerMPS = 10f;

	[SerializeField]
	private float barricadeDamageMultiplier = 0.002f;

	[SerializeField]
	private float minVelToDestroy = 6f;

	[SerializeField]
	private float velReduction = 10f;

	[SerializeField]
	private GameObjectRef barricadeDamageEffect;

	private TrainCar hitTrain;

	private TriggerTrainCollisions hitTrainTrigger;

	private TrainTrackSpline track;

	public Vector3 Position => ((Component)this).transform.position;

	public float FrontWheelSplineDist { get; private set; }

	public TrainCar.TrainCarType CarType => TrainCar.TrainCarType.Other;

	public bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger)
	{
		bool result = false;
		if (base.baseEntity.isServer)
		{
			float num = Mathf.Abs(train.GetTrackSpeed());
			SetHitTrain(train, trainTrigger);
			if (num < minVelToDestroy && !vehicle.cinematictrains)
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)PushForceTick, 0f, 0.25f, 0.025f);
			}
			else
			{
				result = true;
				((FacepunchBehaviour)this).Invoke((Action)DestroyThisBarrier, 0f);
			}
		}
		return result;
	}

	public bool EqualNetID(BaseNetworkable other)
	{
		return base.baseEntity.EqualNetID(other);
	}

	public Vector3 GetWorldVelocity()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return base.baseEntity.GetWorldVelocity();
	}

	public void OnParentSpawning()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (TrainTrackSpline.TryFindTrackNear(((Component)this).transform.position, 5f, out var splineResult, out var distResult))
		{
			track = splineResult;
			FrontWheelSplineDist = distResult;
			track.RegisterTrackUser(this);
		}
	}

	public void OnParentDestroying()
	{
		if ((Object)(object)track != (Object)null)
		{
			track.DeregisterTrackUser(this);
		}
	}

	private void SetHitTrain(TrainCar train, TriggerTrainCollisions trainTrigger)
	{
		hitTrain = train;
		hitTrainTrigger = trainTrigger;
	}

	private void ClearHitTrain()
	{
		SetHitTrain(null, null);
	}

	private void DestroyThisBarrier()
	{
		if (base.baseEntity.IsDead() || base.baseEntity.IsDestroyed)
		{
			return;
		}
		if ((Object)(object)hitTrain != (Object)null)
		{
			hitTrain.completeTrain.ReduceSpeedBy(velReduction);
			if (vehicle.cinematictrains)
			{
				hitTrain.Hurt(9999f, DamageType.Collision, base.baseEntity, useProtection: false);
			}
			else
			{
				float amount = Mathf.Abs(hitTrain.GetTrackSpeed()) * trainDamagePerMPS;
				hitTrain.Hurt(amount, DamageType.Collision, base.baseEntity, useProtection: false);
			}
		}
		ClearHitTrain();
		base.baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
	}

	private void PushForceTick()
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)hitTrain == (Object)null || (Object)(object)hitTrainTrigger == (Object)null || hitTrain.IsDead() || hitTrain.IsDestroyed || base.baseEntity.IsDead() || !hitTrain.IsOn())
		{
			ClearHitTrain();
			((FacepunchBehaviour)this).CancelInvoke((Action)PushForceTick);
			return;
		}
		bool flag = true;
		Bounds bounds = hitTrainTrigger.triggerCollider.bounds;
		if (!((Bounds)(ref bounds)).Intersects(base.baseEntity.bounds))
		{
			Vector3 val = ((hitTrainTrigger.location != 0) ? hitTrainTrigger.owner.GetRearOfTrainPos() : hitTrainTrigger.owner.GetFrontOfTrainPos());
			flag = Vector3.SqrMagnitude(((Component)this).transform.position + ((Bounds)(ref base.baseEntity.bounds)).ClosestPoint(val - ((Component)this).transform.position) - val) < 2f;
		}
		if (flag)
		{
			float num = hitTrainTrigger.owner.completeTrain.TotalForces;
			if (hitTrainTrigger.location == TriggerTrainCollisions.Location.Rear)
			{
				num *= -1f;
			}
			num = Mathf.Max(0f, num);
			base.baseEntity.Hurt(num * barricadeDamageMultiplier, DamageType.Generic, hitTrain);
			if (base.baseEntity.IsDead())
			{
				hitTrain.completeTrain.FreeStaticCollision();
			}
		}
		else
		{
			ClearHitTrain();
			((FacepunchBehaviour)this).CancelInvoke((Action)PushForceTick);
		}
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		bool flag = base.baseEntity.lastAttacker is TrainCar;
		info.msg.simpleInt = Pool.Get<SimpleInt>();
		info.msg.simpleInt.value = (flag ? 1 : 0);
	}
}


public interface ITrainCollidable
{
	bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger);

	bool EqualNetID(BaseNetworkable other);
}


using UnityEngine;

public class LocomotiveExtraVisuals : MonoBehaviour
{
	[Header("Gauges")]
	[SerializeField]
	private TrainEngine trainEngine;

	[SerializeField]
	private Transform needleA;

	[SerializeField]
	private Transform needleB;

	[SerializeField]
	private Transform needleC;

	[SerializeField]
	private float maxAngle = 240f;

	[SerializeField]
	private float speedoMoveSpeed = 75f;

	[SerializeField]
	private float pressureMoveSpeed = 25f;

	[SerializeField]
	private float fanAcceleration = 50f;

	[SerializeField]
	private float fanMaxSpeed = 1000f;

	[SerializeField]
	private float speedoMax = 80f;

	[Header("Fans")]
	[SerializeField]
	private Transform[] engineFans;
}


using UnityEngine;

public class MountableParentCombatEntity : BaseCombatEntity
{
	private BaseMountable mountable;

	private BaseMountable Mountable
	{
		get
		{
			if ((Object)(object)mountable == (Object)null)
			{
				mountable = ((Component)this).GetComponentInParent<BaseMountable>();
			}
			return mountable;
		}
	}
}


using UnityEngine;

public class TrainCarAudio : MonoBehaviour
{
	[Header("Train Car Audio")]
	[SerializeField]
	private TrainCar trainCar;

	[SerializeField]
	private SoundDefinition movementStartDef;

	[SerializeField]
	private SoundDefinition movementStopDef;

	[SerializeField]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private AnimationCurve movementLoopGainCurve;

	[SerializeField]
	private float movementChangeOneshotDebounce = 1f;

	private Sound movementLoop;

	private SoundModulation.Modulator movementLoopGain;

	[SerializeField]
	private SoundDefinition turnLoopDef;

	private Sound turnLoop;

	[SerializeField]
	private SoundDefinition trackClatterLoopDef;

	[SerializeField]
	private AnimationCurve trackClatterGainCurve;

	[SerializeField]
	private AnimationCurve trackClatterPitchCurve;

	private Sound trackClatterLoop;

	private SoundModulation.Modulator trackClatterGain;

	private SoundModulation.Modulator trackClatterPitch;
}


using System;
using UnityEngine;

public class TrainCarFuelHatches : MonoBehaviour
{
	[SerializeField]
	private TrainCar owner;

	[SerializeField]
	private float animSpeed = 1f;

	[SerializeField]
	private Transform hatch1Col;

	[SerializeField]
	private Transform hatch1Vis;

	[SerializeField]
	private Transform hatch2Col;

	[SerializeField]
	private Transform hatch2Vis;

	[SerializeField]
	private Transform hatch3Col;

	[SerializeField]
	private Transform hatch3Vis;

	private const float closedXAngle = 0f;

	private const float openXAngle = -145f;

	[SerializeField]
	private SoundDefinition hatchOpenSoundDef;

	[SerializeField]
	private SoundDefinition hatchCloseSoundDef;

	private Vector3 _angles = Vector3.zero;

	private float _hatchLerp;

	private bool opening;

	private bool openingQueued;

	private bool isMoving;

	public void LinedUpStateChanged(bool linedUp)
	{
		openingQueued = linedUp;
		if (!isMoving)
		{
			opening = linedUp;
			_ = opening;
			isMoving = true;
			InvokeHandler.InvokeRepeating((Behaviour)(object)this, (Action)MoveTick, 0f, 0f);
		}
	}

	private void MoveTick()
	{
		if (opening)
		{
			_hatchLerp += Time.deltaTime * animSpeed;
			if (_hatchLerp >= 1f)
			{
				EndMove();
			}
			else
			{
				SetAngleOnAll(_hatchLerp, closing: false);
			}
		}
		else
		{
			_hatchLerp += Time.deltaTime * animSpeed;
			if (_hatchLerp >= 1f)
			{
				EndMove();
			}
			else
			{
				SetAngleOnAll(_hatchLerp, closing: true);
			}
		}
	}

	private void EndMove()
	{
		_hatchLerp = 0f;
		if (openingQueued == opening)
		{
			InvokeHandler.CancelInvoke((Behaviour)(object)this, (Action)MoveTick);
			isMoving = false;
		}
		else
		{
			opening = openingQueued;
		}
	}

	private void SetAngleOnAll(float lerpT, bool closing)
	{
		float angle;
		float angle2;
		float angle3;
		if (closing)
		{
			angle = LeanTween.easeOutBounce(-145f, 0f, Mathf.Clamp01(_hatchLerp * 1.15f));
			angle2 = LeanTween.easeOutBounce(-145f, 0f, _hatchLerp);
			angle3 = LeanTween.easeOutBounce(-145f, 0f, Mathf.Clamp01(_hatchLerp * 1.25f));
		}
		else
		{
			angle = LeanTween.easeOutBounce(0f, -145f, Mathf.Clamp01(_hatchLerp * 1.15f));
			angle2 = LeanTween.easeOutBounce(0f, -145f, _hatchLerp);
			angle3 = LeanTween.easeOutBounce(0f, -145f, Mathf.Clamp01(_hatchLerp * 1.25f));
		}
		SetAngle(hatch1Col, angle);
		SetAngle(hatch2Col, angle2);
		SetAngle(hatch3Col, angle3);
	}

	private void SetAngle(Transform transform, float angle)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		_angles.x = angle;
		transform.localEulerAngles = _angles;
	}
}


using System;
using Rust;
using UnityEngine;

public class TrainCarUnloadableLoot : TrainCarUnloadable
{
	[Serializable]
	public class LootCrateSet
	{
		public GameObjectRef[] crates;
	}

	[SerializeField]
	private LootCrateSet[] lootLayouts;

	[SerializeField]
	private Transform[] lootPositions;

	public override void Spawn()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (Application.isLoadingSave)
		{
			return;
		}
		int num = Random.Range(0, lootLayouts.Length);
		for (int i = 0; i < lootLayouts[num].crates.Length; i++)
		{
			GameObjectRef gameObjectRef = lootLayouts[num].crates[i];
			BaseEntity baseEntity = GameManager.server.CreateEntity(gameObjectRef.resourcePath, lootPositions[i].localPosition, lootPositions[i].localRotation);
			if ((Object)(object)baseEntity != (Object)null)
			{
				baseEntity.Spawn();
				baseEntity.SetParent(this);
			}
		}
	}
}


using System;

[Serializable]
public class LootCrateSet
{
	public GameObjectRef[] crates;
}


using Oxide.Core;
using UnityEngine;

public class TrainCoupling
{
	public readonly TrainCar owner;

	public readonly bool isFrontCoupling;

	public readonly TrainCouplingController controller;

	public readonly Transform couplingPoint;

	public readonly Transform couplingPivot;

	public readonly BaseEntity.Flags flag;

	public readonly bool isValid;

	public TimeSince timeSinceCouplingBlock;

	public bool IsCoupled => owner.HasFlag(flag);

	public bool IsUncoupled => !owner.HasFlag(flag);

	public TrainCoupling CoupledTo { get; private set; }

	public TrainCoupling(TrainCar owner, bool isFrontCoupling, TrainCouplingController controller)
		: this(owner, isFrontCoupling, controller, null, null, BaseEntity.Flags.Placeholder)
	{
	}

	public TrainCoupling(TrainCar owner, bool isFrontCoupling, TrainCouplingController controller, Transform couplingPoint, Transform couplingPivot, BaseEntity.Flags flag)
	{
		this.owner = owner;
		this.isFrontCoupling = isFrontCoupling;
		this.controller = controller;
		this.couplingPoint = couplingPoint;
		this.couplingPivot = couplingPivot;
		this.flag = flag;
		isValid = (Object)(object)couplingPoint != (Object)null;
	}

	public bool IsCoupledTo(TrainCar them)
	{
		if (CoupledTo != null)
		{
			return (Object)(object)CoupledTo.owner == (Object)(object)them;
		}
		return false;
	}

	public bool IsCoupledTo(TrainCoupling them)
	{
		if (CoupledTo != null)
		{
			return CoupledTo == them;
		}
		return false;
	}

	public bool TryCouple(TrainCoupling theirCoupling, bool reflect)
	{
		if (!isValid)
		{
			return false;
		}
		if (CoupledTo == theirCoupling)
		{
			return true;
		}
		if (IsCoupled)
		{
			return false;
		}
		object obj = Interface.CallHook("CanTrainCarCouple", (object)owner, (object)theirCoupling.owner);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (reflect && !theirCoupling.TryCouple(this, reflect: false))
		{
			return false;
		}
		CoupledTo = theirCoupling;
		owner.SetFlag(flag, b: true, recursive: false, networkupdate: false);
		owner.SendNetworkUpdate();
		return true;
	}

	public void Uncouple(bool reflect)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!IsUncoupled)
		{
			if (reflect && CoupledTo != null)
			{
				CoupledTo.Uncouple(reflect: false);
			}
			CoupledTo = null;
			owner.SetFlag(flag, b: false, recursive: false, networkupdate: false);
			owner.SendNetworkUpdate();
			timeSinceCouplingBlock = TimeSince.op_Implicit(0f);
		}
	}

	public TrainCoupling GetOppositeCoupling()
	{
		if (!isFrontCoupling)
		{
			return controller.frontCoupling;
		}
		return controller.rearCoupling;
	}

	public bool TryGetCoupledToID(out NetworkableId id)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (CoupledTo != null && (Object)(object)CoupledTo.owner != (Object)null && CoupledTo.owner.IsValid())
		{
			id = CoupledTo.owner.net.ID;
			return true;
		}
		id = default(NetworkableId);
		return false;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TrainCouplingController
{
	public const BaseEntity.Flags Flag_CouplingFront = BaseEntity.Flags.Reserved2;

	public const BaseEntity.Flags Flag_CouplingRear = BaseEntity.Flags.Reserved3;

	public readonly TrainCoupling frontCoupling;

	public readonly TrainCoupling rearCoupling;

	private readonly TrainCar owner;

	[ServerVar(Help = "Maximum difference in velocity for train cars to couple")]
	public static float max_couple_speed = 9f;

	public bool IsCoupled
	{
		get
		{
			if (!IsFrontCoupled)
			{
				return IsRearCoupled;
			}
			return true;
		}
	}

	public bool IsFrontCoupled => owner.HasFlag(BaseEntity.Flags.Reserved2);

	public bool IsRearCoupled => owner.HasFlag(BaseEntity.Flags.Reserved3);

	public TrainCouplingController(TrainCar owner)
	{
		this.owner = owner;
		frontCoupling = new TrainCoupling(owner, isFrontCoupling: true, this, owner.frontCoupling, owner.frontCouplingPivot, BaseEntity.Flags.Reserved2);
		rearCoupling = new TrainCoupling(owner, isFrontCoupling: false, this, owner.rearCoupling, owner.rearCouplingPivot, BaseEntity.Flags.Reserved3);
	}

	public bool IsCoupledTo(TrainCar them)
	{
		if (!frontCoupling.IsCoupledTo(them))
		{
			return rearCoupling.IsCoupledTo(them);
		}
		return true;
	}

	public bool TryCouple(TrainCar them, TriggerTrainCollisions.Location ourLocation)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		TrainCoupling trainCoupling = ((ourLocation == TriggerTrainCollisions.Location.Front) ? frontCoupling : rearCoupling);
		if (!trainCoupling.isValid)
		{
			return false;
		}
		if (trainCoupling.IsCoupled)
		{
			return false;
		}
		if (TimeSince.op_Implicit(trainCoupling.timeSinceCouplingBlock) < 1.5f)
		{
			return false;
		}
		if ((Object)(object)them == (Object)(object)owner)
		{
			return false;
		}
		float num = Vector3.Angle(((Component)owner).transform.forward, ((Component)them).transform.forward);
		if (num > 25f && num < 155f)
		{
			return false;
		}
		bool num2 = num < 90f;
		TrainCoupling trainCoupling2 = ((!num2) ? ((ourLocation == TriggerTrainCollisions.Location.Front) ? them.coupling.frontCoupling : them.coupling.rearCoupling) : ((ourLocation == TriggerTrainCollisions.Location.Front) ? them.coupling.rearCoupling : them.coupling.frontCoupling));
		float num3 = them.GetTrackSpeed();
		if (!num2)
		{
			num3 = 0f - num3;
		}
		if (Mathf.Abs(num3 - owner.GetTrackSpeed()) > max_couple_speed)
		{
			trainCoupling.timeSinceCouplingBlock = TimeSince.op_Implicit(0f);
			trainCoupling2.timeSinceCouplingBlock = TimeSince.op_Implicit(0f);
			return false;
		}
		if (!trainCoupling2.isValid)
		{
			return false;
		}
		if (Vector3.SqrMagnitude(trainCoupling.couplingPoint.position - trainCoupling2.couplingPoint.position) > 0.5f)
		{
			return false;
		}
		TrainTrackSpline frontTrackSection = owner.FrontTrackSection;
		TrainTrackSpline frontTrackSection2 = them.FrontTrackSection;
		if ((Object)(object)frontTrackSection2 != (Object)(object)frontTrackSection && !frontTrackSection.HasConnectedTrack(frontTrackSection2))
		{
			return false;
		}
		return trainCoupling.TryCouple(trainCoupling2, reflect: true);
	}

	public void Uncouple(bool front)
	{
		if (front)
		{
			frontCoupling.Uncouple(reflect: true);
		}
		else
		{
			rearCoupling.Uncouple(reflect: true);
		}
	}

	public void GetAll(ref List<TrainCar> result)
	{
		result.Add(owner);
		TrainCoupling coupledTo = rearCoupling.CoupledTo;
		while (coupledTo != null && coupledTo.IsCoupled && !result.Contains(coupledTo.owner))
		{
			result.Insert(0, coupledTo.owner);
			coupledTo = coupledTo.GetOppositeCoupling();
			coupledTo = coupledTo.CoupledTo;
		}
		TrainCoupling coupledTo2 = frontCoupling.CoupledTo;
		while (coupledTo2 != null && coupledTo2.IsCoupled && !result.Contains(coupledTo2.owner))
		{
			result.Add(coupledTo2.owner);
			coupledTo2 = coupledTo2.GetOppositeCoupling();
			coupledTo2 = coupledTo2.CoupledTo;
		}
	}
}


using System;
using UnityEngine;

public class TrainEngineAudio : TrainCarAudio
{
	[Serializable]
	public class EngineReflection
	{
		public Vector3 direction;

		public Vector3 offset;

		public SoundDefinition soundDef;

		public Sound sound;

		public SoundModulation.Modulator pitchMod;

		public SoundModulation.Modulator gainMod;

		public float distance = 20f;
	}

	[SerializeField]
	private TrainEngine trainEngine;

	[SerializeField]
	private Transform cockpitSoundPosition;

	[SerializeField]
	private Transform hornSoundPosition;

	[SerializeField]
	[Header("Engine")]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineActiveLoopDef;

	[SerializeField]
	private AnimationCurve engineActiveLoopPitchCurve;

	[SerializeField]
	private float engineActiveLoopChangeSpeed = 0.2f;

	private Sound engineActiveLoop;

	private SoundModulation.Modulator engineActiveLoopPitch;

	[SerializeField]
	private BlendedLoopEngineSound engineLoops;

	[SerializeField]
	private EngineReflection[] engineReflections;

	[SerializeField]
	private LayerMask reflectionLayerMask;

	[SerializeField]
	private float reflectionMaxDistance = 20f;

	[SerializeField]
	private float reflectionGainChangeSpeed = 10f;

	[SerializeField]
	private float reflectionPositionChangeSpeed = 10f;

	[SerializeField]
	private float reflectionRayOffset = 0.5f;

	[Header("Horn")]
	[SerializeField]
	private SoundDefinition hornLoop;

	[SerializeField]
	private SoundDefinition hornStart;

	[SerializeField]
	[Header("Other")]
	private SoundDefinition lightsToggleSound;

	[SerializeField]
	private SoundDefinition proximityAlertDef;

	private Sound proximityAlertSound;

	[SerializeField]
	private SoundDefinition damagedLoopDef;

	private Sound damagedLoop;

	[SerializeField]
	private SoundDefinition changeThrottleDef;

	[SerializeField]
	private SoundDefinition changeCouplingDef;

	[SerializeField]
	private SoundDefinition unloadableStartDef;

	[SerializeField]
	private SoundDefinition unloadableEndDef;

	[SerializeField]
	private GameObject bellObject;

	[SerializeField]
	private SoundDefinition bellRingDef;

	[SerializeField]
	private SoundPlayer brakeSound;
}


using System;
using UnityEngine;

[Serializable]
public class EngineReflection
{
	public Vector3 direction;

	public Vector3 offset;

	public SoundDefinition soundDef;

	public Sound sound;

	public SoundModulation.Modulator pitchMod;

	public SoundModulation.Modulator gainMod;

	public float distance = 20f;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class TrainTrackSpline : WorldSpline
{
	public enum TrackSelection
	{
		Default,
		Left,
		Right
	}

	public enum TrackPosition
	{
		Next,
		Prev
	}

	public enum TrackOrientation
	{
		Same,
		Reverse
	}

	public class ConnectedTrackInfo
	{
		public readonly TrainTrackSpline track;

		public readonly TrackOrientation orientation;

		public readonly float angle;

		public ConnectedTrackInfo(TrainTrackSpline track, TrackOrientation orientation, float angle)
		{
			this.track = track;
			this.orientation = orientation;
			this.angle = angle;
		}
	}

	public enum DistanceType
	{
		SplineDistance,
		WorldDistance
	}

	public interface ITrainTrackUser
	{
		Vector3 Position { get; }

		float FrontWheelSplineDist { get; }

		TrainCar.TrainCarType CarType { get; }

		Vector3 GetWorldVelocity();
	}

	public struct MoveRequest
	{
		public delegate MoveResult SplineAction(MoveResult result, MoveRequest request, TrainTrackSpline spline, float splineLength);

		public float distAlongSpline;

		public float maxMoveDist;

		public SplineAction onSpline;

		public TrackRequest trackRequest;

		public float totalDistMoved;

		public float ProjectEndDist(bool facingForward)
		{
			if (!facingForward)
			{
				return distAlongSpline - maxMoveDist;
			}
			return distAlongSpline + maxMoveDist;
		}

		public MoveRequest(float distAlongSpline, float maxMoveDist, SplineAction onSpline, TrackRequest trackRequest)
		{
			this.distAlongSpline = distAlongSpline;
			this.maxMoveDist = maxMoveDist;
			this.onSpline = onSpline;
			this.trackRequest = trackRequest;
			totalDistMoved = 0f;
		}
	}

	public struct TrackRequest
	{
		public TrackSelection trackSelection;

		public TrainTrackSpline preferredAltA;

		public TrainTrackSpline preferredAltB;

		public TrackRequest(TrackSelection trackSelection, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
		{
			this.trackSelection = trackSelection;
			this.preferredAltA = preferredAltA;
			this.preferredAltB = preferredAltB;
		}
	}

	public struct MoveResult
	{
		public TrainTrackSpline spline;

		public float distAlongSpline;

		public bool atEndOfLine;

		public TrainSignal signal;

		public float totalDistMoved;
	}

	[Tooltip("Is this track spline part of a train station?")]
	public bool isStation;

	[Tooltip("Can above-ground trains spawn here?")]
	public bool aboveGroundSpawn;

	public int hierarchy;

	public static List<TrainTrackSpline> SidingSplines = new List<TrainTrackSpline>();

	public readonly List<ConnectedTrackInfo> nextTracks = new List<ConnectedTrackInfo>();

	public int straightestNextIndex;

	public readonly List<ConnectedTrackInfo> prevTracks = new List<ConnectedTrackInfo>();

	public int straightestPrevIndex;

	[NonSerialized]
	public HashSet<ITrainTrackUser> trackUsers = new HashSet<ITrainTrackUser>();

	[NonSerialized]
	public HashSet<TrainSignal> signals = new HashSet<TrainSignal>();

	public bool HasNextTrack => nextTracks.Count > 0;

	public bool HasPrevTrack => prevTracks.Count > 0;

	public void SetAll(Vector3[] points, Vector3[] tangents, TrainTrackSpline sourceSpline)
	{
		base.points = points;
		base.tangents = tangents;
		lutInterval = sourceSpline.lutInterval;
		isStation = sourceSpline.isStation;
		aboveGroundSpawn = sourceSpline.aboveGroundSpawn;
		hierarchy = sourceSpline.hierarchy;
	}

	public MoveResult MoveAlongSpline(float prevSplineDist, Vector3 askerForward, float distMoved, TrackRequest tReq = default(TrackRequest), MoveRequest.SplineAction onSpline = null)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		MoveRequest request = new MoveRequest(prevSplineDist, distMoved, onSpline, tReq);
		bool facingForward = IsForward(askerForward, prevSplineDist);
		return MoveAlongSpline(request, facingForward, 0f);
	}

	private MoveResult MoveAlongSpline(MoveRequest request, bool facingForward, float prevDistMoved)
	{
		MoveResult moveResult = default(MoveResult);
		moveResult.totalDistMoved = prevDistMoved;
		MoveResult result = moveResult;
		WorldSplineData data = GetData();
		result.distAlongSpline = request.ProjectEndDist(facingForward);
		if (request.onSpline != null)
		{
			result = request.onSpline(result, request, this, data.Length);
		}
		result.spline = this;
		if (result.distAlongSpline < 0f)
		{
			result.totalDistMoved += request.distAlongSpline;
			result = MoveToPrevSpline(result, request, facingForward);
		}
		else if (result.distAlongSpline > data.Length)
		{
			result.totalDistMoved += data.Length - request.distAlongSpline;
			result = MoveToNextSpline(result, request, facingForward, data.Length);
		}
		else
		{
			result.totalDistMoved += Mathf.Abs(result.distAlongSpline - request.distAlongSpline);
		}
		return result;
	}

	private MoveResult MoveToNextSpline(MoveResult result, MoveRequest request, bool facingForward, float splineLength)
	{
		if (HasNextTrack)
		{
			ConnectedTrackInfo trackSelection = GetTrackSelection(nextTracks, straightestNextIndex, nextTrack: true, facingForward, request.trackRequest);
			request.maxMoveDist = (facingForward ? (result.distAlongSpline - splineLength) : (0f - (result.distAlongSpline - splineLength)));
			if (trackSelection.orientation == TrackOrientation.Same)
			{
				request.distAlongSpline = 0f;
			}
			else
			{
				request.distAlongSpline = trackSelection.track.GetLength();
				facingForward = !facingForward;
			}
			return trackSelection.track.MoveAlongSpline(request, facingForward, result.totalDistMoved);
		}
		result.atEndOfLine = true;
		result.distAlongSpline = splineLength;
		return result;
	}

	private MoveResult MoveToPrevSpline(MoveResult result, MoveRequest request, bool facingForward)
	{
		if (HasPrevTrack)
		{
			ConnectedTrackInfo trackSelection = GetTrackSelection(prevTracks, straightestPrevIndex, nextTrack: false, facingForward, request.trackRequest);
			request.maxMoveDist = (facingForward ? result.distAlongSpline : (0f - result.distAlongSpline));
			if (trackSelection.orientation == TrackOrientation.Same)
			{
				request.distAlongSpline = trackSelection.track.GetLength();
			}
			else
			{
				request.distAlongSpline = 0f;
				facingForward = !facingForward;
			}
			return trackSelection.track.MoveAlongSpline(request, facingForward, result.totalDistMoved);
		}
		result.atEndOfLine = true;
		result.distAlongSpline = 0f;
		return result;
	}

	public float GetDistance(Vector3 position, float maxError, out float minSplineDist)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		WorldSplineData data = GetData();
		float num = maxError * maxError;
		Vector3 val = ((Component)this).transform.InverseTransformPoint(position);
		float num2 = float.MaxValue;
		minSplineDist = 0f;
		int num3 = 0;
		int num4 = data.LUTValues.Count;
		if (data.Length > 40f)
		{
			for (int i = 0; (float)i < data.Length + 10f; i += 10)
			{
				float num5 = Vector3.SqrMagnitude(data.GetPointCubicHermite(i) - val);
				if (num5 < num2)
				{
					num2 = num5;
					minSplineDist = i;
				}
			}
			num3 = Mathf.FloorToInt(Mathf.Max(0f, minSplineDist - 10f + 1f));
			num4 = Mathf.CeilToInt(Mathf.Min((float)data.LUTValues.Count, minSplineDist + 10f - 1f));
		}
		for (int j = num3; j < num4; j++)
		{
			WorldSplineData.LUTEntry lUTEntry = data.LUTValues[j];
			for (int k = 0; k < lUTEntry.points.Count; k++)
			{
				WorldSplineData.LUTEntry.LUTPoint lUTPoint = lUTEntry.points[k];
				float num6 = Vector3.SqrMagnitude(lUTPoint.pos - val);
				if (num6 < num2)
				{
					num2 = num6;
					minSplineDist = lUTPoint.distance;
					if (num6 < num)
					{
						break;
					}
				}
			}
		}
		return Mathf.Sqrt(num2);
	}

	public float GetLength()
	{
		return GetData().Length;
	}

	public Vector3 GetPosition(float distance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return GetPointCubicHermiteWorld(distance);
	}

	public Vector3 GetPositionAndTangent(float distance, Vector3 askerForward, out Vector3 tangent)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pointAndTangentCubicHermiteWorld = GetPointAndTangentCubicHermiteWorld(distance, out tangent);
		if (Vector3.Dot(askerForward, tangent) < 0f)
		{
			tangent = -tangent;
		}
		return pointAndTangentCubicHermiteWorld;
	}

	public void AddTrackConnection(TrainTrackSpline track, TrackPosition p, TrackOrientation o)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		List<ConnectedTrackInfo> list = ((p == TrackPosition.Next) ? nextTracks : prevTracks);
		for (int i = 0; i < list.Count; i++)
		{
			if ((Object)(object)list[i].track == (Object)(object)track)
			{
				return;
			}
		}
		Vector3 val = ((p == TrackPosition.Next) ? points[points.Length - 2] : points[0]);
		Vector3 val2 = ((p == TrackPosition.Next) ? points[points.Length - 1] : points[1]);
		Vector3 val3 = ((Component)this).transform.TransformPoint(val2) - ((Component)this).transform.TransformPoint(val);
		Vector3 initialVector = GetInitialVector(track, p, o);
		float num = Vector3.SignedAngle(val3, initialVector, Vector3.up);
		int j;
		for (j = 0; j < list.Count && !(list[j].angle > num); j++)
		{
		}
		list.Insert(j, new ConnectedTrackInfo(track, o, num));
		int num2 = int.MaxValue;
		for (int k = 0; k < list.Count; k++)
		{
			num2 = Mathf.Min(num2, list[k].track.hierarchy);
		}
		float num3 = float.MaxValue;
		int num4 = 0;
		for (int l = 0; l < list.Count; l++)
		{
			ConnectedTrackInfo connectedTrackInfo = list[l];
			if (connectedTrackInfo.track.hierarchy > num2)
			{
				continue;
			}
			float num5 = Mathf.Abs(connectedTrackInfo.angle);
			if (num5 < num3)
			{
				num3 = num5;
				num4 = l;
				if (num3 == 0f)
				{
					break;
				}
			}
		}
		if (p == TrackPosition.Next)
		{
			straightestNextIndex = num4;
		}
		else
		{
			straightestPrevIndex = num4;
		}
	}

	public void RegisterTrackUser(ITrainTrackUser user)
	{
		trackUsers.Add(user);
	}

	public void DeregisterTrackUser(ITrainTrackUser user)
	{
		if (user != null)
		{
			trackUsers.Remove(user);
		}
	}

	public void RegisterSignal(TrainSignal signal)
	{
		signals.Add(signal);
	}

	public void DeregisterSignal(TrainSignal signal)
	{
		if (!((Object)(object)signal == (Object)null))
		{
			signals.Remove(signal);
		}
	}

	public bool IsForward(Vector3 askerForward, float askerSplineDist)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		WorldSplineData data = GetData();
		Vector3 tangentCubicHermiteWorld = GetTangentCubicHermiteWorld(askerSplineDist, data);
		return Vector3.Dot(askerForward, tangentCubicHermiteWorld) >= 0f;
	}

	public bool HasValidHazardWithin(TrainCar asker, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, float trackSpeed, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 askerForward = ((trackSpeed >= 0f) ? ((Component)asker).transform.forward : (-((Component)asker).transform.forward));
		bool movingForward = IsForward(askerForward, askerSplineDist);
		return HasValidHazardWithin(asker, askerForward, askerSplineDist, minHazardDist, maxHazardDist, trackSelection, movingForward, preferredAltA, preferredAltB);
	}

	public bool HasValidHazardWithin(ITrainTrackUser asker, Vector3 askerForward, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, bool movingForward, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		WorldSplineData data = GetData();
		foreach (ITrainTrackUser trackUser in trackUsers)
		{
			if (trackUser == asker)
			{
				continue;
			}
			Vector3 val = trackUser.Position - asker.Position;
			if (!(Vector3.Dot(askerForward, val) >= 0f))
			{
				continue;
			}
			float magnitude = ((Vector3)(ref val)).magnitude;
			if (magnitude > minHazardDist && magnitude < maxHazardDist)
			{
				Vector3 worldVelocity = trackUser.GetWorldVelocity();
				if (((Vector3)(ref worldVelocity)).sqrMagnitude < 4f || Vector3.Dot(worldVelocity, val) < 0f)
				{
					return true;
				}
			}
		}
		float num = (movingForward ? (askerSplineDist + minHazardDist) : (askerSplineDist - minHazardDist));
		float num2 = (movingForward ? (askerSplineDist + maxHazardDist) : (askerSplineDist - maxHazardDist));
		if (num2 < 0f)
		{
			if (HasPrevTrack)
			{
				ConnectedTrackInfo connectedTrackInfo = GetTrackSelection(request: new TrackRequest(trackSelection, preferredAltA, preferredAltB), trackOptions: prevTracks, straightestIndex: straightestPrevIndex, nextTrack: false, trainForward: movingForward);
				if (connectedTrackInfo.orientation == TrackOrientation.Same)
				{
					askerSplineDist = connectedTrackInfo.track.GetLength();
				}
				else
				{
					askerSplineDist = 0f;
					movingForward = !movingForward;
				}
				float minHazardDist2 = Mathf.Max(0f - num, 0f);
				float maxHazardDist2 = 0f - num2;
				return connectedTrackInfo.track.HasValidHazardWithin(asker, askerForward, askerSplineDist, minHazardDist2, maxHazardDist2, trackSelection, movingForward, preferredAltA, preferredAltB);
			}
		}
		else if (num2 > data.Length && HasNextTrack)
		{
			ConnectedTrackInfo connectedTrackInfo2 = GetTrackSelection(request: new TrackRequest(trackSelection, preferredAltA, preferredAltB), trackOptions: nextTracks, straightestIndex: straightestNextIndex, nextTrack: true, trainForward: movingForward);
			if (connectedTrackInfo2.orientation == TrackOrientation.Same)
			{
				askerSplineDist = 0f;
			}
			else
			{
				askerSplineDist = connectedTrackInfo2.track.GetLength();
				movingForward = !movingForward;
			}
			float minHazardDist3 = Mathf.Max(num - data.Length, 0f);
			float maxHazardDist3 = num2 - data.Length;
			return connectedTrackInfo2.track.HasValidHazardWithin(asker, askerForward, askerSplineDist, minHazardDist3, maxHazardDist3, trackSelection, movingForward, preferredAltA, preferredAltB);
		}
		return false;
	}

	public bool HasAnyUsers()
	{
		return trackUsers.Count > 0;
	}

	public bool HasAnyUsersOfType(TrainCar.TrainCarType carType)
	{
		foreach (ITrainTrackUser trackUser in trackUsers)
		{
			if (trackUser.CarType == carType)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasConnectedTrack(TrainTrackSpline tts)
	{
		if (!HasConnectedNextTrack(tts))
		{
			return HasConnectedPrevTrack(tts);
		}
		return true;
	}

	public bool HasConnectedNextTrack(TrainTrackSpline tts)
	{
		foreach (ConnectedTrackInfo nextTrack in nextTracks)
		{
			if ((Object)(object)nextTrack.track == (Object)(object)tts)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasConnectedPrevTrack(TrainTrackSpline tts)
	{
		foreach (ConnectedTrackInfo prevTrack in prevTracks)
		{
			if ((Object)(object)prevTrack.track == (Object)(object)tts)
			{
				return true;
			}
		}
		return false;
	}

	public static Vector3 GetInitialVector(TrainTrackSpline track, TrackPosition p, TrackOrientation o)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val;
		Vector3 val2;
		if (p == TrackPosition.Next)
		{
			if (o == TrackOrientation.Reverse)
			{
				val = track.points[track.points.Length - 1];
				val2 = track.points[track.points.Length - 2];
			}
			else
			{
				val = track.points[0];
				val2 = track.points[1];
			}
		}
		else if (o == TrackOrientation.Reverse)
		{
			val = track.points[1];
			val2 = track.points[0];
		}
		else
		{
			val = track.points[track.points.Length - 2];
			val2 = track.points[track.points.Length - 1];
		}
		return ((Component)track).transform.TransformPoint(val2) - ((Component)track).transform.TransformPoint(val);
	}

	protected override void OnDrawGizmosSelected()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		base.OnDrawGizmosSelected();
		for (int i = 0; i < nextTracks.Count; i++)
		{
			Color splineColour = Color.white;
			if (straightestNextIndex != i && nextTracks.Count > 1)
			{
				if (i == 0)
				{
					splineColour = Color.green;
				}
				else if (i == nextTracks.Count - 1)
				{
					splineColour = Color.yellow;
				}
			}
			WorldSpline.DrawSplineGizmo(nextTracks[i].track, splineColour);
		}
		for (int j = 0; j < prevTracks.Count; j++)
		{
			Color splineColour2 = Color.white;
			if (straightestPrevIndex != j && prevTracks.Count > 1)
			{
				if (j == 0)
				{
					splineColour2 = Color.green;
				}
				else if (j == nextTracks.Count - 1)
				{
					splineColour2 = Color.yellow;
				}
			}
			WorldSpline.DrawSplineGizmo(prevTracks[j].track, splineColour2);
		}
	}

	public ConnectedTrackInfo GetTrackSelection(List<ConnectedTrackInfo> trackOptions, int straightestIndex, bool nextTrack, bool trainForward, TrackRequest request)
	{
		if (trackOptions.Count == 1)
		{
			return trackOptions[0];
		}
		foreach (ConnectedTrackInfo trackOption in trackOptions)
		{
			if ((Object)(object)trackOption.track == (Object)(object)request.preferredAltA || (Object)(object)trackOption.track == (Object)(object)request.preferredAltB)
			{
				return trackOption;
			}
		}
		bool flag = nextTrack ^ trainForward;
		switch (request.trackSelection)
		{
		case TrackSelection.Left:
			if (!flag)
			{
				return trackOptions[0];
			}
			return trackOptions[trackOptions.Count - 1];
		case TrackSelection.Right:
			if (!flag)
			{
				return trackOptions[trackOptions.Count - 1];
			}
			return trackOptions[0];
		default:
			return trackOptions[straightestIndex];
		}
	}

	public static bool TryFindTrackNear(Vector3 pos, float maxDist, out TrainTrackSpline splineResult, out float distResult)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		splineResult = null;
		distResult = 0f;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(pos, maxDist, list, 65536, (QueryTriggerInteraction)1);
		if (list.Count > 0)
		{
			List<TrainTrackSpline> list2 = Pool.Get<List<TrainTrackSpline>>();
			float num = float.MaxValue;
			foreach (Collider item in list)
			{
				((Component)item).GetComponentsInParent<TrainTrackSpline>(false, list2);
				if (list2.Count <= 0)
				{
					continue;
				}
				foreach (TrainTrackSpline item2 in list2)
				{
					float minSplineDist;
					float distance = item2.GetDistance(pos, 1f, out minSplineDist);
					if (distance < num)
					{
						num = distance;
						distResult = minSplineDist;
						splineResult = item2;
					}
				}
			}
			Pool.FreeUnmanaged<TrainTrackSpline>(ref list2);
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return (Object)(object)splineResult != (Object)null;
	}
}


public enum TrackSelection
{
	Default,
	Left,
	Right
}


public enum TrackPosition
{
	Next,
	Prev
}


public enum TrackOrientation
{
	Same,
	Reverse
}


public class ConnectedTrackInfo
{
	public readonly TrainTrackSpline track;

	public readonly TrackOrientation orientation;

	public readonly float angle;

	public ConnectedTrackInfo(TrainTrackSpline track, TrackOrientation orientation, float angle)
	{
		this.track = track;
		this.orientation = orientation;
		this.angle = angle;
	}
}


public enum DistanceType
{
	SplineDistance,
	WorldDistance
}


using UnityEngine;

public interface ITrainTrackUser
{
	Vector3 Position { get; }

	float FrontWheelSplineDist { get; }

	TrainCar.TrainCarType CarType { get; }

	Vector3 GetWorldVelocity();
}


public struct MoveRequest
{
	public delegate MoveResult SplineAction(MoveResult result, MoveRequest request, TrainTrackSpline spline, float splineLength);

	public float distAlongSpline;

	public float maxMoveDist;

	public SplineAction onSpline;

	public TrackRequest trackRequest;

	public float totalDistMoved;

	public float ProjectEndDist(bool facingForward)
	{
		if (!facingForward)
		{
			return distAlongSpline - maxMoveDist;
		}
		return distAlongSpline + maxMoveDist;
	}

	public MoveRequest(float distAlongSpline, float maxMoveDist, SplineAction onSpline, TrackRequest trackRequest)
	{
		this.distAlongSpline = distAlongSpline;
		this.maxMoveDist = maxMoveDist;
		this.onSpline = onSpline;
		this.trackRequest = trackRequest;
		totalDistMoved = 0f;
	}
}


public delegate MoveResult SplineAction(MoveResult result, MoveRequest request, TrainTrackSpline spline, float splineLength);


public struct TrackRequest
{
	public TrackSelection trackSelection;

	public TrainTrackSpline preferredAltA;

	public TrainTrackSpline preferredAltB;

	public TrackRequest(TrackSelection trackSelection, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
	{
		this.trackSelection = trackSelection;
		this.preferredAltA = preferredAltA;
		this.preferredAltB = preferredAltB;
	}
}


public struct MoveResult
{
	public TrainTrackSpline spline;

	public float distAlongSpline;

	public bool atEndOfLine;

	public TrainSignal signal;

	public float totalDistMoved;
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Scriptable Object/Vehicles/Train Wagon Loot Data", fileName = "Train Wagon Loot Data")]
public class TrainWagonLootData : ScriptableObject
{
	[Serializable]
	public class LootOption
	{
		public bool showsFX = true;

		public ItemDefinition lootItem;

		[FormerlySerializedAs("lootAmount")]
		public int maxLootAmount;

		public int minLootAmount;

		public Material lootMaterial;

		public float spawnWeighting = 1f;

		public Color fxTint;

		[FormerlySerializedAs("indoorFXTint")]
		public Color particleFXTint;
	}

	[SerializeField]
	private LootOption[] oreOptions;

	[SerializeField]
	[ReadOnly]
	private LootOption lootWagonContent;

	[SerializeField]
	private LootOption fuelWagonContent;

	private static TrainWagonLootData _instance;

	private const int LOOT_WAGON_INDEX = 1000;

	private const int FUEL_WAGON_INDEX = 1001;

	public static TrainWagonLootData instance
	{
		get
		{
			if ((Object)(object)_instance == (Object)null)
			{
				_instance = Resources.Load<TrainWagonLootData>("Train Wagon Loot Data");
			}
			return _instance;
		}
	}

	public LootOption GetLootOption(TrainCarUnloadable.WagonType wagonType, out int index)
	{
		switch (wagonType)
		{
		case TrainCarUnloadable.WagonType.Lootboxes:
			index = 1000;
			return lootWagonContent;
		case TrainCarUnloadable.WagonType.Fuel:
			index = 1001;
			return fuelWagonContent;
		default:
		{
			float num = 0f;
			LootOption[] array = oreOptions;
			foreach (LootOption lootOption in array)
			{
				num += lootOption.spawnWeighting;
			}
			float num2 = Random.value * num;
			for (index = 0; index < oreOptions.Length; index++)
			{
				if ((num2 -= oreOptions[index].spawnWeighting) < 0f)
				{
					return oreOptions[index];
				}
			}
			return oreOptions[index];
		}
		}
	}

	public bool TryGetLootFromIndex(int index, out LootOption lootOption)
	{
		switch (index)
		{
		case 1000:
			lootOption = lootWagonContent;
			return true;
		case 1001:
			lootOption = fuelWagonContent;
			return true;
		default:
			index = Mathf.Clamp(index, 0, oreOptions.Length - 1);
			lootOption = oreOptions[index];
			return true;
		}
	}

	public bool TryGetIndexFromLoot(LootOption lootOption, out int index)
	{
		if (lootOption == lootWagonContent)
		{
			index = 1000;
			return true;
		}
		if (lootOption == fuelWagonContent)
		{
			index = 1001;
			return true;
		}
		for (index = 0; index < oreOptions.Length; index++)
		{
			if (oreOptions[index] == lootOption)
			{
				return true;
			}
		}
		index = -1;
		return false;
	}

	public static float GetOrePercent(int lootTypeIndex, StorageContainer sc)
	{
		if (instance.TryGetLootFromIndex(lootTypeIndex, out var lootOption))
		{
			return GetOrePercent(lootOption, sc);
		}
		return 0f;
	}

	public static void SetOrePercent(int lootTypeIndex, StorageContainer sc, float percent)
	{
		if (instance.TryGetLootFromIndex(lootTypeIndex, out var lootOption))
		{
			SetOrePercent(lootOption, sc, percent);
		}
	}

	public static float GetOrePercent(LootOption lootOption, StorageContainer sc)
	{
		float result = 0f;
		if (sc.IsValid())
		{
			int maxLootAmount = lootOption.maxLootAmount;
			result = (((float)maxLootAmount != 0f) ? Mathf.Clamp01((float)sc.inventory.GetAmount(lootOption.lootItem.itemid, onlyUsableAmounts: false) / (float)maxLootAmount) : 0f);
		}
		return result;
	}

	public static void SetOrePercent(LootOption lootOption, StorageContainer sc, float percent)
	{
		if (!sc.IsValid())
		{
			return;
		}
		int maxLootAmount = lootOption.maxLootAmount;
		if ((float)maxLootAmount > 0f)
		{
			Item item = sc.inventory.FindItemByItemID(lootOption.lootItem.itemid);
			if (item != null)
			{
				item.amount = Mathf.Max(Mathf.RoundToInt((float)maxLootAmount * percent), 1);
			}
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[Serializable]
public class LootOption
{
	public bool showsFX = true;

	public ItemDefinition lootItem;

	[FormerlySerializedAs("lootAmount")]
	public int maxLootAmount;

	public int minLootAmount;

	public Material lootMaterial;

	public float spawnWeighting = 1f;

	public Color fxTint;

	[FormerlySerializedAs("indoorFXTint")]
	public Color particleFXTint;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerTrainCollisions : TriggerBase
{
	public enum Location
	{
		Front,
		Rear
	}

	public Collider triggerCollider;

	public Location location;

	public TrainCar owner;

	[NonSerialized]
	public HashSet<GameObject> staticContents = new HashSet<GameObject>();

	[NonSerialized]
	public HashSet<TrainCar> trainContents = new HashSet<TrainCar>();

	[NonSerialized]
	public HashSet<Rigidbody> otherRigidbodyContents = new HashSet<Rigidbody>();

	[NonSerialized]
	public HashSet<Collider> colliderContents = new HashSet<Collider>();

	private const float TICK_RATE = 0.2f;

	public bool HasAnyStaticContents => staticContents.Count > 0;

	public bool HasAnyTrainContents => trainContents.Count > 0;

	public bool HasAnyOtherRigidbodyContents => otherRigidbodyContents.Count > 0;

	public bool HasAnyNonStaticContents
	{
		get
		{
			if (!HasAnyTrainContents)
			{
				return HasAnyOtherRigidbodyContents;
			}
			return true;
		}
	}

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		if (!owner.isServer)
		{
			return;
		}
		base.OnObjectAdded(obj, col);
		if ((Object)(object)obj != (Object)null)
		{
			BaseEntity baseEntity = obj.ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				Vector3 val = ((Component)baseEntity).transform.position + ((Component)baseEntity).transform.rotation * Vector3.Scale(obj.transform.lossyScale, ((Bounds)(ref baseEntity.bounds)).center);
				Bounds bounds = triggerCollider.bounds;
				Vector3 center = ((Bounds)(ref bounds)).center;
				Vector3 val2 = val - center;
				bool flag = Vector3.Dot(((Component)owner).transform.forward, val2) > 0f;
				if ((location == Location.Front && !flag) || (location == Location.Rear && flag))
				{
					return;
				}
			}
		}
		if ((Object)(object)obj != (Object)null)
		{
			Rigidbody componentInParent = obj.GetComponentInParent<Rigidbody>();
			if ((Object)(object)componentInParent != (Object)null)
			{
				TrainCar componentInParent2 = obj.GetComponentInParent<TrainCar>();
				if ((Object)(object)componentInParent2 != (Object)null && (Object)(object)componentInParent2 != (Object)(object)owner)
				{
					trainContents.Add(componentInParent2);
					if (owner.coupling != null)
					{
						owner.coupling.TryCouple(componentInParent2, location);
					}
					((FacepunchBehaviour)this).InvokeRepeating((Action)TrainContentsTick, 0.2f, 0.2f);
				}
				else
				{
					otherRigidbodyContents.Add(componentInParent);
				}
			}
			else
			{
				ITrainCollidable componentInParent3 = obj.GetComponentInParent<ITrainCollidable>();
				if (componentInParent3 == null)
				{
					if (!obj.CompareTag("Railway"))
					{
						staticContents.Add(obj);
					}
				}
				else if (!componentInParent3.EqualNetID(owner) && !componentInParent3.CustomCollision(owner, this))
				{
					staticContents.Add(obj);
				}
			}
		}
		if ((Object)(object)col != (Object)null)
		{
			colliderContents.Add(col);
		}
	}

	internal override void OnObjectRemoved(GameObject obj)
	{
		if (!owner.isServer || (Object)(object)obj == (Object)null)
		{
			return;
		}
		Collider[] components = obj.GetComponents<Collider>();
		foreach (Collider item in components)
		{
			colliderContents.Remove(item);
		}
		if (!staticContents.Remove(obj))
		{
			TrainCar componentInParent = obj.GetComponentInParent<TrainCar>();
			if ((Object)(object)componentInParent != (Object)null)
			{
				if (!HasAnotherColliderFor<TrainCar>(componentInParent))
				{
					trainContents.Remove(componentInParent);
					if (trainContents == null || trainContents.Count == 0)
					{
						((FacepunchBehaviour)this).CancelInvoke((Action)TrainContentsTick);
					}
				}
			}
			else
			{
				Rigidbody componentInParent2 = obj.GetComponentInParent<Rigidbody>();
				if (!HasAnotherColliderFor<Rigidbody>(componentInParent2))
				{
					otherRigidbodyContents.Remove(componentInParent2);
				}
			}
		}
		base.OnObjectRemoved(obj);
		bool HasAnotherColliderFor<T>(T component) where T : Component
		{
			foreach (Collider colliderContent in colliderContents)
			{
				if ((Object)(object)colliderContent != (Object)null && (Object)(object)((Component)colliderContent).GetComponentInParent<T>() == (Object)(object)component)
				{
					return true;
				}
			}
			return false;
		}
	}

	private void TrainContentsTick()
	{
		if (trainContents == null)
		{
			return;
		}
		foreach (TrainCar trainContent in trainContents)
		{
			if (trainContent.IsValid() && !trainContent.IsDestroyed && owner.coupling != null)
			{
				owner.coupling.TryCouple(trainContent, location);
			}
		}
	}
}


public enum Location
{
	Front,
	Rear
}


using System;
using UnityEngine;

[Serializable]
public class VisualCarWheel : CarWheel
{
	public Transform visualWheel;

	public Transform visualWheelSteering;

	public bool visualPowerWheel = true;

	public ParticleSystem snowFX;

	public ParticleSystem sandFX;

	public ParticleSystem dirtFX;

	public ParticleSystem asphaltFX;

	public ParticleSystem waterFX;

	public ParticleSystem snowSpinFX;

	public ParticleSystem sandSpinFX;

	public ParticleSystem dirtSpinFX;

	public ParticleSystem asphaltSpinFX;
}


using UnityEngine;

public abstract class VehicleChassisVisuals<T> : MonoBehaviour where T : BaseEntity, VehicleChassisVisuals<T>.IClientWheelUser
{
	public interface IClientWheelUser
	{
		Vector3 Velocity { get; }

		float DriveWheelVelocity { get; }

		float SteerAngle { get; }

		float MaxSteerAngle { get; }

		float GetThrottleInput();
	}
}


using UnityEngine;

public interface IClientWheelUser
{
	Vector3 Velocity { get; }

	float DriveWheelVelocity { get; }

	float SteerAngle { get; }

	float MaxSteerAngle { get; }

	float GetThrottleInput();
}


using System;
using Rust;

public interface IEngineControllerUser : IEntity
{
	bool HasFlag(BaseEntity.Flags f);

	bool IsDead();

	void SetFlag(BaseEntity.Flags f, bool b, bool recursive = false, bool networkupdate = true);

	void Invoke(Action action, float time);

	void CancelInvoke(Action action);

	void OnEngineStartFailed();

	bool MeetsEngineRequirements();
}


using System;
using Oxide.Core;
using UnityEngine;

public class VehicleEngineController<TOwner> where TOwner : BaseMountable, IEngineControllerUser
{
	public enum EngineState
	{
		Off,
		Starting,
		On
	}

	public readonly TOwner owner;

	private readonly bool isServer;

	public readonly float engineStartupTime;

	public readonly Transform waterloggedPoint;

	public readonly BaseEntity.Flags engineStartingFlag;

	public EngineState CurEngineState
	{
		get
		{
			if (owner.HasFlag(engineStartingFlag))
			{
				return EngineState.Starting;
			}
			if (owner.HasFlag(BaseEntity.Flags.On))
			{
				return EngineState.On;
			}
			return EngineState.Off;
		}
	}

	public bool IsOn => CurEngineState == EngineState.On;

	public bool IsOff => CurEngineState == EngineState.Off;

	public bool IsStarting => CurEngineState == EngineState.Starting;

	public bool IsStartingOrOn => CurEngineState != EngineState.Off;

	public IFuelSystem FuelSystem { get; private set; }

	public VehicleEngineController(TOwner owner, IFuelSystem fuelSystem, bool isServer, float engineStartupTime, Transform waterloggedPoint = null, BaseEntity.Flags engineStartingFlag = BaseEntity.Flags.Reserved1)
	{
		FuelSystem = fuelSystem;
		this.owner = owner;
		this.isServer = isServer;
		this.engineStartupTime = engineStartupTime;
		this.waterloggedPoint = waterloggedPoint;
		this.engineStartingFlag = engineStartingFlag;
	}

	public EngineState EngineStateFrom(BaseEntity.Flags flags)
	{
		if (flags.HasFlag(engineStartingFlag))
		{
			return EngineState.Starting;
		}
		if (flags.HasFlag(BaseEntity.Flags.On))
		{
			return EngineState.On;
		}
		return EngineState.Off;
	}

	public bool IsWaterlogged()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)waterloggedPoint != (Object)null)
		{
			return WaterLevel.Test(waterloggedPoint.position, waves: true, volumes: true, owner);
		}
		return false;
	}

	public void TryStartEngine(BasePlayer player)
	{
		if (isServer && !owner.IsDead() && !IsStartingOrOn && player.net != null)
		{
			if (!CanRunEngine())
			{
				owner.OnEngineStartFailed();
			}
			else if (Interface.CallHook("OnEngineStart", (object)((VehicleEngineController<>)(object)this).owner, (object)player) == null)
			{
				owner.SetFlag(engineStartingFlag, b: true);
				owner.SetFlag(BaseEntity.Flags.On, b: false);
				((FacepunchBehaviour)owner).Invoke((Action)FinishStartingEngine, engineStartupTime);
				Interface.CallHook("OnEngineStarted", (object)((VehicleEngineController<>)(object)this).owner, (object)player);
			}
		}
	}

	public void FinishStartingEngine()
	{
		if (isServer && !owner.IsDead() && !IsOn)
		{
			owner.SetFlag(BaseEntity.Flags.On, b: true);
			owner.SetFlag(engineStartingFlag, b: false);
			Interface.CallHook("OnEngineStartFinished", (object)((VehicleEngineController<>)(object)this).owner);
		}
	}

	public void StopEngine()
	{
		if (isServer && !IsOff && Interface.CallHook("OnEngineStop", (object)((VehicleEngineController<>)(object)this).owner) == null)
		{
			CancelEngineStart();
			owner.SetFlag(BaseEntity.Flags.On, b: false);
			owner.SetFlag(engineStartingFlag, b: false);
			Interface.CallHook("OnEngineStopped", (object)((VehicleEngineController<>)(object)this).owner);
		}
	}

	public void CheckEngineState()
	{
		if (IsStartingOrOn && !CanRunEngine())
		{
			StopEngine();
		}
	}

	public bool CanRunEngine()
	{
		if (owner.MeetsEngineRequirements() && FuelSystem.HasFuel() && !IsWaterlogged())
		{
			return !owner.IsDead();
		}
		return false;
	}

	public int TickFuel(float fuelPerSecond)
	{
		if (IsOn)
		{
			return FuelSystem.TryUseFuel(Time.fixedDeltaTime, fuelPerSecond);
		}
		return 0;
	}

	public void UseFuel(int amount)
	{
		FuelSystem.RemoveFuel(amount);
	}

	public void CancelEngineStart()
	{
		if (CurEngineState == EngineState.Starting)
		{
			((FacepunchBehaviour)owner).CancelInvoke((Action)FinishStartingEngine);
		}
	}
}


public enum EngineState
{
	Off,
	Starting,
	On
}


using UnityEngine;

public class VehicleTerrainHandler
{
	public enum Surface
	{
		Default,
		Road,
		Snow,
		Ice,
		Sand,
		Frictionless
	}

	public string CurGroundPhysicsMatName;

	public Surface OnSurface;

	public bool IsGrounded;

	public float RayLength = 1.5f;

	private readonly string[] TerrainRoad = new string[5] { "rock", "concrete", "gravel", "metal", "path" };

	private const float SECONDS_BETWEEN_TERRAIN_SAMPLE = 0.25f;

	private TimeSince timeSinceTerrainCheck;

	private readonly BaseVehicle vehicle;

	public bool IsOnSnowOrIce
	{
		get
		{
			if (OnSurface != Surface.Snow)
			{
				return OnSurface == Surface.Ice;
			}
			return true;
		}
	}

	public VehicleTerrainHandler(BaseVehicle vehicle)
	{
		this.vehicle = vehicle;
	}

	public void FixedUpdate()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!vehicle.IsStationary() && TimeSince.op_Implicit(timeSinceTerrainCheck) > 0.25f)
		{
			DoTerrainCheck();
		}
	}

	private void DoTerrainCheck()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		timeSinceTerrainCheck = TimeSince.op_Implicit(Random.Range(-0.025f, 0.025f));
		Transform transform = ((Component)vehicle).transform;
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(transform.position + transform.up * 0.5f, -transform.up, ref val, RayLength, 161546241, (QueryTriggerInteraction)1))
		{
			CurGroundPhysicsMatName = ((RaycastHit)(ref val)).collider.GetMaterialAt(((RaycastHit)(ref val)).point).GetNameLower();
			if (GetOnRoad(CurGroundPhysicsMatName))
			{
				OnSurface = Surface.Road;
			}
			else if (CurGroundPhysicsMatName == "snow")
			{
				if (((Component)((RaycastHit)(ref val)).collider).CompareTag("TreatSnowAsIce"))
				{
					OnSurface = Surface.Ice;
				}
				else
				{
					OnSurface = Surface.Snow;
				}
			}
			else if (CurGroundPhysicsMatName == "sand")
			{
				OnSurface = Surface.Sand;
			}
			else if (CurGroundPhysicsMatName.Contains("zero friction"))
			{
				OnSurface = Surface.Frictionless;
			}
			else
			{
				OnSurface = Surface.Default;
			}
			IsGrounded = true;
		}
		else
		{
			CurGroundPhysicsMatName = "concrete";
			OnSurface = Surface.Default;
			IsGrounded = false;
		}
	}

	private bool GetOnRoad(string physicMat)
	{
		for (int i = 0; i < TerrainRoad.Length; i++)
		{
			if (TerrainRoad[i] == physicMat)
			{
				return true;
			}
		}
		return false;
	}
}


public enum Surface
{
	Default,
	Road,
	Snow,
	Ice,
	Sand,
	Frictionless
}


public interface IPoolVehicle
{
	void OnPoolDestroyed();

	void WakeUp();
}


public class DeployGuide : BaseMonoBehaviour
{
	public static DeployGuide current;
}


using UnityEngine;

public class DeployGuideRenderer : MonoBehaviour
{
	public BaseEntity Prefab;
}


using System;
using System.Linq;
using ConVar;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class DroppedItem : WorldItem, IContainerSounds, Hopper.IHopperTarget
{
	public enum DropReasonEnum
	{
		Unknown,
		Player,
		Death,
		Loot
	}

	public class DroppedItemUnderwaterQueue : PersistentObjectWorkQueue<DroppedItem>
	{
		protected override void RunJob(DroppedItem entity)
		{
			if ((Object)(object)entity != (Object)null)
			{
				entity.CheckUnderwaterStatus(canSplash: true);
			}
		}
	}

	[Header("DroppedItem")]
	public GameObjectRef itemModel;

	public GameObjectRef splashEffect;

	[ServerVar(Help = "How many milliseconds to spend on updating underwater drag levels")]
	public static float underwater_drag_budget_ms = 0.1f;

	private const Flags FLAG_STUCK = Flags.Reserved1;

	private const Flags FLAG_UNDERWATER = Flags.Reserved2;

	public const Flags FLAG_HOPPERANIMATING = Flags.Reserved3;

	private int originalLayer = -1;

	[NonSerialized]
	public DropReasonEnum DropReason;

	[NonSerialized]
	public ulong DroppedBy;

	[NonSerialized]
	public DateTime DroppedTime;

	[NonSerialized]
	public bool NeverCombine;

	private Rigidbody rB;

	private CollisionDetectionMode originalCollisionMode;

	private Vector3 prevLocalPos;

	private const float SLEEP_CHECK_FREQUENCY = 11f;

	private const float AIR_DRAG = 0.1f;

	private const float UNDERWATER_DRAG = 7f;

	private bool hasLastPos;

	private Vector3 lastGoodColliderCentre;

	private Vector3 lastGoodPos;

	private Quaternion lastGoodRot;

	private Action cachedSleepCheck;

	private float maxBoundsExtent;

	private readonly Vector3 smallVerticalOffset = new Vector3(0f, 0.05f, 0f);

	public static DroppedItemUnderwaterQueue underwaterStatusQueue = new DroppedItemUnderwaterQueue();

	private TimeSince lastUnderwaterFlowImpulse;

	public Collider childCollider { get; private set; }

	private bool StuckInSomething => HasFlag(Flags.Reserved1);

	public SoundDefinition OpenSound
	{
		get
		{
			if (item == null)
			{
				return null;
			}
			ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
			if ((Object)(object)component == (Object)null)
			{
				return null;
			}
			return component.openSound;
		}
	}

	public SoundDefinition CloseSound
	{
		get
		{
			if (item == null)
			{
				return null;
			}
			ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
			if ((Object)(object)component == (Object)null)
			{
				return null;
			}
			return component.closeSound;
		}
	}

	public Rigidbody Rigidbody => rB;

	public int NumberOfItemsToTransfer => 1 + ((item.contents != null) ? item.contents.itemList.Count() : 0);

	public float EndPositionToleranceMultiplier => 1f;

	public bool IsSleeping
	{
		get
		{
			if ((Object)(object)rB != (Object)null)
			{
				return rB.IsSleeping();
			}
			return false;
		}
	}

	public BaseEntity ToEntity => this;

	protected override bool CanBePickedUp => !HasFlag(Flags.Reserved3);

	public void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 itemFallbackPosition)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (item == null || itemContainer == null)
		{
			return;
		}
		if (item.contents != null && item.IsBackpack())
		{
			int capacity = item.contents.capacity;
			for (int i = 0; i < capacity; i++)
			{
				if (item.contents != null)
				{
					Item slot = item.contents.GetSlot(i);
					if (slot != null && !slot.MoveToContainer(itemContainer))
					{
						slot.DropAndTossUpwards(itemFallbackPosition);
					}
				}
			}
		}
		if (item != null)
		{
			if (item.MoveToContainer(itemContainer))
			{
				RemoveItem();
			}
			else
			{
				CancelHopper();
			}
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (GetDespawnDuration() < float.PositiveInfinity)
		{
			((FacepunchBehaviour)this).Invoke((Action)IdleDestroy, GetDespawnDuration());
		}
		ReceiveCollisionMessages(b: true);
		prevLocalPos = ((Component)this).transform.localPosition;
		((PersistentObjectWorkQueue<DroppedItem>)underwaterStatusQueue).Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		((PersistentObjectWorkQueue<DroppedItem>)underwaterStatusQueue).Remove(this);
	}

	public virtual float GetDespawnDuration()
	{
		return item?.GetDespawnDuration() ?? Server.itemdespawn;
	}

	public void IdleDestroy()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		Interface.CallHook("OnItemDespawn", (object)item);
		Analytics.Azure.OnItemDespawn(this, item, (int)DropReason, DroppedBy);
		if (item != null)
		{
			BuriedItems.Instance.Register(item, ((Component)this).transform.position);
		}
		DestroyItem();
		Kill();
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (item != null && item.MaxStackable() > 1)
		{
			DroppedItem droppedItem = hitEntity as DroppedItem;
			if (!((Object)(object)droppedItem == (Object)null) && droppedItem.item != null && !((Object)(object)droppedItem.item.info != (Object)(object)item.info) && droppedItem.item.skin == item.skin)
			{
				droppedItem.OnDroppedOn(this);
			}
		}
	}

	public void OnDroppedOn(DroppedItem di)
	{
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", (object)this, (object)di) != null || (Object)(object)di.item.info != (Object)(object)item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if ((Object)(object)di.item.info != (Object)null)
		{
			if (di.item.info.amountType == ItemDefinition.AmountType.Genetics)
			{
				int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
				int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
				if (num != num2)
				{
					return;
				}
			}
			if (((Object)(object)((Component)di.item.info).GetComponent<ItemModSign>() != (Object)null && (Object)(object)ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != (Object)null) || ((Object)(object)item.info != (Object)null && (Object)(object)((Component)item.info).GetComponent<ItemModSign>() != (Object)null && (Object)(object)ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != (Object)null))
			{
				return;
			}
		}
		if (Item.BlockStackFoodItem(item, di.item))
		{
			return;
		}
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.MaxStackable() && num3 != 0)
		{
			Interface.CallHook("OnDroppedItemCombined", (object)this);
			if (di.DropReason == DropReasonEnum.Player)
			{
				DropReason = DropReasonEnum.Player;
			}
			di.item.MigrateItemOwnership(item, di.item.amount);
			di.DestroyItem();
			di.Kill();
			int worldModelIndex = item.info.GetWorldModelIndex(item.amount);
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				((FacepunchBehaviour)this).Invoke((Action)IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			int worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);
			if (worldModelIndex != worldModelIndex2)
			{
				item.Drop(((Component)this).transform.position, Vector3.zero, ((Component)this).transform.rotation);
			}
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		if ((Object)(object)newParent != (Object)null && (Object)(object)newParent != (Object)(object)oldParent)
		{
			OnParented();
		}
		else if ((Object)(object)newParent == (Object)null && (Object)(object)oldParent != (Object)null)
		{
			OnUnparented();
		}
	}

	internal override void OnParentRemoved()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rB == (Object)null)
		{
			base.OnParentRemoved();
			return;
		}
		Vector3 val = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		SetParent(null);
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val + Vector3.up * 2f, Vector3.down, ref val2, 2f, 161546240) && val.y < ((RaycastHit)(ref val2)).point.y)
		{
			val += Vector3.up * 1.5f;
		}
		((Component)this).transform.position = val;
		((Component)this).transform.rotation = rotation;
		Unstick();
		if (GetDespawnDuration() < float.PositiveInfinity)
		{
			((FacepunchBehaviour)this).Invoke((Action)IdleDestroy, GetDespawnDuration());
		}
	}

	public void StickIn()
	{
		SetFlag(Flags.Reserved1, b: true);
	}

	public void Unstick()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	private void SleepCheck()
	{
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (!HasParent() || StuckInSomething)
		{
			return;
		}
		if (rB.isKinematic)
		{
			if (maxBoundsExtent == 0f)
			{
				float num;
				if (!((Object)(object)childCollider != (Object)null))
				{
					num = Vector3Ex.Max(((Bounds)(ref bounds)).extents);
				}
				else
				{
					Bounds val = childCollider.bounds;
					num = Vector3Ex.Max(((Bounds)(ref val)).extents);
				}
				maxBoundsExtent = num;
			}
			if (!GamePhysics.Trace(new Ray(CenterPoint(), Vector3.down), 0f, out var _, maxBoundsExtent + 0.1f, -928830719, (QueryTriggerInteraction)1, this))
			{
				BecomeActive();
			}
		}
		else if (Vector3.SqrMagnitude(((Component)this).transform.localPosition - prevLocalPos) < 0.075f)
		{
			BecomeInactive();
		}
		prevLocalPos = ((Component)this).transform.localPosition;
	}

	private void OnPhysicsNeighbourChanged()
	{
		if (!StuckInSomething)
		{
			BecomeActive();
		}
	}

	public override void OnPositionalNetworkUpdate()
	{
		base.OnPositionalNetworkUpdate();
		if (!HasFlag(Flags.Reserved3))
		{
			CheckValidPosition();
		}
	}

	protected override bool ShouldUpdateNetworkPosition()
	{
		if (syncPosition)
		{
			return !rB.isKinematic;
		}
		return false;
	}

	private void CheckValidPosition()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)rB != (Object)null) || !((Object)(object)childCollider != (Object)null))
		{
			return;
		}
		Bounds val = childCollider.bounds;
		Vector3 val2 = ((Bounds)(ref val)).center + smallVerticalOffset;
		Vector3 val3 = val2 - lastGoodColliderCentre;
		Ray ray = default(Ray);
		((Ray)(ref ray))..ctor(lastGoodColliderCentre, ((Vector3)(ref val3)).normalized);
		if (hasLastPos && GamePhysics.Trace(ray, 0f, out var _, ((Vector3)(ref val3)).magnitude, 1218511105, (QueryTriggerInteraction)1, this))
		{
			((Component)this).transform.position = lastGoodPos + smallVerticalOffset;
			((Component)this).transform.rotation = lastGoodRot;
			if (!rB.isKinematic)
			{
				rB.velocity = Vector3.zero;
				rB.angularVelocity = Vector3.zero;
			}
			Physics.SyncTransforms();
		}
		else
		{
			lastGoodColliderCentre = val2;
			lastGoodPos = ((Component)this).transform.position;
			lastGoodRot = ((Component)this).transform.rotation;
			hasLastPos = true;
		}
	}

	public void PrepareForHopper()
	{
		SetFlag(Flags.Reserved3, b: true);
		if ((Object)(object)childCollider != (Object)null)
		{
			childCollider.enabled = false;
		}
	}

	public void HopperCancelled()
	{
		SetFlag(Flags.Reserved3, b: false);
		if ((Object)(object)childCollider != (Object)null)
		{
			childCollider.enabled = true;
		}
	}

	public void CancelHopper()
	{
		SetFlag(Flags.Reserved3, b: false);
		if ((Object)(object)Rigidbody != (Object)null)
		{
			Rigidbody.useGravity = true;
		}
		if ((Object)(object)childCollider != (Object)null)
		{
			childCollider.enabled = true;
		}
	}

	private void OnUnparented()
	{
		if (cachedSleepCheck != null)
		{
			((FacepunchBehaviour)this).CancelInvoke(cachedSleepCheck);
		}
	}

	private void OnParented()
	{
		if ((Object)(object)childCollider == (Object)null)
		{
			return;
		}
		if (Object.op_Implicit((Object)(object)childCollider))
		{
			childCollider.enabled = false;
			((FacepunchBehaviour)this).Invoke((Action)EnableCollider, 0.1f);
		}
		if (base.isServer && !StuckInSomething)
		{
			if (cachedSleepCheck == null)
			{
				cachedSleepCheck = SleepCheck;
			}
			((FacepunchBehaviour)this).InvokeRandomized(cachedSleepCheck, 5.5f, 11f, Random.Range(-1.1f, 1.1f));
		}
	}

	public override void PostInitShared()
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		base.PostInitShared();
		GameObject val = null;
		if (item != null && item.GetWorldModel().isValid)
		{
			val = base.gameManager.CreatePrefab(item.GetWorldModel().resourcePath, ((Component)this).transform);
			val.transform.localScale = item.GetWorldModel().Get().transform.localScale;
		}
		else
		{
			val = base.gameManager.CreatePrefab(itemModel.resourcePath, ((Component)this).transform);
		}
		val.transform.localPosition = Vector3.zero;
		val.transform.localRotation = Quaternion.identity;
		val.SetLayerRecursive(((Component)this).gameObject.layer);
		childCollider = val.GetComponentInChildren<Collider>();
		if (Object.op_Implicit((Object)(object)childCollider))
		{
			childCollider.enabled = false;
			if (HasParent())
			{
				OnParented();
			}
			else
			{
				childCollider.enabled = true;
			}
			originalLayer = ((Component)childCollider).gameObject.layer;
		}
		if (base.isServer)
		{
			float angularDrag = 0.1f;
			rB = ((Component)this).gameObject.AddComponent<Rigidbody>();
			UpdateItemMass();
			rB.drag = 0.1f;
			rB.angularDrag = angularDrag;
			rB.interpolation = (RigidbodyInterpolation)0;
			rB.collisionDetectionMode = (CollisionDetectionMode)3;
			originalCollisionMode = rB.collisionDetectionMode;
			rB.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
			CheckValidPosition();
			CheckUnderwaterStatus(canSplash: false);
			UpdateUnderwaterDrag();
		}
		if (item != null)
		{
			PhysicsEffects component = ((Component)this).gameObject.GetComponent<PhysicsEffects>();
			if ((Object)(object)component != (Object)null)
			{
				component.entity = this;
				if ((Object)(object)item.info.physImpactSoundDef != (Object)null)
				{
					component.physImpactSoundDef = item.info.physImpactSoundDef;
				}
			}
			Buoyancy component2 = val.GetComponent<Buoyancy>();
			if ((Object)(object)component2 != (Object)null && base.isServer)
			{
				component2.rigidBody = rB;
			}
		}
		val.SetActive(true);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!old.HasFlag(Flags.Reserved1) && next.HasFlag(Flags.Reserved1))
		{
			BecomeInactive();
		}
		else if (old.HasFlag(Flags.Reserved1) && !next.HasFlag(Flags.Reserved1))
		{
			BecomeActive();
		}
		if (base.isServer && old.HasFlag(Flags.Reserved2) != next.HasFlag(Flags.Reserved2))
		{
			UpdateUnderwaterDrag();
		}
	}

	private void BecomeActive()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			rB.isKinematic = false;
			rB.collisionDetectionMode = originalCollisionMode;
			rB.WakeUp();
			if (HasParent())
			{
				Rigidbody component = ((Component)GetParentEntity()).GetComponent<Rigidbody>();
				if ((Object)(object)component != (Object)null)
				{
					rB.velocity = component.velocity;
					rB.angularVelocity = component.angularVelocity;
				}
			}
			prevLocalPos = ((Component)this).transform.localPosition;
		}
		if ((Object)(object)childCollider != (Object)null)
		{
			((Component)childCollider).gameObject.layer = originalLayer;
		}
	}

	private void BecomeInactive()
	{
		if (base.isServer)
		{
			rB.collisionDetectionMode = (CollisionDetectionMode)0;
			rB.isKinematic = true;
		}
		if ((Object)(object)childCollider != (Object)null)
		{
			((Component)childCollider).gameObject.layer = 19;
		}
	}

	private void EnableCollider()
	{
		if (Object.op_Implicit((Object)(object)childCollider))
		{
			childCollider.enabled = true;
		}
	}

	public void UpdateItemMass()
	{
		if ((Object)(object)rB == (Object)null)
		{
			rB = ((Component)this).GetComponent<Rigidbody>();
		}
		if ((Object)(object)rB == (Object)null || item == null || item.contents?.itemList == null)
		{
			return;
		}
		float num = item.info.GetWorldModelMass();
		ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
		if ((Object)(object)component != (Object)null)
		{
			_ = component.worldWeightScale;
		}
		foreach (Item item in item.contents.itemList)
		{
			num += item.info.GetWorldModelMass() * component.worldWeightScale;
		}
		if ((Object)(object)component != (Object)null && component.maxWeight > 0f)
		{
			num = Mathf.Min(component.maxWeight, num);
		}
		rB.mass = num;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved3, b: false);
	}

	public override bool ShouldInheritNetworkGroup()
	{
		return false;
	}

	private void CheckUnderwaterStatus(bool canSplash)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		bool flag = WaterLevel.Test(((Component)this).transform.position, waves: false, volumes: true, this);
		if (canSplash && flag && !HasFlag(Flags.Reserved2) && splashEffect.isValid)
		{
			Effect.server.Run(splashEffect.resourcePath, ((Component)this).transform.position, Vector3.zero);
		}
		SetFlag(Flags.Reserved2, flag);
		if (flag && (Object)(object)rB != (Object)null && !rB.IsSleeping() && TimeSince.op_Implicit(lastUnderwaterFlowImpulse) > 1f)
		{
			lastUnderwaterFlowImpulse = TimeSince.op_Implicit(0f - Random.Range(0f, 1f));
			rB.AddForceAtPosition(Random.onUnitSphere, ((Component)this).transform.position + Random.onUnitSphere * 3f, (ForceMode)1);
		}
	}

	private void UpdateUnderwaterDrag()
	{
		if ((Object)(object)rB != (Object)null)
		{
			rB.drag = (HasFlag(Flags.Reserved2) ? 7f : 0.1f);
		}
	}
}


public enum DropReasonEnum
{
	Unknown,
	Player,
	Death,
	Loot
}


using UnityEngine;

public class DroppedItemUnderwaterQueue : PersistentObjectWorkQueue<DroppedItem>
{
	protected override void RunJob(DroppedItem entity)
	{
		if ((Object)(object)entity != (Object)null)
		{
			entity.CheckUnderwaterStatus(canSplash: true);
		}
	}
}


using Rust;

public class ItemPickup : DroppedItem
{
	public ItemDefinition itemDef;

	public int amount = 1;

	public ulong skinOverride;

	public override float GetDespawnDuration()
	{
		return float.PositiveInfinity;
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			Item item = ItemManager.Create(itemDef, amount, skinOverride);
			InitializeItem(item);
			item.SetWorldEntity(this);
		}
	}

	internal override void DoServerDestroy()
	{
		if (item != null)
		{
			item.Remove();
			item = null;
		}
		base.DoServerDestroy();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		IdleDestroy();
	}

	public override void TryApplyOwnershipOnPickup(BasePlayer player, Item item)
	{
		item.SetItemOwnership(player, ItemOwnershipPhrases.LootedPhrase);
	}
}


using UnityEngine;

public class ANDSwitch : IOEntity
{
	private int input1Amount;

	private int input2Amount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		if (input1Amount == 0 || input2Amount == 0)
		{
			return false;
		}
		if (input1Amount == input2Amount)
		{
			return inputIndex == 0;
		}
		int num = ((input1Amount <= input2Amount) ? 1 : 0);
		return inputIndex == num;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (input1Amount <= 0 || input2Amount <= 0)
		{
			return 0;
		}
		return Mathf.Max(input1Amount, input2Amount);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		switch (slot)
		{
		case 0:
			input1Amount = inputAmount;
			break;
		case 1:
			input2Amount = inputAmount;
			break;
		}
		int num = ((input1Amount > 0 && input2Amount > 0) ? (input1Amount + input2Amount) : 0);
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 && input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
		base.UpdateFromInput(inputAmount, slot);
	}
}


public interface ISubscribable
{
	bool AddSubscription(ulong steamId);

	bool RemoveSubscription(ulong steamId);

	bool HasSubscription(ulong steamId);
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class StorageMonitor : AppIOEntity
{
	public readonly Action<Item, bool> _onItemAddedRemoved;

	private readonly Action<Item, int> _onItemAddedToStack;

	private readonly Action<Item, int> _onItemRemovedFromStack;

	private readonly Action _resetSwitchHandler;

	private double _lastPowerOnUpdate;

	public override AppEntityType Type => (AppEntityType)3;

	public override bool Value
	{
		get
		{
			return IsOn();
		}
		set
		{
		}
	}

	public StorageMonitor()
	{
		_onItemAddedRemoved = OnItemAddedRemoved;
		_onItemAddedToStack = OnItemAddedToStack;
		_onItemRemovedFromStack = OnItemRemovedFromStack;
		_resetSwitchHandler = ResetSwitch;
	}

	internal override void FillEntityPayload(AppEntityPayload payload)
	{
		base.FillEntityPayload(payload);
		StorageContainer storageContainer = GetStorageContainer();
		ContainerIOEntity containerIOEntity = GetContainerIOEntity();
		if (((Object)(object)storageContainer == (Object)null && (Object)(object)containerIOEntity == (Object)null) || !HasFlag(Flags.Reserved8))
		{
			return;
		}
		payload.items = Pool.Get<List<Item>>();
		ItemContainer inventory = GetInventory();
		if (inventory == null)
		{
			return;
		}
		foreach (Item item in inventory.itemList)
		{
			Item val = Pool.Get<Item>();
			val.itemId = (item.IsBlueprint() ? item.blueprintTargetDef.itemid : item.info.itemid);
			val.quantity = item.amount;
			val.itemIsBlueprint = item.IsBlueprint();
			payload.items.Add(val);
		}
		payload.capacity = inventory.capacity;
		if ((Object)(object)storageContainer != (Object)null && storageContainer is BuildingPrivlidge buildingPrivlidge)
		{
			payload.hasProtection = true;
			float protectedMinutes = buildingPrivlidge.GetProtectedMinutes();
			if (protectedMinutes > 0f)
			{
				payload.protectionExpiry = (uint)DateTimeOffset.UtcNow.AddMinutes(protectedMinutes).ToUnixTimeSeconds();
			}
		}
	}

	public override void Init()
	{
		base.Init();
		ItemContainer inventory = GetInventory();
		if (inventory != null)
		{
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, _onItemAddedRemoved);
			inventory.onItemAddedToStack = (Action<Item, int>)Delegate.Combine(inventory.onItemAddedToStack, _onItemAddedToStack);
			inventory.onItemRemovedFromStack = (Action<Item, int>)Delegate.Combine(inventory.onItemRemovedFromStack, _onItemRemovedFromStack);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		ItemContainer inventory = GetInventory();
		if (inventory != null)
		{
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Remove(inventory.onItemAddedRemoved, _onItemAddedRemoved);
			inventory.onItemAddedToStack = (Action<Item, int>)Delegate.Remove(inventory.onItemAddedToStack, _onItemAddedToStack);
			inventory.onItemRemovedFromStack = (Action<Item, int>)Delegate.Remove(inventory.onItemRemovedFromStack, _onItemRemovedFromStack);
		}
	}

	private StorageContainer GetStorageContainer()
	{
		return GetParentEntity() as StorageContainer;
	}

	private ContainerIOEntity GetContainerIOEntity()
	{
		return GetParentEntity() as ContainerIOEntity;
	}

	private ItemContainer GetInventory()
	{
		StorageContainer storageContainer = GetStorageContainer();
		ContainerIOEntity containerIOEntity = GetContainerIOEntity();
		if ((Object)(object)storageContainer == (Object)null && (Object)(object)containerIOEntity != (Object)null && containerIOEntity.inventory != null)
		{
			return containerIOEntity.inventory;
		}
		if ((Object)(object)storageContainer != (Object)null && storageContainer.inventory != null && (Object)(object)containerIOEntity == (Object)null)
		{
			return storageContainer.inventory;
		}
		return null;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		switch (outputSlot)
		{
		case 0:
			if (!IsOn())
			{
				return 0;
			}
			return Mathf.Min(1, GetCurrentEnergy());
		case 1:
		{
			int num = GetCurrentEnergy();
			if (!IsOn())
			{
				return num;
			}
			return num - 1;
		}
		default:
			return 0;
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		bool flag = HasFlag(Flags.Reserved8);
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputSlot == 0)
		{
			bool num = inputAmount >= ConsumptionAmount();
			double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
			if (num && !flag && _lastPowerOnUpdate < realtimeSinceStartup - 1.0)
			{
				_lastPowerOnUpdate = realtimeSinceStartup;
				BroadcastValueChange();
			}
		}
	}

	private void OnItemAddedRemoved(Item item, bool added)
	{
		OnContainerChanged();
	}

	private void OnItemAddedToStack(Item item, int amount)
	{
		OnContainerChanged();
	}

	private void OnItemRemovedFromStack(Item item, int amount)
	{
		OnContainerChanged();
	}

	public void OnContainerChanged()
	{
		if (HasFlag(Flags.Reserved8))
		{
			((FacepunchBehaviour)this).Invoke(_resetSwitchHandler, 0.5f);
			if (!IsOn())
			{
				SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
				SendNetworkUpdate_Flags();
				MarkDirty();
				BroadcastValueChange();
			}
		}
	}

	private void ResetSwitch()
	{
		SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		MarkDirty();
		BroadcastValueChange();
	}
}


using System;
using UnityEngine;

public static class DigitalClockEx
{
	public static TimeSpan ToTimeSpan(this float value)
	{
		int num = Mathf.RoundToInt(value * 60f);
		int hours = num / 60;
		int minutes = num % 60;
		return new TimeSpan(hours, minutes, 0);
	}

	public static float ToFloat(this TimeSpan timeSpan)
	{
		int hours = timeSpan.Hours;
		float num = (float)timeSpan.Minutes / 60f;
		return (float)hours + num;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class DoorManipulator : IOEntity
{
	public enum DoorEffect
	{
		Close,
		Open,
		Toggle
	}

	public EntityRef entityRef;

	public Door targetDoor;

	public DoorEffect powerAction;

	private bool toggle = true;

	public virtual bool CanPairWithLockedDoors()
	{
		return true;
	}

	public override void Init()
	{
		base.Init();
		SetupInitialDoorConnection();
	}

	public virtual void SetupInitialDoorConnection()
	{
		if ((Object)(object)targetDoor == (Object)null && !entityRef.IsValid(serverside: true))
		{
			SetTargetDoor(FindDoor(CanPairWithLockedDoors()));
		}
		if ((Object)(object)targetDoor != (Object)null && !entityRef.IsValid(serverside: true))
		{
			entityRef.Set(targetDoor);
		}
		if (entityRef.IsValid(serverside: true) && (Object)(object)targetDoor == (Object)null)
		{
			SetTargetDoor(((Component)entityRef.Get(serverside: true)).GetComponent<Door>());
		}
	}

	public virtual void SetTargetDoor(Door newTargetDoor)
	{
		Door door = targetDoor;
		targetDoor = newTargetDoor;
		SetFlag(Flags.On, (Object)(object)targetDoor != (Object)null);
		entityRef.Set(newTargetDoor);
		if ((Object)(object)door != (Object)(object)targetDoor && (Object)(object)targetDoor != (Object)null)
		{
			DoAction(powerAction);
		}
	}

	public virtual Door FindDoor(bool allowLocked = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		List<Door> list = Pool.Get<List<Door>>();
		Vis.Entities(((Component)this).transform.position, 1f, list, 2097152, (QueryTriggerInteraction)1);
		Door result = null;
		float num = float.PositiveInfinity;
		foreach (Door item in list)
		{
			if (!item.isServer)
			{
				continue;
			}
			if (!allowLocked)
			{
				BaseLock baseLock = item.GetSlot(Slot.Lock) as BaseLock;
				if ((Object)(object)baseLock != (Object)null && baseLock.IsLocked())
				{
					continue;
				}
			}
			if (!item.IsOnMovingObject())
			{
				float num2 = Vector3.Distance(((Component)item).transform.position, ((Component)this).transform.position);
				if (num2 < num)
				{
					result = item;
					num = num2;
				}
			}
		}
		Pool.FreeUnmanaged<Door>(ref list);
		return result;
	}

	public virtual void DoActionDoorMissing()
	{
		SetTargetDoor(FindDoor(CanPairWithLockedDoors()));
	}

	public virtual void DoAction(DoorEffect action)
	{
		bool flag = IsPowered();
		if ((Object)(object)targetDoor == (Object)null)
		{
			DoActionDoorMissing();
		}
		if (!((Object)(object)targetDoor != (Object)null))
		{
			return;
		}
		if (targetDoor.IsBusy())
		{
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				DoAction(action);
			}, 1f);
		}
		else if (action == DoorEffect.Open)
		{
			if (flag)
			{
				if (!targetDoor.IsOpen())
				{
					targetDoor.SetOpen(open: true);
				}
			}
			else if (targetDoor.IsOpen())
			{
				targetDoor.SetOpen(open: false);
			}
		}
		else if (action == DoorEffect.Close)
		{
			if (flag)
			{
				if (targetDoor.IsOpen())
				{
					targetDoor.SetOpen(open: false);
				}
			}
			else if (!targetDoor.IsOpen())
			{
				targetDoor.SetOpen(open: true);
			}
		}
		else if (action == DoorEffect.Toggle)
		{
			if (flag && toggle)
			{
				targetDoor.SetOpen(!targetDoor.IsOpen());
				toggle = false;
			}
			else if (!toggle)
			{
				toggle = true;
			}
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		DoAction(powerAction);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity.genericEntRef1 = entityRef.uid;
		info.msg.ioEntity.genericInt1 = (int)powerAction;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			entityRef.uid = info.msg.ioEntity.genericEntRef1;
			powerAction = (DoorEffect)info.msg.ioEntity.genericInt1;
		}
	}
}


public enum DoorEffect
{
	Close,
	Open,
	Toggle
}


using System;

public class DummySwitch : IOEntity
{
	public string listenString = "";

	public string listenStringOff = "";

	public float duration = -1f;

	public override bool WantsPower(int inputIndex)
	{
		return IsOn();
	}

	public override void ResetIOState()
	{
		SetFlag(Flags.On, b: false);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsOn())
		{
			return 0;
		}
		return GetCurrentEnergy();
	}

	public void SetOn(bool wantsOn)
	{
		SetFlag(Flags.On, wantsOn);
		MarkDirty();
		if (IsOn() && duration != -1f)
		{
			((FacepunchBehaviour)this).Invoke((Action)SetOff, duration);
		}
	}

	public void SetOff()
	{
		SetOn(wantsOn: false);
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == listenString)
		{
			if (IsOn())
			{
				SetOn(wantsOn: false);
			}
			SetOn(wantsOn: true);
		}
		else if (msg == listenStringOff && listenStringOff != "" && IsOn())
		{
			SetOn(wantsOn: false);
		}
	}
}


using UnityEngine;

public class ElectricFurnaceIO : IOEntity, IIndustrialStorage
{
	public int PowerConsumption = 3;

	public ItemContainer Container => GetParentOven().inventory;

	public BaseEntity IndustrialEntity => this;

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if ((Object)(object)GetParentEntity() == (Object)null)
		{
			return 0;
		}
		if (!GetParentEntity().IsOn())
		{
			return 0;
		}
		return PowerConsumption;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		ElectricOven parentOven = GetParentOven();
		if (!((Object)(object)parentOven == (Object)null))
		{
			if (inputAmount > 0)
			{
				parentOven.StartCooking();
			}
			else
			{
				parentOven.StopCooking();
			}
		}
	}

	private ElectricOven GetParentOven()
	{
		return GetParentEntity() as ElectricOven;
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i(1, 2);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i(3, 5);
	}

	public void OnStorageItemTransferBegin()
	{
	}

	public void OnStorageItemTransferEnd()
	{
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ElectricGenerator : IOEntity
{
	public float electricAmount = 8f;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int MaximalPowerOutput()
	{
		return Mathf.FloorToInt(electricAmount);
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetCurrentEnergy()
	{
		return (int)electricAmount;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return GetCurrentEnergy();
	}

	public override void UpdateOutputs()
	{
		currentEnergy = GetCurrentEnergy();
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().UpdateFromInput(currentEnergy, iOSlot.connectedToSlot);
			}
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		((FacepunchBehaviour)this).Invoke((Action)ForcePuzzleReset, 4f);
	}

	private void ForcePuzzleReset()
	{
		PuzzleReset component = ((Component)this).GetComponent<PuzzleReset>();
		if ((Object)(object)component != (Object)null)
		{
			component.DoReset();
			component.ResetTimer();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			return;
		}
		PuzzleReset component = ((Component)this).GetComponent<PuzzleReset>();
		if (Object.op_Implicit((Object)(object)component))
		{
			info.msg.puzzleReset = Pool.Get<PuzzleReset>();
			info.msg.puzzleReset.playerBlocksReset = component.playersBlockReset;
			if ((Object)(object)component.playerDetectionOrigin != (Object)null)
			{
				info.msg.puzzleReset.playerDetectionOrigin = component.playerDetectionOrigin.position;
			}
			info.msg.puzzleReset.playerDetectionRadius = component.playerDetectionRadius;
			info.msg.puzzleReset.scaleWithServerPopulation = component.scaleWithServerPopulation;
			info.msg.puzzleReset.timeBetweenResets = component.timeBetweenResets;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (!info.fromDisk || info.msg.puzzleReset == null)
		{
			return;
		}
		PuzzleReset component = ((Component)this).GetComponent<PuzzleReset>();
		if ((Object)(object)component != (Object)null)
		{
			component.playersBlockReset = info.msg.puzzleReset.playerBlocksReset;
			if ((Object)(object)component.playerDetectionOrigin != (Object)null)
			{
				component.playerDetectionOrigin.position = info.msg.puzzleReset.playerDetectionOrigin;
			}
			component.playerDetectionRadius = info.msg.puzzleReset.playerDetectionRadius;
			component.scaleWithServerPopulation = info.msg.puzzleReset.scaleWithServerPopulation;
			component.timeBetweenResets = info.msg.puzzleReset.timeBetweenResets;
			component.ResetTimer();
		}
	}
}


public class ElevatorIOEntity : IOEntity
{
	public int Consumption = 5;

	public override int ConsumptionAmount()
	{
		return Consumption;
	}
}


using System;
using UnityEngine;

public class FluidSwitch : ElectricSwitch
{
	private Flags Flag_PumpPowered = Flags.Reserved6;

	public Animator PumpAnimator;

	private bool pumpEnabled;

	private int lastToggleInput;

	public override bool IsGravitySource => true;

	protected override bool DisregardGravityRestrictionsOnLiquid => HasFlag(Flag_PumpPowered);

	public override void ResetState()
	{
		base.ResetState();
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		if (inputSlot == 1 && lastToggleInput != inputAmount)
		{
			lastToggleInput = inputAmount;
			SetSwitch(inputAmount > 0);
		}
		if (inputSlot == 2)
		{
			bool num = pumpEnabled;
			pumpEnabled = inputAmount > 0;
			if (num != pumpEnabled)
			{
				lastPassthroughEnergy = -1;
				SetFlag(Flag_PumpPowered, pumpEnabled);
				SendChangedToRoot(forceUpdate: true);
			}
		}
	}

	public override void SetSwitch(bool wantsOn)
	{
		base.SetSwitch(wantsOn);
		((FacepunchBehaviour)this).Invoke((Action)DelayedSendChanged, IOEntity.responsetime * 2f);
	}

	private void DelayedSendChanged()
	{
		SendChangedToRoot(forceUpdate: true);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot == 0)
		{
			if (!IsOn())
			{
				return 0;
			}
			return GetCurrentEnergy();
		}
		return 0;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement = false)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (!forPlacement && !IsOn())
		{
			return false;
		}
		return base.AllowLiquidPassthrough(fromSource, sourceWorldPosition);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class Fridge : ContainerIOEntity, IFoodSpoilModifier
{
	public ItemCategory OnlyAcceptCategory = ItemCategory.All;

	public List<ItemDefinition> IncludedItems = new List<ItemDefinition>();

	public int PowerConsumption = 5;

	public bool isLockable;

	[Range(0f, 1f)]
	public float PoweredFoodSpoilageRateMultiplier = 0.1f;

	public float GetSpoilMultiplier(Item arg)
	{
		if (IsPowered())
		{
			return PoweredFoodSpoilageRateMultiplier;
		}
		return 1f;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.canAcceptItem = CanAcceptItem;
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		if (OnlyAcceptCategory == ItemCategory.All)
		{
			return true;
		}
		if (item.info.category != OnlyAcceptCategory)
		{
			return IsItemInAcceptedList(item);
		}
		return true;
	}

	private bool IsItemInAcceptedList(Item item)
	{
		foreach (ItemDefinition includedItem in IncludedItems)
		{
			if ((Object)(object)item.info == (Object)(object)includedItem)
			{
				return true;
			}
		}
		return false;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	private bool CanOpenLootPanel(BasePlayer player)
	{
		if (!CanBeLooted(player))
		{
			return false;
		}
		BaseLock @lock = GetLock();
		if ((Object)(object)@lock != (Object)null && !@lock.OnTryToOpen(player))
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
			return false;
		}
		return true;
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (!CanOpenLootPanel(player))
		{
			return false;
		}
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if ((Object)(object)GetSlot(Slot.Lock) != (Object)null)
		{
			lastPickupError = Phrase.op_Implicit(string.Format(PickupErrors.ItemHasLock.translated, pickup.itemTarget.displayName.translated));
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public override bool HasSlot(Slot slot)
	{
		if (isLockable && slot == Slot.Lock)
		{
			return true;
		}
		return base.HasSlot(slot);
	}
}


public class FuseBox : IOEntity
{
	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		SetFlag(Flags.On, IsPowered());
	}
}


using UnityEngine;

public class ORSwitch : IOEntity
{
	private int input1Amount;

	private int input2Amount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		if (IsFlickering())
		{
			return true;
		}
		if (input1Amount == 0 && input2Amount == 0)
		{
			return false;
		}
		if (input1Amount == input2Amount)
		{
			return inputIndex == 0;
		}
		int num = ((input1Amount <= input2Amount) ? 1 : 0);
		return inputIndex == num;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int num = Mathf.Max(input1Amount, input2Amount);
		return Mathf.Max(0, num);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		if (IsConnectedTo(this, slot, IOEntity.backtracking))
		{
			inputAmount = 0;
		}
		switch (slot)
		{
		case 0:
			input1Amount = inputAmount;
			break;
		case 1:
			input2Amount = inputAmount;
			break;
		}
		int num = input1Amount + input2Amount;
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
		base.UpdateFromInput(inputAmount, slot);
	}
}


public class PressButton_TrainTunnel : PressButton
{
}


public class SimpleLight : IOEntity
{
	public override void ResetIOState()
	{
		base.ResetIOState();
		if (IsOn())
		{
			SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		bool num = IsOn();
		bool flag = IsPowered();
		if (num != flag)
		{
			SetFlag(Flags.On, flag, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}
}


using UnityEngine;

public class Splitter : IOEntity
{
	public override bool BlockFluidDraining => true;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot < 0 || outputSlot >= outputs.Length)
		{
			return 0;
		}
		IOEntity iOEntity = outputs[outputSlot].connectedTo.Get();
		if ((Object)(object)iOEntity == (Object)null || iOEntity.IsDestroyed)
		{
			return 0;
		}
		int num = ((cachedOutputsUsed == 0) ? 1 : cachedOutputsUsed);
		int num2 = GetCurrentEnergy();
		int num3 = num2 / num;
		int num4 = 0;
		for (int i = 0; i < outputs.Length; i++)
		{
			if (!((Object)(object)outputs[i].connectedTo.Get() != (Object)null) || outputs[i].connectedTo.Get().IsDestroyed)
			{
				continue;
			}
			if (outputSlot == i)
			{
				if (num4 < num2 % num)
				{
					return num3 + 1;
				}
				return num3;
			}
			num4++;
		}
		return 0;
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public override void OnCircuitChanged(bool forceUpdate)
	{
		MarkDirtyForceUpdateOutputs();
	}
}


using System;
using UnityEngine;

public class XORSwitch : IOEntity
{
	private int input1Amount;

	private int input2Amount;

	private bool input1Set;

	private bool input2Set;

	private bool firstRun = true;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		if (input1Amount != 0)
		{
			return input2Amount == 0;
		}
		return true;
	}

	public override void ResetState()
	{
		base.ResetState();
		input1Set = false;
		input2Set = false;
		firstRun = true;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if ((HasFlag(Flags.Reserved1) && !input1Set) || (HasFlag(Flags.Reserved2) && !input2Set))
		{
			return 0;
		}
		if (input1Amount > 0 && input2Amount > 0)
		{
			return 0;
		}
		int num = Mathf.Max(input1Amount, input2Amount);
		return Mathf.Max(0, num);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		if (inputAmount > 0 && IsConnectedTo(this, slot, IOEntity.backtracking))
		{
			inputAmount = 0;
			SetFlag(Flags.Reserved7, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved7, b: false);
		}
		switch (slot)
		{
		case 0:
			input1Set = true;
			input1Amount = inputAmount;
			break;
		case 1:
			input2Set = true;
			input2Amount = inputAmount;
			break;
		}
		if (firstRun)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdateFlags))
			{
				((FacepunchBehaviour)this).Invoke((Action)UpdateFlags, 0.1f);
			}
		}
		else
		{
			UpdateFlags();
		}
		firstRun = false;
		base.UpdateFromInput(inputAmount, slot);
	}

	private void UpdateFlags()
	{
		int num = ((input1Amount <= 0 || input2Amount <= 0) ? Mathf.Max(input1Amount, input2Amount) : 0);
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class Hopper : IndustrialEntity, IIndustrialStorage
{
	public enum MountType
	{
		Flat,
		Barrel
	}

	private struct HopperMove : IEqualityComparer<HopperMove>
	{
		public IHopperTarget Target;

		public TimeSince Duration;

		public bool Equals(HopperMove x, HopperMove y)
		{
			return object.Equals(x.Target, y.Target);
		}

		public int GetHashCode(HopperMove obj)
		{
			return HashCode.Combine(obj.Target);
		}
	}

	[BurstCompile]
	private struct FillRaycastJob : IJobParallelFor
	{
		[ReadOnly]
		public NativeArray<Vector3> points;

		public NativeArray<RaycastCommand> commands;

		public Vector3 originPoint;

		public int layerMask;

		public void Execute(int index)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = points[index];
			if (!(val == Vector3.zero))
			{
				ref NativeArray<RaycastCommand> reference = ref commands;
				Vector3 val2 = originPoint - val;
				reference[index] = new RaycastCommand(val, ((Vector3)(ref val2)).normalized, Vector3.Distance(val, originPoint), layerMask, 1);
			}
		}
	}

	public class HopperAnimationWorkQueue : PersistentObjectWorkQueue<Hopper>
	{
		protected override void RunJob(Hopper entity)
		{
			entity.MovingItemsTick();
		}
	}

	public interface IHopperTarget
	{
		BaseEntity ToEntity { get; }

		Rigidbody Rigidbody { get; }

		int NumberOfItemsToTransfer { get; }

		float EndPositionToleranceMultiplier { get; }

		void PrepareForHopper();

		void HopperCancelled();

		void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 fallbackWorldPos);
	}

	public TriggerEnterTimer ItemTrigger;

	public Transform ItemMoveTarget;

	public float ItemMoveSpeed = 2f;

	public AnimationCurve ItemHeightChangeSpeed;

	private const float MoveRate = 1f / 60f;

	public AnimationCurve ItemHeightCurve;

	public AnimationCurve ItemSpeedMultiplierCurve;

	public AnimationCurve ItemRotationSpeed;

	public GameObjectRef BloodSpray;

	public bool DebugMode;

	public const Flags MovingItems = Flags.Reserved1;

	public const Flags StandardMount = Flags.Reserved2;

	public const Flags BarrelMount = Flags.Reserved3;

	public Transform RaycastOriginPoint;

	private Action queueScanAction;

	private HashSet<HopperMove> movingItems = new HashSet<HopperMove>();

	private BaseEntity _cachedParent;

	private ItemContainer cachedContainer;

	private Predicate<HopperMove> cachedCheckNull;

	private Predicate<HopperMove> cachedRemove;

	private IHopperTarget matchCheck;

	public static HopperAnimationWorkQueue WorkQueue = new HopperAnimationWorkQueue();

	public BaseEntity cachedParent
	{
		get
		{
			if ((Object)(object)_cachedParent == (Object)null)
			{
				_cachedParent = GetParentEntity();
			}
			return _cachedParent;
		}
	}

	public ItemContainer Container
	{
		get
		{
			if (cachedContainer == null)
			{
				cachedContainer = (cachedParent as StorageContainer)?.inventory;
			}
			return cachedContainer;
		}
	}

	public BaseEntity IndustrialEntity => this;

	public override int ConsumptionAmount()
	{
		return 8;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		return 8;
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public void OnStorageItemTransferBegin()
	{
	}

	public void OnStorageItemTransferEnd()
	{
	}

	private void ScanForItemsTick()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		if (ItemTrigger.HasAnyEntityContents && TimeSince.op_Implicit(ItemTrigger.EnterTime) > 0.5f)
		{
			Vector3 position = RaycastOriginPoint.position;
			int num = 128;
			NativeArray<RaycastCommand> val = default(NativeArray<RaycastCommand>);
			val..ctor(num, (Allocator)3, (NativeArrayOptions)1);
			NativeArray<RaycastHit> val2 = default(NativeArray<RaycastHit>);
			val2..ctor(num, (Allocator)3, (NativeArrayOptions)1);
			NativeArray<Vector3> points = default(NativeArray<Vector3>);
			points..ctor(num, (Allocator)3, (NativeArrayOptions)1);
			List<IHopperTarget> list = Pool.Get<List<IHopperTarget>>();
			int num2 = 0;
			int count = movingItems.Count;
			foreach (BaseEntity entityContent in ItemTrigger.entityContents)
			{
				if (entityContent is IHopperTarget hopperTarget && hopperTarget.ToEntity.isServer)
				{
					if (entityContent is DroppedItem droppedItem && !droppedItem.HasFlag(Flags.Reserved3) && Container.QuickIndustrialPreCheck(droppedItem.item, new Vector2i(0, Container.capacity - 1), count, out var _))
					{
						Vector3 val3 = ((Component)droppedItem).transform.position;
						if ((Object)(object)droppedItem.childCollider != (Object)null)
						{
							Bounds val4 = droppedItem.childCollider.bounds;
							val3 = ((Bounds)(ref val4)).center;
						}
						points[num2++] = val3;
						list.Add(hopperTarget);
					}
					else if (entityContent is BaseCorpse baseCorpse && !baseCorpse.HasFlag(Flags.Reserved1))
					{
						Vector3 position2 = ((Component)baseCorpse).transform.position;
						points[num2++] = position2;
						list.Add(hopperTarget);
					}
				}
				if (list.Count == num)
				{
					break;
				}
			}
			FillRaycastJob fillRaycastJob = default(FillRaycastJob);
			fillRaycastJob.originPoint = position;
			fillRaycastJob.points = points;
			fillRaycastJob.commands = val;
			fillRaycastJob.layerMask = 2097152;
			JobHandle val5 = IJobParallelForExtensions.Schedule<FillRaycastJob>(fillRaycastJob, num2, 6, default(JobHandle));
			val5 = RaycastCommand.ScheduleBatch(val, val2, 1, 1, val5);
			((JobHandle)(ref val5)).Complete();
			for (int i = 0; i < num2; i++)
			{
				RaycastHit val6 = val2[i];
				IHopperTarget hopperTarget2 = list[i];
				if ((Object)(object)((RaycastHit)(ref val6)).collider == (Object)null && movingItems.Add(new HopperMove
				{
					Target = hopperTarget2,
					Duration = TimeSince.op_Implicit(0f)
				}))
				{
					hopperTarget2.PrepareForHopper();
					if ((Object)(object)hopperTarget2.Rigidbody != (Object)null)
					{
						hopperTarget2.Rigidbody.useGravity = false;
						hopperTarget2.Rigidbody.velocity = Vector3.zero;
						hopperTarget2.Rigidbody.angularVelocity = Vector3.zero;
					}
					if (Server.hopperAnimationBudgetMs <= 0f)
					{
						IntakeItem(hopperTarget2);
					}
					break;
				}
			}
			val.Dispose();
			val2.Dispose();
			points.Dispose();
			Pool.FreeUnmanaged<IHopperTarget>(ref list);
		}
		SetFlag(Flags.Reserved1, movingItems.Count > 0);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			bool flag = next.HasFlag(Flags.Reserved8) || DebugMode;
			if (!((FacepunchBehaviour)this).IsInvoking(queueScanAction) && flag)
			{
				((FacepunchBehaviour)this).InvokeRepeating(queueScanAction, 0.5f, 0.5f);
			}
			else if (((FacepunchBehaviour)this).IsInvoking(queueScanAction) && !flag)
			{
				((FacepunchBehaviour)this).CancelInvoke(queueScanAction);
			}
			bool flag2 = next.HasFlag(Flags.Reserved1);
			if (!((PersistentObjectWorkQueue<Hopper>)WorkQueue).Contains(this) && flag2)
			{
				((PersistentObjectWorkQueue<Hopper>)WorkQueue).Add(this);
			}
			else if (((PersistentObjectWorkQueue<Hopper>)WorkQueue).Contains(this) && !flag2)
			{
				((PersistentObjectWorkQueue<Hopper>)WorkQueue).Remove(this);
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		queueScanAction = QueueScan;
		if (DebugMode)
		{
			OnFlagsChanged(flags, flags);
		}
	}

	internal override void DoServerDestroy()
	{
		if (HasFlag(Flags.Reserved1))
		{
			ResetAllMovingItems();
		}
		base.DoServerDestroy();
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		if (HasFlag(Flags.Reserved1))
		{
			ResetAllMovingItems();
		}
		base.OnPickedUp(createdItem, player);
	}

	private void ResetAllMovingItems()
	{
		((PersistentObjectWorkQueue<Hopper>)WorkQueue).Remove(this);
		SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
		Rigidbody val = default(Rigidbody);
		foreach (HopperMove movingItem in movingItems)
		{
			if (movingItem.Target != null && (Object)(object)movingItem.Target.ToEntity != (Object)null)
			{
				if (((Component)movingItem.Target.ToEntity).TryGetComponent<Rigidbody>(ref val))
				{
					val.useGravity = true;
				}
				movingItem.Target.HopperCancelled();
			}
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		MountType mountType = MountType.Flat;
		if ((Object)(object)newParent != (Object)null && newParent is BoxStorage boxStorage)
		{
			mountType = boxStorage.HopperMountType;
		}
		SetFlag(Flags.Reserved3, mountType == MountType.Barrel);
		SetFlag(Flags.Reserved2, mountType == MountType.Flat);
	}

	private void QueueScan()
	{
		((ObjectWorkQueue<IndustrialEntity>)global::IndustrialEntity.Queue).Add((IndustrialEntity)this);
	}

	protected override void RunJob()
	{
		base.RunJob();
		if (IsPowered() || DebugMode)
		{
			ScanForItemsTick();
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (inputSlot == 0)
		{
			bool b = inputAmount >= ConsumptionAmount() && inputAmount > 0;
			SetFlag(Flags.Reserved8, b);
			currentEnergy = inputAmount;
			ensureOutputsUpdated = true;
			MarkDirty();
		}
	}

	private void MovingItemsTick()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		if (movingItems.Count == 0)
		{
			return;
		}
		if (cachedCheckNull == null)
		{
			cachedCheckNull = CheckNull;
		}
		movingItems.RemoveWhere(cachedCheckNull);
		PooledList<IHopperTarget> val = Pool.Get<PooledList<IHopperTarget>>();
		try
		{
			float num = ItemMoveSpeed * (1f / 60f * Time.timeScale);
			Vector3 position = ItemMoveTarget.position;
			Quaternion rotation = ItemMoveTarget.rotation;
			foreach (HopperMove movingItem in movingItems)
			{
				if (movingItem.Target != null && !((Object)(object)movingItem.Target.ToEntity == (Object)null))
				{
					Vector3 position2 = ((Component)movingItem.Target.ToEntity).transform.position;
					Quaternion rotation2 = ((Component)movingItem.Target.ToEntity).transform.rotation;
					float num2 = Mathf.Clamp01(Vector3.Distance(position2, Vector3Ex.WithY(position, position2.y)) / 3f);
					float num3 = ItemHeightCurve.Evaluate(num2);
					float num4 = ItemSpeedMultiplierCurve.Evaluate(1f - num2);
					Vector3 val2 = Vector3.MoveTowards(position2, position, num * num4);
					val2.y = Mathf.MoveTowards(val2.y, position.y + num3, Time.deltaTime * ItemHeightChangeSpeed.Evaluate(1f - num2));
					Quaternion val3 = Quaternion.RotateTowards(rotation2, rotation, Time.deltaTime * ItemRotationSpeed.Evaluate(1f - num2));
					((Component)movingItem.Target.ToEntity).transform.SetPositionAndRotation(val2, val3);
					if ((Object)(object)movingItem.Target.Rigidbody != (Object)null)
					{
						movingItem.Target.Rigidbody.velocity = Vector3.zero;
						movingItem.Target.Rigidbody.angularVelocity = Vector3.zero;
					}
					float num5 = 0.015f * movingItem.Target.EndPositionToleranceMultiplier;
					Vector3 val4 = val2 - position;
					if (((Vector3)(ref val4)).sqrMagnitude < num5 * num5)
					{
						((List<IHopperTarget>)(object)val).Add(movingItem.Target);
					}
				}
			}
			foreach (HopperMove movingItem2 in movingItems)
			{
				if (TimeSince.op_Implicit(movingItem2.Duration) > 5f)
				{
					((List<IHopperTarget>)(object)val).Add(movingItem2.Target);
				}
			}
			foreach (IHopperTarget item in (List<IHopperTarget>)(object)val)
			{
				IntakeItem(item);
			}
			if (movingItems.Count == 0)
			{
				SetFlag(Flags.Reserved1, b: false);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		static bool CheckNull(HopperMove obj)
		{
			if (obj.Target != null)
			{
				return (Object)(object)obj.Target.ToEntity == (Object)null;
			}
			return true;
		}
	}

	private bool Match(HopperMove obj)
	{
		return obj.Target == matchCheck;
	}

	private void IntakeItem(IHopperTarget targetItem)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (cachedRemove == null)
		{
			cachedRemove = Match;
		}
		matchCheck = targetItem;
		movingItems.RemoveWhere(cachedRemove);
		if (BloodSpray.isValid && targetItem.ToEntity is BaseCorpse)
		{
			Effect.server.Run(BloodSpray.resourcePath, ((Component)this).transform.position);
		}
		targetItem.TransferAllItemsToContainer(Container, ItemMoveTarget.position);
	}
}


public enum MountType
{
	Flat,
	Barrel
}


using System;
using System.Collections.Generic;

private struct HopperMove : IEqualityComparer<HopperMove>
{
	public IHopperTarget Target;

	public TimeSince Duration;

	public bool Equals(HopperMove x, HopperMove y)
	{
		return object.Equals(x.Target, y.Target);
	}

	public int GetHashCode(HopperMove obj)
	{
		return HashCode.Combine(obj.Target);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
private struct FillRaycastJob : IJobParallelFor
{
	[ReadOnly]
	public NativeArray<Vector3> points;

	public NativeArray<RaycastCommand> commands;

	public Vector3 originPoint;

	public int layerMask;

	public void Execute(int index)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = points[index];
		if (!(val == Vector3.zero))
		{
			ref NativeArray<RaycastCommand> reference = ref commands;
			Vector3 val2 = originPoint - val;
			reference[index] = new RaycastCommand(val, ((Vector3)(ref val2)).normalized, Vector3.Distance(val, originPoint), layerMask, 1);
		}
	}
}


public class HopperAnimationWorkQueue : PersistentObjectWorkQueue<Hopper>
{
	protected override void RunJob(Hopper entity)
	{
		entity.MovingItemsTick();
	}
}


using UnityEngine;

public interface IHopperTarget
{
	BaseEntity ToEntity { get; }

	Rigidbody Rigidbody { get; }

	int NumberOfItemsToTransfer { get; }

	float EndPositionToleranceMultiplier { get; }

	void PrepareForHopper();

	void HopperCancelled();

	void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 fallbackWorldPos);
}


using UnityEngine;

public class IndustrialEntity : IOEntity
{
	public class IndustrialProcessQueue : ObjectWorkQueue<IndustrialEntity>
	{
		protected override void RunJob(IndustrialEntity job)
		{
			if ((Object)(object)job != (Object)null)
			{
				job.RunJob();
			}
		}
	}

	public static IndustrialProcessQueue Queue = new IndustrialProcessQueue();

	protected virtual void RunJob()
	{
	}
}


using UnityEngine;

public class IndustrialProcessQueue : ObjectWorkQueue<IndustrialEntity>
{
	protected override void RunJob(IndustrialEntity job)
	{
		if ((Object)(object)job != (Object)null)
		{
			job.RunJob();
		}
	}
}


public interface IIndustrialStorage
{
	ItemContainer Container { get; }

	BaseEntity IndustrialEntity { get; }

	Vector2i InputSlotRange(int slotIndex);

	Vector2i OutputSlotRange(int slotIndex);

	void OnStorageItemTransferBegin();

	void OnStorageItemTransferEnd();
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class IndustrialFilterBuffer : MonoBehaviour
{
	public RustText ItemName;

	public Image ItemIcon;

	public GameObject BlueprintRoot;

	public RustSlider BufferSlider;

	public RustText BufferProgressText;
}


using Rust.UI;
using UnityEngine;

public class IndustrialFilterDialog : UIDialog
{
	public GameObjectRef ItemPrefab;

	public Transform ItemParent;

	public GameObject ItemSearchParent;

	public ItemSearchEntry ItemSearchEntryPrefab;

	public GameObject NoItemsPrompt;

	public Dropdown FilterModeDropdown;

	public GameObject[] FilterModeExplanations;

	public GameObject FilterModeBlocker;

	public RustText FilterCountText;

	public GameObject BufferRoot;

	public GameObjectRef BufferItemPrefab;

	public Transform BufferTransform;

	public RustButton PasteButton;

	public GameObject[] RegularCopyPasteButtons;

	public GameObject[] JsonCopyPasteButtons;

	public bool closeWhenClicked;

	public int count = 20;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class IndustrialFilterItemIcon : MonoBehaviour
{
	public Image ItemIcon;

	public RustText ItemName;

	public RustInput MaxInput;

	public RustInput BufferInput;

	public RustInput MinInput;

	public GameObject BlueprintIcon;

	public GameObject InverseModeBlocker;
}


using UnityEngine;

public class IndustrialStorageAdaptor : IndustrialEntity, IIndustrialStorage
{
	public GameObject GreenLight;

	public GameObject RedLight;

	public BaseEntity _cachedParent;

	public ItemContainer cachedContainer;

	public BaseEntity cachedParent
	{
		get
		{
			if ((Object)(object)_cachedParent == (Object)null)
			{
				_cachedParent = GetParentEntity();
			}
			return _cachedParent;
		}
	}

	public ItemContainer Container
	{
		get
		{
			if (cachedContainer == null)
			{
				cachedContainer = (cachedParent as StorageContainer)?.inventory;
				if (cachedContainer == null)
				{
					cachedContainer = (cachedParent as ContainerIOEntity)?.inventory;
				}
			}
			return cachedContainer;
		}
	}

	public BaseEntity IndustrialEntity => this;

	public override void ServerInit()
	{
		base.ServerInit();
		_cachedParent = null;
		cachedContainer = null;
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedParent != (Object)null)
		{
			if (cachedParent is IIndustrialStorage industrialStorage)
			{
				return industrialStorage.InputSlotRange(slotIndex);
			}
			if (cachedParent is Locker locker)
			{
				Vector3 localPosition = ((Component)this).transform.localPosition;
				return locker.GetIndustrialSlotRange(localPosition);
			}
		}
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedParent != (Object)null)
		{
			if (cachedParent is IIndustrialStorage industrialStorage)
			{
				return industrialStorage.OutputSlotRange(slotIndex);
			}
			if (cachedParent is Locker locker)
			{
				Vector3 localPosition = ((Component)this).transform.localPosition;
				return locker.GetIndustrialSlotRange(localPosition);
			}
		}
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public void OnStorageItemTransferBegin()
	{
		if ((Object)(object)cachedParent != (Object)null)
		{
			if (cachedParent is VendingMachine vendingMachine)
			{
				vendingMachine.OnIndustrialItemTransferBegins();
			}
			else if (cachedParent is Locker locker)
			{
				locker.OnIndustrialItemTransferBegin();
			}
		}
	}

	public void OnStorageItemTransferEnd()
	{
		if ((Object)(object)cachedParent != (Object)null)
		{
			if (cachedParent is VendingMachine vendingMachine)
			{
				vendingMachine.OnIndustrialItemTransferEnds();
			}
			else if (cachedParent is Locker locker)
			{
				locker.OnIndustrialItemTransferEnd();
			}
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		if ((Object)(object)newParent != (Object)null)
		{
			cachedContainer = null;
		}
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public void ClientNotifyItemAddRemoved(bool add)
	{
		if (add)
		{
			GreenLight.SetActive(false);
			GreenLight.SetActive(true);
		}
		else
		{
			RedLight.SetActive(false);
			RedLight.SetActive(true);
		}
	}
}


using System;
using UnityEngine;

[RequireComponent(typeof(IOEntity))]
public class IOEntityMovementChecker : FacepunchBehaviour
{
	private IOEntity ioEntity;

	private Vector3 prevPos;

	private const float MAX_MOVE = 0.05f;

	private const float MAX_MOVE_SQR = 0.0025000002f;

	protected void Awake()
	{
		ioEntity = ((Component)this).GetComponent<IOEntity>();
	}

	protected void OnEnable()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckPosition, Random.Range(0f, 0.25f), 0.25f);
	}

	protected void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CheckPosition);
	}

	private void CheckPosition()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (!ioEntity.isClient && Vector3.SqrMagnitude(((Component)this).transform.position - prevPos) > 0.0025000002f)
		{
			prevPos = ((Component)this).transform.position;
			if (ioEntity.HasConnections())
			{
				ioEntity.SendChangedToRoot(forceUpdate: true);
				ioEntity.ClearConnections();
			}
		}
	}
}


using UnityEngine;

public class IOHandle : MonoBehaviour
{
}


public enum IOHandlePriority
{
	Normal,
	Low,
	High
}


public class IOManager : SingletonComponent<IOManager>
{
}


using UnityEngine;

public class ProgressDoor : IOEntity
{
	public float storedEnergy;

	public float energyForOpen = 1f;

	public float secondsToClose = 1f;

	public float openProgress;

	public override void ResetIOState()
	{
		storedEnergy = 0f;
		UpdateProgress();
	}

	public override float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot = 0)
	{
		if (inputAmount > 0f)
		{
			AddEnergy(inputAmount);
			if (storedEnergy == energyForOpen)
			{
				return inputAmount;
			}
			return 0f;
		}
		NoEnergy();
		return inputAmount;
	}

	public virtual void NoEnergy()
	{
	}

	public virtual void AddEnergy(float amount)
	{
		if (!(amount <= 0f))
		{
			storedEnergy += amount;
			storedEnergy = Mathf.Clamp(storedEnergy, 0f, energyForOpen);
		}
	}

	public virtual void UpdateProgress()
	{
		SendNetworkUpdate();
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class SlidingProgressDoor : ProgressDoor
{
	public Vector3 openPosition;

	public Vector3 closedPosition;

	public GameObject doorObject;

	public TriggerVehiclePush vehiclePhysBox;

	private float lastEnergyTime;

	private float lastServerUpdateTime;

	public override void Spawn()
	{
		base.Spawn();
		((FacepunchBehaviour)this).InvokeRepeating((Action)ServerUpdate, 0f, 0.1f);
		if ((Object)(object)vehiclePhysBox != (Object)null)
		{
			((Component)vehiclePhysBox).gameObject.SetActive(false);
		}
	}

	public override void NoEnergy()
	{
		base.NoEnergy();
	}

	public override void AddEnergy(float amount)
	{
		lastEnergyTime = Time.time;
		base.AddEnergy(amount);
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}

	public void ServerUpdate()
	{
		if (!base.isServer)
		{
			return;
		}
		if (lastServerUpdateTime == 0f)
		{
			lastServerUpdateTime = Time.realtimeSinceStartup;
		}
		float num = Time.realtimeSinceStartup - lastServerUpdateTime;
		lastServerUpdateTime = Time.realtimeSinceStartup;
		if (Time.time > lastEnergyTime + 0.333f)
		{
			float num2 = energyForOpen * num / secondsToClose;
			float num3 = Mathf.Min(storedEnergy, num2);
			if ((Object)(object)vehiclePhysBox != (Object)null)
			{
				((Component)vehiclePhysBox).gameObject.SetActive(num3 > 0f && storedEnergy > 0f);
				if (((Component)vehiclePhysBox).gameObject.activeSelf && vehiclePhysBox.ContentsCount > 0)
				{
					num3 = 0f;
				}
			}
			storedEnergy -= num3;
			storedEnergy = Mathf.Clamp(storedEnergy, 0f, energyForOpen);
			if (num3 > 0f)
			{
				IOSlot[] array = outputs;
				foreach (IOSlot iOSlot in array)
				{
					if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
					{
						iOSlot.connectedTo.Get().IOInput(this, ioType, 0f - num3, iOSlot.connectedToSlot);
					}
				}
			}
		}
		UpdateProgress();
	}

	public override void UpdateProgress()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localPosition = doorObject.transform.localPosition;
		float num = storedEnergy / energyForOpen;
		Vector3 val = Vector3.Lerp(closedPosition, openPosition, num);
		doorObject.transform.localPosition = val;
		if (base.isServer)
		{
			bool flag = Vector3.Distance(localPosition, val) > 0.01f;
			SetFlag(Flags.Reserved1, flag);
			if (flag)
			{
				SendNetworkUpdate();
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.sphereEntity;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.sphereEntity = Pool.Get<SphereEntity>();
		info.msg.sphereEntity.radius = storedEnergy;
	}
}


using System;
using UnityEngine;

public class NoPlayersIOReset : FacepunchBehaviour
{
	[SerializeField]
	private IOEntity[] entitiesToReset;

	[SerializeField]
	private float radius;

	[SerializeField]
	private float timeBetweenChecks;

	protected void OnEnable()
	{
		((FacepunchBehaviour)this).InvokeRandomized((Action)Check, timeBetweenChecks, timeBetweenChecks, timeBetweenChecks * 0.1f);
	}

	protected void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Check);
	}

	private void Check()
	{
		if (!PuzzleReset.AnyPlayersWithinDistance(((Component)this).transform, radius))
		{
			Reset();
		}
	}

	private void Reset()
	{
		IOEntity[] array = entitiesToReset;
		foreach (IOEntity iOEntity in array)
		{
			if (iOEntity.IsValid() && iOEntity.isServer)
			{
				iOEntity.ResetIOState();
				iOEntity.MarkDirty();
			}
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public class PuzzleReset : FacepunchBehaviour
{
	public SpawnGroup[] respawnGroups;

	public IOEntity[] resetEnts;

	public GameObject[] resetObjects;

	public bool playersBlockReset;

	public bool CheckSleepingAIZForPlayers;

	public float playerDetectionRadius;

	public Transform playerDetectionOrigin;

	public bool ignoreAboveGroundPlayers;

	public float timeBetweenResets = 30f;

	public bool scaleWithServerPopulation;

	[HideInInspector]
	public Vector3[] resetPositions;

	public bool broadcastResetMessage;

	public Phrase resetPhrase;

	private AIInformationZone zone;

	public float resetTimeElapsed;

	private float resetTickTime = 10f;

	public float GetResetSpacing()
	{
		return timeBetweenResets * (scaleWithServerPopulation ? (1f - SpawnHandler.PlayerLerp(Spawn.min_rate, Spawn.max_rate)) : 1f);
	}

	public void Start()
	{
		if (timeBetweenResets != float.PositiveInfinity)
		{
			ResetTimer();
		}
	}

	public void ResetTimer()
	{
		resetTimeElapsed = 0f;
		((FacepunchBehaviour)this).CancelInvoke((Action)ResetTick);
		((FacepunchBehaviour)this).InvokeRandomized((Action)ResetTick, Random.Range(0f, 1f), resetTickTime, 0.5f);
	}

	public bool PassesResetCheck()
	{
		if (playersBlockReset)
		{
			if (CheckSleepingAIZForPlayers)
			{
				return AIZSleeping();
			}
			return !PlayersWithinDistance();
		}
		return true;
	}

	private bool AIZSleeping()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)zone != (Object)null)
		{
			if (!zone.PointInside(((Component)this).transform.position))
			{
				zone = AIInformationZone.GetForPoint(((Component)this).transform.position);
			}
		}
		else
		{
			zone = AIInformationZone.GetForPoint(((Component)this).transform.position);
		}
		if ((Object)(object)zone == (Object)null)
		{
			return false;
		}
		return zone.Sleeping;
	}

	private bool PlayersWithinDistance()
	{
		return AnyPlayersWithinDistance(playerDetectionOrigin, playerDetectionRadius, ignoreAboveGroundPlayers);
	}

	public static bool AnyPlayersWithinDistance(Transform origin, float radius, bool ignoreAboveGroundPlayers = false)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!current.IsSleeping() && current.IsAlive() && Vector3.Distance(((Component)current).transform.position, origin.position) < radius && (!ignoreAboveGroundPlayers || current.IsUnderground()))
				{
					return true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}

	public void ResetTick()
	{
		if (PassesResetCheck())
		{
			resetTimeElapsed += resetTickTime;
		}
		if (resetTimeElapsed > GetResetSpacing())
		{
			resetTimeElapsed = 0f;
			DoReset();
		}
	}

	public void CleanupSleepers()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)playerDetectionOrigin == (Object)null || BasePlayer.sleepingPlayerList == null)
		{
			return;
		}
		for (int num = BasePlayer.sleepingPlayerList.Count - 1; num >= 0; num--)
		{
			BasePlayer basePlayer = BasePlayer.sleepingPlayerList[num];
			if (!((Object)(object)basePlayer == (Object)null) && basePlayer.IsSleeping() && Vector3.Distance(((Component)basePlayer).transform.position, playerDetectionOrigin.position) <= playerDetectionRadius && (!ignoreAboveGroundPlayers || basePlayer.IsUnderground()))
			{
				basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
			}
		}
	}

	public void DoReset()
	{
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		CleanupSleepers();
		IOEntity component = ((Component)this).GetComponent<IOEntity>();
		if ((Object)(object)component != (Object)null)
		{
			ResetIOEntRecursive(component, Time.frameCount);
			component.MarkDirty();
		}
		else if (resetPositions != null)
		{
			Vector3[] array = resetPositions;
			foreach (Vector3 val in array)
			{
				Vector3 position = ((Component)this).transform.TransformPoint(val);
				List<IOEntity> list = Pool.Get<List<IOEntity>>();
				Vis.Entities(position, 0.5f, list, 1235288065, (QueryTriggerInteraction)1);
				foreach (IOEntity item in list)
				{
					if (item.IsRootEntity() && item.isServer)
					{
						ResetIOEntRecursive(item, Time.frameCount);
						item.MarkDirty();
					}
				}
				Pool.FreeUnmanaged<IOEntity>(ref list);
			}
		}
		List<SpawnGroup> list2 = Pool.Get<List<SpawnGroup>>();
		Vis.Components<SpawnGroup>(((Component)this).transform.position, 1f, list2, 262144, (QueryTriggerInteraction)2);
		foreach (SpawnGroup item2 in list2)
		{
			if (!((Object)(object)item2 == (Object)null))
			{
				item2.Clear();
				item2.DelayedSpawn();
			}
		}
		Pool.FreeUnmanaged<SpawnGroup>(ref list2);
		GameObject[] array2 = resetObjects;
		foreach (GameObject val2 in array2)
		{
			if ((Object)(object)val2 != (Object)null)
			{
				val2.SendMessage("OnPuzzleReset", (SendMessageOptions)1);
			}
		}
		if (!broadcastResetMessage)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator3 = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator3.MoveNext())
			{
				BasePlayer current3 = enumerator3.Current;
				if (!current3.IsNpc && current3.IsConnected && !current3.IsInTutorial)
				{
					current3.ShowToast(GameTip.Styles.Server_Event, resetPhrase, false);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator3/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void ResetIOEntRecursive(IOEntity target, int resetIndex)
	{
		if (target.lastResetIndex == resetIndex)
		{
			return;
		}
		target.lastResetIndex = resetIndex;
		target.ResetIOState();
		IOEntity.IOSlot[] outputs = target.outputs;
		foreach (IOEntity.IOSlot iOSlot in outputs)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null && (Object)(object)iOSlot.connectedTo.Get() != (Object)(object)target)
			{
				ResetIOEntRecursive(iOSlot.connectedTo.Get(), resetIndex);
			}
		}
	}
}


public class FrequencyConfig : IOConfig<IRFObject>
{
}


using UnityEngine;

public interface IRFObject
{
	Vector3 GetPosition();

	float GetMaxRange();

	void RFSignalUpdate(bool on);

	int GetFrequency();
}


using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class RFManager
{
	private static readonly Dictionary<int, HashSet<IRFObject>> _listeners = new Dictionary<int, HashSet<IRFObject>>();

	private static readonly Dictionary<int, HashSet<IRFObject>> _broadcasters = new Dictionary<int, HashSet<IRFObject>>();

	private static readonly Dictionary<int, bool> _isFrequencyBroadcasting = new Dictionary<int, bool>();

	public static int minFreq = 1;

	public static int maxFreq = 999999;

	private static int reserveRangeMin = 4760;

	private static int reserveRangeMax = 4790;

	public static Phrase reservedFrequencyPhrase = new Phrase("rf.reservedfrequency", "Channels {0} to {1} are restricted");

	public static int ClampFrequency(int freq)
	{
		return Mathf.Clamp(freq, minFreq, maxFreq);
	}

	public static HashSet<IRFObject> GetListenerSet(int frequency)
	{
		frequency = ClampFrequency(frequency);
		if (!_listeners.TryGetValue(frequency, out var value))
		{
			value = new HashSet<IRFObject>();
			_listeners[frequency] = value;
		}
		return value;
	}

	public static HashSet<IRFObject> GetBroadcasterSet(int frequency)
	{
		frequency = ClampFrequency(frequency);
		if (!_broadcasters.TryGetValue(frequency, out var value))
		{
			value = new HashSet<IRFObject>();
			_broadcasters[frequency] = value;
		}
		return value;
	}

	public static void AddListener(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfListenerAdd", (object)obj, (object)frequency) == null && GetListenerSet(frequency).Add(obj))
		{
			bool value;
			bool on = _isFrequencyBroadcasting.TryGetValue(frequency, out value) && value;
			obj.RFSignalUpdate(on);
			Interface.CallHook("OnRfListenerAdded", (object)obj, (object)frequency);
		}
	}

	public static void RemoveListener(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfListenerRemove", (object)obj, (object)frequency) == null && GetListenerSet(frequency).Remove(obj))
		{
			obj.RFSignalUpdate(on: false);
			Interface.CallHook("OnRfListenerRemoved", (object)obj, (object)frequency);
		}
	}

	public static void AddBroadcaster(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfBroadcasterAdd", (object)obj, (object)frequency) != null)
		{
			return;
		}
		HashSet<IRFObject> broadcasterSet = GetBroadcasterSet(frequency);
		if (broadcasterSet.RemoveWhere((IRFObject b) => b == null || !b.IsValidEntityReference()) > 0)
		{
			Debug.LogWarning((object)$"Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.");
		}
		if (broadcasterSet.Add(obj))
		{
			Interface.CallHook("OnRfBroadcasterAdded", (object)obj, (object)frequency);
			if (!_isFrequencyBroadcasting.TryGetValue(frequency, out var value) || !value)
			{
				_isFrequencyBroadcasting[frequency] = true;
				UpdateListenersForFrequency(frequency, isBroadcasting: true);
			}
		}
	}

	public static void RemoveBroadcaster(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfBroadcasterRemove", (object)obj, (object)frequency) != null)
		{
			return;
		}
		HashSet<IRFObject> broadcasterSet = GetBroadcasterSet(frequency);
		if (broadcasterSet.RemoveWhere((IRFObject b) => b == null || !b.IsValidEntityReference()) > 0)
		{
			Debug.LogWarning((object)$"Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.");
		}
		if (broadcasterSet.Remove(obj))
		{
			Interface.CallHook("OnRfBroadcasterRemoved", (object)obj, (object)frequency);
			if (broadcasterSet.Count == 0)
			{
				_isFrequencyBroadcasting[frequency] = false;
				UpdateListenersForFrequency(frequency, isBroadcasting: false);
			}
		}
	}

	private static void UpdateListenersForFrequency(int frequency, bool isBroadcasting)
	{
		HashSet<IRFObject> listenerSet = GetListenerSet(frequency);
		listenerSet.RemoveWhere((IRFObject l) => l == null || !l.IsValidEntityReference());
		foreach (IRFObject item in listenerSet)
		{
			item.RFSignalUpdate(isBroadcasting);
		}
	}

	public static bool IsReserved(int frequency)
	{
		if (frequency >= reserveRangeMin && frequency <= reserveRangeMax)
		{
			return true;
		}
		return false;
	}

	public static void ReserveErrorPrint(BasePlayer player)
	{
		player.ShowToast(GameTip.Styles.Error, reservedFrequencyPhrase, false, reserveRangeMin.ToString(), reserveRangeMax.ToString());
	}

	public static void ChangeFrequency(int oldFrequency, int newFrequency, IRFObject obj, bool isListener, bool isOn = true)
	{
		newFrequency = ClampFrequency(newFrequency);
		if (isListener)
		{
			RemoveListener(oldFrequency, obj);
			if (isOn)
			{
				AddListener(newFrequency, obj);
			}
		}
		else
		{
			RemoveBroadcaster(oldFrequency, obj);
			if (isOn)
			{
				AddBroadcaster(newFrequency, obj);
			}
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class BaseHuntEvent : BaseEntity
{
	public GameObjectRef[] HuntablePrefab;

	protected List<string> HuntableResourcePathCached;

	public AudioSource huntStartSound;

	public override void ServerInit()
	{
		base.ServerInit();
		HuntableResourcePathCached = new List<string>();
		for (int i = 0; i < HuntablePrefab.Length; i++)
		{
			HuntableResourcePathCached.Add(HuntablePrefab[i].resourcePath);
		}
	}
}


using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class CargoPlane : BaseEntity
{
	public GameObjectRef prefabDrop;

	public SpawnFilter filter;

	public Vector3 startPos;

	public Vector3 endPos;

	public float secondsToTake;

	public float secondsTaken;

	public bool dropped;

	public Vector3 dropPosition = Vector3.zero;

	public override void ServerInit()
	{
		base.ServerInit();
		Initialize();
	}

	public override void PostServerLoad()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		if (dropPosition == Vector3.zero)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (dropPosition == Vector3.zero)
		{
			dropPosition = RandomDropPosition();
		}
		UpdateDropPosition(dropPosition);
	}

	public void InitDropPosition(Vector3 newDropPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		dropPosition = newDropPosition;
		dropPosition.y = 0f;
	}

	public Vector3 RandomDropPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		float num = 100f;
		float x = TerrainMeta.Size.x;
		do
		{
			zero = Vector3Ex.Range(0f - x / 3f, x / 3f);
		}
		while (filter.GetFactor(zero) == 0f && (num -= 1f) > 0f);
		zero.y = 0f;
		return zero;
	}

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float y = TerrainMeta.HighestPoint.y + 250f;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		((Vector3)(ref startPos)).Normalize();
		startPos *= x * 2f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 50f;
		secondsToTake *= Random.Range(0.95f, 1.05f);
		((Component)this).transform.position = startPos;
		((Component)this).transform.rotation = Quaternion.LookRotation(endPos - startPos);
		dropPosition = newDropPosition;
		Interface.CallHook("OnAirdrop", (object)this, (object)newDropPosition);
	}

	private void Update()
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		secondsTaken += Time.deltaTime;
		float num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
		if (!dropped && num >= 0.5f)
		{
			dropped = true;
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, ((Component)this).transform.position);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.globalBroadcast = true;
				baseEntity.Spawn();
				Interface.CallHook("OnSupplyDropDropped", (object)baseEntity, (object)this);
			}
		}
		((Component)this).transform.position = Vector3.Lerp(startPos, endPos, num);
		((Component)this).transform.hasChanged = true;
		if (num >= 1f)
		{
			Kill();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (base.isServer && info.forDisk)
		{
			info.msg.cargoPlane = Pool.Get<CargoPlane>();
			info.msg.cargoPlane.startPos = startPos;
			info.msg.cargoPlane.endPos = endPos;
			info.msg.cargoPlane.secondsToTake = secondsToTake;
			info.msg.cargoPlane.secondsTaken = secondsTaken;
			info.msg.cargoPlane.dropped = dropped;
			info.msg.cargoPlane.dropPosition = dropPosition;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (base.isServer && info.fromDisk && info.msg.cargoPlane != null)
		{
			startPos = info.msg.cargoPlane.startPos;
			endPos = info.msg.cargoPlane.endPos;
			secondsToTake = info.msg.cargoPlane.secondsToTake;
			secondsTaken = info.msg.cargoPlane.secondsTaken;
			dropped = info.msg.cargoPlane.dropped;
			dropPosition = info.msg.cargoPlane.dropPosition;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class RoadBradleys : TriggeredEvent
{
	private List<BradleyAPC> spawnedAPCs = new List<BradleyAPC>();

	public static int StaticBradleyCount;

	public int GetNumBradleys()
	{
		CleanList();
		return spawnedAPCs.Count;
	}

	public int GetDesiredNumber()
	{
		return Mathf.CeilToInt((float)World.Size / 1000f) * 2;
	}

	private void CleanList()
	{
		for (int num = spawnedAPCs.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)spawnedAPCs[num] == (Object)null)
			{
				spawnedAPCs.RemoveAt(num);
			}
		}
	}

	public override void RunEvent()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		int numBradleys = GetNumBradleys();
		int num = GetDesiredNumber() - numBradleys;
		if (num <= 0 || (Object)(object)TerrainMeta.Path == (Object)null || TerrainMeta.Path.Roads.Count == 0)
		{
			return;
		}
		Debug.Log((object)"[event] assets/prefabs/npc/m2bradley/bradleyapc.prefab");
		Debug.Log((object)("Spawning :" + num + "Bradleys"));
		for (int i = 0; i < num; i++)
		{
			Vector3 zero = Vector3.zero;
			PathList pathList = TerrainMeta.Path.Roads[Random.Range(0, TerrainMeta.Path.Roads.Count)];
			zero = pathList.Path.Points[Random.Range(0, pathList.Path.Points.Length)];
			BradleyAPC bradleyAPC = BradleyAPC.SpawnRoadDrivingBradley(zero, Quaternion.identity);
			if (Object.op_Implicit((Object)(object)bradleyAPC))
			{
				spawnedAPCs.Add(bradleyAPC);
				continue;
			}
			Vector3 val = zero;
			Debug.Log((object)("Failed to spawn bradley at: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString()));
		}
		StaticBradleyCount = spawnedAPCs.Count;
	}

	public override void Kill()
	{
		base.Kill();
		foreach (BradleyAPC spawnedAPC in spawnedAPCs)
		{
			spawnedAPC.Kill();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using ConVar;
using Rust;
using UnityEngine;

public class EventSchedule : BaseMonoBehaviour
{
	[Tooltip("The minimum amount of hours between events")]
	public float minimumHoursBetween = 12f;

	[Tooltip("The maximum amount of hours between events")]
	public float maxmumHoursBetween = 24f;

	[Tooltip("ID to reference this event via convars")]
	public string Key;

	public static HashSet<EventSchedule> allEvents = new HashSet<EventSchedule>();

	public static HashSet<EventSchedule> enabledEvents = new HashSet<EventSchedule>();

	public float hoursRemaining;

	public long lastRun;

	[ServerVar(Name = "triggerevent")]
	public static void TriggerEvent(Arg arg)
	{
		string eventName = arg.GetString(0, "");
		string[] source = enabledEvents.Select((EventSchedule x) => x.GetName().ToLower()).ToArray();
		string[] array = (from x in source
			where StringEx.Contains(x, eventName, CompareOptions.IgnoreCase)
			select x.ToLower()).ToArray();
		if (string.IsNullOrEmpty(eventName) || array.Length == 0)
		{
			arg.ReplyWith("Unknown event - event list:\n\n" + string.Join("\n", source.Select(Path.GetFileNameWithoutExtension).ToArray()));
			return;
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(x, eventName, StringComparison.OrdinalIgnoreCase) == 0);
			if (text != null)
			{
				array[0] = text;
			}
		}
		foreach (EventSchedule enabledEvent in enabledEvents)
		{
			if (enabledEvent.GetName() == array[0])
			{
				enabledEvent.Trigger();
				arg.ReplyWith("Triggered " + enabledEvent.GetName());
			}
		}
	}

	[ServerVar(Name = "killallevents")]
	public static void KillAllEvents()
	{
		foreach (EventSchedule enabledEvent in enabledEvents)
		{
			TriggeredEvent[] components = ((Component)enabledEvent).GetComponents<TriggeredEvent>();
			for (int i = 0; i < components.Length; i++)
			{
				components[i].Kill();
			}
		}
	}

	public string GetName()
	{
		return Path.GetFileNameWithoutExtension(((Object)this).name);
	}

	private void Awake()
	{
		allEvents.Add(this);
		Events.UpdateScheduleFromConVars(this);
	}

	private void OnDestroy()
	{
		allEvents.Remove(this);
	}

	private void OnEnable()
	{
		hoursRemaining = Random.Range(minimumHoursBetween, maxmumHoursBetween);
		((FacepunchBehaviour)this).InvokeRepeating((Action)RunSchedule, 1f, 1f);
		enabledEvents.Add(this);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			enabledEvents.Remove(this);
			((FacepunchBehaviour)this).CancelInvoke((Action)RunSchedule);
		}
	}

	public virtual void RunSchedule()
	{
		if (!Application.isLoading && ConVar.Server.events)
		{
			CountHours();
			if (!(hoursRemaining > 0f))
			{
				Trigger();
			}
		}
	}

	private void Trigger()
	{
		hoursRemaining = Random.Range(minimumHoursBetween, maxmumHoursBetween);
		TriggeredEvent[] components = ((Component)this).GetComponents<TriggeredEvent>();
		if (components.Length != 0)
		{
			TriggeredEvent triggeredEvent = components[Random.Range(0, components.Length)];
			if (!((Object)(object)triggeredEvent == (Object)null))
			{
				triggeredEvent.RunEvent();
			}
		}
	}

	private void CountHours()
	{
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			if (lastRun != 0L)
			{
				hoursRemaining -= (float)TOD_Sky.Instance.Cycle.DateTime.Subtract(DateTime.FromBinary(lastRun)).TotalSeconds / 60f / 60f;
			}
			lastRun = TOD_Sky.Instance.Cycle.DateTime.ToBinary();
		}
	}
}


using UnityEngine;

public class EventScheduleWipeOffset : EventSchedule
{
	[ServerVar(Name = "event_hours_before_wipe")]
	public static float hoursBeforeWipeRealtime = 24f;

	public override void RunSchedule()
	{
		if (!((Object)(object)WipeTimer.serverinstance == (Object)null) && !(WipeTimer.serverinstance.GetTimeSpanUntilWipe().TotalHours > (double)hoursBeforeWipeRealtime))
		{
			base.RunSchedule();
		}
	}
}


using UnityEngine;

public class TriggeredEvent : MonoBehaviour
{
	public virtual void RunEvent()
	{
	}

	public virtual void Kill()
	{
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class TriggeredEventPrefab : TriggeredEvent
{
	public GameObjectRef targetPrefab;

	public bool shouldBroadcastSpawn;

	public Phrase spawnPhrase;

	public BaseEntity spawnedEntity;

	public override void RunEvent()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnEventTrigger", (object)this) != null)
		{
			return;
		}
		Debug.Log((object)("[event] " + targetPrefab.resourcePath));
		BaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);
		if (!Object.op_Implicit((Object)(object)baseEntity))
		{
			return;
		}
		((Component)baseEntity).SendMessage("TriggeredEventSpawn", (SendMessageOptions)1);
		baseEntity.Spawn();
		spawnedEntity = baseEntity;
		if (!shouldBroadcastSpawn)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (Object.op_Implicit((Object)(object)current) && current.IsConnected && !current.IsInTutorial)
				{
					current.ShowToast(GameTip.Styles.Server_Event, spawnPhrase, false);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public override void Kill()
	{
		if (!((Object)(object)spawnedEntity == (Object)null))
		{
			base.Kill();
			spawnedEntity.Kill();
			spawnedEntity = null;
			Debug.Log((object)("Killed " + ((Object)this).name));
		}
	}
}


using System;
using UnityEngine;

public class TravellingVendorEvent : TriggeredEvent
{
	public Phrase spawnPhrase;

	public static TravellingVendor currentVendor = null;

	public static float dontSpawnHoursBeforeWipe = 24f;

	public override void RunEvent()
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)currentVendor != (Object)null || (Object)(object)TerrainMeta.Path == (Object)null || TerrainMeta.Path.Roads.Count == 0 || !TravellingVendor.should_spawn || RoadBradleys.StaticBradleyCount > 0)
		{
			return;
		}
		TravellingVendor travellingVendor = TravellingVendor.SpawnTravellingVendorForEvent();
		if (Object.op_Implicit((Object)(object)travellingVendor))
		{
			Debug.Log((object)"[event] assets/prefabs/npc/travelling vendor/travellingvendor.prefab");
			currentVendor = travellingVendor;
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if (Object.op_Implicit((Object)(object)current) && current.IsConnected && !current.IsInTutorial)
					{
						current.ShowToast(GameTip.Styles.Server_Event, spawnPhrase, false);
					}
				}
				return;
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		Debug.Log((object)"Failed to spawn travelling vendor.");
	}

	private bool HoursCheck()
	{
		if (WipeTimer.serverinstance.GetTimeSpanUntilWipe().TotalHours > (double)dontSpawnHoursBeforeWipe)
		{
			return true;
		}
		return false;
	}
}


using System;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using CompanionServer;
using CompanionServer.Handlers;
using ConVar;
using Development.Attributes;
using Facepunch;
using Facepunch.Network;
using Facepunch.Network.Raknet;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Facepunch.Utility;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Ai;
using Rust.UI;
using UnityEngine;
using UnityEngine.AI;

[ResetStaticFields]
public class Bootstrap : SingletonComponent<Bootstrap>
{
	internal static bool bootstrapInitRun;

	public static bool isErrored;

	public Phrase currentLoadingPhrase;

	public CanvasGroup BootstrapUiCanvas;

	public GameObject errorPanel;

	public RustText errorText;

	public RustText statusText;

	private Phrase openingBundles = new Phrase("bootstrap.openingbundles", "Opening Bundles");

	private static string lastWrittenValue;

	public static bool needsSetup => !bootstrapInitRun;

	public static bool isPresent
	{
		get
		{
			if (bootstrapInitRun)
			{
				return true;
			}
			if (Object.FindObjectsOfType<GameSetup>().Count() > 0)
			{
				return true;
			}
			return false;
		}
	}

	public static void RunDefaults()
	{
		Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
		Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;
		Application.targetFrameRate = 256;
		Time.fixedDeltaTime = 0.0625f;
		Time.maximumDeltaTime = 0.125f;
	}

	public static void Init_Tier0()
	{
		RunDefaults();
		GameSetup.RunOnce = true;
		bootstrapInitRun = true;
		Index.Initialize(ConsoleGen.All);
		Index.Reset();
		UnityButtons.Register();
		Output.Install();
		Pool.ResizeBuffer<NetRead>(16384);
		Pool.ResizeBuffer<NetWrite>(16384);
		Pool.ResizeBuffer<Networkable>(65536);
		Pool.ResizeBuffer<EntityLink>(65536);
		Pool.ResizeBuffer<EventRecord>(16384);
		Pool.ResizeBuffer<SellOrder>(2048);
		Pool.FillBuffer<Networkable>();
		Pool.FillBuffer<EntityLink>();
		if (CommandLine.HasSwitch("-nonetworkthread"))
		{
			BaseNetwork.Multithreading = false;
		}
		SteamNetworking.SetDebugFunction();
		if (CommandLine.HasSwitch("-swnet"))
		{
			NetworkInitSteamworks(enableSteamDatagramRelay: false);
		}
		else if (CommandLine.HasSwitch("-sdrnet"))
		{
			NetworkInitSteamworks(enableSteamDatagramRelay: true);
		}
		else if (CommandLine.HasSwitch("-raknet"))
		{
			NetworkInitRaknet();
		}
		else
		{
			NetworkInitRaknet();
		}
		if (!Application.isEditor)
		{
			string text = CommandLine.Full.Replace(CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", "RCONPASSWORD")), "******");
			WriteToLog("Command Line: " + text);
		}
		Interface.Initialize();
		int parentProcessId = CommandLine.GetSwitchInt("-parent-pid", 0);
		if (parentProcessId != 0)
		{
			try
			{
				SynchronizationContext syncContext = SynchronizationContext.Current;
				Process processById = Process.GetProcessById(parentProcessId);
				processById.EnableRaisingEvents = true;
				processById.Exited += delegate
				{
					syncContext.Post(delegate
					{
						//IL_001a: Unknown result type (might be due to invalid IL or missing references)
						WriteToLog($"Parent process ID {parentProcessId} exited. Exiting the server now...");
						ConsoleSystem.Run(Option.Server, "quit", Array.Empty<object>());
					}, null);
				};
				WriteToLog($"Watching parent process ID {parentProcessId}...");
			}
			catch (ArgumentException)
			{
				WriteToLog($"Parent process ID {parentProcessId} has exited during boot! Exiting now...");
				Application.Quit();
			}
		}
		UnityHookHandler.EnsureCreated();
	}

	public static void Init_Systems()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		Global.Init();
		Integration val = new Integration();
		val.OnManifestUpdated += CpuAffinity.Apply;
		Application.Initialize((BaseIntegration)val);
		Performance.GetMemoryUsage = () => SystemInfoEx.systemMemoryUsed;
	}

	public static void Init_Config()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		ConsoleNetwork.Init();
		ConsoleSystem.UpdateValuesFromCommandLine();
		ConsoleSystem.Run(Option.Server, "server.readcfg", Array.Empty<object>());
		ServerUsers.Load();
		if (string.IsNullOrEmpty(ConVar.Server.server_id))
		{
			ConVar.Server.server_id = Guid.NewGuid().ToString("N");
			ConsoleSystem.Run(Option.Server, "server.writecfg", Array.Empty<object>());
		}
		if (CommandLine.HasSwitch("-disable-server-occlusion"))
		{
			ServerOcclusion.OcclusionEnabled = false;
			ServerOcclusion.OcclusionIncludeRocks = false;
		}
		if (CommandLine.HasSwitch("-disable-server-occlusion-rocks"))
		{
			ServerOcclusion.OcclusionIncludeRocks = false;
		}
		HttpManager.UpdateMaxConnections();
		if (!RuntimeProfiler.runtime_profiling_persist)
		{
			RuntimeProfiler.Disable();
		}
	}

	public static void NetworkInitRaknet()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Expected O, but got Unknown
		Net.sv = (Server)new Server();
	}

	public static void NetworkInitSteamworks(bool enableSteamDatagramRelay)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		Net.sv = (Server)new Server(enableSteamDatagramRelay);
	}

	private IEnumerator Start()
	{
		WriteToLog("Bootstrap Startup");
		EarlyInitialize();
		BenchmarkTimer.Enabled = CommandLine.Full.Contains("+autobench");
		Stopwatch timer = BenchmarkTimer.Get("bootstrap");
		timer?.Start();
		if (!Application.isEditor)
		{
			BuildInfo current = BuildInfo.Current;
			if ((current.Scm.Branch == null || !(current.Scm.Branch == "experimental/release")) && !(current.Scm.Branch == "release"))
			{
				ExceptionReporter.InitializeFromUrl("https://0654eb77d1e04d6babad83201b6b6b95:d2098f1d15834cae90501548bd5dbd0d@sentry.io/1836389");
			}
			else
			{
				ExceptionReporter.InitializeFromUrl("https://83df169465e84da091c1a3cd2fbffeee:3671b903f9a840ecb68411cf946ab9b6@sentry.io/51080");
			}
			bool num = CommandLine.Full.Contains("-official") || CommandLine.Full.Contains("-server.official") || CommandLine.Full.Contains("+official") || CommandLine.Full.Contains("+server.official");
			bool flag = CommandLine.Full.Contains("-stats") || CommandLine.Full.Contains("-server.stats") || CommandLine.Full.Contains("+stats") || CommandLine.Full.Contains("+server.stats");
			ExceptionReporter.Disabled = !(num && flag);
		}
		Scope val;
		Scope val2;
		if (AssetBundleBackend.Enabled)
		{
			AssetBundleBackend newBackend = new AssetBundleBackend();
			val = BenchmarkTimer.Measure("bootstrap;bundles");
			try
			{
				yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(openingBundles));
				newBackend.Load("Bundles/Bundles");
				FileSystem.Backend = (FileSystemBackend)(object)newBackend;
			}
			finally
			{
				((IDisposable)(Scope)(ref val)/*cast due to .constrained prefix*/).Dispose();
			}
			val = default(Scope);
			if (FileSystem.Backend.isError)
			{
				ThrowError(FileSystem.Backend.loadingError);
				yield break;
			}
			val2 = BenchmarkTimer.Measure("bootstrap;bundlesindex");
			try
			{
				newBackend.BuildFileIndex();
			}
			finally
			{
				((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
			}
			while (true)
			{
				if (FileSystem.Backend.isError)
				{
					ThrowError(FileSystem.Backend.loadingError);
					yield break;
				}
				float assetSceneProgress = newBackend.GetAssetSceneProgress("AssetScene-bootstrap");
				if (assetSceneProgress >= 1f)
				{
					break;
				}
				yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit($"Loading Menu Prefabs {assetSceneProgress * 100f:0.0}%")));
			}
		}
		if (FileSystem.Backend.isError)
		{
			ThrowError(FileSystem.Backend.loadingError);
			yield break;
		}
		if (!Application.isEditor)
		{
			WriteToLog(SystemInfoGeneralText.currentInfo);
		}
		Texture.SetGlobalAnisotropicFilteringLimits(1, 16);
		QualitySettings.streamingMipmapsActive = false;
		QualitySettings.streamingMipmapsActive = false;
		if (isErrored)
		{
			yield break;
		}
		val = BenchmarkTimer.Measure("bootstrap;gamemanifest");
		try
		{
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Loading Game Manifest")));
			GameManifest.Load();
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("DONE!")));
		}
		finally
		{
			((IDisposable)(Scope)(ref val)/*cast due to .constrained prefix*/).Dispose();
		}
		val = default(Scope);
		val = BenchmarkTimer.Measure("bootstrap;selfcheck");
		try
		{
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Running Self Check")));
			SelfCheck.Run();
		}
		finally
		{
			((IDisposable)(Scope)(ref val)/*cast due to .constrained prefix*/).Dispose();
		}
		val = default(Scope);
		if (isErrored)
		{
			yield break;
		}
		yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Bootstrap Tier0")));
		val2 = BenchmarkTimer.Measure("bootstrap;tier0");
		try
		{
			Init_Tier0();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		val2 = BenchmarkTimer.Measure("bootstrap;commandlinevalues");
		try
		{
			ConsoleSystem.UpdateValuesFromCommandLine();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Bootstrap Systems")));
		val2 = BenchmarkTimer.Measure("bootstrap;init_systems");
		try
		{
			Init_Systems();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Bootstrap Config")));
		val2 = BenchmarkTimer.Measure("bootstrap;init_config");
		try
		{
			Init_Config();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		val2 = BenchmarkTimer.Measure("bootstrap;commandlinevalues2");
		try
		{
			ConsoleSystem.UpdateValuesFromCommandLine();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		if (!isErrored)
		{
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Loading Items")));
			val2 = BenchmarkTimer.Measure("bootstrap;itemmanager");
			try
			{
				ItemManager.Initialize();
			}
			finally
			{
				((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
			}
			if (!isErrored)
			{
				yield return ((MonoBehaviour)this).StartCoroutine(DedicatedServerStartup());
				timer?.Stop();
				GameManager.Destroy(((Component)this).gameObject);
			}
		}
	}

	private IEnumerator DedicatedServerStartup()
	{
		Application.isLoading = true;
		Application.backgroundLoadingPriority = (ThreadPriority)4;
		WriteToLog("Skinnable Warmup");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		GameManifest.LoadAssets();
		WriteToLog("Initializing Nexus");
		yield return ((MonoBehaviour)this).StartCoroutine(StartNexusServer());
		WriteToLog("Loading Scene");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		Physics.defaultSolverIterations = 3;
		int @int = PlayerPrefs.GetInt("UnityGraphicsQuality");
		QualitySettings.SetQualityLevel(0);
		PlayerPrefs.SetInt("UnityGraphicsQuality", @int);
		Object.DontDestroyOnLoad((Object)(object)((Component)this).gameObject);
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/server_console.prefab"));
		StartupShared();
		World.InitSize(ConVar.Server.worldsize);
		World.InitSeed(ConVar.Server.seed);
		World.InitSalt(ConVar.Server.salt);
		World.Url = ConVar.Server.levelurl;
		World.Transfer = ConVar.Server.leveltransfer;
		yield return LevelManager.LoadLevelAsync(ConVar.Server.level);
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return ((MonoBehaviour)this).StartCoroutine(FileSystem_Warmup.Run(WriteToLog, "Asset Warmup ({0}/{1})"));
		yield return ((MonoBehaviour)this).StartCoroutine(StartServer(!CommandLine.HasSwitch("-skipload"), "", allowOutOfDateSaves: false));
		if (!Object.op_Implicit((Object)(object)Object.FindObjectOfType<Performance>()))
		{
			Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/performance.prefab"));
		}
		Rust.GC.Collect();
		Application.isLoading = false;
	}

	private static void EnsureRootFolderCreated()
	{
		try
		{
			Directory.CreateDirectory(ConVar.Server.rootFolder);
		}
		catch (Exception arg)
		{
			Debug.LogWarning((object)$"Failed to automatically create the save directory: {ConVar.Server.rootFolder}\n\n{arg}");
		}
	}

	public static IEnumerator StartNexusServer()
	{
		EnsureRootFolderCreated();
		yield return NexusServer.Initialize();
		if (NexusServer.FailedToStart)
		{
			Debug.LogError((object)"Nexus server failed to start, terminating");
			Application.Quit();
		}
	}

	public static IEnumerator StartServer(bool doLoad, string saveFileOverride, bool allowOutOfDateSaves)
	{
		float timeScale = Time.timeScale;
		if (ConVar.Time.pausewhileloading)
		{
			Time.timeScale = 0f;
		}
		RCon.Initialize();
		BaseEntity.Query.Server = new BaseEntity.Query.EntityTree(8096f);
		EnsureRootFolderCreated();
		if (Object.op_Implicit((Object)(object)SingletonComponent<WorldSetup>.Instance))
		{
			yield return ((MonoBehaviour)SingletonComponent<WorldSetup>.Instance).StartCoroutine(SingletonComponent<WorldSetup>.Instance.InitCoroutine());
		}
		if (Object.op_Implicit((Object)(object)SingletonComponent<DynamicNavMesh>.Instance) && ((Behaviour)SingletonComponent<DynamicNavMesh>.Instance).enabled && !AiManager.nav_disable)
		{
			yield return ((MonoBehaviour)SingletonComponent<DynamicNavMesh>.Instance).StartCoroutine(SingletonComponent<DynamicNavMesh>.Instance.UpdateNavMeshAndWait());
		}
		if (Object.op_Implicit((Object)(object)SingletonComponent<AiManager>.Instance) && ((Behaviour)SingletonComponent<AiManager>.Instance).enabled)
		{
			SingletonComponent<AiManager>.Instance.Initialize();
			if (!AiManager.nav_disable && AI.npc_enable && (Object)(object)TerrainMeta.Path != (Object)null)
			{
				foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
				{
					if (monument.HasNavmesh)
					{
						yield return ((MonoBehaviour)monument).StartCoroutine(monument.GetMonumentNavMesh().UpdateNavMeshAndWait());
					}
				}
				if (Object.op_Implicit((Object)(object)TerrainMeta.Path) && Object.op_Implicit((Object)(object)TerrainMeta.Path.DungeonGridRoot))
				{
					DungeonNavmesh dungeonNavmesh = TerrainMeta.Path.DungeonGridRoot.AddComponent<DungeonNavmesh>();
					dungeonNavmesh.NavMeshCollectGeometry = (NavMeshCollectGeometry)1;
					dungeonNavmesh.LayerMask = LayerMask.op_Implicit(65537);
					yield return ((MonoBehaviour)dungeonNavmesh).StartCoroutine(dungeonNavmesh.UpdateNavMeshAndWait());
				}
				else
				{
					Debug.LogWarning((object)"Failed to find DungeonGridRoot, NOT generating Dungeon navmesh");
				}
				if (Object.op_Implicit((Object)(object)TerrainMeta.Path) && Object.op_Implicit((Object)(object)TerrainMeta.Path.DungeonBaseRoot))
				{
					DungeonNavmesh dungeonNavmesh2 = TerrainMeta.Path.DungeonBaseRoot.AddComponent<DungeonNavmesh>();
					dungeonNavmesh2.NavmeshResolutionModifier = 0.3f;
					dungeonNavmesh2.NavMeshCollectGeometry = (NavMeshCollectGeometry)1;
					dungeonNavmesh2.LayerMask = LayerMask.op_Implicit(65537);
					yield return ((MonoBehaviour)dungeonNavmesh2).StartCoroutine(dungeonNavmesh2.UpdateNavMeshAndWait());
				}
				else
				{
					Debug.LogWarning((object)"Failed to find DungeonBaseRoot , NOT generating Dungeon navmesh");
				}
				GenerateDungeonBase.SetupAI();
			}
		}
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/shared.prefab"));
		GameObject val = GameManager.server.CreatePrefab("assets/bundled/prefabs/system/server.prefab");
		Object.DontDestroyOnLoad((Object)(object)val);
		ServerMgr serverMgr = val.GetComponent<ServerMgr>();
		bool saveWasLoaded = serverMgr.Initialize(doLoad, saveFileOverride, allowOutOfDateSaves);
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.InitializeEntityLinks();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.InitializeEntitySupports();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.InitializeEntityConditionals();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.GetSaveCache();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		BaseGameMode.CreateGameMode();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		MissionManifest.Get();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		if (Clan.enabled)
		{
			ClanManager clanManager = ClanManager.ServerInstance;
			if ((Object)(object)clanManager == (Object)null)
			{
				Debug.LogError((object)"ClanManager was not spawned!");
				Application.Quit();
				yield break;
			}
			Task initializeTask = clanManager.Initialize();
			yield return (object)new WaitUntil((Func<bool>)(() => initializeTask.IsCompleted));
			initializeTask.Wait();
			clanManager.LoadClanInfoForSleepers();
		}
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		if (ServerOcclusion.OcclusionEnabled)
		{
			ServerOcclusion.SetupGrid();
		}
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		if (NexusServer.Started)
		{
			NexusServer.UploadMapImage();
			if (saveWasLoaded)
			{
				NexusServer.RestoreUnsavedState();
			}
			NexusServer.ZoneClient.StartListening();
		}
		if (ConVar.Server.autoUploadMap)
		{
			Task uploadTask = MapUploader.UploadMap();
			while (!uploadTask.IsCompleted)
			{
				yield return null;
			}
			if (!uploadTask.IsCompletedSuccessfully)
			{
				Debug.LogError((object)"Failed to upload map file:");
				Debug.LogException((Exception)uploadTask.Exception);
			}
		}
		serverMgr.OpenConnection();
		CompanionServer.Server.Initialize();
		if (ConVar.Server.autoUploadMapImages && Map.ImageData != null)
		{
			MapUploader.UploadMapImage(Map.ImageData);
		}
		Scope val2 = BenchmarkTimer.Measure("Boombox.LoadStations");
		try
		{
			BoomBox.LoadStations();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		RustEmojiLibrary.FindAllServerEmoji();
		if (ConVar.Time.pausewhileloading)
		{
			Time.timeScale = timeScale;
		}
		WriteToLog("Server startup complete");
		Application.isServerStarted = true;
	}

	private void StartupShared()
	{
		Interface.CallHook("InitLogging");
		ItemManager.Initialize();
	}

	public bool RetrySteam()
	{
		if (!CommandLine.HasSwitch("-nosteam"))
		{
			return !PlatformService.Initialize((IPlatformHooks)(object)RustPlatformHooks.Instance);
		}
		return true;
	}

	public void ThrowError(string error)
	{
		isErrored = true;
	}

	public void ClearError()
	{
		isErrored = false;
	}

	public void ThrowSteamError()
	{
		isErrored = true;
	}

	public void ExitGame()
	{
		Debug.Log((object)"Exiting due to Exit Game button on bootstrap error panel");
		Application.Quit();
	}

	public static IEnumerator LoadingUpdate(Phrase phrase)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Bootstrap>.Instance))
		{
			SingletonComponent<Bootstrap>.Instance.currentLoadingPhrase = phrase;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
		}
	}

	public static void WriteToLog(string str)
	{
		if (!(lastWrittenValue == str))
		{
			DebugEx.Log((object)str, (StackTraceLogType)0);
			lastWrittenValue = str;
		}
	}

	private static void EarlyInitialize()
	{
	}
}


using System;
using System.Runtime.InteropServices;
using Facepunch;
using UnityEngine;

public static class SelfCheck
{
	public static bool Run()
	{
		if (FileSystem.Backend.isError)
		{
			return Failed("Asset Bundle Error: " + FileSystem.Backend.loadingError);
		}
		if ((Object)(object)FileSystem.Load<GameManifest>("Assets/manifest.asset", true) == (Object)null)
		{
			return Failed("Couldn't load game manifest - verify your game content!");
		}
		if (!TestRustNative())
		{
			return false;
		}
		if (CommandLine.HasSwitch("-force-feature-level-9-3"))
		{
			return Failed("Invalid command line argument: -force-feature-level-9-3");
		}
		if (CommandLine.HasSwitch("-force-feature-level-10-0"))
		{
			return Failed("Invalid command line argument: -force-feature-level-10-0");
		}
		if (CommandLine.HasSwitch("-force-feature-level-10-1"))
		{
			return Failed("Invalid command line argument: -force-feature-level-10-1");
		}
		return true;
	}

	private static bool Failed(string Message)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Bootstrap>.Instance))
		{
			SingletonComponent<Bootstrap>.Instance.currentLoadingPhrase = null;
			SingletonComponent<Bootstrap>.Instance.ThrowError(Message);
		}
		Debug.LogError((object)("SelfCheck Failed: " + Message));
		return false;
	}

	private static bool TestRustNative()
	{
		try
		{
			if (!RustNative_VersionCheck(5))
			{
				return Failed("RustNative is wrong version!");
			}
		}
		catch (DllNotFoundException ex)
		{
			return Failed("RustNative library couldn't load! " + ex.Message);
		}
		return true;
	}

	[DllImport("RustNative")]
	private static extern bool RustNative_VersionCheck(int version);
}


using UnityEngine;

public class BuildingBlockedGuide : MonoBehaviour
{
	public Mesh BoxMesh;

	public Mesh SphereMesh;

	public Mesh CapsuleMesh;

	public MeshRenderer Renderer;

	public MeshFilter Filter;

	public Collider LargestVolume;

	public float OverrideEnableDistance;
}


using ConVar;
using UnityEngine;
using UnityEngine.AI;

public abstract class BuildingManager
{
	public class Building
	{
		public uint ID;

		public ListHashSet<BuildingPrivlidge> buildingPrivileges = new ListHashSet<BuildingPrivlidge>();

		public ListHashSet<BuildingBlock> buildingBlocks = new ListHashSet<BuildingBlock>();

		public ListHashSet<DecayEntity> decayEntities = new ListHashSet<DecayEntity>();

		public ListHashSet<Door> doors = new ListHashSet<Door>();

		public NavMeshObstacle buildingNavMeshObstacle;

		public ListHashSet<NavMeshObstacle> navmeshCarvers;

		public bool isNavMeshCarvingDirty;

		public bool isNavMeshCarveOptimized;

		public bool IsEmpty()
		{
			if (HasBuildingPrivileges())
			{
				return false;
			}
			if (HasBuildingBlocks())
			{
				return false;
			}
			if (HasDecayEntities())
			{
				return false;
			}
			return true;
		}

		public BuildingPrivlidge GetDominatingBuildingPrivilege()
		{
			BuildingPrivlidge buildingPrivlidge = null;
			if (HasBuildingPrivileges())
			{
				for (int i = 0; i < buildingPrivileges.Count; i++)
				{
					BuildingPrivlidge buildingPrivlidge2 = buildingPrivileges[i];
					if (!((Object)(object)buildingPrivlidge2 == (Object)null) && buildingPrivlidge2.IsOlderThan(buildingPrivlidge))
					{
						buildingPrivlidge = buildingPrivlidge2;
					}
				}
			}
			return buildingPrivlidge;
		}

		public bool HasBuildingPrivileges()
		{
			if (buildingPrivileges != null)
			{
				return buildingPrivileges.Count > 0;
			}
			return false;
		}

		public bool HasBuildingBlocks()
		{
			if (buildingBlocks != null)
			{
				return buildingBlocks.Count > 0;
			}
			return false;
		}

		public bool HasDecayEntities()
		{
			if (decayEntities != null)
			{
				return decayEntities.Count > 0;
			}
			return false;
		}

		public void AddBuildingPrivilege(BuildingPrivlidge ent)
		{
			if (!((Object)(object)ent == (Object)null) && !buildingPrivileges.Contains(ent))
			{
				buildingPrivileges.Add(ent);
			}
		}

		public void RemoveBuildingPrivilege(BuildingPrivlidge ent)
		{
			if (!((Object)(object)ent == (Object)null))
			{
				buildingPrivileges.Remove(ent);
			}
		}

		public void AddBuildingBlock(BuildingBlock ent)
		{
			if ((Object)(object)ent == (Object)null || buildingBlocks.Contains(ent))
			{
				return;
			}
			buildingBlocks.Add(ent);
			if (!AI.nav_carve_use_building_optimization)
			{
				return;
			}
			NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
			if ((Object)(object)component != (Object)null)
			{
				isNavMeshCarvingDirty = true;
				if (navmeshCarvers == null)
				{
					navmeshCarvers = new ListHashSet<NavMeshObstacle>();
				}
				navmeshCarvers.Add(component);
			}
		}

		public void RemoveBuildingBlock(BuildingBlock ent)
		{
			if ((Object)(object)ent == (Object)null)
			{
				return;
			}
			buildingBlocks.Remove(ent);
			if (!AI.nav_carve_use_building_optimization || navmeshCarvers == null)
			{
				return;
			}
			NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
			if (!((Object)(object)component != (Object)null))
			{
				return;
			}
			navmeshCarvers.Remove(component);
			if (navmeshCarvers.Count == 0)
			{
				navmeshCarvers = null;
			}
			isNavMeshCarvingDirty = true;
			if (navmeshCarvers == null)
			{
				Building building = ent.GetBuilding();
				if (building != null)
				{
					int ticks = 2;
					server.UpdateNavMeshCarver(building, ref ticks, 0);
				}
			}
		}

		public void AddDecayEntity(DecayEntity ent)
		{
			if (!((Object)(object)ent == (Object)null))
			{
				if (!decayEntities.Contains(ent))
				{
					decayEntities.Add(ent);
				}
				if (ent is Door door && !doors.Contains(door))
				{
					doors.Add(ent as Door);
				}
			}
		}

		public void RemoveDecayEntity(DecayEntity ent)
		{
			if (!((Object)(object)ent == (Object)null))
			{
				decayEntities.Remove(ent);
				if (ent is Door door)
				{
					doors.Remove(door);
				}
			}
		}

		public void Add(DecayEntity ent)
		{
			AddDecayEntity(ent);
			AddBuildingBlock(ent as BuildingBlock);
			AddBuildingPrivilege(ent as BuildingPrivlidge);
		}

		public void Remove(DecayEntity ent)
		{
			RemoveDecayEntity(ent);
			RemoveBuildingBlock(ent as BuildingBlock);
			RemoveBuildingPrivilege(ent as BuildingPrivlidge);
		}

		public void Dirty()
		{
			BuildingPrivlidge dominatingBuildingPrivilege = GetDominatingBuildingPrivilege();
			if ((Object)(object)dominatingBuildingPrivilege != (Object)null)
			{
				dominatingBuildingPrivilege.BuildingDirty();
			}
		}
	}

	public static ServerBuildingManager server = new ServerBuildingManager();

	public ListHashSet<DecayEntity> decayEntities = new ListHashSet<DecayEntity>();

	public ListDictionary<uint, Building> buildingDictionary = new ListDictionary<uint, Building>();

	public Building GetBuilding(uint buildingID)
	{
		Building result = null;
		buildingDictionary.TryGetValue(buildingID, ref result);
		return result;
	}

	public void Add(DecayEntity ent)
	{
		if (ent.buildingID == 0)
		{
			if (!decayEntities.Contains(ent))
			{
				decayEntities.Add(ent);
			}
			return;
		}
		Building building = GetBuilding(ent.buildingID);
		if (building == null)
		{
			building = CreateBuilding(ent.buildingID);
			buildingDictionary.Add(ent.buildingID, building);
		}
		building.Add(ent);
		building.Dirty();
	}

	public void Remove(DecayEntity ent)
	{
		if (ent.buildingID == 0)
		{
			decayEntities.Remove(ent);
			return;
		}
		Building building = GetBuilding(ent.buildingID);
		if (building != null)
		{
			building.Remove(ent);
			if (building.IsEmpty())
			{
				buildingDictionary.Remove(ent.buildingID);
				DisposeBuilding(ref building);
			}
			else
			{
				building.Dirty();
			}
		}
	}

	public void Clear()
	{
		buildingDictionary.Clear();
	}

	protected abstract Building CreateBuilding(uint id);

	protected abstract void DisposeBuilding(ref Building building);
}


using ConVar;
using UnityEngine;
using UnityEngine.AI;

public class Building
{
	public uint ID;

	public ListHashSet<BuildingPrivlidge> buildingPrivileges = new ListHashSet<BuildingPrivlidge>();

	public ListHashSet<BuildingBlock> buildingBlocks = new ListHashSet<BuildingBlock>();

	public ListHashSet<DecayEntity> decayEntities = new ListHashSet<DecayEntity>();

	public ListHashSet<Door> doors = new ListHashSet<Door>();

	public NavMeshObstacle buildingNavMeshObstacle;

	public ListHashSet<NavMeshObstacle> navmeshCarvers;

	public bool isNavMeshCarvingDirty;

	public bool isNavMeshCarveOptimized;

	public bool IsEmpty()
	{
		if (HasBuildingPrivileges())
		{
			return false;
		}
		if (HasBuildingBlocks())
		{
			return false;
		}
		if (HasDecayEntities())
		{
			return false;
		}
		return true;
	}

	public BuildingPrivlidge GetDominatingBuildingPrivilege()
	{
		BuildingPrivlidge buildingPrivlidge = null;
		if (HasBuildingPrivileges())
		{
			for (int i = 0; i < buildingPrivileges.Count; i++)
			{
				BuildingPrivlidge buildingPrivlidge2 = buildingPrivileges[i];
				if (!((Object)(object)buildingPrivlidge2 == (Object)null) && buildingPrivlidge2.IsOlderThan(buildingPrivlidge))
				{
					buildingPrivlidge = buildingPrivlidge2;
				}
			}
		}
		return buildingPrivlidge;
	}

	public bool HasBuildingPrivileges()
	{
		if (buildingPrivileges != null)
		{
			return buildingPrivileges.Count > 0;
		}
		return false;
	}

	public bool HasBuildingBlocks()
	{
		if (buildingBlocks != null)
		{
			return buildingBlocks.Count > 0;
		}
		return false;
	}

	public bool HasDecayEntities()
	{
		if (decayEntities != null)
		{
			return decayEntities.Count > 0;
		}
		return false;
	}

	public void AddBuildingPrivilege(BuildingPrivlidge ent)
	{
		if (!((Object)(object)ent == (Object)null) && !buildingPrivileges.Contains(ent))
		{
			buildingPrivileges.Add(ent);
		}
	}

	public void RemoveBuildingPrivilege(BuildingPrivlidge ent)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			buildingPrivileges.Remove(ent);
		}
	}

	public void AddBuildingBlock(BuildingBlock ent)
	{
		if ((Object)(object)ent == (Object)null || buildingBlocks.Contains(ent))
		{
			return;
		}
		buildingBlocks.Add(ent);
		if (!AI.nav_carve_use_building_optimization)
		{
			return;
		}
		NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
		if ((Object)(object)component != (Object)null)
		{
			isNavMeshCarvingDirty = true;
			if (navmeshCarvers == null)
			{
				navmeshCarvers = new ListHashSet<NavMeshObstacle>();
			}
			navmeshCarvers.Add(component);
		}
	}

	public void RemoveBuildingBlock(BuildingBlock ent)
	{
		if ((Object)(object)ent == (Object)null)
		{
			return;
		}
		buildingBlocks.Remove(ent);
		if (!AI.nav_carve_use_building_optimization || navmeshCarvers == null)
		{
			return;
		}
		NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
		if (!((Object)(object)component != (Object)null))
		{
			return;
		}
		navmeshCarvers.Remove(component);
		if (navmeshCarvers.Count == 0)
		{
			navmeshCarvers = null;
		}
		isNavMeshCarvingDirty = true;
		if (navmeshCarvers == null)
		{
			Building building = ent.GetBuilding();
			if (building != null)
			{
				int ticks = 2;
				server.UpdateNavMeshCarver(building, ref ticks, 0);
			}
		}
	}

	public void AddDecayEntity(DecayEntity ent)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			if (!decayEntities.Contains(ent))
			{
				decayEntities.Add(ent);
			}
			if (ent is Door door && !doors.Contains(door))
			{
				doors.Add(ent as Door);
			}
		}
	}

	public void RemoveDecayEntity(DecayEntity ent)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			decayEntities.Remove(ent);
			if (ent is Door door)
			{
				doors.Remove(door);
			}
		}
	}

	public void Add(DecayEntity ent)
	{
		AddDecayEntity(ent);
		AddBuildingBlock(ent as BuildingBlock);
		AddBuildingPrivilege(ent as BuildingPrivlidge);
	}

	public void Remove(DecayEntity ent)
	{
		RemoveDecayEntity(ent);
		RemoveBuildingBlock(ent as BuildingBlock);
		RemoveBuildingPrivilege(ent as BuildingPrivlidge);
	}

	public void Dirty()
	{
		BuildingPrivlidge dominatingBuildingPrivilege = GetDominatingBuildingPrivilege();
		if ((Object)(object)dominatingBuildingPrivilege != (Object)null)
		{
			dominatingBuildingPrivilege.BuildingDirty();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using UnityEngine;
using UnityEngine.AI;

public class ServerBuildingManager : BuildingManager
{
	private int decayTickBuildingIndex;

	private int decayTickEntityIndex;

	private int decayTickWorldIndex;

	private int navmeshCarveTickBuildingIndex;

	private uint maxBuildingID;

	public void CheckSplit(DecayEntity ent)
	{
		if (ent.buildingID != 0)
		{
			Building building = ent.GetBuilding();
			if (building != null && ShouldSplit(building))
			{
				Split(building);
			}
		}
	}

	private bool ShouldSplit(Building building)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (building.HasBuildingBlocks())
		{
			building.buildingBlocks[0].EntityLinkBroadcast();
			Enumerator<BuildingBlock> enumerator = building.buildingBlocks.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					if (!enumerator.Current.ReceivedEntityLinkBroadcast())
					{
						return true;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		return false;
	}

	private void Split(Building oldBuilding)
	{
		List<Building> list = Pool.Get<List<Building>>();
		Building largestSplit = null;
		while (oldBuilding.HasBuildingBlocks())
		{
			BuildingBlock buildingBlock = oldBuilding.buildingBlocks[0];
			uint newID = BuildingManager.server.NewBuildingID();
			Interface.CallHook("OnBuildingSplit", (object)oldBuilding, (object)newID);
			buildingBlock.EntityLinkBroadcast(delegate(BuildingBlock b)
			{
				b.AttachToBuilding(newID);
			});
			Building building = BuildingManager.server.GetBuilding(newID);
			if (building != null)
			{
				list.Add(building);
			}
		}
		int num = 0;
		foreach (Building item in list)
		{
			if (item.buildingBlocks.Count > num)
			{
				num = item.buildingBlocks.Count;
				largestSplit = item;
			}
		}
		SplitEntities<BuildingPrivlidge>(oldBuilding.buildingPrivileges, largestSplit);
		SplitEntities<DecayEntity>(oldBuilding.decayEntities, largestSplit);
		if (AI.nav_carve_use_building_optimization)
		{
			oldBuilding.isNavMeshCarvingDirty = true;
			int ticks = 2;
			UpdateNavMeshCarver(oldBuilding, ref ticks, 0);
		}
		Pool.FreeUnmanaged<Building>(ref list);
	}

	private static void SplitEntities<T>(ListHashSet<T> input, Building largestSplit) where T : DecayEntity
	{
		List<T> list = Pool.Get<List<T>>();
		list.AddRange((IEnumerable<T>)input);
		foreach (T item in list)
		{
			BuildingBlock nearbyBuildingBlock = item.GetNearbyBuildingBlock();
			uint num = ((item is ContainerCorpse || item.GetParentEntity() is ContainerCorpse) ? largestSplit.ID : 0u);
			item.AttachToBuilding(Object.op_Implicit((Object)(object)nearbyBuildingBlock) ? nearbyBuildingBlock.buildingID : num);
		}
		Pool.FreeUnmanaged<T>(ref list);
	}

	public void CheckMerge(DecayEntity ent)
	{
		if (ent.buildingID == 0)
		{
			return;
		}
		Building building = ent.GetBuilding();
		if (building == null)
		{
			return;
		}
		ent.EntityLinkMessage(delegate(BuildingBlock b)
		{
			if (b.buildingID != building.ID)
			{
				Building building2 = b.GetBuilding();
				if (building2 != null)
				{
					Merge(building, building2);
				}
			}
		});
		if (AI.nav_carve_use_building_optimization)
		{
			building.isNavMeshCarvingDirty = true;
			int ticks = 2;
			UpdateNavMeshCarver(building, ref ticks, 0);
		}
	}

	private void Merge(Building building1, Building building2)
	{
		Interface.CallHook("OnBuildingMerge", (object)this, (object)building1, (object)building2);
		while (building2.HasDecayEntities())
		{
			building2.decayEntities[0].AttachToBuilding(building1.ID);
		}
		if (AI.nav_carve_use_building_optimization)
		{
			building1.isNavMeshCarvingDirty = true;
			building2.isNavMeshCarvingDirty = true;
			int ticks = 3;
			UpdateNavMeshCarver(building1, ref ticks, 0);
			UpdateNavMeshCarver(building1, ref ticks, 0);
		}
	}

	public void Cycle()
	{
		TimeWarning val = TimeWarning.New("StabilityCheckQueue", 0);
		try
		{
			((ObjectWorkQueue<StabilityEntity>)StabilityEntity.stabilityCheckQueue).RunQueue((double)Stability.stabilityqueue);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("UpdateSurroundingsQueue", 0);
		try
		{
			((ObjectWorkQueue<Bounds>)StabilityEntity.updateSurroundingsQueue).RunQueue((double)Stability.surroundingsqueue);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("UpdateSkinQueue", 0);
		try
		{
			((ObjectWorkQueue<BuildingBlock>)BuildingBlock.updateSkinQueueServer).RunQueue(1.0);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("BuildingDecayTick", 0);
		try
		{
			int num = 5;
			BufferList<Building> values = buildingDictionary.Values;
			for (int i = decayTickBuildingIndex; i < values.Count; i++)
			{
				if (num <= 0)
				{
					break;
				}
				BufferList<DecayEntity> values2 = values[i].decayEntities.Values;
				for (int j = decayTickEntityIndex; j < values2.Count; j++)
				{
					if (num <= 0)
					{
						break;
					}
					values2[j].DecayTick();
					num--;
					if (num <= 0)
					{
						decayTickBuildingIndex = i;
						decayTickEntityIndex = j;
					}
				}
				if (num > 0)
				{
					decayTickEntityIndex = 0;
				}
			}
			if (num > 0)
			{
				decayTickBuildingIndex = 0;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("WorldDecayTick", 0);
		try
		{
			int num2 = 5;
			BufferList<DecayEntity> values3 = decayEntities.Values;
			for (int k = decayTickWorldIndex; k < values3.Count; k++)
			{
				if (num2 <= 0)
				{
					break;
				}
				values3[k].DecayTick();
				num2--;
				if (num2 <= 0)
				{
					decayTickWorldIndex = k;
				}
			}
			if (num2 > 0)
			{
				decayTickWorldIndex = 0;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (!AI.nav_carve_use_building_optimization)
		{
			return;
		}
		val = TimeWarning.New("NavMeshCarving", 0);
		try
		{
			int ticks = 5;
			BufferList<Building> values4 = buildingDictionary.Values;
			for (int l = navmeshCarveTickBuildingIndex; l < values4.Count; l++)
			{
				if (ticks <= 0)
				{
					break;
				}
				Building building = values4[l];
				UpdateNavMeshCarver(building, ref ticks, l);
			}
			if (ticks > 0)
			{
				navmeshCarveTickBuildingIndex = 0;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void UpdateNavMeshCarver(Building building, ref int ticks, int i)
	{
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.nav_carve_use_building_optimization || (!building.isNavMeshCarveOptimized && building.navmeshCarvers.Count < AI.nav_carve_min_building_blocks_to_apply_optimization) || !building.isNavMeshCarvingDirty)
		{
			return;
		}
		building.isNavMeshCarvingDirty = false;
		if (building.navmeshCarvers == null)
		{
			if ((Object)(object)building.buildingNavMeshObstacle != (Object)null)
			{
				Object.Destroy((Object)(object)((Component)building.buildingNavMeshObstacle).gameObject);
				building.buildingNavMeshObstacle = null;
				building.isNavMeshCarveOptimized = false;
			}
			return;
		}
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor((float)World.Size, (float)World.Size, (float)World.Size);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor((float)(0L - (long)World.Size), (float)(0L - (long)World.Size), (float)(0L - (long)World.Size));
		int count = building.navmeshCarvers.Count;
		if (count > 0)
		{
			for (int j = 0; j < count; j++)
			{
				NavMeshObstacle val3 = building.navmeshCarvers[j];
				if (((Behaviour)val3).enabled)
				{
					((Behaviour)val3).enabled = false;
				}
				for (int k = 0; k < 3; k++)
				{
					Vector3 position = ((Component)val3).transform.position;
					if (((Vector3)(ref position))[k] < ((Vector3)(ref val))[k])
					{
						int num = k;
						position = ((Component)val3).transform.position;
						((Vector3)(ref val))[num] = ((Vector3)(ref position))[k];
					}
					position = ((Component)val3).transform.position;
					if (((Vector3)(ref position))[k] > ((Vector3)(ref val2))[k])
					{
						int num2 = k;
						position = ((Component)val3).transform.position;
						((Vector3)(ref val2))[num2] = ((Vector3)(ref position))[k];
					}
				}
			}
			Vector3 val4 = (val2 + val) * 0.5f;
			Vector3 zero = Vector3.zero;
			float num3 = Mathf.Abs(val4.x - val.x);
			float num4 = Mathf.Abs(val4.y - val.y);
			float num5 = Mathf.Abs(val4.z - val.z);
			float num6 = Mathf.Abs(val2.x - val4.x);
			float num7 = Mathf.Abs(val2.y - val4.y);
			float num8 = Mathf.Abs(val2.z - val4.z);
			zero.x = Mathf.Max((num3 > num6) ? num3 : num6, AI.nav_carve_min_base_size);
			zero.y = Mathf.Max((num4 > num7) ? num4 : num7, AI.nav_carve_min_base_size);
			zero.z = Mathf.Max((num5 > num8) ? num5 : num8, AI.nav_carve_min_base_size);
			zero = ((count >= 10) ? (zero * (AI.nav_carve_size_multiplier - 1f)) : (zero * AI.nav_carve_size_multiplier));
			if (building.navmeshCarvers.Count > 0)
			{
				if ((Object)(object)building.buildingNavMeshObstacle == (Object)null)
				{
					building.buildingNavMeshObstacle = new GameObject($"Building ({building.ID}) NavMesh Carver").AddComponent<NavMeshObstacle>();
					((Behaviour)building.buildingNavMeshObstacle).enabled = false;
					building.buildingNavMeshObstacle.carving = true;
					building.buildingNavMeshObstacle.shape = (NavMeshObstacleShape)1;
					building.buildingNavMeshObstacle.height = AI.nav_carve_height;
					building.isNavMeshCarveOptimized = true;
				}
				if ((Object)(object)building.buildingNavMeshObstacle != (Object)null)
				{
					((Component)building.buildingNavMeshObstacle).transform.position = val4;
					building.buildingNavMeshObstacle.size = zero;
					if (!((Behaviour)building.buildingNavMeshObstacle).enabled)
					{
						((Behaviour)building.buildingNavMeshObstacle).enabled = true;
					}
				}
			}
		}
		else if ((Object)(object)building.buildingNavMeshObstacle != (Object)null)
		{
			Object.Destroy((Object)(object)((Component)building.buildingNavMeshObstacle).gameObject);
			building.buildingNavMeshObstacle = null;
			building.isNavMeshCarveOptimized = false;
		}
		ticks--;
		if (ticks <= 0)
		{
			navmeshCarveTickBuildingIndex = i;
		}
	}

	public uint NewBuildingID()
	{
		return ++maxBuildingID;
	}

	public void LoadBuildingID(uint id)
	{
		maxBuildingID = Mathx.Max(maxBuildingID, id);
	}

	protected override Building CreateBuilding(uint id)
	{
		return new Building
		{
			ID = id
		};
	}

	protected override void DisposeBuilding(ref Building building)
	{
		building = null;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using Facepunch;
using UnityEngine;

public sealed class ClanAsyncResult<T> : IPooled
{
	private readonly List<Action<T>> _callbacks = new List<Action<T>>(4);

	private readonly Stopwatch _sinceStarted = new Stopwatch();

	private bool _isComplete;

	private T _result;

	public bool IsStarted => _sinceStarted.IsRunning;

	public float Elapsed => (float)_sinceStarted.Elapsed.TotalSeconds;

	public bool IsComplete => _isComplete;

	public void Start()
	{
		_sinceStarted.Restart();
	}

	public bool TrySetResult(T result)
	{
		if (_isComplete)
		{
			return false;
		}
		_result = result;
		_isComplete = true;
		_sinceStarted.Stop();
		foreach (Action<T> callback in _callbacks)
		{
			try
			{
				callback(_result);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		_callbacks.Clear();
		return true;
	}

	public void OnComplete(Action<T> callback)
	{
		if (callback == null)
		{
			throw new ArgumentNullException("callback");
		}
		if (_isComplete)
		{
			try
			{
				callback(_result);
				return;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				return;
			}
		}
		_callbacks.Add(callback);
	}

	private void Reset()
	{
		_callbacks.Clear();
		_sinceStarted.Reset();
		_isComplete = false;
		_result = default(T);
	}

	void IPooled.EnterPool()
	{
		Reset();
	}

	void IPooled.LeavePool()
	{
		Reset();
	}
}


using System;
using System.Collections.Generic;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using ProtoBuf;
using UnityEngine;

public class ClanChangeTracker : IClanChangeSink
{
	private struct ClanChangedEvent
	{
		public long ClanId;

		public ClanDataSource DataSources;
	}

	private struct ClanDisbandedEvent
	{
		public long ClanId;
	}

	private struct InvitationCreatedEvent
	{
		public ulong SteamId;

		public long ClanId;
	}

	private struct MembershipChangedEvent
	{
		public ulong SteamId;

		public long ClanId;
	}

	private struct ChatMessageEvent
	{
		public long ClanId;

		public ClanChatEntry Message;
	}

	private class ChatMessageEventComparer : IComparer<ChatMessageEvent>
	{
		public static readonly ChatMessageEventComparer Instance = new ChatMessageEventComparer();

		public int Compare(ChatMessageEvent x, ChatMessageEvent y)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			return x.Message.Time.CompareTo(y.Message.Time);
		}
	}

	private readonly ClanManager _clanManager;

	private readonly List<ClanChangedEvent> _clanChangedEvents = new List<ClanChangedEvent>();

	private readonly List<ClanDisbandedEvent> _clanDisbandedEvents = new List<ClanDisbandedEvent>();

	private readonly List<InvitationCreatedEvent> _invitationCreatedEvents = new List<InvitationCreatedEvent>();

	private readonly List<MembershipChangedEvent> _membershipChangedEvents = new List<MembershipChangedEvent>();

	private readonly List<ChatMessageEvent> _chatMessageEvents = new List<ChatMessageEvent>();

	public ClanChangeTracker(ClanManager clanManager)
	{
		_clanManager = clanManager;
	}

	public void HandleEvents()
	{
		lock (_clanChangedEvents)
		{
			foreach (ClanChangedEvent clanChangedEvent in _clanChangedEvents)
			{
				HandleClanChanged(clanChangedEvent);
			}
			_clanChangedEvents.Clear();
		}
		lock (_clanDisbandedEvents)
		{
			foreach (ClanDisbandedEvent clanDisbandedEvent in _clanDisbandedEvents)
			{
				HandleClanDisbanded(clanDisbandedEvent);
			}
			_clanDisbandedEvents.Clear();
		}
		lock (_invitationCreatedEvents)
		{
			foreach (InvitationCreatedEvent invitationCreatedEvent in _invitationCreatedEvents)
			{
				HandleInvitationCreated(invitationCreatedEvent);
			}
			_invitationCreatedEvents.Clear();
		}
		lock (_membershipChangedEvents)
		{
			foreach (MembershipChangedEvent membershipChangedEvent in _membershipChangedEvents)
			{
				HandleMembershipChanged(membershipChangedEvent);
			}
			_membershipChangedEvents.Clear();
		}
		lock (_chatMessageEvents)
		{
			foreach (ChatMessageEvent chatMessageEvent in _chatMessageEvents)
			{
				HandleChatMessageEvent(chatMessageEvent);
			}
			_chatMessageEvents.Clear();
		}
	}

	private void HandleClanChanged(in ClanChangedEvent data)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		IClan clan = default(IClan);
		if (_clanManager.Backend.TryGet(data.ClanId, ref clan))
		{
			_clanManager.SendClanChanged(clan);
			AppBroadcast val = Pool.Get<AppBroadcast>();
			val.clanChanged = Pool.Get<AppClanChanged>();
			val.clanChanged.clanInfo = clan.ToProto();
			CompanionServer.Server.Broadcast(new ClanTarget(data.ClanId), val);
		}
		if (((Enum)data.DataSources).HasFlag((Enum)(object)(ClanDataSource)16))
		{
			_clanManager.ClanMemberConnectionsChanged(data.ClanId);
		}
	}

	private void HandleClanDisbanded(in ClanDisbandedEvent data)
	{
	}

	private void HandleInvitationCreated(in InvitationCreatedEvent data)
	{
		_clanManager.SendClanInvitation(data.SteamId, data.ClanId);
	}

	private void HandleMembershipChanged(in MembershipChangedEvent data)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(data.SteamId);
		if ((Object)(object)basePlayer == (Object)null)
		{
			basePlayer = BasePlayer.FindSleeping(data.SteamId);
		}
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.clanId = data.ClanId;
			basePlayer.SendNetworkUpdateImmediate();
			if (basePlayer.IsConnected)
			{
				_clanManager.ClientRPC(RpcTarget.Player("Client_CurrentClanChanged", basePlayer));
			}
			IClan serverClan = default(IClan);
			if (_clanManager.Backend.TryGet(basePlayer.clanId, ref serverClan))
			{
				basePlayer.serverClan = serverClan;
			}
			else
			{
				basePlayer.LoadClanInfo();
			}
		}
	}

	private void HandleChatMessageEvent(in ChatMessageEvent data)
	{
		if (_clanManager.TryGetClanMemberConnections(data.ClanId, out var connections) && connections.Count > 0)
		{
			string nameColor = Chat.GetNameColor(data.Message.SteamId);
			ConsoleNetwork.SendClientCommand(connections, "chat.add2", 5, data.Message.SteamId, data.Message.Message, data.Message.Name, nameColor, 1f);
		}
		AppBroadcast val = Pool.Get<AppBroadcast>();
		val.clanMessage = Pool.Get<AppNewClanMessage>();
		val.clanMessage.clanId = data.ClanId;
		val.clanMessage.message = Pool.Get<AppClanMessage>();
		val.clanMessage.message.steamId = data.Message.SteamId;
		val.clanMessage.message.name = data.Message.Name;
		val.clanMessage.message.message = data.Message.Message;
		val.clanMessage.message.time = data.Message.Time;
		CompanionServer.Server.Broadcast(new ClanTarget(data.ClanId), val);
	}

	public void ClanChanged(long clanId, ClanDataSource dataSources)
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Expected I4, but got Unknown
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		lock (_clanChangedEvents)
		{
			int num = List.FindIndexWith<ClanChangedEvent, long>((IReadOnlyList<ClanChangedEvent>)_clanChangedEvents, (Func<ClanChangedEvent, long>)((ClanChangedEvent e) => e.ClanId), clanId, (IEqualityComparer<long>)null);
			if (num < 0)
			{
				_clanChangedEvents.Add(new ClanChangedEvent
				{
					ClanId = clanId,
					DataSources = dataSources
				});
			}
			else
			{
				ClanChangedEvent value = _clanChangedEvents[num];
				ref ClanDataSource dataSources2 = ref value.DataSources;
				dataSources2 |= dataSources;
				_clanChangedEvents[num] = value;
			}
		}
	}

	public void ClanDisbanded(long clanId)
	{
		lock (_clanDisbandedEvents)
		{
			_clanDisbandedEvents.Add(new ClanDisbandedEvent
			{
				ClanId = clanId
			});
		}
	}

	public void InvitationCreated(ulong steamId, long clanId)
	{
		lock (_invitationCreatedEvents)
		{
			_invitationCreatedEvents.Add(new InvitationCreatedEvent
			{
				SteamId = steamId,
				ClanId = clanId
			});
		}
	}

	public void MembershipChanged(ulong steamId, long? clanId)
	{
		lock (_membershipChangedEvents)
		{
			_membershipChangedEvents.Add(new MembershipChangedEvent
			{
				SteamId = steamId,
				ClanId = clanId.GetValueOrDefault()
			});
		}
	}

	public void ClanChatMessage(long clanId, ClanChatEntry entry)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		lock (_chatMessageEvents)
		{
			ChatMessageEvent chatMessageEvent = default(ChatMessageEvent);
			chatMessageEvent.ClanId = clanId;
			chatMessageEvent.Message = entry;
			ChatMessageEvent item = chatMessageEvent;
			int num = _chatMessageEvents.BinarySearch(item, ChatMessageEventComparer.Instance);
			_chatMessageEvents.Insert((num >= 0) ? num : (~num), item);
		}
	}
}


private struct ClanChangedEvent
{
	public long ClanId;

	public ClanDataSource DataSources;
}


private struct ClanDisbandedEvent
{
	public long ClanId;
}


private struct InvitationCreatedEvent
{
	public ulong SteamId;

	public long ClanId;
}


private struct MembershipChangedEvent
{
	public ulong SteamId;

	public long ClanId;
}


private struct ChatMessageEvent
{
	public long ClanId;

	public ClanChatEntry Message;
}


using System.Collections.Generic;

private class ChatMessageEventComparer : IComparer<ChatMessageEvent>
{
	public static readonly ChatMessageEventComparer Instance = new ChatMessageEventComparer();

	public int Compare(ChatMessageEvent x, ChatMessageEvent y)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return x.Message.Time.CompareTo(y.Message.Time);
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public static class ClanInfoExtensions
{
	public static ClanInfo ToProto(this IClan clan)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if (clan == null)
		{
			return null;
		}
		ClanInfo val = Pool.Get<ClanInfo>();
		val.clanId = clan.ClanId;
		val.name = clan.Name;
		val.created = clan.Created;
		val.creator = clan.Creator;
		val.motd = clan.Motd;
		val.motdTimestamp = clan.MotdTimestamp;
		val.motdAuthor = clan.MotdAuthor;
		val.logo = clan.Logo;
		val.color = ColorEx.ToInt32(clan.Color);
		val.maxMemberCount = clan.MaxMemberCount;
		val.score = clan.Score;
		val.roles = Pool.Get<List<Role>>();
		foreach (ClanRole role in clan.Roles)
		{
			val.roles.Add(role.ToProto());
		}
		val.members = Pool.Get<List<Member>>();
		foreach (ClanMember member in clan.Members)
		{
			val.members.Add(member.ToProto());
		}
		val.invites = Pool.Get<List<Invite>>();
		foreach (ClanInvite invite in clan.Invites)
		{
			val.invites.Add(invite.ToProto());
		}
		return val;
	}

	private static Role ToProto(this ClanRole role)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		bool flag = role.Rank == 1;
		Role obj = Pool.Get<Role>();
		obj.roleId = role.RoleId;
		obj.rank = role.Rank;
		obj.name = role.Name;
		obj.canSetMotd = flag || role.CanSetMotd;
		obj.canSetLogo = flag || role.CanSetLogo;
		obj.canInvite = flag || role.CanInvite;
		obj.canKick = flag || role.CanKick;
		obj.canPromote = flag || role.CanPromote;
		obj.canDemote = flag || role.CanDemote;
		obj.canSetPlayerNotes = flag || role.CanSetPlayerNotes;
		obj.canAccessLogs = flag || role.CanAccessLogs;
		obj.canAccessScoreEvents = flag || role.CanAccessScoreEvents;
		return obj;
	}

	public static ClanRole FromProto(this Role proto)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		ClanRole result = default(ClanRole);
		result.RoleId = proto.roleId;
		result.Rank = proto.rank;
		result.Name = proto.name;
		result.CanSetMotd = proto.canSetMotd;
		result.CanSetLogo = proto.canSetLogo;
		result.CanInvite = proto.canInvite;
		result.CanKick = proto.canKick;
		result.CanPromote = proto.canPromote;
		result.CanDemote = proto.canDemote;
		result.CanSetPlayerNotes = proto.canSetPlayerNotes;
		result.CanAccessLogs = proto.canAccessLogs;
		result.CanAccessScoreEvents = proto.canAccessScoreEvents;
		return result;
	}

	private static Member ToProto(this ClanMember member)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Member obj = Pool.Get<Member>();
		obj.steamId = member.SteamId;
		obj.roleId = member.RoleId;
		obj.joined = member.Joined;
		obj.lastSeen = member.LastSeen;
		obj.notes = member.Notes;
		obj.online = (NexusServer.Started ? NexusServer.IsOnline(member.SteamId) : ServerPlayers.IsOnline(member.SteamId));
		return obj;
	}

	private static Invite ToProto(this ClanInvite invite)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Invite obj = Pool.Get<Invite>();
		obj.steamId = invite.SteamId;
		obj.recruiter = invite.Recruiter;
		obj.timestamp = invite.Timestamp;
		return obj;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public static class ClanInvitationExtensions
{
	public static ClanInvitations ToProto(this List<ClanInvitation> invitations)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		List<Invitation> list = Pool.Get<List<Invitation>>();
		foreach (ClanInvitation invitation in invitations)
		{
			list.Add(invitation.ToProto());
		}
		ClanInvitations obj = Pool.Get<ClanInvitations>();
		obj.invitations = list;
		return obj;
	}

	public static Invitation ToProto(this ClanInvitation invitation)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Invitation obj = Pool.Get<Invitation>();
		obj.clanId = invitation.ClanId;
		obj.recruiter = invitation.Recruiter;
		obj.timestamp = invitation.Timestamp;
		return obj;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public static class ClanLeaderboardExtensions
{
	public static ClanLeaderboard ToProto(this List<ClanLeaderboardEntry> leaderboard)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		List<Entry> list = Pool.Get<List<Entry>>();
		foreach (ClanLeaderboardEntry item in leaderboard)
		{
			list.Add(item.ToProto());
		}
		ClanLeaderboard obj = Pool.Get<ClanLeaderboard>();
		obj.entries = list;
		return obj;
	}

	public static Entry ToProto(this ClanLeaderboardEntry entry)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Entry obj = Pool.Get<Entry>();
		obj.clanId = entry.ClanId;
		obj.name = entry.Name;
		obj.score = entry.Score;
		return obj;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public static class ClanLogExtensions
{
	public static ClanLog ToProto(this ClanLogs clanLogs)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		List<Entry> list = Pool.Get<List<Entry>>();
		foreach (ClanLogEntry entry in clanLogs.Entries)
		{
			Entry val = Pool.Get<Entry>();
			val.timestamp = entry.Timestamp;
			val.eventKey = entry.EventKey;
			val.arg1 = entry.Arg1;
			val.arg2 = entry.Arg2;
			val.arg3 = entry.Arg3;
			val.arg4 = entry.Arg4;
			list.Add(val);
		}
		ClanLog obj = Pool.Get<ClanLog>();
		obj.clanId = clanLogs.ClanId;
		obj.logEntries = list;
		return obj;
	}

	public static ClanScoreEvents ToProto(this ClanScoreEvents clanScoreEvents)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected I4, but got Unknown
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		List<Entry> list = Pool.Get<List<Entry>>();
		foreach (ClanScoreEvent scoreEvent in clanScoreEvents.ScoreEvents)
		{
			Entry val = Pool.Get<Entry>();
			val.timestamp = scoreEvent.Timestamp;
			val.type = (int)scoreEvent.Type;
			val.score = scoreEvent.Score;
			val.multiplier = scoreEvent.Multiplier;
			val.steamId = scoreEvent.SteamId.GetValueOrDefault();
			val.otherSteamId = scoreEvent.OtherSteamId.GetValueOrDefault();
			val.otherClanId = scoreEvent.OtherClanId.GetValueOrDefault();
			val.arg1 = scoreEvent.Arg1;
			val.arg2 = scoreEvent.Arg2;
			list.Add(val);
		}
		ClanScoreEvents obj = Pool.Get<ClanScoreEvents>();
		obj.clanId = clanScoreEvents.ClanId;
		obj.scoreEvents = list;
		return obj;
	}
}


using UnityEngine;

public struct ClanMetadata
{
	public long ClanId;

	public string Name;

	public int Members;

	public Color32 Color;
}


using System;
using System.Collections.Generic;
using CompanionServer;
using ConVar;
using Facepunch;
using UnityEngine;

public static class ClanPushNotifications
{
	public static async void SendClanAnnouncement(IClan clan, long previousTimestamp, ulong ignorePlayer)
	{
		if (ClanUtility.Timestamp() - previousTimestamp < 300000)
		{
			return;
		}
		try
		{
			List<ulong> steamIds = Pool.Get<List<ulong>>();
			foreach (ClanMember member in clan.Members)
			{
				if (member.SteamId != ignorePlayer)
				{
					steamIds.Add(member.SteamId);
				}
			}
			Dictionary<string, string> dictionary = Util.TryGetServerPairingData();
			if (dictionary != null)
			{
				dictionary.Add("type", "clan");
				dictionary.Add("fromId", ignorePlayer.ToString("G"));
				await NotificationList.SendNotificationTo(steamIds, NotificationChannel.ClanAnnouncement, "[" + clan.Name + "] Announcement was updated", ConVar.Server.hostname, dictionary);
			}
			Pool.FreeUnmanaged<ulong>(ref steamIds);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}
}


public class ClientIOLineParent : FacepunchBehaviour
{
	public AnimatedBuildingBlock parentEntity;

	public string boneName;

	public bool ignoreForPlugConnections;
}


using UnityEngine;

public class ClientIOLineParentClampedBounds : ClientIOLineParent
{
	public Bounds ClampedLocalBounds;

	public Transform BoundsRelativeTo;

	private OBB clampedObb;
}


using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;

public class Climate : SingletonComponent<Climate>
{
	[Serializable]
	public class ClimateParameters
	{
		public AnimationCurve Temperature;

		[Horizontal(4, -1)]
		public Float4 AerialDensity;

		[Horizontal(4, -1)]
		public Float4 FogDensity;

		[Horizontal(4, -1)]
		public Color4 FogColorGrad;

		[Horizontal(4, -1)]
		public Float4 FogAmbientIntensity = Float4.One();

		[Range(0f, 1f)]
		[Horizontal(4, -1)]
		public Float4 FogAmbientSaturation = Float4.One();

		[Horizontal(4, -1)]
		public Float4 FogLightBoost = Float4.One();

		public float BiomeWeightExponent = 1f;

		public float FogHeightFalloff = 0.02f;
	}

	[Serializable]
	public class WeatherParameters
	{
		[Range(0f, 1f)]
		public float ClearChance = 1f;

		[Range(0f, 1f)]
		public float DustChance;

		[Range(0f, 1f)]
		public float FogChance;

		[Range(0f, 1f)]
		public float OvercastChance;

		[Range(0f, 1f)]
		public float StormChance;

		[Range(0f, 1f)]
		public float RainChance;
	}

	public class Value4<T>
	{
		public T Dawn;

		public T Noon;

		public T Dusk;

		public T Night;

		public float FindBlendParameters(TOD_Sky sky, out T src, out T dst)
		{
			float num = Mathf.Abs(sky.SunriseTime - sky.Cycle.Hour);
			float num2 = Mathf.Abs(sky.SunsetTime - sky.Cycle.Hour);
			float num3 = (180f - sky.SunZenith) / 180f;
			float num4 = 1f / 9f;
			if (num < num2)
			{
				if (num3 < 0.5f)
				{
					src = Night;
					dst = Dawn;
					return Mathf.InverseLerp(0.5f - num4, 0.5f, num3);
				}
				src = Dawn;
				dst = Noon;
				return Mathf.InverseLerp(0.5f, 0.5f + num4, num3);
			}
			if (num3 > 0.5f)
			{
				src = Noon;
				dst = Dusk;
				return Mathf.InverseLerp(0.5f + num4, 0.5f, num3);
			}
			src = Dusk;
			dst = Night;
			return Mathf.InverseLerp(0.5f, 0.5f - num4, num3);
		}
	}

	[Serializable]
	public class Float4 : Value4<float>
	{
		public static Float4 One()
		{
			return new Float4
			{
				Dawn = 1f,
				Dusk = 1f,
				Noon = 1f,
				Night = 1f
			};
		}
	}

	[Serializable]
	public class Color4 : Value4<Color>
	{
	}

	[Serializable]
	public class Texture2D4 : Value4<Texture2D>
	{
	}

	private const float fadeAngle = 20f;

	private const float defaultTemp = 15f;

	private const int weatherDurationHours = 18;

	private const int weatherFadeHours = 6;

	public float BiomeFogShoreDistanceFalloff = -25f;

	[Range(0f, 1f)]
	public float BlendingSpeed = 1f;

	public float FogDarknessDistance = 200f;

	public bool DebugLUTBlending;

	public WeatherParameters Weather;

	public WeatherPreset[] WeatherPresets;

	public ClimateParameters Arid;

	public ClimateParameters Temperate;

	public ClimateParameters Tundra;

	public ClimateParameters Arctic;

	public ClimateParameters Jungle;

	public float UndergroundFogDensity;

	public Color UndergroundFogColor = Color.black;

	public VolumeCloudsConfig[] DefaultCloudConfigs;

	public VolumeCloudsCirrusConfig[] DefaultCirrusConfigs;

	public VolumeCloudsConfig[] AllCloudConfigs;

	public Dictionary<WeatherPresetType, WeatherPreset[]> presetLookup;

	private ClimateParameters[] climateLookup;

	public float WeatherStateBlend { get; set; }

	public uint WeatherSeedPrevious { get; set; }

	public uint WeatherSeedTarget { get; set; }

	public uint WeatherSeedNext { get; set; }

	public WeatherPreset WeatherStatePrevious { get; set; }

	public WeatherPreset WeatherStateTarget { get; set; }

	public WeatherPreset WeatherStateNext { get; set; }

	public WeatherPreset WeatherState { get; set; }

	public WeatherPreset WeatherClampsMin { get; private set; }

	public WeatherPreset WeatherClampsMax { get; private set; }

	public WeatherPreset WeatherOverrides { get; set; }

	public LegacyWeatherState Overrides { get; set; }

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
		WeatherState = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherClampsMin = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherClampsMax = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherOverrides = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherState.Reset();
		WeatherClampsMin.Reset();
		WeatherClampsMax.Reset();
		WeatherOverrides.Reset();
		Overrides = new LegacyWeatherState(WeatherOverrides);
	}

	protected override void OnDestroy()
	{
		if (!Application.isQuitting)
		{
			((SingletonComponent)this).OnDestroy();
			if ((Object)(object)WeatherState != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherState);
			}
			if ((Object)(object)WeatherClampsMin != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherClampsMin);
			}
			if ((Object)(object)WeatherClampsMax != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherClampsMax);
			}
			if ((Object)(object)WeatherOverrides != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherOverrides);
			}
		}
	}

	private void GetPresetVCloudConfigs(WeatherPreset preset, uint seed, out VolumeCloudsConfig cfg, out VolumeCloudsCirrusConfig cfgCirrus, out VolumeCloudsRadialWeatherLayerConfig cfgStorm)
	{
		if (preset.VolumeCloudsConfigs != null && preset.VolumeCloudsConfigs.Length != 0)
		{
			cfg = preset.VolumeCloudsConfigs[SeedRandom.Range(seed, 0, preset.VolumeCloudsConfigs.Length)];
		}
		else if (DefaultCloudConfigs.Length == 0)
		{
			Debug.LogError((object)"Current weather profile has no cloud config, and default cloud config list is empty!  This shouldn't be so");
			cfg = null;
		}
		else
		{
			cfg = DefaultCloudConfigs[SeedRandom.Range(seed, 0, DefaultCloudConfigs.Length)];
		}
		if (preset.VolumeCloudsCirrusConfigs != null && preset.VolumeCloudsCirrusConfigs.Length != 0)
		{
			cfgCirrus = preset.VolumeCloudsCirrusConfigs[SeedRandom.Range(seed, 0, preset.VolumeCloudsCirrusConfigs.Length)];
		}
		else if (DefaultCirrusConfigs.Length == 0)
		{
			Debug.LogError((object)"Current weather profile has no cirrus cloud config, and default cirrus cloud config list is empty!  This shouldn't be so");
			cfgCirrus = null;
		}
		else
		{
			cfgCirrus = DefaultCirrusConfigs[SeedRandom.Range(seed, 0, DefaultCirrusConfigs.Length)];
		}
		if (preset.VolumeCloudsStormLayers != null && preset.VolumeCloudsStormLayers.Length != 0)
		{
			cfgStorm = preset.VolumeCloudsStormLayers[SeedRandom.Range(seed, 0, preset.VolumeCloudsStormLayers.Length)];
		}
		else
		{
			cfgStorm = null;
		}
	}

	public void Update()
	{
		if (!Application.isReceiving && !Application.isLoading && Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			TOD_Sky instance = TOD_Sky.Instance;
			long num = World.Seed + instance.Cycle.Ticks;
			long num2 = 648000000000L;
			long num3 = 216000000000L;
			long num4 = num / num2;
			WeatherStateBlend = Mathf.InverseLerp(0f, (float)num3, (float)(num % num2));
			uint seed = (WeatherSeedPrevious = GetSeedFromLong(num4));
			WeatherStatePrevious = GetWeatherPreset(seed);
			seed = (WeatherSeedTarget = GetSeedFromLong(num4 + 1));
			WeatherStateTarget = GetWeatherPreset(seed);
			seed = (WeatherSeedNext = GetSeedFromLong(num4 + 2));
			WeatherStateNext = GetWeatherPreset(seed);
			WeatherState.Fade(WeatherStatePrevious, WeatherStateTarget, WeatherStateBlend);
			WeatherState.Override(WeatherOverrides);
		}
	}

	private static bool Initialized()
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStatePrevious))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStateTarget))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStateNext))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherState))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherClampsMin))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherOverrides))
		{
			return false;
		}
		return true;
	}

	public static float GetClouds(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Clouds.Coverage;
	}

	public static float GetFog(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Atmosphere.Fogginess;
	}

	public static float GetWind(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Wind;
	}

	public static float GetThunder(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		float thunder = SingletonComponent<Climate>.Instance.WeatherOverrides.Thunder;
		if (thunder >= 0f)
		{
			return thunder;
		}
		float thunder2 = SingletonComponent<Climate>.Instance.WeatherState.Thunder;
		float thunder3 = SingletonComponent<Climate>.Instance.WeatherStatePrevious.Thunder;
		float thunder4 = SingletonComponent<Climate>.Instance.WeatherStateTarget.Thunder;
		if (thunder3 > 0f && thunder2 > 0.5f * thunder3)
		{
			return thunder2;
		}
		if (thunder4 > 0f && thunder2 > 0.5f * thunder4)
		{
			return thunder2;
		}
		return 0f;
	}

	public static float GetRainbow(Vector3 position)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance) || !instance.IsDay || instance.LerpValue < 1f)
		{
			return 0f;
		}
		if (GetFog(position) > 0.25f)
		{
			return 0f;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 3) : 0f);
		if (num <= 0f)
		{
			return 0f;
		}
		float rainbow = SingletonComponent<Climate>.Instance.WeatherOverrides.Rainbow;
		if (rainbow >= 0f)
		{
			return rainbow * num;
		}
		if (SingletonComponent<Climate>.Instance.WeatherState.Rainbow <= 0f)
		{
			return 0f;
		}
		if (SingletonComponent<Climate>.Instance.WeatherStateTarget.Rainbow > 0f)
		{
			return 0f;
		}
		float rainbow2 = SingletonComponent<Climate>.Instance.WeatherStatePrevious.Rainbow;
		float num2 = SeedRandom.Value(SingletonComponent<Climate>.Instance.WeatherSeedPrevious);
		if (rainbow2 < num2)
		{
			return 0f;
		}
		return num;
	}

	public static float GetAurora(Vector3 position)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance) || !instance.IsNight || instance.LerpValue > 0f)
		{
			return 0f;
		}
		if (GetClouds(position) > 0.1f)
		{
			return 0f;
		}
		if (GetFog(position) > 0.1f)
		{
			return 0f;
		}
		if (!Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap))
		{
			return 0f;
		}
		return TerrainMeta.BiomeMap.GetBiome(position, 8);
	}

	public static float GetRain(Vector3 position)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 1) : 0f);
		float num2 = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 8) : 0f);
		return SingletonComponent<Climate>.Instance.WeatherState.Rain * Mathf.Lerp(1f, 0.5f, num) * (1f - num2);
	}

	public static float GetSnow(Vector3 position)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 8) : 0f);
		return SingletonComponent<Climate>.Instance.WeatherState.Rain * num;
	}

	public static float GetTemperature(Vector3 position)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 15f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance))
		{
			return 15f;
		}
		ClimateParameters src;
		ClimateParameters dst;
		float num = SingletonComponent<Climate>.Instance.FindBlendParameters(position, out src, out dst);
		if (src == null || dst == null)
		{
			return 15f;
		}
		float hour = instance.Cycle.Hour;
		float num2 = src.Temperature.Evaluate(hour);
		float num3 = dst.Temperature.Evaluate(hour);
		return Mathf.Lerp(num2, num3, num);
	}

	private uint GetSeedFromLong(long val)
	{
		uint result = (uint)((val % uint.MaxValue + uint.MaxValue) % uint.MaxValue);
		SeedRandom.Wanghash(ref result);
		SeedRandom.Wanghash(ref result);
		SeedRandom.Wanghash(ref result);
		return result;
	}

	private WeatherPreset GetWeatherPreset(uint seed)
	{
		float num = Weather.ClearChance + Weather.DustChance + Weather.FogChance + Weather.OvercastChance + Weather.StormChance + Weather.RainChance;
		float num2 = SeedRandom.Range(ref seed, 0f, num);
		if (num2 < Weather.RainChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Rain);
		}
		if (num2 < Weather.RainChance + Weather.StormChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Storm);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Overcast);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance + Weather.FogChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Fog);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance + Weather.FogChance + Weather.DustChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Dust);
		}
		return GetWeatherPreset(seed, WeatherPresetType.Clear);
	}

	private WeatherPreset GetWeatherPreset(uint seed, WeatherPresetType type)
	{
		if (presetLookup == null)
		{
			presetLookup = new Dictionary<WeatherPresetType, WeatherPreset[]>();
		}
		if (!presetLookup.TryGetValue(type, out var value))
		{
			presetLookup.Add(type, value = CacheWeatherPresets(type));
		}
		return value.GetRandom(ref seed);
	}

	public WeatherPreset[] CacheWeatherPresets(WeatherPresetType type)
	{
		return WeatherPresets.Where((WeatherPreset x) => x.Type == type).ToArray();
	}

	private float FindBlendParameters(Vector3 pos, out ClimateParameters src, out ClimateParameters dst)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		if (climateLookup == null)
		{
			climateLookup = new ClimateParameters[5] { Arid, Temperate, Tundra, Arctic, Jungle };
		}
		if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
		{
			src = Temperate;
			dst = Temperate;
			return 0.5f;
		}
		int biomeMaxType = TerrainMeta.BiomeMap.GetBiomeMaxType(pos);
		int biomeMaxType2 = TerrainMeta.BiomeMap.GetBiomeMaxType(pos, ~biomeMaxType);
		src = climateLookup[TerrainBiome.TypeToIndex(biomeMaxType)];
		dst = climateLookup[TerrainBiome.TypeToIndex(biomeMaxType2)];
		return TerrainMeta.BiomeMap.GetBiome(pos, biomeMaxType2);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ClimateParameters
{
	public AnimationCurve Temperature;

	[Horizontal(4, -1)]
	public Float4 AerialDensity;

	[Horizontal(4, -1)]
	public Float4 FogDensity;

	[Horizontal(4, -1)]
	public Color4 FogColorGrad;

	[Horizontal(4, -1)]
	public Float4 FogAmbientIntensity = Float4.One();

	[Range(0f, 1f)]
	[Horizontal(4, -1)]
	public Float4 FogAmbientSaturation = Float4.One();

	[Horizontal(4, -1)]
	public Float4 FogLightBoost = Float4.One();

	public float BiomeWeightExponent = 1f;

	public float FogHeightFalloff = 0.02f;
}


using System;
using UnityEngine;

[Serializable]
public class WeatherParameters
{
	[Range(0f, 1f)]
	public float ClearChance = 1f;

	[Range(0f, 1f)]
	public float DustChance;

	[Range(0f, 1f)]
	public float FogChance;

	[Range(0f, 1f)]
	public float OvercastChance;

	[Range(0f, 1f)]
	public float StormChance;

	[Range(0f, 1f)]
	public float RainChance;
}


using UnityEngine;

public class Value4<T>
{
	public T Dawn;

	public T Noon;

	public T Dusk;

	public T Night;

	public float FindBlendParameters(TOD_Sky sky, out T src, out T dst)
	{
		float num = Mathf.Abs(sky.SunriseTime - sky.Cycle.Hour);
		float num2 = Mathf.Abs(sky.SunsetTime - sky.Cycle.Hour);
		float num3 = (180f - sky.SunZenith) / 180f;
		float num4 = 1f / 9f;
		if (num < num2)
		{
			if (num3 < 0.5f)
			{
				src = Night;
				dst = Dawn;
				return Mathf.InverseLerp(0.5f - num4, 0.5f, num3);
			}
			src = Dawn;
			dst = Noon;
			return Mathf.InverseLerp(0.5f, 0.5f + num4, num3);
		}
		if (num3 > 0.5f)
		{
			src = Noon;
			dst = Dusk;
			return Mathf.InverseLerp(0.5f + num4, 0.5f, num3);
		}
		src = Dusk;
		dst = Night;
		return Mathf.InverseLerp(0.5f, 0.5f - num4, num3);
	}
}


using System;

[Serializable]
public class Float4 : Value4<float>
{
	public static Float4 One()
	{
		return new Float4
		{
			Dawn = 1f,
			Dusk = 1f,
			Noon = 1f,
			Night = 1f
		};
	}
}


using System;
using UnityEngine;

[Serializable]
public class Color4 : Value4<Color>
{
}


using System;
using UnityEngine;

[Serializable]
public class Texture2D4 : Value4<Texture2D>
{
}


using System;
using UnityEngine;

public class ColliderInfo : MonoBehaviour
{
	[Flags]
	public enum Flags
	{
		Usable = 1,
		Shootable = 2,
		Melee = 4,
		Opaque = 8,
		Airflow = 0x10,
		OnlyBlockBuildingBlock = 0x20,
		Monument = 0x40,
		Tunnels = 0x80,
		AllowBuildInsideMesh = 0x100
	}

	public const Flags FlagsNone = (Flags)0;

	public const Flags FlagsEverything = (Flags)(-1);

	public const Flags FlagsDefault = Flags.Usable | Flags.Shootable | Flags.Melee | Flags.Opaque;

	[InspectorFlags]
	public Flags flags = Flags.Usable | Flags.Shootable | Flags.Melee | Flags.Opaque;

	public bool HasFlag(Flags f)
	{
		return (flags & f) == f;
	}

	public void SetFlag(Flags f, bool b)
	{
		if (b)
		{
			flags |= f;
		}
		else
		{
			flags &= ~f;
		}
	}

	public bool Filter(HitTest info)
	{
		switch (info.type)
		{
		case HitTest.Type.MeleeAttack:
			if ((flags & Flags.Melee) == 0)
			{
				return false;
			}
			break;
		case HitTest.Type.ProjectileEffect:
		case HitTest.Type.Projectile:
			if ((flags & Flags.Shootable) == 0)
			{
				return false;
			}
			break;
		case HitTest.Type.Use:
			if ((flags & Flags.Usable) == 0)
			{
				return false;
			}
			break;
		}
		return true;
	}
}


using System;

[Flags]
public enum Flags
{
	Usable = 1,
	Shootable = 2,
	Melee = 4,
	Opaque = 8,
	Airflow = 0x10,
	OnlyBlockBuildingBlock = 0x20,
	Monument = 0x40,
	Tunnels = 0x80,
	AllowBuildInsideMesh = 0x100
}


public class ColliderInfo_Pipe : ColliderInfo
{
	public int OutputSlotIndex;

	public IOEntity ParentEntity;
}


using UnityEngine;

public class ConditionalGibbable : MonoBehaviour
{
	[ReadOnly]
	public int id;
}


using UnityEngine;

public class CreateEffect : MonoBehaviour
{
	public GameObjectRef EffectToCreate;

	public void OnEnable()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Effect.client.Run(EffectToCreate.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up, ((Component)this).transform.forward);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class CreationGibSpawner : BaseMonoBehaviour
{
	[Serializable]
	public class GibReplacement
	{
		public GameObject oldGib;

		public GameObject newGib;
	}

	[Serializable]
	public class EffectMaterialPair
	{
		public PhysicMaterial material;

		public GameObjectRef effect;
	}

	[Serializable]
	public struct ConditionalGibSource
	{
		public GameObject source;

		public Vector3 pos;

		public Quaternion rot;
	}

	private GameObject gibSource;

	public GameObject gibsInstance;

	public float startTime;

	public float duration = 1f;

	public float buildScaleAdditionalAmount = 0.5f;

	[Tooltip("Entire object will be scaled on xyz during duration by this curve")]
	public AnimationCurve scaleCurve;

	[Tooltip("Object will be pushed out along transform.forward/right/up based on build direction by this amount")]
	public AnimationCurve buildCurve;

	[Tooltip("Additional scaling to apply to object based on build direction")]
	public AnimationCurve buildScaleCurve;

	public AnimationCurve xCurve;

	public AnimationCurve yCurve;

	public AnimationCurve zCurve;

	public Vector3[] spawnPositions;

	public GameObject[] particles;

	public float[] gibProgress;

	public PhysicMaterial physMaterial;

	public List<Transform> gibs;

	public bool started;

	public GameObjectRef placeEffect;

	public GameObject smokeEffect;

	public float effectSpacing = 0.2f;

	public bool invert;

	public Vector3 buildDirection;

	[Horizontal(1, 0)]
	public GibReplacement[] GibReplacements;

	public EffectMaterialPair[] effectLookup;

	private float startDelay;

	public List<ConditionalGibSource> conditionalGibSources = new List<ConditionalGibSource>();

	private float nextEffectTime = float.NegativeInfinity;

	public GameObjectRef GetEffectForMaterial(PhysicMaterial mat)
	{
		EffectMaterialPair[] array = effectLookup;
		foreach (EffectMaterialPair effectMaterialPair in array)
		{
			if ((Object)(object)effectMaterialPair.material == (Object)(object)mat)
			{
				return effectMaterialPair.effect;
			}
		}
		return effectLookup[0].effect;
	}

	public void SetDelay(float newDelay)
	{
		startDelay = newDelay;
	}

	public void FinishSpawn()
	{
		if (startDelay == 0f)
		{
			Init();
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)Init, startDelay);
		}
	}

	public float GetProgress(float delay)
	{
		if (!started)
		{
			return 0f;
		}
		if (duration == 0f)
		{
			return 1f;
		}
		return Mathf.Clamp01((Time.time - (startTime + delay)) / duration);
	}

	public void AddConditionalGibSource(GameObject cGibSource, Vector3 pos, Quaternion rot)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"Adding conditional gib source");
		ConditionalGibSource item = default(ConditionalGibSource);
		item.source = cGibSource;
		item.pos = pos;
		item.rot = rot;
		conditionalGibSources.Add(item);
	}

	public void SetGibSource(GameObject newGibSource)
	{
		GameObject val = newGibSource;
		for (int i = 0; i < GibReplacements.Length; i++)
		{
			if ((Object)(object)GibReplacements[i].oldGib == (Object)(object)newGibSource)
			{
				val = GibReplacements[i].newGib;
				break;
			}
		}
		gibSource = val;
	}

	private int SortsGibs(Transform a, Transform b)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		MeshRenderer component = ((Component)a).GetComponent<MeshRenderer>();
		MeshRenderer component2 = ((Component)b).GetComponent<MeshRenderer>();
		Bounds bounds;
		if (!invert)
		{
			float y;
			if (!((Object)(object)component == (Object)null))
			{
				bounds = ((Renderer)component).bounds;
				y = ((Bounds)(ref bounds)).center.y;
			}
			else
			{
				y = a.localPosition.y;
			}
			float num = y;
			float y2;
			if (!((Object)(object)component2 == (Object)null))
			{
				bounds = ((Renderer)component2).bounds;
				y2 = ((Bounds)(ref bounds)).center.y;
			}
			else
			{
				y2 = b.localPosition.y;
			}
			float value = y2;
			return num.CompareTo(value);
		}
		float y3;
		if (!((Object)(object)component == (Object)null))
		{
			bounds = ((Renderer)component).bounds;
			y3 = ((Bounds)(ref bounds)).center.y;
		}
		else
		{
			y3 = a.localPosition.y;
		}
		float value2 = y3;
		float y4;
		if (!((Object)(object)component2 == (Object)null))
		{
			bounds = ((Renderer)component2).bounds;
			y4 = ((Bounds)(ref bounds)).center.y;
		}
		else
		{
			y4 = b.localPosition.y;
		}
		float num2 = y4;
		return num2.CompareTo(value2);
	}

	public void Init()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		started = true;
		startTime = Time.time;
		gibsInstance = Object.Instantiate<GameObject>(gibSource, ((Component)this).transform.position, ((Component)this).transform.rotation);
		List<Transform> list = gibsInstance.GetComponentsInChildren<Transform>().ToList();
		list.Remove(gibsInstance.transform);
		list.Sort(SortsGibs);
		gibs = list;
		spawnPositions = (Vector3[])(object)new Vector3[gibs.Count];
		gibProgress = new float[gibs.Count];
		particles = (GameObject[])(object)new GameObject[gibs.Count];
		for (int i = 0; i < gibs.Count; i++)
		{
			Transform val = gibs[i];
			spawnPositions[i] = val.localPosition;
			gibProgress[i] = 0f;
			particles[i] = null;
			val.localScale = Vector3.one * scaleCurve.Evaluate(0f);
			_ = spawnPositions[i].x;
			_ = 0f;
			Transform transform = ((Component)val).transform;
			transform.position += ((Component)this).transform.right * GetPushDir(spawnPositions[i], val) * buildCurve.Evaluate(0f) * buildDirection.x;
			Transform transform2 = ((Component)val).transform;
			transform2.position += ((Component)this).transform.up * yCurve.Evaluate(0f);
			Transform transform3 = ((Component)val).transform;
			transform3.position += ((Component)this).transform.forward * zCurve.Evaluate(0f);
		}
		((FacepunchBehaviour)this).Invoke((Action)DestroyMe, duration + 0.05f);
	}

	public float GetPushDir(Vector3 spawnPos, Transform theGib)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		if (!(spawnPos.x >= 0f))
		{
			return 1f;
		}
		return -1f;
	}

	public void DestroyMe()
	{
		Object.Destroy((Object)(object)gibsInstance);
	}

	public float GetStartDelay(Transform gib)
	{
		return 0f;
	}

	public void Update()
	{
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		if (!started)
		{
			return;
		}
		float deltaTime = Time.deltaTime;
		int num = Mathf.CeilToInt((float)gibs.Count / 10f);
		for (int i = 0; i < gibs.Count; i++)
		{
			Transform val = gibs[i];
			if ((Object)(object)val == (Object)(object)((Component)this).transform)
			{
				continue;
			}
			if (deltaTime <= 0f)
			{
				break;
			}
			float num2 = 0.33f;
			float num3 = num2 / ((float)gibs.Count * num2) * (duration - num2);
			float num4 = (float)i * num3;
			if (Time.time - startTime < num4)
			{
				continue;
			}
			MeshFilter component = ((Component)val).GetComponent<MeshFilter>();
			int seed = Random.seed;
			Random.seed = i + gibs.Count;
			bool num5 = num <= 1 || Random.Range(0, num) == 0;
			Random.seed = seed;
			if (num5 && (Object)(object)particles[i] == (Object)null && (Object)(object)component != (Object)null && (Object)(object)component.sharedMesh != (Object)null)
			{
				Bounds bounds = component.sharedMesh.bounds;
				Vector3 size = ((Bounds)(ref bounds)).size;
				if (((Vector3)(ref size)).magnitude == 0f)
				{
					continue;
				}
				GameObject val2 = Object.Instantiate<GameObject>(smokeEffect);
				val2.transform.SetParent(val);
				val2.transform.localPosition = Vector3.zero;
				val2.transform.localScale = Vector3.one;
				val2.transform.localRotation = Quaternion.identity;
				ParticleSystem component2 = val2.GetComponent<ParticleSystem>();
				MeshRenderer component3 = ((Component)component).GetComponent<MeshRenderer>();
				ShapeModule shape = component2.shape;
				((ShapeModule)(ref shape)).shapeType = (ParticleSystemShapeType)5;
				bounds = ((Renderer)component3).bounds;
				((ShapeModule)(ref shape)).boxThickness = ((Bounds)(ref bounds)).extents;
				particles[i] = val2;
			}
			float num6 = Mathf.Clamp01(gibProgress[i] / num2);
			float num7 = Mathf.Clamp01((num6 + Time.deltaTime) / num2);
			gibProgress[i] += Time.deltaTime;
			float num8 = scaleCurve.Evaluate(num7);
			((Component)val).transform.localScale = new Vector3(num8, num8, num8);
			Transform transform = ((Component)val).transform;
			transform.localScale += buildDirection * buildScaleCurve.Evaluate(num7) * buildScaleAdditionalAmount;
			((Component)val).transform.localPosition = spawnPositions[i];
			Transform transform2 = ((Component)val).transform;
			transform2.position += ((Component)this).transform.right * GetPushDir(spawnPositions[i], val) * buildCurve.Evaluate(num7) * buildDirection.x;
			Transform transform3 = ((Component)val).transform;
			transform3.position += ((Component)this).transform.up * buildCurve.Evaluate(num7) * buildDirection.y;
			Transform transform4 = ((Component)val).transform;
			transform4.position += ((Component)this).transform.forward * buildCurve.Evaluate(num7) * buildDirection.z;
			if (num7 >= 1f && num7 > num6 && Time.time > nextEffectTime)
			{
				nextEffectTime = Time.time + effectSpacing;
				if ((Object)(object)particles[i] != (Object)null)
				{
					particles[i].GetComponent<ParticleSystem>();
					particles[i].transform.SetParent((Transform)null, true);
					particles[i].BroadcastOnParentDestroying();
				}
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class GibReplacement
{
	public GameObject oldGib;

	public GameObject newGib;
}


using System;
using UnityEngine;

[Serializable]
public class EffectMaterialPair
{
	public PhysicMaterial material;

	public GameObjectRef effect;
}


using System;
using UnityEngine;

[Serializable]
public struct ConditionalGibSource
{
	public GameObject source;

	public Vector3 pos;

	public Quaternion rot;
}


public class CullingManager : SingletonComponent<CullingManager>
{
}


using System.Collections.Generic;
using UnityEngine;

public class CullingVolume : MonoBehaviour, IClientComponent
{
	[Tooltip("Override occludee root from children of this object (default) to children of any other object.")]
	public GameObject OccludeeRoot;

	[Tooltip("Invert visibility. False will show occludes. True will hide them.")]
	public bool Invert;

	[Tooltip("A portal in the culling volume chain does not toggle objects visible, it merely signals the non-portal volumes to hide their occludees.")]
	public bool Portal;

	[Tooltip("Secondary culling volumes, connected to this one, that will get signaled when this trigger is activated.")]
	public List<CullingVolume> Connections = new List<CullingVolume>();
}


using System;
using UnityEngine;

public class Deployable : PrefabAttribute
{
	public Mesh guideMesh;

	public Vector3 guideMeshScale = Vector3.one;

	public bool overrideRotation;

	public Vector3 guideMeshOrientation = Vector3.zero;

	public Vector3 guideMeshPositionOffset = Vector3.zero;

	public bool guideLights = true;

	public bool wantsInstanceData;

	public bool copyInventoryFromItem;

	public bool setSocketParent;

	public bool toSlot;

	public BaseEntity.Slot slot;

	public GameObjectRef placeEffect;

	[Tooltip("Only required if the guideMesh is in a significantly different position or there are multiple meshes")]
	public Transform[] guideTargets;

	[NonSerialized]
	public Bounds bounds;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
	}

	protected override Type GetIndexedType()
	{
		return typeof(Deployable);
	}

	public bool IsGuideTarget(Transform t)
	{
		if (guideTargets != null)
		{
			Transform[] array = guideTargets;
			for (int i = 0; i < array.Length; i++)
			{
				if ((Object)(object)array[i] == (Object)(object)t)
				{
					return true;
				}
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployableShowVolume : PrefabAttribute, IClientComponent
{
	public enum VolumeType
	{
		PrefabHemisphere,
		PrefabSphere,
		Sphere,
		Hemisphere,
		Cone
	}

	[Serializable]
	public class Volume
	{
		public VolumeType type;

		[Tooltip("Adding a sphere collider here will automatically fill out the fields below in the PreProcess step.")]
		public SphereCollider associatedCollider;

		public Vector3 localPosition;

		public Vector3 rotation;

		public float size;
	}

	public List<Volume> volumes = new List<Volume>();

	protected override Type GetIndexedType()
	{
		return typeof(DeployableShowVolume);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (volumes == null || volumes.Count == 0)
		{
			return;
		}
		foreach (Volume volume in volumes)
		{
			if (volume != null && !((Object)(object)volume.associatedCollider == (Object)null))
			{
				volume.size = volume.associatedCollider.radius * 2f;
				Transform transform = ((Component)volume.associatedCollider).transform;
				volume.localPosition = transform.localPosition;
				volume.rotation = transform.localEulerAngles;
			}
		}
	}
}


public enum VolumeType
{
	PrefabHemisphere,
	PrefabSphere,
	Sphere,
	Hemisphere,
	Cone
}


using System;
using UnityEngine;

[Serializable]
public class Volume
{
	public VolumeType type;

	[Tooltip("Adding a sphere collider here will automatically fill out the fields below in the PreProcess step.")]
	public SphereCollider associatedCollider;

	public Vector3 localPosition;

	public Vector3 rotation;

	public float size;
}


using System;
using UnityEngine;

public class DeployShell : PrefabAttribute
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public OBB WorldSpaceBounds(Transform transform)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(transform.position, transform.lossyScale, transform.rotation, bounds);
	}

	public float LineOfSightPadding()
	{
		return 0.025f;
	}

	protected override Type GetIndexedType()
	{
		return typeof(DeployShell);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.Serialization;

public abstract class DeployVolume : PrefabAttribute
{
	public enum EntityMode
	{
		ExcludeList,
		IncludeList
	}

	public enum TypeFilterMode
	{
		Include,
		Ignore
	}

	public LayerMask layers = LayerMask.op_Implicit(537001984);

	[InspectorFlags]
	public ColliderInfo.Flags ignore;

	public EntityMode entityMode;

	[FormerlySerializedAs("entities")]
	public BaseEntity[] entityList;

	[SerializeField]
	public EntityListScriptableObject[] entityGroups;

	[SerializeField]
	public bool includeAllDoors;

	public bool IsBuildingBlock { get; set; }

	public static Collider LastDeployHit { get; set; }

	protected override Type GetIndexedType()
	{
		return typeof(DeployVolume);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		IsBuildingBlock = (Object)(object)rootObj.GetComponent<BuildingBlock>() != (Object)null;
	}

	protected abstract bool Check(Vector3 position, Quaternion rotation, int mask = -1);

	protected abstract bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1);

	protected abstract bool Check(Vector3 position, Quaternion rotation, OBB test, int mask = -1);

	public static bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, int mask = -1)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < volumes.Length; i++)
		{
			if (volumes[i].Check(position, rotation, mask))
			{
				return true;
			}
		}
		return false;
	}

	public static bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < volumes.Length; i++)
		{
			if (volumes[i].Check(position, rotation, types, filterMode, ignoredEntity, mask))
			{
				return true;
			}
		}
		return false;
	}

	public static bool Check(Vector3 position, Quaternion rotation, List<DeployVolume> volumes, OBB test, int mask = -1)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < volumes.Count; i++)
		{
			if (volumes[i].Check(position, rotation, test, mask))
			{
				return true;
			}
		}
		return false;
	}

	public static bool CheckSphere(Vector3 pos, float radius, int layerMask, DeployVolume volume)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(pos, radius, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, DeployVolume volume)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return CheckCapsule(start, end, radius, layerMask, volume, null, TypeFilterMode.Include);
	}

	public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, DeployVolume volume, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapCapsule(start, end, radius, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume, types, filterMode, ignoredEntity);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckOBB(OBB obb, int layerMask, DeployVolume volume)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return CheckOBB(obb, layerMask, volume, null, TypeFilterMode.Include);
	}

	public static bool CheckOBB(OBB obb, int layerMask, DeployVolume volume, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(obb, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume, types, filterMode, ignoredEntity);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckBounds(Bounds bounds, int layerMask, DeployVolume volume)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapBounds(bounds, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private static bool CheckFlags(List<Collider> list, DeployVolume volume, List<Type> types = null, TypeFilterMode filterMode = TypeFilterMode.Include, BaseEntity ignoredEntity = null)
	{
		if (volume == null)
		{
			return true;
		}
		LastDeployHit = null;
		for (int i = 0; i < list.Count; i++)
		{
			LastDeployHit = list[i];
			BaseEntity baseEntity = LastDeployHit.ToBaseEntity();
			if ((Object)(object)ignoredEntity != (Object)null && (Object)(object)baseEntity != (Object)null && (Object)(object)baseEntity == (Object)(object)ignoredEntity)
			{
				continue;
			}
			if (volume.includeAllDoors && (Object)(object)list[i] != (Object)null)
			{
				BaseEntity baseEntity2 = list[i].ToBaseEntity();
				if ((Object)(object)baseEntity2 != (Object)null && baseEntity2 is Door)
				{
					return true;
				}
			}
			if ((Object)(object)baseEntity != (Object)null && types != null)
			{
				Type type = ((object)baseEntity).GetType();
				bool flag = types.Contains(type);
				if ((filterMode == TypeFilterMode.Include && !flag) || (filterMode == TypeFilterMode.Ignore && flag))
				{
					continue;
				}
			}
			GameObject gameObject = ((Component)list[i]).gameObject;
			if (gameObject.CompareTag("DeployVolumeIgnore"))
			{
				continue;
			}
			ColliderInfo component = gameObject.GetComponent<ColliderInfo>();
			if ((Object)(object)component != (Object)null && component.HasFlag(ColliderInfo.Flags.OnlyBlockBuildingBlock) && !volume.IsBuildingBlock)
			{
				continue;
			}
			if (gameObject.HasCustomTag(GameObjectTag.BlockPlacement))
			{
				return true;
			}
			MonumentInfo monument = list[i].GetMonument();
			if ((!((Object)(object)monument != (Object)null) || monument.IsSafeZone || !volume.ignore.HasFlag(ColliderInfo.Flags.Monument)) && (!((Object)(object)component != (Object)null) || (volume.ignore & component.flags) == 0))
			{
				if ((Object)(object)component != (Object)null && volume.ignore != 0 && component.HasFlag(volume.ignore))
				{
					return false;
				}
				if (ShouldApplyVolumeForEntity(volume, baseEntity))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool ShouldApplyVolumeForEntity(DeployVolume volume, BaseEntity entity)
	{
		if (volume.entityList == null || volume.entityGroups == null || (volume.entityList.Length == 0 && volume.entityGroups.Length == 0))
		{
			return true;
		}
		if (volume.entityGroups.Length != 0)
		{
			EntityListScriptableObject[] array = volume.entityGroups;
			foreach (EntityListScriptableObject entityListScriptableObject in array)
			{
				if (entityListScriptableObject.entities.IsNullOrEmpty())
				{
					Debug.LogWarning((object)("Skipping entity group '" + ((Object)entityListScriptableObject).name + "' when checking volume: there are no entities"));
				}
				else if (CheckEntityList(entity, entityListScriptableObject.entities, trueIfAnyFound: true))
				{
					return true;
				}
			}
		}
		if (volume.entityList.Length != 0 && CheckEntityList(entity, volume.entityList, volume.entityMode == EntityMode.IncludeList))
		{
			return true;
		}
		return false;
	}

	public static bool CheckEntityList(BaseEntity entity, BaseEntity[] entities, bool trueIfAnyFound)
	{
		if (entities == null || entities.Length == 0)
		{
			return true;
		}
		bool flag = false;
		if ((Object)(object)entity != (Object)null)
		{
			foreach (BaseEntity baseEntity in entities)
			{
				if (entity.prefabID == baseEntity.prefabID)
				{
					flag = true;
					break;
				}
				if (entity is ModularCar && baseEntity is ModularCar)
				{
					flag = true;
					break;
				}
			}
		}
		if (trueIfAnyFound)
		{
			return flag;
		}
		return !flag;
	}
}


public enum EntityMode
{
	ExcludeList,
	IncludeList
}


public enum TypeFilterMode
{
	Include,
	Ignore
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeCapsule : DeployVolume
{
	public Vector3 center = Vector3.zero;

	public float radius = 0.5f;

	public float height = 1f;

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		Vector3 start = position + rotation * worldRotation * Vector3.up * height * 0.5f;
		Vector3 end = position + rotation * worldRotation * Vector3.down * height * 0.5f;
		if (DeployVolume.CheckCapsule(start, end, radius, LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		Vector3 start = position + rotation * worldRotation * Vector3.up * height * 0.5f;
		Vector3 end = position + rotation * worldRotation * Vector3.down * height * 0.5f;
		if (DeployVolume.CheckCapsule(start, end, radius, LayerMask.op_Implicit(layers) & mask, this, types, filterMode, ignoredEntity))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask = -1)
	{
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeEntityBounds : DeployVolume
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * ((Bounds)(ref bounds)).center;
		if (DeployVolume.CheckOBB(new OBB(position, ((Bounds)(ref bounds)).size, rotation), LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Check(position, rotation, mask);
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask = -1)
	{
		return false;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class DeployVolumeEntityBoundsReverse : DeployVolume
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public int layer;

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * ((Bounds)(ref bounds)).center;
		OBB test = default(OBB);
		((OBB)(ref test))..ctor(position, ((Bounds)(ref bounds)).size, rotation);
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, ((Vector3)(ref test.extents)).magnitude, list, LayerMask.op_Implicit(layers) & mask, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			DeployVolume[] array = PrefabAttribute.server.FindAll<DeployVolume>(item.prefabID);
			List<DeployVolume> list2 = Pool.Get<List<DeployVolume>>();
			DeployVolume[] array2 = array;
			foreach (DeployVolume deployVolume in array2)
			{
				if (DeployVolume.ShouldApplyVolumeForEntity(deployVolume, item))
				{
					list2.Add(deployVolume);
				}
			}
			if (DeployVolume.Check(((Component)item).transform.position, ((Component)item).transform.rotation, list2, test, 1 << layer))
			{
				Pool.FreeUnmanaged<DeployVolume>(ref list2);
				Pool.FreeUnmanaged<BaseEntity>(ref list);
				return true;
			}
			Pool.FreeUnmanaged<DeployVolume>(ref list2);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Check(position, rotation, mask);
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB test, int mask = -1)
	{
		return false;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
		layer = rootObj.layer;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeOBB : DeployVolume
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public DeployVolumeOBB(Bounds bounds, LayerMask layers)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		this.bounds = bounds;
		base.layers = layers;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * ((Bounds)(ref bounds)).center + worldPosition);
		if (DeployVolume.CheckOBB(new OBB(position, ((Bounds)(ref bounds)).size, rotation * worldRotation), LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * ((Bounds)(ref bounds)).center + worldPosition);
		if (DeployVolume.CheckOBB(new OBB(position, ((Bounds)(ref bounds)).size, rotation * worldRotation), LayerMask.op_Implicit(layers) & mask, this, types, filterMode, ignoredEntity))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB test, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * ((Bounds)(ref bounds)).center + worldPosition);
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(position, ((Bounds)(ref bounds)).size, rotation * worldRotation);
		if ((LayerMask.op_Implicit(layers) & mask) != 0 && ((OBB)(ref val)).Intersects(test))
		{
			return true;
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeSphere : DeployVolume
{
	public Vector3 center = Vector3.zero;

	public float radius = 0.5f;

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		if (DeployVolume.CheckSphere(position, radius, LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Check(position, rotation, mask);
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		if ((LayerMask.op_Implicit(layers) & mask) != 0 && Vector3.Distance(position, ((OBB)(ref obb)).ClosestPoint(position)) <= radius)
		{
			return true;
		}
		return false;
	}
}


using UnityEngine;

[CreateAssetMenu(fileName = "NewEntityList", menuName = "Rust/EntityList")]
public class EntityListScriptableObject : ScriptableObject
{
	[SerializeField]
	public BaseEntity[] entities;

	public bool blockIfAny;

	public bool IsInList(uint prefabId)
	{
		if (entities == null)
		{
			return false;
		}
		BaseEntity[] array = entities;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].prefabID == prefabId)
			{
				return true;
			}
		}
		return false;
	}
}


using UnityEngine;

public class PreventBuildingMonumentTag : MonoBehaviour
{
	public bool autoFindMonument;

	[SerializeField]
	private MonumentInfo AttachedMonument;

	public MonumentInfo GetAttachedMonument()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (autoFindMonument && (Object)(object)AttachedMonument == (Object)null)
		{
			MonumentInfo attachedMonument = TerrainMeta.Path.FindClosest(TerrainMeta.Path.Monuments, ((Component)this).transform.position);
			AttachedMonument = attachedMonument;
		}
		return AttachedMonument;
	}

	public void SetMonument(MonumentInfo monument)
	{
		AttachedMonument = monument;
	}
}


using ConVar;
using Oxide.Core;
using UnityEngine;

public class DestroyOnGroundMissing : MonoBehaviour, IServerComponent
{
	private void OnGroundMissing()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null && Interface.CallHook("OnEntityGroundMissing", (object)baseEntity) == null)
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			if (Stability.log_ground_missing_death)
			{
				Debug.Log((object)$"Killing '{((object)baseEntity).ToString()}' at position {((Component)this).transform.position} due to ground missing");
			}
			if ((Object)(object)baseCombatEntity != (Object)null)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}
}


using UnityEngine;

public class DetachMonumentChildren : MonoBehaviour
{
	private void Awake()
	{
		((Component)this).transform.DetachChildren();
	}
}


public class EffectBlood : EffectRecycle
{
	public GameObjectRef ReplacementEffect;
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class EffectDictionary
{
	private static Dictionary<string, string[]> effectDictionary;

	public static string GetParticle(string impactType, string materialName)
	{
		return LookupEffect("impacts", impactType, materialName);
	}

	public static string GetParticle(DamageType damageType, string materialName)
	{
		return damageType switch
		{
			DamageType.Bullet => GetParticle("bullet", materialName), 
			DamageType.Arrow => GetParticle("bullet", materialName), 
			DamageType.Blunt => GetParticle("blunt", materialName), 
			DamageType.Slash => GetParticle("slash", materialName), 
			DamageType.Stab => GetParticle("stab", materialName), 
			_ => GetParticle("blunt", materialName), 
		};
	}

	public static string GetDecal(string impactType, string materialName)
	{
		return LookupEffect("decals", impactType, materialName);
	}

	public static string GetDecal(DamageType damageType, string materialName)
	{
		return damageType switch
		{
			DamageType.Bullet => GetDecal("bullet", materialName), 
			DamageType.Arrow => GetDecal("bullet", materialName), 
			DamageType.Blunt => GetDecal("blunt", materialName), 
			DamageType.Slash => GetDecal("slash", materialName), 
			DamageType.Stab => GetDecal("stab", materialName), 
			_ => GetDecal("blunt", materialName), 
		};
	}

	public static string GetDisplacement(string impactType, string materialName)
	{
		return LookupEffect("displacement", impactType, materialName);
	}

	private static string LookupEffect(string category, string effect, string material)
	{
		if (effectDictionary == null)
		{
			effectDictionary = GameManifest.LoadEffectDictionary();
		}
		string format = "assets/bundled/prefabs/fx/{0}/{1}/{2}";
		if (!effectDictionary.TryGetValue(StringFormatCache.Get(format, category, effect, material), out var value) && !effectDictionary.TryGetValue(StringFormatCache.Get(format, category, effect, "generic"), out value))
		{
			return string.Empty;
		}
		return value[Random.Range(0, value.Length)];
	}
}


using UnityEngine;
using UnityEngine.Serialization;

public class EffectRecycle : BaseMonoBehaviour, IClientComponent, IRagdollInhert, IEffectRecycle
{
	public enum PlayMode
	{
		Once,
		Looped
	}

	public enum ParentDestroyBehaviour
	{
		Detach,
		Destroy,
		DetachWaitDestroy
	}

	[ReadOnly]
	[FormerlySerializedAs("lifeTime")]
	public float detachTime;

	[ReadOnly]
	[FormerlySerializedAs("lifeTime")]
	public float recycleTime;

	public PlayMode playMode;

	public ParentDestroyBehaviour onParentDestroyed;

	[Range(1f, 50f)]
	public int WarmedUpAmount = 1;
}


public enum PlayMode
{
	Once,
	Looped
}


public enum ParentDestroyBehaviour
{
	Detach,
	Destroy,
	DetachWaitDestroy
}


public class EffectRecycleDetach : BaseMonoBehaviour, IClientComponent, IEffectRecycle
{
	public float recycleTime = 1f;
}


public class EffectRecycleLite : BasePrefab, IClientComponent, IEffectRecycle
{
	private const float lifeTime = 60f;
}


using UnityEngine;

public class EffectSilencerSelect : MonoBehaviour
{
	public GameObjectRef MilitaryEffect;

	public GameObjectRef OilFilterEffect;

	public GameObjectRef SodaCanEffect;

	public bool GetEffectForSilencerType(ProjectileWeaponMod.SilencerType silencerType, out GameObjectRef result)
	{
		result = null;
		switch (silencerType)
		{
		case ProjectileWeaponMod.SilencerType.Military:
			result = MilitaryEffect;
			break;
		case ProjectileWeaponMod.SilencerType.OilFilter:
			result = OilFilterEffect;
			break;
		case ProjectileWeaponMod.SilencerType.SodaCan:
			result = SodaCanEffect;
			break;
		}
		if (result != null)
		{
			return result.isValid;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class EnvironmentManager : SingletonComponent<EnvironmentManager>
{
	public static EnvironmentType Get(OBB obb)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		EnvironmentType environmentType = (EnvironmentType)0;
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		GamePhysics.OverlapOBB<EnvironmentVolume>(obb, list, 262144, (QueryTriggerInteraction)2);
		for (int i = 0; i < list.Count; i++)
		{
			environmentType |= list[i].Type;
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return environmentType;
	}

	public static EnvironmentType Get(Vector3 pos, ref List<EnvironmentVolume> list, float radius = 0.01f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		EnvironmentType environmentType = (EnvironmentType)0;
		GamePhysics.OverlapSphere<EnvironmentVolume>(pos, radius, list, 262144, (QueryTriggerInteraction)2);
		for (int i = 0; i < list.Count; i++)
		{
			environmentType |= list[i].Type;
		}
		return environmentType;
	}

	public static EnvironmentType Get(Vector3 pos, float radius = 0.01f)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		EnvironmentType result = Get(pos, ref list, radius);
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return result;
	}

	public static bool Check(OBB obb, EnvironmentType type)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return (Get(obb) & type) != 0;
	}

	public static bool Check(Vector3 pos, EnvironmentType type, float radius = 0.01f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return (Get(pos, radius) & type) != 0;
	}
}


using System;

[Flags]
public enum EnvironmentType
{
	Underground = 1,
	Building = 2,
	Outdoor = 4,
	Elevator = 8,
	PlayerConstruction = 0x10,
	TrainTunnels = 0x20,
	UnderwaterLab = 0x40,
	Submarine = 0x80,
	BuildingDark = 0x100,
	BuildingVeryDark = 0x200,
	NoSunlight = 0x400,
	SpatiallyAware = 0x800,
	Entrance = 0x1000
}


using System;

[Flags]
public enum NetworkGroupType
{
	Cave = 1,
	TrainTunnels = 2,
	Canyon = 4
}


using UnityEngine;

[ExecuteInEditMode]
public class EnvironmentVolume : MonoBehaviour, IPrefabPreProcess
{
	public enum VolumeShape
	{
		Cube,
		Sphere,
		Capsule
	}

	private static readonly Vector3[] volumeCorners = (Vector3[])(object)new Vector3[8]
	{
		new Vector3(-0.5f, -0.5f, -0.5f),
		new Vector3(0.5f, -0.5f, -0.5f),
		new Vector3(0.5f, 0.5f, -0.5f),
		new Vector3(-0.5f, 0.5f, -0.5f),
		new Vector3(-0.5f, -0.5f, 0.5f),
		new Vector3(0.5f, -0.5f, 0.5f),
		new Vector3(0.5f, 0.5f, 0.5f),
		new Vector3(-0.5f, 0.5f, 0.5f)
	};

	[InspectorFlags]
	public EnvironmentType Type = EnvironmentType.Underground;

	[InspectorFlags]
	public NetworkGroupType NetworkType;

	public Vector3 Center = Vector3.zero;

	public Vector3 Size = Vector3.one;

	[field: SerializeField]
	[field: Tooltip("Controls the falloff amount of the positive axes of spatially aware volumes.")]
	public Vector3 FalloffPositive { get; private set; } = Vector3.zero;

	[field: Tooltip("Controls the falloff amount of the negative axes of spatially aware volumes.")]
	[field: SerializeField]
	public Vector3 FalloffNegative { get; private set; } = Vector3.zero;

	[field: SerializeField]
	public VolumeShape SpatialVolumeShape { get; private set; }

	public Matrix4x4 VolumeTransformation { get; private set; }

	public Matrix4x4 VolumeTransformationInverse { get; private set; }

	public Vector3 VolumePosition { get; private set; }

	public Bounds VolumeBounds { get; private set; }

	public float AmbientMultiplier { get; private set; }

	public float ReflectionMultiplier { get; private set; }

	public float CombinedMultiplier { get; private set; }

	public bool NoSunlight { get; private set; }

	public bool PropertiesCached { get; private set; }

	public Collider trigger { get; private set; }

	public bool IsSpatialVolume => (Type & EnvironmentType.SpatiallyAware) != 0;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	private void OnValidate()
	{
		PropertiesCached = false;
		UpdateVolumeTransformationAndBounds();
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (clientside && IsSpatialVolume && !((Object)(object)((Component)this).gameObject == (Object)null) && (Object)(object)((Component)this).GetComponent<EnvironmentVolumeLOD>() == (Object)null)
		{
			((Component)this).gameObject.AddComponent<EnvironmentVolumeLOD>();
		}
	}

	protected void Awake()
	{
		UpdateTrigger();
	}

	protected void OnEnable()
	{
		if (Object.op_Implicit((Object)(object)trigger) && !trigger.enabled)
		{
			trigger.enabled = true;
		}
		NetworkVisibilityGrid.RegisterEnvironmentVolume(this);
		UpdateVolumeTransformationAndBounds();
	}

	protected void OnDisable()
	{
		if (Object.op_Implicit((Object)(object)trigger) && trigger.enabled)
		{
			trigger.enabled = false;
		}
	}

	private Bounds CalculateTransformationBounds(Matrix4x4 transformationMatrix)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.positiveInfinity;
		Vector3 val2 = Vector3.negativeInfinity;
		for (int i = 0; i < volumeCorners.Length; i++)
		{
			Vector3 val3 = ((Matrix4x4)(ref transformationMatrix)).MultiplyPoint3x4(volumeCorners[i]);
			val = Vector3.Min(val, val3);
			val2 = Vector3.Max(val2, val3);
		}
		if (IsSpatialVolume && SpatialVolumeShape == VolumeShape.Capsule)
		{
			float num = Mathf.Abs(val2.y - val.y) * 0.5f;
			val.y -= num;
			val2.y += num;
		}
		Bounds result = default(Bounds);
		((Bounds)(ref result))..ctor(Vector3.zero, Vector3.one);
		((Bounds)(ref result)).SetMinMax(val, val2);
		return result;
	}

	public void UpdateVolumeTransformationAndBounds()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Size + new Vector3(0.001f, 0.001f, 0.001f);
		VolumeTransformation = ((Component)this).transform.localToWorldMatrix * Matrix4x4.Translate(Center) * Matrix4x4.Scale(val);
		Matrix4x4 volumeTransformation = VolumeTransformation;
		VolumeTransformationInverse = ((Matrix4x4)(ref volumeTransformation)).inverse;
		volumeTransformation = VolumeTransformation;
		VolumePosition = ((Matrix4x4)(ref volumeTransformation)).GetPosition();
		VolumeBounds = CalculateTransformationBounds(VolumeTransformation);
	}

	public void CacheVolumeProperties(EnvironmentVolumePropertiesCollection properties)
	{
		if (!PropertiesCached)
		{
			PropertiesCached = true;
			NoSunlight = (Type & EnvironmentType.NoSunlight) != 0 || (Type & EnvironmentType.TrainTunnels) != 0;
			CombinedMultiplier = AmbientMultiplier * ReflectionMultiplier;
		}
	}

	public void UpdateTrigger()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)trigger))
		{
			trigger = ((Component)this).gameObject.GetComponent<Collider>();
		}
		if (!Object.op_Implicit((Object)(object)trigger))
		{
			trigger = (Collider)(object)((Component)this).gameObject.AddComponent<BoxCollider>();
		}
		trigger.isTrigger = true;
		Collider obj = trigger;
		BoxCollider val = (BoxCollider)(object)((obj is BoxCollider) ? obj : null);
		if (Object.op_Implicit((Object)(object)val))
		{
			val.center = Center;
			val.size = Size;
		}
	}
}


public enum VolumeShape
{
	Cube,
	Sphere,
	Capsule
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class EnvironmentVolumeEx
{
	public static bool CheckEnvironmentVolumes(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		OBB obb = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			((OBB)(ref obb))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
			((OBB)(ref obb)).Transform(pos, scale, rot);
			if (EnvironmentManager.Check(obb, type))
			{
				Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
				return true;
			}
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return false;
	}

	public static bool CheckEnvironmentVolumes(this Transform transform, EnvironmentType type)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumes(transform.position, transform.rotation, transform.lossyScale, type);
	}

	public static bool CheckEnvironmentVolumesInsideTerrain(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float padding = 0f)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.HeightMap == (Object)null)
		{
			return true;
		}
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) == 0 || (environmentVolume.Type & typeIgnore) != 0)
			{
				continue;
			}
			((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
			((OBB)(ref val)).Transform(pos, scale, rot);
			Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
			Vector3 point2 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
			Vector3 point3 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
			Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
			Bounds val2 = ((OBB)(ref val)).ToBounds();
			float max = ((Bounds)(ref val2)).max.y + padding;
			bool fail = false;
			TerrainMeta.HeightMap.ForEachParallel(point, point2, point3, point4, delegate(int x, int z)
			{
				if (TerrainMeta.HeightMap.GetHeight(x, z) <= max)
				{
					fail = true;
				}
			});
			if (fail)
			{
				Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesInsideTerrain(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesInsideTerrain(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}

	public static bool CheckEnvironmentVolumesOutsideTerrain(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float padding = 0f)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.HeightMap == (Object)null)
		{
			return true;
		}
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) == 0 || (environmentVolume.Type & typeIgnore) != 0)
			{
				continue;
			}
			((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
			((OBB)(ref val)).Transform(pos, scale, rot);
			Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
			Vector3 point2 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
			Vector3 point3 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
			Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
			Bounds val2 = ((OBB)(ref val)).ToBounds();
			float min = ((Bounds)(ref val2)).min.y - padding;
			bool fail = false;
			TerrainMeta.HeightMap.ForEachParallel(point, point2, point3, point4, delegate(int x, int z)
			{
				if (TerrainMeta.HeightMap.GetHeight(x, z) >= min)
				{
					fail = true;
				}
			});
			if (fail)
			{
				Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesOutsideTerrain(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesOutsideTerrain(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}

	public static bool CheckEnvironmentVolumesAboveAltitude(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float altitude = 0f)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.GetList<EnvironmentVolume>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeList<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) != 0 && (environmentVolume.Type & typeIgnore) == 0)
			{
				((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
				((OBB)(ref val)).Transform(pos, scale, rot);
				Bounds val2 = ((OBB)(ref val)).ToBounds();
				if (((Bounds)(ref val2)).min.y <= altitude)
				{
					Pool.FreeList<EnvironmentVolume>(ref list);
					return false;
				}
			}
		}
		Pool.FreeList<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesAboveAltitude(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesAboveAltitude(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}

	public static bool CheckEnvironmentVolumesBelowAltitude(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float altitude = 0f)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.GetList<EnvironmentVolume>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeList<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) != 0 && (environmentVolume.Type & typeIgnore) == 0)
			{
				((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
				((OBB)(ref val)).Transform(pos, scale, rot);
				Bounds val2 = ((OBB)(ref val)).ToBounds();
				if (((Bounds)(ref val2)).max.y >= altitude)
				{
					Pool.FreeList<EnvironmentVolume>(ref list);
					return false;
				}
			}
		}
		Pool.FreeList<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesBelowAltitude(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesBelowAltitude(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}
}


using UnityEngine;

public class EnvironmentVolumeTrigger : MonoBehaviour
{
	[HideInInspector]
	public Vector3 Center = Vector3.zero;

	[HideInInspector]
	public Vector3 Size = Vector3.one;

	public EnvironmentVolume volume { get; private set; }

	public void Awake()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		volume = ((Component)this).gameObject.GetComponent<EnvironmentVolume>();
		if ((Object)(object)volume == (Object)null)
		{
			volume = ((Component)this).gameObject.AddComponent<EnvironmentVolume>();
			volume.Center = Center;
			volume.Size = Size;
		}
		volume.UpdateTrigger();
		OnVolumeTriggerUpdate();
	}

	protected virtual void OnVolumeTriggerUpdate()
	{
	}
}


using UnityEngine;

[ExecuteAlways]
public class FakePhysicsRope : FacepunchBehaviour, IClientComponent
{
	public enum RenderMode
	{
		LineRenderer2D,
		TubeRenderer3D,
		Both
	}

	[Header("References")]
	public Transform startPoint;

	public Transform endPoint;

	public Transform leadPoint;

	public Vector3 endPointOffset;

	[Header("Settings")]
	[Range(2f, 100f)]
	public int linePoints = 10;

	[Tooltip("Value highly dependent on use case, a metal cable would have high stiffness, a rubber rope would have a low one")]
	public float stiffness = 350f;

	[Tooltip("0 is no damping, 50 is a lot")]
	public float damping = 15f;

	[Tooltip("How long is the rope. It will hang more or less from starting point to end point depending on this value")]
	public float ropeLength = 15f;

	[Tooltip("The Rope width set at start (changing this value during run time will produce no effect)")]
	public float ropeWidth = 0.1f;

	[Tooltip("Adjust the middle control point weight for the Rational Bezier curve")]
	[Range(1f, 15f)]
	public float midPointWeight = 1f;

	[Tooltip("Use local positions instead of world positions (relative to this object)")]
	public bool useLocalPositions;

	[Header("Rendering")]
	public RenderMode renderMode;

	[Header("Wind")]
	public bool AddFakeWind;

	public float windFrequency;

	public float windAmplitude;

	protected Vector3 EndPointPosition => endPoint.position + endPointOffset;

	public static Vector3 GetRationalBezierPoint(Vector3 p0, Vector3 p1, Vector3 p2, float t, float w0 = 1f, float w1 = 1f, float w2 = 1f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = w0 * p0;
		Vector3 val2 = w1 * p1;
		Vector3 val3 = w2 * p2;
		float num = w0 * Mathf.Pow(1f - t, 2f) + 2f * w1 * (1f - t) * t + w2 * Mathf.Pow(t, 2f);
		return (val * Mathf.Pow(1f - t, 2f) + val2 * 2f * (1f - t) * t + val3 * Mathf.Pow(t, 2f)) / num;
	}
}


public enum RenderMode
{
	LineRenderer2D,
	TubeRenderer3D,
	Both
}


using UnityEngine;
using UnityEngine.Rendering;

[ExecuteAlways]
public class FoliageGrid : SingletonComponent<FoliageGrid>, IClientComponent
{
	private const int GRID_POOL_SIZE = 48;

	private const float FOLIAGE_CULL_RADIUS = 2f;

	private const int COMPUTE_CELL_DIM = 4;

	private const int COMPUTE_TILE_DIM = 5;

	private const int COMPUTE_TILE_HALF = 2;

	private const int COMPUTE_CELL_COUNT = 16;

	private const int GRID_OFFSET = 65536;

	public static bool Paused;

	public static bool RefreshDisabled;

	public GameObjectRef BatchPrefab;

	public float CellSize = 50f;

	[SerializeField]
	private ComputeShader foliageCompute;

	public LayerSelect FoliageLayer = 0;

	public ShadowCastingMode FoliageShadows;

	public void OnGlobalTextureMipmapLimitChange()
	{
	}
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Foliage Placement")]
public class FoliagePlacement : ScriptableObject
{
	public struct PlacementMeshInfo
	{
		public int placementIdx;

		public int matIdx;

		public int masterIdx;

		public int subMeshIdx;

		public int subFoliageIdx;

		public PlacementMeshInfo(int placementIdx, int matIdx, int masterIdx, int subMeshIdx, int subFoliageIdx)
		{
			this.placementIdx = placementIdx;
			this.matIdx = matIdx;
			this.masterIdx = masterIdx;
			this.subMeshIdx = subMeshIdx;
			this.subFoliageIdx = subFoliageIdx;
		}
	}

	[Header("Placement")]
	public float Density = 2f;

	[Header("Filter")]
	public SpawnFilter Filter;

	[FormerlySerializedAs("Cutoff")]
	public float FilterCutoff = 0.5f;

	public float FilterFade = 0.1f;

	[FormerlySerializedAs("Scaling")]
	public float FilterScaling = 1f;

	[Header("Randomization")]
	public float RandomScaling = 0.2f;

	[MinMax(0f, 1f)]
	[Header("Placement Range")]
	public MinMax Range = new MinMax(0f, 1f);

	public float RangeFade = 0.1f;

	[Range(0f, 1f)]
	[Header("LOD")]
	public float DistanceDensity;

	[Range(1f, 2f)]
	public float DistanceScaling = 2f;

	[Header("Visuals")]
	public Material material;

	[FormerlySerializedAs("mesh")]
	public Mesh mesh0;

	[FormerlySerializedAs("mesh")]
	public Mesh mesh1;

	[FormerlySerializedAs("mesh")]
	public Mesh mesh2;

	public const int lods = 5;

	public const int octaves = 1;

	public const float frequency = 0.05f;

	public const float amplitude = 0.5f;

	public const float offset = 0.5f;

	[NonSerialized]
	public uint baseSeed;

	[NonSerialized]
	public int count;

	[NonSerialized]
	public int mergeID;

	[NonSerialized]
	public int vertexOffset;

	public PlacementMeshInfo info;
}


public struct PlacementMeshInfo
{
	public int placementIdx;

	public int matIdx;

	public int masterIdx;

	public int subMeshIdx;

	public int subFoliageIdx;

	public PlacementMeshInfo(int placementIdx, int matIdx, int masterIdx, int subMeshIdx, int subFoliageIdx)
	{
		this.placementIdx = placementIdx;
		this.matIdx = matIdx;
		this.masterIdx = masterIdx;
		this.subMeshIdx = subMeshIdx;
		this.subFoliageIdx = subFoliageIdx;
	}
}


using UnityEngine;

public class FoliageRenderer : MonoBehaviour, IClientComponent
{
	public Material material;

	public Mesh LOD0;

	public Mesh LOD1;
}


using UnityEngine;

public class FoliageSpawn : MonoBehaviour, IClientComponent
{
	public FoliagePlacement Placement;
}


using System;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;
using UnityEngine.SceneManagement;

public class GameManager
{
	public static GameManager server = new GameManager(clientside: false, serverside: true);

	public PrefabPreProcess preProcessed;

	public PrefabPoolCollection pool;

	public bool Clientside;

	public bool Serverside;

	public void Reset()
	{
		pool.Clear();
	}

	public GameManager(bool clientside, bool serverside)
	{
		Clientside = clientside;
		Serverside = serverside;
		preProcessed = new PrefabPreProcess(clientside, serverside);
		pool = new PrefabPoolCollection(clientside);
	}

	public GameObject FindPrefab(uint prefabID)
	{
		string text = StringPool.Get(prefabID);
		if (string.IsNullOrEmpty(text))
		{
			return null;
		}
		return FindPrefab(text);
	}

	public GameObject FindPrefab(BaseEntity ent)
	{
		if ((Object)(object)ent == (Object)null)
		{
			return null;
		}
		return FindPrefab(ent.PrefabName);
	}

	public GameObject FindPrefab(string strPrefab)
	{
		GameObject val = preProcessed.Find(strPrefab);
		if ((Object)(object)val != (Object)null)
		{
			return val;
		}
		val = FileSystem.LoadPrefab(strPrefab);
		if ((Object)(object)val == (Object)null)
		{
			return null;
		}
		try
		{
			preProcessed.Process(strPrefab, val);
		}
		catch
		{
			Debug.LogError((object)("Failed to preprocess prefab: " + strPrefab));
			throw;
		}
		GameObject val2 = preProcessed.Find(strPrefab);
		if (!((Object)(object)val2 != (Object)null))
		{
			return val;
		}
		return val2;
	}

	public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, Vector3 scale, bool active = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = Instantiate(strPrefab, pos, rot);
		if (Object.op_Implicit((Object)(object)val))
		{
			val.transform.localScale = scale;
			if (active)
			{
				val.AwakeFromInstantiate();
			}
		}
		return val;
	}

	public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, bool active = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = Instantiate(strPrefab, pos, rot);
		if (Object.op_Implicit((Object)(object)val) && active)
		{
			val.AwakeFromInstantiate();
		}
		return val;
	}

	public GameObject CreatePrefab(string strPrefab, bool active = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = Instantiate(strPrefab, Vector3.zero, Quaternion.identity);
		if (Object.op_Implicit((Object)(object)val) && active)
		{
			val.AwakeFromInstantiate();
		}
		return val;
	}

	public GameObject CreatePrefab(string strPrefab, Transform parent, bool active = true)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = Instantiate(strPrefab, parent.position, parent.rotation);
		if (Object.op_Implicit((Object)(object)val))
		{
			val.transform.SetParent(parent, false);
			val.Identity();
			if (active)
			{
				val.AwakeFromInstantiate();
			}
		}
		return val;
	}

	public BaseEntity CreateEntity(string strPrefab, Vector3 pos = default(Vector3), Quaternion rot = default(Quaternion), bool startActive = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(strPrefab))
		{
			return null;
		}
		GameObject val = CreatePrefab(strPrefab, pos, rot, startActive);
		if ((Object)(object)val == (Object)null)
		{
			return null;
		}
		BaseEntity component = val.GetComponent<BaseEntity>();
		if ((Object)(object)component == (Object)null)
		{
			Debug.LogError((object)("CreateEntity called on a prefab that isn't an entity! " + strPrefab));
			Object.Destroy((Object)(object)val);
			return null;
		}
		if (((Component)component).CompareTag("CannotBeCreated"))
		{
			Debug.LogWarning((object)("CreateEntity called on a prefab that has the CannotBeCreated tag set. " + strPrefab));
			Object.Destroy((Object)(object)val);
			return null;
		}
		return component;
	}

	private GameObject Instantiate(string strPrefab, Vector3 pos, Quaternion rot)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		if (!StringEx.IsLower(strPrefab))
		{
			Debug.LogWarning((object)("Converting prefab name to lowercase: " + strPrefab));
			strPrefab = strPrefab.ToLower();
		}
		GameObject val = FindPrefab(strPrefab);
		if (!Object.op_Implicit((Object)(object)val))
		{
			Debug.LogError((object)("Couldn't find prefab \"" + strPrefab + "\""));
			return null;
		}
		GameObject val2 = pool.Pop(StringPool.Get(strPrefab), pos, rot);
		if ((Object)(object)val2 == (Object)null)
		{
			val2 = Instantiate.GameObject(val, pos, rot);
			((Object)val2).name = strPrefab;
		}
		else
		{
			val2.transform.localScale = val.transform.localScale;
		}
		if (!Clientside && Serverside && (Object)(object)val2.transform.parent == (Object)null && Application.isPlaying)
		{
			Scene entityScene = Rust.Server.EntityScene;
			if (!((Scene)(ref entityScene)).IsValid() || !((Scene)(ref entityScene)).isLoaded)
			{
				Destroy(val2);
				return null;
			}
			SceneManager.MoveGameObjectToScene(val2, entityScene);
		}
		return val2;
	}

	public static void Destroy(Component component, float delay = 0f)
	{
		if ((component as BaseEntity).IsValid())
		{
			Debug.LogError((object)("Trying to destroy an entity without killing it first: " + ((Object)component).name));
		}
		Object.Destroy((Object)(object)component, delay);
	}

	public static void Destroy(GameObject instance, float delay = 0f)
	{
		if (Object.op_Implicit((Object)(object)instance))
		{
			if (instance.GetComponent<BaseEntity>().IsValid())
			{
				Debug.LogError((object)("Trying to destroy an entity without killing it first: " + ((Object)instance).name));
			}
			Object.Destroy((Object)(object)instance, delay);
		}
	}

	public static void DestroyImmediate(Component component, bool allowDestroyingAssets = false)
	{
		if ((component as BaseEntity).IsValid())
		{
			Debug.LogError((object)("Trying to destroy an entity without killing it first: " + ((Object)component).name));
		}
		Object.DestroyImmediate((Object)(object)component, allowDestroyingAssets);
	}

	public static void DestroyImmediate(GameObject instance, bool allowDestroyingAssets = false)
	{
		if (instance.GetComponent<BaseEntity>().IsValid())
		{
			Debug.LogError((object)("Trying to destroy an entity without killing it first: " + ((Object)instance).name));
		}
		Object.DestroyImmediate((Object)(object)instance, allowDestroyingAssets);
	}

	public void Retire(GameObject instance)
	{
		if (!Object.op_Implicit((Object)(object)instance))
		{
			return;
		}
		TimeWarning val = TimeWarning.New("GameManager.Retire", 0);
		try
		{
			if (instance.GetComponent<BaseEntity>().IsValid())
			{
				Debug.LogError((object)("Trying to retire an entity without killing it first: " + ((Object)instance).name));
			}
			if (!Application.isUnloadingWorld && LevelManager.isLoaded && Pool.enabled && instance.SupportsPooling())
			{
				pool.Push(instance);
			}
			else
			{
				Object.Destroy((Object)(object)instance);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using UnityEngine;

public class CapturePointTrigger : TriggerBase
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if ((Object)(object)(baseEntity as BasePlayer) == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System;
using Facepunch;
using ProtoBuf;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class GameModeCapturePoint : BaseEntity
{
	public CapturePointTrigger captureTrigger;

	public float timeToCapture = 3f;

	public int scorePerSecond = 1;

	public string scoreName = "score";

	private float captureFraction;

	private int captureTeam = -1;

	private int capturingTeam = -1;

	public EntityRef capturingPlayer;

	public EntityRef capturedPlayer;

	public const Flags Flag_Contested = Flags.Busy;

	public RustText capturePointText;

	public RustText captureOwnerName;

	public Image captureProgressImage;

	public GameObjectRef progressBeepEffect;

	public GameObjectRef progressCompleteEffect;

	public Transform computerPoint;

	private float nextBeepTime;

	public bool IsContested()
	{
		return HasFlag(Flags.Busy);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)AssignPoints, 0f, 1f);
	}

	public void Update()
	{
		if (!base.isClient)
		{
			UpdateCaptureAmount();
		}
	}

	public void AssignPoints()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode == (Object)null || !activeGameMode.IsMatchActive())
		{
			return;
		}
		if (activeGameMode.IsTeamGame())
		{
			if (captureTeam != -1 && captureFraction == 1f)
			{
				activeGameMode.ModifyTeamScore(captureTeam, scorePerSecond);
			}
		}
		else if (capturedPlayer.IsValid(serverside: true))
		{
			activeGameMode.ModifyPlayerGameScore(((Component)capturedPlayer.Get(serverside: true)).GetComponent<BasePlayer>(), "score", scorePerSecond);
		}
	}

	public void DoCaptureEffect()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(progressCompleteEffect.resourcePath, computerPoint.position);
	}

	public void DoProgressEffect()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!(Time.time < nextBeepTime))
		{
			Effect.server.Run(progressBeepEffect.resourcePath, computerPoint.position);
			nextBeepTime = Time.time + 0.5f;
		}
	}

	public void UpdateCaptureAmount()
	{
		if (base.isClient)
		{
			return;
		}
		float num = captureFraction;
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode == (Object)null)
		{
			return;
		}
		if (captureTrigger.entityContents == null)
		{
			SetFlag(Flags.Busy, b: false, recursive: false, networkupdate: false);
		}
		else
		{
			if (!activeGameMode.IsMatchActive())
			{
				return;
			}
			if (activeGameMode.IsTeamGame())
			{
				int[] array = new int[activeGameMode.GetNumTeams()];
				foreach (BaseEntity entityContent in captureTrigger.entityContents)
				{
					if (!((Object)(object)entityContent == (Object)null) && !entityContent.isClient)
					{
						BasePlayer component = ((Component)entityContent).GetComponent<BasePlayer>();
						if (!((Object)(object)component == (Object)null) && component.IsAlive() && !component.IsNpc && component.gamemodeteam != -1)
						{
							array[component.gamemodeteam]++;
						}
					}
				}
				int num2 = 0;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] > 0)
					{
						num2++;
					}
				}
				if (num2 < 2)
				{
					int num3 = -1;
					int num4 = 0;
					for (int j = 0; j < array.Length; j++)
					{
						if (array[j] > num4)
						{
							num4 = array[j];
							num3 = j;
						}
					}
					if (captureTeam == -1 && captureFraction == 0f)
					{
						capturingTeam = num3;
					}
					if (captureFraction > 0f && num3 != captureTeam && num3 != capturingTeam)
					{
						captureFraction = Mathf.Clamp01(captureFraction - Time.deltaTime / timeToCapture);
						if (captureFraction == 0f)
						{
							captureTeam = -1;
						}
					}
					else if (captureTeam == -1 && captureFraction < 1f && capturingTeam == num3)
					{
						DoProgressEffect();
						captureFraction = Mathf.Clamp01(captureFraction + Time.deltaTime / timeToCapture);
						if (captureFraction == 1f)
						{
							DoCaptureEffect();
							captureTeam = num3;
						}
					}
				}
				SetFlag(Flags.Busy, num2 > 1);
			}
			else
			{
				if (!capturingPlayer.IsValid(serverside: true) && !capturedPlayer.IsValid(serverside: true))
				{
					captureFraction = 0f;
				}
				if (captureTrigger.entityContents.Count == 0)
				{
					capturingPlayer.Set(null);
				}
				if (captureTrigger.entityContents.Count == 1)
				{
					foreach (BaseEntity entityContent2 in captureTrigger.entityContents)
					{
						BasePlayer component2 = ((Component)entityContent2).GetComponent<BasePlayer>();
						if ((Object)(object)component2 == (Object)null)
						{
							continue;
						}
						if (!capturedPlayer.IsValid(serverside: true) && captureFraction == 0f)
						{
							capturingPlayer.Set(component2);
						}
						if (captureFraction > 0f && (Object)(object)component2 != (Object)(object)capturedPlayer.Get(serverside: true) && (Object)(object)component2 != (Object)(object)capturingPlayer.Get(serverside: true))
						{
							captureFraction = Mathf.Clamp01(captureFraction - Time.deltaTime / timeToCapture);
							if (captureFraction == 0f)
							{
								capturedPlayer.Set(null);
							}
						}
						else if (!Object.op_Implicit((Object)(object)capturedPlayer.Get(serverside: true)) && captureFraction < 1f && (Object)(object)capturingPlayer.Get(serverside: true) == (Object)(object)component2)
						{
							DoProgressEffect();
							captureFraction = Mathf.Clamp01(captureFraction + Time.deltaTime / timeToCapture);
							if (captureFraction == 1f)
							{
								DoCaptureEffect();
								capturedPlayer.Set(component2);
							}
						}
						break;
					}
				}
				SetFlag(Flags.Busy, captureTrigger.entityContents.Count > 1);
			}
			if (num != captureFraction)
			{
				SendNetworkUpdate();
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.genericFloat1 = captureFraction;
		info.msg.ioEntity.genericInt1 = captureTeam;
		info.msg.ioEntity.genericInt2 = capturingTeam;
		info.msg.ioEntity.genericEntRef1 = capturedPlayer.uid;
		info.msg.ioEntity.genericEntRef2 = capturingPlayer.uid;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Game Mode Manifest")]
public class GameModeManifest : ScriptableObject
{
	public static GameModeManifest instance;

	public List<GameObjectRef> gameModePrefabs;

	public static GameModeManifest Get()
	{
		if ((Object)(object)instance == (Object)null)
		{
			instance = Resources.Load<GameModeManifest>("GameModeManifest");
		}
		return instance;
	}
}


using System.Linq;
using UnityEngine;

public class GameModeObjectToggle : BaseMonoBehaviour
{
	public string[] gameModeTags;

	public string[] tagsToDisable;

	public GameObject[] toToggle;

	public bool defaultState;

	public void Awake()
	{
		SetToggle(defaultState);
		BaseGameMode.GameModeChanged += OnGameModeChanged;
	}

	public void OnDestroy()
	{
		BaseGameMode.GameModeChanged -= OnGameModeChanged;
	}

	public void OnGameModeChanged(BaseGameMode newGameMode)
	{
		bool toggle = ShouldBeVisible(newGameMode);
		SetToggle(toggle);
	}

	public void SetToggle(bool wantsOn)
	{
		GameObject[] array = toToggle;
		foreach (GameObject val in array)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.SetActive(wantsOn);
			}
		}
	}

	public bool ShouldBeVisible(BaseGameMode newGameMode)
	{
		if ((Object)(object)newGameMode == (Object)null)
		{
			return defaultState;
		}
		if (tagsToDisable.Length != 0 && (newGameMode.HasAnyGameModeTag(tagsToDisable) || tagsToDisable.Contains("*")))
		{
			return false;
		}
		if (gameModeTags.Length != 0 && (newGameMode.HasAnyGameModeTag(gameModeTags) || gameModeTags.Contains("*")))
		{
			return true;
		}
		return defaultState;
	}
}


public class GameModeVanilla : BaseGameMode
{
}


using System;
using ConVar;

public class GameModeHardcore : GameModeVanilla
{
	protected override void OnCreated()
	{
		base.OnCreated();
	}

	public override void InitShared()
	{
		base.InitShared();
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
	}

	protected override float GetCraftingCostConVar(CraftingCostConVar conVar)
	{
		if (conVar == CraftingCostConVar.HardcoreFirearmAmmunition)
		{
			return Server.hardcoreFirearmAmmunitionCraftingMultiplier;
		}
		return base.GetCraftingCostConVar(conVar);
	}

	public override void ServerInit()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is Recycler recycler)
				{
					recycler.UpdateInSafeZone();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


public class EraGameMode : BaseGameMode
{
}


public class PrimitiveGameMode : EraGameMode
{
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/WorldConfig")]
public class ScriptableWorldConfig : ScriptableObject
{
	public string[] GameModes;

	public bool UndergroundTrains = true;

	public bool UnderwaterLabs = true;

	public string[] BlacklistedPrefabs;
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public class GameModeSoftcore : GameModeVanilla
{
	public GameObjectRef reclaimManagerPrefab;

	[ServerVar]
	public static float reclaim_fraction_belt = 0.5f;

	[ServerVar]
	public static float reclaim_fraction_wear = 1f;

	[ServerVar]
	public static float reclaim_fraction_main = 0.5f;

	[ServerVar]
	public static bool reclaim_suicide = false;

	[ServerVar]
	public static bool reclaim_building_auth = false;

	private static string[] StartingItems = new string[5] { "rock", "torch", "cakefiveyear", "partyhat", "snowball" };

	protected override void OnCreated()
	{
		base.OnCreated();
		SingletonComponent<ServerMgr>.Instance.CreateImportantEntity<ReclaimManager>(reclaimManagerPrefab.resourcePath);
	}

	public void ReturnItemsTo(List<Item> source, ItemContainer itemContainer)
	{
		foreach (Item item in source)
		{
			item.MoveToContainer(itemContainer);
		}
	}

	public override void OnPlayerDeath(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo = null)
	{
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)victim != (Object)null && (victim.IsInTutorial || (victim.net != null && victim.net.group != null && victim.net.group.restricted) || (deathInfo != null && deathInfo.damageTypes.GetMajorityDamageType() == DamageType.Suicide && !victim.IsWounded() && !reclaim_suicide)))
		{
			return;
		}
		if ((Object)(object)victim != (Object)null && !victim.IsNpc && !victim.IsInTutorial)
		{
			if (!reclaim_building_auth)
			{
				BuildingPrivlidge buildingPrivilege = victim.GetBuildingPrivilege();
				if ((Object)(object)buildingPrivilege != (Object)null && buildingPrivilege.IsAuthed(victim))
				{
					return;
				}
			}
			SetInventoryLocked(victim, wantsLocked: false);
			if ((Object)(object)ReclaimManager.instance == (Object)null)
			{
				Debug.LogWarning((object)"No reclaim manage for softcore");
				return;
			}
			List<Item> list = Pool.Get<List<Item>>();
			List<Item> list2 = Pool.Get<List<Item>>();
			List<Item> list3 = Pool.Get<List<Item>>();
			List<Item> list4 = Pool.Get<List<Item>>();
			List<Item> list5 = Pool.Get<List<Item>>();
			List<Item> list6 = Pool.Get<List<Item>>();
			List<Item> list7 = Pool.Get<List<Item>>();
			List<Item> list8 = Pool.Get<List<Item>>();
			victim.inventory.containerBelt.RemoveItemsFromContainer(list5, StartingItems);
			victim.inventory.containerMain.RemoveItemsFromContainer(list7, StartingItems);
			victim.inventory.containerWear.RemoveItemsFromContainer(list6, StartingItems);
			victim.inventory.containerBelt.RemoveFractionOfContainer(list, 1f - reclaim_fraction_belt);
			victim.inventory.containerMain.RemoveFractionOfContainer(list3, 1f - reclaim_fraction_main);
			Item backpackWithInventory = victim.inventory.GetBackpackWithInventory();
			if (backpackWithInventory != null)
			{
				backpackWithInventory.contents.RemoveItemsFromContainer(list8, StartingItems);
				backpackWithInventory.contents.RemoveFractionOfContainer(list4, 1f - reclaim_fraction_main);
				if (list4.Count > 0)
				{
					backpackWithInventory.contents.MergeAllStacks();
				}
				ReturnItemsTo(list8, backpackWithInventory.contents);
			}
			victim.inventory.containerWear.RemoveFractionOfContainer(list2, 1f - reclaim_fraction_wear);
			if (list.Count > 0 || list2.Count > 0 || list3.Count > 0)
			{
				ReclaimManager.instance.AddPlayerReclaim(victim.userID, list, list2, list3, list4);
			}
			ReturnItemsTo(list5, victim.inventory.containerBelt);
			ReturnItemsTo(list7, victim.inventory.containerMain);
			ReturnItemsTo(list6, victim.inventory.containerWear);
			if (backpackWithInventory != null && list2.Contains(backpackWithInventory))
			{
				victim.inventory.containerMain.MergeAllStacks();
				backpackWithInventory.contents.MoveAllItems(victim.inventory.containerMain);
				backpackWithInventory.contents.MoveAllItems(victim.inventory.containerBelt);
				if (backpackWithInventory.contents.itemList.Count > 0)
				{
					backpackWithInventory.contents.Drop(ReclaimManager.ReclaimCorpsePrefab, victim.GetDropPosition(), ((Component)victim).transform.rotation, 0f);
				}
			}
			Pool.Free<Item>(ref list, false);
			Pool.Free<Item>(ref list2, false);
			Pool.Free<Item>(ref list3, false);
			Pool.Free<Item>(ref list4, false);
			Pool.Free<Item>(ref list5, false);
			Pool.Free<Item>(ref list6, false);
			Pool.Free<Item>(ref list7, false);
			Pool.Free<Item>(ref list8, false);
		}
		base.OnPlayerDeath(instigator, victim, deathInfo);
	}

	public override void OnPlayerRespawn(BasePlayer player)
	{
		base.OnPlayerRespawn(player);
		ReclaimManager.instance.GetReclaim(player.userID)?.GiveToPlayer(player);
	}

	public override SleepingBag[] FindSleepingBagsForPlayer(ulong playerID, bool ignoreTimers)
	{
		return SleepingBag.FindForPlayer(playerID, ignoreTimers);
	}

	public override float CorpseRemovalTime(BaseCorpse corpse)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			if ((Object)(object)monument != (Object)null && monument.IsSafeZone && ((Bounds)(ref monument.Bounds)).Contains(((Component)corpse).transform.position))
			{
				return 30f;
			}
		}
		return ConVar.Server.corpsedespawn;
	}

	public void SetInventoryLocked(BasePlayer player, bool wantsLocked)
	{
		player.inventory.containerMain.SetLocked(wantsLocked);
		player.inventory.containerBelt.SetLocked(wantsLocked);
		player.inventory.containerWear.SetLocked(wantsLocked);
	}

	public override void OnPlayerWounded(BasePlayer instigator, BasePlayer victim, HitInfo info)
	{
		base.OnPlayerWounded(instigator, victim, info);
		SetInventoryLocked(victim, wantsLocked: true);
	}

	public override void OnPlayerRevived(BasePlayer instigator, BasePlayer victim)
	{
		if (!victim.IsRestrained)
		{
			SetInventoryLocked(victim, wantsLocked: false);
		}
		base.OnPlayerRevived(instigator, victim);
	}

	public override bool CanMoveItemsFrom(PlayerInventory inv, BaseEntity source, Item item)
	{
		if (item.parent != null && item.parent.HasFlag(ItemContainer.Flag.IsPlayer))
		{
			return !item.parent.IsLocked();
		}
		return base.CanMoveItemsFrom(inv, source, item);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ReclaimManager : BaseEntity
{
	public class PlayerReclaimEntry : IPooled
	{
		public float timeAlive;

		public int id;

		public ulong victimID;

		public ItemContainer mainInventory;

		public ItemContainer wearInventory;

		public ItemContainer beltInventory;

		public ItemContainer backpackInventory;

		public bool HasItems()
		{
			if ((mainInventory == null || mainInventory.itemList.Count <= 0) && (wearInventory == null || wearInventory.itemList.Count <= 0) && (beltInventory == null || beltInventory.itemList.Count <= 0))
			{
				if (backpackInventory != null)
				{
					return backpackInventory.itemList.Count > 0;
				}
				return false;
			}
			return true;
		}

		private ItemContainer CreateContainer()
		{
			ItemContainer itemContainer = Pool.Get<ItemContainer>();
			itemContainer.entityOwner = instance;
			itemContainer.allowedContents = ItemContainer.ContentsType.Generic;
			itemContainer.SetOnlyAllowedItem(null);
			itemContainer.maxStackSize = 0;
			itemContainer.containerVolume = 10;
			itemContainer.ServerInitialize(null, 40);
			itemContainer.canAcceptItem = null;
			itemContainer.GiveUID();
			return itemContainer;
		}

		void IPooled.LeavePool()
		{
			mainInventory = CreateContainer();
			wearInventory = CreateContainer();
			beltInventory = CreateContainer();
			backpackInventory = CreateContainer();
		}

		void IPooled.EnterPool()
		{
			timeAlive = 0f;
			id = -2;
			Pool.Free<ItemContainer>(ref mainInventory);
			Pool.Free<ItemContainer>(ref wearInventory);
			Pool.Free<ItemContainer>(ref beltInventory);
			Pool.Free<ItemContainer>(ref backpackInventory);
		}

		public void GiveToPlayer(BasePlayer player)
		{
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			wearInventory.MoveAllItems(player.inventory.containerWear);
			beltInventory.MoveAllItems(player.inventory.containerBelt);
			mainInventory.MoveAllItems(player.inventory.containerMain);
			if (backpackInventory.itemList.Count > 0)
			{
				Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
				if (backpackWithInventory != null)
				{
					backpackInventory.MoveAllItems(backpackWithInventory.contents);
				}
				if (backpackInventory.itemList.Count > 0)
				{
					backpackInventory.MoveAllItems(player.inventory.containerMain);
				}
				if (backpackInventory.itemList.Count > 0)
				{
					backpackInventory.MoveAllItems(player.inventory.containerBelt);
				}
			}
			if (wearInventory.itemList.Count + beltInventory.itemList.Count + mainInventory.itemList.Count + backpackInventory.itemList.Count > 0)
			{
				ItemContainer.Drop("assets/prefabs/misc/item drop/item_drop_backpack.prefab", player.GetDropPosition(), default(Quaternion), wearInventory, beltInventory, mainInventory, backpackInventory);
			}
		}
	}

	private const int defaultReclaims = 128;

	private const int reclaimSlotCount = 40;

	public static string ReclaimCorpsePrefab = "assets/prefabs/misc/item drop/item_drop_backpack.prefab";

	private int lastReclaimID;

	[ServerVar]
	public static float reclaim_expire_minutes = 120f;

	private static ReclaimManager _instance;

	private Dictionary<ulong, PlayerReclaimEntry> entries = new Dictionary<ulong, PlayerReclaimEntry>();

	private float lastTickTime;

	public static ReclaimManager instance => _instance;

	public int AddPlayerReclaim(ulong victimID, List<Item> belt, List<Item> wear, List<Item> main, List<Item> backpack)
	{
		PlayerReclaimEntry orCreateReclaim = GetOrCreateReclaim(victimID);
		if (belt != null)
		{
			foreach (Item item in belt)
			{
				item.MoveToContainer(orCreateReclaim.beltInventory);
			}
		}
		if (wear != null)
		{
			foreach (Item item2 in wear)
			{
				item2.MoveToContainer(orCreateReclaim.wearInventory);
			}
		}
		if (main != null)
		{
			foreach (Item item3 in main)
			{
				item3.MoveToContainer(orCreateReclaim.mainInventory);
			}
		}
		if (backpack != null)
		{
			foreach (Item item4 in backpack)
			{
				item4.MoveToContainer(orCreateReclaim.backpackInventory);
			}
		}
		lastReclaimID++;
		orCreateReclaim.victimID = victimID;
		orCreateReclaim.id = lastReclaimID;
		orCreateReclaim.timeAlive = 0f;
		return orCreateReclaim.id;
	}

	public void DoCleanup()
	{
		List<PlayerReclaimEntry> list = Pool.Get<List<PlayerReclaimEntry>>();
		foreach (PlayerReclaimEntry value in entries.Values)
		{
			if (!value.HasItems() || value.timeAlive / 60f > reclaim_expire_minutes)
			{
				list.Add(value);
			}
		}
		foreach (PlayerReclaimEntry item in list)
		{
			RemoveEntry(item);
		}
		Pool.Free<PlayerReclaimEntry>(ref list, false);
	}

	public void TickEntries()
	{
		float num = Time.realtimeSinceStartup - lastTickTime;
		foreach (PlayerReclaimEntry value in entries.Values)
		{
			value.timeAlive += num;
		}
		lastTickTime = Time.realtimeSinceStartup;
		DoCleanup();
	}

	public bool HasReclaims(ulong playerID)
	{
		return entries.ContainsKey(playerID);
	}

	public PlayerReclaimEntry GetReclaim(ulong victimId)
	{
		entries.TryGetValue(victimId, out var value);
		return value;
	}

	public PlayerReclaimEntry GetOrCreateReclaim(ulong victimId)
	{
		PlayerReclaimEntry playerReclaimEntry = GetReclaim(victimId);
		if (playerReclaimEntry == null)
		{
			playerReclaimEntry = Pool.Get<PlayerReclaimEntry>();
			playerReclaimEntry.victimID = victimId;
			entries.Add(victimId, playerReclaimEntry);
		}
		return playerReclaimEntry;
	}

	public void RemoveEntry(PlayerReclaimEntry entry)
	{
		entries.Remove(entry.victimID);
		Pool.Free<PlayerReclaimEntry>(ref entry);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk || info.msg.reclaimManager == null)
		{
			return;
		}
		lastReclaimID = info.msg.reclaimManager.lastReclaimID;
		foreach (ReclaimInfo reclaimEntry in info.msg.reclaimManager.reclaimEntries)
		{
			PlayerReclaimEntry orCreateReclaim = GetOrCreateReclaim(reclaimEntry.victimID);
			orCreateReclaim.victimID = reclaimEntry.victimID;
			orCreateReclaim.id = reclaimEntry.reclaimId;
			orCreateReclaim.mainInventory.Load(reclaimEntry.mainInventory);
			orCreateReclaim.wearInventory.Load(reclaimEntry.wearInventory);
			orCreateReclaim.beltInventory.Load(reclaimEntry.beltInventory);
			orCreateReclaim.backpackInventory.Load(reclaimEntry.backpackInventory);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			return;
		}
		info.msg.reclaimManager = Pool.Get<ReclaimManager>();
		info.msg.reclaimManager.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
		info.msg.reclaimManager.lastReclaimID = lastReclaimID;
		foreach (PlayerReclaimEntry value in entries.Values)
		{
			ReclaimInfo val = Pool.Get<ReclaimInfo>();
			val.victimID = value.victimID;
			val.reclaimId = value.id;
			val.mainInventory = value.mainInventory.Save();
			val.wearInventory = value.wearInventory.Save();
			val.beltInventory = value.beltInventory.Save();
			val.backpackInventory = value.backpackInventory.Save();
			info.msg.reclaimManager.reclaimEntries.Add(val);
		}
	}

	public override void ServerInit()
	{
		_instance = this;
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)TickEntries, 1f, 60f);
	}

	internal override void DoServerDestroy()
	{
		_instance = null;
		base.DoServerDestroy();
	}
}


using Facepunch;
using UnityEngine;

public class PlayerReclaimEntry : IPooled
{
	public float timeAlive;

	public int id;

	public ulong victimID;

	public ItemContainer mainInventory;

	public ItemContainer wearInventory;

	public ItemContainer beltInventory;

	public ItemContainer backpackInventory;

	public bool HasItems()
	{
		if ((mainInventory == null || mainInventory.itemList.Count <= 0) && (wearInventory == null || wearInventory.itemList.Count <= 0) && (beltInventory == null || beltInventory.itemList.Count <= 0))
		{
			if (backpackInventory != null)
			{
				return backpackInventory.itemList.Count > 0;
			}
			return false;
		}
		return true;
	}

	private ItemContainer CreateContainer()
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.entityOwner = instance;
		itemContainer.allowedContents = ItemContainer.ContentsType.Generic;
		itemContainer.SetOnlyAllowedItem(null);
		itemContainer.maxStackSize = 0;
		itemContainer.containerVolume = 10;
		itemContainer.ServerInitialize(null, 40);
		itemContainer.canAcceptItem = null;
		itemContainer.GiveUID();
		return itemContainer;
	}

	void IPooled.LeavePool()
	{
		mainInventory = CreateContainer();
		wearInventory = CreateContainer();
		beltInventory = CreateContainer();
		backpackInventory = CreateContainer();
	}

	void IPooled.EnterPool()
	{
		timeAlive = 0f;
		id = -2;
		Pool.Free<ItemContainer>(ref mainInventory);
		Pool.Free<ItemContainer>(ref wearInventory);
		Pool.Free<ItemContainer>(ref beltInventory);
		Pool.Free<ItemContainer>(ref backpackInventory);
	}

	public void GiveToPlayer(BasePlayer player)
	{
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		wearInventory.MoveAllItems(player.inventory.containerWear);
		beltInventory.MoveAllItems(player.inventory.containerBelt);
		mainInventory.MoveAllItems(player.inventory.containerMain);
		if (backpackInventory.itemList.Count > 0)
		{
			Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
			if (backpackWithInventory != null)
			{
				backpackInventory.MoveAllItems(backpackWithInventory.contents);
			}
			if (backpackInventory.itemList.Count > 0)
			{
				backpackInventory.MoveAllItems(player.inventory.containerMain);
			}
			if (backpackInventory.itemList.Count > 0)
			{
				backpackInventory.MoveAllItems(player.inventory.containerBelt);
			}
		}
		if (wearInventory.itemList.Count + beltInventory.itemList.Count + mainInventory.itemList.Count + backpackInventory.itemList.Count > 0)
		{
			ItemContainer.Drop("assets/prefabs/misc/item drop/item_drop_backpack.prefab", player.GetDropPosition(), default(Quaternion), wearInventory, beltInventory, mainInventory, backpackInventory);
		}
	}
}


using System;
using System.Collections;
using System.IO;
using ConVar;
using Facepunch;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.SceneManagement;

public class GameSetup : MonoBehaviour
{
	public static bool RunOnce;

	public bool startServer = true;

	public string demoPath;

	public string clientConnectCommand = "client.connect 127.0.0.1:28015";

	public bool loadMenu = true;

	public bool loadLevel;

	public string loadLevelScene = "";

	public bool loadSave;

	public string loadSaveFile = "";

	public string initializationFile = "";

	public string initializationCommands = "";

	public bool normalRendering;

	protected void Awake()
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		if (RunOnce)
		{
			GameManager.Destroy(((Component)this).gameObject);
			return;
		}
		if (!string.IsNullOrEmpty(initializationCommands))
		{
			CommandLine.Force(CommandLine.Full + " " + initializationCommands);
		}
		Render.use_normal_rendering = normalRendering;
		GameManifest.Load();
		GameManifest.LoadAssets();
		RunOnce = true;
		if (Bootstrap.needsSetup)
		{
			Bootstrap.Init_Tier0();
			if (!string.IsNullOrEmpty(initializationFile))
			{
				if (!File.Exists(initializationFile))
				{
					Debug.Log((object)("Unable to load " + initializationFile + ", does not exist"));
				}
				else
				{
					Debug.Log((object)("Loading initialization file: " + initializationFile));
					ConsoleSystem.RunFile(Option.Server, File.ReadAllText(initializationFile));
				}
			}
			if (!string.IsNullOrEmpty(initializationCommands))
			{
				string[] array = initializationCommands.Split(';');
				foreach (string text in array)
				{
					Debug.Log((object)("Running initialization command: " + text));
					string text2 = text.Trim();
					ConsoleSystem.Run(Option.Server, text2, Array.Empty<object>());
				}
			}
			Bootstrap.Init_Systems();
			Bootstrap.Init_Config();
		}
		((MonoBehaviour)this).StartCoroutine(DoGameSetup());
	}

	private IEnumerator DoGameSetup()
	{
		Application.isLoading = true;
		TerrainMeta.InitNoTerrain();
		ItemManager.Initialize();
		Scene activeScene = SceneManager.GetActiveScene();
		LevelManager.CurrentLevelName = ((Scene)(ref activeScene)).name;
		if (startServer)
		{
			yield return ((MonoBehaviour)this).StartCoroutine(Bootstrap.StartNexusServer());
		}
		if (loadLevel && !string.IsNullOrEmpty(loadLevelScene))
		{
			Net.sv.Reset();
			ConVar.Server.level = loadLevelScene;
			LoadingScreen.Update("LOADING SCENE");
			Application.LoadLevelAdditive(loadLevelScene);
			LoadingScreen.Update(loadLevelScene.ToUpper() + " LOADED");
		}
		if (startServer)
		{
			yield return ((MonoBehaviour)this).StartCoroutine(StartServer());
		}
		yield return null;
		Application.isLoading = false;
	}

	private IEnumerator StartServer()
	{
		ConVar.GC.collect();
		ConVar.GC.unload();
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		if (loadSaveFile.StartsWith('"') && loadSaveFile.EndsWith('"'))
		{
			loadSaveFile = loadSaveFile.Substring(1, loadSaveFile.Length - 2);
		}
		yield return ((MonoBehaviour)this).StartCoroutine(Bootstrap.StartServer(loadSave, loadSaveFile, allowOutOfDateSaves: true));
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class Gibbable : PrefabAttribute, IClientComponent
{
	[Serializable]
	public struct OverrideMesh
	{
		public bool enabled;

		public ColliderType ColliderType;

		public Vector3 BoxSize;

		public Vector3 ColliderCentre;

		public float ColliderRadius;

		public float CapsuleHeight;

		public int CapsuleDirection;

		public bool BlockMaterialCopy;
	}

	public enum ColliderType
	{
		Box,
		Sphere,
		Capsule
	}

	public enum ParentingType
	{
		None,
		GibsOnly,
		FXOnly,
		All
	}

	public enum BoundsEffectType
	{
		None,
		Electrical,
		Glass,
		Scrap,
		Stone,
		Wood
	}

	public GameObject gibSource;

	public Material[] customMaterials;

	public GameObject materialSource;

	public bool copyMaterialBlock = true;

	public bool applyDamageTexture;

	public PhysicMaterial physicsMaterial;

	public GameObjectRef fxPrefab;

	public bool spawnFxPrefab = true;

	[Tooltip("If enabled, gibs will spawn even though we've hit a gib limit")]
	public bool important;

	public bool useContinuousCollision;

	public float explodeScale;

	public float scaleOverride = 1f;

	[ReadOnly]
	public int uniqueId;

	public BoundsEffectType boundsEffectType;

	public bool isConditional;

	[ReadOnly]
	public Bounds effectBounds;

	public List<OverrideMesh> MeshOverrides = new List<OverrideMesh>();

	public bool UsePerGibWaterCheck;

	public bool ForceNoParenting;

	protected override Type GetIndexedType()
	{
		return typeof(Gibbable);
	}
}


using System;
using UnityEngine;

[Serializable]
public struct OverrideMesh
{
	public bool enabled;

	public ColliderType ColliderType;

	public Vector3 BoxSize;

	public Vector3 ColliderCentre;

	public float ColliderRadius;

	public float CapsuleHeight;

	public int CapsuleDirection;

	public bool BlockMaterialCopy;
}


public enum ColliderType
{
	Box,
	Sphere,
	Capsule
}


public enum ParentingType
{
	None,
	GibsOnly,
	FXOnly,
	All
}


public enum BoundsEffectType
{
	None,
	Electrical,
	Glass,
	Scrap,
	Stone,
	Wood
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class GroundWatch : EntityComponent<BaseEntity>, IServerComponent
{
	public Vector3 groundPosition = Vector3.zero;

	public LayerMask layers = LayerMask.op_Implicit(161546240);

	public float radius = 0.1f;

	public bool needBuildingBlock;

	[Tooltip("By default, we consider a deployable as not grounded when at least one AreaCheck fails. This allows you to consider it grounded as long as one AreaCheck passes.")]
	public bool needOnlyOneAreaCheckValid;

	[Header("Whitelist")]
	public BaseEntity[] whitelist;

	public int fails;

	public BaseCombatEntity cachedGround { get; private set; }

	public override void InitShared()
	{
		base.InitShared();
		CacheGround();
	}

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.green;
		Gizmos.DrawSphere(groundPosition, radius);
	}

	public static void PhysicsChanged(GameObject obj)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)obj == (Object)null)
		{
			return;
		}
		Collider component = obj.GetComponent<Collider>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			return;
		}
		Bounds bounds = component.bounds;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vector3 center = ((Bounds)(ref bounds)).center;
		Vector3 extents = ((Bounds)(ref bounds)).extents;
		Vis.Entities(center, ((Vector3)(ref extents)).magnitude + 1f, list, 2263296, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.IsDestroyed && !item.isClient && !(item is BuildingBlock))
			{
				((Component)item).BroadcastMessage("OnPhysicsNeighbourChanged", (SendMessageOptions)1);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public static void PhysicsChanged(Vector3 origin, float radius, int layerMask)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(origin, radius, list, layerMask, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.IsDestroyed && !item.isClient && !(item is BuildingBlock))
			{
				((Component)item).BroadcastMessage("OnPhysicsNeighbourChanged", (SendMessageOptions)1);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public void OnPhysicsNeighbourChanged()
	{
		bool flag = OnGround();
		if (flag && needBuildingBlock)
		{
			flag = HasBuildingBlock();
		}
		if (!flag)
		{
			fails++;
			if (fails >= Physics.groundwatchfails)
			{
				BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					((Component)((Component)baseEntity).transform).BroadcastMessage("OnGroundMissing", (object)cachedGround, (SendMessageOptions)1);
				}
			}
			else
			{
				if (Physics.groundwatchdebug)
				{
					Debug.Log((object)("GroundWatch retry: " + fails));
				}
				((FacepunchBehaviour)this).Invoke((Action)OnPhysicsNeighbourChanged, Physics.groundwatchdelay);
			}
		}
		else
		{
			fails = 0;
		}
	}

	private bool HasBuildingBlock()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(((Component)this).transform.TransformPoint(groundPosition), radius, list, 2097152, (QueryTriggerInteraction)2);
		bool result = false;
		foreach (Collider item in list)
		{
			BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !baseEntity.IsDestroyed && !baseEntity.isClient && baseEntity is BuildingBlock)
			{
				result = true;
				break;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public bool OnGround()
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
		if (Object.op_Implicit((Object)(object)component) && component.isServer)
		{
			if (component.HasParent())
			{
				return true;
			}
			Construction construction = PrefabAttribute.server.Find<Construction>(component.prefabID);
			if ((bool)construction)
			{
				Socket_Base[] allSockets = construction.allSockets;
				for (int i = 0; i < allSockets.Length; i++)
				{
					SocketMod[] socketMods = allSockets[i].socketMods;
					for (int j = 0; j < socketMods.Length; j++)
					{
						SocketMod_AreaCheck socketMod_AreaCheck = socketMods[j] as SocketMod_AreaCheck;
						if (!socketMod_AreaCheck || !socketMod_AreaCheck.wantsInside)
						{
							continue;
						}
						if (needOnlyOneAreaCheckValid)
						{
							if (socketMod_AreaCheck.DoCheck(((Component)component).transform.position, ((Component)component).transform.rotation, component))
							{
								return true;
							}
						}
						else if (!socketMod_AreaCheck.DoCheck(((Component)component).transform.position, ((Component)component).transform.rotation, component))
						{
							if (Physics.groundwatchdebug)
							{
								Debug.Log((object)("GroundWatch failed: " + socketMod_AreaCheck.hierachyName));
							}
							return false;
						}
					}
				}
			}
		}
		if (Physics.groundwatchdebug)
		{
			Debug.Log((object)"GroundWatch failed: Legacy radius check");
		}
		if (LegacyRadiusCheck(component))
		{
			return true;
		}
		return false;
	}

	private void CacheGround()
	{
		BaseEntity baseEntity = GetBaseEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity.isServer)
		{
			LegacyRadiusCheck(baseEntity);
		}
	}

	private bool LegacyRadiusCheck(BaseEntity entity)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(((Component)this).transform.TransformPoint(groundPosition), radius, list, LayerMask.op_Implicit(layers), (QueryTriggerInteraction)2);
		foreach (Collider item in list)
		{
			BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
			if ((Object)(object)baseEntity == (Object)null)
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				return true;
			}
			if ((Object)(object)baseEntity != (Object)null && ((Object)(object)baseEntity == (Object)(object)entity || baseEntity.IsDestroyed || baseEntity.isClient))
			{
				continue;
			}
			if (whitelist != null && whitelist.Length != 0)
			{
				bool flag = false;
				BaseEntity[] array = whitelist;
				foreach (BaseEntity baseEntity2 in array)
				{
					if (baseEntity.prefabID == baseEntity2.prefabID)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					continue;
				}
			}
			DecayEntity decayEntity = entity as DecayEntity;
			DecayEntity decayEntity2 = baseEntity as DecayEntity;
			if (!((Object)(object)decayEntity != (Object)null) || decayEntity.buildingID == 0 || !((Object)(object)decayEntity2 != (Object)null) || decayEntity2.buildingID == 0 || decayEntity.buildingID == decayEntity2.buildingID)
			{
				cachedGround = baseEntity as BaseCombatEntity;
				Pool.FreeUnmanaged<Collider>(ref list);
				return true;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return false;
	}
}


using UnityEngine;

public class HideUntilMobile : EntityComponent<BaseEntity>
{
	public GameObject[] visuals;

	[Tooltip("If turned on, the script will use the convar \"server.projectile.camera.clipdistance\" to determine the distance at which the object will be visible. If turned off, it will use the value in \"overrideDistance\".")]
	public bool useConvarDistance = true;

	public float overrideDistance = 0.3f;

	private Vector3 startPos;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class HitTest : IPooled
{
	public enum Type
	{
		Generic,
		ProjectileEffect,
		Projectile,
		MeleeAttack,
		Use
	}

	public bool hasLifetimeSetup;

	public Type type;

	public Ray AttackRay;

	public float Radius;

	public float Forgiveness;

	public float MaxDistance;

	public RaycastHit RayHit;

	public bool MultiHit;

	public bool BestHit;

	public bool DidHit;

	public DamageProperties damageProperties;

	public GameObject gameObject;

	public Collider collider;

	public BaseEntity ignoreEntity;

	public List<System.Type> ignoredTypes = new List<System.Type>();

	public BaseEntity HitEntity;

	public Vector3 HitPoint;

	public Vector3 HitNormal;

	public float HitDistance;

	public Transform HitTransform;

	public uint HitPart;

	public string HitMaterial;

	public void EnterPool()
	{
		Clear();
	}

	public void LeavePool()
	{
	}

	public void CopyFrom(HitTest other, bool copyHitInfo = false)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		type = other.type;
		AttackRay = other.AttackRay;
		Radius = other.Radius;
		Forgiveness = other.Forgiveness;
		MaxDistance = other.MaxDistance;
		RayHit = other.RayHit;
		damageProperties = other.damageProperties;
		ignoreEntity = other.ignoreEntity;
		ignoredTypes = other.ignoredTypes;
		if (copyHitInfo)
		{
			HitEntity = other.HitEntity;
			HitPoint = other.HitPoint;
			HitNormal = other.HitNormal;
			HitDistance = other.HitDistance;
			HitTransform = other.HitTransform;
			HitPart = other.HitPart;
			HitMaterial = other.HitMaterial;
			MultiHit = other.MultiHit;
			BestHit = other.BestHit;
			DidHit = other.DidHit;
		}
	}

	public Vector3 HitPointWorld()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)HitEntity != (Object)null)
		{
			Transform val = HitTransform;
			if (!Object.op_Implicit((Object)(object)val))
			{
				val = ((Component)HitEntity).transform;
			}
			return val.TransformPoint(HitPoint);
		}
		return HitPoint;
	}

	public Vector3 HitNormalWorld()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)HitEntity != (Object)null)
		{
			Transform val = HitTransform;
			if (!Object.op_Implicit((Object)(object)val))
			{
				val = ((Component)HitEntity).transform;
			}
			return val.TransformDirection(HitNormal);
		}
		return HitNormal;
	}

	public void Clear()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		hasLifetimeSetup = false;
		type = Type.Generic;
		AttackRay = default(Ray);
		Radius = 0f;
		Forgiveness = 0f;
		MaxDistance = 0f;
		RayHit = default(RaycastHit);
		MultiHit = false;
		BestHit = false;
		DidHit = false;
		damageProperties = null;
		gameObject = null;
		collider = null;
		ignoreEntity = null;
		HitEntity = null;
		HitPoint = default(Vector3);
		HitNormal = default(Vector3);
		HitDistance = 0f;
		HitTransform = null;
		HitPart = 0u;
		HitMaterial = null;
		ignoredTypes.Clear();
	}
}


public enum Type
{
	Generic,
	ProjectileEffect,
	Projectile,
	MeleeAttack,
	Use
}


using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;

public class HitInfo : IPooled
{
	public BaseEntity Initiator;

	public BaseEntity WeaponPrefab;

	public AttackEntity Weapon;

	public bool DoHitEffects = true;

	public bool DoDecals = true;

	public bool IsPredicting;

	public bool UseProtection = true;

	public Connection Predicted;

	public bool DidHit;

	public BaseEntity HitEntity;

	public uint HitBone;

	public uint HitPart;

	public uint HitMaterial;

	public Vector3 HitPositionWorld;

	public Vector3 HitPositionLocal;

	public Vector3 HitNormalWorld;

	public Vector3 HitNormalLocal;

	public Vector3 PointStart;

	public Vector3 PointEnd;

	public int ProjectileID;

	public int ProjectileHits;

	public float ProjectileDistance;

	public float ProjectileIntegrity;

	public float ProjectileTravelTime;

	public float ProjectileTrajectoryMismatch;

	public Vector3 ProjectileVelocity;

	public Projectile ProjectilePrefab;

	public PhysicMaterial material;

	public DamageProperties damageProperties;

	public DamageTypeList damageTypes = new DamageTypeList();

	public bool CanGather;

	public bool DidGather;

	public float gatherScale = 1f;

	public BasePlayer InitiatorPlayer
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)Initiator))
			{
				return null;
			}
			return Initiator.ToPlayer();
		}
	}

	public Vector3 attackNormal
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = PointEnd - PointStart;
			return ((Vector3)(ref val)).normalized;
		}
	}

	public bool hasDamage => damageTypes.Total() > 0f;

	public bool InitiatorParented
	{
		get
		{
			if ((Object)(object)Initiator != (Object)null && (Object)(object)Initiator.GetParentEntity() != (Object)null)
			{
				return Initiator.GetParentEntity().IsValid();
			}
			return false;
		}
	}

	public bool HitEntityParented
	{
		get
		{
			if ((Object)(object)HitEntity != (Object)null && (Object)(object)HitEntity.GetParentEntity() != (Object)null)
			{
				return HitEntity.GetParentEntity().IsValid();
			}
			return false;
		}
	}

	public bool isHeadshot
	{
		get
		{
			if ((Object)(object)HitEntity == (Object)null)
			{
				return false;
			}
			BaseCombatEntity baseCombatEntity = HitEntity as BaseCombatEntity;
			if ((Object)(object)baseCombatEntity == (Object)null)
			{
				return false;
			}
			if ((Object)(object)baseCombatEntity.skeletonProperties == (Object)null)
			{
				return false;
			}
			SkeletonProperties.BoneProperty boneProperty = baseCombatEntity.skeletonProperties.FindBone(HitBone);
			if (boneProperty == null)
			{
				return false;
			}
			return boneProperty.area == HitArea.Head;
		}
	}

	public Phrase bonePhrase
	{
		get
		{
			if ((Object)(object)HitEntity == (Object)null)
			{
				return null;
			}
			BaseCombatEntity baseCombatEntity = HitEntity as BaseCombatEntity;
			if ((Object)(object)baseCombatEntity == (Object)null)
			{
				return null;
			}
			if ((Object)(object)baseCombatEntity.skeletonProperties == (Object)null)
			{
				return null;
			}
			return baseCombatEntity.skeletonProperties.FindBone(HitBone)?.name;
		}
	}

	public string boneName
	{
		get
		{
			Phrase val = bonePhrase;
			if (val != null)
			{
				return val.english;
			}
			return "N/A";
		}
	}

	public HitArea boneArea
	{
		get
		{
			if ((Object)(object)HitEntity == (Object)null)
			{
				return (HitArea)(-1);
			}
			BaseCombatEntity baseCombatEntity = HitEntity as BaseCombatEntity;
			if ((Object)(object)baseCombatEntity == (Object)null)
			{
				return (HitArea)(-1);
			}
			return baseCombatEntity.SkeletonLookup(HitBone);
		}
	}

	public void EnterPool()
	{
		Clear();
	}

	public void LeavePool()
	{
	}

	public void Clear()
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		Initiator = null;
		WeaponPrefab = null;
		Weapon = null;
		DoHitEffects = true;
		DoDecals = true;
		IsPredicting = false;
		UseProtection = true;
		Predicted = null;
		DidHit = false;
		HitEntity = null;
		HitBone = 0u;
		HitPart = 0u;
		HitMaterial = 0u;
		HitPositionWorld = default(Vector3);
		HitPositionLocal = default(Vector3);
		HitNormalWorld = default(Vector3);
		HitNormalLocal = default(Vector3);
		PointStart = default(Vector3);
		PointEnd = default(Vector3);
		ProjectileID = 0;
		ProjectileHits = 0;
		ProjectileDistance = 0f;
		ProjectileIntegrity = 0f;
		ProjectileTravelTime = 0f;
		ProjectileTrajectoryMismatch = 0f;
		ProjectileVelocity = default(Vector3);
		ProjectilePrefab = null;
		material = null;
		damageProperties = null;
		damageTypes.Clear();
		CanGather = false;
		DidGather = false;
		gatherScale = 1f;
	}

	public void CopyFrom(HitInfo other)
	{
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		Initiator = other.Initiator;
		WeaponPrefab = other.WeaponPrefab;
		Weapon = other.Weapon;
		DoHitEffects = other.DoHitEffects;
		DoDecals = other.DoDecals;
		IsPredicting = other.IsPredicting;
		UseProtection = other.UseProtection;
		Predicted = other.Predicted;
		DidHit = other.DidHit;
		HitEntity = other.HitEntity;
		HitBone = other.HitBone;
		HitPart = other.HitPart;
		HitMaterial = other.HitMaterial;
		HitPositionWorld = other.HitPositionWorld;
		HitPositionLocal = other.HitPositionLocal;
		HitNormalWorld = other.HitNormalWorld;
		HitNormalLocal = other.HitNormalLocal;
		PointStart = other.PointStart;
		PointEnd = other.PointEnd;
		ProjectileID = other.ProjectileID;
		ProjectileHits = other.ProjectileHits;
		ProjectileDistance = other.ProjectileDistance;
		ProjectileIntegrity = other.ProjectileIntegrity;
		ProjectileTravelTime = other.ProjectileTravelTime;
		ProjectileTrajectoryMismatch = other.ProjectileTrajectoryMismatch;
		ProjectileVelocity = other.ProjectileVelocity;
		ProjectilePrefab = other.ProjectilePrefab;
		material = other.material;
		damageProperties = other.damageProperties;
		for (int i = 0; i < damageTypes.types.Length; i++)
		{
			damageTypes.types[i] = other.damageTypes.types[i];
		}
		CanGather = other.CanGather;
		DidGather = other.DidGather;
		gatherScale = other.gatherScale;
	}

	public bool IsProjectile()
	{
		return ProjectileID != 0;
	}

	public void Init(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount, Vector3 vhitPosition)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Initiator = attacker;
		HitEntity = target;
		HitPositionWorld = vhitPosition;
		if ((Object)(object)attacker != (Object)null)
		{
			PointStart = ((Component)attacker).transform.position;
		}
		damageTypes.Add(type, damageAmount);
	}

	public HitInfo()
	{
	}

	public HitInfo(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount, Vector3 vhitPosition)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		Init(attacker, target, type, damageAmount, vhitPosition);
	}

	public HitInfo(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Init(attacker, target, type, damageAmount, ((Component)target).transform.position);
	}

	public void LoadFromAttack(Attack attack, bool serverSide)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		HitEntity = null;
		PointStart = attack.pointStart;
		PointEnd = attack.pointEnd;
		if (((NetworkableId)(ref attack.hitID)).IsValid)
		{
			DidHit = true;
			if (serverSide)
			{
				HitEntity = BaseNetworkable.serverEntities.Find(attack.hitID) as BaseEntity;
			}
			if (Object.op_Implicit((Object)(object)HitEntity))
			{
				HitBone = attack.hitBone;
				HitPart = attack.hitPartID;
			}
		}
		DidHit = true;
		HitPositionLocal = attack.hitPositionLocal;
		HitPositionWorld = attack.hitPositionWorld;
		HitNormalLocal = ((Vector3)(ref attack.hitNormalLocal)).normalized;
		HitNormalWorld = ((Vector3)(ref attack.hitNormalWorld)).normalized;
		HitMaterial = attack.hitMaterialID;
		if (((NetworkableId)(ref attack.srcParentID)).IsValid)
		{
			BaseEntity baseEntity = null;
			if (serverSide)
			{
				baseEntity = BaseNetworkable.serverEntities.Find(attack.srcParentID) as BaseEntity;
			}
			if (baseEntity.IsValid())
			{
				PointStart = ((Component)baseEntity).transform.TransformPoint(PointStart);
			}
		}
		if (((NetworkableId)(ref attack.dstParentID)).IsValid)
		{
			BaseEntity baseEntity2 = null;
			if (serverSide)
			{
				baseEntity2 = BaseNetworkable.serverEntities.Find(attack.dstParentID) as BaseEntity;
			}
			if (baseEntity2.IsValid())
			{
				PointEnd = ((Component)baseEntity2).transform.TransformPoint(PointEnd);
				HitPositionWorld = ((Component)baseEntity2).transform.TransformPoint(HitPositionWorld);
				HitNormalWorld = ((Component)baseEntity2).transform.TransformDirection(HitNormalWorld);
			}
		}
	}

	public Vector3 PositionOnRay(Vector3 position)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Ray val = default(Ray);
		((Ray)(ref val))..ctor(PointStart, attackNormal);
		if ((Object)(object)ProjectilePrefab == (Object)null)
		{
			return val.ClosestPoint(position);
		}
		Sphere val2 = default(Sphere);
		((Sphere)(ref val2))..ctor(position, ProjectilePrefab.thickness);
		RaycastHit val3 = default(RaycastHit);
		if (((Sphere)(ref val2)).Trace(val, ref val3, float.PositiveInfinity))
		{
			return ((RaycastHit)(ref val3)).point;
		}
		return position;
	}

	public Vector3 HitPositionOnRay()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return PositionOnRay(HitPositionWorld);
	}

	public bool IsNaNOrInfinity()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(PointStart))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(PointEnd))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(HitPositionWorld))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(HitPositionLocal))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(HitNormalWorld))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(HitNormalLocal))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(ProjectileVelocity))
		{
			return true;
		}
		if (float.IsNaN(ProjectileDistance))
		{
			return true;
		}
		if (float.IsInfinity(ProjectileDistance))
		{
			return true;
		}
		if (float.IsNaN(ProjectileIntegrity))
		{
			return true;
		}
		if (float.IsInfinity(ProjectileIntegrity))
		{
			return true;
		}
		if (float.IsNaN(ProjectileTravelTime))
		{
			return true;
		}
		if (float.IsInfinity(ProjectileTravelTime))
		{
			return true;
		}
		if (float.IsNaN(ProjectileTrajectoryMismatch))
		{
			return true;
		}
		if (float.IsInfinity(ProjectileTrajectoryMismatch))
		{
			return true;
		}
		return false;
	}
}


using System;

[Flags]
public enum HitArea
{
	Head = 1,
	Chest = 2,
	Stomach = 4,
	Arm = 8,
	Hand = 0x10,
	Leg = 0x20,
	Foot = 0x40
}


public static class HitAreaConst
{
	public const HitArea Nothing = (HitArea)0;

	public const HitArea Everything = (HitArea)(-1);
}


public static class HitAreaUtil
{
	public static string Format(HitArea area)
	{
		return area switch
		{
			(HitArea)0 => "None", 
			(HitArea)(-1) => "Generic", 
			_ => area.ToString(), 
		};
	}
}


using System;
using UnityEngine;

public class IgnoreRotation : MonoBehaviour
{
	[Serializable]
	public enum RotationType
	{
		None,
		X,
		Y,
		Z
	}

	public RotationType ignoreType;

	public Transform parent;

	private void LateUpdate()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if (ignoreType != 0)
		{
			Quaternion localRotation;
			if (ignoreType == RotationType.X)
			{
				Transform transform = ((Component)this).transform;
				localRotation = parent.localRotation;
				float y = ((Quaternion)(ref localRotation)).eulerAngles.y;
				localRotation = parent.localRotation;
				transform.localRotation = Quaternion.Euler(0f, y, ((Quaternion)(ref localRotation)).eulerAngles.z);
			}
			else if (ignoreType == RotationType.Y)
			{
				Transform transform2 = ((Component)this).transform;
				localRotation = parent.localRotation;
				float x = ((Quaternion)(ref localRotation)).eulerAngles.x;
				localRotation = parent.localRotation;
				transform2.localRotation = Quaternion.Euler(x, 0f, ((Quaternion)(ref localRotation)).eulerAngles.z);
			}
			else if (ignoreType == RotationType.Z)
			{
				Transform transform3 = ((Component)this).transform;
				localRotation = parent.localRotation;
				float x2 = ((Quaternion)(ref localRotation)).eulerAngles.x;
				localRotation = parent.localRotation;
				transform3.localRotation = Quaternion.Euler(x2, ((Quaternion)(ref localRotation)).eulerAngles.y, 0f);
			}
		}
	}
}


using System;

[Serializable]
public enum RotationType
{
	None,
	X,
	Y,
	Z
}


using ProtoBuf;

public interface IInstanceDataReceiver
{
	void ReceiveInstanceData(InstanceData data);
}


public interface IOnParentDestroying
{
	void OnParentDestroying();
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class OnParentDestroyingEx
{
	public static void BroadcastOnParentDestroying(this GameObject go)
	{
		List<IOnParentDestroying> list = Pool.Get<List<IOnParentDestroying>>();
		go.GetComponentsInChildren<IOnParentDestroying>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnParentDestroying();
		}
		Pool.FreeUnmanaged<IOnParentDestroying>(ref list);
	}

	public static void SendOnParentDestroying(this GameObject go)
	{
		List<IOnParentDestroying> list = Pool.Get<List<IOnParentDestroying>>();
		go.GetComponents<IOnParentDestroying>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnParentDestroying();
		}
		Pool.FreeUnmanaged<IOnParentDestroying>(ref list);
	}
}


public interface IOnParentSpawning
{
	void OnParentSpawning();
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class OnParentSpawningEx
{
	public static void BroadcastOnParentSpawning(this GameObject go)
	{
		List<IOnParentSpawning> list = Pool.Get<List<IOnParentSpawning>>();
		go.GetComponentsInChildren<IOnParentSpawning>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnParentSpawning();
		}
		Pool.FreeUnmanaged<IOnParentSpawning>(ref list);
	}

	public static void SendOnParentSpawning(this GameObject go)
	{
		List<IOnParentSpawning> list = Pool.Get<List<IOnParentSpawning>>();
		go.GetComponents<IOnParentSpawning>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnParentSpawning();
		}
		Pool.FreeUnmanaged<IOnParentSpawning>(ref list);
	}
}


public interface IOnPostNetworkUpdate
{
	void OnPostNetworkUpdate(BaseEntity entity);
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class OnPostNetworkUpdateEx
{
	public static void BroadcastOnPostNetworkUpdate(this GameObject go, BaseEntity entity)
	{
		List<IOnPostNetworkUpdate> list = Pool.Get<List<IOnPostNetworkUpdate>>();
		go.GetComponentsInChildren<IOnPostNetworkUpdate>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnPostNetworkUpdate(entity);
		}
		Pool.FreeUnmanaged<IOnPostNetworkUpdate>(ref list);
	}

	public static void SendOnPostNetworkUpdate(this GameObject go, BaseEntity entity)
	{
		List<IOnPostNetworkUpdate> list = Pool.Get<List<IOnPostNetworkUpdate>>();
		go.GetComponents<IOnPostNetworkUpdate>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnPostNetworkUpdate(entity);
		}
		Pool.FreeUnmanaged<IOnPostNetworkUpdate>(ref list);
	}
}


public interface IOnSendNetworkUpdate
{
	void OnSendNetworkUpdate(BaseEntity entity);
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class OnSendNetworkUpdateEx
{
	public static void BroadcastOnSendNetworkUpdate(this GameObject go, BaseEntity entity)
	{
		List<IOnSendNetworkUpdate> list = Pool.Get<List<IOnSendNetworkUpdate>>();
		go.GetComponentsInChildren<IOnSendNetworkUpdate>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnSendNetworkUpdate(entity);
		}
		Pool.FreeUnmanaged<IOnSendNetworkUpdate>(ref list);
	}

	public static void SendOnSendNetworkUpdate(this GameObject go, BaseEntity entity)
	{
		List<IOnSendNetworkUpdate> list = Pool.Get<List<IOnSendNetworkUpdate>>();
		go.GetComponents<IOnSendNetworkUpdate>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnSendNetworkUpdate(entity);
		}
		Pool.FreeUnmanaged<IOnSendNetworkUpdate>(ref list);
	}
}


using UnityEngine;

public class LakeInfo : MonoBehaviour
{
	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.LakeObjs.Add(this);
		}
	}
}


using UnityEngine;

public class LandmarkInfo : MonoBehaviour
{
	[Header("LandmarkInfo")]
	public bool shouldDisplayOnMap;

	public bool isLayerSpecific;

	public Phrase displayPhrase;

	public Sprite mapIcon;

	public virtual MapLayer MapLayer => MapLayer.Overworld;

	protected virtual void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.Landmarks.Add(this);
		}
	}
}


using UnityEngine;

public class LevelInfo : SingletonComponent<LevelInfo>
{
	public string shortName;

	public string displayName;

	[TextArea]
	public string description;

	[Tooltip("A background image to be shown when loading the map")]
	public Texture2D image;

	[Tooltip("You should incrememnt this version when you make changes to the map that will invalidate old saves")]
	[Space(10f)]
	public int version = 1;
}


using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Extend;
using Network;
using UnityEngine;
using UnityEngine.SceneManagement;

public static class LevelManager
{
	public static string CurrentLevelName;

	private static readonly Queue<int> taskQueue = new Queue<int>();

	private static int nextTaskId = 0;

	private const string emptySceneName = "EmptyLastScene";

	public static bool isLoaded
	{
		get
		{
			if (CurrentLevelName == null)
			{
				return false;
			}
			if (CurrentLevelName == "")
			{
				return false;
			}
			if (CurrentLevelName == "Empty")
			{
				return false;
			}
			if (CurrentLevelName == "MenuBackground")
			{
				return false;
			}
			return true;
		}
	}

	public static bool IsValid(string strName)
	{
		return Application.CanStreamedLevelBeLoaded(strName);
	}

	public static IEnumerator LoadLevelAsync(string strName, bool keepLoadingScreenOpen = true, bool showLoadingScreen = true)
	{
		int taskId = nextTaskId++;
		taskQueue.Enqueue(taskId);
		while (taskQueue.Peek() != taskId)
		{
			yield return null;
		}
		try
		{
			if (strName == "proceduralmap")
			{
				strName = "Procedural Map";
			}
			Log("Loading level: " + strName);
			Scene sceneByName = SceneManager.GetSceneByName("EmptyLastScene");
			if (!((Scene)(ref sceneByName)).IsValid())
			{
				SceneManager.CreateScene("EmptyLastScene");
			}
			List<string> list = new List<string>();
			int sceneCount = SceneManager.sceneCount;
			for (int i = 0; i < sceneCount; i++)
			{
				Scene sceneAt = SceneManager.GetSceneAt(i);
				string name = ((Scene)(ref sceneAt)).name;
				if (CanUnloadScene(name))
				{
					list.Add(name);
				}
			}
			int num = List.FindIndex<string>((IReadOnlyList<string>)list, CurrentLevelName, (IEqualityComparer<string>)StringComparer.OrdinalIgnoreCase);
			if (num >= 0)
			{
				string item = list[num];
				list.RemoveAt(num);
				list.Add(item);
			}
			List<GameObject> list2 = Pool.Get<List<GameObject>>();
			foreach (string item2 in list)
			{
				Log("Disabling all objects in scene: " + item2);
				Scene sceneByName2 = SceneManager.GetSceneByName(item2);
				if (!((Scene)(ref sceneByName2)).IsValid())
				{
					Debug.LogWarning((object)("Cannot disable objects in scene because it was not found: " + item2));
					continue;
				}
				list2.Clear();
				((Scene)(ref sceneByName2)).GetRootGameObjects(list2);
				foreach (GameObject item3 in list2)
				{
					if (!((Object)(object)item3 == (Object)null))
					{
						item3.SetActive(false);
					}
				}
			}
			Pool.FreeUnmanaged<GameObject>(ref list2);
			List<AsyncOperation> list3 = new List<AsyncOperation>();
			foreach (string item4 in list)
			{
				AsyncOperation val = SceneManager.UnloadSceneAsync(item4);
				if (val == null)
				{
					Debug.LogError((object)("Failed to unload scene: " + item4));
					continue;
				}
				Log("Unloading scene: " + item4);
				list3.Add(val);
			}
			foreach (AsyncOperation item5 in list3)
			{
				yield return item5;
			}
			Net.sv.Reset();
			Log("Loading scene: " + strName);
			AsyncOperation loadOp = SceneManager.LoadSceneAsync(strName, (LoadSceneMode)1);
			if (loadOp == null)
			{
				Debug.LogError((object)("Failed to load level: " + strName));
				yield break;
			}
			loadOp.allowSceneActivation = false;
			Scene newScene = SceneManager.GetSceneByName(strName);
			while (!loadOp.isDone)
			{
				if (loadOp.progress >= 0.9f)
				{
					Log("Level " + strName + " loaded, activating...");
					loadOp.allowSceneActivation = true;
					CurrentLevelName = strName;
				}
				yield return null;
			}
			Log("Making " + strName + " the default scene");
			SceneManager.SetActiveScene(newScene);
			Log("Level " + strName + " loaded successfully.");
		}
		finally
		{
			taskQueue.Dequeue();
		}
		static bool CanUnloadScene(string sceneName)
		{
			if (string.Equals(sceneName, "DontDestroyOnLoad", StringComparison.OrdinalIgnoreCase) || string.Equals(sceneName, "EmptyLastScene", StringComparison.OrdinalIgnoreCase))
			{
				return false;
			}
			if (AssetBundleBackend.Enabled)
			{
				foreach (Entry scene in AssetSceneManifest.Current.Scenes)
				{
					if (string.Equals(sceneName, scene.Name, StringComparison.OrdinalIgnoreCase))
					{
						return false;
					}
				}
			}
			return true;
		}
	}

	public static IEnumerator UnloadLevelAsync(bool loadingScreen = true)
	{
		yield return LoadLevelAsync("Empty", keepLoadingScreenOpen: false, showLoadingScreen: false);
	}

	private static void Log(string message)
	{
	}
}


public class AnimatorLOD : LODComponent
{
	public float Distance = 100f;
}


public static class BatchingToggleEx
{
}


public interface IBatchingHandler
{
}


using Rust.Workshop;
using UnityEngine;

public class RendererBatch : MonoBehaviour, IClientComponent, ICustomMaterialReplacer, IWorkshopPreview
{
}


public class RendererGrid : SingletonComponent<RendererGrid>, IClientComponent
{
	public static bool Paused;

	public GameObjectRef BatchPrefab;

	public float CellSize = 50f;

	public float MaxMilliseconds = 0.1f;

	public const float MinTimeBetweenRefreshes = 1f;
}


public class CanvasLOD : LODComponent
{
	public float Distance = 100f;
}


using UnityEngine;

public class ClothLOD : FacepunchBehaviour
{
	[ServerVar(Help = "distance cloth will simulate until")]
	public static float clothLODDist = 20f;

	public Cloth cloth;
}


using UnityEngine;

public class CopyLODValues : MonoBehaviour, IEditorComponent
{
	[SerializeField]
	private LODGroup source;

	[SerializeField]
	private LODGroup destination;

	[Tooltip("Is false, exact values are copied. If true, values are scaled based on LODGroup size, so the changeover point will match.")]
	[SerializeField]
	private bool scale = true;

	public bool CanCopy()
	{
		if ((Object)(object)source != (Object)null)
		{
			return (Object)(object)destination != (Object)null;
		}
		return false;
	}

	public void Copy()
	{
		if (!CanCopy())
		{
			return;
		}
		LOD[] lODs = source.GetLODs();
		if (scale)
		{
			float num = destination.size / source.size;
			for (int i = 0; i < lODs.Length; i++)
			{
				lODs[i].screenRelativeTransitionHeight *= num;
			}
		}
		LOD[] lODs2 = destination.GetLODs();
		for (int j = 0; j < lODs2.Length && j < lODs.Length; j++)
		{
			int num2 = ((j == lODs2.Length - 1) ? (lODs.Length - 1) : j);
			lODs2[j].screenRelativeTransitionHeight = lODs[num2].screenRelativeTransitionHeight;
			Debug.Log((object)$"Set destination LOD {j} to {lODs2[j].screenRelativeTransitionHeight}");
		}
		destination.SetLODs(lODs2);
	}
}


public class DecalCull : LODComponent
{
	public float Distance = 20f;
}


public class EnvironmentVolumeLOD : LODComponent
{
	public float Distance = 500f;
}


using UnityEngine;

public class GameObjectLOD : LODComponent
{
	public float Distance = 100f;

	public GameObject TargetGameObject;
}


using UnityEngine;

public class HLODBounds : MonoBehaviour, IEditorComponent
{
	[Tooltip("The bounds that this HLOD will cover. This should not overlap with any other HLODs")]
	public Bounds MeshBounds = new Bounds(Vector3.zero, new Vector3(50f, 25f, 50f));

	[Tooltip("Assets created will use this prefix. Make sure multiple HLODS in a scene have different prefixes")]
	public string MeshPrefix = "root";

	[Tooltip("The point from which to calculate the HLOD. Any RendererLODs that are visible at this distance will baked into the HLOD mesh")]
	public float CullDistance = 100f;

	[Tooltip("If set, the lod will take over at this distance instead of the CullDistance (eg. we make a model based on what this area looks like at 200m but we actually want it take over rendering at 300m)")]
	public float OverrideLodDistance;

	[Tooltip("Any renderers below this height will considered culled even if they are visible from a distance. Good for underground areas")]
	public float CullBelowHeight;

	[Tooltip("Optimises the mesh produced by removing non-visible and small faces. Can turn it off during dev but should be on for final builds")]
	public bool ApplyMeshTrimming = true;

	public MeshTrimSettings Settings = MeshTrimSettings.Default;

	public LODComponent DebugComponent;

	public bool ShowTrimSettings;

	[Tooltip("Prints out information about what the baker is doing, helpful for diagnosing errors")]
	public bool DebugMode;
}


public interface IHLODMeshSource
{
}


public interface ILOD
{
}


using System;
using Rust.Workshop;
using UnityEngine;

public abstract class LODComponent : BaseMonoBehaviour, IClientComponent, ILOD, IWorkshopPreview
{
	[Serializable]
	public struct OccludeeParameters
	{
		[Tooltip("Is Occludee dynamic or static?")]
		public bool isDynamic;

		[Tooltip("Dynamic occludee update interval in seconds; 0 = every frame")]
		public float dynamicUpdateInterval;

		[Tooltip("Distance scale combined with occludee max bounds size at which culled occludee shadows are still visible")]
		public float shadowRangeScale;

		[Tooltip("Show culling bounds via gizmos; editor only")]
		public bool showBounds;

		[Tooltip("Force Occludee always visible?")]
		public bool forceVisible;
	}

	public LODDistanceMode DistanceMode;

	public OccludeeParameters OccludeeParams = new OccludeeParameters
	{
		isDynamic = false,
		dynamicUpdateInterval = 0.2f,
		shadowRangeScale = 3f,
		showBounds = false,
		forceVisible = false
	};
}


using System;
using UnityEngine;

[Serializable]
public struct OccludeeParameters
{
	[Tooltip("Is Occludee dynamic or static?")]
	public bool isDynamic;

	[Tooltip("Dynamic occludee update interval in seconds; 0 = every frame")]
	public float dynamicUpdateInterval;

	[Tooltip("Distance scale combined with occludee max bounds size at which culled occludee shadows are still visible")]
	public float shadowRangeScale;

	[Tooltip("Show culling bounds via gizmos; editor only")]
	public bool showBounds;

	[Tooltip("Force Occludee always visible?")]
	public bool forceVisible;
}


using UnityEngine;

public abstract class LODComponentParticleSystem : LODComponent
{
	[Tooltip("Automatically call Play() the particle system when it's shown via LOD")]
	public bool playOnShow = true;

	public bool disableSubEmittersOnShow;
}


public class LODGrid : SingletonComponent<LODGrid>, IClientComponent
{
	public static bool Paused = false;

	public static bool RefreshDisabled = false;

	public float CellSize = 50f;

	public const float MaxRefreshDistance = 500f;

	public static float TreeMeshDistance = 500f;

	public const float MinTimeBetweenRefreshes = 1f;
}


public class LODManager : SingletonComponent<LODManager>
{
	public float MaxMilliseconds = 1f;
}


using UnityEngine;

public class LODMasterMesh : LODComponent
{
	public MeshRenderer ReplacementMesh;

	public float Distance = 100f;

	public LODComponent[] ChildComponents;

	public bool Block;

	public Bounds MeshBounds;
}


using UnityEngine;

public static class LODUtil
{
	public const float DefaultDistance = 1000f;

	public const float FarCameraDistance = 30f;

	public static float GetDistance(Transform transform, LODDistanceMode mode = LODDistanceMode.XYZ)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetDistance(transform.position, mode);
	}

	public static float GetDistance(Vector3 meshPos, LODDistanceMode mode = LODDistanceMode.XYZ)
	{
		return 1000f;
	}

	private static float GetDistanceInternal(Vector3 cameraPos, Vector3 worldPos, LODDistanceMode mode)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		return mode switch
		{
			LODDistanceMode.XYZ => Vector3.Distance(cameraPos, worldPos), 
			LODDistanceMode.XZ => Vector3Ex.Distance2D(cameraPos, worldPos), 
			LODDistanceMode.Y => Mathf.Abs(cameraPos.y - worldPos.y), 
			_ => 1000f, 
		};
	}

	public static float VerifyDistance(float distance)
	{
		return Mathf.Min(500f, distance);
	}

	public static LODEnvironmentMode DetermineEnvironmentMode(Transform transform)
	{
		if (((Component)transform).CompareTag("OnlyVisibleUnderground") || ((Component)transform.root).CompareTag("OnlyVisibleUnderground"))
		{
			return LODEnvironmentMode.Underground;
		}
		return LODEnvironmentMode.Default;
	}
}


public enum LODDistanceMode
{
	XYZ,
	XZ,
	Y
}


public enum LODEnvironmentMode
{
	Default,
	Underground
}


public class MeshCull : LODComponent, IBatchingHandler
{
	public float Distance = 100f;
}


public class MeshGroupCull : LODComponent
{
	public float Distance = 100f;
}


using System;
using UnityEngine;

public class MeshLOD : LODComponent, IBatchingHandler, IHLODMeshSource
{
	[Serializable]
	public class State
	{
		[Range(1f, 1000f)]
		public float distance;

		public Mesh mesh;
	}

	[Horizontal(1, 0)]
	public State[] States;

	public Mesh GetHighestDetailMesh()
	{
		if (States != null && States.Length != 0)
		{
			return States[0].mesh;
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public class State
{
	[Range(1f, 1000f)]
	public float distance;

	public Mesh mesh;
}


public class MeshTreeLOD : MeshLOD
{
}


using UnityEngine;

public class NotifyLOD : LODComponent
{
	public float Distance = 100f;

	public float MinDistanceMultiplier = 0.2f;

	public GameObject TargetGameObject;
}


public interface INotifyLOD
{
}


using System;

public class ParticleCollisionLOD : LODComponentParticleSystem
{
	public enum QualityLevel
	{
		Disabled = -1,
		HighQuality,
		MediumQuality,
		LowQuality
	}

	[Serializable]
	public class State
	{
		public float distance;

		public QualityLevel quality = QualityLevel.Disabled;
	}

	[Horizontal(1, 0)]
	public State[] States;
}


public enum QualityLevel
{
	Disabled = -1,
	HighQuality,
	MediumQuality,
	LowQuality
}


using System;

[Serializable]
public class State
{
	public float distance;

	public QualityLevel quality = QualityLevel.Disabled;
}


public class ParticleSystemCull : LODComponentParticleSystem
{
	public float Distance = 100f;
}


public class ParticleSystemLightCull : LODComponent
{
	public float LightCullDistance = 5f;
}


using System;
using UnityEngine;

public class ParticleSystemLOD : LODComponentParticleSystem
{
	[Serializable]
	public class State
	{
		public float distance;

		[Range(0f, 1f)]
		public float emission;
	}

	[Horizontal(1, 0)]
	public State[] States;
}


using System;
using UnityEngine;

[Serializable]
public class State
{
	public float distance;

	[Range(0f, 1f)]
	public float emission;
}


using System;
using UnityEngine;
using UnityEngine.Rendering;

public class RendererLOD : LODComponent, IBatchingHandler, IPrefabPreProcess, ICustomMaterialReplacer, IHLODMeshSource
{
	[Serializable]
	public class State
	{
		public float distance;

		public Renderer renderer;

		[NonSerialized]
		public MeshFilter filter;

		[NonSerialized]
		public ShadowCastingMode shadowMode;

		[NonSerialized]
		public bool isImpostor;

		[ReadOnly]
		public bool hasCached;

		[ReadOnly]
		public Mesh stateMesh;

		[ReadOnly]
		public Material[] stateMaterials;

		[ReadOnly]
		public ShadowCastingMode cachedShadowMode;
	}

	public float minDistanceMultiplier;

	public State[] States;

	public bool shouldNotifyOnLODChange;

	[ReadOnly]
	public MeshRenderer collapsedRenderer;

	[ReadOnly]
	public MeshFilter collapsedFilter;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public Mesh GetFinalLodMesh(out Matrix4x4 localToWorldMatrix)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		MeshFilter val2 = default(MeshFilter);
		for (int num = States.Length - 1; num >= 0; num--)
		{
			Mesh val = null;
			if ((Object)(object)States[num].renderer != (Object)null && ((Component)States[num].renderer).TryGetComponent<MeshFilter>(ref val2))
			{
				val = val2.sharedMesh;
			}
			if ((Object)(object)val != (Object)null)
			{
				localToWorldMatrix = ((Component)States[num].renderer).transform.localToWorldMatrix;
				return val;
			}
		}
		return null;
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering;

[Serializable]
public class State
{
	public float distance;

	public Renderer renderer;

	[NonSerialized]
	public MeshFilter filter;

	[NonSerialized]
	public ShadowCastingMode shadowMode;

	[NonSerialized]
	public bool isImpostor;

	[ReadOnly]
	public bool hasCached;

	[ReadOnly]
	public Mesh stateMesh;

	[ReadOnly]
	public Material[] stateMaterials;

	[ReadOnly]
	public ShadowCastingMode cachedShadowMode;
}


public static class RendererToggleDynamicEx
{
}


public class RigidbodyLOD : LODComponent
{
	public float Distance = 100f;
}


using UnityEngine;

public class SwitchLODMaterials : MonoBehaviour, IEditorComponent
{
	public Material[] materialSet1;

	public Material[] materialSet2;
}


using System;
using UnityEngine;
using UnityEngine.Rendering;

public class TreeLOD : LODComponent
{
	[Serializable]
	public class State
	{
		public float distance;

		public Renderer renderer;

		[NonSerialized]
		public MeshFilter filter;

		[NonSerialized]
		public ShadowCastingMode shadowMode;

		[NonSerialized]
		public bool isImpostor;
	}

	[Horizontal(1, 0)]
	public State[] States;

	public bool GetClosestPointOnBounds;
}


using System;
using UnityEngine;
using UnityEngine.Rendering;

[Serializable]
public class State
{
	public float distance;

	public Renderer renderer;

	[NonSerialized]
	public MeshFilter filter;

	[NonSerialized]
	public ShadowCastingMode shadowMode;

	[NonSerialized]
	public bool isImpostor;
}


using UnityEngine;

public class UndergroundLODSwitcher : MonoBehaviour, IClientComponent
{
	public LODComponent TargetComponent;
}


using UnityEngine;

public class MeshReplacement : MonoBehaviour
{
	public SkinnedMeshRenderer Female;

	internal static void Process(GameObject go, bool IsFemale)
	{
	}
}


using UnityEngine;

public class MonumentInfo : LandmarkInfo, IPrefabPreProcess
{
	[Header("MonumentInfo")]
	public MonumentType Type = MonumentType.Building;

	[InspectorFlags]
	public MonumentTier Tier = (MonumentTier)(-1);

	public int MinWorldSize;

	public Bounds Bounds = new Bounds(Vector3.zero, Vector3.zero);

	public bool HasNavmesh;

	public bool IsSafeZone;

	public bool AllowPatrolHeliCrash;

	[HideInInspector]
	public bool WantsDungeonLink;

	[HideInInspector]
	public bool HasDungeonLink;

	[HideInInspector]
	public DungeonGridInfo DungeonEntrance;

	private OBB obbBounds;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	protected override void Awake()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Awake();
		obbBounds = new OBB(((Component)this).transform.position, ((Component)this).transform.rotation, Bounds);
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.Monuments.Add(this);
		}
	}

	private void Start()
	{
	}

	public bool CheckPlacement(Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(pos, scale, rot, Bounds);
		Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
		Vector3 point2 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
		Vector3 point3 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
		Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
		int topology = TerrainMeta.TopologyMap.GetTopology(point);
		int topology2 = TerrainMeta.TopologyMap.GetTopology(point2);
		int topology3 = TerrainMeta.TopologyMap.GetTopology(point3);
		int topology4 = TerrainMeta.TopologyMap.GetTopology(point4);
		int num = TierToMask(Tier);
		int num2 = 0;
		if ((num & topology) != 0)
		{
			num2++;
		}
		if ((num & topology2) != 0)
		{
			num2++;
		}
		if ((num & topology3) != 0)
		{
			num2++;
		}
		if ((num & topology4) != 0)
		{
			num2++;
		}
		if (num2 < 3)
		{
			return false;
		}
		WaterBody componentInChildren = ((Component)this).GetComponentInChildren<WaterBody>();
		if ((Object)(object)componentInChildren == (Object)null || componentInChildren.Type != WaterBodyType.Lake)
		{
			return true;
		}
		if (pos.y + componentInChildren.MinWaterLevel() < 1f)
		{
			return false;
		}
		return true;
	}

	public float Distance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).Distance(position);
	}

	public float SqrDistance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).SqrDistance(position);
	}

	public float Distance(OBB obb)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).Distance(obb);
	}

	public float SqrDistance(OBB obb)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).SqrDistance(obb);
	}

	public bool IsInBounds(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).Contains(position);
	}

	public Vector3 ClosestPointOnBounds(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).ClosestPoint(position);
	}

	public PathFinder.Point GetPathFinderPoint(int res)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		float num = TerrainMeta.NormalizeX(position.x);
		float num2 = TerrainMeta.NormalizeZ(position.z);
		PathFinder.Point result = default(PathFinder.Point);
		result.x = Mathf.Clamp((int)(num * (float)res), 0, res - 1);
		result.y = Mathf.Clamp((int)(num2 * (float)res), 0, res - 1);
		return result;
	}

	public int GetPathFinderRadius(int res)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Bounds)(ref Bounds)).extents.x * TerrainMeta.OneOverSize.x;
		float num2 = ((Bounds)(ref Bounds)).extents.z * TerrainMeta.OneOverSize.z;
		return Mathf.CeilToInt(Mathf.Max(num, num2) * (float)res);
	}

	public float GetWidest2DBound()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		float x = ((Bounds)(ref Bounds)).size.x;
		float z = ((Bounds)(ref Bounds)).size.z;
		return Mathf.Max(x, z);
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = new Color(0f, 0.7f, 1f, 0.1f);
		Gizmos.DrawCube(((Bounds)(ref Bounds)).center, ((Bounds)(ref Bounds)).size);
		Gizmos.color = new Color(0f, 0.7f, 1f, 1f);
		Gizmos.DrawWireCube(((Bounds)(ref Bounds)).center, ((Bounds)(ref Bounds)).size);
	}

	public MonumentNavMesh GetMonumentNavMesh()
	{
		return ((Component)this).GetComponent<MonumentNavMesh>();
	}

	public static int TierToMask(MonumentTier tier)
	{
		int num = 0;
		if ((tier & MonumentTier.Tier0) != 0)
		{
			num |= 0x4000000;
		}
		if ((tier & MonumentTier.Tier1) != 0)
		{
			num |= 0x8000000;
		}
		if ((tier & MonumentTier.Tier2) != 0)
		{
			num |= 0x10000000;
		}
		return num;
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		HasDungeonLink = DetermineHasDungeonLink();
		WantsDungeonLink = DetermineWantsDungeonLink();
		DungeonEntrance = FindDungeonEntrance();
	}

	private DungeonGridInfo FindDungeonEntrance()
	{
		return ((Component)this).GetComponentInChildren<DungeonGridInfo>();
	}

	private bool DetermineHasDungeonLink()
	{
		return (Object)(object)((Component)this).GetComponentInChildren<DungeonGridLink>() != (Object)null;
	}

	private bool DetermineWantsDungeonLink()
	{
		if (Type == MonumentType.WaterWell)
		{
			return false;
		}
		if (Type == MonumentType.Building && displayPhrase.token.StartsWith("mining_quarry"))
		{
			return false;
		}
		if (Type == MonumentType.Radtown && displayPhrase.token.StartsWith("swamp"))
		{
			return false;
		}
		return true;
	}
}


public enum MonumentType
{
	Cave,
	Airport,
	Building,
	Town,
	Radtown,
	Lighthouse,
	WaterWell,
	Roadside,
	Mountain,
	Lake,
	Oasis,
	Canyon
}


public enum MonumentTier
{
	Tier0 = 1,
	Tier1 = 2,
	Tier2 = 4
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PickupVolume : PrefabAttribute
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	protected override Type GetIndexedType()
	{
		return typeof(PickupVolume);
	}

	public static bool Check(Vector3 position, Quaternion rotation, PickupVolume[] volumes, BaseEntity ignoreEntity = null)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < volumes.Length; i++)
		{
			if (volumes[i].CheckInternal(position, rotation, 256, ignoreEntity))
			{
				return true;
			}
		}
		return false;
	}

	protected bool CheckInternal(Vector3 position, Quaternion rotation, int mask = -1, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * ((Bounds)(ref bounds)).center + worldPosition);
		if (CheckOBB(new OBB(position, ((Bounds)(ref bounds)).size, rotation * worldRotation), mask, this, ignoreEntity))
		{
			return true;
		}
		return false;
	}

	private static bool CheckOBB(OBB obb, int layerMask, PickupVolume volume)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return CheckOBB(obb, layerMask, volume, null);
	}

	private static bool CheckOBB(OBB obb, int layerMask, PickupVolume volume, BaseEntity ignoredEntity = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(obb, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume, ignoredEntity);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckFlags(List<Collider> colliders, PickupVolume volume, BaseEntity ignoredEntity = null)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		foreach (Collider collider in colliders)
		{
			BaseEntity baseEntity = collider.ToBaseEntity();
			if ((!((Object)(object)baseEntity != (Object)null) || !((Object)(object)ignoredEntity != (Object)null) || !(baseEntity.net.ID == ignoredEntity.net.ID)) && (Object)(object)baseEntity != (Object)null && (Object)(object)baseEntity != (Object)(object)ignoredEntity)
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using UnityEngine;

public class Prefab<T> : Prefab, IComparable<Prefab<T>> where T : Component
{
	public T Component;

	public Prefab(string name, GameObject prefab, T component, GameManager manager, PrefabAttribute.Library attribute)
		: base(name, prefab, manager, attribute)
	{
		Component = component;
	}

	public int CompareTo(Prefab<T> that)
	{
		return CompareTo((Prefab)that);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

public class Prefab : IComparable<Prefab>
{
	public uint ID;

	public string Name;

	public string Folder;

	public GameObject Object;

	public GameManager Manager;

	public PrefabAttribute.Library Attribute;

	public PrefabParameters Parameters;

	public PrefabWeight Weight;

	public int SpawnedCount;

	private TerrainAnchor[] cachedTerrainAnchors;

	private TerrainCheck[] cachedTerrainChecks;

	private TerrainFilter[] cachedTerrainFilters;

	private TerrainModifier[] cachedTerrainModifiers;

	private TerrainPlacement[] cachedTerrainPlacements;

	private WaterCheck[] cachedWaterChecks;

	private BoundsCheck[] cachedBoundsChecks;

	private DecorComponent[] cachedDecorComponents;

	private EnvironmentVolumeCheck[] cachedEnvironmentVolumeChecks;

	public static PrefabAttribute.Library DefaultAttribute => PrefabAttribute.server;

	public static GameManager DefaultManager => GameManager.server;

	public Prefab(string name, GameObject prefab, GameManager manager, PrefabAttribute.Library attribute)
	{
		ID = StringPool.Get(name);
		Name = name;
		Folder = (string.IsNullOrWhiteSpace(name) ? "" : Path.GetDirectoryName(name));
		Object = prefab;
		Manager = manager;
		Attribute = attribute;
		Parameters = (Object.op_Implicit((Object)(object)prefab) ? prefab.GetComponent<PrefabParameters>() : null);
		Weight = attribute?.Find<PrefabWeight>(ID);
	}

	public static implicit operator GameObject(Prefab prefab)
	{
		return prefab.Object;
	}

	public int CompareTo(Prefab that)
	{
		return that?.PriorityCompare(this) ?? 1;
	}

	private int PriorityCompare(Prefab that)
	{
		int num = (int)(((Object)(object)Parameters != (Object)null) ? Parameters.Priority : PrefabPriority.Default);
		int num2 = (int)(((Object)(object)that.Parameters != (Object)null) ? that.Parameters.Priority : PrefabPriority.Default);
		if (num == num2)
		{
			int spawnedCount = SpawnedCount;
			int spawnedCount2 = that.SpawnedCount;
			if (spawnedCount == spawnedCount2)
			{
				return 0;
			}
			if (spawnedCount >= spawnedCount2)
			{
				return -1;
			}
			return 1;
		}
		if (num <= num2)
		{
			return -1;
		}
		return 1;
	}

	public bool ApplyTerrainAnchors(ref Vector3 pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter = null)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainAnchors == null)
		{
			cachedTerrainAnchors = Attribute.FindAll<TerrainAnchor>(ID);
		}
		return Object.transform.ApplyTerrainAnchors(cachedTerrainAnchors, ref pos, rot, scale, mode, filter);
	}

	public bool ApplyTerrainAnchors(ref Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainAnchors == null)
		{
			cachedTerrainAnchors = Attribute.FindAll<TerrainAnchor>(ID);
		}
		return Object.transform.ApplyTerrainAnchors(cachedTerrainAnchors, ref pos, rot, scale, filter);
	}

	public bool ApplyTerrainChecks(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainChecks == null)
		{
			cachedTerrainChecks = Attribute.FindAll<TerrainCheck>(ID);
		}
		return Object.transform.ApplyTerrainChecks(cachedTerrainChecks, pos, rot, scale, filter);
	}

	public bool ApplyTerrainFilters(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainFilters == null)
		{
			cachedTerrainFilters = Attribute.FindAll<TerrainFilter>(ID);
		}
		return Object.transform.ApplyTerrainFilters(cachedTerrainFilters, pos, rot, scale, filter);
	}

	public void ApplyTerrainModifiers(Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainModifiers == null)
		{
			cachedTerrainModifiers = Attribute.FindAll<TerrainModifier>(ID);
		}
		Object.transform.ApplyTerrainModifiers(cachedTerrainModifiers, pos, rot, scale);
	}

	public void ApplyTerrainPlacements(Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainPlacements == null)
		{
			cachedTerrainPlacements = Attribute.FindAll<TerrainPlacement>(ID);
		}
		Object.transform.ApplyTerrainPlacements(cachedTerrainPlacements, pos, rot, scale);
	}

	public bool ApplyWaterChecks(Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedWaterChecks == null)
		{
			cachedWaterChecks = Attribute.FindAll<WaterCheck>(ID);
		}
		return Object.transform.ApplyWaterChecks(cachedWaterChecks, pos, rot, scale);
	}

	public bool ApplyBoundsChecks(Vector3 pos, Quaternion rot, Vector3 scale, LayerMask rejectOnLayer)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (cachedBoundsChecks == null)
		{
			cachedBoundsChecks = Attribute.FindAll<BoundsCheck>(ID);
		}
		BaseEntity component = Object.GetComponent<BaseEntity>();
		if ((Object)(object)component != (Object)null)
		{
			return component.ApplyBoundsChecks(cachedBoundsChecks, pos, rot, scale, rejectOnLayer);
		}
		return true;
	}

	public void ApplyDecorComponents(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		if (cachedDecorComponents == null)
		{
			cachedDecorComponents = Attribute.FindAll<DecorComponent>(ID);
		}
		Object.transform.ApplyDecorComponents(cachedDecorComponents, ref pos, ref rot, ref scale);
	}

	public bool ApplyEnvironmentVolumeChecks(Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedEnvironmentVolumeChecks == null)
		{
			cachedEnvironmentVolumeChecks = Attribute.FindAll<EnvironmentVolumeCheck>(ID);
		}
		return Object.transform.ApplyEnvironmentVolumeChecks(cachedEnvironmentVolumeChecks, pos, rot, scale);
	}

	public bool CheckEnvironmentVolumes(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Object.transform.CheckEnvironmentVolumes(pos, rot, scale, type);
	}

	public bool CheckEnvironmentVolumesInsideTerrain(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float padding = 0f)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Object.transform.CheckEnvironmentVolumesInsideTerrain(pos, rot, scale, typeRequire, typeIgnore, padding);
	}

	public bool CheckEnvironmentVolumesOutsideTerrain(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float padding = 0f)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Object.transform.CheckEnvironmentVolumesOutsideTerrain(pos, rot, scale, typeRequire, typeIgnore, padding);
	}

	public bool CheckEnvironmentVolumesAboveAltitude(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float altitude = 0f)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Object.transform.CheckEnvironmentVolumesAboveAltitude(pos, rot, scale, typeRequire, typeIgnore, altitude);
	}

	public bool CheckEnvironmentVolumesBelowAltitude(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float altitude = 0f)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Object.transform.CheckEnvironmentVolumesBelowAltitude(pos, rot, scale, typeRequire, typeIgnore, altitude);
	}

	public void ApplySequenceReplacement(List<Prefab> sequence, ref Prefab replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex, Vector3 position)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		PathSequence pathSequence = Attribute.Find<PathSequence>(ID);
		if (pathSequence != null)
		{
			pathSequence.ApplySequenceReplacement(sequence, ref replacement, possibleReplacements, pathLength, pathIndex, position);
		}
	}

	public GameObject Spawn(Transform transform, bool active = true)
	{
		return Manager.CreatePrefab(Name, transform, active);
	}

	public GameObject Spawn(Vector3 pos, Quaternion rot, bool active = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Manager.CreatePrefab(Name, pos, rot, active);
	}

	public GameObject Spawn(Vector3 pos, Quaternion rot, Vector3 scale, bool active = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return Manager.CreatePrefab(Name, pos, rot, scale, active);
	}

	public BaseEntity SpawnEntity(Vector3 pos, Quaternion rot, bool active = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Manager.CreateEntity(Name, pos, rot, active);
	}

	public static Prefab<T> Load<T>(uint id, GameManager manager = null, PrefabAttribute.Library attribute = null) where T : Component
	{
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		string text = StringPool.Get(id);
		if (string.IsNullOrWhiteSpace(text))
		{
			Debug.LogWarning((object)$"Could not find path for prefab ID {id}");
			return null;
		}
		GameObject val = manager.FindPrefab(text);
		T component = val.GetComponent<T>();
		return new Prefab<T>(text, val, component, manager, attribute);
	}

	public static Prefab Load(uint id, GameManager manager = null, PrefabAttribute.Library attribute = null)
	{
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		string text = StringPool.Get(id);
		if (string.IsNullOrWhiteSpace(text))
		{
			Debug.LogWarning((object)$"Could not find path for prefab ID {id}");
			return null;
		}
		GameObject prefab = manager.FindPrefab(text);
		return new Prefab(text, prefab, manager, attribute);
	}

	public static Prefab[] Load(string folder, GameManager manager = null, PrefabAttribute.Library attribute = null, bool useProbabilities = true, bool useWorldConfig = true)
	{
		if (string.IsNullOrEmpty(folder))
		{
			return null;
		}
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		string[] array = FindPrefabNames(folder, useProbabilities, useWorldConfig);
		Prefab[] array2 = new Prefab[array.Length];
		for (int i = 0; i < array2.Length; i++)
		{
			string text = array[i];
			GameObject prefab = manager.FindPrefab(text);
			array2[i] = new Prefab(text, prefab, manager, attribute);
		}
		return array2;
	}

	public static Prefab<T>[] Load<T>(string folder, GameManager manager = null, PrefabAttribute.Library attribute = null, bool useProbabilities = true, bool useWorldConfig = true) where T : Component
	{
		if (string.IsNullOrEmpty(folder))
		{
			return null;
		}
		return Load<T>(FindPrefabNames(folder, useProbabilities, useWorldConfig), manager, attribute);
	}

	public static Prefab<T>[] Load<T>(string[] names, GameManager manager = null, PrefabAttribute.Library attribute = null) where T : Component
	{
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		Prefab<T>[] array = new Prefab<T>[names.Length];
		for (int i = 0; i < array.Length; i++)
		{
			string text = names[i];
			GameObject val = manager.FindPrefab(text);
			if ((Object)(object)val == (Object)null)
			{
				Debug.LogError((object)("Can't find prefab '" + text + "'"));
			}
			T component = val.GetComponent<T>();
			array[i] = new Prefab<T>(text, val, component, manager, attribute);
		}
		return array;
	}

	public static Prefab LoadRandom(string folder, ref uint seed, GameManager manager = null, PrefabAttribute.Library attribute = null, bool useProbabilities = true)
	{
		if (string.IsNullOrEmpty(folder))
		{
			return null;
		}
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		string[] array = FindPrefabNames(folder, useProbabilities);
		if (array.Length == 0)
		{
			return null;
		}
		string text = array[SeedRandom.Range(ref seed, 0, array.Length)];
		GameObject prefab = manager.FindPrefab(text);
		return new Prefab(text, prefab, manager, attribute);
	}

	public static Prefab<T> LoadRandom<T>(string folder, ref uint seed, GameManager manager = null, PrefabAttribute.Library attribute = null, bool useProbabilities = true) where T : Component
	{
		if (string.IsNullOrEmpty(folder))
		{
			return null;
		}
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		string[] array = FindPrefabNames(folder, useProbabilities);
		if (array.Length == 0)
		{
			return null;
		}
		string text = array[SeedRandom.Range(ref seed, 0, array.Length)];
		GameObject val = manager.FindPrefab(text);
		T component = val.GetComponent<T>();
		return new Prefab<T>(text, val, component, manager, attribute);
	}

	private static string[] FindPrefabNames(string strPrefab, bool useProbabilities = false, bool useWorldConfig = false)
	{
		strPrefab = strPrefab.TrimEnd('/').ToLower();
		GameObject[] array = FileSystem.LoadPrefabs(strPrefab + "/");
		List<string> list = new List<string>(array.Length);
		GameObject[] array2 = array;
		foreach (GameObject val in array2)
		{
			string text = strPrefab + "/" + ((Object)val).name.ToLower() + ".prefab";
			if (useWorldConfig && !World.Config.IsPrefabAllowed(text))
			{
				continue;
			}
			if (!useProbabilities)
			{
				list.Add(text);
				continue;
			}
			PrefabParameters component = val.GetComponent<PrefabParameters>();
			float num = (Object.op_Implicit((Object)(object)component) ? component.Count : 1f);
			for (int j = 0; (float)j < num; j++)
			{
				list.Add(text);
			}
		}
		list.Sort();
		return list.ToArray();
	}
}


using System;
using UnityEngine;

public class PrefabInformation : PrefabAttribute
{
	public ItemDefinition associatedItemDefinition;

	public Phrase title;

	public Phrase description;

	public Sprite sprite;

	public bool shownOnDeathScreen;

	protected override Type GetIndexedType()
	{
		return typeof(PrefabInformation);
	}
}


using UnityEngine;

public class PrefabInstantiate : MonoBehaviour, IClientComponent
{
	public GameObjectRef Prefab;
}


public enum PrefabPriority
{
	Lowest,
	Low,
	Default,
	High,
	Highest
}


using UnityEngine;

public class PrefabParameters : MonoBehaviour
{
	public PrefabPriority Priority = PrefabPriority.Default;

	public float Count = 1f;
}


public struct PreProcessPrefabOptions
{
	public static readonly PreProcessPrefabOptions Default;

	public static readonly PreProcessPrefabOptions Default_NoResetPosition;

	public static readonly PreProcessPrefabOptions AssetSceneBundling;

	public static readonly PreProcessPrefabOptions AssetSceneRuntime;

	public bool ResetLocalTransform;

	public bool StripComponents;

	public bool StripEmptyChildren;

	public bool PreProcess;

	public bool PostProcess;

	public bool UpdateMeshCooking;

	static PreProcessPrefabOptions()
	{
		Default = new PreProcessPrefabOptions
		{
			ResetLocalTransform = true,
			StripComponents = true,
			StripEmptyChildren = true,
			PreProcess = true,
			PostProcess = true,
			UpdateMeshCooking = true
		};
		AssetSceneBundling = new PreProcessPrefabOptions
		{
			ResetLocalTransform = true,
			StripComponents = true,
			StripEmptyChildren = true,
			PreProcess = true,
			PostProcess = false,
			UpdateMeshCooking = true
		};
		AssetSceneRuntime = new PreProcessPrefabOptions
		{
			ResetLocalTransform = false,
			StripComponents = false,
			StripEmptyChildren = false,
			PreProcess = true,
			PostProcess = true,
			UpdateMeshCooking = false
		};
		Default_NoResetPosition = Default;
		Default_NoResetPosition.ResetLocalTransform = false;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.BurstCloth;
using Rust.UI;
using TMPro;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UnityStandardAssets.ImageEffects;
using VLB;

public class PrefabPreProcess : IPrefabProcessor
{
	public static Type[] clientsideOnlyTypes = new Type[40]
	{
		typeof(IClientComponent),
		typeof(SkeletonSkinLod),
		typeof(ImageEffectLayer),
		typeof(NGSS_Directional),
		typeof(VolumetricDustParticles),
		typeof(VolumetricLightBeam),
		typeof(Cloth),
		typeof(TextMeshPro),
		typeof(MeshFilter),
		typeof(Renderer),
		typeof(AudioLowPassFilter),
		typeof(AudioSource),
		typeof(AudioListener),
		typeof(ParticleSystemRenderer),
		typeof(ParticleSystem),
		typeof(ParticleEmitFromParentObject),
		typeof(ImpostorShadows),
		typeof(Light),
		typeof(LODGroup),
		typeof(Animator),
		typeof(AnimationEvents),
		typeof(PlayerVoiceSpeaker),
		typeof(VoiceProcessor),
		typeof(PlayerVoiceRecorder),
		typeof(ParticleScaler),
		typeof(PostEffectsBase),
		typeof(TOD_ImageEffect),
		typeof(TOD_Scattering),
		typeof(TOD_Rays),
		typeof(Tree),
		typeof(Projector),
		typeof(HttpImage),
		typeof(EventTrigger),
		typeof(StandaloneInputModule),
		typeof(UIBehaviour),
		typeof(Canvas),
		typeof(CanvasRenderer),
		typeof(CanvasGroup),
		typeof(GraphicRaycaster),
		typeof(BurstClothConstraint)
	};

	public static Type[] serversideOnlyTypes = new Type[5]
	{
		typeof(IServerComponent),
		typeof(NavMeshLink),
		typeof(NavMeshSurface),
		typeof(NavMeshObstacle),
		typeof(NavMeshModifierVolume)
	};

	public bool isClientside;

	public bool isServerside;

	public bool isBundling;

	public Dictionary<string, GameObject> prefabList = new Dictionary<string, GameObject>(StringComparer.OrdinalIgnoreCase);

	public List<Component> destroyList = new List<Component>();

	public List<GameObject> cleanupList = new List<GameObject>();

	public PrefabPreProcess(bool clientside, bool serverside, bool bundling = false)
	{
		isClientside = clientside;
		isServerside = serverside;
		isBundling = bundling;
	}

	public GameObject Find(string strPrefab)
	{
		if (prefabList.TryGetValue(strPrefab, out var value))
		{
			if ((Object)(object)value == (Object)null)
			{
				prefabList.Remove(strPrefab);
				return null;
			}
			return value;
		}
		return null;
	}

	public bool NeedsProcessing(GameObject go, PreProcessPrefabOptions options)
	{
		if (go.CompareTag("NoPreProcessing"))
		{
			return false;
		}
		if (options.PreProcess && HasComponents<IPrefabPreProcess>(go.transform))
		{
			return true;
		}
		if (options.PostProcess && HasComponents<IPrefabPostProcess>(go.transform))
		{
			return true;
		}
		if (options.StripComponents && HasComponents<IEditorComponent>(go.transform))
		{
			return true;
		}
		if (!isClientside)
		{
			if (options.StripComponents && clientsideOnlyTypes.Any((Type type) => HasComponents(go.transform, type)))
			{
				return true;
			}
			if (options.StripComponents && HasComponents<IClientComponentEx>(go.transform))
			{
				return true;
			}
		}
		if (!isServerside)
		{
			if (options.StripComponents && serversideOnlyTypes.Any((Type type) => HasComponents(go.transform, type)))
			{
				return true;
			}
			if (options.StripComponents && HasComponents<IServerComponentEx>(go.transform))
			{
				return true;
			}
		}
		return false;
	}

	public void ProcessObject(string name, GameObject go, PreProcessPrefabOptions options)
	{
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Expected O, but got Unknown
		StringPool.Get(name);
		StripEmptyChildren stripEmptyChildren = default(StripEmptyChildren);
		bool flag = go.TryGetComponent<StripEmptyChildren>(ref stripEmptyChildren) && Render.IsInstancingEnabled;
		if (options.StripComponents)
		{
			if (!isClientside)
			{
				Type[] array = clientsideOnlyTypes;
				foreach (Type t in array)
				{
					DestroyComponents(t, go, isClientside, isServerside);
				}
				foreach (IClientComponentEx item in FindIComponents<IClientComponentEx>(go.transform))
				{
					item.PreClientComponentCull((IPrefabProcessor)(object)this);
				}
			}
			if (!isServerside)
			{
				Type[] array = serversideOnlyTypes;
				foreach (Type t2 in array)
				{
					DestroyComponents(t2, go, isClientside, isServerside);
				}
				foreach (IServerComponentEx item2 in FindIComponents<IServerComponentEx>(go.transform))
				{
					item2.PreServerComponentCull((IPrefabProcessor)(object)this);
				}
			}
			DestroyComponents(typeof(IEditorComponent), go, isClientside, isServerside);
		}
		if (options.ResetLocalTransform)
		{
			go.transform.localPosition = Vector3.zero;
			go.transform.localRotation = Quaternion.identity;
		}
		List<Transform> list = this.FindComponents<Transform>(go.transform);
		list.Reverse();
		if (options.UpdateMeshCooking)
		{
			MeshColliderCookingOptions val = (MeshColliderCookingOptions)14;
			MeshColliderCookingOptions cookingOptions = (MeshColliderCookingOptions)30;
			MeshColliderCookingOptions val2 = (MeshColliderCookingOptions)(-1);
			foreach (MeshCollider item3 in this.FindComponents<MeshCollider>(go.transform))
			{
				if (item3.cookingOptions == val || item3.cookingOptions == val2)
				{
					item3.cookingOptions = cookingOptions;
				}
			}
		}
		if (options.PreProcess)
		{
			foreach (IPrefabPreProcess item4 in FindIComponents<IPrefabPreProcess>(go.transform))
			{
				if (!isBundling || item4.CanRunDuringBundling)
				{
					item4.PreProcess((IPrefabProcessor)(object)this, go, name, isServerside, isClientside, isBundling);
					MarkPropertiesDirty((Object)item4);
				}
			}
		}
		if (options.StripEmptyChildren)
		{
			BaseEntity baseEntity = default(BaseEntity);
			foreach (Transform item5 in list)
			{
				if (!Object.op_Implicit((Object)(object)item5) || !Object.op_Implicit((Object)(object)((Component)item5).gameObject))
				{
					continue;
				}
				if (isServerside && ((Component)item5).gameObject.CompareTag("Server Cull"))
				{
					RemoveComponents(((Component)item5).gameObject);
					NominateForDeletion(((Component)item5).gameObject);
				}
				if (isClientside)
				{
					bool num = ((Component)item5).gameObject.CompareTag("Client Cull");
					bool flag2 = (Object)(object)item5 != (Object)(object)go.transform && ((Component)item5).gameObject.TryGetComponent<BaseEntity>(ref baseEntity);
					if (num || flag2)
					{
						RemoveComponents(((Component)item5).gameObject);
						NominateForDeletion(((Component)item5).gameObject);
					}
					else if (flag)
					{
						NominateForDeletion(((Component)item5).gameObject);
					}
				}
			}
		}
		RunCleanupQueue();
		if (!options.PostProcess)
		{
			return;
		}
		foreach (IPrefabPostProcess item6 in FindIComponents<IPrefabPostProcess>(go.transform))
		{
			item6.PostProcess((IPrefabProcessor)(object)this, go, name, isServerside, isClientside, isBundling);
		}
	}

	public void Process(string name, GameObject go)
	{
		PreProcessPrefabOptions assetSceneRuntime = PreProcessPrefabOptions.AssetSceneRuntime;
		if (Application.isPlaying && !go.CompareTag("NoPreProcessing"))
		{
			if (NeedsProcessing(go, assetSceneRuntime))
			{
				ProcessObject(name, go, assetSceneRuntime);
			}
			AddPrefab(name, go);
		}
	}

	public void Invalidate(string name)
	{
		if (prefabList.TryGetValue(name, out var value))
		{
			prefabList.Remove(name);
			if ((Object)(object)value != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)value, true);
			}
		}
	}

	public void InvalidateAll()
	{
		foreach (var (_, val2) in prefabList)
		{
			if ((Object)(object)val2 != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)val2, true);
			}
		}
		prefabList.Clear();
	}

	public GameObject GetHierarchyGroup()
	{
		if (isClientside && isServerside)
		{
			return HierarchyUtil.GetRoot("PrefabPreProcess - Generic", groupActive: false, persistant: true);
		}
		if (isServerside)
		{
			return HierarchyUtil.GetRoot("PrefabPreProcess - Server", groupActive: false, persistant: true);
		}
		return HierarchyUtil.GetRoot("PrefabPreProcess - Client", groupActive: false, persistant: true);
	}

	public void AddPrefab(string name, GameObject go)
	{
		go.SetActive(false);
		prefabList.Add(name, go);
	}

	private void DestroyComponents(Type t, GameObject go, bool client, bool server)
	{
		List<Component> list = new List<Component>();
		FindComponents(go.transform, list, t);
		list.Reverse();
		RealmedRemove realmedRemove = default(RealmedRemove);
		foreach (Component item in list)
		{
			if (!item.TryGetComponent<RealmedRemove>(ref realmedRemove) || realmedRemove.ShouldDelete(item, client, server))
			{
				if (!item.gameObject.CompareTag("persist"))
				{
					NominateForDeletion(item.gameObject);
				}
				Object.DestroyImmediate((Object)(object)item, true);
			}
		}
	}

	private bool ShouldExclude(Transform transform)
	{
		BaseEntity baseEntity = default(BaseEntity);
		if (((Component)transform).TryGetComponent<BaseEntity>(ref baseEntity))
		{
			return true;
		}
		return false;
	}

	private void GatherExcludedTransf(Transform root, HashSet<Transform> excludeSet)
	{
		List<BaseEntity> list = new List<BaseEntity>();
		((Component)root).GetComponentsInChildren<BaseEntity>(true, list);
		int i = 0;
		if (list.Count > 0 && (Object)(object)((Component)list[0]).transform == (Object)(object)root)
		{
			i = 1;
		}
		for (; i < list.Count; i++)
		{
			ExcludeChildHierarchy(((Component)list[i]).transform, excludeSet);
		}
		static void ExcludeChildHierarchy(Transform transf, HashSet<Transform> set)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Expected O, but got Unknown
			set.Add(transf);
			foreach (Transform item in transf)
			{
				ExcludeChildHierarchy(item, set);
			}
		}
	}

	private bool HasComponents<T>(Transform transform)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		T val = default(T);
		if (((Component)transform).TryGetComponent<T>(ref val))
		{
			return true;
		}
		foreach (Transform item in transform)
		{
			Transform transform2 = item;
			if (!ShouldExclude(transform2) && HasComponents<T>(transform2))
			{
				return true;
			}
		}
		return false;
	}

	private bool HasComponents(Transform transform, Type t)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		Component val = default(Component);
		if (((Component)transform).TryGetComponent(t, ref val))
		{
			return true;
		}
		foreach (Transform item in transform)
		{
			Transform transform2 = item;
			if (!ShouldExclude(transform2) && HasComponents(transform2, t))
			{
				return true;
			}
		}
		return false;
	}

	public List<T> FindComponents<T>(Transform transform) where T : Component
	{
		List<T> list = new List<T>();
		FindComponents(transform, list);
		return list;
	}

	public void FindComponents<T>(Transform transform, List<T> list) where T : Component
	{
		List<T> list2 = new List<T>();
		((Component)transform).GetComponentsInChildren<T>(true, list2);
		HashSet<Transform> hashSet = new HashSet<Transform>();
		GatherExcludedTransf(transform, hashSet);
		try
		{
			foreach (T item in list2)
			{
				Transform transform2 = ((Component)item).transform;
				if (!hashSet.Contains(transform2))
				{
					list.Add(item);
				}
			}
		}
		catch
		{
			throw;
		}
	}

	public List<T> FindIComponents<T>(Transform transform)
	{
		List<T> list = new List<T>();
		FindIComponents(transform, list);
		return list;
	}

	public void FindIComponents<T>(Transform transform, List<T> list)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		list.AddRange(((Component)transform).GetComponents<T>());
		foreach (Transform item in transform)
		{
			Transform transform2 = item;
			if (!ShouldExclude(transform2))
			{
				FindIComponents(transform2, list);
			}
		}
	}

	public List<Component> FindComponents(Transform transform, Type t)
	{
		List<Component> list = new List<Component>();
		FindComponents(transform, list, t);
		return list;
	}

	public void FindComponents(Transform transform, List<Component> list, Type t)
	{
		Component[] componentsInChildren = ((Component)transform).GetComponentsInChildren(t, true);
		HashSet<Transform> hashSet = new HashSet<Transform>();
		GatherExcludedTransf(transform, hashSet);
		Component[] array = componentsInChildren;
		foreach (Component val in array)
		{
			Transform transform2 = val.transform;
			if (!hashSet.Contains(transform2))
			{
				list.Add(val);
			}
		}
	}

	public void RemoveComponent(Component c)
	{
		if (!((Object)(object)c == (Object)null))
		{
			destroyList.Add(c);
		}
	}

	public void RemoveComponents(GameObject gameObj)
	{
		Component[] components = gameObj.GetComponents<Component>();
		foreach (Component val in components)
		{
			if (!(val is Transform))
			{
				destroyList.Add(val);
			}
		}
	}

	public void NominateForDeletion(GameObject gameObj)
	{
		cleanupList.Add(gameObj);
	}

	public void MarkPropertiesDirty(Object obj)
	{
	}

	public void RunCleanupQueue()
	{
		foreach (Component destroy in destroyList)
		{
			Object.DestroyImmediate((Object)(object)destroy, true);
		}
		destroyList.Clear();
		foreach (GameObject cleanup in cleanupList)
		{
			DoCleanup(cleanup);
		}
		cleanupList.Clear();
	}

	public void DoCleanup(GameObject go)
	{
		if (!((Object)(object)go == (Object)null) && go.GetComponentsInChildren<Component>(true).Length <= 1)
		{
			Transform parent = go.transform.parent;
			if (!((Object)(object)parent == (Object)null) && !((Object)parent).name.StartsWith("PrefabPreProcess - "))
			{
				Object.DestroyImmediate((Object)(object)go, true);
			}
		}
	}
}


using System;
using ConVar;
using Rust;

public class PrefabWeight : PrefabAttribute
{
	public float Scale = 1f;

	public Era Era;

	protected override Type GetIndexedType()
	{
		return typeof(PrefabWeight);
	}

	public bool IsActiveInEra()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((int)Era != 0)
		{
			return Era == ConVar.Server.Era;
		}
		return true;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Armor Properties")]
public class ArmorProperties : ScriptableObject
{
	[InspectorFlags]
	public HitArea area;

	public bool Contains(HitArea hitArea)
	{
		return (area & hitArea) != 0;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Clothing Movement Properties")]
public class ClothingMovementProperties : ScriptableObject
{
	public float speedReduction;

	public float waterSpeedBonus;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Damage Properties")]
public class DamageProperties : ScriptableObject
{
	[Serializable]
	public class HitAreaProperty
	{
		public HitArea area = HitArea.Head;

		public float damage = 1f;
	}

	public DamageProperties fallback;

	[Horizontal(1, 0)]
	public HitAreaProperty[] bones;

	public float GetMultiplier(HitArea area)
	{
		for (int i = 0; i < bones.Length; i++)
		{
			HitAreaProperty hitAreaProperty = bones[i];
			if (hitAreaProperty.area == area)
			{
				return hitAreaProperty.damage;
			}
		}
		if (!Object.op_Implicit((Object)(object)fallback))
		{
			return 1f;
		}
		return fallback.GetMultiplier(area);
	}

	public void ScaleDamage(HitInfo info)
	{
		HitArea boneArea = info.boneArea;
		if (boneArea != (HitArea)(-1) && boneArea != 0)
		{
			info.damageTypes.ScaleAll(GetMultiplier(boneArea));
		}
	}
}


using System;

[Serializable]
public class HitAreaProperty
{
	public HitArea area = HitArea.Head;

	public float damage = 1f;
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/LazyAim Properties")]
public class LazyAimProperties : ScriptableObject
{
	[Range(0f, 10f)]
	public float snapStrength = 6f;

	[Range(0f, 45f)]
	public float deadzoneAngle = 1f;
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Skeleton Properties")]
public class SkeletonProperties : ScriptableObject
{
	[Serializable]
	public class BoneProperty
	{
		public GameObject bone;

		public Phrase name;

		public HitArea area;
	}

	public GameObject boneReference;

	[BoneProperty]
	public BoneProperty[] bones;

	[NonSerialized]
	private Dictionary<uint, BoneProperty> quickLookup;

	public void OnValidate()
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Expected O, but got Unknown
		if ((Object)(object)boneReference == (Object)null)
		{
			Debug.LogWarning((object)("boneReference is null on " + ((Object)this).name), (Object)(object)this);
			return;
		}
		List<BoneProperty> list = bones.ToList();
		foreach (Transform child in boneReference.transform.GetAllChildren())
		{
			if (list.All((BoneProperty x) => (Object)(object)x.bone != (Object)(object)((Component)child).gameObject))
			{
				list.Add(new BoneProperty
				{
					bone = ((Component)child).gameObject,
					name = new Phrase("", "")
					{
						token = ((Object)child).name.ToLower(),
						english = ((Object)child).name.ToLower()
					}
				});
			}
		}
		bones = list.ToArray();
	}

	private void BuildDictionary()
	{
		quickLookup = new Dictionary<uint, BoneProperty>();
		if ((Object)(object)boneReference == (Object)null)
		{
			Debug.LogWarning((object)("boneReference is null on " + ((Object)this).name), (Object)(object)this);
			return;
		}
		BoneProperty[] array = bones;
		foreach (BoneProperty boneProperty in array)
		{
			if (boneProperty == null || (Object)(object)boneProperty.bone == (Object)null || ((Object)boneProperty.bone).name == null)
			{
				Debug.LogWarning((object)("Bone error in SkeletonProperties.BuildDictionary for " + ((Object)boneReference).name));
				continue;
			}
			uint key = StringPool.Get(((Object)boneProperty.bone).name);
			if (!quickLookup.ContainsKey(key))
			{
				quickLookup.Add(key, boneProperty);
				continue;
			}
			string name = ((Object)boneProperty.bone).name;
			string name2 = ((Object)quickLookup[key].bone).name;
			Debug.LogWarning((object)("Duplicate bone id " + key + " for " + name + " and " + name2));
		}
	}

	public BoneProperty FindBone(uint id)
	{
		if (quickLookup == null)
		{
			BuildDictionary();
		}
		BoneProperty value = null;
		if (!quickLookup.TryGetValue(id, out value))
		{
			return null;
		}
		return value;
	}
}


using System;
using UnityEngine;

[Serializable]
public class BoneProperty
{
	public GameObject bone;

	public Phrase name;

	public HitArea area;
}


using UnityEngine;

public class BonePropertyAttribute : PropertyAttribute
{
}


using UnityEngine;

public static class Radiation
{
	public enum Tier
	{
		MINIMAL,
		LOW,
		MEDIUM,
		HIGH,
		NONE
	}

	[ServerVar]
	public static bool water_loot_damage = true;

	[ServerVar]
	public static bool water_inventory_damage = true;

	public static float MaterialToRadsRatio = 0.0044f;

	[ServerVar]
	public static float materialToRadsRatio
	{
		get
		{
			return MaterialToRadsRatio;
		}
		set
		{
			MaterialToRadsRatio = value;
		}
	}

	public static float MaxExposureProtection => 0.5f;

	public static float GetRadiation(Tier tier)
	{
		return tier switch
		{
			Tier.NONE => 0f, 
			Tier.MINIMAL => 2f, 
			Tier.LOW => 10f, 
			Tier.MEDIUM => 25f, 
			Tier.HIGH => 51f, 
			_ => 1f, 
		};
	}

	public static float GetRadiationAfterProtection(float radiationAmount, float radiationProtection)
	{
		return Mathf.Clamp(radiationAmount - radiationProtection, 0f, radiationAmount);
	}
}


public enum Tier
{
	MINIMAL,
	LOW,
	MEDIUM,
	HIGH,
	NONE
}


using ConVar;
using UnityEngine;

public class RealmedCollider : BasePrefab
{
	public Collider ServerCollider;

	public Collider ClientCollider;

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(process, rootObj, name, serverside, clientside, bundling);
		if (serverside && (Object)(object)ServerCollider != (Object)(object)ClientCollider)
		{
			if (Tree.simplified_collider)
			{
				if (Object.op_Implicit((Object)(object)ClientCollider))
				{
					process.RemoveComponent((Component)(object)ClientCollider);
					ClientCollider = ServerCollider;
				}
			}
			else if (Object.op_Implicit((Object)(object)ServerCollider))
			{
				process.RemoveComponent((Component)(object)ServerCollider);
				ServerCollider = ClientCollider;
			}
		}
		process.RemoveComponent((Component)(object)this);
	}
}


using System.Linq;
using UnityEngine;

public class RealmedRemove : MonoBehaviour, IPrefabPreProcess
{
	public GameObject[] removedFromClient;

	public Component[] removedComponentFromClient;

	public GameObject[] removedFromServer;

	public Component[] removedComponentFromServer;

	public Component[] doNotRemoveFromServer;

	public Component[] doNotRemoveFromClient;

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (clientside)
		{
			GameObject[] array = removedFromClient;
			for (int i = 0; i < array.Length; i++)
			{
				Object.DestroyImmediate((Object)(object)array[i], true);
			}
			Component[] array2 = removedComponentFromClient;
			for (int i = 0; i < array2.Length; i++)
			{
				Object.DestroyImmediate((Object)(object)array2[i], true);
			}
		}
		if (serverside)
		{
			GameObject[] array = removedFromServer;
			for (int i = 0; i < array.Length; i++)
			{
				Object.DestroyImmediate((Object)(object)array[i], true);
			}
			Component[] array2 = removedComponentFromServer;
			for (int i = 0; i < array2.Length; i++)
			{
				Object.DestroyImmediate((Object)(object)array2[i], true);
			}
		}
		process.RemoveComponent((Component)(object)this);
	}

	public bool ShouldDelete(Component comp, bool client, bool server)
	{
		if (client && doNotRemoveFromClient != null && doNotRemoveFromClient.Contains(comp))
		{
			return false;
		}
		if (server && doNotRemoveFromServer != null && doNotRemoveFromServer.Contains(comp))
		{
			return false;
		}
		return true;
	}
}


using System;
using UnityEngine;

public class RepositionOnGroundMissing : EntityComponent<BaseEntity>, IServerComponent
{
	public GameObjectRef originalPrefab;

	public bool killIfInvalid;

	public LayerMask castLayers = LayerMask.op_Implicit(10551552);

	private void OnGroundMissing()
	{
		((FacepunchBehaviour)this).Invoke((Action)Process, 0.1f);
	}

	private void Process()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
		if (!((Object)(object)baseEntity == (Object)null))
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			Vector3 position = ((Component)baseCombatEntity).transform.position;
			Quaternion rotation = ((Component)baseCombatEntity).transform.rotation;
			if (GamePhysics.Trace(new Ray(((Component)this).transform.position, Vector3.down), 0f, out var hitInfo, 100f, LayerMask.op_Implicit(castLayers), (QueryTriggerInteraction)0))
			{
				position = ((RaycastHit)(ref hitInfo)).point;
				rotation = Quaternion.FromToRotation(((Component)baseEntity).transform.up, ((RaycastHit)(ref hitInfo)).normal) * ((Component)baseCombatEntity).transform.rotation;
			}
			else
			{
				float height = TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position);
				Vector3 normal = TerrainMeta.HeightMap.GetNormal(((Component)this).transform.position);
				position = Vector3Ex.WithY(baseEntity.ServerPosition, height);
				rotation = Quaternion.LookRotation(((Component)baseEntity).transform.forward, normal);
			}
			uint prefabID = (originalPrefab.isValid ? originalPrefab.resourceID : baseEntity.prefabID);
			if (baseEntity is ContainerCorpse containerCorpse)
			{
				prefabID = containerCorpse.entityToSpawn.resourceID;
			}
			if (!ContainerCorpse.IsValidPointForEntity(prefabID, position, rotation, baseEntity) && killIfInvalid)
			{
				Debug.LogWarning((object)$"Killing {baseCombatEntity.ShortPrefabName} instead of repositioning as we couldn't find a valid position for {position}");
				baseCombatEntity.Kill();
			}
			else
			{
				baseEntity.ServerPosition = position;
				baseEntity.ServerRotation = rotation;
				baseEntity.SendNetworkUpdate();
			}
		}
	}
}


using UnityEngine;

public class RiverInfo : MonoBehaviour
{
	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.RiverObjs.Add(this);
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Facepunch.Rust;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using ProtoBuf;
using Rust;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;
using UnityEngine.Assertions;

public class SaveRestore : SingletonComponent<SaveRestore>
{
	[JsonModel]
	public class SaveExtraData
	{
		public string WipeId;
	}

	[CompilerGenerated]
	private sealed class <DoAutomatedSave>d__20 : IEnumerator<object>, IEnumerator, IDisposable
	{
		private int <>1__state;

		private object <>2__current;

		public bool AndWait;

		public SaveRestore <>4__this;

		private string <folder>5__2;

		object IEnumerator<object>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <DoAutomatedSave>d__20(int <>1__state)
		{
			this.<>1__state = <>1__state;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
		}

		private bool MoveNext()
		{
			int num = <>1__state;
			SaveRestore saveRestore = <>4__this;
			switch (num)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				IsSaving = true;
				<folder>5__2 = ConVar.Server.rootFolder;
				if (!AndWait)
				{
					<>2__current = CoroutineEx.waitForEndOfFrame;
					<>1__state = 1;
					return true;
				}
				goto IL_0061;
			case 1:
				<>1__state = -1;
				goto IL_0061;
			case 2:
				<>1__state = -1;
				goto IL_00d0;
			case 3:
				{
					<>1__state = -1;
					break;
				}
				IL_0061:
				if (AndWait)
				{
					IEnumerator enumerator = Save(<folder>5__2 + "/" + World.SaveFileName, AndWait);
					while (enumerator.MoveNext())
					{
					}
					goto IL_00d0;
				}
				<>2__current = ((MonoBehaviour)saveRestore).StartCoroutine(Save(<folder>5__2 + "/" + World.SaveFileName, AndWait));
				<>1__state = 2;
				return true;
				IL_00d0:
				if (!AndWait)
				{
					<>2__current = CoroutineEx.waitForEndOfFrame;
					<>1__state = 3;
					return true;
				}
				break;
			}
			Debug.Log((object)"Saving complete");
			IsSaving = false;
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}
	}

	public static bool IsSaving = false;

	public static DateTime SaveCreatedTime;

	private static RealTimeSince TimeSinceLastSave;

	private static MemoryStream SaveBuffer = new MemoryStream(33554432);

	private static Action<Stream> onSaveComplete;

	private static object callbackLock = new object();

	private static Queue<Stream> saveQueue = new Queue<Stream>();

	private static object saveQueueLock = new object();

	public static string WipeId { get; private set; }

	public static void AddOnSaveCallback(Action<Stream> callback)
	{
		lock (callbackLock)
		{
			onSaveComplete = (Action<Stream>)Delegate.Combine(onSaveComplete, callback);
		}
	}

	public static void RemoveOnSaveCallback(Action<Stream> callback)
	{
		lock (callbackLock)
		{
			onSaveComplete = (Action<Stream>)Delegate.Remove(onSaveComplete, callback);
		}
	}

	public static IEnumerator Save(string strFilename, bool AndWait = false)
	{
		if (Application.isQuitting)
		{
			yield break;
		}
		Stopwatch timerCache = new Stopwatch();
		Stopwatch timerWrite = new Stopwatch();
		Stopwatch timerDisk = new Stopwatch();
		SaveBuffer.Position = 0L;
		SaveBuffer.SetLength(0L);
		InitializeWipeId();
		if (AndWait)
		{
			IEnumerator enumerator = WarmUpEntityCaches(AndWait, timerCache);
			while (enumerator.MoveNext())
			{
			}
		}
		else
		{
			yield return ((MonoBehaviour)SingletonComponent<SaveRestore>.Instance).StartCoroutine(WarmUpEntityCaches(AndWait, timerCache));
		}
		timerWrite.Start();
		int iEnts = 0;
		TimeWarning val = TimeWarning.New("SaveWrite", 100);
		try
		{
			BinaryWriter writer = new BinaryWriter(SaveBuffer);
			WriteHeader(writer);
			if (!AndWait)
			{
				yield return CoroutineEx.waitForEndOfFrame;
			}
			iEnts = WriteEntities(writer);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		timerWrite.Stop();
		if (!AndWait)
		{
			yield return CoroutineEx.waitForEndOfFrame;
		}
		timerDisk.Start();
		TimeWarning val2 = TimeWarning.New("SaveBackup", 100);
		try
		{
			ShiftSaveBackups(strFilename);
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
		val2 = TimeWarning.New("SaveDisk", 100);
		try
		{
			string text = strFilename + ".new";
			if (File.Exists(text))
			{
				File.Delete(text);
			}
			try
			{
				using FileStream destination = File.OpenWrite(text);
				SaveBuffer.Position = 0L;
				SaveBuffer.CopyTo(destination);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)("Couldn't write save file! We got an exception: " + ex));
				if (File.Exists(text))
				{
					File.Delete(text);
				}
				yield break;
			}
			File.Copy(text, strFilename, overwrite: true);
			File.Delete(text);
		}
		catch (Exception ex2)
		{
			Debug.LogError((object)("Error when saving to disk: " + ex2));
			yield break;
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
		timerDisk.Stop();
		Debug.LogFormat("Saved {0} ents, cache({1}), write({2}), disk({3}).", new object[4]
		{
			iEnts.ToString("N0"),
			timerCache.Elapsed.TotalSeconds.ToString("0.00"),
			timerWrite.Elapsed.TotalSeconds.ToString("0.00"),
			timerDisk.Elapsed.TotalSeconds.ToString("0.00")
		});
		PerformanceLogging.server?.SetTiming("save.cache", timerCache.Elapsed);
		PerformanceLogging.server?.SetTiming("save.write", timerWrite.Elapsed);
		PerformanceLogging.server?.SetTiming("save.disk", timerDisk.Elapsed);
		NexusServer.PostGameSaved();
	}

	private static IEnumerator SaveToStream(Stream stream)
	{
		InitializeWipeId();
		yield return ((MonoBehaviour)SingletonComponent<SaveRestore>.Instance).StartCoroutine(WarmUpEntityCaches());
		TimeWarning val = TimeWarning.New("SaveWrite", 100);
		try
		{
			BinaryWriter writer = new BinaryWriter(stream);
			WriteHeader(writer);
			yield return CoroutineEx.waitForEndOfFrame;
			WriteEntities(writer);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		Action<Stream> action;
		lock (callbackLock)
		{
			action = onSaveComplete;
		}
		action(stream);
	}

	private static void ShiftSaveBackups(string fileName)
	{
		int num = Mathf.Max(ConVar.Server.saveBackupCount, 2);
		if (!File.Exists(fileName))
		{
			return;
		}
		try
		{
			int num2 = 0;
			for (int j = 1; j <= num; j++)
			{
				if (!File.Exists(fileName + "." + j))
				{
					break;
				}
				num2++;
			}
			string text = GetBackupName(num2 + 1);
			for (int num3 = num2; num3 > 0; num3--)
			{
				string text2 = GetBackupName(num3);
				if (num3 == num)
				{
					File.Delete(text2);
				}
				else if (File.Exists(text2))
				{
					if (File.Exists(text))
					{
						File.Delete(text);
					}
					File.Move(text2, text);
				}
				text = text2;
			}
			File.Copy(fileName, text, overwrite: true);
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Error while backing up old saves: " + ex.Message));
			Debug.LogException(ex);
			throw;
		}
		string GetBackupName(int i)
		{
			return $"{fileName}.{i}";
		}
	}

	private void Start()
	{
		((MonoBehaviour)this).StartCoroutine(SaveRegularly());
		((MonoBehaviour)this).StartCoroutine(ProcessStreamRequests());
	}

	private IEnumerator SaveRegularly()
	{
		while (true)
		{
			yield return CoroutineEx.waitForSeconds(1f);
			if (RealTimeSince.op_Implicit(TimeSinceLastSave) >= (float)ConVar.Server.saveinterval || NexusServer.NeedsJournalFlush || NexusServer.NeedTransferFlush)
			{
				yield return ((MonoBehaviour)this).StartCoroutine(DoAutomatedSave());
				TimeSinceLastSave = RealTimeSince.op_Implicit(0f);
			}
		}
	}

	private IEnumerator ProcessStreamRequests()
	{
		while (true)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			bool flag = false;
			Stream result = null;
			lock (saveQueueLock)
			{
				flag = saveQueue.TryDequeue(out result);
			}
			if (flag)
			{
				((MonoBehaviour)this).StartCoroutine(SaveToStream(result));
			}
		}
	}

	[IteratorStateMachine(typeof(<DoAutomatedSave>d__20))]
	private IEnumerator DoAutomatedSave(bool AndWait = false)
	{
		Interface.CallHook("OnServerSave");
		return new <DoAutomatedSave>d__20(0)
		{
			<>4__this = this,
			AndWait = AndWait
		};
	}

	public static bool Save(bool AndWait)
	{
		if ((Object)(object)SingletonComponent<SaveRestore>.Instance == (Object)null)
		{
			return false;
		}
		if (IsSaving)
		{
			return false;
		}
		IEnumerator enumerator = SingletonComponent<SaveRestore>.Instance.DoAutomatedSave(AndWait: true);
		while (enumerator.MoveNext())
		{
		}
		return true;
	}

	public static void RequestSave(Stream stream)
	{
		lock (saveQueueLock)
		{
			saveQueue.Enqueue(stream);
		}
	}

	private static IEnumerator WarmUpEntityCaches(bool isBlocking = false, Stopwatch cacheTimer = null)
	{
		cacheTimer?.Start();
		TimeWarning val = TimeWarning.New("SaveCache", 100);
		try
		{
			Stopwatch sw = Stopwatch.StartNew();
			BaseEntity[] array = BaseEntity.saveList.ToArray();
			foreach (BaseEntity baseEntity in array)
			{
				if ((Object)(object)baseEntity == (Object)null || !baseEntity.IsValid())
				{
					continue;
				}
				try
				{
					baseEntity.GetSaveCache();
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
				}
				if (sw.Elapsed.TotalMilliseconds > (double)ConVar.Server.saveframebudget)
				{
					if (!isBlocking)
					{
						yield return CoroutineEx.waitForEndOfFrame;
					}
					sw.Reset();
					sw.Start();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		cacheTimer?.Stop();
	}

	private static void WriteHeader(BinaryWriter writer)
	{
		writer.Write((sbyte)83);
		writer.Write((sbyte)65);
		writer.Write((sbyte)86);
		writer.Write((sbyte)82);
		SaveExtraData saveExtraData = new SaveExtraData();
		saveExtraData.WipeId = WipeId;
		writer.Write((sbyte)74);
		writer.Write(JsonConvert.SerializeObject((object)saveExtraData));
		writer.Write((sbyte)68);
		writer.Write(Epoch.FromDateTime(SaveCreatedTime));
		writer.Write(270u);
	}

	private static int WriteEntities(BinaryWriter writer)
	{
		int num = 0;
		foreach (BaseEntity save in BaseEntity.saveList)
		{
			if ((Object)(object)save == (Object)null || save.IsDestroyed)
			{
				Debug.LogWarning((object)("Entity is NULL but is still in saveList - not destroyed properly? " + (object)save), (Object)(object)save);
				continue;
			}
			MemoryStream memoryStream = null;
			try
			{
				memoryStream = save.GetSaveCache();
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			if (memoryStream == null || memoryStream.Length <= 0)
			{
				Debug.LogWarningFormat("Skipping saving entity {0} - because {1}", new object[2]
				{
					save,
					(memoryStream == null) ? "savecache is null" : "savecache is 0"
				});
			}
			else
			{
				writer.Write((uint)memoryStream.Length);
				writer.Write(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
				num++;
			}
		}
		return num;
	}

	public static List<BaseEntity> FindMapEntities()
	{
		return new List<BaseEntity>(Object.FindObjectsOfType<BaseEntity>());
	}

	public static void ClearMapEntities(List<BaseEntity> entities)
	{
		int count = entities.Count;
		DebugEx.Log((object)("Destroying " + count + " old entities"), (StackTraceLogType)0);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int num = count - 1; num >= 0; num--)
		{
			BaseEntity baseEntity = entities[num];
			if (baseEntity.enableSaving || !((Object)(object)((Component)baseEntity).GetComponent<DisableSave>() != (Object)null))
			{
				baseEntity.KillAsMapEntity();
				if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
				{
					stopwatch.Reset();
					stopwatch.Start();
					DebugEx.Log((object)("\t" + (count - num) + " / " + count), (StackTraceLogType)0);
				}
				entities.RemoveAt(num);
			}
		}
		ItemManager.Heartbeat();
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static void SpawnMapEntities(List<BaseEntity> entities)
	{
		DebugEx.Log((object)("Spawning " + entities.Count + " entities from map"), (StackTraceLogType)0);
		foreach (BaseEntity entity in entities)
		{
			if (!((Object)(object)entity == (Object)null))
			{
				entity.SpawnAsMapEntity();
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
		DebugEx.Log((object)("Postprocessing " + entities.Count + " entities from map"), (StackTraceLogType)0);
		foreach (BaseEntity entity2 in entities)
		{
			if (!((Object)(object)entity2 == (Object)null))
			{
				entity2.PostMapEntitySpawn();
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static bool Load(string strFilename = "", bool allowOutOfDateSaves = false)
	{
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_0306: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		SaveCreatedTime = DateTime.UtcNow;
		try
		{
			if (strFilename == "")
			{
				strFilename = World.SaveFolderName + "/" + World.SaveFileName;
			}
			if (!File.Exists(strFilename))
			{
				Interface.CallHook("OnNewSave", (object)strFilename);
				if (!File.Exists("TestSaves/" + strFilename))
				{
					Debug.LogWarning((object)("Couldn't load " + strFilename + " - file doesn't exist"));
					return false;
				}
				strFilename = "TestSaves/" + strFilename;
			}
			List<BaseEntity> list = FindMapEntities();
			Dictionary<BaseEntity, Entity> dictionary = new Dictionary<BaseEntity, Entity>();
			using (FileStream fileStream = File.OpenRead(strFilename))
			{
				using BinaryReader binaryReader = new BinaryReader(fileStream);
				SaveCreatedTime = File.GetCreationTime(strFilename);
				if (binaryReader.ReadSByte() != 83 || binaryReader.ReadSByte() != 65 || binaryReader.ReadSByte() != 86 || binaryReader.ReadSByte() != 82)
				{
					Debug.LogWarning((object)"Invalid save (missing header)");
					return false;
				}
				if (binaryReader.PeekChar() == 74)
				{
					binaryReader.ReadChar();
					WipeId = JsonConvert.DeserializeObject<SaveExtraData>(binaryReader.ReadString()).WipeId;
				}
				if (binaryReader.PeekChar() == 68)
				{
					binaryReader.ReadChar();
					SaveCreatedTime = Epoch.ToDateTime((long)binaryReader.ReadInt32());
				}
				if (binaryReader.ReadUInt32() != 270)
				{
					if (allowOutOfDateSaves)
					{
						Debug.LogWarning((object)"This save is from an older (possibly incompatible) version!");
					}
					else
					{
						Debug.LogWarning((object)"This save is from an older version. It might not load properly.");
					}
				}
				ClearMapEntities(list);
				Assert.IsTrue(BaseEntity.saveList.Count == 0, "BaseEntity.saveList isn't empty!");
				Net.sv.Reset();
				Application.isLoadingSave = true;
				HashSet<NetworkableId> hashSet = new HashSet<NetworkableId>();
				while (fileStream.Position < fileStream.Length)
				{
					RCon.Update();
					uint num = binaryReader.ReadUInt32();
					long position = fileStream.Position;
					Entity entData = Pool.Get<Entity>();
					try
					{
						ProtoStreamExtensions.ReadFromStream((IProto)(object)entData, (Stream)fileStream, (int)num, false);
					}
					catch (Exception ex)
					{
						Debug.LogWarning((object)("Skipping entity since it could not be deserialized - stream position: " + position + " size: " + num));
						Debug.LogException(ex);
						fileStream.Position = position + num;
						Pool.Free<Entity>(ref entData);
						continue;
					}
					NetworkableId uid;
					if (entData.basePlayer != null && dictionary.Any((KeyValuePair<BaseEntity, Entity> x) => x.Value.basePlayer != null && x.Value.basePlayer.userid == entData.basePlayer.userid))
					{
						string[] obj = new string[5] { "Skipping entity ", null, null, null, null };
						uid = entData.baseNetworkable.uid;
						obj[1] = ((object)(NetworkableId)(ref uid)/*cast due to .constrained prefix*/).ToString();
						obj[2] = " - it's a player ";
						obj[3] = entData.basePlayer.userid.ToString();
						obj[4] = " who is in the save multiple times";
						Debug.LogWarning((object)string.Concat(obj));
						Pool.Free<Entity>(ref entData);
					}
					else if (((NetworkableId)(ref entData.baseNetworkable.uid)).IsValid && hashSet.Contains(entData.baseNetworkable.uid))
					{
						string[] obj2 = new string[5] { "Skipping entity ", null, null, null, null };
						uid = entData.baseNetworkable.uid;
						obj2[1] = ((object)(NetworkableId)(ref uid)/*cast due to .constrained prefix*/).ToString();
						obj2[2] = " ";
						obj2[3] = StringPool.Get(entData.baseNetworkable.prefabID);
						obj2[4] = " - uid is used multiple times";
						Debug.LogWarning((object)string.Concat(obj2));
						Pool.Free<Entity>(ref entData);
					}
					else
					{
						if (((NetworkableId)(ref entData.baseNetworkable.uid)).IsValid)
						{
							hashSet.Add(entData.baseNetworkable.uid);
						}
						BaseEntity baseEntity = GameManager.server.CreateEntity(StringPool.Get(entData.baseNetworkable.prefabID), entData.baseEntity.pos, Quaternion.Euler(entData.baseEntity.rot));
						if (Object.op_Implicit((Object)(object)baseEntity))
						{
							baseEntity.InitLoad(entData.baseNetworkable.uid);
							baseEntity.PreServerLoad();
							dictionary.Add(baseEntity, entData);
						}
					}
				}
			}
			DebugEx.Log((object)("Spawning " + list.Count + " entities from map"), (StackTraceLogType)0);
			foreach (BaseEntity item in list)
			{
				if (!((Object)(object)item == (Object)null))
				{
					item.SpawnAsMapEntity();
				}
			}
			DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
			DebugEx.Log((object)("Spawning " + dictionary.Count + " entities from save"), (StackTraceLogType)0);
			object obj3 = Interface.CallHook("OnSaveLoad", (object)dictionary);
			if (obj3 is bool)
			{
				return (bool)obj3;
			}
			BaseNetworkable.LoadInfo info = default(BaseNetworkable.LoadInfo);
			info.fromDisk = true;
			Stopwatch stopwatch = Stopwatch.StartNew();
			int num2 = 0;
			foreach (KeyValuePair<BaseEntity, Entity> item2 in dictionary)
			{
				BaseEntity key = item2.Key;
				if ((Object)(object)key == (Object)null)
				{
					continue;
				}
				RCon.Update();
				info.msg = item2.Value;
				key.Spawn();
				key.Load(info);
				if (key.IsValid())
				{
					num2++;
					if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
					{
						stopwatch.Reset();
						stopwatch.Start();
						DebugEx.Log((object)("\t" + num2 + " / " + dictionary.Count), (StackTraceLogType)0);
					}
				}
			}
			DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
			DebugEx.Log((object)("Postprocessing " + list.Count + " entities from map"), (StackTraceLogType)0);
			foreach (BaseEntity item3 in list)
			{
				if (!((Object)(object)item3 == (Object)null))
				{
					item3.PostMapEntitySpawn();
				}
			}
			DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
			DebugEx.Log((object)("Postprocessing " + list.Count + " entities from save"), (StackTraceLogType)0);
			foreach (KeyValuePair<BaseEntity, Entity> item4 in dictionary)
			{
				BaseEntity key2 = item4.Key;
				if (!((Object)(object)key2 == (Object)null))
				{
					RCon.Update();
					if (key2.IsValid())
					{
						key2.UpdateNetworkGroup();
						key2.PostServerLoad();
					}
				}
			}
			DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
			foreach (KeyValuePair<BaseEntity, Entity> item5 in dictionary)
			{
				Entity value = item5.Value;
				Pool.Free<Entity>(ref value);
			}
			dictionary.Clear();
			if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
			{
				DebugEx.Log((object)"Enforcing SpawnPopulation Limits", (StackTraceLogType)0);
				SingletonComponent<SpawnHandler>.Instance.EnforceLimits();
				DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
			}
			InitializeWipeId();
			Application.isLoadingSave = false;
			return true;
		}
		catch (Exception ex2)
		{
			Debug.LogWarning((object)("Error loading save (" + strFilename + ")"));
			Debug.LogException(ex2);
			return false;
		}
	}

	public static void GetSaveCache()
	{
		BaseEntity[] array = BaseEntity.saveList.ToArray();
		if (array.Length == 0)
		{
			return;
		}
		DebugEx.Log((object)("Initializing " + array.Length + " entity save caches"), (StackTraceLogType)0);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			BaseEntity baseEntity = array[i];
			if (baseEntity.IsValid())
			{
				baseEntity.GetSaveCache();
				if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
				{
					stopwatch.Reset();
					stopwatch.Start();
					DebugEx.Log((object)("\t" + (i + 1) + " / " + array.Length), (StackTraceLogType)0);
				}
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static void InitializeEntityLinks()
	{
		BaseEntity[] array = (from x in BaseNetworkable.serverEntities
			where x is BaseEntity
			select x as BaseEntity).ToArray();
		if (array.Length == 0)
		{
			return;
		}
		DebugEx.Log((object)("Initializing " + array.Length + " entity links"), (StackTraceLogType)0);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			RCon.Update();
			array[i].RefreshEntityLinks();
			if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
			{
				stopwatch.Reset();
				stopwatch.Start();
				DebugEx.Log((object)("\t" + (i + 1) + " / " + array.Length), (StackTraceLogType)0);
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static void InitializeEntitySupports()
	{
		if (!ConVar.Server.stability)
		{
			return;
		}
		StabilityEntity[] array = (from x in BaseNetworkable.serverEntities
			where x is StabilityEntity
			select x as StabilityEntity).ToArray();
		if (array.Length == 0)
		{
			return;
		}
		DebugEx.Log((object)("Initializing " + array.Length + " stability supports"), (StackTraceLogType)0);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			RCon.Update();
			array[i].InitializeSupports();
			if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
			{
				stopwatch.Reset();
				stopwatch.Start();
				DebugEx.Log((object)("\t" + (i + 1) + " / " + array.Length), (StackTraceLogType)0);
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static void InitializeEntityConditionals()
	{
		BuildingBlock[] array = (from x in BaseNetworkable.serverEntities
			where x is BuildingBlock
			select x as BuildingBlock).ToArray();
		if (array.Length == 0)
		{
			return;
		}
		DebugEx.Log((object)("Initializing " + array.Length + " conditional models"), (StackTraceLogType)0);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			RCon.Update();
			array[i].UpdateSkin(force: true);
			if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
			{
				stopwatch.Reset();
				stopwatch.Start();
				DebugEx.Log((object)("\t" + (i + 1) + " / " + array.Length), (StackTraceLogType)0);
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static void InitializeWipeId()
	{
		if (WipeId == null)
		{
			WipeId = Guid.NewGuid().ToString("N");
		}
	}
}


[JsonModel]
public class SaveExtraData
{
	public string WipeId;
}


using UnityEngine;

public class SceneToPrefab : MonoBehaviour, IEditorComponent
{
	public bool flattenHierarchy;

	public GameObject outputPrefab;

	[Tooltip("If true the HLOD generation will be skipped and the previous results will be used, good to use if non-visual changes were made (eg.triggers)")]
	public bool skipAllHlod;
}


using UnityEngine;

public class SceneToPrefabTag : MonoBehaviour, IEditorComponent
{
	public enum TagType
	{
		ForceInclude,
		ForceExclude,
		SingleMaterial,
		UseSpecificLOD
	}

	public TagType Type;

	public int SpecificLOD;
}


public enum TagType
{
	ForceInclude,
	ForceExclude,
	SingleMaterial,
	UseSpecificLOD
}


using System;
using Facepunch;
using UnityEngine;
using UnityEngine.UI;

public class SkinViewer : FacepunchBehaviour
{
	[Serializable]
	public class SkinViewItem
	{
		public RawImage target;

		public ItemDefinition itemDef;

		public ulong skinID;
	}

	[SerializeField]
	private Camera cam;

	[SerializeField]
	private Transform positionParent;

	[SerializeField]
	private Transform modelParent;

	[SerializeField]
	private GameObject[] lights;

	[SerializeField]
	private SkinSetCollection skin;

	[SerializeField]
	private float rotateResetSpeed = 200f;

	[SerializeField]
	private float dragSpeed = 0.33f;

	[SerializeField]
	private bool autoSpin;

	[SerializeField]
	private float timeoutSeconds = 15f;

	[SerializeField]
	private Skeleton skinViewerSkeleton;
}


using System;
using UnityEngine.UI;

[Serializable]
public class SkinViewItem
{
	public RawImage target;

	public ItemDefinition itemDef;

	public ulong skinID;
}


using UnityEngine;

public class SkinViewerTesting : FacepunchBehaviour
{
	[SerializeField]
	private GameObjectRef skinViewerPrefab;

	[SerializeField]
	private SkinViewer.SkinViewItem[] panels;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class ConvarControlledSpawnPointPopulation : ConvarControlledSpawnPopulation
{
	public BaseSpawnPoint.SpawnPointType spawnPointType;

	[NonSerialized]
	private List<BaseSpawnPoint> spawnPoints;

	protected override bool Initialize()
	{
		TryGetSpawnPoints(out spawnPoints);
		return base.Initialize();
	}

	public override bool GetSpawnPosOverride(Prefab<Spawnable> prefab, ref Vector3 newPos, ref Quaternion newRot)
	{
		if (spawnPoints == null || spawnPoints.Count == 0)
		{
			return false;
		}
		int num = Random.Range(0, spawnPoints.Count);
		for (int i = 0; i < spawnPoints.Count; i++)
		{
			num++;
			if (num >= spawnPoints.Count)
			{
				num = 0;
			}
			BaseSpawnPoint baseSpawnPoint = spawnPoints[num];
			prefab = Prefabs[Random.Range(0, Prefabs.Length)];
			if ((Object)(object)baseSpawnPoint != (Object)null && baseSpawnPoint.IsAvailableTo(prefab.Object))
			{
				baseSpawnPoint.GetLocation(out newPos, out newRot);
				return true;
			}
		}
		return false;
	}

	private bool TryGetSpawnPoints(out List<BaseSpawnPoint> result)
	{
		return BaseSpawnPoint.spawnPoints.TryGetValue(spawnPointType, out result);
	}
}


using UnityEngine;
using UnityEngine.Assertions;

[CreateAssetMenu(menuName = "Rust/Convar Controlled Spawn Population")]
public class ConvarControlledSpawnPopulation : DensitySpawnPopulation
{
	[Header("Convars")]
	public string PopulationConvar;

	private Command _command;

	protected Command Command
	{
		get
		{
			if (_command == null)
			{
				_command = Server.Find(PopulationConvar);
				Assert.IsNotNull<Command>(_command, $"{this} has missing convar {PopulationConvar}");
			}
			return _command;
		}
	}

	public override float TargetDensity => Command.AsFloat;
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ConvarControlledSpawnPopulationRail : ConvarControlledSpawnPopulation
{
	private const float MIN_MARGIN = 75f;

	public override bool GetSpawnPosOverride(Prefab<Spawnable> prefab, ref Vector3 newPos, ref Quaternion newRot)
	{
		if (TrainTrackSpline.SidingSplines.Count <= 0)
		{
			return false;
		}
		TrainCar component = prefab.Object.GetComponent<TrainCar>();
		if ((Object)(object)component == (Object)null)
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": Train prefab has no TrainCar component: " + ((Object)prefab.Object).name));
			return false;
		}
		int num = 0;
		foreach (TrainTrackSpline sidingSpline in TrainTrackSpline.SidingSplines)
		{
			if (sidingSpline.HasAnyUsersOfType(TrainCar.TrainCarType.Engine))
			{
				num++;
			}
		}
		bool flag = component.CarType == TrainCar.TrainCarType.Engine;
		int num2 = 0;
		while (num2 < 20)
		{
			num2++;
			TrainTrackSpline trainTrackSpline = null;
			if (flag)
			{
				foreach (TrainTrackSpline sidingSpline2 in TrainTrackSpline.SidingSplines)
				{
					if (!sidingSpline2.HasAnyUsersOfType(TrainCar.TrainCarType.Engine))
					{
						trainTrackSpline = sidingSpline2;
						break;
					}
				}
			}
			if ((Object)(object)trainTrackSpline == (Object)null)
			{
				int index = Random.Range(0, TrainTrackSpline.SidingSplines.Count);
				trainTrackSpline = TrainTrackSpline.SidingSplines[index];
			}
			if ((Object)(object)trainTrackSpline != (Object)null && TryGetRandomPointOnSpline(trainTrackSpline, component, out newPos, out newRot))
			{
				return true;
			}
		}
		return false;
	}

	public override void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		base.SubFill(spawnHandler, distribution, numToFill, initialSpawn);
		List<Prefab<Spawnable>> list = Pool.Get<List<Prefab<Spawnable>>>();
		Prefab<Spawnable>[] prefabs = Prefabs;
		foreach (Prefab<Spawnable> prefab in prefabs)
		{
			TrainCar component = prefab.Object.GetComponent<TrainCar>();
			if ((Object)(object)component != (Object)null && component.CarType == TrainCar.TrainCarType.Engine)
			{
				list.Add(prefab);
			}
		}
		foreach (TrainTrackSpline sidingSpline in TrainTrackSpline.SidingSplines)
		{
			if (sidingSpline.HasAnyUsersOfType(TrainCar.TrainCarType.Engine))
			{
				continue;
			}
			int num = Random.Range(0, list.Count);
			Prefab<Spawnable> prefab2 = Prefabs[num];
			TrainCar component2 = prefab2.Object.GetComponent<TrainCar>();
			if ((Object)(object)component2 == (Object)null)
			{
				continue;
			}
			int num2 = 0;
			while (num2 < 20)
			{
				num2++;
				if (TryGetRandomPointOnSpline(sidingSpline, component2, out var pos, out var rot))
				{
					spawnHandler.Spawn(this, prefab2, pos, rot);
					break;
				}
			}
		}
		Pool.FreeUnmanaged<Prefab<Spawnable>>(ref list);
	}

	protected override float GetPrefabWeight(Prefab<Spawnable> prefab)
	{
		float num = (Object.op_Implicit((Object)(object)prefab.Parameters) ? prefab.Parameters.Count : 1f);
		TrainCar component = prefab.Object.GetComponent<TrainCar>();
		if ((Object)(object)component != (Object)null)
		{
			if (component.CarType == TrainCar.TrainCarType.Wagon)
			{
				num *= (float)TrainCar.wagons_per_engine;
			}
		}
		else
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": No TrainCar script on train prefab " + ((Object)prefab.Object).name));
		}
		return num;
	}

	private bool TryGetRandomPointOnSpline(TrainTrackSpline spline, TrainCar trainCar, out Vector3 pos, out Quaternion rot)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		float length = spline.GetLength();
		if (length < 80f)
		{
			pos = Vector3.zero;
			rot = Quaternion.identity;
			return false;
		}
		float distance = Random.Range(75f, length - 75f);
		pos = spline.GetPointAndTangentCubicHermiteWorld(distance, out var tangent) + Vector3.up * 0.5f;
		rot = Quaternion.LookRotation(tangent);
		float radius = Vector3Ex.Max(((Bounds)(ref trainCar.bounds)).extents);
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(pos, radius, list, 32768, (QueryTriggerInteraction)1);
		bool result = true;
		foreach (Collider item in list)
		{
			if (!trainCar.ColliderIsPartOfTrain(item))
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Density Spawn Population")]
public class DensitySpawnPopulation : SpawnPopulationBase
{
	[FormerlySerializedAs("TargetDensity")]
	[SerializeField]
	[Tooltip("Usually per square km")]
	[Header("Spawn Info")]
	public float _targetDensity = 1f;

	public int ClusterSizeMin = 1;

	public int ClusterSizeMax = 1;

	public int ClusterDithering;

	public int SpawnAttemptsInitial = 20;

	public int SpawnAttemptsRepeating = 10;

	public bool ScaleWithLargeMaps = true;

	public bool ScaleWithSpawnFilter = true;

	public bool AlignToNormal;

	public SpawnFilter Filter = new SpawnFilter();

	public float FilterCutoff;

	public float FilterRadius;

	public bool FilterOutTutorialIslands;

	public MonumentType[] FilterOutMonuments;

	public float NpcRadiusCheckDistance;

	private int sumToSpawn;

	public virtual float TargetDensity => _targetDensity;

	public override void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
	{
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Max((float)ClusterSizeMax, distribution.GetGridCellArea() * GetMaximumSpawnDensity());
		UpdateWeights(distribution, GetTargetCount(distribution));
		int num2 = (initialSpawn ? (numToFill * SpawnAttemptsInitial) : (numToFill * SpawnAttemptsRepeating));
		while (numToFill >= ClusterSizeMax && num2 > 0)
		{
			ByteQuadtree.Element node = distribution.SampleNode();
			int num3 = Random.Range(ClusterSizeMin, ClusterSizeMax + 1);
			num3 = Mathx.Min(num2, numToFill, num3);
			for (int i = 0; i < num3; i++)
			{
				Vector3 spawnPos;
				Quaternion spawnRot;
				bool flag = distribution.Sample(out spawnPos, out spawnRot, node, AlignToNormal, ClusterDithering, 0f, Filter, FilterCutoff);
				if (flag && FilterOutTutorialIslands && ((Bounds)(ref TutorialIsland.WorldBoundsMinusTutorialIslands)).size != Vector3.zero)
				{
					flag = ((Bounds)(ref TutorialIsland.WorldBoundsMinusTutorialIslands)).Contains(spawnPos);
				}
				if (flag && FilterRadius > 0f)
				{
					flag = Filter.GetFactor(spawnPos + Vector3.forward * FilterRadius) > 0f && Filter.GetFactor(spawnPos - Vector3.forward * FilterRadius) > 0f && Filter.GetFactor(spawnPos + Vector3.right * FilterRadius) > 0f && Filter.GetFactor(spawnPos - Vector3.right * FilterRadius) > 0f;
				}
				if (flag && NpcRadiusCheckDistance > 0f)
				{
					PooledList<BaseNPC2> val = Pool.Get<PooledList<BaseNPC2>>();
					try
					{
						BaseEntity.Query.Server.GetBrainsInSphere(spawnPos, NpcRadiusCheckDistance, (List<BaseNPC2>)(object)val);
						flag = ((List<BaseNPC2>)(object)val).Count == 0;
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
				}
				if (flag && FilterOutMonuments != null && FilterOutMonuments.Length != 0)
				{
					flag = (Object)(object)TerrainMeta.Path.FindMonumentWithBoundsOverlap(spawnPos, FilterOutMonuments) == (Object)null;
				}
				if (flag && TryTakeRandomPrefab(out var result))
				{
					if (GetSpawnPosOverride(result, ref spawnPos, ref spawnRot) && (float)distribution.GetCount(spawnPos) < num)
					{
						if ((Object)(object)spawnHandler.Spawn(this, result, spawnPos, spawnRot) != (Object)null)
						{
							numToFill--;
						}
					}
					else
					{
						ReturnPrefab(result);
					}
				}
				num2--;
			}
		}
	}

	public void UpdateWeights(SpawnDistribution distribution, int targetCount)
	{
		float num = 0f;
		for (int i = 0; i < Prefabs.Length; i++)
		{
			Prefab<Spawnable> prefab = Prefabs[i];
			float prefabWeight = GetPrefabWeight(prefab);
			num += prefabWeight;
		}
		int num2 = Mathf.CeilToInt((float)targetCount / num);
		sumToSpawn = 0;
		for (int j = 0; j < Prefabs.Length; j++)
		{
			Prefab<Spawnable> prefab2 = Prefabs[j];
			float num3 = GetPrefabWeight(prefab2);
			if (prefab2.Weight != null && prefab2.Weight.IsActiveInEra())
			{
				num3 *= prefab2.Weight.Scale;
			}
			int count = distribution.GetCount(prefab2.ID);
			int num4 = Mathf.Max(Mathf.FloorToInt(num3 * (float)num2 - (float)count), 0);
			numToSpawn[j] = num4;
			sumToSpawn += num4;
		}
	}

	protected virtual float GetPrefabWeight(Prefab<Spawnable> prefab)
	{
		if (!Object.op_Implicit((Object)(object)prefab.Parameters))
		{
			return 1f;
		}
		return prefab.Parameters.Count;
	}

	public bool TryTakeRandomPrefab(out Prefab<Spawnable> result)
	{
		int num = Random.Range(0, sumToSpawn);
		for (int i = 0; i < Prefabs.Length; i++)
		{
			if ((num -= numToSpawn[i]) < 0)
			{
				numToSpawn[i]--;
				sumToSpawn--;
				result = Prefabs[i];
				return true;
			}
		}
		result = null;
		return false;
	}

	public void ReturnPrefab(Prefab<Spawnable> prefab)
	{
		if (prefab == null)
		{
			return;
		}
		for (int i = 0; i < Prefabs.Length; i++)
		{
			if (Prefabs[i] == prefab)
			{
				numToSpawn[i]++;
				sumToSpawn++;
			}
		}
	}

	public float GetCurrentSpawnDensity()
	{
		if (ScaleWithServerPopulation)
		{
			return TargetDensity * SpawnHandler.PlayerLerp(Spawn.min_density, Spawn.max_density) * 1E-06f;
		}
		return TargetDensity * Spawn.max_density * 1E-06f;
	}

	public float GetMaximumSpawnDensity()
	{
		if (ScaleWithServerPopulation)
		{
			return 2f * TargetDensity * SpawnHandler.PlayerLerp(Spawn.min_density, Spawn.max_density) * 1E-06f;
		}
		return 2f * TargetDensity * Spawn.max_density * 1E-06f;
	}

	public virtual bool GetSpawnPosOverride(Prefab<Spawnable> prefab, ref Vector3 newPos, ref Quaternion newRot)
	{
		return true;
	}

	public override byte[] GetBaseMapValues(int populationRes)
	{
		byte[] baseValues = new byte[populationRes * populationRes];
		SpawnFilter filter = Filter;
		float cutoff = FilterCutoff;
		Parallel.For(0, populationRes, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < populationRes; i++)
			{
				float normX = ((float)i + 0.5f) / (float)populationRes;
				float normZ = ((float)z + 0.5f) / (float)populationRes;
				float factor = filter.GetFactor(normX, normZ);
				baseValues[z * populationRes + i] = (byte)((factor > cutoff) ? (255f * factor) : 0f);
			}
		});
		return baseValues;
	}

	public override int GetTargetCount(SpawnDistribution distribution)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.Size.x * TerrainMeta.Size.z;
		float num2 = GetCurrentSpawnDensity();
		if (!ScaleWithLargeMaps)
		{
			num = Mathf.Min(num, 16000000f);
		}
		if (ScaleWithSpawnFilter)
		{
			num2 *= distribution.Density;
		}
		float num3 = 1f;
		if (Prefabs != null && Prefabs.Length != 0)
		{
			float num4 = 0f;
			Prefab<Spawnable>[] prefabs = Prefabs;
			foreach (Prefab<Spawnable> prefab in prefabs)
			{
				num4 = ((prefab == null || !(prefab.Weight != null) || !prefab.Weight.IsActiveInEra()) ? (num4 + 1f) : (num4 + prefab.Weight.Scale));
			}
			num3 = num4 / (float)Prefabs.Length;
		}
		return Mathf.RoundToInt(num * num2 * num3);
	}

	public override SpawnFilter GetSpawnFilter()
	{
		return Filter;
	}
}


using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class Spawnable : MonoBehaviour, IServerComponent
{
	[ReadOnly]
	public SpawnPopulationBase Population;

	[SerializeField]
	private bool ForceSpawnOnly;

	[SerializeField]
	private string ForceSpawnInfoMessage = string.Empty;

	internal bool SpawnIndividual;

	internal Vector3 SpawnPosition;

	internal Quaternion SpawnRotation;

	protected void OnEnable()
	{
		if (!Application.isLoadingSave)
		{
			Add();
		}
	}

	protected void OnDisable()
	{
		if (!Application.isQuitting && !Application.isLoadingSave)
		{
			Remove();
		}
	}

	private void Add()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		SpawnPosition = ((Component)this).transform.position;
		SpawnRotation = ((Component)this).transform.rotation;
		if (!Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			return;
		}
		if (Population != null)
		{
			SingletonComponent<SpawnHandler>.Instance.AddInstance(this);
		}
		else if (Application.isLoading && !Application.isLoadingSave)
		{
			BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
			if ((Object)(object)component != (Object)null && component.enableSaving && !component.syncPosition)
			{
				SingletonComponent<SpawnHandler>.Instance.AddRespawn(new SpawnIndividual(component.prefabID, SpawnPosition, SpawnRotation));
			}
		}
	}

	private void Remove()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance) && Population != null)
		{
			SingletonComponent<SpawnHandler>.Instance.RemoveInstance(this);
		}
	}

	internal void Save(BaseNetworkable.SaveInfo info)
	{
		if (!(Population == null))
		{
			info.msg.spawnable = Pool.Get<Spawnable>();
			info.msg.spawnable.population = Population.FilenameStringId;
		}
	}

	internal void Load(BaseNetworkable.LoadInfo info)
	{
		if (info.msg.spawnable != null)
		{
			Population = FileSystem.Load<SpawnPopulationBase>(StringPool.Get(info.msg.spawnable.population), true);
		}
		Add();
	}

	protected void OnValidate()
	{
		Population = null;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class SpawnDistribution
{
	internal SpawnHandler Handler;

	public float Density;

	public int Count;

	private WorldSpaceGrid<int> grid;

	private Dictionary<uint, int> dict = new Dictionary<uint, int>();

	private ByteQuadtree quadtree = new ByteQuadtree();

	private Vector3 origin;

	private Vector3 area;

	public SpawnDistribution(SpawnHandler handler, byte[] baseValues, Vector3 origin, Vector3 area)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		Handler = handler;
		quadtree.UpdateValues(baseValues);
		this.origin = origin;
		float num = 0f;
		for (int i = 0; i < baseValues.Length; i++)
		{
			num += (float)(int)baseValues[i];
		}
		Density = num / (float)(255 * baseValues.Length);
		Count = 0;
		this.area = new Vector3(area.x / (float)quadtree.Size, area.y, area.z / (float)quadtree.Size);
		grid = new WorldSpaceGrid<int>(area.x, 20f, (RoundingMode)0);
	}

	public bool Sample(out Vector3 spawnPos, out Quaternion spawnRot, bool alignToNormal = false, float dithering = 0f, float radius = 0f, SpawnFilter filter = null, float cutoff = 0f)
	{
		return Sample(out spawnPos, out spawnRot, SampleNode(), alignToNormal, dithering, radius, filter, cutoff);
	}

	public bool Sample(out Vector3 spawnPos, out Quaternion spawnRot, ByteQuadtree.Element node, bool alignToNormal = false, float dithering = 0f, float radius = 0f, SpawnFilter filter = null, float cutoff = 0f)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Handler == (Object)null || (Object)(object)TerrainMeta.HeightMap == (Object)null)
		{
			spawnPos = Vector3.zero;
			spawnRot = Quaternion.identity;
			return false;
		}
		LayerMask placementMask = Handler.PlacementMask;
		LayerMask placementCheckMask = Handler.PlacementCheckMask;
		float placementCheckHeight = Handler.PlacementCheckHeight;
		LayerMask radiusCheckMask = Handler.RadiusCheckMask;
		float radiusCheckDistance = Handler.RadiusCheckDistance;
		Vector3 val = default(Vector3);
		RaycastHit val2 = default(RaycastHit);
		for (int i = 0; i < 15; i++)
		{
			spawnPos = origin;
			spawnPos.x += node.Coords.x * area.x;
			spawnPos.z += node.Coords.y * area.z;
			spawnPos.x += Random.value * area.x;
			spawnPos.z += Random.value * area.z;
			spawnPos.x += Random.Range(0f - dithering, dithering);
			spawnPos.z += Random.Range(0f - dithering, dithering);
			((Vector3)(ref val))..ctor(spawnPos.x, TerrainMeta.HeightMap.GetHeight(spawnPos), spawnPos.z);
			if (val.y <= spawnPos.y || (filter != null && filter.GetFactor(spawnPos) <= cutoff))
			{
				continue;
			}
			if (LayerMask.op_Implicit(placementCheckMask) != 0)
			{
				bool flag = false;
				if ((radius != 0f) ? Physics.SphereCast(val + Vector3.up * placementCheckHeight, radius, Vector3.down, ref val2, placementCheckHeight, LayerMask.op_Implicit(placementCheckMask)) : Physics.Raycast(val + Vector3.up * placementCheckHeight, Vector3.down, ref val2, placementCheckHeight, LayerMask.op_Implicit(placementCheckMask)))
				{
					if (((1 << ((Component)((RaycastHit)(ref val2)).transform).gameObject.layer) & LayerMask.op_Implicit(placementMask)) == 0)
					{
						continue;
					}
					val.y = ((RaycastHit)(ref val2)).point.y;
				}
			}
			if (LayerMask.op_Implicit(radiusCheckMask) == 0 || !Physics.CheckSphere(val, radiusCheckDistance, LayerMask.op_Implicit(radiusCheckMask)))
			{
				spawnPos.y = val.y;
				spawnRot = Quaternion.Euler(new Vector3(0f, Random.Range(0f, 360f), 0f));
				if (alignToNormal)
				{
					Vector3 normal = TerrainMeta.HeightMap.GetNormal(spawnPos);
					spawnRot = QuaternionEx.LookRotationForcedUp(spawnRot * Vector3.forward, normal);
				}
				return true;
			}
		}
		spawnPos = Vector3.zero;
		spawnRot = Quaternion.identity;
		return false;
	}

	public ByteQuadtree.Element SampleNode()
	{
		ByteQuadtree.Element result = quadtree.Root;
		while (!result.IsLeaf)
		{
			result = result.RandChild;
		}
		return result;
	}

	public void AddInstance(Spawnable spawnable)
	{
		UpdateCount(spawnable, 1);
	}

	public void RemoveInstance(Spawnable spawnable)
	{
		UpdateCount(spawnable, -1);
	}

	private void UpdateCount(Spawnable spawnable, int delta)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Count += delta;
		WorldSpaceGrid<int> val = grid;
		Vector3 spawnPosition = spawnable.SpawnPosition;
		val[spawnPosition] += delta;
		BaseEntity component = ((Component)spawnable).GetComponent<BaseEntity>();
		if (Object.op_Implicit((Object)(object)component))
		{
			if (dict.TryGetValue(component.prefabID, out var value))
			{
				dict[component.prefabID] = value + delta;
				return;
			}
			value = delta;
			dict.Add(component.prefabID, value);
		}
	}

	public int GetCount(uint prefabID)
	{
		dict.TryGetValue(prefabID, out var value);
		return value;
	}

	public int GetCount(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return grid[position];
	}

	public float GetGridCellArea()
	{
		return grid.CellArea;
	}
}


using UnityEngine;

public struct SpawnIndividual
{
	public uint PrefabID;

	public Vector3 Position;

	public Quaternion Rotation;

	public SpawnIndividual(uint prefabID, Vector3 position, Quaternion rotation)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		PrefabID = prefabID;
		Position = position;
		Rotation = rotation;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Spawn Point Spawn Population")]
public class SpawnPointSpawnPopulation : SpawnPopulationBase
{
	[SerializeField]
	private BaseSpawnPoint.SpawnPointType spawnPointType;

	private SpawnFilter Filter = new SpawnFilter();

	public override void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (numToFill == 0)
		{
			return;
		}
		if (!TryGetSpawnPoints(out var result))
		{
			Debug.LogWarning((object)(((Object)this).name + " couldn't find any spawn points of type: " + spawnPointType), (Object)(object)this);
			return;
		}
		foreach (BaseSpawnPoint item in result)
		{
			Prefab<Spawnable> prefab = Prefabs[Random.Range(0, Prefabs.Length)];
			if ((Object)(object)item != (Object)null && item.IsAvailableTo(prefab.Object))
			{
				item.GetLocation(out var pos, out var rot);
				spawnHandler.Spawn(this, prefab, pos, rot);
				numToFill--;
				if (numToFill == 0)
				{
					break;
				}
			}
		}
	}

	public override byte[] GetBaseMapValues(int populationRes)
	{
		return new byte[0];
	}

	public override SpawnFilter GetSpawnFilter()
	{
		return Filter;
	}

	public override int GetTargetCount(SpawnDistribution distribution)
	{
		if (TryGetSpawnPoints(out var result))
		{
			return result.Count;
		}
		return 0;
	}

	private bool TryGetSpawnPoints(out List<BaseSpawnPoint> result)
	{
		return BaseSpawnPoint.spawnPoints.TryGetValue(spawnPointType, out result);
	}
}


