using System;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[Embedded]
[CompilerGenerated]
internal sealed class IsUnmanagedAttribute : Attribute
{
}


using System;
using UnityEngine;

public class BaseRaidBenchmarkScene : BenchmarkScene
{
	[Serializable]
	public struct RunConfig
	{
		public string Name;

		public int PlayerCount;

		public int BaseCount;

		public TextAsset[] BaseJsons;

		public bool SpawnBaseInMiddle;

		public TextAsset MiddleBase;
	}

	[Header("Base Raid Benchmark")]
	public GameObject WorldSetupPrefab;

	public TerrainConfig TerrainConfig;

	public GameObjectRef PlayerPrefab;

	public GameObjectRef ClientPrefab;

	public GameObjectRef SoundManagerPrefab;

	public RunConfig[] Runs;
}


using System;
using UnityEngine;

[Serializable]
public struct RunConfig
{
	public string Name;

	public int PlayerCount;

	public int BaseCount;

	public TextAsset[] BaseJsons;

	public bool SpawnBaseInMiddle;

	public TextAsset MiddleBase;
}


using UnityEngine;

public class BiomeBenchmarkScene : BenchmarkScene
{
	[Header("Biome Benchmark")]
	public uint IslandWidth = 300u;

	public uint IslandHeight = 1000u;

	public uint IslandGap = 50u;

	public float FlyingSpeed = 16f;

	public GameObject WorldSetupPrefab;

	public TerrainConfig TerrainConfig;

	public Enum BiomesToTest = (Enum)(-1);

	public float StreamingPause = 4f;

	[Header("Biome Benchmark - Debug")]
	public bool DebugMode;

	[Range(0f, 4f)]
	public int DebugIslandNum;

	[Range(0f, 1f)]
	public float DebugProgress;
}


public class ClothingBenchmarkScene : BenchmarkScene
{
	public GameObjectRef PlayerModelPrefab;

	public bool ChangeClothingEveryFrame;
}


public class FireworkBenchmarkScene : BenchmarkScene
{
	public GameObjectRef[] shellTypes;

	public int fireworkCount;
}


public class HitDetectionBenchmark : BenchmarkScene
{
	private const int PlayerCount = 50;

	public GameObjectRef PlayerModelPrefab;

	public GameObjectRef PlayerCollisionPrefab;
}


using UnityEngine;

public class MonumentBenchmarkScene : BenchmarkScene
{
	public Transform[] vantagePoints;
}


using UnityEngine;

public class BenchmarkScene : MonoBehaviour
{
	public string BenchmarkTitle = "My Benchmark";

	public string BenchmarkIdent = "benchmark";

	public int MaxNumberOfFrames;

	public int MaxNumberOfSeconds = 10;
}


using UnityEngine;

public class RustigeEggSkinViewer : MonoBehaviour
{
	public Animator animator;
}


using System;
using System.Collections.Generic;
using Rust.UI.MainMenu;
using Rust.Workshop;
using UnityEngine;

public class SkinViewer2 : SingletonComponent<SkinViewer2>
{
	public Camera cam;

	[SerializeField]
	private GameObject parent;

	[SerializeField]
	private GameObject modelsParent;

	[SerializeField]
	private GameObject defaultLightingRig;

	[SerializeField]
	private List<WorkshopRenderSettings> renderSettings;

	private CoverImage targetImage;

	private static Item[] schemaItems;

	public GameObject currentSkinGameObject { get; private set; }

	public bool IsOpen => parent.activeSelf;

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
		parent.SetActive(false);
		UI_MenuManager.OnOpenStateChanged = (Action)Delegate.Combine(UI_MenuManager.OnOpenStateChanged, new Action(OnMenuOpenStateChanged));
	}

	protected override void OnDestroy()
	{
		UI_MenuManager.OnOpenStateChanged = (Action)Delegate.Remove(UI_MenuManager.OnOpenStateChanged, new Action(OnMenuOpenStateChanged));
	}

	public bool TrySet(CoverImage target, IPlayerItemDefinition playerItemDef, Action<bool> skinLoadCallback)
	{
		if (playerItemDef == null)
		{
			return false;
		}
		if (!ItemSkinDirectory.TryGetItemFromDefinitionID(playerItemDef.DefinitionId, out var result))
		{
			string text = playerItemDef.ItemShortName;
			if (text == "lr300.item")
			{
				text = "rifle.lr300";
			}
			result = ItemManager.FindItemDefinition(text);
		}
		return TrySet(target, result, playerItemDef.DefinitionId, playerItemDef.WorkshopId, skinLoadCallback);
	}

	public bool TrySet(CoverImage target, ItemDefinition itemDef, int skinID, ulong workshopID, Action<bool> skinLoadCallback)
	{
		GameObject val = null;
		bool flag = false;
		foreach (WorkshopRenderSettings renderSetting in renderSettings)
		{
			if ((Object)(object)renderSetting == (Object)null)
			{
				continue;
			}
			if ((Object)(object)renderSetting.ItemDefinition == (Object)(object)itemDef)
			{
				val = ((Component)renderSetting).gameObject;
				((Component)renderSetting).gameObject.SetActive(true);
				if (renderSetting.ToggleLightingRig && (Object)(object)renderSetting.LightingRig != (Object)null)
				{
					((Component)renderSetting.LightingRig).gameObject.SetActive(true);
					flag = true;
				}
			}
			else
			{
				((Component)renderSetting).gameObject.SetActive(false);
			}
		}
		defaultLightingRig.gameObject.SetActive(!flag);
		if ((Object)(object)val == (Object)null)
		{
			skinLoadCallback?.Invoke(obj: false);
			return false;
		}
		targetImage = target;
		RefreshRenderTexture();
		parent.SetActive(true);
		currentSkinGameObject = val;
		ItemSkinDirectory.Skin skin2 = ItemSkinDirectory.FindByInventoryDefinitionId(skinID);
		WorkshopSkin.Reset(((Component)this).gameObject);
		if (workshopID != 0L)
		{
			if (skin2.id == 0)
			{
				WorkshopSkin.Apply(val, workshopID, (Action<Skin>)delegate(Skin skin)
				{
					if (IsOpen)
					{
						RemoveMipMapLimit(skin);
						skinLoadCallback?.Invoke(obj: true);
					}
				}, (Action)null);
			}
			else if (skin2.id == skinID)
			{
				(skin2.invItem as ItemSkin).ApplySkin(val);
				skinLoadCallback?.Invoke(obj: true);
			}
		}
		else
		{
			if (skin2.id == skinID)
			{
				ItemSkin itemSkin = skin2.invItem as ItemSkin;
				if ((Object)(object)itemSkin != (Object)null)
				{
					itemSkin.ApplySkin(val);
				}
			}
			skinLoadCallback?.Invoke(obj: true);
		}
		return true;
	}

	private void RemoveMipMapLimit(Skin skin)
	{
		foreach (Texture2D allTexture in skin.GetAllTextures())
		{
			if (((Texture)allTexture).isReadable)
			{
				allTexture.requestedMipmapLevel = 0;
				allTexture.ignoreMipmapLimit = true;
			}
		}
	}

	public void RefreshRenderTexture()
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Expected O, but got Unknown
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetImage == (Object)null)
		{
			return;
		}
		int num = 1920;
		int num2 = 1080;
		if ((Object)(object)cam.targetTexture != (Object)null && ((Texture)cam.targetTexture).width == num && ((Texture)cam.targetTexture).height == num2)
		{
			targetImage.texture = (Texture)(object)cam.targetTexture;
			return;
		}
		if ((Object)(object)cam.targetTexture != (Object)null)
		{
			cam.targetTexture.Release();
			Object.Destroy((Object)(object)cam.targetTexture);
		}
		RenderTexture val = new RenderTexture(num, num2, 16)
		{
			useMipMap = true,
			autoGenerateMips = true,
			filterMode = (FilterMode)2
		};
		cam.targetTexture = val;
		cam.pixelRect = new Rect(0f, 0f, (float)num, (float)num2);
		targetImage.texture = (Texture)(object)val;
	}

	public void Close()
	{
		parent.SetActive(false);
	}

	public static bool ShouldShow3DSkin(IPlayerItemDefinition playerItemDef)
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<SkinViewer2>.Instance))
		{
			return false;
		}
		if (playerItemDef == null)
		{
			return false;
		}
		if (string.IsNullOrEmpty(playerItemDef.ItemShortName))
		{
			return false;
		}
		string text = playerItemDef.ItemShortName;
		if (text == "lr300.item")
		{
			text = "rifle.lr300";
		}
		if (Object.op_Implicit((Object)(object)ItemManager.FindItemDefinition(text)))
		{
			return true;
		}
		return false;
	}

	private void OnMenuOpenStateChanged()
	{
		if (!MainMenu.IsOpen())
		{
			Close();
		}
	}

	[ClientVar(ClientAdmin = true)]
	public static void printSupportedItems(Arg arg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		TextTable val = new TextTable();
		val.AddColumns(new string[2] { "Item", "Name" });
		foreach (WorkshopRenderSettings renderSetting in SingletonComponent<SkinViewer2>.Instance.renderSettings)
		{
			ItemDefinition itemDefinition = renderSetting.ItemDefinition;
			val.AddRow(new string[2]
			{
				itemDefinition.shortname,
				itemDefinition.displayName.english
			});
		}
		arg.ReplyWith(((object)val).ToString());
	}
}


using UnityEngine;

public class SkinViewerRenderSettings : MonoBehaviour
{
	public bool overrideFullScreenPosition;

	public Vector3 fullScreenPositionOffset;

	[Space]
	public bool overrideFullScreenRotation;

	public Vector3 fullScreenRotation;

	[Space]
	public bool overrideZoom;

	public Vector2 minMaxZoom = new Vector2(20f, 8f);
}


using Development.Attributes;
using Rust.UI.MainMenu;
using UnityEngine;

[ResetStaticFields]
public static class MainMenu
{
	private static Canvas _canvas;

	public static Canvas Canvas
	{
		get
		{
			if ((Object)(object)SingletonComponent<UI_MenuManager>.Instance == (Object)null)
			{
				return null;
			}
			if ((Object)(object)_canvas == (Object)null)
			{
				_canvas = ((Component)SingletonComponent<UI_MenuManager>.Instance).GetComponent<Canvas>();
			}
			return _canvas;
		}
	}

	public static bool IsOpen()
	{
		return UI_MenuManager.IsOpen;
	}
}


public static class Notifications
{
}


using Rust.UI.MainMenu;

public class UI_Hero_TwitchDrops : UI_Hero_InfoBox
{
}


public static class PlayerJoin
{
}


using System;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_QuitModal : UI_Window
{
	public static UI_QuitModal Instance;

	[SerializeField]
	private UIEscapeCapture _capture;

	protected override void Awake()
	{
		if ((Object)(object)Instance == (Object)null)
		{
			Instance = this;
		}
		else if ((Object)(object)Instance != (Object)(object)this)
		{
			Object.Destroy((Object)(object)((Component)this).gameObject);
			return;
		}
		base.Awake();
		SetUI(state: false);
		((Behaviour)_capture).enabled = false;
	}

	protected override void OnOpened()
	{
		base.OnOpened();
		((Behaviour)_capture).enabled = true;
	}

	protected override void OnClosed()
	{
		base.OnClosed();
		((Behaviour)_capture).enabled = false;
	}

	public void Quit()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		ConsoleSystem.Run(Option.Client, "quit", Array.Empty<object>());
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Facepunch.Flexbox;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class FlexVirtualScroll : MonoBehaviour
{
	public interface IVisualUpdate
	{
		void OnVisualUpdate(int i, GameObject obj);
	}

	[Tooltip("Optional, we'll try to GetComponent IDataSource from this object on awake")]
	public GameObject DataSourceObject;

	public GameObject SourceObject;

	public ScrollRect ScrollRect;

	public FlexElement FlexContentRoot;

	public FlexGridsElement FlexGrid;

	public int ItemHeight;

	public int ItemsPerLine = 1;

	public int Gap;

	public FlexElement topSpacer;

	public FlexElement bottomSpacer;

	[Tooltip("Objects that are already spawned and in editor rather than being instantiated at runtime")]
	public List<GameObject> PreloadObjects = new List<GameObject>();

	private VirtualScroll.IDataSource dataSource;

	private Dictionary<int, GameObject> ActivePool = new Dictionary<int, GameObject>();

	private Stack<GameObject> InactivePool = new Stack<GameObject>();

	private FlexValue topHeight;

	private FlexValue bottomHeight;

	public int BlockHeight
	{
		get
		{
			if ((Object)(object)FlexContentRoot != (Object)null)
			{
				return ItemHeight;
			}
			if ((Object)(object)FlexGrid != (Object)null)
			{
				return ItemHeight;
			}
			return 0;
		}
	}

	public void Awake()
	{
		((UnityEvent<Vector2>)(object)ScrollRect.onValueChanged).AddListener((UnityAction<Vector2>)OnScrollChanged);
		if ((Object)(object)DataSourceObject != (Object)null)
		{
			SetDataSource(DataSourceObject.GetComponent<VirtualScroll.IDataSource>());
		}
	}

	public void PrewarmPool()
	{
		foreach (GameObject preloadObject in PreloadObjects)
		{
			preloadObject.SetActive(false);
			if ((Object)(object)FlexContentRoot != (Object)null)
			{
				preloadObject.transform.SetParent(((Component)FlexContentRoot).transform, false);
			}
			else if ((Object)(object)FlexGrid != (Object)null)
			{
				preloadObject.transform.SetParent(((Component)FlexGrid).transform, false);
			}
			InactivePool.Push(preloadObject);
		}
	}

	public void OnDestroy()
	{
		((UnityEvent<Vector2>)(object)ScrollRect.onValueChanged).RemoveListener((UnityAction<Vector2>)OnScrollChanged);
	}

	private void OnScrollChanged(Vector2 pos)
	{
		Rebuild();
	}

	public void SetDataSource(VirtualScroll.IDataSource source, bool forceRebuild = false)
	{
		if (dataSource != source || forceRebuild)
		{
			dataSource = source;
			FullRebuild();
		}
	}

	public void FullRebuild()
	{
		int[] array = ActivePool.Keys.ToArray();
		foreach (int key in array)
		{
			Recycle(key);
		}
		Rebuild();
	}

	public void DataChanged()
	{
		foreach (KeyValuePair<int, GameObject> item in ActivePool)
		{
			dataSource.SetItemData(item.Key, item.Value);
		}
		Rebuild();
	}

	public void Rebuild()
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		if (dataSource == null)
		{
			return;
		}
		int itemCount = dataSource.GetItemCount();
		int num = Mathf.CeilToInt((float)itemCount / (float)ItemsPerLine);
		float num2 = num * BlockHeight + Mathf.Max(0, (num - 1) * Gap);
		ScrollRect.content.SetSizeWithCurrentAnchors((Axis)1, num2);
		float y = ScrollRect.content.anchoredPosition.y;
		float y2 = ScrollRect.content.anchoredPosition.y;
		Rect rect = ScrollRect.viewport.rect;
		float num3 = y2 + ((Rect)(ref rect)).height;
		float num4 = BlockHeight + Gap;
		int num5 = 0;
		int num6 = num - 1;
		for (int i = 0; i < num; i++)
		{
			if ((float)(i * (BlockHeight + Gap)) + (float)BlockHeight >= y - num4)
			{
				num5 = i;
				break;
			}
		}
		for (int num7 = num - 1; num7 >= 0; num7--)
		{
			if ((float)(num7 * (BlockHeight + Gap)) <= num3 + num4)
			{
				num6 = num7;
				break;
			}
		}
		int num8 = num5 * ItemsPerLine;
		int num9 = Mathf.Min((num6 + 1) * ItemsPerLine, itemCount);
		RecycleOutOfRange(num8, num9 - 1);
		for (int j = num8; j < num9; j++)
		{
			BuildItem(j);
		}
		ReorderFlexChildren(num8, num9 - 1);
		topHeight.Value = num5 * (BlockHeight + Gap);
		topHeight.HasValue = true;
		float num10 = num - (num6 + 1);
		bottomHeight.Value = num10 * (float)(BlockHeight + Gap);
		bottomHeight.HasValue = true;
		((FlexElementBase)topSpacer).OverridePreferredHeight = topHeight;
		((FlexElementBase)bottomSpacer).OverridePreferredHeight = bottomHeight;
		if ((Object)(object)FlexGrid != (Object)null)
		{
			((FlexElementBase)FlexGrid).SetLayoutDirty(true);
		}
		if ((Object)(object)FlexContentRoot != (Object)null)
		{
			((FlexElementBase)FlexContentRoot).SetLayoutDirty(true);
		}
	}

	public void Update()
	{
		if (!(dataSource is IVisualUpdate visualUpdate))
		{
			return;
		}
		foreach (KeyValuePair<int, GameObject> item in ActivePool)
		{
			visualUpdate.OnVisualUpdate(item.Key, item.Value);
		}
	}

	private void RecycleOutOfRange(int startVisible, float endVisible)
	{
		int[] array = (from x in ActivePool.Keys
			where x < startVisible || (float)x > endVisible
			select (x)).ToArray();
		foreach (int key in array)
		{
			Recycle(key);
		}
	}

	private void Recycle(int key)
	{
		GameObject val = ActivePool[key];
		val.SetActive(false);
		ActivePool.Remove(key);
		InactivePool.Push(val);
	}

	private void BuildItem(int i)
	{
		if (i >= 0 && !ActivePool.ContainsKey(i))
		{
			GameObject item = GetItem();
			item.SetActive(true);
			dataSource.SetItemData(i, item);
			ActivePool[i] = item;
		}
	}

	private GameObject GetItem()
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (InactivePool.Count == 0)
		{
			GameObject val = Object.Instantiate<GameObject>(SourceObject);
			if ((Object)(object)FlexContentRoot != (Object)null)
			{
				val.transform.SetParent(((Component)FlexContentRoot).transform, false);
			}
			if ((Object)(object)FlexGrid != (Object)null)
			{
				val.transform.SetParent(((Component)FlexGrid).transform, false);
			}
			val.transform.localScale = Vector3.one;
			val.SetActive(false);
			InactivePool.Push(val);
		}
		return InactivePool.Pop();
	}

	private void ReorderFlexChildren(int startIndex, int endIndex)
	{
		int num = 0;
		((Component)topSpacer).transform.SetSiblingIndex(num++);
		for (int i = startIndex; i <= endIndex; i++)
		{
			if (ActivePool.TryGetValue(i, out var value))
			{
				value.transform.SetSiblingIndex(num++);
			}
		}
		((Component)bottomSpacer).transform.SetSiblingIndex(num++);
	}
}


using UnityEngine;

public interface IVisualUpdate
{
	void OnVisualUpdate(int i, GameObject obj);
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using Facepunch.Math;
using Newtonsoft.Json;
using UnityEngine;

public static class MenuDiskData
{
	[JsonModel]
	public struct ServerSaveData
	{
		public string Name { get; set; }

		public string Address { get; set; }

		public int QueryPort { get; set; }

		public uint LastConnected { get; set; }
	}

	[JsonModel]
	public class MenuData
	{
		public List<int> ReadNotifications { get; set; } = new List<int>();

		public List<ServerSaveData> SavedServers { get; set; } = new List<ServerSaveData>();
	}

	private static MenuData _menuData;

	private static readonly string _menuDataPath = Path.Combine(Application.persistentDataPath, "menu_data.json");

	public static MenuData Data
	{
		get
		{
			if (_menuData == null)
			{
				Load();
			}
			return _menuData;
		}
	}

	public static void Load()
	{
		try
		{
			if (File.Exists(_menuDataPath))
			{
				_menuData = JsonConvert.DeserializeObject<MenuData>(File.ReadAllText(_menuDataPath));
				if (_menuData == null)
				{
					_menuData = new MenuData();
				}
			}
			else
			{
				_menuData = new MenuData();
			}
		}
		catch (NullReferenceException ex)
		{
			Debug.LogWarning((object)("Menu data file corrupted (NRE): " + ex.Message + ". Deleting file and creating a new one."));
			try
			{
				if (File.Exists(_menuDataPath))
				{
					File.Delete(_menuDataPath);
				}
			}
			catch (Exception ex2)
			{
				Debug.LogException(ex2);
			}
			finally
			{
				_menuData = new MenuData();
			}
		}
		catch (Exception ex3)
		{
			Debug.LogException(ex3);
			_menuData = new MenuData();
		}
	}

	public static async Task Save()
	{
		try
		{
			string directoryName = Path.GetDirectoryName(_menuDataPath);
			if (!string.IsNullOrEmpty(directoryName) && !Directory.Exists(directoryName))
			{
				Directory.CreateDirectory(directoryName);
			}
			string contents = JsonConvert.SerializeObject((object)_menuData, (Formatting)1);
			await File.WriteAllTextAsync(_menuDataPath, contents);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void AddRecentServer(string name, string address, int queryPort)
	{
		ServerSaveData serverSaveData = default(ServerSaveData);
		serverSaveData.Name = name;
		serverSaveData.Address = address;
		serverSaveData.QueryPort = queryPort;
		serverSaveData.LastConnected = (uint)Epoch.Current;
		ServerSaveData item = serverSaveData;
		Data.SavedServers.RemoveAll((ServerSaveData s) => s.Address.Equals(address, StringComparison.OrdinalIgnoreCase) && s.QueryPort == queryPort);
		Data.SavedServers.Insert(0, item);
		if (Data.SavedServers.Count > 3)
		{
			Data.SavedServers.RemoveRange(3, Data.SavedServers.Count - 3);
		}
	}
}


[JsonModel]
public struct ServerSaveData
{
	public string Name { get; set; }

	public string Address { get; set; }

	public int QueryPort { get; set; }

	public uint LastConnected { get; set; }
}


using System.Collections.Generic;

[JsonModel]
public class MenuData
{
	public List<int> ReadNotifications { get; set; } = new List<int>();

	public List<ServerSaveData> SavedServers { get; set; } = new List<ServerSaveData>();
}


using System;
using UnityEngine;

public class UI_LoadingRotate : MonoBehaviour
{
	[SerializeField]
	private Transform RotateImage;

	private bool _keepRotating;

	public void Toggle()
	{
		_keepRotating = !_keepRotating;
	}

	public void ContinuouslyRotate(bool state)
	{
		_keepRotating = state;
	}

	public void Update()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (_keepRotating && !((Object)(object)RotateImage == (Object)null))
		{
			((Component)RotateImage).transform.localEulerAngles = new Vector3(0f, 0f, RotateImage.localEulerAngles.z - Time.deltaTime * 500f);
		}
	}

	public void RotateOnce()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		float z = RotateImage.localEulerAngles.z;
		float num = z + 360f;
		LeanTween.value(((Component)RotateImage).gameObject, z, num, 0.5f).setEase((LeanTweenType)1).setOnUpdate((Action<float, object>)delegate(float angle, object obj)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			Transform val = (Transform)((obj is Transform) ? obj : null);
			if (val != null)
			{
				val.localEulerAngles = new Vector3(0f, 0f, angle);
			}
		}, (object)RotateImage);
	}

	public void Reset()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		RotateImage.localEulerAngles = Vector3.zero;
	}
}


using Facepunch.Flexbox;
using Rust.UI;
using TMPro;
using UnityEngine;

public class UI_SearchBar : MonoBehaviour
{
	public RustInput rustInput;

	[Space]
	public RustButton cancelButton;

	public GameObject defaultIcon;

	[Space]
	public FlexTransition transition;

	public UIEscapeCapture escapeCapture;

	public TMP_InputField InputField => rustInput.InputField;
}


using System;
using Network;
using UnityEngine;

public class TreeMarker : BaseEntity
{
	public GameObjectRef hitEffect;

	public SoundDefinition hitEffectSound;

	public GameObjectRef spawnEffect;

	private Vector3 initialPosition;

	public bool SpherecastOnInit = true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TreeMarker.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


using System;
using System.Collections.Generic;
using Facepunch.Extend;
using UnityEngine;

public class NexusDock : SingletonComponent<NexusDock>
{
	[Header("Targets")]
	public Transform FerryWaypoint;

	public Transform[] QueuePoints;

	public Transform Arrival;

	public Transform Docking;

	public Transform Docked;

	public Transform CastingOff;

	public Transform Departure;

	[Header("Ferry")]
	public float WaitTime = 30f;

	[Header("Ejection")]
	public BoxCollider EjectionZone;

	public float TraceHeight = 100f;

	public LayerMask TraceLayerMask = LayerMask.op_Implicit(1503731969);

	[NonSerialized]
	public NexusFerry[] QueuedFerries;

	[NonSerialized]
	public NexusFerry CurrentFerry;

	public Transform GetEntryPoint(NexusFerry ferry, out bool entered)
	{
		if ((Object)(object)ferry == (Object)null)
		{
			throw new ArgumentNullException("ferry");
		}
		CleanupQueuedFerries();
		if ((Object)(object)ferry == (Object)(object)CurrentFerry)
		{
			entered = true;
			return Arrival;
		}
		int num = List.FindIndex<NexusFerry>((IReadOnlyList<NexusFerry>)QueuedFerries, ferry, (IEqualityComparer<NexusFerry>)null);
		if (num < 0)
		{
			if ((Object)(object)QueuedFerries[0] == (Object)null)
			{
				QueuedFerries[0] = ferry;
				entered = false;
				return QueuePoints[0];
			}
			entered = false;
			return FerryWaypoint;
		}
		int num2 = QueuedFerries.Length - 1;
		if (num == num2)
		{
			if ((Object)(object)CurrentFerry == (Object)null)
			{
				QueuedFerries[num] = null;
				CurrentFerry = ferry;
				entered = true;
				return Arrival;
			}
			entered = false;
			return QueuePoints[num];
		}
		if (num < num2)
		{
			if ((Object)(object)QueuedFerries[num + 1] == (Object)null)
			{
				QueuedFerries[num] = null;
				QueuedFerries[num + 1] = ferry;
				entered = false;
				return QueuePoints[num + 1];
			}
			entered = false;
			return QueuePoints[num];
		}
		entered = false;
		return QueuePoints[num];
	}

	public bool Depart(NexusFerry ferry)
	{
		if ((Object)(object)ferry != (Object)(object)CurrentFerry)
		{
			return false;
		}
		CurrentFerry = null;
		return true;
	}

	public bool TryFindEjectionPosition(out Vector3 position, float radius = 5f)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)EjectionZone == (Object)null)
		{
			Debug.LogError((object)"EjectionZone is null, cannot find an eject position", (Object)(object)this);
			position = Vector3.zero;
			return false;
		}
		Transform transform = ((Component)EjectionZone).transform;
		Vector3 size = EjectionZone.size;
		float num = transform.position.y - size.y / 2f;
		RaycastHit val3 = default(RaycastHit);
		for (int i = 0; i < 10; i++)
		{
			Vector3 val = Vector3Ex.Scale(size, Random.value - 0.5f, 0f, Random.value - 0.5f);
			Vector3 val2 = transform.TransformPoint(val);
			if (Physics.SphereCast(Vector3Ex.WithY(val2, num + TraceHeight), radius, Vector3.down, ref val3, TraceHeight + radius, LayerMask.op_Implicit(TraceLayerMask), (QueryTriggerInteraction)1) && !(((RaycastHit)(ref val3)).point.y < val2.y - size.y) && !(((RaycastHit)(ref val3)).point.y > val2.y + size.y))
			{
				float waterSurface = WaterLevel.GetWaterSurface(val2, waves: false, volumes: false);
				if (!(((RaycastHit)(ref val3)).point.y < waterSurface))
				{
					position = ((RaycastHit)(ref val3)).point;
					return true;
				}
			}
		}
		position = Vector3.zero;
		return false;
	}

	public void CleanupQueuedFerries()
	{
		Array.Resize(ref QueuedFerries, QueuePoints.Length);
		for (int i = 0; i < QueuedFerries.Length; i++)
		{
			if (!Object.op_Implicit((Object)(object)QueuedFerries[i]))
			{
				QueuedFerries[i] = null;
			}
		}
		if (!Object.op_Implicit((Object)(object)CurrentFerry))
		{
			CurrentFerry = null;
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Nexus.Models;
using ProtoBuf;
using Rust.UI;
using UnityEngine;

public class NexusDockTerminal : BaseEntity
{
	public static readonly Phrase ScheduleSoonPhrase = new Phrase("nexus.dock.schedule.soon", "{0} - Now");

	public static readonly Phrase ScheduleMinutesPhrase = new Phrase("nexus.dock.schedule.minutes", "{0} - {1} min");

	public static readonly Phrase ScheduleUnknownPhrase = new Phrase("nexus.dock.schedule.unknown", "{0} - Unknown");

	public float TravelTime = 90f;

	public RustText[] ScheduleLabels;

	private List<ScheduleEntry> _scheduleEntries;

	private static readonly HashSet<string> SeenFerries = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateFerrySchedule, 0f, 10f, 5f);
		}
	}

	public override void AdminKill()
	{
		if (!HasFlag(Flags.Debugging))
		{
			Debug.LogWarning((object)"Prevented killing NexusDock, set debugging flag to override");
		}
	}

	private void UpdateFerrySchedule()
	{
		if (_scheduleEntries == null)
		{
			_scheduleEntries = Pool.Get<List<ScheduleEntry>>();
		}
		foreach (ScheduleEntry scheduleEntry in _scheduleEntries)
		{
			ScheduleEntry current = scheduleEntry;
			Pool.Free<ScheduleEntry>(ref current);
		}
		_scheduleEntries.Clear();
		List<(string, float?)> list = Pool.Get<List<(string, float?)>>();
		CalculateFerryEstimates(list);
		foreach (var item in list)
		{
			NexusZoneDetails val = NexusServer.FindZone(item.Item1);
			if (val != null)
			{
				ScheduleEntry val2 = Pool.Get<ScheduleEntry>();
				val2.nextZoneId = val.Id;
				val2.estimate = (int)Mathf.Round(item.Item2 ?? (-1f));
				_scheduleEntries.Add(val2);
			}
		}
		SendNetworkUpdate();
	}

	private void CalculateFerryEstimates(List<(string NextZone, float? Estimate)> estimates)
	{
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Invalid comparison between Unknown and I4
		if (estimates == null)
		{
			throw new ArgumentNullException("estimates");
		}
		estimates.Clear();
		SeenFerries.Clear();
		NexusDock instance = SingletonComponent<NexusDock>.Instance;
		if ((Object)(object)instance == (Object)null || !NexusServer.Started || NexusServer.Zones == null)
		{
			return;
		}
		instance.CleanupQueuedFerries();
		float num = 0f;
		if ((Object)(object)instance.CurrentFerry != (Object)null && !instance.CurrentFerry.IsRetiring)
		{
			estimates.Add((instance.CurrentFerry.NextZone, num));
			SeenFerries.Add(instance.CurrentFerry.OwnerZone);
		}
		NexusFerry[] queuedFerries = instance.QueuedFerries;
		foreach (NexusFerry nexusFerry in queuedFerries)
		{
			if (!((Object)(object)nexusFerry == (Object)null) && !nexusFerry.IsRetiring)
			{
				estimates.Add((nexusFerry.NextZone, num));
				num += instance.WaitTime;
				SeenFerries.Add(nexusFerry.OwnerZone);
			}
		}
		string zoneKey = NexusServer.ZoneKey;
		foreach (NexusZoneDetails zone in NexusServer.Zones)
		{
			if (SeenFerries.Contains(zone.Key) || !((Dictionary<string, VariableData>)(object)zone.Variables).TryGetValue("ferry", out VariableData value) || (int)((VariableData)(ref value)).Type != 1 || string.IsNullOrWhiteSpace(((VariableData)(ref value)).Value) || !((VariableData)(ref value)).Value.Contains(zoneKey, StringComparison.InvariantCultureIgnoreCase) || !NexusUtil.TryParseFerrySchedule(zone.Key, ((VariableData)(ref value)).Value, out var schedule))
			{
				continue;
			}
			int num2 = List.FindIndex<string>((IReadOnlyList<string>)schedule, zoneKey, (IEqualityComparer<string>)StringComparer.InvariantCultureIgnoreCase);
			if (num2 < 0)
			{
				continue;
			}
			string item = ((num2 < schedule.Length - 1) ? schedule[num2 + 1] : schedule[0]);
			if (!NexusServer.TryGetFerryStatus(zone.Key, out var currentZone, out var status))
			{
				estimates.Add((item, null));
				SeenFerries.Add(zone.Key);
				continue;
			}
			int num3 = List.FindIndex<string>((IReadOnlyList<string>)schedule, currentZone, (IEqualityComparer<string>)StringComparer.InvariantCultureIgnoreCase);
			if (num3 < 0)
			{
				estimates.Add((item, null));
				SeenFerries.Add(zone.Key);
				continue;
			}
			float num4 = 0f;
			int idx = num3;
			NexusFerry.State state = (NexusFerry.State)status.state;
			if (idx == num3)
			{
				if (state == NexusFerry.State.SailingIn)
				{
					num4 += num + TravelTime;
				}
				else if (state <= NexusFerry.State.Waiting)
				{
					num4 += num;
				}
				else
				{
					num4 += instance.WaitTime + TravelTime;
					NextIdx();
				}
			}
			else
			{
				if (state <= NexusFerry.State.Stopping)
				{
					num4 += TravelTime;
				}
				if (state <= NexusFerry.State.Waiting)
				{
					num4 += instance.WaitTime;
				}
				if (state <= NexusFerry.State.SailingOut)
				{
					num4 += TravelTime;
				}
			}
			while (idx != num2)
			{
				num4 += TravelTime + instance.WaitTime + TravelTime;
				NextIdx();
			}
			estimates.Add((item, num4));
			SeenFerries.Add(zone.Key);
			void NextIdx()
			{
				idx++;
				if (idx >= schedule.Length)
				{
					idx = 0;
				}
			}
		}
		SeenFerries.Clear();
		estimates.Sort(delegate((string NextZone, float? Estimate) a, (string NextZone, float? Estimate) b)
		{
			int num5 = StringComparer.InvariantCultureIgnoreCase.Compare(a.NextZone, b.NextZone);
			if (num5 != 0)
			{
				return num5;
			}
			if (!a.Estimate.HasValue && !b.Estimate.HasValue)
			{
				return 0;
			}
			if (!a.Estimate.HasValue)
			{
				return 1;
			}
			return (!b.Estimate.HasValue) ? (-1) : a.Estimate.Value.CompareTo(b.Estimate.Value);
		});
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		info.msg.nexusDockTerminal.schedule = Pool.Get<List<ScheduleEntry>>();
		if (_scheduleEntries == null)
		{
			return;
		}
		foreach (ScheduleEntry scheduleEntry in _scheduleEntries)
		{
			info.msg.nexusDockTerminal.schedule.Add(scheduleEntry.Copy());
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.nexusDockTerminal?.schedule == null)
		{
			return;
		}
		if (_scheduleEntries != null)
		{
			foreach (ScheduleEntry scheduleEntry in _scheduleEntries)
			{
				ScheduleEntry current = scheduleEntry;
				Pool.Free<ScheduleEntry>(ref current);
			}
			Pool.Free<ScheduleEntry>(ref _scheduleEntries, false);
		}
		_scheduleEntries = info.msg.nexusDockTerminal.schedule;
		info.msg.nexusDockTerminal.schedule = null;
	}
}


using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using Development.Attributes;
using Facepunch;
using Facepunch.Extend;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust;
using Rust.UI;
using UnityEngine;

[ResetStaticFields]
public class NexusFerry : BaseEntity
{
	public enum State
	{
		Invalid,
		SailingIn,
		Queued,
		Arrival,
		Docking,
		Stopping,
		Waiting,
		CastingOff,
		Departure,
		SailingOut,
		Transferring
	}

	private readonly struct Edge
	{
		public readonly Node Next;

		public readonly float Distance;

		public Edge(Node next, float distance)
		{
			Next = next;
			Distance = distance;
		}
	}

	private class Node : IComparable<Node>, IPooled
	{
		public int Index;

		public Vector3 Position;

		public readonly List<Edge> Edges;

		public Node Parent;

		public float G;

		public float H;

		public float F => G + H;

		public Node()
		{
			Edges = new List<Edge>();
		}

		public Node ConnectTo(Node other)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			float distance = Vector3.Distance(Position, other.Position);
			Edges.Add(new Edge(other, distance));
			other.Edges.Add(new Edge(this, distance));
			return this;
		}

		public void Reset()
		{
			Parent = null;
			G = 0f;
			H = 0f;
		}

		public int CompareTo(Node other)
		{
			if (this == other || Index == other.Index)
			{
				return 0;
			}
			if (!(F < other.F))
			{
				return -1;
			}
			return 1;
		}

		public void EnterPool()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			Index = 0;
			Position = Vector3.zero;
			Edges.Clear();
			Reset();
		}

		public void LeavePool()
		{
		}
	}

	private class Graph : IPooled
	{
		private readonly List<Node> _nodes;

		public Graph()
		{
			_nodes = new List<Node>();
		}

		public Node AddNode(Vector3 position)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			Node node = Pool.Get<Node>();
			node.Index = _nodes.Count;
			node.Position = position;
			_nodes.Add(node);
			return node;
		}

		public Node FindClosest(Vector3 position)
		{
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			float num = float.MaxValue;
			Node result = null;
			foreach (Node node in _nodes)
			{
				float num2 = Vector3.Distance(node.Position, position);
				if (!(num2 >= num))
				{
					num = num2;
					result = node;
				}
			}
			return result;
		}

		public bool TryFindPath(Node start, Node end, List<Vector3> path)
		{
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			//IL_015a: Unknown result type (might be due to invalid IL or missing references)
			foreach (Node node3 in _nodes)
			{
				node3.Reset();
			}
			bool[] array = ArrayPool<bool>.Shared.Rent(_nodes.Count);
			Array.Clear(array, 0, array.Length);
			List<Node> list = Pool.Get<List<Node>>();
			list.Add(start);
			while (list.Count > 0)
			{
				int index = list.Count - 1;
				Node node = list[index];
				list.RemoveAt(index);
				array[node.Index] = true;
				if (node == end)
				{
					ArrayPool<bool>.Shared.Return(array);
					Pool.Free<Node>(ref list, false);
					path.Clear();
					for (Node node2 = node; node2 != null; node2 = node2.Parent)
					{
						path.Add(node2.Position);
						if (path.Count > _nodes.Count)
						{
							Debug.LogError((object)"Pathfinding code is broken!");
							path.Clear();
							return false;
						}
					}
					path.Reverse();
					return true;
				}
				foreach (Edge edge in node.Edges)
				{
					Node next = edge.Next;
					if (!array[next.Index])
					{
						float num = node.G + edge.Distance;
						if (next.Parent == null)
						{
							next.Parent = node;
							next.G = num;
							next.H = Vector3.Distance(next.Position, end.Position);
						}
						else if (num < next.G)
						{
							next.Parent = node;
							next.G = num;
						}
						int num2 = list.BinarySearch(next);
						if (num2 < 0)
						{
							list.Insert(~num2, next);
						}
					}
				}
			}
			ArrayPool<bool>.Shared.Return(array);
			Pool.Free<Node>(ref list, false);
			path.Clear();
			return false;
		}

		public void EnterPool()
		{
			foreach (Node node in _nodes)
			{
				Node current = node;
				Pool.Free<Node>(ref current);
			}
			_nodes.Clear();
		}

		public void LeavePool()
		{
		}
	}

	public static readonly Phrase RetiringPhrase = new Phrase("ferry.not_in_service", "Not In Service");

	[Header("NexusFerry")]
	public float TravelVelocity = 20f;

	public float ApproachVelocity = 5f;

	public float StoppingVelocity = 1f;

	public float AccelerationSpeed = 1f;

	public float TurnSpeed = 1f;

	public float VelocityPreservationOnTurn = 0.1f;

	public float TargetDistanceThreshold = 10f;

	public GameObjectRef hornEffect;

	public Transform hornEffectTransform;

	public float departureHornLeadTime = 5f;

	[Header("Pathing")]
	public SphereCollider SphereCaster;

	public int CastSweepDegrees = 16;

	[Range(0f, 1f)]
	public float CastSweepNoise = 0.25f;

	public LayerMask CastLayers = LayerMask.op_Implicit(134283264);

	public float CastInterval = 1f;

	public float CastHitProtection = 5f;

	public int PathLookahead = 4;

	public int PathLookaheadThreshold = 5;

	[Header("UI")]
	public RustText[] NextZoneLabels;

	private long _timestamp;

	private string _ownerZone;

	private List<string> _schedule;

	private int _scheduleIndex;

	private State _state;

	private bool _isRetiring;

	private int _nextScheduleIndex;

	private bool _departureHornPlayed;

	public static readonly ListHashSet<NexusFerry> All = new ListHashSet<NexusFerry>();

	private List<NetworkableId> _transferredIds;

	private NexusDock _targetDock;

	private bool _isTransferring;

	private TimeSince _sinceStartedWaiting;

	private TimeSince _sinceLastTransferAttempt;

	private RealTimeSince _sinceLastNextIndexUpdate;

	private TimeSince _sincePathCalculation;

	private Vector3? _pathTargetPosition;

	private Quaternion? _pathTargetRotation;

	private Vector3 _velocity;

	public string OwnerZone => _ownerZone;

	public bool IsRetiring => _isRetiring;

	public string NextZone
	{
		get
		{
			int? num = TryGetNextScheduleIndex();
			if (!num.HasValue)
			{
				return null;
			}
			return _schedule[num.Value];
		}
	}

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public void Initialize(string ownerZone, List<string> schedule)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			if (string.IsNullOrWhiteSpace(ownerZone))
			{
				throw new ArgumentNullException("ownerZone");
			}
			if (schedule == null)
			{
				throw new ArgumentNullException("schedule");
			}
			if (schedule.Count <= 1 || !schedule.Contains<string>(ownerZone, StringComparer.InvariantCultureIgnoreCase))
			{
				throw new ArgumentException("Ferry schedule is invalid", "schedule");
			}
			_timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
			_ownerZone = ownerZone;
			_schedule = schedule;
			_scheduleIndex = List.FindIndex<string>((IReadOnlyList<string>)schedule, ownerZone, (IEqualityComparer<string>)StringComparer.InvariantCultureIgnoreCase);
			_state = State.Stopping;
			_departureHornPlayed = false;
			if (_scheduleIndex < 0)
			{
				throw new InvalidOperationException("Ferry couldn't find the owner zone in its schedule");
			}
			EnsureInitialized();
			Transform targetTransform = GetTargetTransform(_state);
			((Component)this).transform.SetPositionAndRotation(targetTransform.position, targetTransform.rotation);
		}
		catch
		{
			Kill();
			throw;
		}
	}

	private void EnsureInitialized()
	{
		_targetDock = SingletonComponent<NexusDock>.Instance;
		if ((Object)(object)_targetDock == (Object)null)
		{
			throw new InvalidOperationException("Ferry has no dock to go to!");
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			if (!NexusServer.Started)
			{
				Debug.LogError((object)"NexusFerry will not work without being connected to a nexus - destroying.");
				Kill();
				return;
			}
			if (string.IsNullOrWhiteSpace(_ownerZone) || _schedule == null || _schedule.Count <= 1 || !_schedule.Contains(_ownerZone))
			{
				Debug.LogError((object)"NexusFerry has not been initialized (you can't spawn them manually) - destroying.");
				Kill();
				return;
			}
		}
		EnsureInitialized();
		All.Add(this);
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer)
		{
			All.Remove(this);
		}
		if (_transferredIds != null)
		{
			Pool.FreeUnmanaged<NetworkableId>(ref _transferredIds);
		}
	}

	public void FixedUpdate()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		if (RealTimeSince.op_Implicit(_sinceLastNextIndexUpdate) > 10f)
		{
			_sinceLastNextIndexUpdate = RealTimeSince.op_Implicit(0f);
			int num = TryGetNextScheduleIndex() ?? (-1);
			if (num != _nextScheduleIndex)
			{
				_nextScheduleIndex = num;
				SendNetworkUpdate();
			}
		}
		if (_state == State.Waiting)
		{
			EnsureInitialized();
			if (!_departureHornPlayed && _targetDock.WaitTime - TimeSince.op_Implicit(_sinceStartedWaiting) < departureHornLeadTime)
			{
				PlayDepartureHornEffect();
			}
			if (!(TimeSince.op_Implicit(_sinceStartedWaiting) >= _targetDock.WaitTime))
			{
				return;
			}
			SwitchToNextState();
		}
		if (MoveTowardsTarget())
		{
			SwitchToNextState();
		}
	}

	public FerryStatus GetStatus()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		FerryStatus obj = Pool.Get<FerryStatus>();
		obj.entityId = net.ID;
		obj.timestamp = _timestamp;
		obj.ownerZone = _ownerZone;
		obj.schedule = List.ShallowClonePooled<string>(_schedule);
		obj.scheduleIndex = _scheduleIndex;
		obj.state = (int)_state;
		obj.isRetiring = _isRetiring;
		return obj;
	}

	public void Retire()
	{
		_isRetiring = true;
	}

	public void UpdateSchedule(List<string> schedule)
	{
		if (_schedule != null)
		{
			Pool.FreeUnmanaged<string>(ref _schedule);
		}
		_schedule = List.ShallowClonePooled<string>(schedule);
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	private void SwitchToNextState()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (_state == State.SailingOut)
		{
			if (!_isTransferring && TimeSince.op_Implicit(_sinceLastTransferAttempt) >= 5f)
			{
				_sinceLastTransferAttempt = TimeSince.op_Implicit(0f);
				TransferToNextZone();
			}
			return;
		}
		if (_state == State.Departure && (Object)(object)_targetDock != (Object)null)
		{
			_targetDock.Depart(this);
		}
		State nextState = GetNextState(_state);
		_state = nextState;
		SendNetworkUpdate();
		if (_state == State.Waiting)
		{
			_sinceStartedWaiting = TimeSince.op_Implicit(0f);
			_departureHornPlayed = false;
		}
		if (_state == State.CastingOff)
		{
			EjectInactiveEntities(_isRetiring);
			if (_isRetiring)
			{
				Kill();
			}
		}
	}

	private static State GetNextState(State currentState)
	{
		State state = currentState + 1;
		if (state >= State.SailingOut)
		{
			state = State.SailingOut;
		}
		return state;
	}

	private static State GetPreviousState(State currentState)
	{
		if ((uint)currentState <= 3u || (uint)(currentState - 9) <= 1u)
		{
			return State.Invalid;
		}
		return currentState - 1;
	}

	private async void TransferToNextZone()
	{
		if (_isTransferring)
		{
			return;
		}
		int? num = TryGetNextScheduleIndex();
		if (!num.HasValue)
		{
			return;
		}
		_isTransferring = true;
		int oldScheduleIndex = _scheduleIndex;
		State oldState = _state;
		try
		{
			_scheduleIndex = num.Value;
			string text = _schedule[_scheduleIndex];
			_state = State.Transferring;
			Debug.Log((object)("Sending ferry to " + text));
			await NexusServer.TransferEntity(this, text, "ferry");
		}
		finally
		{
			_isTransferring = false;
			_scheduleIndex = oldScheduleIndex;
			_state = oldState;
		}
	}

	private int? TryGetNextScheduleIndex()
	{
		string zoneKey = NexusServer.ZoneKey;
		int num = (_scheduleIndex + 1) % _schedule.Count;
		for (int i = 0; i < _schedule.Count; i++)
		{
			string text = _schedule[num];
			if (!string.Equals(text, zoneKey, StringComparison.InvariantCultureIgnoreCase) && NexusServer.TryGetZoneStatus(text, out var status) && status.IsOnline)
			{
				return num;
			}
			num++;
			if (num >= _schedule.Count)
			{
				num = 0;
			}
		}
		return null;
	}

	private void EjectInactiveEntities(bool forceAll = false)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		HashSet<NetworkableId> hashSet = Pool.Get<HashSet<NetworkableId>>();
		hashSet.Clear();
		if (_transferredIds != null)
		{
			foreach (NetworkableId transferredId in _transferredIds)
			{
				hashSet.Add(transferredId);
			}
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		foreach (BaseEntity child in children)
		{
			if (!(child is NPCAutoTurret) && (hashSet.Contains(child.net.ID) || forceAll) && (!IsEntityActive(child) || forceAll))
			{
				list.Add(child);
			}
		}
		foreach (BaseEntity item in list)
		{
			EjectEntity(item);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		hashSet.Clear();
		Pool.FreeUnmanaged<NetworkableId>(ref hashSet);
	}

	private void EjectEntity(BaseEntity entity)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)entity == (Object)null))
		{
			if ((Object)(object)_targetDock != (Object)null && _targetDock.TryFindEjectionPosition(out var position))
			{
				entity.SetParent(null);
				entity.ServerPosition = position;
				entity.SendNetworkUpdateImmediate();
			}
			else
			{
				Debug.LogWarning((object)$"Couldn't find an ejection point for {entity}", (Object)(object)entity);
			}
		}
	}

	private static bool IsEntityActive(BaseEntity entity)
	{
		bool result = false;
		if (entity is BasePlayer player)
		{
			result = IsPlayerReady(player);
		}
		else if (entity is BaseVehicle baseVehicle)
		{
			List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
			baseVehicle.GetMountedPlayers(list);
			foreach (BasePlayer item in list)
			{
				if (IsPlayerReady(item))
				{
					result = true;
					break;
				}
			}
			Pool.FreeUnmanaged<BasePlayer>(ref list);
		}
		return result;
	}

	private static bool IsPlayerReady(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null && player.IsConnected)
		{
			return !player.IsLoadingAfterTransfer();
		}
		return false;
	}

	private void PlayDepartureHornEffect()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (hornEffect.isValid)
		{
			Effect.server.Run(hornEffect.resourcePath, this, 0u, hornEffectTransform.localPosition, Vector3.up);
		}
		_departureHornPlayed = true;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		((FacepunchBehaviour)this).Invoke(base.DisableTransferProtectionAction, 0.1f);
	}

	public override void Save(SaveInfo info)
	{
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.nexusFerry = Pool.Get<NexusFerry>();
		info.msg.nexusFerry.timestamp = _timestamp;
		info.msg.nexusFerry.ownerZone = _ownerZone;
		info.msg.nexusFerry.schedule = List.ShallowClonePooled<string>(_schedule);
		info.msg.nexusFerry.scheduleIndex = _scheduleIndex;
		info.msg.nexusFerry.state = (int)_state;
		info.msg.nexusFerry.isRetiring = _isRetiring;
		info.msg.nexusFerry.nextScheduleIndex = _nextScheduleIndex;
		if (info.forTransfer)
		{
			List<NetworkableId> list = Pool.Get<List<NetworkableId>>();
			foreach (BaseEntity child in children)
			{
				list.Add(child.net.ID);
			}
			info.msg.nexusFerry.transferredIds = list;
		}
		else
		{
			info.msg.nexusFerry.transferredIds = List.ShallowClonePooled<NetworkableId>(_transferredIds) ?? Pool.Get<List<NetworkableId>>();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.nexusFerry == null)
		{
			return;
		}
		_timestamp = info.msg.nexusFerry.timestamp;
		_ownerZone = info.msg.nexusFerry.ownerZone;
		if (_schedule != null)
		{
			Pool.FreeUnmanaged<string>(ref _schedule);
		}
		_schedule = List.ShallowClonePooled<string>(info.msg.nexusFerry.schedule);
		_scheduleIndex = info.msg.nexusFerry.scheduleIndex;
		_state = (State)info.msg.nexusFerry.state;
		_isRetiring = info.msg.nexusFerry.isRetiring;
		_nextScheduleIndex = info.msg.nexusFerry.nextScheduleIndex;
		if (base.isServer)
		{
			if (_transferredIds != null)
			{
				Pool.FreeUnmanaged<NetworkableId>(ref _transferredIds);
			}
			_transferredIds = List.ShallowClonePooled<NetworkableId>(info.msg.nexusFerry.transferredIds);
			if (_state == State.Transferring)
			{
				_state = State.SailingIn;
			}
		}
	}

	public static NexusFerry Get(NetworkableId entityId, long timestamp)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		if (BaseNetworkable.serverEntities.Find(entityId) is NexusFerry nexusFerry && nexusFerry._timestamp == timestamp)
		{
			return nexusFerry;
		}
		return null;
	}

	private bool MoveTowardsTarget()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		EnsureInitialized();
		switch (_state)
		{
		case State.Transferring:
			return false;
		case State.SailingIn:
			return MoveTowardsPositionAvoidObstacles(_targetDock.FerryWaypoint.position);
		case State.Queued:
		{
			bool entered;
			Transform entryPoint = _targetDock.GetEntryPoint(this, out entered);
			return MoveTowardsPositionAvoidObstacles(entryPoint.position) && entered;
		}
		case State.SailingOut:
			return MoveTowardsPositionAvoidObstacles(GetIslandTransferPosition());
		default:
			return MoveTowardsTargetTransform();
		}
	}

	private bool MoveTowardsPositionAvoidObstacles(Vector3 targetPosition)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		if (!_pathTargetPosition.HasValue || !_pathTargetRotation.HasValue || TimeSince.op_Implicit(_sincePathCalculation) > CastInterval)
		{
			Vector3 val = ChooseWaypoint(targetPosition);
			_sincePathCalculation = TimeSince.op_Implicit(0f);
			_pathTargetPosition = null;
			_pathTargetRotation = null;
			Vector3 position = ((Component)this).transform.position;
			Vector3 forward = ((Component)this).transform.forward;
			float num = Vector3Ex.Distance2D(val, position);
			float num2;
			if (!(num > 0.01f))
			{
				num2 = 0f;
			}
			else
			{
				Quaternion val2 = Quaternion.LookRotation(Vector3Ex.Direction2D(val, position));
				num2 = ((Quaternion)(ref val2)).eulerAngles.y;
			}
			float num3 = num2;
			float num4 = (float)Random.Range(0, CastSweepDegrees) * CastSweepNoise;
			int num5 = Mathf.FloorToInt(360f / (float)CastSweepDegrees);
			List<(float, float, float, Vector3, Quaternion)> list = Pool.Get<List<(float, float, float, Vector3, Quaternion)>>();
			float num6 = 0f;
			for (int i = 1; i < num5; i++)
			{
				int num7 = (((i & 1) == 0) ? 1 : (-1));
				int num8 = i / 2 * num7;
				Quaternion val3 = Quaternion.Euler(0f, num3 + num4 + (float)CastSweepDegrees * 0.5f * (float)num8, 0f);
				Vector3 val4 = val3 * Vector3.forward;
				float travelDistance;
				Vector3 endPosition;
				bool num9 = SphereCast(val4, num, out travelDistance, out endPosition);
				float item = Mathf.Clamp(Vector3.Dot(forward, val4), 0.5f, 1f);
				float item2 = (num9 ? Mathf.Clamp01(travelDistance / 30f) : 1f);
				float num10 = Vector3Ex.Distance2D(val, endPosition);
				list.Add((item, item2, num10, endPosition, val3));
				num6 = Mathf.Max(num6, num10);
				if (!num9)
				{
					break;
				}
			}
			float num11 = -1f;
			Vector3 value = Vector3.zero;
			Quaternion value2 = Quaternion.identity;
			foreach (var item8 in list)
			{
				float item3 = item8.Item1;
				float item4 = item8.Item2;
				float item5 = item8.Item3;
				Vector3 item6 = item8.Item4;
				Quaternion item7 = item8.Item5;
				float num12 = 1f - Mathf.Clamp01(item5 / num6);
				float num13 = item3 * item4 * num12;
				if (!(num13 <= num11))
				{
					num11 = num13;
					value = item6;
					value2 = item7;
				}
			}
			Pool.FreeUnmanaged<(float, float, float, Vector3, Quaternion)>(ref list);
			_pathTargetPosition = value;
			_pathTargetRotation = value2;
		}
		if (_pathTargetPosition.HasValue && _pathTargetRotation.HasValue)
		{
			return MoveTowardsPosition(_pathTargetPosition.Value, _pathTargetRotation.Value);
		}
		return false;
		Vector3 ChooseWaypoint(Vector3 target)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			List<Vector3> list2 = Pool.Get<List<Vector3>>();
			if (TryFindWaypointsTowards(target, list2))
			{
				Vector3 position2 = ((Component)this).transform.position;
				Vector3 direction = default(Vector3);
				float distance = default(float);
				for (int num14 = list2.Count - 1; num14 >= 0; num14--)
				{
					Vector3Ex.ToDirectionAndMagnitude(list2[num14] - position2, ref direction, ref distance);
					if (!SphereCast(direction, distance, out var _, out var _))
					{
						Vector3 result = list2[num14];
						Pool.FreeUnmanaged<Vector3>(ref list2);
						return result;
					}
				}
				Vector3 result2 = list2[0];
				Pool.FreeUnmanaged<Vector3>(ref list2);
				return result2;
			}
			Pool.FreeUnmanaged<Vector3>(ref list2);
			return target;
		}
	}

	private bool MoveTowardsTargetTransform()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Transform targetTransform = GetTargetTransform(_state);
		Vector3 position = targetTransform.position;
		Quaternion rotation = targetTransform.rotation;
		return MoveTowardsPosition(position, rotation);
	}

	private Transform GetTargetTransform(State state)
	{
		EnsureInitialized();
		switch (state)
		{
		case State.Arrival:
			return _targetDock.Arrival;
		case State.Docking:
			return _targetDock.Docking;
		case State.Stopping:
		case State.Waiting:
			return _targetDock.Docked;
		case State.CastingOff:
			return _targetDock.CastingOff;
		case State.Departure:
			return _targetDock.Departure;
		default:
			Debug.LogError((object)$"Cannot call GetTargetTransform in state {state}");
			return ((Component)this).transform;
		}
	}

	private bool MoveTowardsPosition(Vector3 targetPosition, Quaternion targetRotation)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		bool flag = _state >= State.Queued && _state <= State.CastingOff;
		Vector3 position = ((Component)this).transform.position;
		targetPosition.y = position.y;
		Vector3 val = default(Vector3);
		float num = default(float);
		Vector3Ex.ToDirectionAndMagnitude(targetPosition - position, ref val, ref num);
		if (num < 0.1f)
		{
			return true;
		}
		Vector3 val2 = default(Vector3);
		float num2 = default(float);
		Vector3Ex.ToDirectionAndMagnitude(_velocity, ref val2, ref num2);
		float num3 = ((!flag) ? TravelVelocity : ((_state == State.Stopping) ? StoppingVelocity : ApproachVelocity));
		num2 = Mathx.Lerp(num2, num3, AccelerationSpeed);
		if (flag)
		{
			_velocity = num2 * val;
		}
		else
		{
			float num4 = Mathf.Clamp(Vector3.Dot(val2, val), 0.1f, 1f);
			_velocity = num4 * num2 * val + (1f - num4) * VelocityPreservationOnTurn * _velocity;
		}
		Quaternion rotation = ((Component)this).transform.rotation;
		State previousState = GetPreviousState(_state);
		Vector3 val3;
		Quaternion val4;
		if (previousState != 0)
		{
			Transform targetTransform = GetTargetTransform(previousState);
			Vector3 position2 = targetTransform.position;
			Quaternion rotation2 = targetTransform.rotation;
			position2.y = position.y;
			float num5 = Vector3Ex.Distance2D(position2, targetPosition);
			float num6 = ((Vector3)(ref _velocity)).magnitude * Time.deltaTime;
			float num7 = Mathf.Min(num6, num);
			val3 = position + val * num7;
			val4 = Quaternion.Slerp(targetRotation, rotation2, num / num5);
			((Component)this).transform.SetPositionAndRotation(val3, val4);
			if (!Mathf.Approximately(num6, 0f))
			{
				return num7 < num6;
			}
			return true;
		}
		Vector3 val5 = _velocity * Time.deltaTime;
		Vector3 val6 = default(Vector3);
		float num8 = default(float);
		Vector3Ex.ToDirectionAndMagnitude(val5, ref val6, ref num8);
		val3 = ((!(num8 >= num) || !((double)Vector3.Dot(val6, val) > 0.5)) ? (position + val5) : targetPosition);
		targetRotation = ((((Vector3)(ref val)).sqrMagnitude > 0.01f) ? Quaternion.LookRotation(val) : Quaternion.identity);
		val4 = Mathx.Lerp(rotation, targetRotation, TurnSpeed);
		((Component)this).transform.SetPositionAndRotation(val3, val4);
		return Vector3.Distance(val3, targetPosition) < TargetDistanceThreshold;
	}

	private bool SphereCast(Vector3 direction, float distance, out float travelDistance, out Vector3 endPosition)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)SphereCaster).transform.position + SphereCaster.center;
		float radius = SphereCaster.radius;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(val, direction), radius, list, distance, LayerMask.op_Implicit(CastLayers), (QueryTriggerInteraction)2);
		bool flag = false;
		travelDistance = 0f;
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			BaseEntity entity = current.GetEntity();
			if ((!((Object)(object)entity != (Object)null) || (!((Object)(object)entity == (Object)(object)this) && !entity.EqualNetID((BaseNetworkable)this))) && (!((RaycastHit)(ref current)).collider.isTrigger || ((Component)((RaycastHit)(ref current)).collider).CompareTag("FerryAvoid")))
			{
				flag = true;
				travelDistance = Mathf.Max(((RaycastHit)(ref current)).distance - CastHitProtection, 0f);
				break;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		if (!flag)
		{
			travelDistance = distance;
		}
		endPosition = val + direction * travelDistance;
		return flag;
	}

	private Vector3 GetIslandTransferPosition()
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		EnsureInitialized();
		int? num = TryGetNextScheduleIndex();
		if (num.HasValue)
		{
			string zoneKey = _schedule[num.Value];
			if (NexusServer.TryGetIsland(zoneKey, out var island))
			{
				return island.FerryWaypoint.position;
			}
			if (NexusServer.TryGetIslandPosition(zoneKey, out var position))
			{
				return position;
			}
		}
		if (NexusIsland.All.Count > 0)
		{
			return NexusIsland.All[0].FerryWaypoint.position;
		}
		return _targetDock.FerryWaypoint.position;
	}

	private bool TryFindWaypointsTowards(Vector3 targetPosition, List<Vector3> waypoints)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.WithY(TerrainMeta.Center, 0f);
		Vector3 size = TerrainMeta.Size;
		float num = Mathf.Sqrt(size.x * size.x + size.z * size.z) / 2f;
		Graph graph = Pool.Get<Graph>();
		Node node = null;
		Node node2 = null;
		float num2 = 0f;
		int num3 = 0;
		while (num3 < 64)
		{
			Vector3 position = val + Quaternion.Euler(0f, num2, 0f) * Vector3.forward * num;
			Node node3 = graph.AddNode(position);
			if (node2 != null)
			{
				node3.ConnectTo(node2);
			}
			if (node == null)
			{
				node = node3;
			}
			node2 = node3;
			num3++;
			num2 += 5.5384617f;
		}
		if (node != null && node2 != null && node != node2)
		{
			node.ConnectTo(node2);
		}
		foreach (NexusIsland item in NexusIsland.All)
		{
			Vector3 position2 = item.FerryWaypoint.position;
			Node other = graph.FindClosest(position2);
			graph.AddNode(position2).ConnectTo(other);
		}
		if ((Object)(object)SingletonComponent<NexusDock>.Instance != (Object)null)
		{
			Vector3 position3 = SingletonComponent<NexusDock>.Instance.FerryWaypoint.position;
			Node node4 = graph.FindClosest(position3);
			Vector3 val2 = (position3 + node4.Position) * 0.5f;
			Vector3 position4 = (val2 + node4.Position) * 0.5f;
			Vector3 position5 = (val2 + position3) * 0.5f;
			Node other2 = graph.AddNode(position4).ConnectTo(node4);
			Node other3 = graph.AddNode(val2).ConnectTo(other2);
			Node other4 = graph.AddNode(position5).ConnectTo(other3);
			graph.AddNode(position3).ConnectTo(other4);
		}
		Node node5 = graph.FindClosest(((Component)this).transform.position);
		Node node6 = graph.FindClosest(targetPosition);
		if (node5 == node6)
		{
			waypoints.Add(targetPosition);
			Pool.Free<Graph>(ref graph);
			return true;
		}
		List<Vector3> list = Pool.Get<List<Vector3>>();
		if (node5 == null || node6 == null || !graph.TryFindPath(node5, node6, list) || list.Count == 0)
		{
			Pool.FreeUnmanaged<Vector3>(ref list);
			Pool.Free<Graph>(ref graph);
			return false;
		}
		Pool.Free<Graph>(ref graph);
		if (list.Count == 1)
		{
			waypoints.Add(list[0]);
			Pool.FreeUnmanaged<Vector3>(ref list);
			return true;
		}
		int num4 = list.Count - 1;
		int num5 = ((num4 < PathLookaheadThreshold) ? 1 : Mathf.Min(PathLookahead, num4));
		for (int i = 1; i <= num5; i++)
		{
			waypoints.Add(list[i]);
		}
		Pool.FreeUnmanaged<Vector3>(ref list);
		return true;
	}
}


public enum State
{
	Invalid,
	SailingIn,
	Queued,
	Arrival,
	Docking,
	Stopping,
	Waiting,
	CastingOff,
	Departure,
	SailingOut,
	Transferring
}


private readonly struct Edge
{
	public readonly Node Next;

	public readonly float Distance;

	public Edge(Node next, float distance)
	{
		Next = next;
		Distance = distance;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

private class Node : IComparable<Node>, IPooled
{
	public int Index;

	public Vector3 Position;

	public readonly List<Edge> Edges;

	public Node Parent;

	public float G;

	public float H;

	public float F => G + H;

	public Node()
	{
		Edges = new List<Edge>();
	}

	public Node ConnectTo(Node other)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		float distance = Vector3.Distance(Position, other.Position);
		Edges.Add(new Edge(other, distance));
		other.Edges.Add(new Edge(this, distance));
		return this;
	}

	public void Reset()
	{
		Parent = null;
		G = 0f;
		H = 0f;
	}

	public int CompareTo(Node other)
	{
		if (this == other || Index == other.Index)
		{
			return 0;
		}
		if (!(F < other.F))
		{
			return -1;
		}
		return 1;
	}

	public void EnterPool()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Index = 0;
		Position = Vector3.zero;
		Edges.Clear();
		Reset();
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Buffers;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

private class Graph : IPooled
{
	private readonly List<Node> _nodes;

	public Graph()
	{
		_nodes = new List<Node>();
	}

	public Node AddNode(Vector3 position)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Node node = Pool.Get<Node>();
		node.Index = _nodes.Count;
		node.Position = position;
		_nodes.Add(node);
		return node;
	}

	public Node FindClosest(Vector3 position)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		Node result = null;
		foreach (Node node in _nodes)
		{
			float num2 = Vector3.Distance(node.Position, position);
			if (!(num2 >= num))
			{
				num = num2;
				result = node;
			}
		}
		return result;
	}

	public bool TryFindPath(Node start, Node end, List<Vector3> path)
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		foreach (Node node3 in _nodes)
		{
			node3.Reset();
		}
		bool[] array = ArrayPool<bool>.Shared.Rent(_nodes.Count);
		Array.Clear(array, 0, array.Length);
		List<Node> list = Pool.Get<List<Node>>();
		list.Add(start);
		while (list.Count > 0)
		{
			int index = list.Count - 1;
			Node node = list[index];
			list.RemoveAt(index);
			array[node.Index] = true;
			if (node == end)
			{
				ArrayPool<bool>.Shared.Return(array);
				Pool.Free<Node>(ref list, false);
				path.Clear();
				for (Node node2 = node; node2 != null; node2 = node2.Parent)
				{
					path.Add(node2.Position);
					if (path.Count > _nodes.Count)
					{
						Debug.LogError((object)"Pathfinding code is broken!");
						path.Clear();
						return false;
					}
				}
				path.Reverse();
				return true;
			}
			foreach (Edge edge in node.Edges)
			{
				Node next = edge.Next;
				if (!array[next.Index])
				{
					float num = node.G + edge.Distance;
					if (next.Parent == null)
					{
						next.Parent = node;
						next.G = num;
						next.H = Vector3.Distance(next.Position, end.Position);
					}
					else if (num < next.G)
					{
						next.Parent = node;
						next.G = num;
					}
					int num2 = list.BinarySearch(next);
					if (num2 < 0)
					{
						list.Insert(~num2, next);
					}
				}
			}
		}
		ArrayPool<bool>.Shared.Return(array);
		Pool.Free<Node>(ref list, false);
		path.Clear();
		return false;
	}

	public void EnterPool()
	{
		foreach (Node node in _nodes)
		{
			Node current = node;
			Pool.Free<Node>(ref current);
		}
		_nodes.Clear();
	}

	public void LeavePool()
	{
	}
}


using UnityEngine;

public class NexusFerrySounds : MonoBehaviour, IClientComponent
{
	[SerializeField]
	private NexusFerry ferry;

	[SerializeField]
	private float roughHalfWidth = 5f;

	[SerializeField]
	private float roughHalfLength = 10f;

	private float soundCullDistanceSq;

	[Header("Engine")]
	[SerializeField]
	private SoundDefinition engineLoopDef;

	private Sound engineLoop;

	private SoundModulation.Modulator engineGainMod;

	private SoundModulation.Modulator enginePitchMod;

	[SerializeField]
	private SoundDefinition engineStartDef;

	[SerializeField]
	private SoundDefinition engineStopDef;

	[SerializeField]
	private AnimationCurve engineGainCurve;

	[SerializeField]
	private AnimationCurve enginePitchCurve;

	[SerializeField]
	private float engineGainChangeRate = 1f;

	[SerializeField]
	private float enginePitchChangeRate = 0.5f;

	[SerializeField]
	private Transform engineTransform;

	[SerializeField]
	[Header("Water")]
	private SoundDefinition waterIdleDef;

	[SerializeField]
	private SoundDefinition waterSideMovementSlowDef;

	[SerializeField]
	private SoundDefinition waterSideMovementFastDef;

	[SerializeField]
	private AnimationCurve waterMovementGainCurve;

	[SerializeField]
	private float waterMovementGainChangeRate = 0.5f;

	[SerializeField]
	private AnimationCurve waterDistanceGainCurve;

	private Sound leftWaterSound;

	private SoundModulation.Modulator leftWaterGainMod;

	private Sound rightWaterSound;

	private SoundModulation.Modulator rightWaterGainMod;

	[SerializeField]
	private Vector3 sideSoundLineStern;

	[SerializeField]
	private Vector3 sideSoundLineBow;

	[SerializeField]
	[Header("Dock")]
	private SoundDefinition dockArrivalSoundDef;

	[SerializeField]
	private SoundDefinition dockDepartureSoundDef;

	[SerializeField]
	private Transform dockSoundTransform;

	[Header("Ambient")]
	private Sound ambientIdleSound;

	[SerializeField]
	private SoundDefinition ambientActiveLoopDef;

	private Sound ambientActiveSound;

	private Line leftSoundLine;

	private Line rightSoundLine;

	[Header("Runtime")]
	public bool engineOn = true;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class NexusIsland : BaseEntity, INexusTransferTriggerController
{
	public const Flags ServerFullFlag = Flags.Reserved1;

	[Header("Nexus Island")]
	public Transform BillboardRoot;

	public Transform Billboard;

	public BoxCollider TransferZone;

	public BoxCollider SpawnZone;

	public float TraceHeight = 100f;

	public LayerMask TraceLayerMask = LayerMask.op_Implicit(1503731969);

	public Transform FerryWaypoint;

	public GameObjectRef MapMarkerPrefab;

	public Transform MapMarkerLocation;

	[NonSerialized]
	public string ZoneKey;

	public static readonly List<NexusIsland> All = new List<NexusIsland>();

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer && !All.Contains(this))
		{
			All.Add(this);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer)
		{
			All.Remove(this);
		}
	}

	public bool CanTransfer(BaseEntity entity)
	{
		if (!(entity is BaseBoat) && !(entity is BaseSubmarine) && !(entity is WaterInflatable) && !(entity is PlayerHelicopter) && !(entity is HotAirBalloon))
		{
			return entity is BasePlayer;
		}
		return true;
	}

	public (string Zone, string Method) GetTransferDestination()
	{
		return (Zone: ZoneKey, Method: "ocean");
	}

	public bool TryFindPosition(out Vector3 position, float radius = 10f)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SpawnZone == (Object)null)
		{
			Debug.LogError((object)"SpawnZone is null, cannot find a spawn position", (Object)(object)this);
			position = Vector3.zero;
			return false;
		}
		Transform transform = ((Component)SpawnZone).transform;
		Vector3 size = SpawnZone.size;
		RaycastHit val3 = default(RaycastHit);
		for (int i = 0; i < 10; i++)
		{
			Vector3 val = Vector3Ex.Scale(size, Random.value - 0.5f, 0f, Random.value - 0.5f);
			Vector3 val2 = transform.TransformPoint(val);
			if (IsValidPosition(val2, radius))
			{
				float waterSurface = WaterLevel.GetWaterSurface(val2, waves: false, volumes: false);
				if (!Physics.SphereCast(Vector3Ex.WithY(val2, waterSurface + TraceHeight), radius, Vector3.down, ref val3, TraceHeight + radius, LayerMask.op_Implicit(TraceLayerMask), (QueryTriggerInteraction)1) || ((RaycastHit)(ref val3)).point.y < waterSurface)
				{
					position = Vector3Ex.WithY(val2, waterSurface);
					return true;
				}
			}
		}
		position = Vector3.zero;
		return false;
		static bool IsValidPosition(Vector3 center, float extent)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			if (ValidBounds.TestInnerBounds(center) && ValidBounds.TestInnerBounds(center + new Vector3(0f - extent, 0f, 0f - extent)) && ValidBounds.TestInnerBounds(center + new Vector3(0f - extent, 0f, extent)) && ValidBounds.TestInnerBounds(center + new Vector3(extent, 0f, 0f - extent)))
			{
				return ValidBounds.TestInnerBounds(center + new Vector3(extent, 0f, extent));
			}
			return false;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.nexusIsland != null)
		{
			ZoneKey = info.msg.nexusIsland.zoneKey;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.nexusIsland = Pool.Get<NexusIsland>();
		info.msg.nexusIsland.zoneKey = ZoneKey;
	}

	public override void ServerInit()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		BaseEntity baseEntity = GameManager.server.CreateEntity(MapMarkerPrefab.resourcePath, MapMarkerLocation.position, MapMarkerLocation.rotation);
		baseEntity.Spawn();
		baseEntity.SetParent(this, worldPositionStays: true);
	}
}


public interface INexusTransferTriggerController
{
	bool CanTransfer(BaseEntity entity);

	(string Zone, string Method) GetTransferDestination();
}


using System.Collections.Generic;
using UnityEngine;

public class NexusTransferTrigger : BaseMonoBehaviour, IServerComponent
{
	[Tooltip("Must implement INexusTransferTriggerController!")]
	public MonoBehaviour Controller;

	private static readonly HashSet<BaseEntity> PendingEntities = new HashSet<BaseEntity>();

	private INexusTransferTriggerController _controller;

	protected void Start()
	{
		_controller = Controller as INexusTransferTriggerController;
		if (_controller == null)
		{
			Debug.LogError((object)"NexusTransferTrigger doesn't have a valid controller assigned!", (Object)(object)this);
		}
	}

	protected void OnTriggerEnter(Collider other)
	{
		if (_controller == null)
		{
			return;
		}
		var (zoneKey, method) = _controller.GetTransferDestination();
		if (string.IsNullOrEmpty(zoneKey))
		{
			return;
		}
		BaseEntity entity = ((Component)other).gameObject.ToBaseEntity();
		if (!((Object)(object)entity == (Object)null))
		{
			BaseEntity baseEntity = NexusServer.FindRootEntity(entity, includeFerry: true);
			if (_controller.CanTransfer(baseEntity) && PendingEntities.Add(baseEntity))
			{
				TransferAndWait();
			}
		}
		async void TransferAndWait()
		{
			try
			{
				await NexusServer.TransferEntity(entity, zoneKey, method);
			}
			finally
			{
				PendingEntities.Remove(entity);
			}
		}
	}
}


using UnityEngine;

public class PlayerIdleAnimationRandomiser : StateMachineBehaviour
{
	public int MaxValue = 3;

	public static int Param_Random = Animator.StringToHash("Random Idle");

	private TimeSince lastRandomisation;
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using Rust;
using UnityEngine;

public class BaseFirework : BaseCombatEntity, IIgniteable
{
	public float fuseLength = 3f;

	public float activityLength = 10f;

	public const Flags Flag_Spent = Flags.Reserved8;

	public float corpseDuration = 15f;

	public bool limitActiveCount;

	[ServerVar]
	public static int maxActiveFireworks = 25;

	public static HashSet<BaseFirework> _activeFireworks = new HashSet<BaseFirework>();

	public bool IsLit()
	{
		return HasFlag(Flags.OnFire);
	}

	public bool IsExhausted()
	{
		return HasFlag(Flags.Reserved8);
	}

	public static int NumActiveFireworks()
	{
		return _activeFireworks.Count;
	}

	public virtual void TryLightFuse()
	{
		if (!IsExhausted() && !IsLit())
		{
			SetFlag(Flags.OnFire, b: true);
			EnableGlobalBroadcast(wants: true);
			((FacepunchBehaviour)this).Invoke((Action)Begin, fuseLength);
			pickup.enabled = false;
			EnableSaving(wants: false);
		}
	}

	public virtual void Begin()
	{
		SetFlag(Flags.OnFire, b: false);
		SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		Interface.CallHook("OnFireworkStarted", (object)this);
		((FacepunchBehaviour)this).Invoke((Action)OnExhausted, activityLength);
	}

	public virtual void OnExhausted()
	{
		SetFlag(Flags.Reserved8, b: true, recursive: false, networkupdate: false);
		SetFlag(Flags.OnFire, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
		EnableGlobalBroadcast(wants: false);
		SendNetworkUpdate_Flags();
		Interface.CallHook("OnFireworkExhausted", (object)this);
		((FacepunchBehaviour)this).Invoke((Action)Cleanup, corpseDuration);
		_activeFireworks.Remove(this);
	}

	public void Cleanup()
	{
		Kill();
	}

	internal override void DoServerDestroy()
	{
		_activeFireworks.Remove(this);
		base.DoServerDestroy();
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer && Interface.CallHook("OnFireworkDamage", (object)this, (object)info) == null && info.damageTypes.Has(DamageType.Heat))
		{
			StaggeredTryLightFuse();
		}
	}

	public void Ignite(Vector3 fromPos)
	{
		StaggeredTryLightFuse();
	}

	public void StaggeredTryLightFuse()
	{
		if (IsExhausted() || (IsLit() && _activeFireworks.Contains(this)))
		{
			return;
		}
		if (limitActiveCount)
		{
			if (NumActiveFireworks() >= maxActiveFireworks)
			{
				SetFlag(Flags.OnFire, b: true);
				((FacepunchBehaviour)this).Invoke((Action)StaggeredTryLightFuse, 0.35f);
				return;
			}
			_activeFireworks.Add(this);
			SetFlag(Flags.OnFire, b: false, recursive: false, networkupdate: false);
		}
		((FacepunchBehaviour)this).Invoke((Action)TryLightFuse, Random.Range(0.1f, 0.3f));
	}

	public bool CanIgnite()
	{
		if (!IsExhausted())
		{
			return !IsLit();
		}
		return false;
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (!IsExhausted() && !IsLit() && !IsOn())
		{
			return base.ShouldDisplayPickupOption(player);
		}
		return false;
	}
}


using UnityEngine;

public class FireworkShell : BaseMonoBehaviour, IClientComponent
{
	public float fuseLengthMin;

	public float fuseLengthMax;

	public float speedMin;

	public float speedMax;

	public ParticleSystem explodePFX;

	public SoundPlayer explodeSound;

	public float inaccuracyDegrees;

	public LightEx explosionLight;

	public float lifetime = 8f;
}


using UnityEngine;

public class MortarFirework : RepeatingFirework
{
	public GameObjectRef[] shellTypes;

	public Transform emissionPoint;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class PatternFirework : MortarFirework, IUGCBrowserEntity
{
	public enum FuseLength
	{
		Short = 0,
		Medium = 1,
		Long = 2,
		Max = 2
	}

	public const int CurrentVersion = 1;

	[Header("PatternFirework")]
	public GameObjectRef FireworkDesignerDialog;

	public int MaxStars = 25;

	public float ShellFuseLengthShort = 3f;

	public float ShellFuseLengthMed = 5.5f;

	public float ShellFuseLengthLong = 8f;

	[NonSerialized]
	public Design Design;

	[NonSerialized]
	public FuseLength ShellFuseLength;

	public uint[] GetContentCRCs
	{
		get
		{
			if (Design == null || Design.stars.Count <= 0)
			{
				return Array.Empty<uint>();
			}
			return new uint[1] { 1u };
		}
	}

	public UGCType ContentType => UGCType.PatternBoomer;

	public List<ulong> EditingHistory
	{
		get
		{
			if (Design == null)
			{
				return new List<ulong>();
			}
			return new List<ulong> { Design.editedBy };
		}
	}

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public override void DestroyShared()
	{
		base.DestroyShared();
		Design design = Design;
		if (design != null)
		{
			design.Dispose();
		}
		Design = null;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ShellFuseLength = FuseLength.Medium;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	private void StartOpenDesigner(RPCMessage rpc)
	{
		if (PlayerCanModify(rpc.player))
		{
			ClientRPC(RpcTarget.Player("OpenDesigner", rpc.player));
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	private void ServerSetFireworkDesign(RPCMessage rpc)
	{
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		if (!PlayerCanModify(rpc.player))
		{
			return;
		}
		Design val = rpc.read.Proto<Design>((Design)null);
		if (Interface.CallHook("OnFireworkDesignChange", (object)this, (object)val, (object)rpc.player) != null)
		{
			return;
		}
		if (val?.stars != null)
		{
			while (val.stars.Count > MaxStars)
			{
				int index = val.stars.Count - 1;
				val.stars[index].Dispose();
				val.stars.RemoveAt(index);
			}
			foreach (Star star in val.stars)
			{
				star.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));
				star.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);
			}
			val.editedBy = rpc.player.userID;
		}
		Design design = Design;
		if (design != null)
		{
			design.Dispose();
		}
		Design = val;
		Interface.CallHook("OnFireworkDesignChanged", (object)this, (object)val, (object)rpc.player);
		SendNetworkUpdateImmediate();
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void SetShellFuseLength(RPCMessage rpc)
	{
		if (PlayerCanModify(rpc.player))
		{
			ShellFuseLength = (FuseLength)Mathf.Clamp(rpc.read.Int32(), 0, 2);
			SendNetworkUpdateImmediate();
		}
	}

	private bool PlayerCanModify(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null || !player.CanInteract())
		{
			return false;
		}
		object obj = Interface.CallHook("CanDesignFirework", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
		if ((Object)(object)buildingPrivilege != (Object)null && !buildingPrivilege.CanAdministrate(player))
		{
			return false;
		}
		return true;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.patternFirework = Pool.Get<PatternFirework>();
		PatternFirework patternFirework = info.msg.patternFirework;
		Design design = Design;
		patternFirework.design = ((design != null) ? design.Copy() : null);
		info.msg.patternFirework.shellFuseLength = (int)ShellFuseLength;
	}

	public void ClearContent()
	{
		Design design = Design;
		if (design != null)
		{
			design.Dispose();
		}
		Design = null;
		SendNetworkUpdateImmediate();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.patternFirework != null)
		{
			Design design = Design;
			if (design != null)
			{
				design.Dispose();
			}
			Design design2 = info.msg.patternFirework.design;
			Design = ((design2 != null) ? design2.Copy() : null);
			ShellFuseLength = (FuseLength)info.msg.patternFirework.shellFuseLength;
		}
	}

	public float GetShellFuseLength()
	{
		return ShellFuseLength switch
		{
			FuseLength.Short => ShellFuseLengthShort, 
			FuseLength.Medium => ShellFuseLengthMed, 
			FuseLength.Long => ShellFuseLengthLong, 
			_ => ShellFuseLengthMed, 
		};
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PatternFirework.OnRpcMessage", 0);
		try
		{
			if (rpc == 3850129568u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSetFireworkDesign "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSetFireworkDesign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3850129568u, "ServerSetFireworkDesign", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3850129568u, "ServerSetFireworkDesign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							ServerSetFireworkDesign(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerSetFireworkDesign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2132764204 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetShellFuseLength "));
				}
				TimeWarning val2 = TimeWarning.New("SetShellFuseLength", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2132764204u, "SetShellFuseLength", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2132764204u, "SetShellFuseLength", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage shellFuseLength = rPCMessage;
							SetShellFuseLength(shellFuseLength);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SetShellFuseLength");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2760408151u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartOpenDesigner "));
				}
				TimeWarning val2 = TimeWarning.New("StartOpenDesigner", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2760408151u, "StartOpenDesigner", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2760408151u, "StartOpenDesigner", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							StartOpenDesigner(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in StartOpenDesigner");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


public enum FuseLength
{
	Short = 0,
	Medium = 1,
	Long = 2,
	Max = 2
}


using UnityEngine;

public class PatternFireworkShell : FireworkShell
{
	public GameObjectRef StarPrefab;

	public AnimationCurve StarCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float Duration = 3f;

	public float Scale = 5f;

	[Header("Random Design")]
	[MinMax(0f, 1f)]
	public MinMax RandomSaturation = new MinMax(0f, 0.5f);

	[MinMax(0f, 1f)]
	public MinMax RandomValue = new MinMax(0.5f, 0.75f);
}


using UnityEngine;

public class PatternFireworkStar : MonoBehaviour, IClientComponent
{
	public GameObject Pixel;

	public GameObject Explosion;

	public ParticleSystem[] ParticleSystems;

	public void Initialize(Color color)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Pixel != (Object)null)
		{
			Pixel.SetActive(true);
		}
		if ((Object)(object)Explosion != (Object)null)
		{
			Explosion.SetActive(false);
		}
		if (ParticleSystems == null)
		{
			return;
		}
		ParticleSystem[] particleSystems = ParticleSystems;
		foreach (ParticleSystem val in particleSystems)
		{
			if (!((Object)(object)val == (Object)null))
			{
				MainModule main = val.main;
				((MainModule)(ref main)).startColor = new MinMaxGradient(color);
			}
		}
	}

	public void Explode()
	{
		if ((Object)(object)Pixel != (Object)null)
		{
			Pixel.SetActive(false);
		}
		if ((Object)(object)Explosion != (Object)null)
		{
			Explosion.SetActive(true);
		}
	}
}


public class PFXRepeatingFirework : RepeatingFirework
{
	public ParticleSystemContainer pfx;
}


using System;
using Network;

public class RepeatingFirework : BaseFirework
{
	public float timeBetweenRepeats = 1f;

	public int maxRepeats = 12;

	public SoundPlayer launchSound;

	private int numFired;

	public override void Begin()
	{
		base.Begin();
		((FacepunchBehaviour)this).InvokeRepeating((Action)SendFire, 0f, timeBetweenRepeats);
		((FacepunchBehaviour)this).CancelInvoke((Action)OnExhausted);
	}

	public void SendFire()
	{
		ClientRPC(RpcTarget.NetworkGroup("RPCFire"));
		numFired++;
		if (numFired >= maxRepeats)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SendFire);
			numFired = 0;
			OnExhausted();
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RepeatingFirework.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class FogMachine : ContainerIOEntity, IAlwaysOn
{
	public const Flags FogFieldOn = Flags.Reserved10;

	public const Flags MotionMode = Flags.Reserved9;

	public const Flags Emitting = Flags.Reserved6;

	public const Flags Flag_HasJuice = Flags.Reserved5;

	public const Flags AlwaysOn = Flags.Reserved11;

	public float fogLength = 60f;

	public float nozzleBlastDuration = 5f;

	public float fuelPerSec = 1f;

	public TriggerBase motionTrigger;

	private BuildingPrivlidge _cachedTc;

	private float _cacheTimeout;

	private float pendingFuel;

	public bool IsEmitting()
	{
		return HasFlag(Flags.Reserved6);
	}

	public bool HasJuice()
	{
		return HasFlag(Flags.Reserved5);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SetFogOn(RPCMessage msg)
	{
		if (!IsEmitting() && !IsOn() && HasFuel() && msg.player.CanBuild())
		{
			SetFlag(Flags.On, b: true);
			((FacepunchBehaviour)this).InvokeRepeating((Action)StartFogging, 0f, fogLength - 1f);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SetFogOff(RPCMessage msg)
	{
		if (IsOn() && msg.player.CanBuild())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)StartFogging);
			SetFlag(Flags.On, b: false);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SetMotionDetection(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (msg.player.CanBuild())
		{
			SetFlag(Flags.Reserved9, flag);
			if (flag)
			{
				SetFlag(Flags.On, b: false);
			}
			UpdateMotionMode();
		}
	}

	public void UpdateMotionMode()
	{
		if (HasFlag(Flags.Reserved9))
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)CheckTrigger, Random.Range(0f, 1.5f), 1f, 0.5f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckTrigger);
		}
	}

	public void CheckTrigger()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		if (IsEmitting() || (Object)(object)motionTrigger == (Object)null || !motionTrigger.HasAnyEntityContents)
		{
			return;
		}
		BuildingPrivlidge cachedTc = GetCachedTc();
		Vector3 targetPos = ((Component)this).transform.position + Vector3.up * 0.1f;
		foreach (BaseEntity entityContent in motionTrigger.entityContents)
		{
			BasePlayer basePlayer = entityContent as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsSleeping() && basePlayer.IsAlive() && ((Object)(object)cachedTc == (Object)null || !cachedTc.IsAuthed(basePlayer)) && basePlayer.CanSee(basePlayer.eyes.position, targetPos))
			{
				StartFogging();
				break;
			}
		}
	}

	private BuildingPrivlidge GetCachedTc()
	{
		if ((Object)(object)_cachedTc != (Object)null && _cachedTc.IsDestroyed)
		{
			_cachedTc = null;
		}
		if ((Object)(object)_cachedTc == (Object)null || Time.realtimeSinceStartup > _cacheTimeout)
		{
			_cachedTc = null;
			BuildingManager.Building building = GetBuilding();
			if (building != null)
			{
				_cachedTc = building.GetDominatingBuildingPrivilege();
			}
			if ((Object)(object)_cachedTc == (Object)null)
			{
				return GetNearestBuildingPrivilege(cached: true, 10f);
			}
			_cacheTimeout = Time.realtimeSinceStartup + 3f;
		}
		return _cachedTc;
	}

	public void StartFogging()
	{
		if (!UseFuel(1f))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)StartFogging);
			SetFlag(Flags.On, b: false);
			return;
		}
		SetFlag(Flags.Reserved6, b: true);
		((FacepunchBehaviour)this).Invoke((Action)EnableFogField, 1f);
		((FacepunchBehaviour)this).Invoke((Action)DisableNozzle, nozzleBlastDuration);
		((FacepunchBehaviour)this).Invoke((Action)FinishFogging, fogLength);
	}

	public virtual void EnableFogField()
	{
		SetFlag(Flags.Reserved10, b: true);
	}

	public void DisableNozzle()
	{
		SetFlag(Flags.Reserved6, b: false);
	}

	public virtual void FinishFogging()
	{
		SetFlag(Flags.Reserved10, b: false);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved10, b: false);
		SetFlag(Flags.Reserved6, b: false);
		SetFlag(Flags.Reserved5, HasFuel());
		if (IsOn())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)StartFogging, 0f, fogLength - 1f);
		}
		UpdateMotionMode();
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		SetFlag(Flags.Reserved5, HasFuel());
		base.PlayerStoppedLooting(player);
	}

	public int GetFuelAmount()
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		return slot.amount;
	}

	public bool HasFuel()
	{
		if (IsAlwaysOn())
		{
			return true;
		}
		return GetFuelAmount() >= 1;
	}

	public bool UseFuel(float seconds)
	{
		if (IsAlwaysOn())
		{
			return true;
		}
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return false;
		}
		pendingFuel += seconds * fuelPerSec;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			Analytics.Azure.AddPendingItems(this, slot.info.shortname, num, "fog");
			pendingFuel -= num;
		}
		return true;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		bool flag = false;
		switch (inputSlot)
		{
		case 0:
			flag = inputAmount > 0;
			break;
		case 1:
			if (inputAmount == 0)
			{
				return;
			}
			flag = true;
			break;
		case 2:
			if (inputAmount == 0)
			{
				return;
			}
			flag = false;
			break;
		}
		if (flag)
		{
			if (!IsEmitting() && !IsOn() && HasFuel())
			{
				SetFlag(Flags.On, b: true);
				((FacepunchBehaviour)this).InvokeRepeating((Action)StartFogging, 0f, fogLength - 1f);
			}
		}
		else if (IsOn())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)StartFogging);
			SetFlag(Flags.On, b: false);
		}
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public virtual bool IsAlwaysOn()
	{
		if (HasFlag(Flags.Reserved11))
		{
			return Creative.alwaysOnEnabled;
		}
		return false;
	}

	public void SetAlwaysOn(bool flag)
	{
		SetFlag(Flags.Reserved11, flag);
		AlwaysOnToggled(flag);
	}

	public void AlwaysOnToggled(bool flag)
	{
		if (flag)
		{
			if (!IsEmitting() && !IsOn() && HasFuel())
			{
				SetFlag(Flags.On, b: true);
				((FacepunchBehaviour)this).InvokeRepeating((Action)StartFogging, 0f, fogLength - 1f);
			}
		}
		else if (IsOn())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)StartFogging);
			SetFlag(Flags.On, b: false);
		}
	}

	public virtual bool MotionModeEnabled()
	{
		return true;
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("FogMachine.OnRpcMessage", 0);
		try
		{
			if (rpc == 2788115565u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetFogOff "));
				}
				TimeWarning val2 = TimeWarning.New("SetFogOff", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2788115565u, "SetFogOff", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage fogOff = rPCMessage;
							SetFogOff(fogOff);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetFogOff");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3905831928u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetFogOn "));
				}
				TimeWarning val2 = TimeWarning.New("SetFogOn", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3905831928u, "SetFogOn", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage fogOn = rPCMessage;
							SetFogOn(fogOn);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SetFogOn");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1773639087 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetMotionDetection "));
				}
				TimeWarning val2 = TimeWarning.New("SetMotionDetection", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1773639087u, "SetMotionDetection", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage motionDetection = rPCMessage;
							SetMotionDetection(motionDetection);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SetMotionDetection");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


using System;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class StrobeLight : IOEntity
{
	public float frequency;

	public MeshRenderer lightMesh;

	public Light strobeLight;

	private float speedSlow = 10f;

	private float speedMed = 20f;

	private float speedFast = 40f;

	public float burnRate = 10f;

	public float lifeTimeSeconds = 21600f;

	public const Flags Flag_Slow = Flags.Reserved6;

	public const Flags Flag_Med = Flags.Reserved7;

	public const Flags Flag_Fast = Flags.Reserved8;

	private int currentSpeed = 1;

	public float GetFrequency()
	{
		if (HasFlag(Flags.Reserved6))
		{
			return speedSlow;
		}
		if (HasFlag(Flags.Reserved7))
		{
			return speedMed;
		}
		if (HasFlag(Flags.Reserved8))
		{
			return speedFast;
		}
		return speedSlow;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SetStrobe(RPCMessage msg)
	{
		bool strobe = msg.read.Bit();
		SetStrobe(strobe);
	}

	private void SetStrobe(bool wantsOn)
	{
		ServerEnableStrobing(wantsOn);
		if (wantsOn)
		{
			UpdateSpeedFlags();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SetStrobeSpeed(RPCMessage msg)
	{
		int num = msg.read.Int32();
		currentSpeed = num;
		UpdateSpeedFlags();
	}

	public void UpdateSpeedFlags()
	{
		SetFlag(Flags.Reserved6, currentSpeed == 1);
		SetFlag(Flags.Reserved7, currentSpeed == 2);
		SetFlag(Flags.Reserved8, currentSpeed == 3);
	}

	public void ServerEnableStrobing(bool wantsOn)
	{
		SetFlag(Flags.Reserved6, b: false);
		SetFlag(Flags.Reserved7, b: false);
		SetFlag(Flags.Reserved8, b: false);
		SetFlag(Flags.On, wantsOn);
		SendNetworkUpdateImmediate();
		UpdateSpeedFlags();
		if (wantsOn)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)SelfDamage, 0f, 10f, 0.1f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SelfDamage);
		}
	}

	public void SelfDamage()
	{
		float num = burnRate / lifeTimeSeconds;
		Hurt(num * MaxHealth(), DamageType.Decay, this, useProtection: false);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		bool strobe = false;
		switch (inputSlot)
		{
		case 0:
			strobe = inputAmount > 0;
			break;
		case 1:
			if (inputAmount == 0)
			{
				return;
			}
			strobe = true;
			break;
		case 2:
			if (inputAmount == 0)
			{
				return;
			}
			strobe = false;
			break;
		}
		SetStrobe(strobe);
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StrobeLight.OnRpcMessage", 0);
		try
		{
			if (rpc == 1433326740 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetStrobe "));
				}
				TimeWarning val2 = TimeWarning.New("SetStrobe", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1433326740u, "SetStrobe", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage strobe = rPCMessage;
							SetStrobe(strobe);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetStrobe");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1814332702 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetStrobeSpeed "));
				}
				TimeWarning val2 = TimeWarning.New("SetStrobeSpeed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1814332702u, "SetStrobeSpeed", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage strobeSpeed = rPCMessage;
							SetStrobeSpeed(strobeSpeed);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SetStrobeSpeed");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class CoalingTower : IOEntity, INotifyEntityTrigger
{
	public enum ActionAttemptStatus
	{
		NoError,
		GenericError,
		NoTrainCar,
		NoNextTrainCar,
		NoPrevTrainCar,
		TrainIsMoving,
		OutputIsFull,
		AlreadyShunting,
		TrainHasThrottle
	}

	[SerializeField]
	[Header("Coaling Tower")]
	private BoxCollider unloadingBounds;

	[SerializeField]
	private GameObjectRef oreStoragePrefab;

	[SerializeField]
	private GameObjectRef fuelStoragePrefab;

	[SerializeField]
	private MeshRenderer[] signalLightsExterior;

	[SerializeField]
	private MeshRenderer[] signalLightsInterior;

	[ColorUsage(false, true)]
	public Color greenLightOnColour;

	[ColorUsage(false, true)]
	public Color yellowLightOnColour;

	[SerializeField]
	private Animator vacuumAnimator;

	[SerializeField]
	private float vacuumStartDelay = 2f;

	[SerializeField]
	[FormerlySerializedAs("unloadingFXContainer")]
	private ParticleSystemContainer unloadingFXContainerOre;

	[SerializeField]
	private ParticleSystem[] unloadingFXMain;

	[SerializeField]
	private ParticleSystem[] unloadingFXDust;

	[SerializeField]
	private ParticleSystemContainer unloadingFXContainerFuel;

	[SerializeField]
	[Header("Coaling Tower Text")]
	private TokenisedPhrase noTraincar;

	[SerializeField]
	private TokenisedPhrase noNextTraincar;

	[SerializeField]
	private TokenisedPhrase noPrevTraincar;

	[SerializeField]
	private TokenisedPhrase trainIsMoving;

	[SerializeField]
	private TokenisedPhrase outputIsFull;

	[SerializeField]
	private TokenisedPhrase trainHasThrottle;

	[SerializeField]
	[Header("Coaling Tower Audio")]
	private GameObject buttonSoundPos;

	[SerializeField]
	private SoundDefinition buttonPressSound;

	[SerializeField]
	private SoundDefinition buttonReleaseSound;

	[SerializeField]
	private SoundDefinition failedActionSound;

	[SerializeField]
	private SoundDefinition failedShuntAlarmSound;

	[SerializeField]
	private SoundDefinition armMovementLower;

	[SerializeField]
	private SoundDefinition armMovementRaise;

	[SerializeField]
	private SoundDefinition suctionAirStart;

	[SerializeField]
	private SoundDefinition suctionAirStop;

	[SerializeField]
	private SoundDefinition suctionAirLoop;

	[SerializeField]
	private SoundDefinition suctionOreStart;

	[SerializeField]
	private SoundDefinition suctionOreLoop;

	[SerializeField]
	private SoundDefinition suctionOreStop;

	[SerializeField]
	private SoundDefinition suctionOreInteriorLoop;

	[SerializeField]
	private SoundDefinition oreBinLoop;

	[SerializeField]
	private SoundDefinition suctionFluidStart;

	[SerializeField]
	private SoundDefinition suctionFluidLoop;

	[SerializeField]
	private SoundDefinition suctionFluidStop;

	[SerializeField]
	private SoundDefinition suctionFluidInteriorLoop;

	[SerializeField]
	private SoundDefinition fluidTankLoop;

	[SerializeField]
	private GameObject interiorPipeSoundLocation;

	[SerializeField]
	private GameObject armMovementSoundLocation;

	[SerializeField]
	private GameObject armSuctionSoundLocation;

	[SerializeField]
	private GameObject oreBinSoundLocation;

	[SerializeField]
	private GameObject fluidTankSoundLocation;

	private NetworkedProperty<int> LootTypeIndex;

	private EntityRef<TrainCar> activeTrainCarRef;

	private EntityRef<TrainCarUnloadable> activeUnloadableRef;

	private const Flags LinedUpFlag = Flags.Reserved2;

	private const Flags HasUnloadableFlag = Flags.Reserved1;

	private const Flags UnloadingInProgressFlag = Flags.Busy;

	private const Flags MoveToNextInProgressFlag = Flags.Reserved3;

	private const Flags MoveToPrevInProgressFlag = Flags.Reserved4;

	private EntityRef<OreHopper> oreStorageInstance;

	private EntityRef<PercentFullStorageContainer> fuelStorageInstance;

	public const float TIME_TO_EMPTY = 40f;

	private static List<CoalingTower> unloadersInWorld = new List<CoalingTower>();

	private Sound armMovementLoopSound;

	private Sound suctionAirLoopSound;

	private Sound suctionMaterialLoopSound;

	private Sound interiorPipeLoopSound;

	private Sound unloadDestinationSound;

	private TrainCarUnloadable tcUnloadingNow;

	private bool HasTrainCar => activeTrainCarRef.IsValid(base.isServer);

	private bool HasUnloadable => activeUnloadableRef.IsValid(base.isServer);

	private bool HasUnloadableLinedUp => HasFlag(Flags.Reserved2);

	public Vector3 UnloadingPos { get; private set; }

	public override void InitShared()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		LootTypeIndex = new NetworkedProperty<int>(this);
		UnloadingPos = ((Component)unloadingBounds).transform.position + ((Component)unloadingBounds).transform.rotation * unloadingBounds.center;
		unloadersInWorld.Add(this);
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		unloadersInWorld.Remove(this);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.coalingTower != null)
		{
			LootTypeIndex.Value = info.msg.coalingTower.lootTypeIndex;
			oreStorageInstance.uid = info.msg.coalingTower.oreStorageID;
			fuelStorageInstance.uid = info.msg.coalingTower.fuelStorageID;
		}
	}

	public static bool IsUnderAnUnloader(TrainCar trainCar, out bool isLinedUp, out Vector3 unloaderPos)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		foreach (CoalingTower item in unloadersInWorld)
		{
			if (item.TrainCarIsUnder(trainCar, out isLinedUp))
			{
				unloaderPos = item.UnloadingPos;
				return true;
			}
		}
		isLinedUp = false;
		unloaderPos = Vector3.zero;
		return false;
	}

	public bool TrainCarIsUnder(TrainCar trainCar, out bool isLinedUp)
	{
		isLinedUp = false;
		if (!trainCar.IsValid())
		{
			return false;
		}
		TrainCarUnloadable activeUnloadable = GetActiveUnloadable();
		if ((Object)(object)activeUnloadable != (Object)null && activeUnloadable.EqualNetID((BaseNetworkable)trainCar))
		{
			isLinedUp = HasUnloadableLinedUp;
			return true;
		}
		return false;
	}

	private OreHopper GetOreStorage()
	{
		OreHopper oreHopper = oreStorageInstance.Get(base.isServer);
		if (oreHopper.IsValid())
		{
			return oreHopper;
		}
		return null;
	}

	private PercentFullStorageContainer GetFuelStorage()
	{
		PercentFullStorageContainer percentFullStorageContainer = fuelStorageInstance.Get(base.isServer);
		if (percentFullStorageContainer.IsValid())
		{
			return percentFullStorageContainer;
		}
		return null;
	}

	private TrainCar GetActiveTrainCar()
	{
		TrainCar trainCar = activeTrainCarRef.Get(base.isServer);
		if (trainCar.IsValid())
		{
			return trainCar;
		}
		return null;
	}

	private TrainCarUnloadable GetActiveUnloadable()
	{
		TrainCarUnloadable trainCarUnloadable = activeUnloadableRef.Get(base.isServer);
		if (trainCarUnloadable.IsValid())
		{
			return trainCarUnloadable;
		}
		return null;
	}

	private bool OutputBinIsFull()
	{
		TrainCarUnloadable activeUnloadable = GetActiveUnloadable();
		if ((Object)(object)activeUnloadable == (Object)null)
		{
			return false;
		}
		switch (activeUnloadable.wagonType)
		{
		case TrainCarUnloadable.WagonType.Lootboxes:
			return false;
		case TrainCarUnloadable.WagonType.Fuel:
		{
			PercentFullStorageContainer fuelStorage = GetFuelStorage();
			if (!((Object)(object)fuelStorage != (Object)null))
			{
				return false;
			}
			return fuelStorage.IsFull();
		}
		default:
		{
			OreHopper oreStorage = GetOreStorage();
			if (!((Object)(object)oreStorage != (Object)null))
			{
				return false;
			}
			return oreStorage.IsFull();
		}
		}
	}

	private bool WagonIsEmpty()
	{
		TrainCarUnloadable activeUnloadable = GetActiveUnloadable();
		if ((Object)(object)activeUnloadable != (Object)null)
		{
			return activeUnloadable.GetOrePercent() == 0f;
		}
		return true;
	}

	private bool CanUnloadNow(out ActionAttemptStatus attemptStatus)
	{
		if (!HasUnloadableLinedUp)
		{
			attemptStatus = ActionAttemptStatus.NoTrainCar;
			return false;
		}
		if (OutputBinIsFull())
		{
			attemptStatus = ActionAttemptStatus.OutputIsFull;
			return false;
		}
		attemptStatus = ActionAttemptStatus.NoError;
		return IsPowered();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.coalingTower = Pool.Get<CoalingTower>();
		info.msg.coalingTower.lootTypeIndex = LootTypeIndex;
		info.msg.coalingTower.oreStorageID = oreStorageInstance.uid;
		info.msg.coalingTower.fuelStorageID = fuelStorageInstance.uid;
		info.msg.coalingTower.activeUnloadableID = activeTrainCarRef.uid;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Busy, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate();
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer)
		{
			if (child.prefabID == oreStoragePrefab.GetEntity().prefabID)
			{
				oreStorageInstance.Set((OreHopper)child);
			}
			else if (child.prefabID == fuelStoragePrefab.GetEntity().prefabID)
			{
				fuelStorageInstance.Set((PercentFullStorageContainer)child);
			}
		}
	}

	public void OnEmpty()
	{
		ClearActiveTrainCar();
	}

	public void OnEntityEnter(BaseEntity ent)
	{
		if (ent.IsValid() && !ent.isClient)
		{
			TrainCar trainCar = ent as TrainCar;
			if ((Object)(object)trainCar != (Object)null)
			{
				SetActiveTrainCar(trainCar);
			}
		}
	}

	public void OnEntityLeave(BaseEntity ent)
	{
		if (ent.IsValid() && !ent.isClient)
		{
			BaseEntity baseEntity = ent.parentEntity.Get(base.isServer);
			TrainCar trainCar = activeTrainCarRef.Get(serverside: true);
			if ((Object)(object)trainCar == (Object)(object)ent && (Object)(object)trainCar != (Object)(object)baseEntity)
			{
				ClearActiveTrainCar();
			}
		}
	}

	private void SetActiveTrainCar(TrainCar trainCar)
	{
		if (!((Object)(object)GetActiveTrainCar() == (Object)(object)trainCar))
		{
			activeTrainCarRef.Set(trainCar);
			if (trainCar is TrainCarUnloadable entity)
			{
				activeUnloadableRef.Set(entity);
			}
			else
			{
				activeUnloadableRef.Set(null);
			}
			bool num = activeUnloadableRef.IsValid(serverside: true);
			CheckWagonLinedUp(networkUpdate: false);
			if (num)
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)CheckWagonLinedUp, 0.15f, 0.15f, 0.015f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)CheckWagonLinedUp);
			}
			SendNetworkUpdate();
		}
	}

	private void ClearActiveTrainCar()
	{
		SetActiveTrainCar(null);
	}

	private void CheckWagonLinedUp()
	{
		CheckWagonLinedUp(networkUpdate: true);
	}

	private void CheckWagonLinedUp(bool networkUpdate)
	{
		bool b = false;
		TrainCarUnloadable activeUnloadable = GetActiveUnloadable();
		if ((Object)(object)activeUnloadable != (Object)null)
		{
			b = activeUnloadable.IsLinedUpToUnload(unloadingBounds);
		}
		SetFlag(Flags.Reserved2, b, recursive: false, networkUpdate);
	}

	private bool TryUnloadActiveWagon(out ActionAttemptStatus attemptStatus)
	{
		TrainCarUnloadable activeUnloadable = GetActiveUnloadable();
		if ((Object)(object)activeUnloadable == (Object)null)
		{
			attemptStatus = ActionAttemptStatus.NoTrainCar;
			return false;
		}
		_ = activeUnloadable.wagonType;
		if (!CanUnloadNow(out attemptStatus))
		{
			return false;
		}
		SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)WagonBeginUnloadAnim, vacuumStartDelay);
		return true;
	}

	private void WagonBeginUnloadAnim()
	{
		TrainCarUnloadable activeUnloadable = GetActiveUnloadable();
		if ((Object)(object)activeUnloadable == (Object)null)
		{
			SetFlag(Flags.Busy, b: false);
			return;
		}
		if (!activeUnloadable.TryGetLootType(out var lootOption))
		{
			SetFlag(Flags.Busy, b: false);
			return;
		}
		TrainWagonLootData.instance.TryGetIndexFromLoot(lootOption, out var index);
		LootTypeIndex.Value = index;
		tcUnloadingNow = activeUnloadable;
		tcUnloadingNow.BeginUnloadAnimation();
		float num = 4f;
		((FacepunchBehaviour)this).InvokeRepeating((Action)EmptyTenPercent, 0f, num);
	}

	private void EmptyTenPercent()
	{
		if (!IsPowered())
		{
			EndEmptyProcess(ActionAttemptStatus.GenericError);
			return;
		}
		if (!HasUnloadableLinedUp)
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		TrainCarUnloadable activeUnloadable = GetActiveUnloadable();
		if ((Object)(object)tcUnloadingNow == (Object)null || (Object)(object)activeUnloadable != (Object)(object)tcUnloadingNow)
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		StorageContainer storageContainer = tcUnloadingNow.GetStorageContainer();
		if (storageContainer.inventory == null || !TrainWagonLootData.instance.TryGetLootFromIndex(LootTypeIndex, out var lootOption))
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		bool flag = tcUnloadingNow.wagonType != TrainCarUnloadable.WagonType.Fuel;
		ItemContainer itemContainer = null;
		PercentFullStorageContainer percentFullStorageContainer = (flag ? GetOreStorage() : GetFuelStorage());
		if ((Object)(object)percentFullStorageContainer != (Object)null)
		{
			itemContainer = percentFullStorageContainer.inventory;
		}
		if (itemContainer == null)
		{
			EndEmptyProcess(ActionAttemptStatus.GenericError);
			return;
		}
		ItemContainer inventory = storageContainer.inventory;
		ItemContainer newcontainer = itemContainer;
		int iAmount = Mathf.RoundToInt((float)lootOption.maxLootAmount / 10f);
		List<Item> list = Pool.Get<List<Item>>();
		int num = inventory.Take(list, lootOption.lootItem.itemid, iAmount);
		bool flag2 = true;
		if (num > 0)
		{
			foreach (Item item in list)
			{
				if (tcUnloadingNow.wagonType == TrainCarUnloadable.WagonType.Lootboxes)
				{
					item.Remove();
					continue;
				}
				if (Interface.CallHook("OnCoalingTowerGather", (object)this, (object)item) != null)
				{
					item.Remove();
					continue;
				}
				bool flag3 = item.MoveToContainer(newcontainer);
				if (!flag2 || flag3)
				{
					continue;
				}
				item.MoveToContainer(inventory);
				flag2 = false;
				break;
			}
		}
		Pool.Free<Item>(ref list, false);
		float orePercent = tcUnloadingNow.GetOrePercent();
		if (orePercent == 0f)
		{
			EndEmptyProcess(ActionAttemptStatus.NoError);
		}
		else if (!flag2)
		{
			EndEmptyProcess(ActionAttemptStatus.OutputIsFull);
		}
		else if (flag)
		{
			tcUnloadingNow.SetVisualOreLevel(orePercent);
		}
	}

	private void EndEmptyProcess(ActionAttemptStatus status)
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)EmptyTenPercent);
		((FacepunchBehaviour)this).CancelInvoke((Action)WagonBeginUnloadAnim);
		if ((Object)(object)tcUnloadingNow != (Object)null)
		{
			tcUnloadingNow.EndEmptyProcess();
			tcUnloadingNow = null;
		}
		SetFlag(Flags.Busy, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate();
		if (status != 0)
		{
			ClientRPC(RpcTarget.NetworkGroup("ActionFailed"), (byte)status, arg2: false);
		}
	}

	private bool TryShuntTrain(bool next, out ActionAttemptStatus attemptStatus)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (!IsPowered() || HasFlag(Flags.Reserved3) || HasFlag(Flags.Reserved4))
		{
			attemptStatus = ActionAttemptStatus.GenericError;
			return false;
		}
		TrainCar activeTrainCar = GetActiveTrainCar();
		if ((Object)(object)activeTrainCar == (Object)null)
		{
			attemptStatus = ActionAttemptStatus.NoTrainCar;
			return false;
		}
		Vector3 unloadingPos = UnloadingPos;
		unloadingPos.y = 0f;
		TrainCar result;
		if (activeTrainCar is TrainCarUnloadable && !HasUnloadableLinedUp)
		{
			Vector3 position = ((Component)activeTrainCar).transform.position;
			Vector3 val = unloadingPos - position;
			if (Vector3.Dot(((Component)this).transform.forward, val) >= 0f == next)
			{
				result = activeTrainCar;
				goto IL_00ba;
			}
		}
		if (!activeTrainCar.TryGetTrainCar(next, ((Component)this).transform.forward, out result))
		{
			attemptStatus = (next ? ActionAttemptStatus.NoNextTrainCar : ActionAttemptStatus.NoPrevTrainCar);
			return false;
		}
		goto IL_00ba;
		IL_00ba:
		Vector3 position2 = ((Component)result).transform.position;
		position2.y = 0f;
		Vector3 shuntDirection = unloadingPos - position2;
		float magnitude = ((Vector3)(ref shuntDirection)).magnitude;
		return activeTrainCar.completeTrain.TryShuntCarTo(shuntDirection, magnitude, result, ShuntEnded, out attemptStatus);
	}

	private void ShuntEnded(ActionAttemptStatus status)
	{
		SetFlag(Flags.Reserved3, b: false);
		SetFlag(Flags.Reserved4, b: false);
		if (status != 0)
		{
			ClientRPC(RpcTarget.NetworkGroup("IssueDuringShunt"));
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Unload(RPCMessage msg)
	{
		if (Interface.CallHook("OnCoalingTowerStart", (object)this, (object)msg.player) == null && !TryUnloadActiveWagon(out var attemptStatus) && (Object)(object)msg.player != (Object)null)
		{
			ClientRPC(RpcTarget.Player("ActionFailed", msg.player), (byte)attemptStatus, arg2: true);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Next(RPCMessage msg)
	{
		if (TryShuntTrain(next: true, out var attemptStatus))
		{
			SetFlag(Flags.Reserved3, b: true);
		}
		else if ((Object)(object)msg.player != (Object)null)
		{
			ClientRPC(RpcTarget.Player("ActionFailed", msg.player), (byte)attemptStatus, arg2: true);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Prev(RPCMessage msg)
	{
		if (TryShuntTrain(next: false, out var attemptStatus))
		{
			SetFlag(Flags.Reserved4, b: true);
		}
		else if ((Object)(object)msg.player != (Object)null)
		{
			ClientRPC(RpcTarget.Player("ActionFailed", msg.player), (byte)attemptStatus, arg2: true);
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CoalingTower.OnRpcMessage", 0);
		try
		{
			if (rpc == 3071873383u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Next "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Next", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3071873383u, "RPC_Next", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Next(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Next");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3656312045u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Prev "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Prev", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3656312045u, "RPC_Prev", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_Prev(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Prev");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 998476828 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Unload "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Unload", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(998476828u, "RPC_Unload", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_Unload(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_Unload");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


public enum ActionAttemptStatus
{
	NoError,
	GenericError,
	NoTrainCar,
	NoNextTrainCar,
	NoPrevTrainCar,
	TrainIsMoving,
	OutputIsFull,
	AlreadyShunting,
	TrainHasThrottle
}


using System;
using UnityEngine;

public class OreHopper : PercentFullStorageContainer
{
	[SerializeField]
	private Transform oreOutputMesh;

	private float visualPercentFull;

	private Vector3 _oreScale = new Vector3(1f, 0f, 1f);

	protected override void OnPercentFullChanged(float newPercentFull)
	{
		VisualLerpToOreLevel();
	}

	private void SetVisualOreLevel(float percentFull)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		_oreScale.y = Mathf.Clamp01(percentFull);
		oreOutputMesh.localScale = _oreScale;
		((Component)oreOutputMesh).gameObject.SetActive(percentFull > 0f);
		visualPercentFull = percentFull;
	}

	public void VisualLerpToOreLevel()
	{
		if (GetPercentFull() != visualPercentFull)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)OreVisualLerpUpdate, 0f, 0f);
		}
	}

	private void OreVisualLerpUpdate()
	{
		float percentFull = GetPercentFull();
		if (Mathf.Abs(visualPercentFull - percentFull) < 0.005f)
		{
			SetVisualOreLevel(percentFull);
			((FacepunchBehaviour)this).CancelInvoke((Action)OreVisualLerpUpdate);
		}
		else
		{
			float visualOreLevel = Mathf.Lerp(visualPercentFull, percentFull, Time.deltaTime * 1.5f);
			SetVisualOreLevel(visualOreLevel);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetVisualOreLevel(GetPercentFull());
	}
}


using System.Collections;
using UnityEngine;
using UnityEngine.AI;

public class WaterBaseNavGenTest : MonoBehaviour
{
	private IEnumerator co;

	[ContextMenu("Nav Gen")]
	public void NavGen()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		DungeonNavmesh dungeonNavmesh = ((Component)this).gameObject.AddComponent<DungeonNavmesh>();
		dungeonNavmesh.NavmeshResolutionModifier = 0.3f;
		dungeonNavmesh.NavMeshCollectGeometry = (NavMeshCollectGeometry)1;
		dungeonNavmesh.LayerMask = LayerMask.op_Implicit(65537);
		co = dungeonNavmesh.UpdateNavMeshAndWait();
		((MonoBehaviour)this).StartCoroutine(co);
	}
}


using System;
using UnityEngine;

public class CargoMoveTest : FacepunchBehaviour
{
	public int targetNodeIndex = -1;

	private float currentThrottle;

	private float turnScale;

	private void Awake()
	{
		((FacepunchBehaviour)this).Invoke((Action)FindInitialNode, 2f);
	}

	public void FindInitialNode()
	{
		targetNodeIndex = GetClosestNodeToUs();
	}

	private void Update()
	{
		UpdateMovement();
	}

	public void UpdateMovement()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.Path.OceanPatrolFar == null || TerrainMeta.Path.OceanPatrolFar.Count == 0 || targetNodeIndex == -1)
		{
			return;
		}
		Vector3 val = TerrainMeta.Path.OceanPatrolFar[targetNodeIndex];
		float num = 0f;
		Vector3 val2 = val - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		float num2 = Vector3.Dot(((Component)this).transform.forward, normalized);
		num = Mathf.InverseLerp(0.5f, 1f, num2);
		float num3 = Vector3.Dot(((Component)this).transform.right, normalized);
		float num4 = 5f;
		float num5 = Mathf.InverseLerp(0.05f, 0.5f, Mathf.Abs(num3));
		turnScale = Mathf.Lerp(turnScale, num5, Time.deltaTime * 0.2f);
		float num6 = ((!(num3 < 0f)) ? 1 : (-1));
		((Component)this).transform.Rotate(Vector3.up, num4 * Time.deltaTime * turnScale * num6, (Space)0);
		currentThrottle = Mathf.Lerp(currentThrottle, num, Time.deltaTime * 0.2f);
		Transform transform = ((Component)this).transform;
		transform.position += ((Component)this).transform.forward * 5f * Time.deltaTime * currentThrottle;
		if (Vector3.Distance(((Component)this).transform.position, val) < 60f)
		{
			targetNodeIndex++;
			if (targetNodeIndex >= TerrainMeta.Path.OceanPatrolFar.Count)
			{
				targetNodeIndex = 0;
			}
		}
	}

	public int GetClosestNodeToUs()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		int result = 0;
		float num = float.PositiveInfinity;
		for (int i = 0; i < TerrainMeta.Path.OceanPatrolFar.Count; i++)
		{
			Vector3 val = TerrainMeta.Path.OceanPatrolFar[i];
			float num2 = Vector3.Distance(((Component)this).transform.position, val);
			if (num2 < num)
			{
				result = i;
				num = num2;
			}
		}
		return result;
	}

	public void OnDrawGizmosSelected()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.Path.OceanPatrolFar != null)
		{
			Gizmos.color = Color.red;
			Gizmos.DrawSphere(TerrainMeta.Path.OceanPatrolFar[targetNodeIndex], 10f);
			for (int i = 0; i < TerrainMeta.Path.OceanPatrolFar.Count; i++)
			{
				Vector3 val = TerrainMeta.Path.OceanPatrolFar[i];
				Gizmos.color = Color.green;
				Gizmos.DrawSphere(val, 3f);
				Vector3 val2 = ((i + 1 == TerrainMeta.Path.OceanPatrolFar.Count) ? TerrainMeta.Path.OceanPatrolFar[0] : TerrainMeta.Path.OceanPatrolFar[i + 1]);
				Gizmos.DrawLine(val, val2);
			}
		}
	}
}


using UnityEngine;

public class CargoNotifier : MonoBehaviour, IServerComponent
{
	[SerializeField]
	private BasePath cargoPath;

	private void Start()
	{
		CargoShip.RegisterHarbor(cargoPath, ((Component)((Component)this).transform.parent).transform);
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class CargoShip : BaseEntity
{
	public struct HarborInfo
	{
		public BasePath harborPath;

		public Transform harborTransform;

		public int approachNode;
	}

	public int targetNodeIndex = -1;

	public GameObject wakeParent;

	public GameObjectRef scientistTurretPrefab;

	public Transform[] scientistSpawnPoints;

	public List<Transform> crateSpawns;

	public GameObjectRef lockedCratePrefab;

	public GameObjectRef militaryCratePrefab;

	public GameObjectRef eliteCratePrefab;

	public GameObjectRef junkCratePrefab;

	public Transform waterLine;

	public Transform rudder;

	public Transform propeller;

	public GameObjectRef escapeBoatPrefab;

	public GameObjectRef primitiveEscapeBoatPrefab;

	public Transform escapeBoatPoint;

	public GameObjectRef microphonePrefab;

	public Transform microphonePoint;

	public GameObjectRef speakerPrefab;

	public Transform[] speakerPoints;

	public GameObject radiation;

	public GameObjectRef mapMarkerEntityPrefab;

	public GameObject hornOrigin;

	public SoundDefinition hornDef;

	public CargoShipSounds cargoShipSounds;

	public GameObject[] layouts;

	public GameObjectRef playerTest;

	public Transform bowPoint;

	private uint layoutChoice;

	public const Flags IsDocked = Flags.Reserved1;

	public const Flags HasDocked = Flags.Reserved2;

	public const Flags DockedHarborIndex0 = Flags.Reserved3;

	public const Flags DockedHarborIndex1 = Flags.Reserved4;

	public const Flags Egressing = Flags.Reserved8;

	[ServerVar]
	public static bool docking_debug = false;

	[ServerVar]
	public static bool should_dock = true;

	[ServerVar]
	public static float dock_time = 480f;

	[ServerVar]
	public static bool event_enabled = true;

	[ServerVar]
	public static float event_duration_minutes = 50f;

	[ServerVar]
	public static float egress_duration_minutes = 10f;

	[ServerVar]
	public static int loot_rounds = 3;

	[ServerVar]
	public static float loot_round_spacing_minutes = 10f;

	[ServerVar]
	public static bool refresh_loot_on_dock = true;

	[ServerVar]
	public static bool cargo_escape_boat_rhib = true;

	public static List<HarborInfo> harbors = new List<HarborInfo>();

	public int currentHarborApproachNode;

	public int harborIndex;

	public bool isDoingHarborApproach;

	private int dockCount;

	private bool shouldLookAhead;

	private float lifetime;

	private CargoShipContainerDestination[] containerDestinations;

	private HashSet<ulong> boardedPlayerIds = new HashSet<ulong>();

	public static bool hasCalculatedApproaches = false;

	public BaseEntity mapMarkerInstance;

	public Vector3 currentVelocity = Vector3.zero;

	public float currentThrottle;

	public float currentTurnSpeed;

	public float turnScale;

	public int lootRoundsPassed;

	public int hornCount;

	public float currentRadiation;

	public bool egressing;

	public BasePath harborApproachPath;

	public HarborProximityManager proxManager;

	private float lastSpeed = 0.3f;

	public bool IsShipDocked => HasFlag(Flags.Reserved1);

	public static int TotalAvailableHarborDockingPaths => harbors.Count;

	private bool HasFinishedDocking
	{
		get
		{
			if (!should_dock)
			{
				return true;
			}
			return dockCount == harbors.Count;
		}
	}

	private float EventTimeRemaining => event_duration_minutes * 60f - lifetime;

	public static List<Vector3> GetCargoApproachPath(int index)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (index >= TotalAvailableHarborDockingPaths)
		{
			return null;
		}
		CalculateHarborApproachNodes();
		List<Vector3> list = new List<Vector3>();
		list.Add(TerrainMeta.Path.OceanPatrolFar[harbors[index].approachNode]);
		foreach (BasePathNode node in harbors[index].harborPath.nodes)
		{
			list.Add(node.Position);
		}
		return list;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	[ServerVar]
	public static void debug_info(Arg arg)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Harbor Positions:");
		for (int i = 0; i < harbors.Count; i++)
		{
			stringBuilder.AppendLine($"harbor {i} is at {harbors[i].harborTransform.position.x}, {harbors[i].harborTransform.position.y}, {harbors[i].harborTransform.position.z}, approach index: {harbors[i].approachNode}");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void debug_cargo_status(Arg arg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is CargoShip cargoShip)
				{
					stringBuilder.AppendLine("Cargoship States:");
					stringBuilder.AppendLine("");
					stringBuilder.AppendLine($"Cargoship [{num}] dump");
					stringBuilder.AppendLine($"is at [{((Component)cargoShip).transform.position}]");
					stringBuilder.AppendLine($"dock count [{cargoShip.dockCount}]");
					stringBuilder.AppendLine($"is docked [{cargoShip.IsShipDocked}]");
					stringBuilder.AppendLine($"current approach node [{cargoShip.currentHarborApproachNode}]");
					stringBuilder.AppendLine($"is doing approach [{cargoShip.isDoingHarborApproach}]");
					stringBuilder.AppendLine($"chosen harbor is [{cargoShip.harborIndex}]");
					stringBuilder.AppendLine($"is egressing: {cargoShip.egressing}");
					arg.ReplyWith(stringBuilder.ToString());
					stringBuilder.Clear();
					num++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.cargoShip == null)
		{
			return;
		}
		layoutChoice = info.msg.cargoShip.layout;
		if (!base.isServer)
		{
			return;
		}
		isDoingHarborApproach = info.msg.cargoShip.isDoingHarborApproach;
		harborIndex = info.msg.cargoShip.harborIndex;
		CalculateHarborApproachNodes();
		if (isDoingHarborApproach && HasFlag(Flags.Reserved1))
		{
			((FacepunchBehaviour)this).Invoke((Action)LeaveHarbor, dock_time);
			((FacepunchBehaviour)this).Invoke((Action)PreHarborLeaveHorn, dock_time - 60f);
		}
		currentHarborApproachNode = info.msg.cargoShip.currentHarborApproachNode;
		dockCount = info.msg.cargoShip.dockCount;
		shouldLookAhead = info.msg.cargoShip.shouldLookAhead;
		lifetime = info.msg.cargoShip.lifetime;
		if (info.msg.cargoShip.isEgressing)
		{
			StartEgress();
		}
		if (HasFinishedDocking)
		{
			((FacepunchBehaviour)this).Invoke((Action)StartEgress, Mathf.Max(EventTimeRemaining, GetTimeRemainingFromCrates()));
		}
		if (HasFlag(Flags.Reserved1) && !((FacepunchBehaviour)this).IsInvoking((Action)LeaveHarbor))
		{
			((FacepunchBehaviour)this).Invoke((Action)LeaveHarbor, dock_time);
		}
		boardedPlayerIds.Clear();
		foreach (ulong playerId in info.msg.cargoShip.playerIds)
		{
			boardedPlayerIds.Add(playerId);
		}
	}

	public void RefreshActiveLayout()
	{
		for (int i = 0; i < layouts.Length; i++)
		{
			layouts[i].SetActive(layoutChoice == i);
		}
		if (base.isServer)
		{
			containerDestinations = ((Component)this).GetComponentsInChildren<CargoShipContainerDestination>();
		}
	}

	public static void RegisterHarbor(BasePath path, Transform tf)
	{
		harbors.Add(new HarborInfo
		{
			harborPath = path,
			harborTransform = tf
		});
		if (docking_debug)
		{
			Debug.Log((object)("Added " + ((Object)tf).name + " to harbor list"));
		}
	}

	public void TriggeredEventSpawn()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = TerrainMeta.RandomPointOffshore();
		val.y = WaterLevel.GetWaterSurface(val, waves: false, volumes: false);
		((Component)this).transform.position = val;
		if (should_dock)
		{
			CalculateHarborApproachNodes();
		}
		if (!event_enabled || event_duration_minutes == 0f)
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, 1f);
		}
	}

	public void TriggeredEventSpawnDockingTest(int index)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		if (harbors.Count <= 0 || !should_dock)
		{
			TriggeredEventSpawn();
			Debug.Log((object)"No harbors registered.");
			return;
		}
		if (harbors.Count <= 0 || index > harbors.Count - 1)
		{
			Debug.Log((object)"Wrong harbor index or no harbors on map.");
			return;
		}
		CalculateHarborApproachNodes();
		if (harbors.Count > 0)
		{
			if (harbors != null)
			{
				int approachNode = harbors[index].approachNode;
				Vector3 val = TerrainMeta.Path.OceanPatrolFar[approachNode + 5];
				val.y = WaterLevel.GetWaterSurface(val, waves: false, volumes: false);
				((Component)this).transform.position = val;
				((Component)this).transform.LookAt(harbors[index].harborPath.nodes[0].Position);
			}
			if (!event_enabled || event_duration_minutes == 0f)
			{
				((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, 1f);
			}
		}
	}

	private static void CalculateHarborApproachNodes()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if (hasCalculatedApproaches)
		{
			return;
		}
		hasCalculatedApproaches = true;
		for (int i = 0; i < harbors.Count; i++)
		{
			HarborInfo value = harbors[i];
			float num = float.MaxValue;
			int num2 = -1;
			for (int j = 0; j < TerrainMeta.Path.OceanPatrolFar.Count; j++)
			{
				Vector3 val = TerrainMeta.Path.OceanPatrolFar[j];
				Vector3 position = value.harborPath.nodes[0].Position;
				float num3 = Vector3.Distance(val, position);
				_ = docking_debug;
				float num4 = num3;
				Vector3 val2 = Vector3.up * 3f;
				if (!GamePhysics.LineOfSightRadius(val + val2, position + val2, 1084293377, 3f))
				{
					num4 *= 20f;
				}
				if (num4 < num)
				{
					num = num4;
					num2 = j;
				}
			}
			if (num2 == -1)
			{
				Debug.LogWarning((object)"Cargo couldn't find harbor approach node. Are you sure ocean paths have been generated?");
				break;
			}
			value.approachNode = num2;
			harbors[i] = value;
		}
	}

	public void OnArrivedAtHarbor()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Reserved1, b: true);
		List<Transform> list = Pool.Get<List<Transform>>();
		float num = Random.Range(dock_time * 0.05f, dock_time * 0.1f);
		Enumerator<HarborCraneContainerPickup> enumerator = HarborCraneContainerPickup.AllCranes.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				HarborCraneContainerPickup current = enumerator.Current;
				if ((Object)(object)current == (Object)null || current.isClient || current.Distance2D((BaseEntity)this) > 150f)
				{
					continue;
				}
				list.Clear();
				CargoShipContainerDestination[] array = containerDestinations;
				foreach (CargoShipContainerDestination cargoShipContainerDestination in array)
				{
					if (current.IsDestinationValidForCrane(cargoShipContainerDestination))
					{
						list.Add(((Component)cargoShipContainerDestination).transform);
					}
				}
				if (list.Count > 0)
				{
					current.AssignDestination(list, this, num);
					num += dock_time * Random.Range(0.1f, 0.15f);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Pool.FreeUnmanaged<Transform>(ref list);
		((FacepunchBehaviour)this).Invoke((Action)PreHarborLeaveHorn, dock_time - 60f);
		if (refresh_loot_on_dock)
		{
			RespawnLoot();
		}
		if (harborIndex == 0)
		{
			SetFlag(Flags.Reserved3, b: true);
		}
		else if (harborIndex == 1)
		{
			SetFlag(Flags.Reserved4, b: true);
		}
		((FacepunchBehaviour)this).Invoke((Action)LeaveHarbor, dock_time);
		Interface.CallHook("OnCargoShipHarborArrived", (object)this);
	}

	private void ClearAllHarborEntitiesOnShip()
	{
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		foreach (BaseEntity child in children)
		{
			if (child is CargoShipContainer)
			{
				list.Add(child);
			}
		}
		foreach (BaseEntity item in list)
		{
			item.Kill();
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public void CreateMapMarker()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)mapMarkerInstance))
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		mapMarkerInstance = baseEntity;
	}

	public void DisableCollisionTest()
	{
	}

	public void SpawnCrate(string resourcePath)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (crateSpawns.Count == 0)
		{
			return;
		}
		int index = Random.Range(0, crateSpawns.Count);
		Vector3 position = crateSpawns[index].position;
		Quaternion rotation = crateSpawns[index].rotation;
		crateSpawns.Remove(crateSpawns[index]);
		BaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, position, rotation);
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			baseEntity.enableSaving = false;
			((Component)baseEntity).SendMessage("SetWasDropped", (SendMessageOptions)1);
			baseEntity.Spawn();
			baseEntity.SetParent(this, worldPositionStays: true);
			Rigidbody component = ((Component)baseEntity).GetComponent<Rigidbody>();
			if ((Object)(object)component != (Object)null)
			{
				component.isKinematic = true;
			}
		}
	}

	public void RespawnLoot()
	{
		if (Interface.CallHook("OnCargoShipSpawnCrate", (object)this) == null)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)PlayHorn, 0f, 8f);
			SpawnCrate(lockedCratePrefab.resourcePath);
			SpawnCrate(eliteCratePrefab.resourcePath);
			for (int i = 0; i < 4; i++)
			{
				SpawnCrate(militaryCratePrefab.resourcePath);
			}
			for (int j = 0; j < 4; j++)
			{
				SpawnCrate(junkCratePrefab.resourcePath);
			}
			lootRoundsPassed++;
			if (lootRoundsPassed >= loot_rounds)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)RespawnLoot);
			}
		}
	}

	public void SpawnSubEntities()
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isLoadingSave)
		{
			string strPrefab = (cargo_escape_boat_rhib ? escapeBoatPrefab.resourcePath : primitiveEscapeBoatPrefab.resourcePath);
			BaseEntity baseEntity = GameManager.server.CreateEntity(strPrefab, escapeBoatPoint.position, escapeBoatPoint.rotation);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.SetParent(this, worldPositionStays: true);
				baseEntity.Spawn();
				RHIB component = ((Component)baseEntity).GetComponent<RHIB>();
				component.SetToKinematic();
				if (Object.op_Implicit((Object)(object)component))
				{
					component.AddFuel(50);
				}
			}
		}
		MicrophoneStand microphoneStand = GameManager.server.CreateEntity(microphonePrefab.resourcePath, microphonePoint.position, microphonePoint.rotation) as MicrophoneStand;
		if (Object.op_Implicit((Object)(object)microphoneStand))
		{
			microphoneStand.enableSaving = false;
			microphoneStand.SetParent(this, worldPositionStays: true);
			microphoneStand.Spawn();
			microphoneStand.SpawnChildEntity();
			IOEntity iOEntity = microphoneStand.ioEntity.Get(serverside: true);
			Transform[] array = speakerPoints;
			foreach (Transform val in array)
			{
				IOEntity iOEntity2 = GameManager.server.CreateEntity(speakerPrefab.resourcePath, val.position, val.rotation) as IOEntity;
				iOEntity2.enableSaving = false;
				iOEntity2.SetParent(this, worldPositionStays: true);
				iOEntity2.Spawn();
				iOEntity.outputs[0].connectedTo.Set(iOEntity2);
				iOEntity2.inputs[0].connectedTo.Set(iOEntity);
				iOEntity = iOEntity2;
			}
			microphoneStand.ioEntity.Get(serverside: true).MarkDirtyForceUpdateOutputs();
		}
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		base.OnChildAdded(child);
		if (!base.isServer)
		{
			return;
		}
		if (Application.isLoadingSave && child is RHIB rHIB)
		{
			Vector3 localPosition = ((Component)rHIB).transform.localPosition;
			Vector3 val = ((Component)this).transform.InverseTransformPoint(((Component)escapeBoatPoint).transform.position);
			if (Vector3.Distance(localPosition, val) < 1f)
			{
				rHIB.SetToKinematic();
			}
		}
		if (Application.isLoadingSave)
		{
			return;
		}
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		((Component)child).GetComponentsInChildren<BasePlayer>(list);
		foreach (BasePlayer item in list)
		{
			if (!item.IsBot && !item.IsNpc && item.IsConnected && boardedPlayerIds.Add(item.userID) && item.serverClan != null)
			{
				item.AddClanScore((ClanScoreEventType)9);
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.cargoShip = Pool.Get<CargoShip>();
		info.msg.cargoShip.layout = layoutChoice;
		info.msg.cargoShip.currentHarborApproachNode = currentHarborApproachNode;
		info.msg.cargoShip.isDoingHarborApproach = isDoingHarborApproach;
		info.msg.cargoShip.dockCount = dockCount;
		info.msg.cargoShip.shouldLookAhead = shouldLookAhead;
		info.msg.cargoShip.isEgressing = egressing;
		info.msg.cargoShip.harborIndex = harborIndex;
		if (!info.forDisk)
		{
			return;
		}
		info.msg.cargoShip.playerIds = Pool.Get<List<ulong>>();
		foreach (ulong boardedPlayerId in boardedPlayerIds)
		{
			info.msg.cargoShip.playerIds.Add(boardedPlayerId);
		}
		info.msg.cargoShip.lifetime = lifetime;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		RefreshActiveLayout();
	}

	public void PlayHorn()
	{
		ClientRPC(RpcTarget.NetworkGroup("DoHornSound"));
		hornCount++;
		if (hornCount >= 3)
		{
			hornCount = 0;
			((FacepunchBehaviour)this).CancelInvoke((Action)PlayHorn);
		}
	}

	public override void Spawn()
	{
		if (!Application.isLoadingSave)
		{
			layoutChoice = (uint)Random.Range(0, layouts.Length);
			SendNetworkUpdate();
			RefreshActiveLayout();
		}
		base.Spawn();
	}

	public override void ServerInit()
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		CalculateHarborApproachNodes();
		((FacepunchBehaviour)this).Invoke((Action)FindInitialNode, 2f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)BuildingCheck, 1f, 5f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)RespawnLoot, 10f, 60f * loot_round_spacing_minutes);
		((FacepunchBehaviour)this).Invoke((Action)DisableCollisionTest, 10f);
		float waterSurface = WaterLevel.GetWaterSurface(((Component)this).transform.position, waves: false, volumes: false);
		Vector3 val = ((Component)this).transform.InverseTransformPoint(((Component)waterLine).transform.position);
		((Component)this).transform.position = new Vector3(((Component)this).transform.position.x, waterSurface - val.y, ((Component)this).transform.position.z);
		SpawnSubEntities();
		if (HasFinishedDocking)
		{
			((FacepunchBehaviour)this).Invoke((Action)StartEgress, Mathf.Max(EventTimeRemaining, 120f));
		}
		CreateMapMarker();
	}

	public void UpdateRadiation()
	{
		currentRadiation += 1f;
		TriggerRadiation[] componentsInChildren = radiation.GetComponentsInChildren<TriggerRadiation>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].RadiationAmountOverride = currentRadiation;
		}
	}

	public void StartEgress()
	{
		if (!isDoingHarborApproach && !egressing)
		{
			egressing = true;
			if (Interface.CallHook("OnCargoShipEgress", (object)this) == null)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)PlayHorn);
				radiation.SetActive(true);
				SetFlag(Flags.Reserved8, b: true);
				((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateRadiation, 10f, 1f);
				((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, 60f * egress_duration_minutes);
			}
		}
	}

	public void DelayedDestroy()
	{
		Kill();
	}

	public void FindInitialNode()
	{
		targetNodeIndex = GetClosestNodeToUs();
	}

	private int GetHackableCrateCount()
	{
		int num = 0;
		foreach (BaseEntity child in children)
		{
			if (child is HackableLockedCrate)
			{
				num++;
			}
		}
		return num;
	}

	public void BuildingCheck()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(WorldSpaceBounds(), list, 2162689, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!(item is JunkPileWater junkPileWater))
			{
				if (item is DecayEntity decayEntity && (Object)(object)decayEntity.parentEntity.Get(serverside: true) != (Object)(object)this && decayEntity.isServer && decayEntity.IsAlive() && !decayEntity.AllowOnCargoShip)
				{
					decayEntity.Kill(DestroyMode.Gib);
				}
			}
			else
			{
				junkPileWater.SinkAndDestroy();
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public void FixedUpdate()
	{
		if (!base.isClient)
		{
			UpdateMovement();
			lifetime += Time.fixedDeltaTime;
		}
	}

	public void UpdateMovement()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (IsOceanPatrolPathAvailable() && IsValidTargetNode())
		{
			InitializeHarborApproach();
			Vector3 approachRotationNode = Vector3.zero;
			CalculateDesiredNodes(out var desiredMoveNode, out approachRotationNode);
			float num = 0f;
			num = CalculateDesiredThrottle(desiredMoveNode);
			UpdateShip(num, desiredMoveNode, approachRotationNode);
			float num2 = (isDoingHarborApproach ? 8f : 80f);
			if (Vector3.Distance(((Component)this).transform.position, desiredMoveNode) < num2)
			{
				HandleNodeArrival(desiredMoveNode);
			}
			UpdateHarborApproachProgress();
		}
	}

	[ContextMenu("Break")]
	public void Break()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		CalculateDesiredNodes(out var desiredMoveNode, out var _);
		Vector3 val = ((Component)this).transform.position - desiredMoveNode;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		((Component)this).transform.forward = normalized;
		currentTurnSpeed = 0f;
	}

	private void UpdateShip(float desiredThrottle, Vector3 desiredWaypoint, Vector3 approachRotationNode)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = desiredWaypoint - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		normalized.y = 0f;
		float num = Vector3.Dot(((Component)this).transform.right, normalized);
		float num2 = (isDoingHarborApproach ? 6.5f : 2.5f);
		float num3 = Mathf.InverseLerp(0.05f, 0.5f, Mathf.Abs(num));
		if (num3 == 0f && Vector3.Dot(normalized, -((Component)this).transform.forward) >= 0.95f)
		{
			num3 = 1f;
		}
		turnScale = Mathf.Lerp(turnScale, num3, Time.deltaTime * 0.2f);
		float num4 = ((!(num < 0f)) ? 1 : (-1));
		currentTurnSpeed = num2 * turnScale * num4;
		if (!isDoingHarborApproach)
		{
			((Component)this).transform.Rotate(Vector3.up, Time.deltaTime * currentTurnSpeed, (Space)0);
		}
		currentThrottle = Mathf.Lerp(currentThrottle, desiredThrottle, Time.deltaTime * 0.2f);
		currentVelocity = ((Component)this).transform.forward * (8f * currentThrottle);
		if (isDoingHarborApproach)
		{
			currentVelocity = normalized * currentThrottle * 5f;
			val = approachRotationNode - ((Component)this).transform.position;
			Vector3 normalized2 = ((Vector3)(ref val)).normalized;
			normalized2.y = 0f;
			if (normalized2 != Vector3.zero)
			{
				((Component)this).transform.rotation = Quaternion.Slerp(((Component)this).transform.rotation, Quaternion.LookRotation(normalized2), Time.deltaTime * 0.1f);
			}
		}
		if (HasFlag(Flags.Reserved1))
		{
			currentVelocity = Vector3.zero;
		}
		Transform transform = ((Component)this).transform;
		transform.position += currentVelocity * Time.deltaTime;
	}

	private void UpdateHarborApproachProgress()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		HarborProximityManager harborProximityManager = default(HarborProximityManager);
		if (isDoingHarborApproach && (Object)(object)harborApproachPath != (Object)null && ((Component)harborApproachPath).TryGetComponent<HarborProximityManager>(ref harborProximityManager))
		{
			float pathLength = harborApproachPath.GetPathLength();
			float pathProgress = harborApproachPath.GetPathProgress(((Component)this).transform.position);
			harborProximityManager.UpdateNormalisedState(Mathf.Clamp01(pathProgress / pathLength));
		}
	}

	private void InitializeHarborApproach(bool forceInit = false)
	{
		if (forceInit || harbors.Count > 0)
		{
			harborApproachPath = harbors[harborIndex].harborPath;
			proxManager = ((Component)harborApproachPath).GetComponent<HarborProximityManager>();
		}
	}

	private float CalculateDesiredThrottle(Vector3 desiredMoveNode)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = desiredMoveNode - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		float num = Vector3.Dot(((Component)this).transform.forward, normalized);
		float num2 = Mathf.InverseLerp(0f, 1f, num);
		if (isDoingHarborApproach)
		{
			if (harborApproachPath.nodes[currentHarborApproachNode].maxVelocityOnApproach > 0f)
			{
				lastSpeed = harborApproachPath.nodes[currentHarborApproachNode].maxVelocityOnApproach;
			}
			num2 = Mathf.Clamp(num2, 0.1f, lastSpeed);
		}
		return num2;
	}

	private void CalculateDesiredNodes(out Vector3 desiredMoveNode, out Vector3 approachRotationNode)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if (isDoingHarborApproach)
		{
			int index = (shouldLookAhead ? Mathf.Min(currentHarborApproachNode + 1, harborApproachPath.nodes.Count - 1) : currentHarborApproachNode);
			approachRotationNode = harborApproachPath.nodes[index].Position;
			desiredMoveNode = harborApproachPath.nodes[currentHarborApproachNode].Position;
			return;
		}
		desiredMoveNode = TerrainMeta.Path.OceanPatrolFar[targetNodeIndex];
		if (egressing)
		{
			Vector3 position = ((Component)this).transform.position;
			Vector3 val = ((Component)this).transform.position - Vector3.zero;
			desiredMoveNode = position + ((Vector3)(ref val)).normalized * 10000f;
			val = ((Component)this).transform.position;
			if (((Vector3)(ref val)).sqrMagnitude > 100000000f)
			{
				Debug.LogWarning((object)"Immediately deleting cargo as it is a long way out of bounds");
				Kill();
			}
		}
		approachRotationNode = Vector3.zero;
	}

	private void HandleNodeArrival(Vector3 waypointPosition)
	{
		if (isDoingHarborApproach)
		{
			if (currentHarborApproachNode == harborApproachPath.nodes.Count - 1)
			{
				EndHarborApproach();
			}
			else
			{
				AdvanceHarborApproach();
			}
			return;
		}
		targetNodeIndex = (targetNodeIndex - 1 + TerrainMeta.Path.OceanPatrolFar.Count) % TerrainMeta.Path.OceanPatrolFar.Count;
		if (HasFinishedDocking)
		{
			return;
		}
		for (int i = 0; i < harbors.Count; i++)
		{
			HarborInfo harborInfo = harbors[i];
			if ((Object)(object)harborInfo.harborPath != (Object)null && harborInfo.approachNode == targetNodeIndex)
			{
				CargoNotifier component = ((Component)harborInfo.harborPath).GetComponent<CargoNotifier>();
				harborApproachPath = harborInfo.harborPath;
				harborIndex = i;
				if ((Object)(object)component != (Object)null)
				{
					StartHarborApproach(component);
					break;
				}
			}
		}
	}

	public void StartHarborApproach(CargoNotifier cn)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnCargoShipHarborApproach", (object)this, (object)cn) != null)
		{
			return;
		}
		PlayHorn();
		isDoingHarborApproach = true;
		dockCount++;
		shouldLookAhead = false;
		if ((Object)(object)proxManager != (Object)null)
		{
			proxManager.StartMovement();
		}
		ClearAllHarborEntitiesOnShip();
		Enumerator<HarborCraneContainerPickup> enumerator = HarborCraneContainerPickup.AllCranes.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				HarborCraneContainerPickup current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && !current.isClient && !(current.Distance2D(harborApproachPath.nodes[harborApproachPath.nodes.Count / 2].Position) > 150f))
				{
					current.ReplenishContainers();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	private float GetTimeRemainingFromCrates()
	{
		float requiredHackSeconds = HackableLockedCrate.requiredHackSeconds;
		if (GetHackableCrateCount() != 0)
		{
			return requiredHackSeconds + requiredHackSeconds * 0.3f;
		}
		return 120f;
	}

	private void EndHarborApproach()
	{
		PlayHorn();
		isDoingHarborApproach = false;
		currentHarborApproachNode = 0;
		FindInitialNode();
		if ((Object)(object)proxManager != (Object)null)
		{
			proxManager.EndMovement();
		}
		if (HasFinishedDocking)
		{
			if (docking_debug)
			{
				Debug.Log((object)$"Finished all docking: {EventTimeRemaining}s left in event");
			}
			((FacepunchBehaviour)this).Invoke((Action)StartEgress, Mathf.Max(EventTimeRemaining, GetTimeRemainingFromCrates()));
		}
	}

	private void AdvanceHarborApproach()
	{
		if (currentHarborApproachNode + 1 < harborApproachPath.nodes.Count)
		{
			currentHarborApproachNode++;
		}
		if (!shouldLookAhead)
		{
			shouldLookAhead = true;
		}
		if (harborApproachPath.nodes[currentHarborApproachNode].maxVelocityOnApproach == 0f)
		{
			OnArrivedAtHarbor();
		}
	}

	private bool IsOceanPatrolPathAvailable()
	{
		if (TerrainMeta.Path.OceanPatrolFar != null)
		{
			return TerrainMeta.Path.OceanPatrolFar.Count > 0;
		}
		return false;
	}

	private bool IsValidTargetNode()
	{
		return targetNodeIndex != -1;
	}

	private void PreHarborLeaveHorn()
	{
		PlayHorn();
	}

	private void LeaveHarbor()
	{
		if (docking_debug)
		{
			Debug.Log((object)"Cargo is leaving harbor.");
		}
		PlayHorn();
		SetFlag(Flags.Reserved1, b: false);
		SetFlag(Flags.Reserved2, b: true);
		currentHarborApproachNode++;
		Interface.CallHook("OnCargoShipHarborLeave", (object)this);
	}

	public int GetClosestNodeToUs()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		int result = 0;
		float num = float.PositiveInfinity;
		for (int i = 0; i < TerrainMeta.Path.OceanPatrolFar.Count; i++)
		{
			Vector3 val = TerrainMeta.Path.OceanPatrolFar[i];
			float num2 = Vector3.Distance(((Component)this).transform.position, val);
			if (num2 < num)
			{
				result = i;
				num = num2;
			}
		}
		return result;
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return currentVelocity;
	}

	public override Quaternion GetAngularVelocityServer()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Euler(0f, currentTurnSpeed, 0f);
	}

	public override float InheritedVelocityScale()
	{
		return 1f;
	}

	public override bool BlocksWaterFor(BasePlayer player)
	{
		return true;
	}

	public override float MaxVelocity()
	{
		return 8f;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool ForceDeployableSetParent()
	{
		return true;
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CargoShip.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


using UnityEngine;

public struct HarborInfo
{
	public BasePath harborPath;

	public Transform harborTransform;

	public int approachNode;
}


using UnityEngine;

public class CargoShipContainerDestination : MonoBehaviour, IServerComponent
{
}


using UnityEngine;

public class CargoShipDevTrigger : MonoBehaviour
{
	public float TimeTrigger = 15f;
}


using UnityEngine;

public class CargoShipInteriorSoundTrigger : MonoBehaviour, IClientComponent
{
	public CargoShipSounds cargoShipSounds;
}


using UnityEngine;

public class CargoShipSounds : MonoBehaviour, IClientComponent
{
	public CargoShip cargoShip;

	public SoundDefinition waveSoundDef;

	public AnimationCurve waveSoundYGainCurve;

	public AnimationCurve waveSoundEdgeDistanceGainCurve;

	private Sound waveSoundL;

	private Sound waveSoundR;

	private SoundModulation.Modulator waveSoundLGainMod;

	private SoundModulation.Modulator waveSoundRGainMod;

	public SoundDefinition sternWakeSoundDef;

	private Sound sternWakeSound;

	private SoundModulation.Modulator sternWakeSoundGainMod;

	public SoundDefinition idleWaveSoundDef;

	public SoundDefinition engineHumSoundDef;

	private Sound engineHumSound;

	private SoundModulation.Modulator enginePitchMod;

	public GameObject engineHumTarget;

	public float enginePitchChangeSpeed = 0.03f;

	public SoundDefinition hugeRumbleSoundDef;

	public AnimationCurve hugeRumbleYDiffCurve;

	public AnimationCurve hugeRumbleRelativeSpeedCurve;

	private Sound hugeRumbleSound;

	private SoundModulation.Modulator hugeRumbleGainMod;

	private Vector3 lastCameraPos;

	private Vector3 lastRumblePos;

	private Vector3 lastRumbleLocalPos;

	public Collider soundFollowCollider;

	public Collider soundFollowColliderL;

	public Collider soundFollowColliderR;

	public Collider sternSoundFollowCollider;

	public SoundDefinition metalGroanSoundDef;

	public float metalGroanMinInterval = 1f;

	public float metalGroanMaxInterval = 30f;
}


using UnityEngine;

public class LadderMinMountHeight : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using UnityEngine;

public class TriggerVehiclePush : TriggerBase, IServerComponent
{
	public BaseEntity thisEntity;

	public float maxPushVelocity = 10f;

	public float minRadius;

	public float maxRadius;

	public bool snapToAxis;

	public Vector3 axisToSnapTo = Vector3.right;

	public bool allowParentRigidbody;

	public bool useRigidbodyPosition;

	public bool useCentreOfMass;

	public int ContentsCount => entityContents?.Count ?? 0;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity is BuildingBlock)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public void FixedUpdate()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)thisEntity == (Object)null || entityContents == null)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		foreach (BaseEntity entityContent in entityContents)
		{
			if (!entityContent.IsValid() || entityContent.EqualNetID((BaseNetworkable)thisEntity))
			{
				continue;
			}
			Rigidbody val = ((Component)entityContent).GetComponent<Rigidbody>();
			if ((Object)(object)val == (Object)null && allowParentRigidbody)
			{
				val = ((Component)entityContent).GetComponentInParent<Rigidbody>();
			}
			if (Object.op_Implicit((Object)(object)val) && !val.isKinematic)
			{
				float num = Vector3Ex.Distance2D(useRigidbodyPosition ? ((Component)val).transform.position : ((Component)entityContent).transform.position, ((Component)this).transform.position);
				float num2 = (((Bounds)(ref entityContent.bounds)).extents.x + ((Bounds)(ref entityContent.bounds)).extents.z) / 2f;
				num -= num2;
				float num3 = 1f - Mathf.InverseLerp(minRadius, maxRadius, num);
				float num4 = 1f - Mathf.InverseLerp(minRadius - 1f, minRadius, num);
				Vector3 val2 = entityContent.ClosestPoint(position);
				Vector3 val3 = Vector3Ex.Direction2D(val2, position);
				val3 = Vector3Ex.Direction2D(useCentreOfMass ? val.worldCenterOfMass : val2, position);
				if (snapToAxis)
				{
					Vector3 val4 = ((Component)this).transform.InverseTransformDirection(val3);
					val3 = ((!(Vector3.Angle(val4, axisToSnapTo) < Vector3.Angle(val4, -axisToSnapTo))) ? (-((Component)this).transform.TransformDirection(axisToSnapTo)) : ((Component)this).transform.TransformDirection(axisToSnapTo));
				}
				val.AddForceAtPosition(val3 * maxPushVelocity * num3, val2, (ForceMode)5);
				if (num4 > 0f)
				{
					val.AddForceAtPosition(val3 * 1f * num4, val2, (ForceMode)2);
				}
			}
		}
	}

	public void OnDrawGizmosSelected()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(((Component)this).transform.position, minRadius);
		Gizmos.color = new Color(0.5f, 0f, 0f, 1f);
		Gizmos.DrawWireSphere(((Component)this).transform.position, maxRadius);
		if (snapToAxis)
		{
			Gizmos.color = Color.cyan;
			Vector3 val = ((Component)this).transform.TransformDirection(axisToSnapTo);
			Gizmos.DrawLine(((Component)this).transform.position + val, ((Component)this).transform.position - val);
		}
	}
}


public class RHIBDriver : BaseVehicleSeat
{
}


using UnityEngine;

public class TwitchBus : CH47Helicopter
{
	public LineRenderer[] LineRenderers;

	public Transform[] LineRendererBusPoints;

	public Transform[] HelicopterPoints;
}


using UnityEngine;

public class sedanAnimation : MonoBehaviour
{
	public Transform[] frontAxles;

	public Transform FL_shock;

	public Transform FL_wheel;

	public Transform FR_shock;

	public Transform FR_wheel;

	public Transform RL_shock;

	public Transform RL_wheel;

	public Transform RR_shock;

	public Transform RR_wheel;

	public WheelCollider FL_wheelCollider;

	public WheelCollider FR_wheelCollider;

	public WheelCollider RL_wheelCollider;

	public WheelCollider RR_wheelCollider;

	public Transform steeringWheel;

	public float motorForceConstant = 150f;

	public float brakeForceConstant = 500f;

	public float brakePedal;

	public float gasPedal;

	public float steering;

	private Rigidbody myRigidbody;

	public float GasLerpTime = 20f;

	public float SteeringLerpTime = 20f;

	private float wheelSpinConstant = 120f;

	private float shockRestingPosY = -0.27f;

	private float shockDistance = 0.3f;

	private float traceDistanceNeutralPoint = 0.7f;

	private void Start()
	{
		myRigidbody = ((Component)this).GetComponent<Rigidbody>();
	}

	private void Update()
	{
		DoSteering();
		ApplyForceAtWheels();
		UpdateTireAnimation();
		InputPlayer();
	}

	private void InputPlayer()
	{
		if (Input.GetKey((KeyCode)119))
		{
			gasPedal = Mathf.Clamp(gasPedal + Time.deltaTime * GasLerpTime, -100f, 100f);
			brakePedal = Mathf.Lerp(brakePedal, 0f, Time.deltaTime * GasLerpTime);
		}
		else if (Input.GetKey((KeyCode)115))
		{
			gasPedal = Mathf.Clamp(gasPedal - Time.deltaTime * GasLerpTime, -100f, 100f);
			brakePedal = Mathf.Lerp(brakePedal, 0f, Time.deltaTime * GasLerpTime);
		}
		else
		{
			gasPedal = Mathf.Lerp(gasPedal, 0f, Time.deltaTime * GasLerpTime);
			brakePedal = Mathf.Lerp(brakePedal, 100f, Time.deltaTime * GasLerpTime / 5f);
		}
		if (Input.GetKey((KeyCode)97))
		{
			steering = Mathf.Clamp(steering - Time.deltaTime * SteeringLerpTime, -60f, 60f);
		}
		else if (Input.GetKey((KeyCode)100))
		{
			steering = Mathf.Clamp(steering + Time.deltaTime * SteeringLerpTime, -60f, 60f);
		}
		else
		{
			steering = Mathf.Lerp(steering, 0f, Time.deltaTime * SteeringLerpTime);
		}
	}

	private void DoSteering()
	{
		FL_wheelCollider.steerAngle = steering;
		FR_wheelCollider.steerAngle = steering;
	}

	private void ApplyForceAtWheels()
	{
		if (FL_wheelCollider.isGrounded)
		{
			FL_wheelCollider.motorTorque = gasPedal * motorForceConstant;
			FL_wheelCollider.brakeTorque = brakePedal * brakeForceConstant;
		}
		if (FR_wheelCollider.isGrounded)
		{
			FR_wheelCollider.motorTorque = gasPedal * motorForceConstant;
			FR_wheelCollider.brakeTorque = brakePedal * brakeForceConstant;
		}
		if (RL_wheelCollider.isGrounded)
		{
			RL_wheelCollider.motorTorque = gasPedal * motorForceConstant;
			RL_wheelCollider.brakeTorque = brakePedal * brakeForceConstant;
		}
		if (RR_wheelCollider.isGrounded)
		{
			RR_wheelCollider.motorTorque = gasPedal * motorForceConstant;
			RR_wheelCollider.brakeTorque = brakePedal * brakeForceConstant;
		}
	}

	private void UpdateTireAnimation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03db: Unknown result type (might be due to invalid IL or missing references)
		//IL_03eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_0421: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Dot(myRigidbody.velocity, ((Component)myRigidbody).transform.forward);
		if (FL_wheelCollider.isGrounded)
		{
			FL_shock.localPosition = new Vector3(FL_shock.localPosition.x, shockRestingPosY + GetShockHeightDelta(FL_wheelCollider), FL_shock.localPosition.z);
			FL_wheel.localEulerAngles = new Vector3(FL_wheel.localEulerAngles.x, FL_wheel.localEulerAngles.y, FL_wheel.localEulerAngles.z - num * Time.deltaTime * wheelSpinConstant);
		}
		else
		{
			FL_shock.localPosition = Vector3.Lerp(FL_shock.localPosition, new Vector3(FL_shock.localPosition.x, shockRestingPosY, FL_shock.localPosition.z), Time.deltaTime * 2f);
		}
		if (FR_wheelCollider.isGrounded)
		{
			FR_shock.localPosition = new Vector3(FR_shock.localPosition.x, shockRestingPosY + GetShockHeightDelta(FR_wheelCollider), FR_shock.localPosition.z);
			FR_wheel.localEulerAngles = new Vector3(FR_wheel.localEulerAngles.x, FR_wheel.localEulerAngles.y, FR_wheel.localEulerAngles.z - num * Time.deltaTime * wheelSpinConstant);
		}
		else
		{
			FR_shock.localPosition = Vector3.Lerp(FR_shock.localPosition, new Vector3(FR_shock.localPosition.x, shockRestingPosY, FR_shock.localPosition.z), Time.deltaTime * 2f);
		}
		if (RL_wheelCollider.isGrounded)
		{
			RL_shock.localPosition = new Vector3(RL_shock.localPosition.x, shockRestingPosY + GetShockHeightDelta(RL_wheelCollider), RL_shock.localPosition.z);
			RL_wheel.localEulerAngles = new Vector3(RL_wheel.localEulerAngles.x, RL_wheel.localEulerAngles.y, RL_wheel.localEulerAngles.z - num * Time.deltaTime * wheelSpinConstant);
		}
		else
		{
			RL_shock.localPosition = Vector3.Lerp(RL_shock.localPosition, new Vector3(RL_shock.localPosition.x, shockRestingPosY, RL_shock.localPosition.z), Time.deltaTime * 2f);
		}
		if (RR_wheelCollider.isGrounded)
		{
			RR_shock.localPosition = new Vector3(RR_shock.localPosition.x, shockRestingPosY + GetShockHeightDelta(RR_wheelCollider), RR_shock.localPosition.z);
			RR_wheel.localEulerAngles = new Vector3(RR_wheel.localEulerAngles.x, RR_wheel.localEulerAngles.y, RR_wheel.localEulerAngles.z - num * Time.deltaTime * wheelSpinConstant);
		}
		else
		{
			RR_shock.localPosition = Vector3.Lerp(RR_shock.localPosition, new Vector3(RR_shock.localPosition.x, shockRestingPosY, RR_shock.localPosition.z), Time.deltaTime * 2f);
		}
		Transform[] array = frontAxles;
		foreach (Transform val in array)
		{
			val.localEulerAngles = new Vector3(steering, val.localEulerAngles.y, val.localEulerAngles.z);
		}
	}

	private float GetShockHeightDelta(WheelCollider wheel)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		int mask = LayerMask.GetMask(new string[3] { "Terrain", "World", "Construction" });
		RaycastHit val = default(RaycastHit);
		Physics.Linecast(((Component)wheel).transform.position, ((Component)wheel).transform.position - Vector3.up * 10f, ref val, mask);
		return Mathx.RemapValClamped(((RaycastHit)(ref val)).distance, traceDistanceNeutralPoint - shockDistance, traceDistanceNeutralPoint + shockDistance, shockDistance * 0.75f, -0.75f * shockDistance);
	}
}


using UnityEngine;

public class SedanWheelSmoke : MonoBehaviour
{
	public ParticleSystem[] tireSmoke;

	public ParticleSystem[] tireWaterSplash;

	public ParticleSystem[] tireWaterSplash_Extra;

	public bool[] wheelTouching;
}


