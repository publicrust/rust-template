using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class Locker : StorageContainer
{
	public enum RowType
	{
		Clothing,
		Belt
	}

	public static class LockerFlags
	{
		public const Flags IsEquipping = Flags.Reserved1;
	}

	public GameObjectRef equipSound;

	public const int maxGearSets = 3;

	public const int attireSize = 8;

	public const int beltSize = 6;

	public const int columnSize = 2;

	public const int backpackSlotIndex = 7;

	public Item[] clothingBuffer = new Item[8];

	public const int setSize = 14;

	public bool isTransferringIndustrialItem;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Locker.OnRpcMessage", 0);
		try
		{
			if (rpc == 1799659668 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Equip "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Equip", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1799659668u, "RPC_Equip", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Equip(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Equip");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsEquipping()
	{
		return HasFlag(Flags.Reserved1);
	}

	public RowType GetRowType(int slot)
	{
		if (slot == -1)
		{
			return RowType.Clothing;
		}
		if (slot % 14 >= 8)
		{
			return RowType.Belt;
		}
		return RowType.Clothing;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Reserved1, b: false);
	}

	public void ClearEquipping()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public void OnIndustrialItemTransferBegin()
	{
		isTransferringIndustrialItem = true;
	}

	public void OnIndustrialItemTransferEnd()
	{
		isTransferringIndustrialItem = false;
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanLockerAcceptItem", (object)this, (object)item, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!base.ItemFilter(item, targetSlot))
		{
			return false;
		}
		bool num = item.IsBackpack();
		bool flag = IsBackpackSlot(targetSlot);
		if (num != flag)
		{
			return false;
		}
		if (isTransferringIndustrialItem && GetRowType(targetSlot) == RowType.Belt && item.info.category == ItemCategory.Attire)
		{
			return false;
		}
		if (item.info.category == ItemCategory.Attire)
		{
			return true;
		}
		return GetRowType(targetSlot) == RowType.Belt;
	}

	public bool IsBackpackSlot(int slot)
	{
		return (slot - 7) % 14 == 0;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Equip(RPCMessage msg)
	{
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		int num = msg.read.Int32();
		if (num < 0 || num >= 3 || Interface.CallHook("OnLockerSwap", (object)this, (object)num, (object)msg.player) != null || IsEquipping())
		{
			return;
		}
		BasePlayer player = msg.player;
		if (player.IsDead())
		{
			return;
		}
		BaseLock @lock = GetLock();
		if ((Object)(object)@lock != (Object)null && !@lock.OnTryToOpen(player))
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
			return;
		}
		int num2 = num * 14;
		bool flag = false;
		for (int i = 0; i < clothingBuffer.Length; i++)
		{
			Item slot = player.inventory.containerWear.GetSlot(i);
			if (slot != null)
			{
				slot.RemoveFromContainer();
				clothingBuffer[i] = slot;
			}
		}
		for (int j = 0; j < 8; j++)
		{
			int num3 = num2 + j;
			Item slot2 = base.inventory.GetSlot(num3);
			Item item = clothingBuffer[j];
			if (slot2 != null)
			{
				flag = true;
				if (slot2.info.category != ItemCategory.Attire || !slot2.MoveToContainer(player.inventory.containerWear, j))
				{
					slot2.Drop(GetDropPosition(), GetDropVelocity());
				}
			}
			if (item != null)
			{
				flag = true;
				if (!item.MoveToContainer(base.inventory, num3) && !item.MoveToContainer(player.inventory.containerWear, j))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
			}
			clothingBuffer[j] = null;
		}
		for (int k = 0; k < 6; k++)
		{
			int num4 = num2 + k + 8;
			int iTargetPos = k;
			Item slot3 = base.inventory.GetSlot(num4);
			Item slot4 = player.inventory.containerBelt.GetSlot(k);
			slot4?.RemoveFromContainer();
			if (slot3 != null)
			{
				flag = true;
				if (!slot3.MoveToContainer(player.inventory.containerBelt, iTargetPos))
				{
					slot3.Drop(GetDropPosition(), GetDropVelocity());
				}
			}
			if (slot4 != null)
			{
				flag = true;
				if (!slot4.MoveToContainer(base.inventory, num4))
				{
					slot4.Drop(GetDropPosition(), GetDropVelocity());
				}
			}
		}
		if (flag)
		{
			Effect.server.Run(equipSound.resourcePath, player, StringPool.Get("spine3"), Vector3.zero, Vector3.zero);
			SetFlag(Flags.Reserved1, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearEquipping, 1.5f);
		}
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		for (int i = 0; i < inventorySlots; i++)
		{
			RowType rowType = GetRowType(i);
			if (item.info.category == ItemCategory.Attire)
			{
				if (rowType != 0)
				{
					continue;
				}
			}
			else if (rowType != RowType.Belt)
			{
				continue;
			}
			if (!base.inventory.SlotTaken(item, i) && (rowType != 0 || !DoesWearableConflictWithRow(item, i)))
			{
				return i;
			}
		}
		return int.MinValue;
	}

	public bool DoesWearableConflictWithRow(Item item, int pos)
	{
		int num = pos / 14 * 14;
		ItemModWearable itemModWearable = item.info.ItemModWearable;
		if ((Object)(object)itemModWearable == (Object)null)
		{
			return false;
		}
		bool num2 = item.IsBackpack();
		bool flag = IsBackpackSlot(pos);
		if (num2 != flag)
		{
			return true;
		}
		for (int i = num; i < num + 8; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				ItemModWearable itemModWearable2 = slot.info.ItemModWearable;
				if (!((Object)(object)itemModWearable2 == (Object)null) && !itemModWearable2.CanExistWith(itemModWearable))
				{
					return true;
				}
			}
		}
		return false;
	}

	public Vector2i GetIndustrialSlotRange(Vector3 localPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (localPosition.x < -0.3f)
		{
			return new Vector2i(28, 41);
		}
		if (localPosition.x > 0.3f)
		{
			return new Vector2i(0, 13);
		}
		return new Vector2i(14, 27);
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (base.CanPickup(player))
		{
			return !HasAttachedStorageAdaptor();
		}
		return false;
	}
}


public enum RowType
{
	Clothing,
	Belt
}


public static class LockerFlags
{
	public const Flags IsEquipping = Flags.Reserved1;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class LootableCorpse : BaseCorpse, LootPanel.IHasLootPanel, IInventoryProvider
{
	public string lootPanelName = "generic";

	[NonSerialized]
	public ulong playerSteamID;

	[NonSerialized]
	public string _playerName;

	[NonSerialized]
	public ItemContainer[] containers;

	[NonSerialized]
	private bool firstLooted;

	public virtual string playerName
	{
		get
		{
			return NameHelper.Get(playerSteamID, _playerName, base.isClient);
		}
		set
		{
			_playerName = value;
		}
	}

	public virtual string streamerName { get; set; }

	public Phrase LootPanelTitle => Phrase.op_Implicit(playerName);

	public Phrase LootPanelName => Phrase.op_Implicit("N/A");

	public bool blockBagDrop { get; set; }

	public override int NumberOfItemsToTransfer
	{
		get
		{
			int num = base.NumberOfItemsToTransfer;
			for (int i = 0; i < containers.Length; i++)
			{
				ItemContainer itemContainer = containers[i];
				if (CanLootContainer(itemContainer, i))
				{
					num += itemContainer.itemList.Count;
				}
			}
			return num;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("LootableCorpse.OnRpcMessage", 0);
		try
		{
			if (rpc == 2278459738u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_LootCorpse "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_LootCorpse", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2278459738u, "RPC_LootCorpse", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_LootCorpse(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_LootCorpse");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		firstLooted = false;
		base.ResetState();
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (!blockBagDrop)
		{
			PreDropItems();
			DropItems();
		}
		blockBagDrop = false;
		if (containers != null)
		{
			ItemContainer[] array = containers;
			for (int i = 0; i < array.Length; i++)
			{
				ItemContainer itemContainer = array[i];
				Pool.Free<ItemContainer>(ref itemContainer);
			}
		}
		containers = null;
	}

	public void TakeFrom(BaseEntity fromEntity, params ItemContainer[] source)
	{
		Assert.IsTrue(containers == null, "Initializing Twice");
		TimeWarning val = TimeWarning.New("Corpse.TakeFrom", 0);
		try
		{
			containers = new ItemContainer[source.Length];
			for (int i = 0; i < source.Length; i++)
			{
				containers[i] = SetUpContainerFromSource(source[i]);
			}
			ResetRemovalTime();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		SetupLootableHeadDispenser(fromEntity);
	}

	public void TakeFrom(BaseEntity fromEntity, ItemContainer containerA, ItemContainer containerB, ItemContainer containerC)
	{
		Assert.IsTrue(containers == null, "Initializing Twice");
		TimeWarning val = TimeWarning.New("Corpse.TakeFrom", 0);
		try
		{
			containers = new ItemContainer[3];
			containers[0] = SetUpContainerFromSource(containerA);
			containers[1] = SetUpContainerFromSource(containerB);
			containers[2] = SetUpContainerFromSource(containerC);
			ResetRemovalTime();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		SetupLootableHeadDispenser(fromEntity);
	}

	public void TakeFrom(BaseEntity fromEntity, ItemContainer containerA)
	{
		Assert.IsTrue(containers == null, "Initializing Twice");
		TimeWarning val = TimeWarning.New("Corpse.TakeFrom", 0);
		try
		{
			containers = new ItemContainer[1];
			containers[0] = SetUpContainerFromSource(containerA);
			ResetRemovalTime();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		SetupLootableHeadDispenser(fromEntity);
	}

	private ItemContainer SetUpContainerFromSource(ItemContainer source)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.ServerInitialize(null, source.capacity);
		itemContainer.GiveUID();
		itemContainer.entityOwner = this;
		itemContainer.containerVolume = source.containerVolume;
		Item[] array = source.itemList.ToArray();
		foreach (Item item in array)
		{
			if (!item.MoveToContainer(itemContainer))
			{
				item.DropAndTossUpwards(((Component)this).transform.position);
			}
		}
		return itemContainer;
	}

	private void SetupLootableHeadDispenser(BaseEntity fromEntity)
	{
		HeadDispenser headDispenser = default(HeadDispenser);
		if (((Component)this).gameObject.TryGetComponent<HeadDispenser>(ref headDispenser))
		{
			GameObject val = GameManager.server.FindPrefab(fromEntity.prefabID);
			BasePlayer overrideEntity = default(BasePlayer);
			if ((Object)(object)val != (Object)null && val.TryGetComponent<BasePlayer>(ref overrideEntity))
			{
				headDispenser.overrideEntity = overrideEntity;
			}
		}
	}

	public void CreateEmptyContainer(int capacity)
	{
		Assert.IsTrue(containers == null, "Initializing Twice");
		containers = new ItemContainer[1];
		ItemContainer itemContainer = new ItemContainer();
		itemContainer.ServerInitialize(null, capacity);
		itemContainer.GiveUID();
		itemContainer.entityOwner = this;
		containers[0] = itemContainer;
	}

	public override bool CanRemove()
	{
		return !IsOpen();
	}

	public virtual bool CanLoot()
	{
		return true;
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		if (!firstLooted)
		{
			if (playerSteamID <= 10000000)
			{
				Analytics.Azure.OnFirstLooted(this, baseEntity);
				ItemContainer[] array = containers;
				for (int i = 0; i < array.Length; i++)
				{
					foreach (Item item in array[i].itemList)
					{
						item.SetItemOwnership(baseEntity, ItemOwnershipPhrases.LootedPhrase);
					}
				}
			}
			firstLooted = true;
		}
		return base.OnStartBeingLooted(baseEntity);
	}

	protected virtual bool CanLootContainer(ItemContainer c, int index)
	{
		return true;
	}

	public float GetRadsInCorpse()
	{
		float num = 0f;
		ItemContainer[] array = containers;
		foreach (ItemContainer itemContainer in array)
		{
			num += itemContainer.GetRadioactiveMaterialInContainer();
		}
		return num;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_LootCorpse(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!Object.op_Implicit((Object)(object)player) || !player.CanInteract() || !CanLoot() || containers == null || Interface.CallHook("CanLootEntity", (object)player, (object)this) != null || !player.inventory.loot.StartLootingEntity(this))
		{
			return;
		}
		SetFlag(Flags.Open, b: true);
		for (int i = 0; i < containers.Length; i++)
		{
			ItemContainer itemContainer = containers[i];
			if (CanLootContainer(itemContainer, i))
			{
				player.inventory.loot.AddContainer(itemContainer);
			}
		}
		player.inventory.loot.SendImmediate();
		player.RadioactiveLootCheck(player.inventory.loot.containers);
		ClientRPC(RpcTarget.Player("RPC_ClientLootCorpse", player));
		SendNetworkUpdate();
	}

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", (object)player, (object)this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

	protected virtual void PreDropItems()
	{
	}

	public void DropItems()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!Global.disableBagDropping && containers != null)
		{
			DroppedItemContainer droppedItemContainer = ItemContainer.Drop("assets/prefabs/misc/item drop/item_drop_backpack.prefab", ((Component)this).transform.position, Quaternion.identity, containers);
			if ((Object)(object)droppedItemContainer != (Object)null)
			{
				droppedItemContainer.playerName = playerName;
				droppedItemContainer.playerSteamID = playerSteamID;
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.lootableCorpse = Pool.Get<LootableCorpse>();
		info.msg.lootableCorpse.playerName = playerName;
		info.msg.lootableCorpse.playerID = playerSteamID;
		info.msg.lootableCorpse.streamerName = streamerName;
		if (!info.forDisk || containers == null)
		{
			return;
		}
		info.msg.lootableCorpse.privateData = Pool.Get<Private>();
		info.msg.lootableCorpse.privateData.container = Pool.Get<List<ItemContainer>>();
		ItemContainer[] array = containers;
		foreach (ItemContainer itemContainer in array)
		{
			if (itemContainer != null)
			{
				ItemContainer val = itemContainer.Save();
				if (val != null)
				{
					info.msg.lootableCorpse.privateData.container.Add(val);
				}
			}
		}
	}

	public void GetAllInventories(List<ItemContainer> list)
	{
		if (containers != null)
		{
			list.AddRange(containers);
		}
	}

	public override void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 itemFallbackPosition)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < containers.Length; i++)
		{
			ItemContainer itemContainer2 = containers[i];
			if (!CanLootContainer(itemContainer2, i))
			{
				continue;
			}
			for (int j = 0; j < itemContainer2.capacity; j++)
			{
				Item slot = itemContainer2.GetSlot(j);
				if (slot != null && !slot.MoveToContainer(itemContainer))
				{
					slot.DropAndTossUpwards(itemFallbackPosition);
				}
			}
		}
		base.TransferAllItemsToContainer(itemContainer, itemFallbackPosition);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.lootableCorpse == null)
		{
			return;
		}
		playerName = info.msg.lootableCorpse.playerName;
		streamerName = info.msg.lootableCorpse.streamerName;
		playerSteamID = info.msg.lootableCorpse.playerID;
		if (info.fromDisk && info.msg.lootableCorpse.privateData != null && info.msg.lootableCorpse.privateData.container != null)
		{
			int count = info.msg.lootableCorpse.privateData.container.Count;
			Debug.Assert(containers == null, "Double init of containers!");
			containers = new ItemContainer[count];
			for (int i = 0; i < count; i++)
			{
				containers[i] = Pool.Get<ItemContainer>();
				containers[i].ServerInitialize(null, info.msg.lootableCorpse.privateData.container[i].slots);
				containers[i].GiveUID();
				containers[i].entityOwner = this;
				containers[i].Load(info.msg.lootableCorpse.privateData.container[i]);
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class MagnetCrane : GroundVehicle, CarPhysics<MagnetCrane>.ICar
{
	[Header("Magnet Crane")]
	public Animator animator;

	[SerializeField]
	private Transform COM;

	[SerializeField]
	public float arm1Speed = 0.01f;

	[SerializeField]
	public float arm2Speed = 0.01f;

	[SerializeField]
	public float turnYawSpeed = 0.01f;

	[SerializeField]
	public BaseMagnet Magnet;

	[SerializeField]
	private MagnetCraneAudio mcAudio;

	[SerializeField]
	public Rigidbody myRigidbody;

	[SerializeField]
	private Transform[] collisionTestingPoints;

	[SerializeField]
	public float maxDistanceFromOrigin;

	[SerializeField]
	public GameObjectRef selfDamageEffect;

	[SerializeField]
	private GameObjectRef explosionEffect;

	[SerializeField]
	private Transform explosionPoint;

	[SerializeField]
	private CapsuleCollider driverCollision;

	[SerializeField]
	private Transform leftHandTarget;

	[SerializeField]
	private Transform rightHandTarget;

	[SerializeField]
	private Transform leftFootTarget;

	[SerializeField]
	private Transform rightFootTarget;

	[SerializeField]
	public float idleFuelPerSec;

	[SerializeField]
	public float maxFuelPerSec;

	[SerializeField]
	private GameObject[] OnTriggers;

	[SerializeField]
	public TriggerHurtEx magnetDamage;

	[SerializeField]
	public int engineKW = 250;

	[SerializeField]
	private CarWheel[] wheels;

	[SerializeField]
	public CarSettings carSettings;

	[SerializeField]
	private ParticleSystem exhaustInner;

	[SerializeField]
	private ParticleSystem exhaustOuter;

	[SerializeField]
	private EmissionToggle lightToggle;

	public static readonly Phrase ReturnMessage = new Phrase("junkyardcrane.return", "Return to the Junkyard. Excessive damage will occur.");

	private const Flags Flag_ArmMovement = Flags.Reserved7;

	private const Flags Flag_BaseMovementInput = Flags.Reserved10;

	private static int leftTreadParam = Animator.StringToHash("left tread movement");

	private static int rightTreadParam = Animator.StringToHash("right tread movement");

	private static int yawParam = Animator.StringToHash("Yaw");

	private static int arm1Param = Animator.StringToHash("Arm_01");

	private static int arm2Param = Animator.StringToHash("Arm_02");

	public float steerInput;

	public float throttleInput;

	private float brakeInput;

	public float yawInput;

	public float extensionInput;

	public float raiseArmInput;

	public float extensionMove;

	public float yawMove;

	public float raiseArmMove;

	public float nextToggleTime;

	public Vector3 spawnOrigin = Vector3.zero;

	public float lastExtensionArmState;

	public float lastRaiseArmState;

	public float lastYawState;

	public bool handbrakeOn = true;

	public float nextSelfHealTime;

	public Vector3 lastDamagePos = Vector3.zero;

	public float lastDrivenTime;

	public float lastFixedUpdateTime;

	public CarPhysics<MagnetCrane> carPhysics;

	public VehicleTerrainHandler serverTerrainHandler;

	private Vector3 customInertiaTensor = new Vector3(25000f, 11000f, 19000f);

	public float extensionArmState;

	public float raiseArmState;

	public float yawState = 1f;

	public override float DriveWheelVelocity => GetSpeed();

	public VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (serverTerrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return serverTerrainHandler.OnSurface;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MagnetCrane.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float GetThrottleInput()
	{
		if (base.isServer)
		{
			return throttleInput;
		}
		throw new NotImplementedException("We don't know magnet crane throttle input on the client.");
	}

	public override float GetBrakeInput()
	{
		if (base.isServer)
		{
			if (handbrakeOn)
			{
				return 1f;
			}
			return brakeInput;
		}
		throw new NotImplementedException("We don't know magnet crane brake input on the client.");
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.crane != null && base.isServer)
		{
			yawState = info.msg.crane.yaw;
			extensionArmState = info.msg.crane.arm1;
			raiseArmState = info.msg.crane.arm2;
		}
	}

	public override float GetMaxForwardSpeed()
	{
		return 13f;
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (!PlayerIsMounted(player))
		{
			return !IsOn();
		}
		return true;
	}

	public override void ServerInit()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateParams, 0f, 0.1f);
		animator.cullingMode = (AnimatorCullingMode)0;
		animator.updateMode = (AnimatorUpdateMode)1;
		myRigidbody.centerOfMass = COM.localPosition;
		carPhysics = new CarPhysics<MagnetCrane>(this, ((Component)this).transform, rigidBody, carSettings);
		serverTerrainHandler = new VehicleTerrainHandler(this);
		Magnet.SetMagnetEnabled(wantsOn: false, null);
		spawnOrigin = ((Component)this).transform.position;
		lastDrivenTime = Time.realtimeSinceStartup;
		GameObject[] onTriggers = OnTriggers;
		for (int i = 0; i < onTriggers.Length; i++)
		{
			onTriggers[i].SetActive(false);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (!IsDriver(player))
		{
			return;
		}
		throttleInput = 0f;
		steerInput = 0f;
		extensionInput = 0f;
		yawInput = 0f;
		raiseArmInput = 0f;
		if (engineController.IsOff)
		{
			if (inputState.IsAnyDown())
			{
				engineController.TryStartEngine(player);
			}
		}
		else if (engineController.IsOn)
		{
			bool num = inputState.IsDown(BUTTON.SPRINT);
			if (inputState.IsDown(BUTTON.RELOAD) && Time.realtimeSinceStartup > nextToggleTime)
			{
				Magnet.SetMagnetEnabled(!Magnet.IsMagnetOn(), player);
				nextToggleTime = Time.realtimeSinceStartup + 0.5f;
			}
			if (num)
			{
				float speed = GetSpeed();
				float num2 = 0f;
				if (inputState.IsDown(BUTTON.FORWARD))
				{
					num2 = 1f;
				}
				else if (inputState.IsDown(BUTTON.BACKWARD))
				{
					num2 = -1f;
				}
				if (speed > 1f && num2 < 0f)
				{
					throttleInput = 0f;
					brakeInput = 0f - num2;
				}
				else if (speed < -1f && num2 > 0f)
				{
					throttleInput = 0f;
					brakeInput = num2;
				}
				else
				{
					throttleInput = num2;
					brakeInput = 0f;
				}
				if (inputState.IsDown(BUTTON.RIGHT))
				{
					steerInput = -1f;
				}
				if (inputState.IsDown(BUTTON.LEFT))
				{
					steerInput = 1f;
				}
			}
			else
			{
				if (inputState.IsDown(BUTTON.LEFT))
				{
					yawInput = 1f;
				}
				else if (inputState.IsDown(BUTTON.RIGHT))
				{
					yawInput = -1f;
				}
				else if (inputState.IsDown(BUTTON.DUCK))
				{
					float @float = animator.GetFloat(yawParam);
					if (@float > 0.01f && @float < 0.99f)
					{
						yawInput = ((@float <= 0.5f) ? (-1f) : 1f);
					}
				}
				if (inputState.IsDown(BUTTON.FORWARD))
				{
					raiseArmInput = 1f;
				}
				else if (inputState.IsDown(BUTTON.BACKWARD))
				{
					raiseArmInput = -1f;
				}
			}
			if (inputState.IsDown(BUTTON.FIRE_PRIMARY))
			{
				extensionInput = 1f;
			}
			if (inputState.IsDown(BUTTON.FIRE_SECONDARY))
			{
				extensionInput = -1f;
			}
		}
		handbrakeOn = throttleInput == 0f && steerInput == 0f;
	}

	public override float MaxVelocity()
	{
		return Mathf.Max(GetMaxForwardSpeed() * 1.3f, 30f);
	}

	public float GetSteerInput()
	{
		return steerInput;
	}

	public bool GetSteerSpeedMod(float speed)
	{
		return false;
	}

	public float GetSteerMaxMult(float speed)
	{
		return 1f;
	}

	public override void OnEngineStartFailed()
	{
	}

	public override bool MeetsEngineRequirements()
	{
		return HasDriver();
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("MagnetCrane.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			rigidBody.ResetInertiaTensor();
			rigidBody.inertiaTensor = Vector3.Lerp(rigidBody.inertiaTensor, customInertiaTensor, 0.5f);
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float num = Mathf.Clamp(realtimeSinceStartup - lastFixedUpdateTime, 0f, 0.5f);
			lastFixedUpdateTime = realtimeSinceStartup;
			float speed = GetSpeed();
			carPhysics.FixedUpdate(Time.fixedDeltaTime, speed);
			serverTerrainHandler.FixedUpdate();
			bool flag = IsOn();
			if (IsOn())
			{
				float num2 = Mathf.Max(Mathf.Abs(throttleInput), Mathf.Abs(steerInput));
				float num3 = Mathf.Lerp(idleFuelPerSec, maxFuelPerSec, num2);
				if (!Magnet.HasConnectedObject())
				{
					num3 = Mathf.Min(num3, maxFuelPerSec * 0.75f);
				}
				engineController.TickFuel(num3);
			}
			engineController.CheckEngineState();
			if (IsOn() != flag)
			{
				GameObject[] onTriggers = OnTriggers;
				for (int i = 0; i < onTriggers.Length; i++)
				{
					onTriggers[i].SetActive(IsOn());
				}
			}
			if (Vector3.Dot(((Component)this).transform.up, Vector3.down) >= 0.4f)
			{
				Kill(DestroyMode.Gib);
				return;
			}
			if (realtimeSinceStartup > lastDrivenTime + 14400f)
			{
				Kill(DestroyMode.Gib);
				return;
			}
			if (spawnOrigin != Vector3.zero && maxDistanceFromOrigin != 0f)
			{
				if (Vector3Ex.Distance2D(((Component)this).transform.position, spawnOrigin) > maxDistanceFromOrigin)
				{
					if (Vector3Ex.Distance2D(((Component)this).transform.position, lastDamagePos) > 6f)
					{
						if ((Object)(object)GetDriver() != (Object)null)
						{
							GetDriver().ShowToast(GameTip.Styles.Red_Normal, ReturnMessage, false);
						}
						Hurt(MaxHealth() * 0.15f, DamageType.Generic, this, useProtection: false);
						lastDamagePos = ((Component)this).transform.position;
						nextSelfHealTime = realtimeSinceStartup + 3600f;
						Effect.server.Run(selfDamageEffect.resourcePath, ((Component)this).transform.position + Vector3.up * 2f, Vector3.up);
						return;
					}
				}
				else if (base.healthFraction < 1f && realtimeSinceStartup > nextSelfHealTime && base.SecondsSinceAttacked > 600f)
				{
					Heal(1000f);
				}
			}
			if (!HasDriver() || !IsOn())
			{
				handbrakeOn = true;
				throttleInput = 0f;
				steerInput = 0f;
				SetFlag(Flags.Reserved10, b: false);
				Magnet.SetMagnetEnabled(wantsOn: false, null);
			}
			else
			{
				lastDrivenTime = realtimeSinceStartup;
				if (Magnet.IsMagnetOn() && Magnet.HasConnectedObject() && GamePhysics.CheckOBB(Magnet.GetConnectedOBB(0.75f), 1084293121, (QueryTriggerInteraction)1))
				{
					Magnet.SetMagnetEnabled(wantsOn: false, null);
					nextToggleTime = realtimeSinceStartup + 2f;
					Effect.server.Run(selfDamageEffect.resourcePath, ((Component)Magnet).transform.position, Vector3.up);
				}
			}
			extensionMove = UpdateMoveInput(extensionInput, extensionMove, 3f, Time.fixedDeltaTime);
			yawMove = UpdateMoveInput(yawInput, yawMove, 3f, Time.fixedDeltaTime);
			raiseArmMove = UpdateMoveInput(raiseArmInput, raiseArmMove, 3f, Time.fixedDeltaTime);
			bool flag2 = extensionInput != 0f || raiseArmInput != 0f || yawInput != 0f;
			SetFlag(Flags.Reserved7, flag2);
			magnetDamage.damageEnabled = IsOn() && flag2;
			extensionArmState += extensionInput * arm1Speed * num;
			raiseArmState += raiseArmInput * arm2Speed * num;
			yawState += yawInput * turnYawSpeed * num;
			yawState %= 1f;
			if (yawState < 0f)
			{
				yawState += 1f;
			}
			extensionArmState = Mathf.Clamp(extensionArmState, -1f, 1f);
			raiseArmState = Mathf.Clamp(raiseArmState, -1f, 1f);
			UpdateAnimator(Time.fixedDeltaTime);
			Magnet.MagnetThink(Time.fixedDeltaTime);
			SetFlag(Flags.Reserved10, throttleInput != 0f || steerInput != 0f);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		static float UpdateMoveInput(float input, float move, float slowRate, float dt)
		{
			if (input != 0f)
			{
				return input;
			}
			return Mathf.MoveTowards(move, 0f, dt * slowRate);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.crane = Pool.Get<Crane>();
		info.msg.crane.arm1 = extensionArmState;
		info.msg.crane.arm2 = raiseArmState;
		info.msg.crane.yaw = yawState;
		info.msg.crane.time = GetNetworkTime();
		byte num = (byte)((carPhysics.TankThrottleLeft + 1f) * 7f);
		byte b = (byte)((carPhysics.TankThrottleRight + 1f) * 7f);
		byte treadInput = (byte)(num + (b << 4));
		info.msg.crane.treadInput = treadInput;
	}

	public void UpdateParams()
	{
		SendNetworkUpdate();
	}

	public void LateUpdate()
	{
		if (!base.isClient)
		{
			if (HasDriver() && IsColliding())
			{
				extensionArmState = lastExtensionArmState;
				raiseArmState = lastRaiseArmState;
				yawState = lastYawState;
				extensionInput = 0f - extensionInput;
				yawInput = 0f - yawInput;
				raiseArmInput = 0f - raiseArmInput;
				UpdateAnimator(Time.deltaTime);
			}
			else
			{
				lastExtensionArmState = extensionArmState;
				lastRaiseArmState = raiseArmState;
				lastYawState = yawState;
			}
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			BasePlayer driver = GetDriver();
			if ((Object)(object)driver != (Object)null && info.damageTypes.Has(DamageType.Bullet))
			{
				Capsule val = default(Capsule);
				((Capsule)(ref val))..ctor(((Component)driverCollision).transform.position, driverCollision.radius, driverCollision.height);
				float num = Vector3.Distance(info.PointStart, info.PointEnd);
				Ray val2 = default(Ray);
				((Ray)(ref val2))..ctor(info.PointStart, Vector3Ex.Direction(info.PointEnd, info.PointStart));
				RaycastHit val3 = default(RaycastHit);
				if (((Capsule)(ref val)).Trace(val2, ref val3, 0.05f, num * 1.2f))
				{
					driver.Hurt(info.damageTypes.Total() * 0.15f, DamageType.Bullet, info.Initiator);
				}
			}
		}
		base.OnAttacked(info);
	}

	public override void OnDied(HitInfo info)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (HasDriver())
		{
			GetDriver().Hurt(10000f, DamageType.Blunt, info.Initiator, useProtection: false);
		}
		if (explosionEffect.isValid)
		{
			Effect.server.Run(explosionEffect.resourcePath, explosionPoint.position, Vector3.up);
		}
		base.OnDied(info);
	}

	public bool IsColliding()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		Transform[] array = collisionTestingPoints;
		foreach (Transform val in array)
		{
			if (((Component)val).gameObject.activeSelf)
			{
				Vector3 position = val.position;
				Quaternion rotation = val.rotation;
				if (GamePhysics.CheckOBB(new OBB(position, new Vector3(val.localScale.x, val.localScale.y, val.localScale.z), rotation), 1084293121, (QueryTriggerInteraction)1))
				{
					return true;
				}
			}
		}
		return false;
	}

	public float GetMaxDriveForce()
	{
		return (float)engineKW * 10f;
	}

	public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float num = MathEx.BiasedLerp(1f - absSpeed / topSpeed, 0.5f);
		num = Mathf.Lerp(num, 1f, Mathf.Abs(steerInput));
		return GetMaxDriveForce() * num;
	}

	public CarWheel[] GetWheels()
	{
		return wheels;
	}

	public float GetWheelsMidPos()
	{
		return 0f;
	}

	public void UpdateAnimator(float dt)
	{
		animator.SetFloat("Arm_01", extensionArmState);
		animator.SetFloat("Arm_02", raiseArmState);
		animator.SetFloat("Yaw", yawState);
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Mailbox : StorageContainer
{
	public string ownerPanel;

	public GameObjectRef mailDropSound;

	public bool autoSubmitWhenClosed;

	public bool shouldMarkAsFull;

	public int InputSlotCount = 1;

	[NonSerialized]
	public ItemContainer InputContainer;

	public int mailInputSlot => 0;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Mailbox.OnRpcMessage", 0);
		try
		{
			if (rpc == 131727457 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Submit "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Submit", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_Submit(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_Submit");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

	public bool IsFull()
	{
		if (shouldMarkAsFull)
		{
			return HasFlag(Flags.Reserved1);
		}
		return false;
	}

	public void MarkFull(bool full)
	{
		SetFlag(Flags.Reserved1, shouldMarkAsFull && full);
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		return base.PlayerOpenLoot(player, PlayerIsOwner(player) ? ownerPanel : panelToOpen);
	}

	public override void AddContainers(PlayerLoot loot)
	{
		if (PlayerIsOwner(loot.GetCastedEntity()))
		{
			loot.AddContainer(base.inventory);
		}
		else
		{
			loot.AddContainer(InputContainer);
		}
	}

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		if (panelName == ownerPanel)
		{
			if (PlayerIsOwner(player))
			{
				return base.CanOpenLootPanel(player, panelName);
			}
			return false;
		}
		if (!HasFreeSpace())
		{
			return !shouldMarkAsFull;
		}
		return true;
	}

	private bool HasFreeSpace()
	{
		return !base.inventory.IsFull();
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (autoSubmitWhenClosed)
		{
			SubmitInputItems(player);
		}
		if (IsFull())
		{
			base.inventory.GetSlot(mailInputSlot)?.Drop(GetDropPosition(), GetDropVelocity());
		}
		base.PlayerStoppedLooting(player);
		if (PlayerIsOwner(player))
		{
			SetFlag(Flags.On, b: false);
		}
	}

	[RPC_Server]
	public void RPC_Submit(RPCMessage msg)
	{
		if (!IsFull())
		{
			BasePlayer player = msg.player;
			SubmitInputItems(player);
		}
	}

	public void SubmitInputItems(BasePlayer fromPlayer)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < InputContainer.capacity; i++)
		{
			Item slot = InputContainer.GetSlot(i);
			if (slot != null && Interface.CallHook("OnItemSubmit", (object)slot, (object)this, (object)fromPlayer) == null && slot.MoveToContainer(base.inventory))
			{
				Effect.server.Run(mailDropSound.resourcePath, GetDropPosition());
				if ((Object)(object)fromPlayer != (Object)null && !PlayerIsOwner(fromPlayer))
				{
					SetFlag(Flags.On, b: true);
				}
			}
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		MarkFull(!HasFreeSpace());
		base.OnItemAddedOrRemoved(item, added);
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (allowedItems == null || allowedItems.Length == 0)
		{
			return base.ItemFilter(item, targetSlot);
		}
		ItemDefinition[] array = allowedItems;
		foreach (ItemDefinition itemDefinition in array)
		{
			if ((Object)(object)item.info == (Object)(object)itemDefinition)
			{
				return true;
			}
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		Mailbox val = Pool.Get<Mailbox>();
		val.inventory = InputContainer.Save();
		info.msg.mailbox = val;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer && info.msg.mailbox != null && info.msg.mailbox.inventory != null)
		{
			InputContainer.Load(info.msg.mailbox.inventory);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (InputContainer == null)
		{
			InputContainer = Pool.Get<ItemContainer>();
			InputContainer.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
			InputContainer.SetOnlyAllowedItem(allowedItem);
			InputContainer.entityOwner = this;
			InputContainer.maxStackSize = maxStackSize;
			InputContainer.ServerInitialize(null, InputSlotCount);
			InputContainer.GiveUID();
			InputContainer.onDirty += OnInventoryDirty;
			InputContainer.onItemAddedRemoved = OnItemAddedOrRemoved;
			ItemContainer inputContainer = InputContainer;
			inputContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(inputContainer.canAcceptItem, new Func<Item, int, bool>(ItemFilter));
			OnInventoryFirstCreated(InputContainer);
		}
	}

	public override void GetAllInventories(List<ItemContainer> list)
	{
		base.GetAllInventories(list);
		list.Add(InputContainer);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class MapEntity : HeldEntity
{
	[NonSerialized]
	public uint[] fogImages = new uint[1];

	[NonSerialized]
	public uint[] paintImages = new uint[144];

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MapEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 1443560440 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ImageUpdate "));
				}
				TimeWarning val2 = TimeWarning.New("ImageUpdate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1443560440u, "ImageUpdate", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1443560440u, "ImageUpdate", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ImageUpdate(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ImageUpdate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.mapEntity != null)
		{
			if (info.msg.mapEntity.fogImages.Count == fogImages.Length)
			{
				fogImages = info.msg.mapEntity.fogImages.ToArray();
			}
			if (info.msg.mapEntity.paintImages.Count == paintImages.Length)
			{
				paintImages = info.msg.mapEntity.paintImages.ToArray();
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.mapEntity = Pool.Get<MapEntity>();
		info.msg.mapEntity.fogImages = Pool.Get<List<uint>>();
		info.msg.mapEntity.fogImages.AddRange(fogImages);
		info.msg.mapEntity.paintImages = Pool.Get<List<uint>>();
		info.msg.mapEntity.paintImages.AddRange(paintImages);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void ImageUpdate(RPCMessage msg)
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null)
		{
			return;
		}
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))
		{
			return;
		}
		uint num2 = (uint)(b * 1000 + b2);
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (array != null)
		{
			FileStorage.server.RemoveEntityNum(net.ID, num2);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
			if (b == 0)
			{
				fogImages[b2] = num3;
			}
			if (b == 1)
			{
				paintImages[b2] = num3;
			}
			InvalidateNetworkCache();
			Interface.CallHook("OnMapImageUpdated");
		}
	}
}


using System;
using Network;
using ProtoBuf;
using UnityEngine;

public class MapMarkerGenericRadius : MapMarker
{
	public float radius;

	public Color color1;

	public Color color2;

	public float alpha;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MapMarkerGenericRadius.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void SendUpdate(bool fullUpdate = true)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		float a = color1.a;
		Vector3 arg = default(Vector3);
		((Vector3)(ref arg))..ctor(color1.r, color1.g, color1.b);
		Vector3 arg2 = default(Vector3);
		((Vector3)(ref arg2))..ctor(color2.r, color2.g, color2.b);
		ClientRPC(RpcTarget.NetworkGroup("MarkerUpdate"), arg, a, arg2, alpha, radius);
	}

	public override AppMarker GetAppMarkerData()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		AppMarker appMarkerData = base.GetAppMarkerData();
		appMarkerData.radius = radius;
		appMarkerData.color1 = Color.op_Implicit(color1);
		appMarkerData.color2 = Color.op_Implicit(color2);
		appMarkerData.alpha = alpha;
		return appMarkerData;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;

public class MarketTerminal : StorageContainer
{
	public const Flags Flag_HasItems = Flags.Reserved1;

	public const Flags Flag_InventoryFull = Flags.Reserved2;

	[Header("Market Terminal")]
	public GameObjectRef menuPrefab;

	public ulong lockToCustomerDuration = 300uL;

	public ulong orderTimeout = 180uL;

	public ItemDefinition deliveryFeeCurrency;

	public int deliveryFeeAmount;

	public DeliveryDroneConfig config;

	public RustText userLabel;

	private ulong _customerSteamId;

	private string _customerName;

	private TimeUntil _timeUntilCustomerExpiry;

	private EntityRef<Marketplace> _marketplace;

	public List<PendingOrder> pendingOrders;

	public Action<BasePlayer, Item> _onCurrencyRemovedCached;

	public Action<BasePlayer, Item> _onItemPurchasedCached;

	private Action _checkForExpiredOrdersCached;

	private bool _transactionActive;

	private static readonly List<NetworkableId> _deliveryEligible = new List<NetworkableId>(128);

	private static RealTimeSince _deliveryEligibleLastCalculated;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MarketTerminal.OnRpcMessage", 0);
		try
		{
			if (rpc == 3793918752u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_Purchase "));
				}
				TimeWarning val2 = TimeWarning.New("Server_Purchase", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3793918752u, "Server_Purchase", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3793918752u, "Server_Purchase", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_Purchase(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_Purchase");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1382511247 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_TryOpenMarket "));
				}
				TimeWarning val2 = TimeWarning.New("Server_TryOpenMarket", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1382511247u, "Server_TryOpenMarket", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1382511247u, "Server_TryOpenMarket", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_TryOpenMarket(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_TryOpenMarket");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool CanPlayerAffordOrderAndDeliveryFee(BasePlayer player, SellOrder sellOrder, int numberOfTransactions)
	{
		PooledList<Item> val = Pool.Get<PooledList<Item>>();
		try
		{
			player.inventory.FindItemsByItemID((List<Item>)(object)val, deliveryFeeCurrency.itemid);
			int num = ((IEnumerable<Item>)val).Sum((Item i) => i.amount);
			int num2 = deliveryFeeAmount;
			if (num < num2)
			{
				return false;
			}
			if (sellOrder != null)
			{
				int num3 = VendingMachine.GetTotalPriceForOrder(sellOrder) * numberOfTransactions;
				if (sellOrder.currencyID == deliveryFeeCurrency.itemid && !sellOrder.currencyIsBP && num < num2 + num3)
				{
					return false;
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool HasPendingOrderFor(NetworkableId vendingMachineId)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		List<PendingOrder> list = pendingOrders;
		return ((list != null) ? List.FindWith<PendingOrder, NetworkableId>((IReadOnlyCollection<PendingOrder>)list, (Func<PendingOrder, NetworkableId>)((PendingOrder o) => o.vendingMachineId), vendingMachineId, (IEqualityComparer<NetworkableId>)null) : null) != null;
	}

	public bool CanPlayerInteract(BasePlayer player)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (_customerSteamId == 0L || TimeUntil.op_Implicit(_timeUntilCustomerExpiry) <= 0f)
		{
			return true;
		}
		return (ulong)player.userID == _customerSteamId;
	}

	public override void Load(LoadInfo info)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.marketTerminal == null)
		{
			return;
		}
		_customerSteamId = info.msg.marketTerminal.customerSteamId;
		_customerName = info.msg.marketTerminal.customerName;
		_timeUntilCustomerExpiry = info.msg.marketTerminal.timeUntilExpiry;
		_marketplace = new EntityRef<Marketplace>(info.msg.marketTerminal.marketplaceId);
		if (pendingOrders == null)
		{
			pendingOrders = Pool.Get<List<PendingOrder>>();
		}
		if (pendingOrders.Count > 0)
		{
			foreach (PendingOrder pendingOrder in pendingOrders)
			{
				PendingOrder current = pendingOrder;
				Pool.Free<PendingOrder>(ref current);
			}
			pendingOrders.Clear();
		}
		foreach (PendingOrder order in info.msg.marketTerminal.orders)
		{
			PendingOrder item = order.Copy();
			pendingOrders.Add(item);
		}
	}

	public void Setup(Marketplace marketplace)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		_marketplace = new EntityRef<Marketplace>(marketplace.net.ID);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		_onCurrencyRemovedCached = OnCurrencyRemoved;
		_onItemPurchasedCached = OnItemPurchased;
		_checkForExpiredOrdersCached = CheckForExpiredOrders;
	}

	private void RegisterOrder(BasePlayer player, VendingMachine vendingMachine)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (pendingOrders == null)
		{
			pendingOrders = Pool.Get<List<PendingOrder>>();
		}
		if (HasPendingOrderFor(vendingMachine.net.ID))
		{
			return;
		}
		if (!_marketplace.TryGet(serverside: true, out var entity))
		{
			Debug.LogError((object)"Marketplace is not set", (Object)(object)this);
			return;
		}
		NetworkableId droneId = entity.SendDrone(player, this, vendingMachine);
		if (!((NetworkableId)(ref droneId)).IsValid)
		{
			Debug.LogError((object)"Failed to spawn delivery drone");
			return;
		}
		PendingOrder val = Pool.Get<PendingOrder>();
		val.vendingMachineId = vendingMachine.net.ID;
		val.timeUntilExpiry = TimeUntil.op_Implicit((float)orderTimeout);
		val.droneId = droneId;
		pendingOrders.Add(val);
		CheckForExpiredOrders();
		UpdateHasItems(sendNetworkUpdate: false);
		SendNetworkUpdateImmediate();
	}

	public void CompleteOrder(NetworkableId vendingMachineId)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (pendingOrders != null)
		{
			int num = List.FindIndexWith<PendingOrder, NetworkableId>((IReadOnlyList<PendingOrder>)pendingOrders, (Func<PendingOrder, NetworkableId>)((PendingOrder o) => o.vendingMachineId), vendingMachineId, (IEqualityComparer<NetworkableId>)null);
			if (num < 0)
			{
				Debug.LogError((object)"Completed market order that doesn't exist?");
				return;
			}
			pendingOrders[num].Dispose();
			pendingOrders.RemoveAt(num);
			CheckForExpiredOrders();
			UpdateHasItems(sendNetworkUpdate: false);
			SendNetworkUpdateImmediate();
		}
	}

	private void CheckForExpiredOrders()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		if (pendingOrders != null && pendingOrders.Count > 0)
		{
			bool flag = false;
			float? num = null;
			for (int i = 0; i < pendingOrders.Count; i++)
			{
				PendingOrder val = pendingOrders[i];
				if (TimeUntil.op_Implicit(val.timeUntilExpiry) <= 0f)
				{
					if (new EntityRef<DeliveryDrone>(val.droneId).TryGet(serverside: true, out var entity))
					{
						Debug.LogError((object)"Delivery timed out waiting for drone (too slow speed?)", (Object)(object)this);
						entity.Kill();
					}
					else
					{
						Debug.LogError((object)"Delivery timed out waiting for drone, and the drone seems to have been destroyed?", (Object)(object)this);
					}
					pendingOrders.RemoveAt(i);
					i--;
					flag = true;
				}
				else if (!num.HasValue || TimeUntil.op_Implicit(val.timeUntilExpiry) < num.Value)
				{
					num = TimeUntil.op_Implicit(val.timeUntilExpiry);
				}
			}
			if (flag)
			{
				UpdateHasItems(sendNetworkUpdate: false);
				SendNetworkUpdate();
			}
			if (num.HasValue)
			{
				((FacepunchBehaviour)this).Invoke(_checkForExpiredOrdersCached, num.Value);
			}
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke(_checkForExpiredOrdersCached);
		}
	}

	private void RestrictToPlayer(BasePlayer player)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (_customerSteamId == (ulong)player.userID)
		{
			_timeUntilCustomerExpiry = TimeUntil.op_Implicit((float)lockToCustomerDuration);
			SendNetworkUpdate();
			return;
		}
		if (_customerSteamId != 0L)
		{
			Debug.LogError((object)"Overwriting player restriction! It should be cleared first.", (Object)(object)this);
		}
		_customerSteamId = player.userID;
		_customerName = player.displayName;
		_timeUntilCustomerExpiry = TimeUntil.op_Implicit((float)lockToCustomerDuration);
		SendNetworkUpdateImmediate();
		ClientRPC(RpcTarget.NetworkGroup("Client_CloseMarketUI"), _customerSteamId);
		RemoveAnyLooters();
		if (IsOpen())
		{
			Debug.LogError((object)"Market terminal's inventory is still open after removing looters!", (Object)(object)this);
		}
	}

	private void ClearRestriction()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (_customerSteamId != 0L)
		{
			_customerSteamId = 0uL;
			_customerName = null;
			_timeUntilCustomerExpiry = TimeUntil.op_Implicit(0f);
			SendNetworkUpdateImmediate();
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void Server_TryOpenMarket(RPCMessage msg)
	{
		if (!CanPlayerInteract(msg.player))
		{
			return;
		}
		if (!_marketplace.IsValid(serverside: true))
		{
			Debug.LogError((object)"Marketplace is not set", (Object)(object)this);
			return;
		}
		EntityIdList val = Pool.Get<EntityIdList>();
		try
		{
			val.entityIds = Pool.Get<List<NetworkableId>>();
			GetDeliveryEligibleVendingMachines(val.entityIds);
			ClientRPC(RpcTarget.Player("Client_OpenMarket", msg.player), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server.IsVisible(3f)]
	public void Server_Purchase(RPCMessage msg)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		if (!CanPlayerInteract(msg.player))
		{
			return;
		}
		if (!_marketplace.IsValid(serverside: true))
		{
			Debug.LogError((object)"Marketplace is not set", (Object)(object)this);
			return;
		}
		NetworkableId val = msg.read.EntityID();
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		VendingMachine vendingMachine = BaseNetworkable.serverEntities.Find(val) as VendingMachine;
		if ((Object)(object)vendingMachine == (Object)null || !vendingMachine.IsValid() || num < 0 || num >= vendingMachine.sellOrders.sellOrders.Count || num2 <= 0 || base.inventory.IsFull())
		{
			return;
		}
		GetDeliveryEligibleVendingMachines(null);
		if (_deliveryEligible == null || !_deliveryEligible.Contains(val))
		{
			return;
		}
		try
		{
			_transactionActive = true;
			int num3 = deliveryFeeAmount;
			SellOrder sellOrder = vendingMachine.sellOrders.sellOrders[num];
			if (!CanPlayerAffordOrderAndDeliveryFee(msg.player, sellOrder, num2))
			{
				return;
			}
			int num4 = msg.player.inventory.Take(null, deliveryFeeCurrency.itemid, num3);
			if (num4 != num3)
			{
				Debug.LogError((object)$"Took an incorrect number of items for the delivery fee (took {num4}, should have taken {num3})");
			}
			ClientRPC(RpcTarget.Player("Client_ShowItemNotice", msg.player), deliveryFeeCurrency.itemid, -num3, arg3: false);
			if (!vendingMachine.DoTransaction(msg.player, num, num2, base.inventory, _onCurrencyRemovedCached, _onItemPurchasedCached, this))
			{
				Item item = ItemManager.CreateByItemID(deliveryFeeCurrency.itemid, num3, 0uL);
				if (!msg.player.inventory.GiveItem(item))
				{
					item.Drop(msg.player.inventory.containerMain.dropPosition, msg.player.inventory.containerMain.dropVelocity);
				}
			}
			else
			{
				RestrictToPlayer(msg.player);
				RegisterOrder(msg.player, vendingMachine);
			}
		}
		finally
		{
			_transactionActive = false;
		}
	}

	private void UpdateHasItems(bool sendNetworkUpdate = true)
	{
		if (!Application.isLoadingSave)
		{
			bool flag = base.inventory.itemList.Count > 0;
			bool flag2 = pendingOrders != null && pendingOrders.Count != 0;
			SetFlag(Flags.Reserved1, flag && !flag2, recursive: false, sendNetworkUpdate);
			SetFlag(Flags.Reserved2, base.inventory.IsFull(), recursive: false, sendNetworkUpdate);
			if (!flag && !flag2)
			{
				ClearRestriction();
			}
		}
	}

	private void OnCurrencyRemoved(BasePlayer player, Item currencyItem)
	{
		if ((Object)(object)player != (Object)null && currencyItem != null)
		{
			ClientRPC(RpcTarget.Player("Client_ShowItemNotice", player), currencyItem.info.itemid, -currencyItem.amount, arg3: false);
		}
	}

	private void OnItemPurchased(BasePlayer player, Item purchasedItem)
	{
		if ((Object)(object)player != (Object)null && purchasedItem != null)
		{
			ClientRPC(RpcTarget.Player("Client_ShowItemNotice", player), purchasedItem.info.itemid, purchasedItem.amount, arg3: true);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.marketTerminal = Pool.Get<MarketTerminal>();
		info.msg.marketTerminal.customerSteamId = _customerSteamId;
		info.msg.marketTerminal.customerName = _customerName;
		info.msg.marketTerminal.timeUntilExpiry = _timeUntilCustomerExpiry;
		info.msg.marketTerminal.marketplaceId = _marketplace.uid;
		info.msg.marketTerminal.orders = Pool.Get<List<PendingOrder>>();
		if (pendingOrders == null)
		{
			return;
		}
		foreach (PendingOrder pendingOrder in pendingOrders)
		{
			PendingOrder item = pendingOrder.Copy();
			info.msg.marketTerminal.orders.Add(item);
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (_transactionActive)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (item.parent == base.inventory)
		{
			return true;
		}
		return false;
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		UpdateHasItems();
	}

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		if (CanPlayerInteract(player) && HasFlag(Flags.Reserved1))
		{
			return base.CanOpenLootPanel(player, panelName);
		}
		return false;
	}

	private void RemoveAnyLooters()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ItemContainer item = base.inventory;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && !((Object)(object)current.inventory == (Object)null) && !((Object)(object)current.inventory.loot == (Object)null) && current.inventory.loot.containers.Contains(item))
				{
					current.inventory.loot.Clear();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void GetDeliveryEligibleVendingMachines(List<NetworkableId> vendingMachineIds)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		if (RealTimeSince.op_Implicit(_deliveryEligibleLastCalculated) < 5f)
		{
			if (vendingMachineIds == null)
			{
				return;
			}
			{
				foreach (NetworkableId item in _deliveryEligible)
				{
					vendingMachineIds.Add(item);
				}
				return;
			}
		}
		_deliveryEligibleLastCalculated = RealTimeSince.op_Implicit(0f);
		_deliveryEligible.Clear();
		foreach (MapMarker serverMapMarker in MapMarker.serverMapMarkers)
		{
			if (serverMapMarker is VendingMachineMapMarker vendingMachineMapMarker && !((Object)(object)vendingMachineMapMarker.server_vendingMachine == (Object)null))
			{
				VendingMachine server_vendingMachine = vendingMachineMapMarker.server_vendingMachine;
				if (!((Object)(object)server_vendingMachine == (Object)null) && (IsEligible(server_vendingMachine, config.vendingMachineOffset, 1) || IsEligible(server_vendingMachine, config.vendingMachineOffset + Vector3.forward * config.maxDistanceFromVendingMachine, 2)))
				{
					_deliveryEligible.Add(server_vendingMachine.net.ID);
				}
			}
		}
		if (vendingMachineIds == null)
		{
			return;
		}
		foreach (NetworkableId item2 in _deliveryEligible)
		{
			vendingMachineIds.Add(item2);
		}
		bool IsEligible(VendingMachine vendingMachine, Vector3 offset, int n)
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			object obj = Interface.CallHook("CanAccessVendingMachine", (object)config, (object)vendingMachine);
			if (obj is bool)
			{
				return (bool)obj;
			}
			if (vendingMachine is NPCVendingMachine)
			{
				return true;
			}
			if (!vendingMachine.IsBroadcasting())
			{
				return false;
			}
			if (!config.IsVendingMachineAccessible(vendingMachine, offset, out var _))
			{
				return false;
			}
			return true;
		}
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class MedicalTool : AttackEntity
{
	public float healDurationSelf = 4f;

	public float healDurationOther = 4f;

	public float healDurationOtherWounded = 7f;

	public float maxDistanceOther = 2f;

	public bool canUseOnOther = true;

	public bool canRevive = true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MedicalTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 789049461 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UseOther "));
				}
				TimeWarning val2 = TimeWarning.New("UseOther", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(789049461u, "UseOther", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							UseOther(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in UseOther");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2918424470u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UseSelf "));
				}
				TimeWarning val2 = TimeWarning.New("UseSelf", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(2918424470u, "UseSelf", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							UseSelf(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UseSelf");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void UseOther(RPCMessage msg)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else if (player.CanInteract() && HasItemAmount() && canUseOnOther)
		{
			BasePlayer basePlayer = BaseNetworkable.serverEntities.Find(msg.read.EntityID()) as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && Vector3.Distance(((Component)basePlayer).transform.position, ((Component)player).transform.position) < 4f)
			{
				ClientRPC(RpcTarget.Player("Reset", player));
				GiveEffectsTo(basePlayer);
				UseItemAmount(1);
				StartAttackCooldown(repeatDelay);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void UseSelf(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else if (player.CanInteract() && HasItemAmount())
		{
			ClientRPC(RpcTarget.Player("Reset", player));
			GiveEffectsTo(player);
			UseItemAmount(1);
			StartAttackCooldown(repeatDelay);
		}
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		if (base.isClient)
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer == (Object)null) && ownerPlayer.CanInteract() && HasItemAmount())
		{
			GiveEffectsTo(ownerPlayer);
			UseItemAmount(1);
			StartAttackCooldown(repeatDelay);
			SignalBroadcast(Signal.Attack, string.Empty);
			if (ownerPlayer.IsNpc)
			{
				ownerPlayer.SignalBroadcast(Signal.Attack);
			}
		}
	}

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!Object.op_Implicit((Object)(object)player))
		{
			return;
		}
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		ItemModConsumable component = ((Component)ownerItemDefinition).GetComponent<ItemModConsumable>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			Debug.LogWarning((object)("No consumable for medicaltool :" + ((Object)this).name));
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", (object)this, (object)player) != null)
			{
				return;
			}
			BasePlayer ownerPlayer = GetOwnerPlayer();
			Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);
			if ((Object)(object)player != (Object)(object)ownerPlayer)
			{
				if (Interface.CallHook("OnPlayerRevive", (object)GetOwnerPlayer(), (object)player) != null)
				{
					return;
				}
				if (player.IsWounded() && canRevive)
				{
					player.StopWounded(ownerPlayer);
				}
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
					player.ProcessMissionEvent(BaseMission.MissionEventType.HEAL, prefabID, effect.amount);
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
			if (player is BasePet)
			{
				player.SendNetworkUpdateImmediate();
			}
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class Megaphone : HeldEntity
{
	[Header("Megaphone")]
	public VoiceProcessor voiceProcessor;

	public float VoiceDamageMinFrequency = 2f;

	public float VoiceDamageAmount = 1f;

	public AudioSource VoiceSource;

	public SoundDefinition StartBroadcastingSfx;

	public SoundDefinition StopBroadcastingSfx;

	[ReplicatedVar(Default = "100")]
	public static float MegaphoneVoiceRange { get; set; } = 100f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Megaphone.OnRpcMessage", 0);
		try
		{
			if (rpc == 4196056309u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_ToggleBroadcasting "));
				}
				TimeWarning val2 = TimeWarning.New("Server_ToggleBroadcasting", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(4196056309u, "Server_ToggleBroadcasting", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_ToggleBroadcasting(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_ToggleBroadcasting");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void UpdateItemCondition()
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null && ownerItem.hasCondition)
		{
			ownerItem.LoseCondition(VoiceDamageAmount);
		}
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void Server_ToggleBroadcasting(RPCMessage msg)
	{
		bool flag = msg.read.Int8() == 1;
		SetFlag(Flags.On, flag);
		if (flag)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdateItemCondition))
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateItemCondition, 0f, VoiceDamageMinFrequency);
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)UpdateItemCondition))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateItemCondition);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Audio;

public class MicrophoneStand : BaseMountable
{
	public enum SpeechMode
	{
		Normal,
		HighPitch,
		LowPitch
	}

	public VoiceProcessor VoiceProcessor;

	public AudioSource VoiceSource;

	private SpeechMode currentSpeechMode;

	public AudioMixerGroup NormalMix;

	public AudioMixerGroup HighPitchMix;

	public AudioMixerGroup LowPitchMix;

	public Phrase NormalPhrase = new Phrase("microphone_normal", "Normal");

	public Phrase NormalDescPhrase = new Phrase("microphone_normal_desc", "No voice effect");

	public Phrase HighPitchPhrase = new Phrase("microphone_high", "High Pitch");

	public Phrase HighPitchDescPhrase = new Phrase("microphone_high_desc", "High pitch voice");

	public Phrase LowPitchPhrase = new Phrase("microphone_low", "Low");

	public Phrase LowPitchDescPhrase = new Phrase("microphone_low_desc", "Low pitch voice");

	public GameObjectRef IOSubEntity;

	public Transform IOSubEntitySpawnPos;

	public bool IsStatic;

	public EntityRef<IOEntity> ioEntity;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MicrophoneStand.OnRpcMessage", 0);
		try
		{
			if (rpc == 1420522459 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetMode "));
				}
				TimeWarning val2 = TimeWarning.New("SetMode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage mode = rPCMessage;
						SetMode(mode);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in SetMode");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	public void SetMode(RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)GetMounted()))
		{
			SpeechMode speechMode = (SpeechMode)msg.read.Int32();
			if (speechMode != currentSpeechMode)
			{
				currentSpeechMode = speechMode;
				SendNetworkUpdate();
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.microphoneStand == null)
		{
			info.msg.microphoneStand = Pool.Get<MicrophoneStand>();
		}
		info.msg.microphoneStand.microphoneMode = (int)currentSpeechMode;
		info.msg.microphoneStand.IORef = ioEntity.uid;
	}

	public void SpawnChildEntity()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		MicrophoneStandIOEntity microphoneStandIOEntity = GameManager.server.CreateEntity(IOSubEntity.resourcePath, IOSubEntitySpawnPos.localPosition, IOSubEntitySpawnPos.localRotation) as MicrophoneStandIOEntity;
		microphoneStandIOEntity.enableSaving = enableSaving;
		microphoneStandIOEntity.SetParent(this);
		microphoneStandIOEntity.Spawn();
		ioEntity.Set(microphoneStandIOEntity);
		SendNetworkUpdate();
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		SpawnChildEntity();
	}

	public override void PostMapEntitySpawn()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		base.PostMapEntitySpawn();
		if (!IsStatic)
		{
			return;
		}
		SpawnChildEntity();
		int num = 128;
		List<ConnectedSpeaker> list = Pool.Get<List<ConnectedSpeaker>>();
		GamePhysics.OverlapSphere<ConnectedSpeaker>(((Component)this).transform.position, (float)num, list, 256, (QueryTriggerInteraction)1);
		IOEntity iOEntity = ioEntity.Get(serverside: true);
		List<MicrophoneStand> list2 = Pool.Get<List<MicrophoneStand>>();
		int num2 = 0;
		foreach (ConnectedSpeaker item in list)
		{
			bool flag = true;
			list2.Clear();
			GamePhysics.OverlapSphere<MicrophoneStand>(((Component)item).transform.position, (float)num, list2, 256, (QueryTriggerInteraction)1);
			if (list2.Count > 1)
			{
				float num3 = Distance((BaseEntity)item);
				foreach (MicrophoneStand item2 in list2)
				{
					if (!item2.isClient && item2.Distance((BaseEntity)item) < num3)
					{
						flag = false;
						break;
					}
				}
			}
			if (flag)
			{
				iOEntity.outputs[0].connectedTo.Set(item);
				item.inputs[0].connectedTo.Set(iOEntity);
				iOEntity = item;
				num2++;
			}
		}
		Pool.FreeUnmanaged<ConnectedSpeaker>(ref list);
		Pool.FreeUnmanaged<MicrophoneStand>(ref list2);
	}

	public override void Load(LoadInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.microphoneStand != null)
		{
			currentSpeechMode = (SpeechMode)info.msg.microphoneStand.microphoneMode;
			ioEntity.uid = info.msg.microphoneStand.IORef;
		}
	}
}


public enum SpeechMode
{
	Normal,
	HighPitch,
	LowPitch
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class MissionSlowUseObject : BaseEntity
{
	public float InteractTime = 5f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MissionSlowUseObject.OnRpcMessage", 0);
		try
		{
			if (rpc == 2005407348 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerUse "));
				}
				TimeWarning val2 = TimeWarning.New("ServerUse", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2005407348u, "ServerUse", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerUse(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerUse");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool CanPlayerUse(BasePlayer bp)
	{
		BaseMission.MissionInstance activeMissionInstance = bp.GetActiveMissionInstance();
		if (activeMissionInstance != null)
		{
			BaseMission.MissionObjectiveEntry[] objectives = activeMissionInstance.GetMission().objectives;
			for (int i = 0; i < objectives.Length; i++)
			{
				if (objectives[i].objective is MissionObjective_ActivateLongUseObject missionObjective_ActivateLongUseObject && missionObjective_ActivateLongUseObject.RequiredEntity.prefabID == prefabID)
				{
					return true;
				}
			}
		}
		return false;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ServerUse(RPCMessage msg)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (CanPlayerUse(player))
		{
			player.ProcessMissionEvent(BaseMission.MissionEventType.LONG_USE_OBJECT, net.ID, 1f);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class MixingTable : StorageContainer
{
	public enum Type
	{
		Mixing,
		Cooking
	}

	public GameObject Particles;

	public Type TableType;

	public RecipeList Recipes;

	public bool OnlyAcceptValidIngredients;

	public bool visualFood;

	public float lastTickTimestamp;

	private List<Item> inventoryItems = new List<Item>();

	private const float mixTickInterval = 1f;

	protected Recipe currentRecipe;

	public int currentQuantity;

	public ItemDefinition currentProductionItem;

	private int pendingItemId;

	private static Dictionary<int, int> itemCostCache = new Dictionary<int, int>();

	public float RemainingMixTime { get; set; }

	public float TotalMixTime { get; set; }

	public int CookingItemId { get; private set; }

	public BasePlayer MixStartingPlayer { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MixingTable.OnRpcMessage", 0);
		try
		{
			if (rpc == 4291077201u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_FillInventoryForRecipe "));
				}
				TimeWarning val2 = TimeWarning.New("SV_FillInventoryForRecipe", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4291077201u, "SV_FillInventoryForRecipe", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4291077201u, "SV_FillInventoryForRecipe", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(4291077201u, "SV_FillInventoryForRecipe", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_FillInventoryForRecipe(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_FillInventoryForRecipe");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SVSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4167839872u, "SVSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SVSwitch(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SVSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
		base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
		RecipeDictionary.CacheRecipes(Recipes);
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		if (item == null)
		{
			return false;
		}
		if (!OnlyAcceptValidIngredients)
		{
			return true;
		}
		if (GetItemWaterAmount(item) > 0)
		{
			item = item.contents.itemList[0];
		}
		if (!((Object)(object)item.info == (Object)(object)currentProductionItem))
		{
			return RecipeDictionary.ValidIngredientForARecipe(item, Recipes);
		}
		return true;
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		if (IsOn())
		{
			StopMixing();
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void SV_FillInventoryForRecipe(RPCMessage msg)
	{
		if ((Object)(object)msg.player == (Object)null)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num >= 0 && num < Recipes.AllRecipes.Count)
		{
			Recipe recipe = Recipes.AllRecipes[num];
			if (!((Object)(object)recipe == (Object)null))
			{
				int amount = msg.read.Int32();
				TryFillInventoryForRecipe(recipe, msg.player, amount);
			}
		}
	}

	private void TryFillInventoryForRecipe(Recipe recipe, BasePlayer player, int amount)
	{
		if ((Object)(object)recipe == (Object)null || (Object)(object)player == (Object)null || amount <= 0)
		{
			return;
		}
		Recipe matchingInventoryRecipe = GetMatchingInventoryRecipe(base.inventory);
		ItemContainer tableContainer = (((Object)(object)matchingInventoryRecipe != (Object)(object)recipe) ? base.inventory : null);
		if (!CanPlayerAffordRecipe(player, recipe, tableContainer, amount))
		{
			return;
		}
		if ((Object)(object)matchingInventoryRecipe != (Object)(object)recipe)
		{
			ReturnInventory(player);
		}
		int num = 0;
		Recipe.RecipeIngredient[] ingredients = recipe.Ingredients;
		for (int i = 0; i < ingredients.Length; i++)
		{
			Recipe.RecipeIngredient recipeIngredient = ingredients[i];
			int num2 = base.inventory.GetSlot(num)?.amount ?? 0;
			int ingredientCount = recipeIngredient.GetIngredientCount(recipe.ProducedItem);
			int num3 = ingredientCount * amount;
			int num4 = Mathf.Clamp(recipeIngredient.Ingredient.stackable - num2, 0, recipeIngredient.Ingredient.stackable);
			if (num3 > num4)
			{
				int num5 = num4 / ingredientCount;
				if (num5 < amount)
				{
					amount = num5;
				}
			}
			num++;
		}
		if (amount <= 0)
		{
			return;
		}
		num = 0;
		ingredients = recipe.Ingredients;
		for (int i = 0; i < ingredients.Length; i++)
		{
			Recipe.RecipeIngredient recipeIngredient2 = ingredients[i];
			PooledList<Item> val = Pool.Get<PooledList<Item>>();
			try
			{
				int num6 = recipeIngredient2.GetIngredientCount(recipe.ProducedItem) * amount;
				if (player.inventory.Take((List<Item>)(object)val, recipeIngredient2.Ingredient.itemid, num6) >= num6)
				{
					foreach (Item item in (List<Item>)(object)val)
					{
						if (!item.MoveToContainer(base.inventory, num))
						{
							player.inventory.GiveItem(item);
						}
					}
				}
				num++;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		ItemManager.DoRemoves();
	}

	private void ReturnInventory(BasePlayer player)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null && !slot.MoveToContainer(player.inventory.containerMain) && !slot.MoveToContainer(player.inventory.containerBelt))
			{
				slot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		ItemManager.DoRemoves();
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnMixingTableToggle", (object)this, (object)msg.player) != null)
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag != IsOn() && !((Object)(object)msg.player == (Object)null))
		{
			if (flag)
			{
				StartMixing(msg.player);
			}
			else
			{
				StopMixing();
			}
		}
	}

	public void StartMixing(BasePlayer player)
	{
		if (IsOn() || !CanStartMixing(player))
		{
			return;
		}
		MixStartingPlayer = player;
		bool itemsAreContiguous;
		List<Item> orderedContainerItems = GetOrderedContainerItems(base.inventory, out itemsAreContiguous);
		currentRecipe = RecipeDictionary.GetMatchingRecipeAndQuantity(Recipes, orderedContainerItems, out var quantity);
		currentQuantity = quantity;
		if (!((Object)(object)currentRecipe == (Object)null) && itemsAreContiguous && (!currentRecipe.RequiresBlueprint || !((Object)(object)currentRecipe.ProducedItem != (Object)null) || player.blueprints.HasUnlocked(currentRecipe.ProducedItem)))
		{
			if (base.isServer)
			{
				lastTickTimestamp = Time.realtimeSinceStartup;
			}
			RemainingMixTime = currentRecipe.MixingDuration * (float)currentQuantity;
			TotalMixTime = RemainingMixTime;
			ReturnExcessItems(orderedContainerItems, player);
			if (RemainingMixTime == 0f)
			{
				ProduceItem(currentRecipe, currentQuantity);
				return;
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)TickMix, 1f, 1f);
			SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
		}
	}

	protected virtual bool CanStartMixing(BasePlayer player)
	{
		return true;
	}

	public void StopMixing()
	{
		if (IsOn())
		{
			SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
			currentRecipe = null;
			currentQuantity = 0;
			RemainingMixTime = 0f;
			((FacepunchBehaviour)this).CancelInvoke((Action)TickMix);
			SendNetworkUpdateImmediate();
		}
	}

	public void TickMix()
	{
		if ((Object)(object)currentRecipe == (Object)null)
		{
			StopMixing();
			return;
		}
		if (base.isServer)
		{
			lastTickTimestamp = Time.realtimeSinceStartup;
			RemainingMixTime -= 1f;
		}
		SendNetworkUpdateImmediate();
		if (RemainingMixTime <= 0f)
		{
			ProduceItem(currentRecipe, currentQuantity);
		}
	}

	public void ProduceItem(Recipe recipe, int quantity)
	{
		pendingItemId = recipe.ProducedItem.itemid;
		StopMixing();
		ConsumeInventory(recipe, quantity);
		CreateRecipeItems(recipe, quantity);
	}

	private void ConsumeInventory(Recipe recipe, int quantity)
	{
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item item = base.inventory.GetSlot(i);
			if (item != null)
			{
				if (GetItemWaterAmount(item) > 0)
				{
					item = item.contents.itemList[0];
				}
				int num = recipe.Ingredients[i].GetIngredientCount(recipe.ProducedItem) * quantity;
				if (num > 0)
				{
					Analytics.Azure.OnCraftMaterialConsumed(item.info.shortname, item.amount, MixStartingPlayer, this, inSafezone: false, recipe.ProducedItem?.shortname);
					item.UseItem(num);
				}
			}
		}
		ItemManager.DoRemoves();
	}

	private void ReturnExcessItems(List<Item> orderedContainerItems, BasePlayer player)
	{
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null || (Object)(object)currentRecipe == (Object)null || orderedContainerItems == null || orderedContainerItems.Count != currentRecipe.Ingredients.Length)
		{
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot == null)
			{
				break;
			}
			int num = slot.amount - currentRecipe.Ingredients[i].GetIngredientCount(currentRecipe.ProducedItem) * currentQuantity;
			if (num > 0)
			{
				Item item = slot.SplitItem(num);
				if (!item.MoveToContainer(player.inventory.containerMain) && !item.MoveToContainer(player.inventory.containerBelt))
				{
					item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
				}
			}
		}
		ItemManager.DoRemoves();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (!added && item.info.itemid == pendingItemId)
		{
			pendingItemId = 0;
			SendNetworkUpdateImmediate();
		}
	}

	protected virtual void CreateRecipeItems(Recipe recipe, int quantity)
	{
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)recipe == (Object)null || (Object)(object)recipe.ProducedItem == (Object)null)
		{
			return;
		}
		int num = quantity * recipe.ProducedItemCount;
		int stackable = recipe.ProducedItem.stackable;
		int num2 = Mathf.CeilToInt((float)num / (float)stackable);
		currentProductionItem = recipe.ProducedItem;
		for (int i = 0; i < num2; i++)
		{
			int num3 = ((num > stackable) ? stackable : num);
			Item item = ItemManager.Create(recipe.ProducedItem, num3, 0uL);
			if ((Object)(object)MixStartingPlayer != (Object)null && !MixStartingPlayer.IsDestroyed)
			{
				item.SetItemOwnership(MixStartingPlayer, ItemOwnershipPhrases.MixingTable);
			}
			Analytics.Azure.OnCraftItem(item.info.shortname, item.amount, MixStartingPlayer, this, inSafezone: false);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
			num -= num3;
			if (num <= 0)
			{
				break;
			}
		}
		currentProductionItem = null;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.mixingTable = Pool.Get<MixingTable>();
		info.msg.mixingTable.pendingItem = pendingItemId;
		if (info.forDisk)
		{
			info.msg.mixingTable.remainingMixTime = RemainingMixTime;
		}
		else
		{
			info.msg.mixingTable.remainingMixTime = RemainingMixTime - Mathf.Max(Time.realtimeSinceStartup - lastTickTimestamp, 0f);
			info.msg.mixingTable.currentRecipe = (((Object)(object)currentRecipe != (Object)null && (Object)(object)currentRecipe.ProducedItem != (Object)null) ? currentRecipe.ProducedItem.itemid : (-1));
		}
		info.msg.mixingTable.totalMixTime = TotalMixTime;
	}

	private int GetItemWaterAmount(Item item)
	{
		if (item == null)
		{
			return 0;
		}
		if (item.contents != null && item.contents.capacity == 1 && item.contents.allowedContents == ItemContainer.ContentsType.Liquid && item.contents.itemList.Count > 0)
		{
			return item.contents.itemList[0].amount;
		}
		return 0;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.mixingTable != null)
		{
			RemainingMixTime = info.msg.mixingTable.remainingMixTime;
			TotalMixTime = info.msg.mixingTable.totalMixTime;
			CookingItemId = info.msg.mixingTable.currentRecipe;
			pendingItemId = info.msg.mixingTable.pendingItem;
		}
	}

	public Recipe GetMatchingInventoryRecipe(ItemContainer container)
	{
		bool itemsAreContiguous;
		int quantity;
		Recipe matchingRecipeAndQuantity = RecipeDictionary.GetMatchingRecipeAndQuantity(Recipes, GetOrderedContainerItems(container, out itemsAreContiguous), out quantity);
		if ((Object)(object)matchingRecipeAndQuantity == (Object)null)
		{
			return null;
		}
		if (!itemsAreContiguous)
		{
			return null;
		}
		if (quantity <= 0)
		{
			return null;
		}
		return matchingRecipeAndQuantity;
	}

	public List<Item> GetOrderedContainerItems(ItemContainer container, out bool itemsAreContiguous)
	{
		itemsAreContiguous = true;
		if (container == null)
		{
			return null;
		}
		if (container.itemList == null)
		{
			return null;
		}
		if (container.itemList.Count == 0)
		{
			return null;
		}
		inventoryItems.Clear();
		bool flag = false;
		for (int i = 0; i < container.capacity; i++)
		{
			Item item = container.GetSlot(i);
			if (item != null && flag)
			{
				itemsAreContiguous = false;
				break;
			}
			if (item == null)
			{
				flag = true;
				continue;
			}
			if (GetItemWaterAmount(item) > 0)
			{
				item = item.contents.itemList[0];
			}
			inventoryItems.Add(item);
		}
		return inventoryItems;
	}

	public int GetMaxPlayerCanAfford(BasePlayer player, Recipe recipe, ItemContainer tableContainer)
	{
		if ((Object)(object)player == (Object)null)
		{
			return 0;
		}
		if ((Object)(object)recipe == (Object)null)
		{
			return 0;
		}
		ItemContainer itemContainer = (((Object)(object)GetMatchingInventoryRecipe(tableContainer) != (Object)(object)recipe) ? tableContainer : null);
		itemCostCache.Clear();
		Recipe.RecipeIngredient[] ingredients = recipe.Ingredients;
		for (int i = 0; i < ingredients.Length; i++)
		{
			Recipe.RecipeIngredient recipeIngredient = ingredients[i];
			if (!itemCostCache.ContainsKey(recipeIngredient.Ingredient.itemid))
			{
				itemCostCache[recipeIngredient.Ingredient.itemid] = 0;
			}
			itemCostCache[recipeIngredient.Ingredient.itemid] += recipeIngredient.GetIngredientCount(recipe.ProducedItem);
		}
		int num = int.MaxValue;
		foreach (KeyValuePair<int, int> item in itemCostCache)
		{
			int amount = player.inventory.GetAmount(item.Key);
			int num2 = itemContainer?.GetAmount(item.Key, onlyUsableAmounts: true) ?? 0;
			int num3 = (amount + num2) / itemCostCache[item.Key];
			if (num3 < num)
			{
				num = num3;
			}
		}
		return num;
	}

	public bool CanPlayerAffordRecipe(BasePlayer player, Recipe recipe, ItemContainer tableContainer, int amount)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if ((Object)(object)recipe == (Object)null)
		{
			return false;
		}
		itemCostCache.Clear();
		Recipe.RecipeIngredient[] ingredients = recipe.Ingredients;
		for (int i = 0; i < ingredients.Length; i++)
		{
			Recipe.RecipeIngredient recipeIngredient = ingredients[i];
			if (!itemCostCache.ContainsKey(recipeIngredient.Ingredient.itemid))
			{
				itemCostCache[recipeIngredient.Ingredient.itemid] = 0;
			}
			itemCostCache[recipeIngredient.Ingredient.itemid] += recipeIngredient.GetIngredientCount(recipe.ProducedItem) * amount;
		}
		foreach (KeyValuePair<int, int> item in itemCostCache)
		{
			int amount2 = player.inventory.GetAmount(item.Key);
			int num = tableContainer?.GetAmount(item.Key, onlyUsableAmounts: true) ?? 0;
			if (amount2 + num < itemCostCache[item.Key])
			{
				return false;
			}
		}
		return true;
	}
}


public enum Type
{
	Mixing,
	Cooking
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class MLRS : BaseMountable
{
	[Serializable]
	public class RocketTube
	{
		public Vector3 firingOffset;

		public Transform hinge;

		public Renderer rocket;
	}

	[Header("MLRS Components")]
	[SerializeField]
	private GameObjectRef rocketStoragePrefab;

	[SerializeField]
	private GameObjectRef dashboardStoragePrefab;

	[SerializeField]
	[Header("MLRS Rotation")]
	private Transform hRotator;

	[SerializeField]
	public float hRotSpeed = 25f;

	[SerializeField]
	private Transform vRotator;

	[SerializeField]
	public float vRotSpeed = 10f;

	[SerializeField]
	[Range(50f, 90f)]
	public float vRotMax = 85f;

	[SerializeField]
	private Transform hydraulics;

	[Header("MLRS Weaponry")]
	[SerializeField]
	[Tooltip("Minimum distance from the MLRS to a targeted hit point. In metres.")]
	public float minRange = 200f;

	[Tooltip("The size of the area that the rockets may hit, minus rocket damage radius.")]
	[SerializeField]
	public float targetAreaRadius = 30f;

	[SerializeField]
	private GameObjectRef mlrsRocket;

	[SerializeField]
	public Transform firingPoint;

	[SerializeField]
	public RocketTube[] rocketTubes;

	[SerializeField]
	[Header("MLRS Dashboard/FX")]
	private GameObject screensChild;

	[SerializeField]
	private Transform leftHandGrip;

	[SerializeField]
	private Transform leftJoystick;

	[SerializeField]
	private Transform rightHandGrip;

	[SerializeField]
	private Transform rightJoystick;

	[SerializeField]
	private Transform controlKnobHeight;

	[SerializeField]
	private Transform controlKnobAngle;

	[SerializeField]
	private GameObjectRef uiDialogPrefab;

	[SerializeField]
	private Light fireButtonLight;

	[SerializeField]
	private GameObject brokenDownEffect;

	[SerializeField]
	private ParticleSystem topScreenShutdown;

	[SerializeField]
	private ParticleSystem bottomScreenShutdown;

	[ServerVar(Help = "How many minutes before the MLRS recovers from use and can be used again")]
	public static float brokenDownMinutes = 20f;

	public const Flags FLAG_FIRING_ROCKETS = Flags.Reserved6;

	public const Flags FLAG_HAS_AIMING_MODULE = Flags.Reserved8;

	private EntityRef rocketStorageInstance;

	private EntityRef dashboardStorageInstance;

	public float rocketBaseGravity;

	public float rocketSpeed;

	private bool isInitialLoad = true;

	public const string MLRS_PLAYER_KILL_STAT = "mlrs_kills";

	private float leftRightInput;

	private float upDownInput;

	public Vector3 lastSentTargetHitPos;

	public Vector3 lastSentTrueHitPos;

	public int nextRocketIndex;

	public EntityRef rocketOwnerRef;

	public TimeSince timeSinceBroken;

	public int radiusModIndex;

	private float[] radiusMods = new float[4]
	{
		0.1f,
		0.2f,
		1f / 3f,
		2f / 3f
	};

	public Vector3 trueTargetHitPos;

	public Vector3 UserTargetHitPos { get; set; }

	public Vector3 TrueHitPos { get; set; }

	public bool HasAimingModule => HasFlag(Flags.Reserved8);

	public bool CanBeUsed
	{
		get
		{
			if (HasAimingModule)
			{
				return !IsBroken();
			}
			return false;
		}
	}

	public bool CanFire
	{
		get
		{
			if (CanBeUsed && RocketAmmoCount > 0 && !IsFiringRockets)
			{
				return !IsRealigning;
			}
			return false;
		}
	}

	public float HRotation
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return hRotator.eulerAngles.y;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			Vector3 eulerAngles = hRotator.eulerAngles;
			eulerAngles.y = value;
			hRotator.eulerAngles = eulerAngles;
		}
	}

	public float VRotation
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return vRotator.localEulerAngles.x;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			Vector3 localEulerAngles = vRotator.localEulerAngles;
			if (value < 0f)
			{
				localEulerAngles.x = Mathf.Clamp(value, 0f - vRotMax, 0f);
			}
			else if (value > 0f)
			{
				localEulerAngles.x = Mathf.Clamp(value, 360f - vRotMax, 360f);
			}
			vRotator.localEulerAngles = localEulerAngles;
		}
	}

	public float CurGravityMultiplier { get; set; }

	public int RocketAmmoCount { get; set; }

	public bool IsRealigning { get; set; }

	public bool IsFiringRockets => HasFlag(Flags.Reserved6);

	public float RocketDamageRadius { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MLRS.OnRpcMessage", 0);
		try
		{
			if (rpc == 455279877 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Fire_Rockets "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Fire_Rockets", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(455279877u, "RPC_Fire_Rockets", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Fire_Rockets(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Fire_Rockets");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 751446792 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open_Dashboard "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open_Dashboard", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(751446792u, "RPC_Open_Dashboard", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_Open_Dashboard(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Open_Dashboard");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1311007340 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open_Rockets "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open_Rockets", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1311007340u, "RPC_Open_Rockets", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_Open_Rockets(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_Open_Rockets");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 858951307 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetTargetHitPos "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetTargetHitPos", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(858951307u, "RPC_SetTargetHitPos", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_SetTargetHitPos(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_SetTargetHitPos");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		GameObject obj = mlrsRocket.Get();
		ServerProjectile component = obj.GetComponent<ServerProjectile>();
		rocketBaseGravity = (0f - Physics.gravity.y) * component.gravityModifier;
		rocketSpeed = component.speed;
		TimedExplosive component2 = obj.GetComponent<TimedExplosive>();
		RocketDamageRadius = component2.explosionRadius;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.mlrs != null)
		{
			SetUserTargetHitPos(info.msg.mlrs.targetPos);
			TrueHitPos = info.msg.mlrs.curHitPos;
			HitPosToRotation(TrueHitPos, out var hRot, out var vRot, out var g);
			CurGravityMultiplier = g / (0f - Physics.gravity.y);
			if (base.isServer)
			{
				HRotation = hRot;
				VRotation = vRot;
			}
			rocketStorageInstance.uid = info.msg.mlrs.rocketStorageID;
			dashboardStorageInstance.uid = info.msg.mlrs.dashboardStorageID;
			RocketAmmoCount = (int)info.msg.mlrs.ammoCount;
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!IsFiringRockets)
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public void SetUserTargetHitPos(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		if (UserTargetHitPos == worldPos)
		{
			return;
		}
		if (base.isServer)
		{
			Vector3 position = TerrainMeta.Position;
			Vector3 val = position + TerrainMeta.Size;
			worldPos.x = Mathf.Clamp(worldPos.x, position.x, val.x);
			worldPos.z = Mathf.Clamp(worldPos.z, position.z, val.z);
			worldPos.y = GetSurfaceHeight(worldPos);
		}
		if (Interface.CallHook("OnMlrsTarget", (object)this, (object)worldPos, (object)_mounted) != null)
		{
			return;
		}
		UserTargetHitPos = worldPos;
		if (base.isServer)
		{
			trueTargetHitPos = UserTargetHitPos;
			foreach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)
			{
				Bounds val2 = allSafeZone.triggerCollider.bounds;
				Vector3 center = ((Bounds)(ref val2)).center;
				center.y = 0f;
				float num = allSafeZone.triggerCollider.GetRadius(((Component)allSafeZone).transform.localScale) + targetAreaRadius;
				trueTargetHitPos.y = 0f;
				if (Vector3.Distance(center, trueTargetHitPos) < num)
				{
					Vector3 val3 = trueTargetHitPos - center;
					trueTargetHitPos = center + ((Vector3)(ref val3)).normalized * num;
					trueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);
					break;
				}
			}
		}
		Interface.CallHook("OnMlrsTargetSet", (object)this, (object)trueTargetHitPos, (object)_mounted);
	}

	public StorageContainer GetRocketContainer()
	{
		BaseEntity baseEntity = rocketStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	public StorageContainer GetDashboardContainer()
	{
		BaseEntity baseEntity = dashboardStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	public void HitPosToRotation(Vector3 hitPos, out float hRot, out float vRot, out float g)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 aimToTarget = Ballistics.GetAimToTarget(firingPoint.position, hitPos, rocketSpeed, vRotMax, rocketBaseGravity, minRange, out g);
		Quaternion val = Quaternion.LookRotation(aimToTarget, Vector3.up);
		Vector3 eulerAngles = ((Quaternion)(ref val)).eulerAngles;
		vRot = eulerAngles.x - 360f;
		aimToTarget.y = 0f;
		hRot = eulerAngles.y;
	}

	public static float ProjectileDistToSpeed(float x, float y, float angle, float g, float fallbackV)
	{
		float num = angle * (MathF.PI / 180f);
		float num2 = Mathf.Sqrt(x * x * g / (x * Mathf.Sin(2f * num) - 2f * y * Mathf.Cos(num) * Mathf.Cos(num)));
		if (float.IsNaN(num2) || num2 < 1f)
		{
			num2 = fallbackV;
		}
		return num2;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer)
		{
			if (child.prefabID == rocketStoragePrefab.GetEntity().prefabID)
			{
				rocketStorageInstance.Set(child);
			}
			if (child.prefabID == dashboardStoragePrefab.GetEntity().prefabID)
			{
				dashboardStorageInstance.Set(child);
			}
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("MLRS.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (IsBroken())
			{
				if (!(TimeSince.op_Implicit(timeSinceBroken) >= brokenDownMinutes * 60f))
				{
					SetFlag(Flags.Reserved8, TryGetAimingModule(out var _));
					return;
				}
				SetRepaired();
			}
			int rocketAmmoCount = RocketAmmoCount;
			UpdateStorageState();
			if (CanBeUsed && AnyMounted())
			{
				Vector3 userTargetHitPos = UserTargetHitPos;
				userTargetHitPos += Vector3.forward * upDownInput * 75f * Time.fixedDeltaTime;
				userTargetHitPos += Vector3.right * leftRightInput * 75f * Time.fixedDeltaTime;
				SetUserTargetHitPos(userTargetHitPos);
			}
			if (!IsFiringRockets)
			{
				HitPosToRotation(trueTargetHitPos, out var hRot, out var vRot, out var g);
				float num = g / (0f - Physics.gravity.y);
				IsRealigning = Mathf.Abs(Mathf.DeltaAngle(VRotation, vRot)) > 0.001f || Mathf.Abs(Mathf.DeltaAngle(HRotation, hRot)) > 0.001f || !Mathf.Approximately(CurGravityMultiplier, num);
				if (IsRealigning)
				{
					if (isInitialLoad)
					{
						VRotation = vRot;
						HRotation = hRot;
						isInitialLoad = false;
					}
					else
					{
						VRotation = Mathf.MoveTowardsAngle(VRotation, vRot, Time.deltaTime * vRotSpeed);
						HRotation = Mathf.MoveTowardsAngle(HRotation, hRot, Time.deltaTime * hRotSpeed);
					}
					CurGravityMultiplier = num;
					Ballistics.TryGetPhysicsProjectileHitPos(firingPoint.position, firingPoint.forward, rocketSpeed, Physics.gravity.y * CurGravityMultiplier, out var result, 2f, 0.66f, 128f, this);
					TrueHitPos = result;
				}
			}
			if (UserTargetHitPos != lastSentTargetHitPos || TrueHitPos != lastSentTrueHitPos || RocketAmmoCount != rocketAmmoCount)
			{
				SendNetworkUpdate();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float GetSurfaceHeight(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return WaterLevel.GetWaterOrTerrainSurface(pos, waves: false, volumes: false);
	}

	public void SetRepaired()
	{
		SetFlag(Flags.Broken, b: false);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			upDownInput = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			upDownInput = -1f;
		}
		else
		{
			upDownInput = 0f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			leftRightInput = -1f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			leftRightInput = 1f;
		}
		else
		{
			leftRightInput = 0f;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.mlrs = Pool.Get<MLRS>();
		info.msg.mlrs.targetPos = UserTargetHitPos;
		info.msg.mlrs.curHitPos = TrueHitPos;
		info.msg.mlrs.rocketStorageID = rocketStorageInstance.uid;
		info.msg.mlrs.dashboardStorageID = dashboardStorageInstance.uid;
		info.msg.mlrs.ammoCount = (uint)RocketAmmoCount;
		lastSentTargetHitPos = UserTargetHitPos;
		lastSentTrueHitPos = TrueHitPos;
	}

	public bool AdminFixUp()
	{
		if (IsDead() || IsFiringRockets)
		{
			return false;
		}
		StorageContainer dashboardContainer = GetDashboardContainer();
		if (!HasAimingModule)
		{
			dashboardContainer.inventory.AddItem(ItemManager.FindItemDefinition("aiming.module.mlrs"), 1, 0uL);
		}
		StorageContainer rocketContainer = GetRocketContainer();
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("ammo.rocket.mlrs");
		int num = rocketContainer.inventory.capacity * itemDefinition.stackable;
		if (RocketAmmoCount < num)
		{
			int num2 = num - RocketAmmoCount;
			while (num2 > 0)
			{
				int num3 = Mathf.Min(num2, itemDefinition.stackable);
				rocketContainer.inventory.AddItem(itemDefinition, itemDefinition.stackable, 0uL);
				num2 -= num3;
			}
		}
		SetRepaired();
		SendNetworkUpdate();
		return true;
	}

	public void Fire(BasePlayer owner)
	{
		UpdateStorageState();
		if (CanFire && !((Object)(object)GetMounted() == (Object)null) && Interface.CallHook("OnMlrsFire", (object)this, (object)owner) == null)
		{
			SetFlag(Flags.Reserved6, b: true);
			radiusModIndex = 0;
			nextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);
			rocketOwnerRef.Set(owner);
			((FacepunchBehaviour)this).InvokeRepeating((Action)FireNextRocket, 0f, 0.5f);
			Interface.CallHook("OnMlrsFired", (object)this, (object)owner);
		}
	}

	public void EndFiring()
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		((FacepunchBehaviour)this).CancelInvoke((Action)FireNextRocket);
		rocketOwnerRef.Set(null);
		if (TryGetAimingModule(out var item))
		{
			item.LoseCondition(1f);
		}
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Broken, b: true, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		timeSinceBroken = TimeSince.op_Implicit(0f);
		Interface.CallHook("OnMlrsFiringEnded", (object)this);
	}

	public void FireNextRocket()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		RocketAmmoCount = GetRocketContainer().inventory.GetAmmoAmount((AmmoTypes)2048);
		if (nextRocketIndex < 0 || nextRocketIndex >= RocketAmmoCount || IsBroken())
		{
			EndFiring();
			return;
		}
		StorageContainer rocketContainer = GetRocketContainer();
		Vector3 firingPos = firingPoint.position + firingPoint.rotation * rocketTubes[nextRocketIndex].firingOffset;
		float num = 1f;
		if (radiusModIndex < radiusMods.Length)
		{
			num = radiusMods[radiusModIndex];
		}
		radiusModIndex++;
		Vector2 val = Random.insideUnitCircle * (targetAreaRadius - RocketDamageRadius) * num;
		Vector3 target = TrueHitPos + new Vector3(val.x, 0f, val.y);
		float requiredGravity;
		Vector3 aimToTarget = Ballistics.GetAimToTarget(firingPoint.position, target, rocketSpeed, vRotMax, rocketBaseGravity, minRange, out requiredGravity);
		if (TryFireProjectile(rocketContainer, (AmmoTypes)2048, firingPos, aimToTarget, rocketOwnerRef.Get(serverside: true) as BasePlayer, 0f, 0f, out var projectile))
		{
			projectile.gravityModifier = requiredGravity / (0f - Physics.gravity.y);
			Interface.CallHook("OnMlrsRocketFired", (object)this, (object)projectile);
			nextRocketIndex--;
		}
		else
		{
			EndFiring();
		}
	}

	private void UpdateStorageState()
	{
		Item item;
		bool b = TryGetAimingModule(out item);
		SetFlag(Flags.Reserved8, b);
		RocketAmmoCount = GetRocketContainer().inventory.GetAmmoAmount((AmmoTypes)2048);
	}

	public bool TryGetAimingModule(out Item item)
	{
		if ((Object)(object)GetDashboardContainer() == (Object)null)
		{
			item = null;
			return false;
		}
		ItemContainer inventory = GetDashboardContainer().inventory;
		if (!inventory.IsEmpty())
		{
			item = inventory.itemList[0];
			return true;
		}
		item = null;
		return false;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SetTargetHitPos(RPCMessage msg)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (PlayerIsMounted(player))
		{
			SetUserTargetHitPos(msg.read.Vector3());
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_Fire_Rockets(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (PlayerIsMounted(player))
		{
			Fire(player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_Open_Rockets(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			IItemContainerEntity rocketContainer = GetRocketContainer();
			if (!rocketContainer.IsUnityNull())
			{
				rocketContainer.PlayerOpenLoot(player, "", doPositionChecks: false);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_Open_Dashboard(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			IItemContainerEntity dashboardContainer = GetDashboardContainer();
			if (!dashboardContainer.IsUnityNull())
			{
				dashboardContainer.PlayerOpenLoot(player);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class RocketTube
{
	public Vector3 firingOffset;

	public Transform hinge;

	public Renderer rocket;
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class MobilePhone : HeldEntity
{
	public PhoneController Controller;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MobilePhone.OnRpcMessage", 0);
		try
		{
			if (rpc == 1529322558 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AnswerPhone "));
				}
				TimeWarning val2 = TimeWarning.New("AnswerPhone", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(1529322558u, "AnswerPhone", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AnswerPhone(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AnswerPhone");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2754362156u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearCurrentUser "));
				}
				TimeWarning val2 = TimeWarning.New("ClearCurrentUser", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(2754362156u, "ClearCurrentUser", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ClearCurrentUser(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ClearCurrentUser");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1095090232 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - InitiateCall "));
				}
				TimeWarning val2 = TimeWarning.New("InitiateCall", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(1095090232u, "InitiateCall", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							InitiateCall(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in InitiateCall");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2606442785u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AddSavedNumber "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AddSavedNumber", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2606442785u, "Server_AddSavedNumber", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2606442785u, "Server_AddSavedNumber", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							Server_AddSavedNumber(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in Server_AddSavedNumber");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1402406333 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RemoveSavedNumber "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RemoveSavedNumber", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1402406333u, "Server_RemoveSavedNumber", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1402406333u, "Server_RemoveSavedNumber", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							Server_RemoveSavedNumber(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in Server_RemoveSavedNumber");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2704491961u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestCurrentState "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestCurrentState", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(2704491961u, "Server_RequestCurrentState", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							Server_RequestCurrentState(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in Server_RequestCurrentState");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 942544266 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestPhoneDirectory "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestPhoneDirectory", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(942544266u, "Server_RequestPhoneDirectory", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(942544266u, "Server_RequestPhoneDirectory", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							Server_RequestPhoneDirectory(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in Server_RequestPhoneDirectory");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1240133378 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerDeleteVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerDeleteVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1240133378u, "ServerDeleteVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1240133378u, "ServerDeleteVoicemail", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg9 = rPCMessage;
							ServerDeleteVoicemail(msg9);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in ServerDeleteVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1221129498 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerHangUp "));
				}
				TimeWarning val2 = TimeWarning.New("ServerHangUp", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(1221129498u, "ServerHangUp", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							ServerHangUp(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in ServerHangUp");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 239260010 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerPlayVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerPlayVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(239260010u, "ServerPlayVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(239260010u, "ServerPlayVoicemail", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							ServerPlayVoicemail(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in ServerPlayVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 189198880 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSendVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSendVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(189198880u, "ServerSendVoicemail", this, player, 5uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg12 = rPCMessage;
							ServerSendVoicemail(msg12);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in ServerSendVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2760189029u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerStopVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerStopVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2760189029u, "ServerStopVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2760189029u, "ServerStopVoicemail", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg13 = rPCMessage;
							ServerStopVoicemail(msg13);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogException(ex12);
						player.Kick("RPC Error in ServerStopVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3900772076u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetCurrentUser "));
				}
				TimeWarning val2 = TimeWarning.New("SetCurrentUser", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(3900772076u, "SetCurrentUser", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage currentUser = rPCMessage;
							SetCurrentUser(currentUser);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex13)
					{
						Debug.LogException(ex13);
						player.Kick("RPC Error in SetCurrentUser");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2760249627u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdatePhoneName "));
				}
				TimeWarning val2 = TimeWarning.New("UpdatePhoneName", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2760249627u, "UpdatePhoneName", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2760249627u, "UpdatePhoneName", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg14 = rPCMessage;
							UpdatePhoneName(msg14);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex14)
					{
						Debug.LogException(ex14);
						player.Kick("RPC Error in UpdatePhoneName");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.telephone == null)
		{
			info.msg.telephone = Pool.Get<Telephone>();
		}
		info.msg.telephone.phoneNumber = Controller.PhoneNumber;
		info.msg.telephone.phoneName = Controller.PhoneName;
		info.msg.telephone.lastNumber = Controller.lastDialedNumber;
		info.msg.telephone.savedNumbers = Controller.savedNumbers;
		if (!info.forDisk)
		{
			info.msg.telephone.usingPlayer = Controller.currentPlayerRef.uid;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Controller.ServerInit();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Controller.PostServerLoad();
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Controller.DoServerDestroy();
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		Controller.OnParentChanged(newParent);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void ClearCurrentUser(RPCMessage msg)
	{
		Controller.ClearCurrentUser(msg);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void SetCurrentUser(RPCMessage msg)
	{
		Controller.SetCurrentUser(msg);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void InitiateCall(RPCMessage msg)
	{
		Controller.InitiateCall(msg);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void AnswerPhone(RPCMessage msg)
	{
		Controller.AnswerPhone(msg);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	private void ServerHangUp(RPCMessage msg)
	{
		Controller.ServerHangUp(msg);
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		Controller.DestroyShared();
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	public void UpdatePhoneName(RPCMessage msg)
	{
		Controller.UpdatePhoneName(msg);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_RequestPhoneDirectory(RPCMessage msg)
	{
		Controller.Server_RequestPhoneDirectory(msg);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_AddSavedNumber(RPCMessage msg)
	{
		Controller.Server_AddSavedNumber(msg);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	public void Server_RemoveSavedNumber(RPCMessage msg)
	{
		Controller.Server_RemoveSavedNumber(msg);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void Server_RequestCurrentState(RPCMessage msg)
	{
		Controller.SetPhoneStateWithPlayer(Controller.serverState);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void ServerSendVoicemail(RPCMessage msg)
	{
		Controller.ServerSendVoicemail(msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void ServerPlayVoicemail(RPCMessage msg)
	{
		Controller.ServerPlayVoicemail(msg);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void ServerStopVoicemail(RPCMessage msg)
	{
		Controller.ServerStopVoicemail(msg);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void ServerDeleteVoicemail(RPCMessage msg)
	{
		Controller.ServerDeleteVoicemail(msg);
	}

	public void ToggleRinging(bool state)
	{
		MobileInventoryEntity associatedEntity = ItemModAssociatedEntity<MobileInventoryEntity>.GetAssociatedEntity(GetItem());
		if ((Object)(object)associatedEntity != (Object)null)
		{
			associatedEntity.ToggleRinging(state);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg?.telephone != null)
		{
			Controller.PhoneNumber = info.msg.telephone.phoneNumber;
			Controller.PhoneName = info.msg.telephone.phoneName;
			Controller.lastDialedNumber = info.msg.telephone.lastNumber;
			Controller.currentPlayerRef.uid = info.msg.telephone.usingPlayer;
			PhoneDirectory savedNumbers = Controller.savedNumbers;
			if (savedNumbers != null)
			{
				savedNumbers.ResetToPool();
			}
			Controller.savedNumbers = info.msg.telephone.savedNumbers;
			if (Controller.savedNumbers != null)
			{
				Controller.savedNumbers.ShouldPool = false;
			}
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && old.HasFlag(Flags.Busy) != next.HasFlag(Flags.Busy))
		{
			if (next.HasFlag(Flags.Busy))
			{
				if (!((FacepunchBehaviour)this).IsInvoking((Action)Controller.WatchForDisconnects))
				{
					((FacepunchBehaviour)this).InvokeRepeating((Action)Controller.WatchForDisconnects, 0f, 0.1f);
				}
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Controller.WatchForDisconnects);
			}
		}
		Controller.OnFlagsChanged(old, next);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Modular;
using UnityEngine;
using UnityEngine.Assertions;

public class ModularCar : BaseModularVehicle, IVehicleLockUser, VehicleChassisVisuals<ModularCar>.IClientWheelUser, TakeCollisionDamage.ICanRestoreVelocity, CarPhysics<ModularCar>.ICar
{
	[Serializable]
	public class SpawnSettings
	{
		public enum AdminBonus
		{
			None,
			T1PlusFuel,
			T2PlusFuel,
			T3PlusFuel
		}

		[Tooltip("Must be true to use any of these settings.")]
		public bool useSpawnSettings;

		[Tooltip("Specify a list of possible module configurations that'll automatically spawn with this vehicle.")]
		public ModularCarPresetConfig[] configurationOptions;

		[Tooltip("Min health % at spawn for any modules that spawn with this chassis.")]
		public float minStartHealthPercent = 0.15f;

		[Tooltip("Max health  % at spawn for any modules that spawn with this chassis.")]
		public float maxStartHealthPercent = 0.5f;

		public AdminBonus adminBonus;
	}

	private class DriverSeatInputs
	{
		public float steerInput;

		public bool steerMod;

		public float brakeInput;

		public float throttleInput;
	}

	[Header("Modular Car")]
	public ModularCarChassisVisuals chassisVisuals;

	public VisualCarWheel wheelFL;

	public VisualCarWheel wheelFR;

	public VisualCarWheel wheelRL;

	public VisualCarWheel wheelRR;

	[SerializeField]
	public CarSettings carSettings;

	[SerializeField]
	public float hurtTriggerMinSpeed = 1f;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerFront;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerRear;

	[SerializeField]
	public ProtectionProperties immortalProtection;

	[SerializeField]
	public ProtectionProperties mortalProtection;

	[SerializeField]
	private BoxCollider mainChassisCollider;

	[SerializeField]
	[Header("Towing")]
	private TriggerTowing towingTrigger;

	[SerializeField]
	private Transform towingPoint;

	[SerializeField]
	public SpawnSettings spawnSettings;

	[SerializeField]
	[HideInInspector]
	public MeshRenderer[] damageShowingRenderers;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population = 3f;

	[ServerVar(Help = "How many minutes before a ModularCar loses all its health while outside")]
	public static float outsidedecayminutes = 864f;

	public const BUTTON RapidSteerButton = BUTTON.SPRINT;

	public VehicleEngineController<GroundVehicle>.EngineState lastSetEngineState;

	public float cachedFuelFraction;

	public static HashSet<ModularCar> allCarsList = new HashSet<ModularCar>();

	public readonly ListDictionary<BaseMountable, DriverSeatInputs> driverSeatInputs = new ListDictionary<BaseMountable, DriverSeatInputs>();

	public CarPhysics<ModularCar> carPhysics;

	public VehicleTerrainHandler serverTerrainHandler;

	private CarWheel[] wheels;

	public float lastEngineOnTime;

	private const float DECAY_TICK_TIME = 60f;

	private const float INSIDE_DECAY_MULTIPLIER = 0.1f;

	private const float CORPSE_DECAY_MINUTES = 5f;

	public Vector3 prevPosition;

	public Quaternion prevRotation;

	private Bounds collisionCheckBounds;

	private Vector3 lastGoodPos;

	private Quaternion lastGoodRot;

	private bool lastPosWasBad;

	public float deathDamageCounter;

	private const float DAMAGE_TO_GIB = 600f;

	public TimeSince timeSinceDeath;

	private const float IMMUNE_TIME = 1f;

	public readonly Vector3 groundedCOMMultiplier = new Vector3(0.25f, 0.3f, 0.25f);

	public readonly Vector3 airbourneCOMMultiplier = new Vector3(0.25f, 0.75f, 0.25f);

	public Vector3 prevCOMMultiplier;

	public override float DriveWheelVelocity
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelVelocity;
			}
			return 0f;
		}
	}

	public float DriveWheelSlip
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelSlip;
			}
			return 0f;
		}
	}

	public float SteerAngle
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.SteerAngle;
			}
			return 0f;
		}
	}

	public new ItemDefinition AssociatedItemDef => repair.itemTarget;

	public float MaxSteerAngle => carSettings.maxSteerAngle;

	public override bool IsLockable => CarLock.HasALock;

	public ModularCarCodeLock CarLock { get; private set; }

	public override bool AlwaysAllowBradleyTargeting => true;

	public bool IsTowing => HasFlag(Flags.Reserved14);

	public BaseEntity TowEntity => this;

	public Transform TowAnchor => towingPoint;

	public Rigidbody TowBody => rigidBody;

	public VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (serverTerrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return serverTerrainHandler.OnSurface;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ModularCar.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1382140449 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuelWithKeycode "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuelWithKeycode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						RPC_OpenFuelWithKeycode(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in RPC_OpenFuelWithKeycode");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2818660542u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TryMountWithKeycode "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TryMountWithKeycode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2818660542u, "RPC_TryMountWithKeycode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_TryMountWithKeycode(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_TryMountWithKeycode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(process, rootObj, name, serverside, clientside, bundling);
		damageShowingRenderers = ((Component)this).GetComponentsInChildren<MeshRenderer>();
	}

	public override void InitShared()
	{
		base.InitShared();
		if (CarLock == null)
		{
			CarLock = new ModularCarCodeLock(this, base.isServer);
		}
	}

	public override float MaxHealth()
	{
		return AssociatedItemDef.condition.max;
	}

	public override float StartHealth()
	{
		return AssociatedItemDef.condition.max;
	}

	public float TotalHealth()
	{
		float num = 0f;
		for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
		{
			num += base.AttachedModuleEntities[i].Health();
		}
		return num;
	}

	public float TotalMaxHealth()
	{
		float num = 0f;
		for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
		{
			num += base.AttachedModuleEntities[i].MaxHealth();
		}
		return num;
	}

	public override float GetMaxForwardSpeed()
	{
		float num = GetMaxDriveForce() / base.TotalMass * 30f;
		return Mathf.Pow(0.9945f, num) * num;
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.modularCar == null)
		{
			return;
		}
		engineController.FuelSystem.SetInstanceID(info.msg.modularCar.fuelStorageID);
		cachedFuelFraction = info.msg.modularCar.fuelFraction;
		bool hasALock = CarLock.HasALock;
		CarLock.Load(info);
		if (CarLock.HasALock != hasALock)
		{
			for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
			{
				base.AttachedModuleEntities[i].RefreshConditionals(canGib: true);
			}
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next)
		{
			RefreshEngineState();
		}
	}

	public override float GetThrottleInput()
	{
		if (base.isServer)
		{
			float num = 0f;
			BufferList<DriverSeatInputs> values = driverSeatInputs.Values;
			for (int i = 0; i < values.Count; i++)
			{
				num += values[i].throttleInput;
			}
			return Mathf.Clamp(num, -1f, 1f);
		}
		return 0f;
	}

	public override float GetBrakeInput()
	{
		if (base.isServer)
		{
			float num = 0f;
			BufferList<DriverSeatInputs> values = driverSeatInputs.Values;
			for (int i = 0; i < values.Count; i++)
			{
				num += values[i].brakeInput;
			}
			return Mathf.Clamp01(num);
		}
		return 0f;
	}

	public float GetMaxDriveForce()
	{
		float num = 0f;
		for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
		{
			num += base.AttachedModuleEntities[i].GetMaxDriveForce();
		}
		return RollOffDriveForce(num);
	}

	public float GetFuelFraction()
	{
		if (base.isServer)
		{
			return engineController.FuelSystem.GetFuelFraction();
		}
		return cachedFuelFraction;
	}

	public bool PlayerHasUnlockPermission(BasePlayer player)
	{
		return CarLock.HasLockPermission(player);
	}

	public bool KeycodeEntryBlocked(BasePlayer player)
	{
		return CarLock.CodeEntryBlocked(player);
	}

	public override bool PlayerCanUseThis(BasePlayer player, ModularCarCodeLock.LockType lockType)
	{
		return CarLock.PlayerCanUseThis(player, lockType);
	}

	public bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)
	{
		object obj = Interface.CallHook("CanDestroyLock", (object)player, (object)this, (object)viaModule);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return CarLock.PlayerCanDestroyLock(viaModule);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (PlayerIsMounted(player))
		{
			return true;
		}
		if (!PlayerCanUseThis(player, ModularCarCodeLock.LockType.General))
		{
			return false;
		}
		if (!IsOn())
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public override bool CanPushNow(BasePlayer pusher)
	{
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (pusher.InSafeZone() && !CarLock.HasLockPermission(pusher))
		{
			return false;
		}
		return true;
	}

	public bool RefreshEngineState()
	{
		if (lastSetEngineState == base.CurEngineState)
		{
			return false;
		}
		if (base.isServer && base.CurEngineState == VehicleEngineController<GroundVehicle>.EngineState.Off)
		{
			lastEngineOnTime = Time.time;
		}
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			attachedModuleEntity.OnEngineStateChanged(lastSetEngineState, base.CurEngineState);
		}
		if (base.isServer && GameInfo.HasAchievements && NumMounted() >= 5)
		{
			foreach (MountPointInfo allMountPoint in base.allMountPoints)
			{
				if ((Object)(object)allMountPoint.mountable != (Object)null && (Object)(object)allMountPoint.mountable.GetMounted() != (Object)null)
				{
					allMountPoint.mountable.GetMounted().GiveAchievement("BATTLE_BUS");
				}
			}
		}
		lastSetEngineState = base.CurEngineState;
		return true;
	}

	public float RollOffDriveForce(float driveForce)
	{
		return Mathf.Pow(0.9999175f, driveForce) * driveForce;
	}

	public void RefreshChassisProtectionState()
	{
		if (base.HasAnyModules)
		{
			baseProtection = immortalProtection;
			if (base.isServer)
			{
				SetHealth(MaxHealth());
			}
		}
		else
		{
			baseProtection = mortalProtection;
		}
	}

	public override void ModuleEntityAdded(BaseVehicleModule addedModule)
	{
		base.ModuleEntityAdded(addedModule);
		RefreshChassisProtectionState();
	}

	public override void ModuleEntityRemoved(BaseVehicleModule removedModule)
	{
		base.ModuleEntityRemoved(removedModule);
		RefreshChassisProtectionState();
	}

	public override void ServerInit()
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		carPhysics = new CarPhysics<ModularCar>(this, ((Component)this).transform, rigidBody, carSettings);
		serverTerrainHandler = new VehicleTerrainHandler(this);
		if (!Application.isLoadingSave)
		{
			SpawnPreassignedModules();
		}
		lastEngineOnTime = Time.realtimeSinceStartup;
		allCarsList.Add(this);
		collisionCheckBounds = new Bounds(mainChassisCollider.center, new Vector3(mainChassisCollider.size.x - 0.5f, 0.05f, mainChassisCollider.size.z - 0.5f));
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.15f, 0.02f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayTick, Random.Range(30f, 60f), 60f, 6f);
	}

	public override void DoServerDestroy()
	{
		base.DoServerDestroy();
		allCarsList.Remove(this);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		CarLock.PostServerLoad();
		if (IsDead())
		{
			Kill();
		}
	}

	public float GetSteerInput()
	{
		float num = 0f;
		BufferList<DriverSeatInputs> values = driverSeatInputs.Values;
		for (int i = 0; i < values.Count; i++)
		{
			num += values[i].steerInput;
		}
		return Mathf.Clamp(num, -1f, 1f);
	}

	public bool GetSteerSpeedMod(float speed)
	{
		BufferList<DriverSeatInputs> values = driverSeatInputs.Values;
		for (int i = 0; i < values.Count; i++)
		{
			if (values[i].steerMod)
			{
				return true;
			}
		}
		return false;
	}

	public float GetSteerMaxMult(float speed)
	{
		return 1f;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ModularCar.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			float speed = GetSpeed();
			carPhysics.FixedUpdate(Time.fixedDeltaTime, speed);
			engineController.CheckEngineState();
			((Component)hurtTriggerFront).gameObject.SetActive(speed > hurtTriggerMinSpeed);
			((Component)hurtTriggerRear).gameObject.SetActive(speed < 0f - hurtTriggerMinSpeed);
			serverTerrainHandler.FixedUpdate();
			float num = Mathf.Abs(speed);
			if (lastPosWasBad || num > 15f)
			{
				if (GamePhysics.CheckOBB(new OBB(((Component)mainChassisCollider).transform, collisionCheckBounds), 1084293377, (QueryTriggerInteraction)1))
				{
					rigidBody.position = lastGoodPos;
					rigidBody.rotation = lastGoodRot;
					((Component)this).transform.position = lastGoodPos;
					((Component)this).transform.rotation = lastGoodRot;
					rigidBody.velocity = Vector3.zero;
					rigidBody.angularVelocity = Vector3.zero;
					lastPosWasBad = true;
				}
				else
				{
					lastGoodPos = rigidBody.position;
					lastGoodRot = rigidBody.rotation;
					lastPosWasBad = false;
				}
			}
			else
			{
				lastGoodPos = rigidBody.position;
				lastGoodRot = rigidBody.rotation;
				lastPosWasBad = false;
			}
			if (IsMoving())
			{
				Vector3 cOMMultiplier = GetCOMMultiplier();
				if (cOMMultiplier != prevCOMMultiplier)
				{
					rigidBody.centerOfMass = Vector3.Scale(realLocalCOM, cOMMultiplier);
					prevCOMMultiplier = cOMMultiplier;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override bool DetermineIfStationary()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = rigidBody.position;
		Quaternion rotation = rigidBody.rotation;
		bool result = position == prevPosition && rotation == prevRotation;
		prevPosition = position;
		prevRotation = rotation;
		return result;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		MountPointInfo playerSeatInfo = GetPlayerSeatInfo(player);
		if (playerSeatInfo == null || !playerSeatInfo.isDriver)
		{
			return;
		}
		if (!this.driverSeatInputs.Contains(playerSeatInfo.mountable))
		{
			this.driverSeatInputs.Add(playerSeatInfo.mountable, new DriverSeatInputs());
		}
		DriverSeatInputs driverSeatInputs = this.driverSeatInputs[playerSeatInfo.mountable];
		if (inputState.IsDown(BUTTON.FIRE_THIRD))
		{
			driverSeatInputs.steerInput += inputState.MouseDelta().x * 0.1f;
		}
		else
		{
			driverSeatInputs.steerInput = 0f;
			if (inputState.IsDown(BUTTON.LEFT))
			{
				driverSeatInputs.steerInput = -1f;
			}
			else if (inputState.IsDown(BUTTON.RIGHT))
			{
				driverSeatInputs.steerInput = 1f;
			}
		}
		driverSeatInputs.steerMod = inputState.IsDown(BUTTON.SPRINT);
		float num = 0f;
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			num = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			num = -1f;
		}
		driverSeatInputs.throttleInput = 0f;
		driverSeatInputs.brakeInput = 0f;
		if (GetSpeed() > 3f && num < -0.1f)
		{
			driverSeatInputs.throttleInput = 0f;
			driverSeatInputs.brakeInput = 0f - num;
		}
		else
		{
			driverSeatInputs.throttleInput = num;
			driverSeatInputs.brakeInput = 0f;
		}
		for (int i = 0; i < base.NumAttachedModules; i++)
		{
			base.AttachedModuleEntities[i].PlayerServerInput(inputState, player);
		}
		if (engineController.IsOff && ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD))))
		{
			engineController.TryStartEngine(player);
		}
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerDismounted(player, seat);
		DriverSeatInputs driverSeatInputs = default(DriverSeatInputs);
		if (this.driverSeatInputs.TryGetValue(seat, ref driverSeatInputs))
		{
			this.driverSeatInputs.Remove(seat);
		}
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			if ((Object)(object)attachedModuleEntity != (Object)null)
			{
				attachedModuleEntity.OnPlayerDismountedVehicle(player);
			}
		}
		CarLock.CheckEnableCentralLocking();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.modularCar = Pool.Get<ModularCar>();
		info.msg.modularCar.steerAngle = SteerAngle;
		info.msg.modularCar.driveWheelVel = DriveWheelVelocity;
		info.msg.modularCar.throttleInput = GetThrottleInput();
		info.msg.modularCar.brakeInput = GetBrakeInput();
		info.msg.modularCar.fuelStorageID = GetFuelSystem().GetInstanceID();
		info.msg.modularCar.fuelFraction = GetFuelFraction();
		CarLock.Save(info);
	}

	public override void Hurt(HitInfo info)
	{
		if (!IsDead() && !IsTransferProtected() && info.damageTypes.Get(DamageType.Decay) == 0f)
		{
			PropagateDamageToModules(info, 0.5f / (float)base.NumAttachedModules, 0.9f / (float)base.NumAttachedModules, null);
		}
		base.Hurt(info);
	}

	public void TickFuel(float fuelUsedPerSecond)
	{
		engineController.TickFuel(fuelUsedPerSecond);
	}

	public override bool MountEligable(BasePlayer player)
	{
		if (!base.MountEligable(player))
		{
			return false;
		}
		ModularCarSeat modularCarSeat = GetIdealMountPointFor(player) as ModularCarSeat;
		if ((Object)(object)modularCarSeat != (Object)null && !modularCarSeat.associatedSeatingModule.DoorsAreLockable)
		{
			return true;
		}
		return PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);
	}

	public override bool IsComplete()
	{
		if (HasAnyEngines() && HasDriverMountPoints())
		{
			return !IsDead();
		}
		return false;
	}

	public void DoDecayDamage(float damage)
	{
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			if (!attachedModuleEntity.IsDestroyed)
			{
				attachedModuleEntity.Hurt(damage, DamageType.Decay);
			}
		}
		if (!base.HasAnyModules)
		{
			Hurt(damage, DamageType.Decay);
		}
	}

	public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float num = 0f;
		for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
		{
			num += base.AttachedModuleEntities[i].GetAdjustedDriveForce(absSpeed, topSpeed);
		}
		return RollOffDriveForce(num);
	}

	public bool HasAnyEngines()
	{
		for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
		{
			if (base.AttachedModuleEntities[i].HasAnEngine)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasAnyWorkingEngines()
	{
		return GetMaxDriveForce() > 0f;
	}

	public override bool MeetsEngineRequirements()
	{
		if (HasAnyWorkingEngines())
		{
			return HasDriver();
		}
		return false;
	}

	public override void OnEngineStartFailed()
	{
		bool arg = !HasAnyWorkingEngines() || engineController.IsWaterlogged();
		ClientRPC(RpcTarget.NetworkGroup("EngineStartFailed"), arg);
	}

	public CarWheel[] GetWheels()
	{
		if (wheels == null)
		{
			wheels = new CarWheel[4] { wheelFL, wheelFR, wheelRL, wheelRR };
		}
		return wheels;
	}

	public float GetWheelsMidPos()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		return (((Component)wheels[0].wheelCollider).transform.localPosition.z - ((Component)wheels[2].wheelCollider).transform.localPosition.z) * 0.5f;
	}

	public override bool AdminFixUp(int tier)
	{
		if (!base.AdminFixUp(tier))
		{
			return false;
		}
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			attachedModuleEntity.AdminFixUp(tier);
		}
		SendNetworkUpdate();
		return true;
	}

	public override void ModuleHurt(BaseVehicleModule hurtModule, HitInfo info)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.ModuleHurt(hurtModule, info);
		if (IsDead())
		{
			if (TimeSince.op_Implicit(timeSinceDeath) > 1f)
			{
				for (int i = 0; i < info.damageTypes.types.Length; i++)
				{
					deathDamageCounter += info.damageTypes.types[i];
				}
			}
			if (deathDamageCounter > 600f && !base.IsDestroyed)
			{
				Kill(DestroyMode.Gib);
			}
		}
		else if (hurtModule.PropagateDamage && info.damageTypes.Get(DamageType.Decay) == 0f)
		{
			PropagateDamageToModules(info, 0.15f, 0.4f, hurtModule);
		}
	}

	public void PropagateDamageToModules(HitInfo info, float minPropagationPercent, float maxPropagationPercent, BaseVehicleModule ignoreModule)
	{
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			if ((Object)(object)attachedModuleEntity == (Object)(object)ignoreModule || attachedModuleEntity.Health() <= 0f)
			{
				continue;
			}
			if (IsDead())
			{
				break;
			}
			float num = Random.Range(minPropagationPercent, maxPropagationPercent);
			for (int i = 0; i < info.damageTypes.types.Length; i++)
			{
				float num2 = info.damageTypes.types[i];
				if (num2 > 0f)
				{
					attachedModuleEntity.AcceptPropagatedDamage(num2 * num, (DamageType)i, info.Initiator, info.UseProtection);
				}
				if (IsDead())
				{
					break;
				}
			}
		}
	}

	public override void ModuleReachedZeroHealth()
	{
		if (IsDead())
		{
			return;
		}
		bool flag = true;
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			if (attachedModuleEntity.health > 0f)
			{
				flag = false;
				break;
			}
		}
		if (flag)
		{
			Die();
		}
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		DismountAllPlayers();
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			attachedModuleEntity.repair.enabled = false;
		}
		if (CarLock != null)
		{
			CarLock.RemoveLock();
		}
		timeSinceDeath = TimeSince.op_Implicit(0f);
		if (vehicle.carwrecks)
		{
			if (!base.HasAnyModules)
			{
				Kill(DestroyMode.Gib);
			}
			else
			{
				SendNetworkUpdate();
			}
		}
		else
		{
			Kill(DestroyMode.Gib);
		}
	}

	public void RemoveLock()
	{
		CarLock.RemoveLock();
	}

	public void RestoreVelocity(Vector3 vel)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 velocity = rigidBody.velocity;
		if (((Vector3)(ref velocity)).sqrMagnitude < ((Vector3)(ref vel)).sqrMagnitude)
		{
			vel.y = rigidBody.velocity.y;
			rigidBody.velocity = vel;
		}
	}

	public override Vector3 GetCOMMultiplier()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (carPhysics == null || !carPhysics.IsGrounded() || !IsOn())
		{
			return airbourneCOMMultiplier;
		}
		return groundedCOMMultiplier;
	}

	public void UpdateClients()
	{
		if (HasDriver())
		{
			byte num = (byte)((GetThrottleInput() + 1f) * 7f);
			byte b = (byte)(GetBrakeInput() * 15f);
			byte arg = (byte)(num + (b << 4));
			byte arg2 = (byte)(GetFuelFraction() * 255f);
			ClientRPC(RpcTarget.NetworkGroup("ModularCarUpdate"), SteerAngle, arg, DriveWheelVelocity, arg2);
		}
	}

	public void DecayTick()
	{
		if (base.IsDestroyed || IsOn() || immuneToDecay || Time.time < lastEngineOnTime + 600f)
		{
			return;
		}
		float num = 1f;
		if (IsDead())
		{
			int num2 = Mathf.Max(1, base.AttachedModuleEntities.Count);
			num /= 5f * (float)num2;
			DoDecayDamage(600f * num);
			return;
		}
		num /= outsidedecayminutes;
		if (!IsOutside())
		{
			num *= 0.1f;
		}
		float num3 = (base.HasAnyModules ? base.AttachedModuleEntities.Max((BaseVehicleModule module) => module.MaxHealth()) : MaxHealth());
		DoDecayDamage(num3 * num);
	}

	public override void DoCollisionDamage(BaseEntity hitEntity, float damage)
	{
		if ((Object)(object)hitEntity == (Object)null)
		{
			return;
		}
		if (hitEntity is BaseVehicleModule baseVehicleModule)
		{
			baseVehicleModule.Hurt(damage, DamageType.Collision, this, useProtection: false);
		}
		else
		{
			if (!((Object)(object)hitEntity == (Object)(object)this))
			{
				return;
			}
			if (base.HasAnyModules)
			{
				float amount = damage / (float)base.NumAttachedModules;
				{
					foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
					{
						attachedModuleEntity.AcceptPropagatedDamage(amount, DamageType.Collision, this, useProtection: false);
					}
					return;
				}
			}
			Hurt(damage, DamageType.Collision, this, useProtection: false);
		}
	}

	public void SpawnPreassignedModules()
	{
		if (!spawnSettings.useSpawnSettings || spawnSettings.configurationOptions.IsNullOrEmpty())
		{
			return;
		}
		ModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[Random.Range(0, spawnSettings.configurationOptions.Length)];
		if (Interface.CallHook("OnVehicleModulesAssign", (object)this, (object)modularCarPresetConfig.socketItemDefs) != null)
		{
			return;
		}
		for (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)
		{
			ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];
			if ((Object)(object)itemModVehicleModule != (Object)null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))
			{
				Item item = ItemManager.Create(((Component)itemModVehicleModule).GetComponent<ItemDefinition>(), 1, 0uL);
				float num = Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);
				item.condition = item.maxCondition * num;
				if (!TryAddModule(item))
				{
					item.Remove();
				}
			}
		}
		Interface.CallHook("OnVehicleModulesAssigned", (object)this, (object)modularCarPresetConfig.socketItemDefs);
		((FacepunchBehaviour)this).Invoke((Action)HandleAdminBonus, 0f);
	}

	public void HandleAdminBonus()
	{
		switch (spawnSettings.adminBonus)
		{
		case SpawnSettings.AdminBonus.T1PlusFuel:
			AdminFixUp(1);
			break;
		case SpawnSettings.AdminBonus.T2PlusFuel:
			AdminFixUp(2);
			break;
		case SpawnSettings.AdminBonus.T3PlusFuel:
			AdminFixUp(3);
			break;
		}
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}

	[RPC_Server]
	public void RPC_OpenFuelWithKeycode(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		string codeEntered = msg.read.String(256, false);
		if (CarLock.TryOpenWithCode(player, codeEntered))
		{
			if (CanBeLooted(player))
			{
				GetFuelSystem().LootFuel(player);
			}
		}
		else
		{
			ClientRPC(RpcTarget.NetworkGroup("CodeEntryFailed"));
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_TryMountWithKeycode(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			string codeEntered = msg.read.String(256, false);
			if (CarLock.TryOpenWithCode(player, codeEntered))
			{
				WantsMount(player);
			}
			else
			{
				ClientRPC(RpcTarget.NetworkGroup("CodeEntryFailed"));
			}
		}
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			if (attachedModuleEntity.HasSeating && attachedModuleEntity is VehicleModuleSeating vehicleModuleSeating && vehicleModuleSeating.IsOnThisModule(player))
			{
				attachedModuleEntity.ScaleDamageForPlayer(player, info);
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class SpawnSettings
{
	public enum AdminBonus
	{
		None,
		T1PlusFuel,
		T2PlusFuel,
		T3PlusFuel
	}

	[Tooltip("Must be true to use any of these settings.")]
	public bool useSpawnSettings;

	[Tooltip("Specify a list of possible module configurations that'll automatically spawn with this vehicle.")]
	public ModularCarPresetConfig[] configurationOptions;

	[Tooltip("Min health % at spawn for any modules that spawn with this chassis.")]
	public float minStartHealthPercent = 0.15f;

	[Tooltip("Max health  % at spawn for any modules that spawn with this chassis.")]
	public float maxStartHealthPercent = 0.5f;

	public AdminBonus adminBonus;
}


public enum AdminBonus
{
	None,
	T1PlusFuel,
	T2PlusFuel,
	T3PlusFuel
}


private class DriverSeatInputs
{
	public float steerInput;

	public bool steerMod;

	public float brakeInput;

	public float throttleInput;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ModularCarGarage : ContainerIOEntity
{
	[Serializable]
	public class ChassisBuildOption
	{
		public GameObjectRef prefab;

		public ItemDefinition itemDef;
	}

	public enum OccupantLock
	{
		CannotHaveLock,
		NoLock,
		HasLock
	}

	private enum VehicleLiftState
	{
		Down,
		Up
	}

	[SerializeField]
	public Transform vehicleLift;

	[SerializeField]
	public Animation vehicleLiftAnim;

	[SerializeField]
	private string animName = "LiftUp";

	[SerializeField]
	public VehicleLiftOccupantTrigger occupantTrigger;

	[SerializeField]
	public float liftMoveTime = 1f;

	[SerializeField]
	public EmissionToggle poweredLight;

	[SerializeField]
	public EmissionToggle inUseLight;

	[SerializeField]
	public Transform vehicleLiftPos;

	[Range(0f, 1f)]
	[SerializeField]
	public float recycleEfficiency = 0.5f;

	[SerializeField]
	public Transform recycleDropPos;

	[SerializeField]
	public bool needsElectricity;

	[SerializeField]
	private SoundDefinition liftStartSoundDef;

	[SerializeField]
	private SoundDefinition liftStopSoundDef;

	[SerializeField]
	private SoundDefinition liftStopDownSoundDef;

	[SerializeField]
	private SoundDefinition liftLoopSoundDef;

	[SerializeField]
	private GameObjectRef addRemoveLockEffect;

	[SerializeField]
	private GameObjectRef changeLockCodeEffect;

	[SerializeField]
	private GameObjectRef repairEffect;

	[SerializeField]
	private TriggerBase playerTrigger;

	public ChassisBuildOption[] chassisBuildOptions;

	public ItemAmount lockResourceCost;

	public VehicleLiftState vehicleLiftState;

	private Sound liftLoopSound;

	public Vector3 downPos;

	public const Flags Flag_DestroyingChassis = Flags.Reserved6;

	public const float TimeToDestroyChassis = 10f;

	public const Flags Flag_EnteringKeycode = Flags.Reserved7;

	public const Flags Flag_PlayerObstructing = Flags.Reserved8;

	public ModularCar lockedOccupant;

	public readonly HashSet<BasePlayer> lootingPlayers = new HashSet<BasePlayer>();

	public MagnetSnap magnetSnap;

	public bool PlatformIsOccupied { get; set; }

	public bool HasEditableOccupant { get; set; }

	public bool HasDriveableOccupant { get; set; }

	public OccupantLock OccupantLockState { get; set; }

	public bool LiftIsUp => vehicleLiftState == VehicleLiftState.Up;

	public bool LiftIsMoving => vehicleLiftAnim.isPlaying;

	public bool LiftIsDown => vehicleLiftState == VehicleLiftState.Down;

	public bool IsDestroyingChassis => HasFlag(Flags.Reserved6);

	private bool IsEnteringKeycode => HasFlag(Flags.Reserved7);

	public bool PlayerObstructingLift => HasFlag(Flags.Reserved8);

	public ModularCar carOccupant
	{
		get
		{
			if (!((Object)(object)lockedOccupant != (Object)null))
			{
				return occupantTrigger.carOccupant;
			}
			return lockedOccupant;
		}
	}

	public bool HasOccupant
	{
		get
		{
			if ((Object)(object)carOccupant != (Object)null)
			{
				return carOccupant.IsFullySpawned();
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ModularCarGarage.OnRpcMessage", 0);
		try
		{
			if (rpc == 554177909 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_DeselectedLootItem "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_DeselectedLootItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(554177909u, "RPC_DeselectedLootItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_DeselectedLootItem(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_DeselectedLootItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3683966290u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_DiedWithKeypadOpen "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_DiedWithKeypadOpen", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3683966290u, "RPC_DiedWithKeypadOpen", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3683966290u, "RPC_DiedWithKeypadOpen", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_DiedWithKeypadOpen(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_DiedWithKeypadOpen");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3659332720u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenEditing "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenEditing", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3659332720u, "RPC_OpenEditing", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3659332720u, "RPC_OpenEditing", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_OpenEditing(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_OpenEditing");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1582295101 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RepairItem "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RepairItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1582295101u, "RPC_RepairItem", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1582295101u, "RPC_RepairItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_RepairItem(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_RepairItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3710764312u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestAddLock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestAddLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3710764312u, "RPC_RequestAddLock", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3710764312u, "RPC_RequestAddLock", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							RPC_RequestAddLock(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in RPC_RequestAddLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3305106830u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestNewCode "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestNewCode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3305106830u, "RPC_RequestNewCode", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3305106830u, "RPC_RequestNewCode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							RPC_RequestNewCode(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in RPC_RequestNewCode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1046853419 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestRemoveLock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestRemoveLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1046853419u, "RPC_RequestRemoveLock", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1046853419u, "RPC_RequestRemoveLock", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							RPC_RequestRemoveLock(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in RPC_RequestRemoveLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4033916654u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SelectedLootItem "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SelectedLootItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4033916654u, "RPC_SelectedLootItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg9 = rPCMessage;
							RPC_SelectedLootItem(msg9);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in RPC_SelectedLootItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2974124904u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_StartDestroyingChassis "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_StartDestroyingChassis", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2974124904u, "RPC_StartDestroyingChassis", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2974124904u, "RPC_StartDestroyingChassis", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2974124904u, "RPC_StartDestroyingChassis", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							RPC_StartDestroyingChassis(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in RPC_StartDestroyingChassis");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3872977075u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_StartKeycodeEntry "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_StartKeycodeEntry", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3872977075u, "RPC_StartKeycodeEntry", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							RPC_StartKeycodeEntry(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in RPC_StartKeycodeEntry");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3830531963u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_StopDestroyingChassis "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_StopDestroyingChassis", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3830531963u, "RPC_StopDestroyingChassis", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3830531963u, "RPC_StopDestroyingChassis", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3830531963u, "RPC_StopDestroyingChassis", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg12 = rPCMessage;
							RPC_StopDestroyingChassis(msg12);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in RPC_StopDestroyingChassis");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		downPos = ((Component)vehicleLift).transform.position;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			UpdateOccupantMode();
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (IsOn())
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public override int ConsumptionAmount()
	{
		return 5;
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}

	public void SetOccupantState(bool hasOccupant, bool editableOccupant, bool driveableOccupant, OccupantLock occupantLockState, bool forced = false)
	{
		if (PlatformIsOccupied == hasOccupant && HasEditableOccupant == editableOccupant && HasDriveableOccupant == driveableOccupant && OccupantLockState == occupantLockState && !forced)
		{
			return;
		}
		bool hasEditableOccupant = HasEditableOccupant;
		PlatformIsOccupied = hasOccupant;
		HasEditableOccupant = editableOccupant;
		HasDriveableOccupant = driveableOccupant;
		OccupantLockState = occupantLockState;
		if (base.isServer)
		{
			UpdateOccupantMode();
			SendNetworkUpdate();
			if (hasEditableOccupant && !editableOccupant)
			{
				EditableOccupantLeft();
			}
			else if (editableOccupant && !hasEditableOccupant)
			{
				EditableOccupantEntered();
			}
		}
		RefreshLiftState();
	}

	public void RefreshLiftState(bool forced = false)
	{
		VehicleLiftState desiredLiftState = ((IsOpen() || IsEnteringKeycode || (HasEditableOccupant && !HasDriveableOccupant)) ? VehicleLiftState.Up : VehicleLiftState.Down);
		MoveLift(desiredLiftState, 0f, forced);
	}

	public void MoveLift(VehicleLiftState desiredLiftState, float startDelay = 0f, bool forced = false)
	{
		if (vehicleLiftState != desiredLiftState || forced)
		{
			_ = vehicleLiftState;
			vehicleLiftState = desiredLiftState;
			if (base.isServer)
			{
				UpdateOccupantMode();
				WakeNearbyRigidbodies();
			}
			if (!((Component)this).gameObject.activeSelf)
			{
				vehicleLiftAnim[animName].time = ((desiredLiftState == VehicleLiftState.Up) ? 1f : 0f);
				vehicleLiftAnim.Play();
			}
			else if (desiredLiftState == VehicleLiftState.Up)
			{
				((FacepunchBehaviour)this).Invoke((Action)MoveLiftUp, startDelay);
			}
			else
			{
				((FacepunchBehaviour)this).Invoke((Action)MoveLiftDown, startDelay);
			}
		}
	}

	public void MoveLiftUp()
	{
		AnimationState obj = vehicleLiftAnim[animName];
		obj.speed = obj.length / liftMoveTime;
		vehicleLiftAnim.Play();
	}

	public void MoveLiftDown()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		AnimationState val = vehicleLiftAnim[animName];
		val.speed = val.length / liftMoveTime;
		if (!vehicleLiftAnim.isPlaying && Vector3.Distance(((Component)vehicleLift).transform.position, downPos) > 0.01f)
		{
			val.time = 1f;
		}
		val.speed *= -1f;
		vehicleLiftAnim.Play();
	}

	public void FixedUpdate()
	{
		if (!base.isServer || magnetSnap == null)
		{
			return;
		}
		if ((Object)(object)playerTrigger != (Object)null)
		{
			bool hasAnyContents = playerTrigger.HasAnyContents;
			if (PlayerObstructingLift != hasAnyContents)
			{
				SetFlag(Flags.Reserved8, hasAnyContents);
			}
		}
		UpdateCarOccupant();
		if (HasOccupant && carOccupant.CouldBeEdited() && carOccupant.GetSpeed() <= 1f)
		{
			if (IsOn() || !carOccupant.IsComplete())
			{
				if ((Object)(object)lockedOccupant == (Object)null && !carOccupant.rigidBody.isKinematic)
				{
					GrabOccupant(occupantTrigger.carOccupant);
				}
				magnetSnap.FixedUpdate(((Component)carOccupant).transform);
			}
			if (carOccupant.CarLock.HasALock && !carOccupant.CarLock.CanHaveALock())
			{
				carOccupant.CarLock.RemoveLock();
			}
		}
		else if (HasOccupant && carOccupant.rigidBody.isKinematic)
		{
			ReleaseOccupant();
		}
		if (HasOccupant && IsDestroyingChassis && carOccupant.HasAnyModules)
		{
			StopChassisDestroy();
		}
	}

	internal override void DoServerDestroy()
	{
		if (HasOccupant)
		{
			ReleaseOccupant();
			if (!HasDriveableOccupant)
			{
				carOccupant.Kill(DestroyMode.Gib);
			}
		}
		base.DoServerDestroy();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		magnetSnap = new MagnetSnap(vehicleLiftPos);
		RefreshOnOffState();
		SetOccupantState(hasOccupant: false, editableOccupant: false, driveableOccupant: false, OccupantLock.CannotHaveLock, forced: true);
		RefreshLiftState(forced: true);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.vehicleLift = Pool.Get<VehicleLift>();
		info.msg.vehicleLift.platformIsOccupied = PlatformIsOccupied;
		info.msg.vehicleLift.editableOccupant = HasEditableOccupant;
		info.msg.vehicleLift.driveableOccupant = HasDriveableOccupant;
		info.msg.vehicleLift.occupantLockState = (int)OccupantLockState;
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (base.CanPickup(player))
		{
			return !PlatformIsOccupied;
		}
		return false;
	}

	public override ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return default(ItemContainerId);
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		SetFlag(Flags.Reserved7, b: false);
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		bool flag = base.PlayerOpenLoot(player, panelToOpen);
		if (!flag)
		{
			return false;
		}
		if (HasEditableOccupant)
		{
			player.inventory.loot.AddContainer(carOccupant.Inventory.ModuleContainer);
			player.inventory.loot.AddContainer(carOccupant.Inventory.ChassisContainer);
			player.inventory.loot.SendImmediate();
		}
		lootingPlayers.Add(player);
		RefreshLiftState();
		return flag;
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		if (!IsEnteringKeycode)
		{
			lootingPlayers.Remove(player);
			RefreshLiftState();
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		RefreshOnOffState();
	}

	public bool TryGetModuleForItem(Item item, out BaseVehicleModule result)
	{
		if (!HasOccupant)
		{
			result = null;
			return false;
		}
		result = carOccupant.GetModuleForItem(item);
		return (Object)(object)result != (Object)null;
	}

	public void RefreshOnOffState()
	{
		bool flag = !needsElectricity || currentEnergy >= ConsumptionAmount();
		if (flag != IsOn())
		{
			SetFlag(Flags.On, flag);
		}
	}

	public void UpdateCarOccupant()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			if (HasOccupant)
			{
				bool editableOccupant = Vector3.SqrMagnitude(((Component)carOccupant).transform.position - vehicleLiftPos.position) < 1f && carOccupant.CouldBeEdited() && !PlayerObstructingLift;
				bool driveableOccupant = carOccupant.IsComplete();
				SetOccupantState(occupantLockState: carOccupant.CarLock.CanHaveALock() ? ((!carOccupant.CarLock.HasALock) ? OccupantLock.NoLock : OccupantLock.HasLock) : OccupantLock.CannotHaveLock, hasOccupant: HasOccupant, editableOccupant: editableOccupant, driveableOccupant: driveableOccupant);
			}
			else
			{
				SetOccupantState(hasOccupant: false, editableOccupant: false, driveableOccupant: false, OccupantLock.CannotHaveLock);
			}
		}
	}

	public void UpdateOccupantMode()
	{
		if (HasOccupant)
		{
			carOccupant.inEditableLocation = HasEditableOccupant && LiftIsUp;
			carOccupant.immuneToDecay = IsOn();
		}
	}

	public void WakeNearbyRigidbodies()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(((Component)this).transform.position, 7f, list, 34816, (QueryTriggerInteraction)2);
		foreach (Collider item in list)
		{
			Rigidbody attachedRigidbody = item.attachedRigidbody;
			if ((Object)(object)attachedRigidbody != (Object)null && attachedRigidbody.IsSleeping())
			{
				attachedRigidbody.WakeUp();
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	public void EditableOccupantEntered()
	{
		RefreshLoot();
	}

	public void EditableOccupantLeft()
	{
		RefreshLoot();
	}

	public void RefreshLoot()
	{
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		list.AddRange(lootingPlayers);
		foreach (BasePlayer item in list)
		{
			item.inventory.loot.Clear();
			PlayerOpenLoot(item);
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	public void GrabOccupant(ModularCar occupant)
	{
		if (!((Object)(object)occupant == (Object)null))
		{
			lockedOccupant = occupant;
			lockedOccupant.DisablePhysics();
		}
	}

	public void ReleaseOccupant()
	{
		if (HasOccupant)
		{
			carOccupant.inEditableLocation = false;
			carOccupant.immuneToDecay = false;
			if ((Object)(object)lockedOccupant != (Object)null)
			{
				lockedOccupant.EnablePhysics();
				lockedOccupant = null;
			}
		}
	}

	public void StopChassisDestroy()
	{
		if (((FacepunchBehaviour)this).IsInvoking((Action)FinishDestroyingChassis))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FinishDestroyingChassis);
		}
		SetFlag(Flags.Reserved6, b: false);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_RepairItem(RPCMessage msg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		ItemId val = msg.read.ItemID();
		if (!((Object)(object)player == (Object)null) && HasOccupant)
		{
			Item vehicleItem = carOccupant.GetVehicleItem(val);
			if (vehicleItem != null)
			{
				RepairBench.RepairAnItem(vehicleItem, player, this, 0f, mustKnowBlueprint: false);
				Effect.server.Run(repairEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			else
			{
				string name = ((object)this).GetType().Name;
				ItemId val2 = val;
				Debug.LogError((object)(name + ": Couldn't get item to repair, with ID: " + ((object)(ItemId)(ref val2)/*cast due to .constrained prefix*/).ToString()));
			}
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_OpenEditing(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !LiftIsMoving)
		{
			PlayerOpenLoot(player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_DiedWithKeypadOpen(RPCMessage msg)
	{
		SetFlag(Flags.Reserved7, b: false);
		lootingPlayers.Clear();
		RefreshLiftState();
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		ItemId itemUID = msg.read.ItemID();
		if ((Object)(object)player == (Object)null || !player.inventory.loot.IsLooting() || (Object)(object)player.inventory.loot.entitySource != (Object)(object)this || !HasOccupant)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", (object)vehicleItem, (object)this, (object)player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result))
		{
			if (result is VehicleModuleStorage vehicleModuleStorage)
			{
				IItemContainerEntity container = vehicleModuleStorage.GetContainer();
				if (!container.IsUnityNull())
				{
					player.inventory.loot.AddContainer(container.inventory);
					flag = true;
				}
			}
			else if (result is VehicleModuleCamper vehicleModuleCamper)
			{
				IItemContainerEntity container2 = vehicleModuleCamper.GetContainer();
				if (!container2.IsUnityNull())
				{
					player.inventory.loot.AddContainer(container2.inventory);
					flag = true;
				}
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", (object)vehicleItem, (object)this, (object)player);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_DeselectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.inventory.loot.IsLooting() && !((Object)(object)player.inventory.loot.entitySource != (Object)(object)this))
		{
			if (player.inventory.loot.RemoveContainerAt(3))
			{
				player.inventory.loot.SendImmediate();
			}
			Interface.CallHook("OnVehicleModuleDeselected", (object)this, (object)player);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_StartKeycodeEntry(RPCMessage msg)
	{
		SetFlag(Flags.Reserved7, b: true);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_RequestAddLock(RPCMessage msg)
	{
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		if (!HasOccupant || carOccupant.CarLock.HasALock)
		{
			return;
		}
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		string text = msg.read.String(256, false);
		if (Interface.CallHook("OnVehicleLockRequest", (object)this, (object)player, (object)text) == null)
		{
			ItemAmount itemAmount = lockResourceCost;
			if ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) >= itemAmount.amount && carOccupant.CarLock.TryAddALock(text, player.userID))
			{
				player.inventory.Take(null, itemAmount.itemDef.itemid, Mathf.CeilToInt(itemAmount.amount));
				Effect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RequestRemoveLock(RPCMessage msg)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (HasOccupant && carOccupant.CarLock.HasALock && Interface.CallHook("OnLockRemove", (object)carOccupant, (object)msg.player) == null)
		{
			carOccupant.CarLock.RemoveLock();
			Effect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RequestNewCode(RPCMessage msg)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (!HasOccupant || !carOccupant.CarLock.HasALock)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			string text = msg.read.String(256, false);
			if (Interface.CallHook("OnCodeChange", (object)carOccupant, (object)player, (object)text) == null && carOccupant.CarLock.TrySetNewCode(text, player.userID))
			{
				Effect.server.Run(changeLockCodeEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	public void RPC_StartDestroyingChassis(RPCMessage msg)
	{
		if (!carOccupant.HasAnyModules)
		{
			((FacepunchBehaviour)this).Invoke((Action)FinishDestroyingChassis, 10f);
			SetFlag(Flags.Reserved6, b: true);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	public void RPC_StopDestroyingChassis(RPCMessage msg)
	{
		StopChassisDestroy();
	}

	public void FinishDestroyingChassis()
	{
		if (HasOccupant && !carOccupant.HasAnyModules)
		{
			carOccupant.Kill(DestroyMode.Gib);
			SetFlag(Flags.Reserved6, b: false);
		}
	}
}


using System;

[Serializable]
public class ChassisBuildOption
{
	public GameObjectRef prefab;

	public ItemDefinition itemDef;
}


public enum OccupantLock
{
	CannotHaveLock,
	NoLock,
	HasLock
}


private enum VehicleLiftState
{
	Down,
	Up
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class ModularCarOven : BaseOven
{
	private BaseVehicleModule moduleParent;

	private BaseVehicleModule ModuleParent
	{
		get
		{
			if ((Object)(object)moduleParent != (Object)null)
			{
				return moduleParent;
			}
			moduleParent = GetParentEntity() as BaseVehicleModule;
			return moduleParent;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ModularCarOven.OnRpcMessage", 0);
		try
		{
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SVSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4167839872u, "SVSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SVSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SVSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		moduleParent = null;
	}

	protected override void SVSwitch(RPCMessage msg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)ModuleParent == (Object)null) && ModuleParent.CanBeLooted(msg.player) && !WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: false))
		{
			base.SVSwitch(msg);
		}
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if ((Object)(object)ModuleParent == (Object)null || !ModuleParent.CanBeLooted(player))
		{
			return false;
		}
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}

	protected override void OnCooked()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.OnCooked();
		if (WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: false))
		{
			StopCooking();
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class ModularCarRadio : BaseCombatEntity
{
	public BoomBox CarRadio;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ModularCarRadio.OnRpcMessage", 0);
		try
		{
			if (rpc == 1918716764 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_UpdateRadioIP "));
				}
				TimeWarning val2 = TimeWarning.New("Server_UpdateRadioIP", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1918716764u, "Server_UpdateRadioIP", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1918716764u, "Server_UpdateRadioIP", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_UpdateRadioIP(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_UpdateRadioIP");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1785864031 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerTogglePlay "));
				}
				TimeWarning val2 = TimeWarning.New("ServerTogglePlay", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1785864031u, "ServerTogglePlay", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1785864031u, "ServerTogglePlay", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ServerTogglePlay(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerTogglePlay");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	public void TryForceOff()
	{
		if ((Object)(object)CarRadio != (Object)null)
		{
			CarRadio.ServerTogglePlay(play: false);
		}
	}

	public BaseVehicleModule GetParentModule()
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity is BaseVehicleModule result)
		{
			return result;
		}
		return null;
	}

	public ModularCar GetParentCar()
	{
		BaseVehicleModule parentModule = GetParentModule();
		if ((Object)(object)parentModule != (Object)null && parentModule.Vehicle is ModularCar result)
		{
			return result;
		}
		return null;
	}

	private bool CanPickupRadio(BasePlayer player)
	{
		ModularCar parentCar = GetParentCar();
		if ((Object)(object)parentCar != (Object)null)
		{
			return parentCar.PlayerHasUnlockPermission(player);
		}
		return false;
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (base.CanPickup(player))
		{
			return CanPickupRadio(player);
		}
		return false;
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.IsVisible(3f)]
	public void ServerTogglePlay(RPCMessage msg)
	{
		CarRadio.ServerTogglePlay(msg, bypassPower: true);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.IsVisible(3f)]
	private void Server_UpdateRadioIP(RPCMessage msg)
	{
		CarRadio.Server_UpdateRadioIP(msg);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		CarRadio.Save(info);
	}

	public override void Load(LoadInfo info)
	{
		CarRadio.Load(info);
		base.Load(info);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class MotorRowboat : BaseBoat
{
	[Header("Audio")]
	public BlendedSoundLoops engineLoops;

	public BlendedSoundLoops waterLoops;

	public SoundDefinition engineStartSoundDef;

	public SoundDefinition engineStopSoundDef;

	public SoundDefinition movementSplashAccentSoundDef;

	public SoundDefinition engineSteerSoundDef;

	public GameObjectRef pushLandEffect;

	public GameObjectRef pushWaterEffect;

	public float waterSpeedDivisor = 10f;

	public float turnPitchModScale = -0.25f;

	public float tiltPitchModScale = 0.3f;

	public float splashAccentFrequencyMin = 1f;

	public float splashAccentFrequencyMax = 10f;

	protected const Flags Flag_ThrottleOn = Flags.Reserved2;

	protected const Flags Flag_TurnLeft = Flags.Reserved3;

	protected const Flags Flag_TurnRight = Flags.Reserved4;

	protected const Flags Flag_HasFuel = Flags.Reserved6;

	protected const Flags Flag_RecentlyPushed = Flags.Reserved8;

	protected const Flags Flag_Submerged = Flags.Reserved9;

	protected const Flags Flag_Dying = Flags.Broken;

	public const float submergeFractionMinimum = 0.85f;

	public float deathSinkRate = 0.1f;

	[Header("Fuel")]
	public GameObjectRef fuelStoragePrefab;

	public float fuelPerSec;

	[Header("Storage")]
	public GameObjectRef storageUnitPrefab;

	public EntityRef<StorageContainer> storageUnitInstance;

	[Header("Effects")]
	public Transform boatRear;

	public ParticleSystemContainer wakeEffect;

	public ParticleSystemContainer engineEffectIdle;

	public ParticleSystemContainer engineEffectThrottle;

	[Tooltip("If not supplied, with use engineEffectThrottle for both")]
	public ParticleSystemContainer engineEffectThrottleReverse;

	[Tooltip("Only needed if using a forwardTravelEffect")]
	public Transform boatFront;

	public ParticleSystemContainer forwardTravelEffect;

	public float forwardTravelEffectMinSpeed = 1f;

	public Projector causticsProjector;

	public Transform causticsDepthTest;

	public Transform engineLeftHandPosition;

	public Transform engineRotate;

	public float engineRotateRangeMultiplier = 1f;

	public Transform propellerRotate;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population = 1f;

	[ServerVar(Help = "How long before a boat loses all its health while outside. If it's in deep water, deepwaterdecayminutes is used")]
	public static float outsidedecayminutes = 180f;

	[ServerVar(Help = "How long before a boat loses all its health while in deep water")]
	public static float deepwaterdecayminutes = 120f;

	[ServerVar(Help = "How long until decay begins after the boat was last used")]
	public static float decaystartdelayminutes = 45f;

	public EntityFuelSystem fuelSystem;

	public Transform[] stationaryDismounts;

	public TimeSince timeSinceLastUsedFuel;

	public float angularDragBase = 0.5f;

	public float engineOffAngularDragMultiplier = 1f;

	public float angularDragVelocity = 0.5f;

	public float landDrag = 0.2f;

	public float waterDrag = 0.8f;

	public float offAxisDrag = 1f;

	public float offAxisDot = 0.25f;

	protected const float DECAY_TICK_TIME = 60f;

	private TimeSince startedFlip;

	public float lastHadDriverTime;

	public const float maxVelForStationaryDismount = 4f;

	public bool IsDying => HasFlag(Flags.Broken);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MotorRowboat.OnRpcMessage", 0);
		try
		{
			if (rpc == 1873751172 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_EngineToggle "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_EngineToggle", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_EngineToggle(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_EngineToggle");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						RPC_OpenFuel(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		fuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		timeSinceLastUsedFuel = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)BoatDecay, Random.Range(30f, 60f), 60f, 6f);
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer)
		{
			if (isSpawned)
			{
				fuelSystem.CheckNewChild(child);
			}
			if (storageUnitPrefab.isValid && child.prefabID == storageUnitPrefab.GetEntity().prefabID)
			{
				storageUnitInstance.Set((StorageContainer)child);
			}
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot && storageUnitInstance.IsValid(base.isServer))
		{
			storageUnitInstance.Get(base.isServer).DropItems();
		}
		base.DoServerDestroy();
	}

	public override IFuelSystem GetFuelSystem()
	{
		return fuelSystem;
	}

	public override int StartingFuelUnits()
	{
		return 50;
	}

	public virtual void BoatDecay()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!IsDying)
		{
			BaseBoat.WaterVehicleDecay(this, 60f, TimeSince.op_Implicit(timeSinceLastUsedFuel), outsidedecayminutes, deepwaterdecayminutes, decaystartdelayminutes, preventDecayIndoors);
		}
	}

	public override void DoPushAction(BasePlayer player)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		if (IsFlipped())
		{
			Vector3 val = ((Component)this).transform.InverseTransformPoint(((Component)player).transform.position);
			float num = 4f;
			if (val.x > 0f)
			{
				num = 0f - num;
			}
			rigidBody.AddRelativeTorque(Vector3.forward * num, (ForceMode)2);
			rigidBody.AddForce(Vector3.up * 4f, (ForceMode)2);
			startedFlip = TimeSince.op_Implicit(0f);
			((FacepunchBehaviour)this).InvokeRepeatingFixedTime((Action)FlipMonitor);
		}
		else
		{
			Vector3 val2 = Vector3Ex.Direction2D(((Component)player).transform.position, ((Component)this).transform.position);
			Vector3 val3 = Vector3Ex.Direction2D(((Component)player).transform.position + player.eyes.BodyForward() * 3f, ((Component)player).transform.position);
			Vector3 val4 = Vector3.up * 0.1f + val3;
			val3 = ((Vector3)(ref val4)).normalized;
			Vector3 val5 = ((Component)this).transform.position + val2 * 2f;
			float num2 = 3f;
			float num3 = Vector3.Dot(((Component)this).transform.forward, val3);
			num2 += Mathf.InverseLerp(0.8f, 1f, num3) * 3f;
			rigidBody.AddForceAtPosition(val3 * num2, val5, (ForceMode)2);
		}
		if (HasFlag(Flags.Reserved9))
		{
			if (pushWaterEffect.isValid)
			{
				Effect.server.Run(pushWaterEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		else if (pushLandEffect.isValid)
		{
			Effect.server.Run(pushLandEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
		WakeUp();
	}

	private void FlipMonitor()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Dot(Vector3.up, ((Component)this).transform.up);
		rigidBody.angularVelocity = Vector3.Lerp(rigidBody.angularVelocity, Vector3.zero, Time.fixedDeltaTime * 8f * num);
		if (TimeSince.op_Implicit(startedFlip) > 3f)
		{
			((FacepunchBehaviour)this).CancelInvokeFixedTime((Action)FlipMonitor);
		}
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && IsDriver(player))
		{
			fuelSystem.LootFuel(player);
		}
	}

	[RPC_Server]
	public void RPC_EngineToggle(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			bool flag = msg.read.Bit();
			if (InDryDock())
			{
				flag = false;
			}
			if (IsDriver(player) && flag != EngineOn())
			{
				EngineToggle(flag);
			}
		}
	}

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", (object)this, (object)driver) == null)
		{
			SetFlag(Flags.On, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", (object)this, (object)driver);
			}
			if (wantsOn)
			{
				rigidBody.WakeUp();
				buoyancy.Wake();
			}
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		((FacepunchBehaviour)this).Invoke((Action)CheckInvalidBoat, 1f);
		if (base.health <= 0f)
		{
			EnterCorpseState();
			buoyancy.buoyancyScale = 0f;
			SetFlag(Flags.Broken, b: true);
		}
	}

	public void CheckInvalidBoat()
	{
		bool num = fuelStoragePrefab.isValid && !fuelSystem.HasValidInstance(base.isServer);
		bool flag = storageUnitPrefab.isValid && !storageUnitInstance.IsValid(base.isServer);
		if (num || flag)
		{
			Debug.Log((object)"Destroying invalid boat ");
			((FacepunchBehaviour)this).Invoke((Action)ActualDeath, 1f);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
	}

	public override bool EngineOn()
	{
		return IsOn();
	}

	public float TimeSinceDriver()
	{
		return Time.time - lastHadDriverTime;
	}

	public override void DriverInput(InputState inputState, BasePlayer player)
	{
		base.DriverInput(inputState, player);
		lastHadDriverTime = Time.time;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		if (IsTransferProtected())
		{
			return;
		}
		TimeWarning val = TimeWarning.New("MotorRowboat.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			float num = TimeSinceDriver();
			if (num > 15f)
			{
				steering += Mathf.InverseLerp(15f, 30f, num);
				steering = Mathf.Clamp(-1f, 1f, steering);
				if (num > 75f)
				{
					gasPedal = 0f;
				}
			}
			SetFlags();
			UpdateDrag();
			if (IsDying)
			{
				buoyancy.buoyancyScale = Mathf.Lerp(buoyancy.buoyancyScale, 0f, Time.fixedDeltaTime * deathSinkRate);
			}
			else
			{
				float num2 = 1f;
				float num3 = Vector3Ex.Magnitude2D(rigidBody.velocity);
				float num4 = Mathf.InverseLerp(1f, 10f, num3) * 0.5f * base.healthFraction;
				if (!EngineOn())
				{
					num4 = 0f;
				}
				float num5 = 1f - 0.3f * (1f - base.healthFraction);
				buoyancy.buoyancyScale = (num2 + num4) * num5;
			}
			if (EngineOn())
			{
				float num6 = (HasFlag(Flags.Reserved2) ? 1f : 0.0333f);
				fuelSystem.TryUseFuel(Time.fixedDeltaTime * num6, fuelPerSec);
				timeSinceLastUsedFuel = TimeSince.op_Implicit(0f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SetFlags()
	{
		TimeWarning val = TimeWarning.New("SetFlag", 0);
		try
		{
			bool b = EngineOn() && !IsFlipped() && base.healthFraction > 0f && fuelSystem.HasFuel() && TimeSinceDriver() < 75f;
			Flags num = flags;
			SetFlag(Flags.Reserved3, steering > 0f, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved4, steering < 0f, recursive: false, networkupdate: false);
			SetFlag(Flags.On, b, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, EngineOn() && gasPedal != 0f, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved9, buoyancy.submergedFraction > 0.85f, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved6, fuelSystem.HasFuel(), recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved8, base.RecentlyPushed, recursive: false, networkupdate: false);
			if (num != flags)
			{
				((FacepunchBehaviour)this).Invoke((Action)base.SendNetworkUpdate_Flags, 0f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override bool DetermineIfStationary()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localVelocity = GetLocalVelocity();
		if (((Vector3)(ref localVelocity)).sqrMagnitude < 0.5f)
		{
			return !AnyMounted();
		}
		return false;
	}

	public override void SeatClippedWorld(BaseMountable mountable)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer mounted = mountable.GetMounted();
		if (!((Object)(object)mounted == (Object)null))
		{
			if (IsDriver(mounted))
			{
				steering = 0f;
				gasPedal = 0f;
			}
			Vector3 velocity = rigidBody.velocity;
			float num = Mathf.InverseLerp(4f, 20f, ((Vector3)(ref velocity)).magnitude);
			if (num > 0f)
			{
				mounted.Hurt(num * 100f, DamageType.Blunt, this, useProtection: false);
			}
			if ((Object)(object)mounted != (Object)null && mounted.isMounted)
			{
				base.SeatClippedWorld(mountable);
			}
		}
	}

	public void UpdateDrag()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3Ex.SqrMagnitude2D(rigidBody.velocity);
		float num2 = Mathf.InverseLerp(0f, 2f, num);
		float num3 = angularDragBase * (IsOn() ? 1f : engineOffAngularDragMultiplier);
		rigidBody.angularDrag = num3 + angularDragVelocity * num2;
		rigidBody.drag = landDrag + waterDrag * Mathf.InverseLerp(0f, 1f, buoyancy.submergedFraction);
		if (offAxisDrag > 0f)
		{
			Vector3 forward = ((Component)this).transform.forward;
			Vector3 velocity = rigidBody.velocity;
			float num4 = Vector3.Dot(forward, ((Vector3)(ref velocity)).normalized);
			float num5 = Mathf.InverseLerp(0.98f, 0.92f, num4);
			Rigidbody obj = rigidBody;
			obj.drag += num5 * offAxisDrag * buoyancy.submergedFraction;
		}
	}

	public override void OnDied(HitInfo info)
	{
		if (!IsDying)
		{
			SetFlag(Flags.Broken, b: true);
			repair.enabled = false;
			((FacepunchBehaviour)this).Invoke((Action)DismountAllPlayers, 10f);
			EnterCorpseState();
		}
	}

	protected virtual void EnterCorpseState()
	{
		((FacepunchBehaviour)this).Invoke((Action)ActualDeath, vehicle.boat_corpse_seconds);
	}

	public void ActualDeath()
	{
		Kill(DestroyMode.Gib);
	}

	public override bool MountEligable(BasePlayer player)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (IsDying)
		{
			return false;
		}
		Vector3 velocity = rigidBody.velocity;
		if (((Vector3)(ref velocity)).magnitude >= 5f && HasDriver())
		{
			return false;
		}
		return base.MountEligable(player);
	}

	public override bool HasValidDismountPosition(BasePlayer player)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldVelocity = GetWorldVelocity();
		if (((Vector3)(ref worldVelocity)).magnitude <= 4f)
		{
			Transform[] array = stationaryDismounts;
			foreach (Transform val in array)
			{
				if (ValidDismountPosition(player, ((Component)val).transform.position))
				{
					return true;
				}
			}
		}
		return base.HasValidDismountPosition(player);
	}

	public override bool GetDismountPosition(BasePlayer player, out Vector3 res, bool silent = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		Vector3 velocity = rigidBody.velocity;
		if (((Vector3)(ref velocity)).magnitude <= 4f)
		{
			List<Vector3> list = Pool.Get<List<Vector3>>();
			Transform[] array = stationaryDismounts;
			foreach (Transform val in array)
			{
				if (ValidDismountPosition(player, ((Component)val).transform.position))
				{
					list.Add(((Component)val).transform.position);
				}
			}
			if (list.Count > 0)
			{
				Vector3 pos = ((Component)player).transform.position;
				list.Sort((Vector3 a, Vector3 b) => Vector3.Distance(a, pos).CompareTo(Vector3.Distance(b, pos)));
				res = list[0];
				Pool.FreeUnmanaged<Vector3>(ref list);
				return true;
			}
			Pool.FreeUnmanaged<Vector3>(ref list);
		}
		return base.GetDismountPosition(player, out res, silent: false);
	}

	public override void DisableTransferProtection()
	{
		if ((Object)(object)GetDriver() != (Object)null && IsOn())
		{
			gasPedal = 0f;
			steering = 0f;
			lastHadDriverTime = Time.time;
		}
		base.DisableTransferProtection();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.motorBoat = Pool.Get<Motorboat>();
		info.msg.motorBoat.storageid = storageUnitInstance.uid;
		info.msg.motorBoat.fuelStorageID = fuelSystem.GetInstanceID();
	}

	public override bool CanPushNow(BasePlayer pusher)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (!IsStationary() || (!(pusher.WaterFactor() <= 0.6f) && !IsFlipped()))
		{
			return false;
		}
		if (!IsFlipped() && pusher.IsStandingOnEntity(this, 8192))
		{
			return false;
		}
		if (Vector3.Distance(((Component)pusher).transform.position, ((Component)this).transform.position) > 5f)
		{
			return false;
		}
		if (IsDying)
		{
			return false;
		}
		if (!pusher.isMounted && pusher.IsOnGround() && base.healthFraction > 0f)
		{
			return ShowPushMenu(pusher);
		}
		return false;
	}

	private bool ShowPushMenu(BasePlayer player)
	{
		if (!IsFlipped() && player.IsStandingOnEntity(this, 8192))
		{
			return false;
		}
		if (IsStationary())
		{
			if (!(player.WaterFactor() <= 0.6f))
			{
				return IsFlipped();
			}
			return true;
		}
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.motorBoat != null)
		{
			fuelSystem.SetInstanceID(info.msg.motorBoat.fuelStorageID);
			storageUnitInstance.uid = info.msg.motorBoat.storageid;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class NeonSign : Signage
{
	private const float FastSpeed = 0.5f;

	private const float MediumSpeed = 1f;

	private const float SlowSpeed = 2f;

	private const float MinSpeed = 0.5f;

	private const float MaxSpeed = 5f;

	[Header("Neon Sign")]
	public Light topLeft;

	public Light topRight;

	public Light bottomLeft;

	public Light bottomRight;

	public float lightIntensity = 2f;

	[Range(1f, 100f)]
	public int powerConsumption = 10;

	public Material activeMaterial;

	public Material inactiveMaterial;

	public float animationSpeed = 1f;

	public int currentFrame;

	public List<Lights> frameLighting;

	public const Flags Flag_HasAuxPower = Flags.Reserved9;

	public bool isAnimating;

	public Action animationLoopAction;

	private int[] cachedInputs;

	private readonly List<int> inputFrameHistory = new List<int>();

	public AmbienceEmitter ambientSoundEmitter;

	public SoundDefinition switchSoundDef;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NeonSign.OnRpcMessage", 0);
		try
		{
			if (rpc == 2433901419u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetAnimationSpeed "));
				}
				TimeWarning val2 = TimeWarning.New("SetAnimationSpeed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2433901419u, "SetAnimationSpeed", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2433901419u, "SetAnimationSpeed", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rPCMessage2 = rPCMessage;
							SetAnimationSpeed(rPCMessage2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetAnimationSpeed");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1919786296 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateNeonColors "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateNeonColors", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1919786296u, "UpdateNeonColors", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1919786296u, "UpdateNeonColors", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							UpdateNeonColors(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UpdateNeonColors");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return powerConsumption;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.neonSign == null)
		{
			return;
		}
		if (frameLighting != null)
		{
			foreach (Lights item in frameLighting)
			{
				Lights current = item;
				Pool.Free<Lights>(ref current);
			}
			Pool.Free<Lights>(ref frameLighting, false);
		}
		frameLighting = info.msg.neonSign.frameLighting;
		info.msg.neonSign.frameLighting = null;
		currentFrame = Mathf.Clamp(info.msg.neonSign.currentFrame, 0, paintableSources.Length);
		animationSpeed = Mathf.Clamp(info.msg.neonSign.animationSpeed, 0.5f, 5f);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		animationLoopAction = SwitchToNextFrame;
		cachedInputs = new int[inputs.Length];
	}

	public override void ResetState()
	{
		base.ResetState();
		((FacepunchBehaviour)this).CancelInvoke(animationLoopAction);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
		else
		{
			if (inputSlot <= 0)
			{
				return;
			}
			bool b = false;
			for (int i = 1; i < cachedInputs.Length; i++)
			{
				if (cachedInputs[i] >= powerConsumption)
				{
					b = true;
					break;
				}
			}
			SetFlag(Flags.Reserved9, b);
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (inputSlot >= 0 && inputSlot < cachedInputs.Length)
		{
			cachedInputs[inputSlot] = inputAmount;
		}
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputSlot > 0)
		{
			if (inputAmount > 0)
			{
				inputFrameHistory.Remove(inputSlot);
				inputFrameHistory.Add(inputSlot);
			}
			else
			{
				inputFrameHistory.Remove(inputSlot);
			}
		}
		int num = 0;
		int num2 = -1;
		if (HasFlag(Flags.Reserved9))
		{
			for (int i = 1; i < cachedInputs.Length; i++)
			{
				int num3 = cachedInputs[i];
				if (num3 > num)
				{
					num = num3;
					num2 = i - 1;
				}
				else if (num3 == num && num3 > 0)
				{
					int item = num2 + 1;
					if (inputFrameHistory.IndexOf(i) > inputFrameHistory.IndexOf(item))
					{
						num2 = i - 1;
					}
				}
			}
		}
		if (inputSlot == 0 && cachedInputs[0] != inputAmount)
		{
			cachedInputs[0] = inputAmount;
		}
		bool flag = HasFlag(Flags.Reserved8);
		if (flag && inputSlot == 0)
		{
			cachedInputs[0] = inputAmount;
			if (!isAnimating)
			{
				((FacepunchBehaviour)this).InvokeRepeating(animationLoopAction, animationSpeed, animationSpeed);
				isAnimating = true;
			}
			if (num2 >= 0)
			{
				currentFrame = num2;
				ClientRPC(RpcTarget.NetworkGroup("SetFrame"), currentFrame);
			}
		}
		if (HasFlag(Flags.Reserved9))
		{
			bool num4 = !flag && inputSlot == 0;
			bool flag2 = inputSlot > 0 && inputSlot - 1 == num2;
			bool flag3 = inputAmount == 0 && num2 != currentFrame && !flag;
			if (num4 || flag2 || flag3)
			{
				currentFrame = num2;
				if (isAnimating && flag)
				{
					((FacepunchBehaviour)this).CancelInvoke(animationLoopAction);
					((FacepunchBehaviour)this).InvokeRepeating(animationLoopAction, animationSpeed, animationSpeed);
				}
				ClientRPC(RpcTarget.NetworkGroup("SetFrame"), currentFrame);
				if (isAnimating && !flag)
				{
					((FacepunchBehaviour)this).CancelInvoke(animationLoopAction);
					isAnimating = false;
				}
			}
		}
		if (isAnimating && !flag)
		{
			((FacepunchBehaviour)this).CancelInvoke(animationLoopAction);
			isAnimating = false;
			MarkDirty();
		}
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (inputIndex == 0)
		{
			return powerConsumption;
		}
		if (!HasFlag(Flags.Reserved8))
		{
			return powerConsumption;
		}
		return 0;
	}

	private void SwitchToFrame(int index)
	{
		if (index >= 0 && index < paintableSources.Length)
		{
			int num = currentFrame;
			currentFrame = index;
			if (currentFrame != num && textureIDs[currentFrame] != 0)
			{
				ClientRPC(RpcTarget.NetworkGroup("SetFrame"), currentFrame);
			}
		}
	}

	private void SwitchToNextFrame()
	{
		int index = (currentFrame + 1) % paintableSources.Length;
		SwitchToFrame(index);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		List<Lights> list = Pool.Get<List<Lights>>();
		if (frameLighting != null)
		{
			foreach (Lights item in frameLighting)
			{
				list.Add(item.Copy());
			}
		}
		info.msg.neonSign = Pool.Get<NeonSign>();
		info.msg.neonSign.frameLighting = list;
		info.msg.neonSign.currentFrame = currentFrame;
		info.msg.neonSign.animationSpeed = animationSpeed;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void SetAnimationSpeed(RPCMessage msg)
	{
		float num = Mathf.Clamp(msg.read.Float(), 0.5f, 5f);
		if (!FloatEx.IsNaN(num))
		{
			animationSpeed = num;
			if (isAnimating)
			{
				((FacepunchBehaviour)this).CancelInvoke(animationLoopAction);
				((FacepunchBehaviour)this).InvokeRepeating(animationLoopAction, animationSpeed, animationSpeed);
			}
			SendNetworkUpdate();
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void UpdateNeonColors(RPCMessage msg)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		if (CanUpdateSign(msg.player))
		{
			int num = msg.read.Int32();
			if (num >= 0 && num < paintableSources.Length)
			{
				EnsureInitialized();
				frameLighting[num].topLeft = ClampColor(msg.read.Color());
				frameLighting[num].topRight = ClampColor(msg.read.Color());
				frameLighting[num].bottomLeft = ClampColor(msg.read.Color());
				frameLighting[num].bottomRight = ClampColor(msg.read.Color());
				SendNetworkUpdate();
			}
		}
	}

	public new void EnsureInitialized()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (frameLighting == null)
		{
			frameLighting = Pool.Get<List<Lights>>();
		}
		while (frameLighting.Count < paintableSources.Length)
		{
			Lights val = Pool.Get<Lights>();
			val.topLeft = Color.clear;
			val.topRight = Color.clear;
			val.bottomLeft = Color.clear;
			val.bottomRight = Color.clear;
			frameLighting.Add(val);
		}
	}

	private static Color ClampColor(Color color)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		return new Color(FloatEx.IsNaN(color.r) ? 0f : Mathf.Clamp01(color.r), FloatEx.IsNaN(color.g) ? 0f : Mathf.Clamp01(color.g), FloatEx.IsNaN(color.b) ? 0f : Mathf.Clamp01(color.b), FloatEx.IsNaN(color.a) ? 0f : Mathf.Clamp01(color.a));
	}
}


using System;
using Network;
using Rust;
using UnityEngine;

public class NewYearGong : BaseCombatEntity
{
	public SoundDefinition gongSound;

	public float minTimeBetweenSounds = 0.25f;

	public GameObject soundRoot;

	public Transform gongCentre;

	public float gongRadius = 1f;

	public AnimationCurve pitchCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public Animator gongAnimator;

	private float lastSound;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NewYearGong.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Hurt(HitInfo info)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!info.damageTypes.IsMeleeType() && !info.damageTypes.Has(DamageType.Bullet) && !info.damageTypes.Has(DamageType.Arrow))
		{
			base.Hurt(info);
			return;
		}
		Vector3 val = gongCentre.InverseTransformPoint(info.HitPositionWorld);
		val.z = 0f;
		float num = Vector3.Distance(val, Vector3.zero);
		if (num < gongRadius)
		{
			if (Time.time - lastSound > minTimeBetweenSounds)
			{
				lastSound = Time.time;
				ClientRPC(RpcTarget.NetworkGroup("PlaySound"), Mathf.Clamp01(num / gongRadius));
			}
		}
		else
		{
			base.Hurt(info);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class NPCTalking : NPCShopKeeper, IConversationProvider
{
	[Serializable]
	public class NPCConversationResultAction
	{
		public string action;

		public int scrapCost;

		public string broadcastMessage;

		public float broadcastRange;
	}

	public const string Generic_Mission_Provider_List_ID = "generic_mission_provider_list";

	public const string Generic_Mission_Provider_Preview_ID = "generic_mission_provider_list_mission_preview";

	public ConversationData[] conversations;

	public NPCConversationResultAction[] conversationResultActions;

	[NonSerialized]
	public float maxConversationDistance = 5f;

	public List<BasePlayer> conversingPlayers = new List<BasePlayer>();

	public BasePlayer lastActionPlayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NPCTalking.OnRpcMessage", 0);
		try
		{
			if (rpc == 4224060672u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ConversationAction "));
				}
				TimeWarning val2 = TimeWarning.New("ConversationAction", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4224060672u, "ConversationAction", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(4224060672u, "ConversationAction", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ConversationAction(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ConversationAction");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2112414875 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_BeginTalking "));
				}
				TimeWarning val2 = TimeWarning.New("Server_BeginTalking", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2112414875u, "Server_BeginTalking", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2112414875u, "Server_BeginTalking", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_BeginTalking(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_BeginTalking");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1597539152 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_EndTalking "));
				}
				TimeWarning val2 = TimeWarning.New("Server_EndTalking", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1597539152u, "Server_EndTalking", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1597539152u, "Server_EndTalking", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							Server_EndTalking(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in Server_EndTalking");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2713250658u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_ResponsePressed "));
				}
				TimeWarning val2 = TimeWarning.New("Server_ResponsePressed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2713250658u, "Server_ResponsePressed", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2713250658u, "Server_ResponsePressed", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							Server_ResponsePressed(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in Server_ResponsePressed");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public int GetConversationIndex(string conversationName)
	{
		for (int i = 0; i < conversations.Length; i++)
		{
			if (conversations[i].shortname == conversationName)
			{
				return i;
			}
		}
		return -1;
	}

	public virtual string GetConversationStartSpeech(BasePlayer player)
	{
		return "intro";
	}

	public ConversationData GetConversation(string conversationName)
	{
		return GetConversation(GetConversationIndex(conversationName));
	}

	public ConversationData GetConversation(int index)
	{
		return conversations[index];
	}

	public virtual ConversationData GetConversationFor(BasePlayer player)
	{
		return conversations[0];
	}

	public bool ProviderBusy()
	{
		return HasFlag(Flags.Reserved1);
	}

	public BaseMission GetGenericMissionById(uint id)
	{
		ScriptableObjectRef[] missionList = MissionManifest.Get().missionList;
		NPCSimpleMissionProvider nPCSimpleMissionProvider = default(NPCSimpleMissionProvider);
		for (int i = 0; i < missionList.Length; i++)
		{
			BaseMission baseMission = missionList[i].Get() as BaseMission;
			if (baseMission != null && baseMission.id == id && baseMission.genericMissionProvider.isValid && baseMission.genericMissionProvider.Get().TryGetComponent<NPCSimpleMissionProvider>(ref nPCSimpleMissionProvider) && nPCSimpleMissionProvider.prefabID == prefabID)
			{
				return baseMission;
			}
		}
		return null;
	}

	public virtual void GetGenericMissionList(List<BaseMission> foundMissions)
	{
	}

	public void ForceEndConversation(BasePlayer player)
	{
		ClientRPC(RpcTarget.Player("Client_EndConversation", player));
		OnConversationEnded(player);
	}

	public void ForceSpeechNode(BasePlayer player, int speechNodeIndex)
	{
		if (!((Object)(object)player == (Object)null))
		{
			ClientRPC(RpcTarget.Player("Client_ForceSpeechNode", player), speechNodeIndex);
		}
	}

	public virtual void OnConversationEnded(BasePlayer player)
	{
		Interface.CallHook("OnNpcConversationEnded", (object)this, (object)player);
		if (conversingPlayers.Contains(player))
		{
			conversingPlayers.Remove(player);
		}
	}

	public void CleanupConversingPlayers()
	{
		for (int num = conversingPlayers.Count - 1; num >= 0; num--)
		{
			BasePlayer basePlayer = conversingPlayers[num];
			if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAlive() || basePlayer.IsSleeping())
			{
				conversingPlayers.RemoveAt(num);
			}
		}
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_BeginTalking(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		Server_BeginTalking(player);
	}

	protected virtual bool CanTalkTo(BasePlayer bp)
	{
		if ((Object)(object)bp == (Object)null)
		{
			return false;
		}
		if (!bp.IsOnGround())
		{
			return false;
		}
		return true;
	}

	public void Server_BeginTalking(BasePlayer ply)
	{
		if (!CanTalkTo(ply))
		{
			return;
		}
		CleanupConversingPlayers();
		OnConversationStarted(ply);
		ConversationData conversationFor = GetConversationFor(ply);
		if ((Object)(object)conversationFor != (Object)null)
		{
			if (conversingPlayers.Contains(ply))
			{
				OnConversationEnded(ply);
			}
			if (Interface.CallHook("OnNpcConversationStart", (object)this, (object)ply, (object)conversationFor) == null)
			{
				conversingPlayers.Add(ply);
				UpdateFlags();
				ClientRPC(RpcTarget.Player("Client_StartConversation", ply), GetConversationIndex(conversationFor.shortname), GetConversationStartSpeech(ply));
			}
		}
	}

	public virtual void OnConversationStarted(BasePlayer speakingTo)
	{
	}

	public virtual void UpdateFlags()
	{
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_EndTalking(RPCMessage msg)
	{
		OnConversationEnded(msg.player);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void ConversationAction(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		string action = msg.read.String(256, false);
		OnConversationAction(player, action);
	}

	public bool ValidConversationPlayer(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3.Distance(((Component)player).transform.position, ((Component)this).transform.position) > maxConversationDistance)
		{
			return false;
		}
		if (conversingPlayers.Contains(player))
		{
			return false;
		}
		return true;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		uint id = msg.read.UInt32();
		ConversationData conversationFor = GetConversationFor(player);
		if ((Object)(object)conversationFor == (Object)null)
		{
			return;
		}
		if (conversationFor.speeches[num].shortname == "generic_mission_provider_list")
		{
			num2 = 0;
		}
		if (conversationFor.speeches[num].shortname == "generic_mission_provider_list_mission_preview" && num2 == 0)
		{
			BaseMission genericMissionById = GetGenericMissionById(id);
			if (genericMissionById != null && player.CanAcceptMission(genericMissionById))
			{
				TryAssignMissionToPlayer(genericMissionById, player);
			}
		}
		ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];
		if (responseNode == null || Interface.CallHook("OnNpcConversationRespond", (object)this, (object)player, (object)conversationFor, (object)responseNode) != null)
		{
			return;
		}
		if (responseNode.conditions.Length != 0)
		{
			UpdateFlags();
		}
		bool flag = responseNode.PassesConditions(player, this);
		if (flag)
		{
			string actionString = responseNode.GetActionString();
			if (!string.IsNullOrEmpty(actionString))
			{
				OnConversationAction(player, actionString);
			}
		}
		int speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
		if (speechNodeIndex == -1)
		{
			ForceEndConversation(player);
			return;
		}
		ForceSpeechNode(player, speechNodeIndex);
		Interface.CallHook("OnNpcConversationResponded", (object)this, (object)player, (object)conversationFor, (object)responseNode);
	}

	public BasePlayer GetActionPlayer()
	{
		return lastActionPlayer;
	}

	public virtual void OnConversationAction(BasePlayer player, string action)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (action == "openvending")
		{
			InvisibleVendingMachine vendingMachine = GetVendingMachine();
			if ((Object)(object)vendingMachine != (Object)null && Vector3.Distance(((Component)player).transform.position, ((Component)this).transform.position) < 5f)
			{
				ForceEndConversation(player);
				if (Interface.CallHook("OnVendingShopOpen", (object)vendingMachine, (object)player) == null)
				{
					vendingMachine.PlayerOpenLoot(player, "vendingmachine.customer", doPositionChecks: false);
					Interface.CallHook("OnVendingShopOpened", (object)vendingMachine, (object)player);
				}
				return;
			}
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("scrap");
		NPCConversationResultAction[] array = conversationResultActions;
		foreach (NPCConversationResultAction nPCConversationResultAction in array)
		{
			if (!(nPCConversationResultAction.action == action))
			{
				continue;
			}
			CleanupConversingPlayers();
			foreach (BasePlayer conversingPlayer in conversingPlayers)
			{
				if (!((Object)(object)conversingPlayer == (Object)(object)player) && !((Object)(object)conversingPlayer == (Object)null))
				{
					int speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex("startbusy");
					ForceSpeechNode(conversingPlayer, speechNodeIndex);
				}
			}
			int num = nPCConversationResultAction.scrapCost;
			PooledList<Item> val = Pool.Get<PooledList<Item>>();
			try
			{
				player.inventory.FindItemsByItemID((List<Item>)(object)val, itemDefinition.itemid);
				foreach (Item item in (List<Item>)(object)val)
				{
					num -= item.amount;
				}
				if (num > 0)
				{
					int speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex("toopoor");
					ForceSpeechNode(player, speechNodeIndex2);
					break;
				}
				Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);
				num = nPCConversationResultAction.scrapCost;
				foreach (Item item2 in (List<Item>)(object)val)
				{
					int num2 = Mathf.Min(num, item2.amount);
					item2.UseItem(num2);
					num -= num2;
					if (num <= 0)
					{
						break;
					}
				}
				lastActionPlayer = player;
				BroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);
				lastActionPlayer = null;
				break;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	protected virtual void TryAssignMissionToPlayer(BaseMission mission, BasePlayer player)
	{
	}
}


using System;

[Serializable]
public class NPCConversationResultAction
{
	public string action;

	public int scrapCost;

	public string broadcastMessage;

	public float broadcastRange;
}


using System;
using Network;
using UnityEngine;

public class OreResourceEntity : StagedResourceEntity
{
	public GameObjectRef bonusPrefab;

	public GameObjectRef finishEffect;

	public GameObjectRef bonusFailEffect;

	public bool useHotspotMinigame = true;

	public SoundPlayer bonusSound;

	public float heightOffset;

	private int bonusesKilled;

	public int bonusesSpawned;

	public OreHotSpot _hotSpot;

	public Vector3 lastNodeDir = Vector3.zero;

	private Ray? spawnBonusHitRay;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("OreResourceEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		if (!info.DidGather && info.gatherScale > 0f)
		{
			if (useHotspotMinigame)
			{
				Jackhammer jackhammer = info.Weapon as Jackhammer;
				bool flag = (Object)(object)_hotSpot == (Object)null;
				if ((Object)(object)_hotSpot == (Object)null)
				{
					_hotSpot = SpawnBonusSpotOnRay(new Ray(info.PointStart, info.attackNormal));
				}
				float num = (((Object)(object)_hotSpot != (Object)null) ? Vector3.Distance(info.HitPositionWorld, ((Component)_hotSpot).transform.position) : float.MaxValue);
				if (flag || num <= ((Component)_hotSpot).GetComponent<SphereCollider>().radius * 1.5f || (Object)(object)jackhammer != (Object)null)
				{
					float num2 = (((Object)(object)jackhammer == (Object)null) ? 1f : jackhammer.HotspotBonusScale);
					bonusesKilled++;
					info.gatherScale = 1f + Mathf.Clamp((float)bonusesKilled * 0.5f, 0f, 2f * num2);
					if ((Object)(object)_hotSpot != (Object)null)
					{
						_hotSpot.FireFinishEffect();
						ClientRPC<int, Vector3>(null, "PlayBonusLevelSound", bonusesKilled, ((Component)_hotSpot).transform.position);
					}
				}
				else if (bonusesKilled > 0)
				{
					bonusesKilled = 0;
					Effect.server.Run(bonusFailEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up);
				}
				if (bonusesKilled > 0)
				{
					CleanupBonus();
				}
				if ((Object)(object)_hotSpot == (Object)null)
				{
					if (flag)
					{
						spawnBonusHitRay = new Ray(info.PointStart, info.attackNormal);
						Vector3 val = info.PointStart - (((Component)this).transform.position + new Vector3(0f, 0.5f, 0f));
						lastNodeDir = ((Vector3)(ref val)).normalized;
						float num3 = 0.5f;
						if (lastNodeDir.y > num3)
						{
							float num4 = lastNodeDir.y - num3;
							lastNodeDir.y = num4;
							lastNodeDir.x += num4;
							lastNodeDir.z += num4;
						}
						lastNodeDir = ((Component)this).transform.InverseTransformDirection(lastNodeDir);
					}
					DelayedBonusSpawn();
				}
			}
			else
			{
				info.gatherScale = 1f;
			}
		}
		base.OnAttacked(info);
	}

	public override void UpdateNetworkStage()
	{
		int num = stage;
		base.UpdateNetworkStage();
		if (stage != num && Object.op_Implicit((Object)(object)_hotSpot) && useHotspotMinigame)
		{
			DelayedBonusSpawn();
		}
	}

	public void CleanupBonus()
	{
		if (Object.op_Implicit((Object)(object)_hotSpot))
		{
			_hotSpot.Kill();
		}
		_hotSpot = null;
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		CleanupBonus();
	}

	public override void OnDied(HitInfo info)
	{
		CleanupBonus();
		base.OnDied(info);
	}

	public void FinishBonusAssigned()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(finishEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up);
	}

	public void DelayedBonusSpawn()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)RespawnBonus);
		((FacepunchBehaviour)this).Invoke((Action)RespawnBonus, 0.25f);
	}

	public void RespawnBonus()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		CleanupBonus();
		if (spawnBonusHitRay.HasValue)
		{
			_hotSpot = SpawnBonusSpotOnRay(spawnBonusHitRay.Value);
			spawnBonusHitRay = null;
		}
		else
		{
			_hotSpot = SpawnBonusSpot(lastNodeDir);
		}
	}

	private OreHotSpot SpawnBonusSpotOnRay(Ray r)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return null;
		}
		if (!useHotspotMinigame)
		{
			return null;
		}
		if (!bonusPrefab.isValid)
		{
			return null;
		}
		RaycastHit val = default(RaycastHit);
		if (((Collider)ResourceMeshCollider).Raycast(r, ref val, 15f))
		{
			OreHotSpot obj = GameManager.server.CreateEntity(bonusPrefab.resourcePath, ((RaycastHit)(ref val)).point - ((Ray)(ref r)).direction * 0.025f, Quaternion.LookRotation(((RaycastHit)(ref val)).normal, Vector3.up)) as OreHotSpot;
			obj.Spawn();
			obj.OreOwner(this);
			return obj;
		}
		return SpawnBonusSpot(lastNodeDir);
	}

	public OreHotSpot SpawnBonusSpot(Vector3 lastDirection)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return null;
		}
		if (!useHotspotMinigame)
		{
			return null;
		}
		if (!bonusPrefab.isValid)
		{
			return null;
		}
		Vector3 zero = Vector3.zero;
		MeshCollider resourceMeshCollider = ResourceMeshCollider;
		Transform transform = ((Component)this).transform;
		Bounds val = ((Collider)resourceMeshCollider).bounds;
		Vector3 val2 = transform.InverseTransformPoint(((Bounds)(ref val)).center);
		Vector3 val6;
		if (lastDirection == Vector3.zero)
		{
			float num = 0.5f;
			if (heightOffset != 0f)
			{
				num = heightOffset;
			}
			Vector3 val3 = RandomCircle();
			Vector3 val4 = (lastNodeDir = ((Component)this).transform.TransformDirection(((Vector3)(ref val3)).normalized));
			val3 = ((Component)this).transform.position + ((Component)this).transform.up * (val2.y + num) + ((Vector3)(ref val4)).normalized * 5f;
			zero = val3;
		}
		else
		{
			Vector3 val5 = Vector3.Cross(lastNodeDir, Vector3.up);
			float num2 = Random.Range(0.25f, 0.5f) + (float)stage * 0.25f;
			float num3 = ((Random.Range(0, 2) == 0) ? (-1f) : 1f);
			val6 = lastNodeDir + val5 * (num2 * num3);
			Vector3 val7 = (lastNodeDir = ((Vector3)(ref val6)).normalized);
			zero = ((Component)this).transform.position + ((Component)this).transform.TransformDirection(val7) * 2f;
			float num4 = Random.Range(1f, 1.5f);
			zero += ((Component)this).transform.up * (val2.y + num4);
		}
		bonusesSpawned++;
		val = ((Collider)resourceMeshCollider).bounds;
		val6 = ((Bounds)(ref val)).center - zero;
		Vector3 normalized = ((Vector3)(ref val6)).normalized;
		RaycastHit val8 = default(RaycastHit);
		if (((Collider)resourceMeshCollider).Raycast(new Ray(zero, normalized), ref val8, 15f))
		{
			OreHotSpot obj = GameManager.server.CreateEntity(bonusPrefab.resourcePath, ((RaycastHit)(ref val8)).point - normalized * 0.025f, Quaternion.LookRotation(((RaycastHit)(ref val8)).normal, Vector3.up)) as OreHotSpot;
			obj.Spawn();
			obj.OreOwner(this);
			return obj;
		}
		return null;
	}

	public Vector3 RandomCircle(float distance = 1f, bool allowInside = false)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val;
		if (!allowInside)
		{
			Vector2 insideUnitCircle = Random.insideUnitCircle;
			val = ((Vector2)(ref insideUnitCircle)).normalized;
		}
		else
		{
			val = Random.insideUnitCircle;
		}
		Vector2 val2 = val;
		return new Vector3(val2.x, 0f, val2.y);
	}

	public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset, bool allowInside = true, bool changeHeight = true)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		degreesOffset = Mathf.Clamp(degreesOffset / 180f, -180f, 180f);
		Vector2 val;
		if (!allowInside)
		{
			Vector2 insideUnitCircle = Random.insideUnitCircle;
			val = ((Vector2)(ref insideUnitCircle)).normalized;
		}
		else
		{
			val = Random.insideUnitCircle;
		}
		Vector2 val2 = val;
		Vector3 val3 = default(Vector3);
		((Vector3)(ref val3))..ctor(val2.x * degreesOffset, changeHeight ? (Random.Range(-1f, 1f) * degreesOffset) : 0f, val2.y * degreesOffset);
		Vector3 val4 = input + val3;
		return ((Vector3)(ref val4)).normalized;
	}

	public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		degreesOffset = Mathf.Clamp(degreesOffset / 180f, -180f, 180f);
		Vector3 val = hemiInput + Vector3.one * degreesOffset;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = hemiInput + Vector3.one * (0f - degreesOffset);
		Vector3 normalized2 = ((Vector3)(ref val)).normalized;
		for (int i = 0; i < 3; i++)
		{
			((Vector3)(ref inputVec))[i] = Mathf.Clamp(((Vector3)(ref inputVec))[i], ((Vector3)(ref normalized2))[i], ((Vector3)(ref normalized))[i]);
		}
		return inputVec;
	}

	public static Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight = 0f, float maxHeight = 0f, bool allowInside = false)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val;
		if (!allowInside)
		{
			Vector2 insideUnitCircle = Random.insideUnitCircle;
			val = ((Vector2)(ref insideUnitCircle)).normalized;
		}
		else
		{
			val = Random.insideUnitCircle;
		}
		Vector2 val2 = val;
		Vector3 val3 = new Vector3(val2.x, 0f, val2.y);
		Vector3 result = ((Vector3)(ref val3)).normalized * distance;
		result.y = Random.Range(minHeight, maxHeight);
		return result;
	}

	public Vector3 ClampToCylinder(Vector3 localPos, Vector3 cylinderAxis, float cylinderDistance, float minHeight = 0f, float maxHeight = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.zero;
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class PagerEntity : BaseEntity, IRFObject
{
	public static Flags Flag_Silent = Flags.Reserved1;

	private int frequency = 55;

	public float beepRepeat = 2f;

	public GameObjectRef pagerEffect;

	public GameObjectRef silentEffect;

	private float nextChangeTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PagerEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 2778616053u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSetFrequency "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSetFrequency", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2778616053u, "ServerSetFrequency", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerSetFrequency(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerSetFrequency");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public int GetFrequency()
	{
		return frequency;
	}

	public override void SwitchParent(BaseEntity ent)
	{
		SetParent(ent, worldPositionStays: false, sendImmediate: true);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		RFManager.AddListener(frequency, this);
	}

	internal override void DoServerDestroy()
	{
		RFManager.RemoveListener(frequency, this);
		base.DoServerDestroy();
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public float GetMaxRange()
	{
		return float.PositiveInfinity;
	}

	public void RFSignalUpdate(bool on)
	{
		if (!base.IsDestroyed)
		{
			bool flag = IsOn();
			if (on != flag)
			{
				SetFlag(Flags.On, on);
				SendNetworkUpdate();
			}
		}
	}

	public void SetSilentMode(bool wantsSilent)
	{
		SetFlag(Flag_Silent, wantsSilent);
	}

	public void SetOff()
	{
		SetFlag(Flags.On, b: false);
	}

	public void ChangeFrequency(int newFreq)
	{
		RFManager.ChangeFrequency(frequency, newFreq, this, isListener: true);
		frequency = newFreq;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ServerSetFrequency(RPCMessage msg)
	{
		if (!((Object)(object)msg.player == (Object)null) && msg.player.CanBuild() && !(Time.time < nextChangeTime))
		{
			nextChangeTime = Time.time + 2f;
			int num = msg.read.Int32();
			if (Interface.CallHook("OnRfFrequencyChange", (object)this, (object)num, (object)msg.player) == null)
			{
				RFManager.ChangeFrequency(frequency, num, this, isListener: true);
				frequency = num;
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnRfFrequencyChanged", (object)this, (object)num, (object)msg.player);
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.genericInt1 = frequency;
	}

	internal override void OnParentRemoved()
	{
		SetParent(null, worldPositionStays: false, sendImmediate: true);
	}

	public void OnParentDestroying()
	{
		if (base.isServer)
		{
			((Component)this).transform.parent = null;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			frequency = info.msg.ioEntity.genericInt1;
		}
		if (base.isServer && info.fromDisk)
		{
			ChangeFrequency(frequency);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class PaintedItemStorageEntity : BaseEntity, IServerFileReceiver, IUGCBrowserEntity
{
	public uint _currentImageCrc;

	private ulong lastEditedBy;

	public uint[] GetContentCRCs
	{
		get
		{
			if (_currentImageCrc == 0)
			{
				return Array.Empty<uint>();
			}
			return new uint[1] { _currentImageCrc };
		}
	}

	public UGCType ContentType => UGCType.ImageJpg;

	public List<ulong> EditingHistory
	{
		get
		{
			if (lastEditedBy == 0)
			{
				return new List<ulong>();
			}
			return new List<ulong> { lastEditedBy };
		}
	}

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public override bool ShouldTransferAssociatedFiles => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PaintedItemStorageEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 2439017595u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_UpdateImage "));
				}
				TimeWarning val2 = TimeWarning.New("Server_UpdateImage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2439017595u, "Server_UpdateImage", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_UpdateImage(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_UpdateImage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.paintedItem != null)
		{
			_currentImageCrc = info.msg.paintedItem.imageCrc;
			if (base.isServer)
			{
				lastEditedBy = info.msg.paintedItem.editedBy;
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.paintedItem = Pool.Get<PaintedItem>();
		info.msg.paintedItem.imageCrc = _currentImageCrc;
		info.msg.paintedItem.editedBy = lastEditedBy;
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	private void Server_UpdateImage(RPCMessage msg)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null || (ulong)msg.player.userID != base.OwnerID)
		{
			return;
		}
		foreach (Item item2 in msg.player.inventory.containerWear.itemList)
		{
			if (item2.instanceData != null && item2.instanceData.subEntity == net.ID)
			{
				return;
			}
		}
		Item item = msg.player.inventory.FindBySubEntityID(net.ID);
		if (item == null || item.isBroken)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (array == null)
		{
			if (_currentImageCrc != 0)
			{
				FileStorage.server.RemoveExact(_currentImageCrc, FileStorage.Type.png, net.ID, 0u);
			}
			_currentImageCrc = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 512, 512))
			{
				return;
			}
			uint currentImageCrc = _currentImageCrc;
			if (_currentImageCrc != 0)
			{
				FileStorage.server.RemoveExact(_currentImageCrc, FileStorage.Type.png, net.ID, 0u);
			}
			_currentImageCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
			if (_currentImageCrc != currentImageCrc)
			{
				item.LoseCondition(0.25f);
			}
			lastEditedBy = msg.player.userID;
		}
		Interface.CallHook("OnItemPainted", (object)this, (object)item, (object)msg.player, (object)array);
		SendNetworkUpdate();
	}

	internal override void DoServerDestroy()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		if (!Application.isQuitting && net != null)
		{
			FileStorage.server.RemoveAllByEntity(net.ID);
		}
	}

	public void ClearContent()
	{
		_currentImageCrc = 0u;
		SendNetworkUpdate();
	}

	[Conditional("PAINTED_ITEM_DEBUG")]
	private void DebugOnlyLog(string str)
	{
		Debug.Log((object)str, (Object)(object)this);
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class PatrolHelicopter : BaseCombatEntity, SeekerTarget.ISeekerTargetOwner
{
	[Serializable]
	public class weakspot
	{
		[NonSerialized]
		public PatrolHelicopter body;

		public string[] bonenames;

		public float maxHealth;

		public float health;

		public float healthFractionOnDestroyed = 0.5f;

		public GameObjectRef destroyedParticles;

		public GameObjectRef damagedParticles;

		public GameObject damagedEffect;

		public GameObject destroyedEffect;

		public List<BasePlayer> attackers;

		private bool isDestroyed;

		public float HealthFraction()
		{
			return health / maxHealth;
		}

		public void Hurt(float amount, HitInfo info)
		{
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			if (!isDestroyed)
			{
				health -= amount;
				Effect.server.Run(damagedParticles.resourcePath, body, StringPool.Get(bonenames[Random.Range(0, bonenames.Length)]), Vector3.zero, Vector3.up, null, broadcast: true);
				if (health <= 0f)
				{
					health = 0f;
					WeakspotDestroyed();
				}
			}
		}

		public void Heal(float amount)
		{
			health += amount;
		}

		public void WeakspotDestroyed()
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			isDestroyed = true;
			Effect.server.Run(destroyedParticles.resourcePath, body, StringPool.Get(bonenames[Random.Range(0, bonenames.Length)]), Vector3.zero, Vector3.up, null, broadcast: true);
			body.Hurt(body.MaxHealth() * healthFractionOnDestroyed, DamageType.Generic, null, useProtection: false);
		}
	}

	public GameObject rotorPivot;

	public GameObject mainRotor;

	public GameObject mainRotor_blades;

	public GameObject mainRotor_blur;

	public GameObject tailRotor;

	public GameObject tailRotor_blades;

	public GameObject tailRotor_blur;

	public GameObject rocket_tube_left;

	public GameObject rocket_tube_right;

	public GameObject left_gun_yaw;

	public GameObject left_gun_pitch;

	public GameObject left_gun_muzzle;

	public GameObject right_gun_yaw;

	public GameObject right_gun_pitch;

	public GameObject right_gun_muzzle;

	public GameObject spotlight_rotation;

	public GameObjectRef rocket_fire_effect;

	public GameObjectRef gun_fire_effect;

	public GameObjectRef bulletEffect;

	public GameObjectRef explosionEffect;

	public GameObjectRef fireBall;

	public GameObjectRef crateToDrop;

	public int maxCratesToSpawn = 4;

	public float bulletSpeed = 250f;

	public float bulletDamage = 20f;

	public GameObjectRef servergibs;

	public GameObjectRef debrisFieldMarker;

	public float flareDuration = 5f;

	public SoundDefinition rotorWashSoundDef;

	private Sound _rotorWashSound;

	public SoundDefinition flightEngineSoundDef;

	public SoundDefinition flightThwopsSoundDef;

	private Sound flightEngineSound;

	private Sound flightThwopsSound;

	public SoundModulation.Modulator flightEngineGainMod;

	public SoundModulation.Modulator flightThwopsGainMod;

	public float rotorGainModSmoothing = 0.25f;

	public float engineGainMin = 0.5f;

	public float engineGainMax = 1f;

	public float thwopGainMin = 0.5f;

	public float thwopGainMax = 1f;

	public float spotlightJitterAmount = 5f;

	public float spotlightJitterSpeed = 5f;

	public GameObject[] nightLights;

	public Vector3 spotlightTarget;

	public float engineSpeed = 1f;

	public float targetEngineSpeed = 1f;

	public float blur_rotationScale = 0.05f;

	public ParticleSystem[] _rotorWashParticles;

	public PatrolHelicopterAI myAI;

	public GameObjectRef mapMarkerEntityPrefab;

	public GameObjectRef fleeMapMarkerEntityPrefab;

	public static PatrolHelicopter Instance;

	public static BaseEntity ClientFleeMapMarker;

	public float lastNetworkUpdate = float.NegativeInfinity;

	private const float networkUpdateRate = 0.25f;

	private BaseEntity mapMarkerInstance;

	private BaseEntity fleeMapMarkerInstance;

	public weakspot[] weakspots;

	private NetworkableId __sync_FleeMarkerId;

	[Sync(Autosave = true)]
	public NetworkableId FleeMarkerId
	{
		[CompilerGenerated]
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return __sync_FleeMarkerId;
		}
		[CompilerGenerated]
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!IsSyncVarEqual<NetworkableId>(__sync_FleeMarkerId, value))
			{
				__sync_FleeMarkerId = value;
				byte nameID = __GetWeaverID("FleeMarkerId");
				QueueSyncVar(nameID);
			}
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PatrolHelicopter.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float MaxVelocity()
	{
		return 100f;
	}

	public override void InitShared()
	{
		base.InitShared();
		InitalizeWeakspots();
		Instance = this;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.helicopter != null)
		{
			spotlightTarget = info.msg.helicopter.spotlightVec;
		}
	}

	public void RadarLock(SeekingServerProjectile incoming)
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)CancelRadar))
		{
			SetFlag(Flags.Reserved8, b: true);
			((FacepunchBehaviour)this).Invoke((Action)CancelRadar, 5f);
		}
	}

	public void CancelRadar()
	{
		SetFlag(Flags.Reserved8, b: false);
	}

	public override void Save(SaveInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.helicopter = Pool.Get<Helicopter>();
		Helicopter helicopter = info.msg.helicopter;
		Quaternion localRotation = rotorPivot.transform.localRotation;
		helicopter.tiltRot = ((Quaternion)(ref localRotation)).eulerAngles;
		info.msg.helicopter.spotlightVec = spotlightTarget;
		info.msg.helicopter.weakspothealths = Pool.Get<List<float>>();
		for (int i = 0; i < weakspots.Length; i++)
		{
			info.msg.helicopter.weakspothealths.Add(weakspots[i].health);
		}
	}

	public override void ServerInit()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		myAI = ((Component)this).GetComponent<PatrolHelicopterAI>();
		if (!myAI.hasInterestZone)
		{
			myAI.SetInitialDestination(Vector3.zero, 1.25f);
			myAI.targetThrottleSpeed = 1f;
			myAI.ExitCurrentState();
			myAI.State_Patrol_Enter();
		}
		CreateMapMarker();
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		}
		if ((Object)(object)fleeMapMarkerInstance != (Object)null)
		{
			DestroyFleeMarker();
		}
		Instance = null;
		base.DestroyShared();
	}

	public void CreateMapMarker()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)mapMarkerInstance))
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.SetParent(this);
		baseEntity.Spawn();
		mapMarkerInstance = baseEntity;
	}

	public bool HasFleeMarker()
	{
		if ((Object)(object)fleeMapMarkerInstance != (Object)null)
		{
			return fleeMapMarkerInstance.IsValid();
		}
		return false;
	}

	public void CreateFleeMarker(Vector3 fleePosition)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)fleeMapMarkerInstance))
		{
			fleeMapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(fleeMapMarkerEntityPrefab.resourcePath, fleePosition, Quaternion.identity);
		baseEntity.Spawn();
		fleeMapMarkerInstance = baseEntity;
		FleeMarkerId = fleeMapMarkerInstance.net.ID;
	}

	public void DestroyFleeMarker()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (HasFleeMarker())
		{
			fleeMapMarkerInstance.Kill();
			fleeMapMarkerInstance = null;
			FleeMarkerId = default(NetworkableId);
		}
	}

	public override void OnPositionalNetworkUpdate()
	{
		SendNetworkUpdate();
		base.OnPositionalNetworkUpdate();
	}

	public void CreateExplosionMarker(float durationMinutes)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(debrisFieldMarker.resourcePath, ((Component)this).transform.position, Quaternion.identity);
		baseEntity.Spawn();
		((Component)baseEntity).SendMessage("SetDuration", (object)durationMinutes, (SendMessageOptions)1);
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		CreateExplosionMarker(10f);
		Effect.server.Run(explosionEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
		Vector3 val = myAI.GetLastMoveDir() * myAI.GetMoveSpeed() * 0.75f;
		GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;
		List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, ((Component)this).gameObject, gibSource, val, 3f);
		if (info.damageTypes.GetMajorityDamageType() != DamageType.Decay)
		{
			for (int i = 0; i < 12 - maxCratesToSpawn; i++)
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
				if (!Object.op_Implicit((Object)(object)baseEntity))
				{
					continue;
				}
				float num = 3f;
				float num2 = 10f;
				Vector3 onUnitSphere = Random.onUnitSphere;
				((Component)baseEntity).transform.position = ((Component)this).transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * Random.Range(-4f, 4f);
				Collider component = ((Component)baseEntity).GetComponent<Collider>();
				baseEntity.Spawn();
				baseEntity.SetVelocity(val + onUnitSphere * Random.Range(num, num2));
				foreach (ServerGib item in list)
				{
					Physics.IgnoreCollision(component, (Collider)(object)item.GetCollider(), true);
				}
			}
		}
		for (int j = 0; j < maxCratesToSpawn; j++)
		{
			Vector3 onUnitSphere2 = Random.onUnitSphere;
			Vector3 pos = ((Component)this).transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere2 * Random.Range(2f, 3f);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));
			baseEntity2.Spawn();
			LootContainer lootContainer = baseEntity2 as LootContainer;
			if (Object.op_Implicit((Object)(object)lootContainer))
			{
				((FacepunchBehaviour)lootContainer).Invoke((Action)lootContainer.RemoveMe, 1800f);
			}
			Collider component2 = ((Component)baseEntity2).GetComponent<Collider>();
			Rigidbody val2 = ((Component)baseEntity2).gameObject.AddComponent<Rigidbody>();
			val2.useGravity = true;
			val2.collisionDetectionMode = (CollisionDetectionMode)2;
			val2.mass = 2f;
			val2.interpolation = (RigidbodyInterpolation)1;
			val2.velocity = val + onUnitSphere2 * Random.Range(1f, 3f);
			val2.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
			val2.drag = 0.5f * (val2.mass / 5f);
			val2.angularDrag = 0.2f * (val2.mass / 5f);
			FireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;
			if (Object.op_Implicit((Object)(object)fireBall))
			{
				fireBall.SetParent(baseEntity2);
				fireBall.Spawn();
				((Component)fireBall).GetComponent<Rigidbody>().isKinematic = true;
				((Component)fireBall).GetComponent<Collider>().enabled = false;
			}
			((Component)baseEntity2).SendMessage("SetLockingEnt", (object)((Component)fireBall).gameObject, (SendMessageOptions)1);
			foreach (ServerGib item2 in list)
			{
				Physics.IgnoreCollision(component2, (Collider)(object)item2.GetCollider(), true);
			}
			Interface.CallHook("OnCrateSpawned", (object)this, (object)baseEntity2);
		}
		base.OnDied(info);
	}

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		base.OnEntityMessage(from, msg);
		if (msg == "RadarLock" && !((FacepunchBehaviour)this).IsInvoking((Action)DoFlare))
		{
			((FacepunchBehaviour)this).Invoke((Action)DoFlare, Random.Range(0.5f, 1f));
		}
	}

	public void DoFlare()
	{
		SetFlag(Flags.OnFire, b: true);
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		((FacepunchBehaviour)this).Invoke((Action)ClearFlares, flareDuration);
	}

	public void ClearFlares()
	{
		SetFlag(Flags.OnFire, b: false);
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	public void Update()
	{
		if (base.isServer && Time.realtimeSinceStartup - lastNetworkUpdate >= 0.25f)
		{
			SendNetworkUpdate();
			lastNetworkUpdate = Time.realtimeSinceStartup;
		}
	}

	public void InitalizeWeakspots()
	{
		weakspot[] array = weakspots;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].body = this;
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer)
		{
			myAI.WasAttacked(info);
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (Interface.CallHook("OnPatrolHelicopterTakeDamage", (object)this, (object)info) != null)
		{
			return;
		}
		bool flag = false;
		if (info.damageTypes.Total() >= base.health)
		{
			if (Interface.CallHook("OnPatrolHelicopterKill", (object)this, (object)info) != null)
			{
				return;
			}
			base.health = 10000f;
			myAI.CriticalDamage();
			flag = true;
		}
		base.Hurt(info);
		if (flag)
		{
			return;
		}
		myAI.OtherDamaged(info);
		weakspot[] array = weakspots;
		foreach (weakspot weakspot in array)
		{
			string[] bonenames = weakspot.bonenames;
			foreach (string str in bonenames)
			{
				if (info.HitBone == StringPool.Get(str))
				{
					weakspot.Hurt(info.damageTypes.Total(), info);
					myAI.WeakspotDamaged(weakspot, info);
				}
			}
		}
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			if (Global.developer > 2)
			{
				NetworkableId iD = net.ID;
				Debug.Log((object)("SyncVar Writing: FleeMarkerId for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite<NetworkableId>(writer, __sync_FleeMarkerId);
			return true;
		}
		return false;
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		return false;
	}

	private byte __GetWeaverID(string propertyName)
	{
		_ = propertyName == "FleeMarkerId";
		return 0;
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteSyncVar(0, val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		return true;
	}

	protected override void ResetSyncVars()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		__sync_FleeMarkerId = default(NetworkableId);
	}
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

[Serializable]
public class weakspot
{
	[NonSerialized]
	public PatrolHelicopter body;

	public string[] bonenames;

	public float maxHealth;

	public float health;

	public float healthFractionOnDestroyed = 0.5f;

	public GameObjectRef destroyedParticles;

	public GameObjectRef damagedParticles;

	public GameObject damagedEffect;

	public GameObject destroyedEffect;

	public List<BasePlayer> attackers;

	private bool isDestroyed;

	public float HealthFraction()
	{
		return health / maxHealth;
	}

	public void Hurt(float amount, HitInfo info)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (!isDestroyed)
		{
			health -= amount;
			Effect.server.Run(damagedParticles.resourcePath, body, StringPool.Get(bonenames[Random.Range(0, bonenames.Length)]), Vector3.zero, Vector3.up, null, broadcast: true);
			if (health <= 0f)
			{
				health = 0f;
				WeakspotDestroyed();
			}
		}
	}

	public void Heal(float amount)
	{
		health += amount;
	}

	public void WeakspotDestroyed()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		isDestroyed = true;
		Effect.server.Run(destroyedParticles.resourcePath, body, StringPool.Get(bonenames[Random.Range(0, bonenames.Length)]), Vector3.zero, Vector3.up, null, broadcast: true);
		body.Hurt(body.MaxHealth() * healthFractionOnDestroyed, DamageType.Generic, null, useProtection: false);
	}
}


using System;
using Network;
using Rust;
using UnityEngine;

public class PetBrain : BaseAIBrain
{
	[Header("Audio")]
	public SoundDefinition CommandGivenVocalSFX;

	[ServerVar]
	public static bool DrownInDeepWater = true;

	[ServerVar]
	public static bool IdleWhenOwnerOfflineOrDead = true;

	[ServerVar]
	public static bool IdleWhenOwnerMounted = true;

	[ServerVar]
	public static float DrownTimer = 15f;

	[ReplicatedVar]
	public static float ControlDistance = 100f;

	public static int Count;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PetBrain.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void AddStates()
	{
		base.AddStates();
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new HumanPathFinder();
		((HumanPathFinder)base.PathFinder).Init(GetBaseEntity());
		Count++;
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		Count--;
	}

	public override void Think(float delta)
	{
		base.Think(delta);
		if (DrownInDeepWater)
		{
			BaseCombatEntity baseCombatEntity = GetBaseEntity() as BaseCombatEntity;
			if ((Object)(object)baseCombatEntity != (Object)null && baseCombatEntity.WaterFactor() > 0.85f && !baseCombatEntity.IsDestroyed)
			{
				baseCombatEntity.Hurt(delta * (baseCombatEntity.MaxHealth() / DrownTimer), DamageType.Drowned);
			}
		}
		EvaluateLoadDefaultDesignTriggers();
	}

	private bool EvaluateLoadDefaultDesignTriggers()
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (loadedDesignIndex == 0)
		{
			return true;
		}
		bool flag = false;
		if (IdleWhenOwnerOfflineOrDead)
		{
			flag = (IdleWhenOwnerOfflineOrDead && (Object)(object)base.OwningPlayer == (Object)null) || base.OwningPlayer.IsSleeping() || base.OwningPlayer.IsDead();
		}
		if (IdleWhenOwnerMounted && !flag)
		{
			flag = (Object)(object)base.OwningPlayer != (Object)null && base.OwningPlayer.isMounted;
		}
		if ((Object)(object)base.OwningPlayer != (Object)null && Vector3.Distance(((Component)this).transform.position, ((Component)base.OwningPlayer).transform.position) > ControlDistance)
		{
			flag = true;
		}
		if (flag)
		{
			LoadDefaultAIDesign();
			return true;
		}
		return false;
	}

	public override void OnAIDesignLoadedAtIndex(int index)
	{
		base.OnAIDesignLoadedAtIndex(index);
		BaseEntity baseEntity = GetBaseEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(baseEntity.OwnerID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.SendClientPetStateIndex();
			}
			baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnCommandGiven"));
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class PhotoFrame : StorageContainer, ILOD, IImageReceiver, ISignage, IUGCBrowserEntity
{
	private const float TextureRequestDistance = 100f;

	public EntityRef _photoEntity;

	public uint _overlayTextureCrc;

	private List<ulong> editHistory = new List<ulong>();

	public GameObjectRef SignEditorDialog;

	public OverlayMeshPaintableSource PaintableSource;

	public NetworkableId NetworkID => net.ID;

	public FileStorage.Type FileType => FileStorage.Type.png;

	public UGCType ContentType => UGCType.ImagePng;

	public List<ulong> EditingHistory => editHistory;

	public uint[] GetContentCRCs => new uint[1] { _overlayTextureCrc };

	public override bool ShouldTransferAssociatedFiles => true;

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public Vector2i TextureSize => new Vector2i(PaintableSource.texWidth, PaintableSource.texHeight);

	public int TextureCount => 1;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PhotoFrame.OnRpcMessage", 0);
		try
		{
			if (rpc == 1455609404 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - LockSign "));
				}
				TimeWarning val2 = TimeWarning.New("LockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455609404u, "LockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							LockSign(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in LockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4149904254u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UnLockSign "));
				}
				TimeWarning val2 = TimeWarning.New("UnLockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4149904254u, "UnLockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							UnLockSign(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UnLockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1255380462 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateSign "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1255380462u, "UpdateSign", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1255380462u, "UpdateSign", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							UpdateSign(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in UpdateSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.photoFrame != null)
		{
			_photoEntity.uid = info.msg.photoFrame.photoEntityId;
			_overlayTextureCrc = info.msg.photoFrame.overlayImageCrc;
		}
		if (!base.isServer || info.msg.photoFrame == null)
		{
			return;
		}
		if (info.msg.photoFrame.editHistory != null)
		{
			if (editHistory == null)
			{
				editHistory = Pool.Get<List<ulong>>();
			}
			editHistory.Clear();
			{
				foreach (ulong item in info.msg.photoFrame.editHistory)
				{
					editHistory.Add(item);
				}
				return;
			}
		}
		if (editHistory != null)
		{
			Pool.FreeUnmanaged<ulong>(ref editHistory);
		}
	}

	public uint[] GetTextureCRCs()
	{
		return new uint[1] { _overlayTextureCrc };
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.photoFrame = Pool.Get<PhotoFrame>();
		info.msg.photoFrame.photoEntityId = _photoEntity.uid;
		info.msg.photoFrame.overlayImageCrc = _overlayTextureCrc;
		if (editHistory.Count <= 0)
		{
			return;
		}
		info.msg.photoFrame.editHistory = Pool.Get<List<ulong>>();
		foreach (ulong item in editHistory)
		{
			info.msg.photoFrame.editHistory.Add(item);
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		base.OnItemAddedOrRemoved(item, added);
		Item item2 = ((base.inventory.itemList.Count > 0) ? base.inventory.itemList[0] : null);
		NetworkableId val = (NetworkableId)((item2 != null && item2.IsValid()) ? item2.instanceData.subEntity : default(NetworkableId));
		if (val != _photoEntity.uid)
		{
			_photoEntity.uid = val;
			SendNetworkUpdate();
		}
	}

	public override void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
	{
		base.OnPickedUpPreItemMove(createdItem, player);
		ItemModSign itemModSign = default(ItemModSign);
		if (_overlayTextureCrc != 0 && ((Component)createdItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			itemModSign.OnSignPickedUp(this, this, createdItem);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		ItemModSign itemModSign = default(ItemModSign);
		if (((Component)fromItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			SignContent associatedEntity = ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(fromItem);
			if ((Object)(object)associatedEntity != (Object)null)
			{
				associatedEntity.CopyInfoToSign(this, this);
			}
		}
	}

	public void SetTextureCRCs(uint[] crcs)
	{
		if (crcs.Length != 0)
		{
			_overlayTextureCrc = crcs[0];
			SendNetworkUpdate();
		}
	}

	private void LogEdit(BasePlayer byPlayer)
	{
		if (!editHistory.Contains(byPlayer.userID))
		{
			editHistory.Insert(0, byPlayer.userID);
			int num = 0;
			while (editHistory.Count > 5 && num < 10)
			{
				editHistory.RemoveAt(5);
				num++;
			}
		}
	}

	public void ClearContent()
	{
		_overlayTextureCrc = 0u;
		SendNetworkUpdate();
	}

	public override bool CanPickup(BasePlayer player)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (base.CanPickup(player))
		{
			NetworkableId uid = _photoEntity.uid;
			return !((NetworkableId)(ref uid)).IsValid;
		}
		return false;
	}

	public bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

	public bool CanUnlockSign(BasePlayer player)
	{
		if (!IsLocked())
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	public bool CanLockSign(BasePlayer player)
	{
		if (IsLocked())
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	[RPC_Server.MaxDistance(5f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public void UpdateSign(RPCMessage msg)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)msg.player == (Object)null) && CanUpdateSign(msg.player))
		{
			byte[] array = msg.read.BytesWithSize(10485760u, false);
			if (array != null && ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				FileStorage.server.RemoveAllByEntity(net.ID);
				_overlayTextureCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
				LogEdit(msg.player);
				SendNetworkUpdate();
				Interface.CallHook("OnSignUpdated", (object)this, (object)msg.player);
			}
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", (object)this, (object)msg.player);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void UnLockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUnlockSign(msg.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (net != null)
		{
			FileStorage.server.RemoveAllByEntity(net.ID);
		}
		_overlayTextureCrc = 0u;
		base.OnDied(info);
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public override string Categorize()
	{
		return "sign";
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Planner : HeldEntity
{
	public struct CanBuildResult
	{
		public bool Result;

		public Phrase Phrase;

		public string[] Arguments;
	}

	public BaseEntity[] buildableList;

	public virtual bool isTypeDeployable => (Object)(object)GetModDeployable() != (Object)null;

	public Vector3 serverStartDurationPlacementPosition { get; private set; }

	public TimeSince serverStartDurationPlacementTime { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Planner.OnRpcMessage", 0);
		try
		{
			if (rpc == 1872774636 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoPlace "));
				}
				TimeWarning val2 = TimeWarning.New("DoPlace", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1872774636u, "DoPlace", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoPlace(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoPlace");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3892284151u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartDurationPlace "));
				}
				TimeWarning val2 = TimeWarning.New("StartDurationPlace", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3892284151u, "StartDurationPlace", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(3892284151u, "StartDurationPlace", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							StartDurationPlace(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in StartDurationPlace");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public ItemModDeployable GetModDeployable()
	{
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		if ((Object)(object)ownerItemDefinition == (Object)null)
		{
			return null;
		}
		return ((Component)ownerItemDefinition).GetComponent<ItemModDeployable>();
	}

	public virtual Deployable GetDeployable()
	{
		ItemModDeployable modDeployable = GetModDeployable();
		if ((Object)(object)modDeployable == (Object)null)
		{
			return null;
		}
		return modDeployable.GetDeployable(this);
	}

	public virtual Deployable GetDeployable(NetworkableId entityId)
	{
		return GetDeployable();
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void DoPlace(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		CreateBuilding val = msg.read.Proto<CreateBuilding>((CreateBuilding)null);
		try
		{
			DoBuild(val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(10uL)]
	private void StartDurationPlace(RPCMessage msg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (Object.op_Implicit((Object)(object)ownerPlayer))
		{
			serverStartDurationPlacementPosition = ((Component)ownerPlayer).transform.position;
			serverStartDurationPlacementTime = TimeSince.op_Implicit(0f);
		}
	}

	public Socket_Base FindSocket(string name, uint prefabIDToFind)
	{
		return PrefabAttribute.server.FindAll<Socket_Base>(prefabIDToFind).FirstOrDefault((Socket_Base s) => s.socketName == name);
	}

	public virtual void DoBuild(CreateBuilding msg)
	{
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return;
		}
		if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredMovementAntiHack())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.AntihackWithReason, false, ownerPlayer.lastViolationType.ToString());
			return;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);
		if (construction == null)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindConstruction, false);
			ConstructionErrors.Log(ownerPlayer, msg.blockID.ToString());
			return;
		}
		if (!CanAffordToPlace(construction))
		{
			ItemAmountList val = Pool.Get<ItemAmountList>();
			try
			{
				val.amount = Pool.Get<List<float>>();
				val.itemID = Pool.Get<List<int>>();
				GetConstructionCost(val, construction);
				ownerPlayer.ClientRPC(RpcTarget.Player("Client_OnRepairFailedResources", ownerPlayer), val);
				return;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
			return;
		}
		Deployable deployable = GetDeployable(msg.entity);
		if (construction.deployable != deployable)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.DeployableMismatch, false);
			return;
		}
		Construction.Target target = default(Construction.Target);
		if (((NetworkableId)(ref msg.entity)).IsValid)
		{
			target.entity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;
			if ((Object)(object)target.entity == (Object)null)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindEntity, false);
				ConstructionErrors.Log(ownerPlayer, ((object)(NetworkableId)(ref msg.entity)/*cast due to .constrained prefix*/).ToString());
				return;
			}
			msg.ray = new Ray(((Component)target.entity).transform.TransformPoint(((Ray)(ref msg.ray)).origin), ((Component)target.entity).transform.TransformDirection(((Ray)(ref msg.ray)).direction));
			msg.position = ((Component)target.entity).transform.TransformPoint(msg.position);
			msg.normal = ((Component)target.entity).transform.TransformDirection(msg.normal);
			msg.rotation = ((Component)target.entity).transform.rotation * msg.rotation;
			if (msg.socket != 0)
			{
				string text = StringPool.Get(msg.socket);
				if (text != "")
				{
					target.socket = FindSocket(text, target.entity.prefabID);
				}
				if (target.socket == null)
				{
					ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindSocket, false);
					ConstructionErrors.Log(ownerPlayer, msg.socket.ToString());
					return;
				}
			}
			else if (target.entity is Door)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantDeployOnDoor, false);
				return;
			}
		}
		target.ray = msg.ray;
		target.onTerrain = msg.onterrain;
		target.position = msg.position;
		target.normal = msg.normal;
		target.rotation = msg.rotation;
		target.player = ownerPlayer;
		target.isHoldingShift = msg.isHoldingShift;
		target.valid = true;
		if (Interface.CallHook("CanBuild", (object)this, (object)construction, (object)target) != null)
		{
			return;
		}
		if (ShouldParent(target.entity, deployable))
		{
			Vector3 position = ((target.socket != null) ? target.GetWorldPosition() : target.position);
			float num = target.entity.Distance(position);
			if (num > 1f)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.ParentTooFar, false);
				ConstructionErrors.Log(ownerPlayer, num.ToString());
				return;
			}
		}
		BaseEntity baseEntity = DoBuild(target, construction);
		if ((Object)(object)baseEntity != (Object)null && baseEntity is BuildingBlock buildingBlock && ownerPlayer.IsInCreativeMode && Creative.freeBuild)
		{
			ConstructionGrade constructionGrade = construction.grades[msg.setToGrade];
			if (buildingBlock.currentGrade != constructionGrade)
			{
				buildingBlock.ChangeGradeAndSkin(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
			}
		}
		if ((Object)(object)baseEntity != (Object)null && baseEntity is DecayEntity decayEntity)
		{
			decayEntity.timePlaced = GetNetworkTime();
		}
	}

	public virtual BaseEntity DoBuild(Construction.Target target, Construction component)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_038b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return null;
		}
		if (target.ray.IsNaNOrInfinity())
		{
			return null;
		}
		if (Vector3Ex.IsNaNOrInfinity(target.position))
		{
			return null;
		}
		if (Vector3Ex.IsNaNOrInfinity(target.normal))
		{
			return null;
		}
		Construction.lastPlacementError = Phrase.op_Implicit("");
		Construction.lastPlacementErrorDebug = "";
		Construction.lastBuildingBlockError = null;
		Construction.lastPlacementErrorIsDetailed = false;
		if (target.socket != null)
		{
			if (!target.socket.female)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.SocketNotFemale, false);
				Construction.lastPlacementErrorDebug = target.socket.socketName;
				return null;
			}
			if ((Object)(object)target.entity != (Object)null && target.entity.IsOccupied(target.socket))
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.SocketOccupied, false);
				Construction.lastPlacementErrorDebug = target.socket.socketName;
				return null;
			}
			if (target.onTerrain)
			{
				Construction.lastPlacementErrorDebug = "Target on terrain is not allowed when attaching to socket (" + target.socket.socketName + ")";
				return null;
			}
		}
		Vector3 deployPos = (((Object)(object)target.entity != (Object)null && target.socket != null) ? target.GetWorldPosition() : target.position);
		if (AntiHack.TestIsBuildingInsideSomething(target, deployPos))
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.InsideObjects, false);
			return null;
		}
		if (ConVar.AntiHack.eye_protection >= 2 && !component.HasAlternativeLOSChecks() && !HasLineOfSight(ownerPlayer, deployPos, target, component))
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.LineOfSightBlocked, false);
			return null;
		}
		if (Server.max_sleeping_bags > 0)
		{
			CanBuildResult? result = SleepingBag.CanBuildBed(ownerPlayer, component);
			if (HandleCanBuild(result, ownerPlayer))
			{
				return null;
			}
		}
		GameObject val = DoPlacement(target, component);
		if ((Object)(object)val == (Object)null)
		{
			if (!string.IsNullOrEmpty(Construction.lastPlacementError.translated))
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, Construction.lastPlacementError, false);
			}
			ConstructionErrors.Log(ownerPlayer, Construction.lastPlacementErrorDebug);
		}
		if ((Object)(object)val != (Object)null)
		{
			Interface.CallHook("OnEntityBuilt", (object)this, (object)val);
			Deployable deployable = GetDeployable();
			BaseEntity baseEntity = val.ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null && deployable != null)
			{
				if (ShouldParent(target.entity, deployable))
				{
					if (target.socket is Socket_Specific_Female socket_Specific_Female)
					{
						if (socket_Specific_Female.parentToBone)
						{
							baseEntity.SetParent(target.entity, socket_Specific_Female.boneName, worldPositionStays: true);
						}
						else
						{
							baseEntity.SetParent(target.entity, worldPositionStays: true);
						}
					}
					else
					{
						baseEntity.SetParent(target.entity, worldPositionStays: true);
					}
				}
				if (deployable.wantsInstanceData && GetOwnerItem().instanceData != null)
				{
					(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);
				}
				if (deployable.copyInventoryFromItem)
				{
					StorageContainer component2 = ((Component)baseEntity).GetComponent<StorageContainer>();
					if (Object.op_Implicit((Object)(object)component2))
					{
						component2.ReceiveInventoryFromItem(GetOwnerItem());
					}
				}
				ItemModDeployable modDeployable = GetModDeployable();
				if ((Object)(object)modDeployable != (Object)null)
				{
					modDeployable.OnDeployed(baseEntity, ownerPlayer);
				}
				baseEntity.OnDeployed(baseEntity.GetParentEntity(), ownerPlayer, GetOwnerItem());
				if (deployable.placeEffect.isValid)
				{
					if (Object.op_Implicit((Object)(object)target.entity) && target.socket != null)
					{
						Effect.server.Run(deployable.placeEffect.resourcePath, ((Component)target.entity).transform.TransformPoint(target.socket.worldPosition), ((Component)target.entity).transform.up);
					}
					else
					{
						Effect.server.Run(deployable.placeEffect.resourcePath, target.position, target.normal);
					}
				}
			}
			if ((Object)(object)baseEntity != (Object)null)
			{
				Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);
				if ((Object)(object)GetOwnerItemDefinition() != (Object)null)
				{
					ownerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload
					{
						WorldPosition = ((Component)baseEntity).transform.position,
						UintIdentifier = baseEntity.prefabID,
						IntIdentifier = GetOwnerItemDefinition().itemid
					}, 1f);
				}
			}
			PayForPlacement(ownerPlayer, component);
			return baseEntity;
		}
		return null;
	}

	public GameObject DoPlacement(Construction.Target placement, Construction component)
	{
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return null;
		}
		BaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);
		if (!Object.op_Implicit((Object)(object)baseEntity))
		{
			return null;
		}
		float num = 1f;
		float num2 = 0f;
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			baseEntity.skinID = ownerItem.skin;
			if (ownerItem.hasCondition)
			{
				num = ownerItem.conditionNormalized;
			}
		}
		((Component)baseEntity).gameObject.AwakeFromInstantiate();
		BuildingBlock buildingBlock = baseEntity as BuildingBlock;
		if (Object.op_Implicit((Object)(object)buildingBlock))
		{
			buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
			if (!buildingBlock.blockDefinition)
			{
				Debug.LogError((object)"Placing a building block that has no block definition!");
				return null;
			}
			buildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);
		}
		BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
		if (Object.op_Implicit((Object)(object)baseCombatEntity))
		{
			num2 = (((Object)(object)buildingBlock != (Object)null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);
			baseCombatEntity.ResetLifeStateOnSpawn = false;
			baseCombatEntity.InitializeHealth(num2 * num, baseCombatEntity.StartMaxHealth());
		}
		if (Interface.CallHook("OnConstructionPlace", (object)baseEntity, (object)component, (object)placement, (object)ownerPlayer) != null)
		{
			if (baseEntity.IsValid())
			{
				baseEntity.KillMessage();
			}
			else
			{
				DecayEntity decayEntity = baseEntity as DecayEntity;
				if (Object.op_Implicit((Object)(object)decayEntity))
				{
					decayEntity.DoServerDestroy();
				}
				baseEntity.TerminateOnServer();
				baseEntity.EntityDestroy();
			}
			return null;
		}
		baseEntity.OnPlaced(ownerPlayer);
		baseEntity.OwnerID = ownerPlayer.userID;
		baseEntity.Spawn();
		if (Object.op_Implicit((Object)(object)buildingBlock))
		{
			Effect.server.Run("assets/bundled/prefabs/fx/build/frame_place.prefab", baseEntity, 0u, Vector3.zero, Vector3.zero);
		}
		StabilityEntity stabilityEntity = baseEntity as StabilityEntity;
		if (Object.op_Implicit((Object)(object)stabilityEntity))
		{
			stabilityEntity.UpdateSurroundingEntities();
		}
		return ((Component)baseEntity).gameObject;
	}

	public virtual void PayForPlacement(BasePlayer player, Construction component)
	{
		if (Interface.CallHook("OnPayForPlacement", (object)player, (object)this, (object)component) != null || (player.IsInCreativeMode && Creative.freeBuild))
		{
			return;
		}
		if (player.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = player.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.OnPlayerBuiltConstruction(player);
			}
		}
		if (isTypeDeployable)
		{
			GetItem().UseItem();
			return;
		}
		List<Item> list = Pool.Get<List<Item>>();
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			player.inventory.Take(list, item.itemDef.itemid, (int)item.amount);
			player.Command("note.inv", item.itemDef.itemid, item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
		Pool.Free<Item>(ref list, false);
	}

	public virtual bool CanAffordToPlace(Construction component)
	{
		if (isTypeDeployable)
		{
			return true;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAffordToPlace", (object)ownerPlayer, (object)this, (object)component);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ownerPlayer.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			if ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

	protected virtual void GetConstructionCost(ItemAmountList list, Construction component)
	{
		list.amount.Clear();
		list.itemID.Clear();
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			list.itemID.Add(item.itemDef.itemid);
			list.amount.Add((int)item.amount);
		}
	}

	private bool ShouldParent(BaseEntity targetEntity, Deployable deployable)
	{
		if ((Object)(object)targetEntity != (Object)null && targetEntity.SupportsChildDeployables() && (targetEntity.ForceDeployableSetParent() || (deployable != null && deployable.setSocketParent)))
		{
			return true;
		}
		return false;
	}

	private bool HandleCanBuild(CanBuildResult? result, BasePlayer player)
	{
		if (result.HasValue)
		{
			if (result.Value.Phrase != null && !player.IsInTutorial)
			{
				player.ShowToast((!result.Value.Result) ? GameTip.Styles.Red_Normal : GameTip.Styles.Blue_Long, result.Value.Phrase, overlay: false, result.Value.Arguments);
			}
			if (!result.Value.Result)
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool HasLineOfSight(BasePlayer player, Vector3 deployPos, Construction.Target target, Construction component)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 center = player.eyes.center;
		Vector3 position = player.eyes.position;
		Vector3 origin = ((Ray)(ref target.ray)).origin;
		Vector3 val = deployPos;
		int num = 2097152;
		int num2 = 2162688;
		if (ConVar.AntiHack.build_terraincheck)
		{
			num2 |= 0x800000;
		}
		if (ConVar.AntiHack.build_vehiclecheck)
		{
			num2 |= 0x8000000;
		}
		float num3 = ConVar.AntiHack.build_losradius;
		float padding = ConVar.AntiHack.build_losradius + 0.01f;
		int layerMask = num2;
		if (target.socket != null)
		{
			num3 = 0f;
			padding = 0.5f;
			layerMask = num;
		}
		if (component.isSleepingBag)
		{
			num3 = ConVar.AntiHack.build_losradius_sleepingbag;
			padding = ConVar.AntiHack.build_losradius_sleepingbag + 0.01f;
			layerMask = num2;
		}
		if (num3 > 0f)
		{
			val += ((Vector3)(ref target.normal)).normalized * num3;
		}
		if ((Object)(object)target.entity != (Object)null)
		{
			DeployShell deployShell = PrefabAttribute.server.Find<DeployShell>(target.entity.prefabID);
			if (deployShell != null)
			{
				val += ((Vector3)(ref target.normal)).normalized * deployShell.LineOfSightPadding();
			}
		}
		if (GamePhysics.LineOfSightRadius(center, position, layerMask, num3) && GamePhysics.LineOfSightRadius(position, origin, layerMask, num3))
		{
			return GamePhysics.LineOfSightRadius(origin, val, layerMask, num3, 0f, padding);
		}
		return false;
	}

	public static bool HasLineOfSight(ref Construction.Placement placement, Construction construction, Construction.Target target)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = target.player;
		Vector3 center = player.eyes.center;
		Vector3 position = player.eyes.position;
		Vector3 origin = ((Ray)(ref target.ray)).origin;
		Vector3 val = (((Object)(object)target.entity != (Object)null && target.socket != null) ? target.GetWorldPosition() : target.position);
		int num = 2097152;
		int num2 = 2162688;
		if (ConVar.AntiHack.build_terraincheck)
		{
			num2 |= 0x800000;
		}
		if (ConVar.AntiHack.build_vehiclecheck)
		{
			num2 |= 0x8000000;
		}
		float num3 = ConVar.AntiHack.build_losradius;
		float padding = ConVar.AntiHack.build_losradius + 0.01f;
		int num4 = num2;
		if (target.socket != null)
		{
			num3 = 0f;
			padding = 0.5f;
			num4 = num;
		}
		if (construction.isSleepingBag)
		{
			num3 = ConVar.AntiHack.build_losradius_sleepingbag;
			padding = ConVar.AntiHack.build_losradius_sleepingbag + 0.01f;
			num4 = num2;
		}
		if (num3 > 0f)
		{
			val += ((Vector3)(ref target.normal)).normalized * num3;
		}
		if ((Object)(object)target.entity != (Object)null)
		{
			DeployShell deployShell = PrefabAttribute.server.Find<DeployShell>(target.entity.prefabID);
			if (deployShell != null)
			{
				val += ((Vector3)(ref target.normal)).normalized * deployShell.LineOfSightPadding();
			}
		}
		if (!GamePhysics.LineOfSightRadius(center, position, num4, num3) || !GamePhysics.LineOfSightRadius(position, origin, num4, num3))
		{
			return false;
		}
		bool flag = GamePhysics.LineOfSightRadius(origin, val, num4, num3, 0f, padding);
		if (!flag && target.socket != null && construction.HasAlternativeLOSChecks())
		{
			Vector3[] alternativeLOSPositions = construction.alternativeLOSPositions;
			foreach (Vector3 val2 in alternativeLOSPositions)
			{
				Vector3 val3 = placement.position + placement.rotation * val2 - origin;
				if (!Physics.Raycast(origin, val3, ((Vector3)(ref val3)).magnitude, num4))
				{
					return true;
				}
			}
		}
		return flag;
	}
}


public struct CanBuildResult
{
	public bool Result;

	public Phrase Phrase;

	public string[] Arguments;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class PlanterBox : StorageContainer, ISplashable
{
	public bool PlantPot;

	public int soilSaturation;

	public int soilSaturationMax = 8000;

	public MeshRenderer soilRenderer;

	[ServerVar]
	public static float outsideTestDistance = 100f;

	private static readonly float MinimumSaturationTriggerLevel = ConVar.Server.optimalPlanterQualitySaturation - 0.2f;

	private static readonly float MaximumSaturationTriggerLevel = ConVar.Server.optimalPlanterQualitySaturation + 0.1f;

	public TimeCachedValue<float> sunExposure;

	public TimeCachedValue<float> artificialLightExposure;

	public TimeCachedValue<float> plantTemperature;

	public TimeCachedValue<float> plantArtificalTemperature;

	private TimeSince lastSplashNetworkUpdate;

	private TimeSince lastRainCheck;

	public float soilSaturationFraction => (float)soilSaturation / (float)soilSaturationMax;

	public int availableIdealWaterCapacity => Mathf.Max(availableIdealWaterCapacity, Mathf.Max(idealSaturation - soilSaturation, 0));

	public int availableWaterCapacity => soilSaturationMax - soilSaturation;

	public int idealSaturation => Mathf.FloorToInt((float)soilSaturationMax * ConVar.Server.optimalPlanterQualitySaturation);

	public bool BelowMinimumSaturationTriggerLevel => soilSaturationFraction < MinimumSaturationTriggerLevel;

	public bool AboveMaximumSaturationTriggerLevel => soilSaturationFraction > MaximumSaturationTriggerLevel;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlanterBox.OnRpcMessage", 0);
		try
		{
			if (rpc == 2965786167u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestSaturationUpdate "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestSaturationUpdate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2965786167u, "RPC_RequestSaturationUpdate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_RequestSaturationUpdate(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_RequestSaturationUpdate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
		base.inventory.SetOnlyAllowedItem(allowedItem);
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(InventoryItemFilter));
		SetupTimeCaches();
	}

	public virtual void SetupTimeCaches()
	{
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		sunExposure = new TimeCachedValue<float>
		{
			refreshCooldown = 30f,
			refreshRandomRange = 5f,
			updateValue = CalculateSunExposure
		};
		artificialLightExposure = new TimeCachedValue<float>
		{
			refreshCooldown = 60f,
			refreshRandomRange = 5f,
			updateValue = CalculateArtificialLightExposure
		};
		plantTemperature = new TimeCachedValue<float>
		{
			refreshCooldown = 20f,
			refreshRandomRange = 5f,
			updateValue = CalculatePlantTemperature
		};
		plantArtificalTemperature = new TimeCachedValue<float>
		{
			refreshCooldown = 60f,
			refreshRandomRange = 5f,
			updateValue = CalculateArtificialTemperature
		};
		lastRainCheck = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)CalculateRainFactor, 20f, 30f, 15f);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (added && ItemIsFertilizer(item))
		{
			FertilizeGrowables();
		}
	}

	public bool InventoryItemFilter(Item item, int targetSlot)
	{
		if (item == null)
		{
			return false;
		}
		if (ItemIsFertilizer(item))
		{
			return true;
		}
		return false;
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (base.CanPickup(player))
		{
			return !HasPlants();
		}
		return false;
	}

	private bool ItemIsFertilizer(Item item)
	{
		return item.info.shortname == "fertilizer";
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.resource = Pool.Get<BaseResource>();
		info.msg.resource.stage = soilSaturation;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.resource != null)
		{
			soilSaturation = info.msg.resource.stage;
		}
	}

	public void FertilizeGrowables()
	{
		if (Interface.CallHook("OnPlanterBoxFertilize", (object)this) != null)
		{
			return;
		}
		int num = GetFertilizerCount();
		if (num <= 0)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			if ((Object)(object)child == (Object)null)
			{
				continue;
			}
			GrowableEntity growableEntity = child as GrowableEntity;
			if (!((Object)(object)growableEntity == (Object)null) && !growableEntity.Fertilized && ConsumeFertilizer())
			{
				growableEntity.Fertilize();
				num--;
				if (num == 0)
				{
					break;
				}
			}
		}
	}

	public int GetFertilizerCount()
	{
		int num = 0;
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null && ItemIsFertilizer(slot))
			{
				num += slot.amount;
			}
		}
		return num;
	}

	public bool ConsumeFertilizer()
	{
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null && ItemIsFertilizer(slot))
			{
				int num = Mathf.Min(1, slot.amount);
				if (num > 0)
				{
					slot.UseItem(num);
					return true;
				}
			}
		}
		return false;
	}

	public int ConsumeWater(int amount, GrowableEntity ignoreEntity = null)
	{
		int num = Mathf.Min(amount, soilSaturation);
		soilSaturation -= num;
		RefreshGrowables(ignoreEntity);
		SendNetworkUpdate();
		return num;
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (base.IsDestroyed)
		{
			return false;
		}
		if ((Object)(object)splashType == (Object)null || splashType.shortname == null)
		{
			return false;
		}
		if (!((Object)(object)splashType == (Object)(object)WaterTypes.SaltWaterItemDef) && !((Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef))
		{
			return soilSaturation < soilSaturationMax;
		}
		return true;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)splashType == (Object)(object)WaterTypes.SaltWaterItemDef)
		{
			soilSaturation = 0;
			RefreshGrowables();
			if (TimeSince.op_Implicit(lastSplashNetworkUpdate) > 60f)
			{
				SendNetworkUpdate();
				lastSplashNetworkUpdate = TimeSince.op_Implicit(0f);
			}
			return amount;
		}
		if ((Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef)
		{
			soilSaturation = 0;
			KillAllPlants();
			if (TimeSince.op_Implicit(lastSplashNetworkUpdate) > 60f)
			{
				SendNetworkUpdate();
				lastSplashNetworkUpdate = TimeSince.op_Implicit(0f);
			}
			return amount;
		}
		int num = Mathf.Min(availableWaterCapacity, amount);
		soilSaturation += num;
		RefreshGrowables();
		if (TimeSince.op_Implicit(lastSplashNetworkUpdate) > 60f)
		{
			SendNetworkUpdate();
			lastSplashNetworkUpdate = TimeSince.op_Implicit(0f);
		}
		return num;
	}

	private void KillAllPlants()
	{
		if (children == null)
		{
			return;
		}
		for (int num = children.Count - 1; num >= 0; num--)
		{
			BaseEntity baseEntity = children[num];
			if (!((Object)(object)baseEntity == (Object)null) && baseEntity is GrowableEntity growableEntity)
			{
				growableEntity.ForceRemove();
			}
		}
	}

	public virtual void RefreshGrowables(GrowableEntity ignoreEntity = null)
	{
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			if (!((Object)(object)child == (Object)null) && !((Object)(object)child == (Object)(object)ignoreEntity) && child is GrowableEntity growableEntity)
			{
				growableEntity.QueueForQualityUpdate();
			}
		}
	}

	public void ForceLightUpdate()
	{
		sunExposure?.ForceNextRun();
		artificialLightExposure?.ForceNextRun();
	}

	public void ForceTemperatureUpdate()
	{
		plantArtificalTemperature?.ForceNextRun();
	}

	public float GetSunExposure()
	{
		return sunExposure?.Get(force: false) ?? 0f;
	}

	public float CalculateSunExposure()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return GrowableEntity.SunRaycast(((Component)this).transform.position + new Vector3(0f, 1f, 0f));
	}

	public float GetArtificialLightExposure()
	{
		return artificialLightExposure?.Get(force: false) ?? 0f;
	}

	public float CalculateArtificialLightExposure()
	{
		return GrowableEntity.CalculateArtificialLightExposure(((Component)this).transform);
	}

	public float GetPlantTemperature()
	{
		return (plantTemperature?.Get(force: false) ?? 0f) + (plantArtificalTemperature?.Get(force: false) ?? 0f);
	}

	public float CalculatePlantTemperature()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Max(Climate.GetTemperature(((Component)this).transform.position), 15f);
	}

	private bool HasPlants()
	{
		foreach (BaseEntity child in children)
		{
			if (child is GrowableEntity)
			{
				return true;
			}
		}
		return false;
	}

	public void CalculateRainFactor()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		float rain = Climate.GetRain(((Component)this).transform.position);
		if (rain > 0f && WaterCatcher.TestIsOutside(((Component)this).transform, Vector3.up, 0.5f, outsideTestDistance))
		{
			soilSaturation = Mathf.Clamp(soilSaturation + Mathf.RoundToInt(4f * rain * TimeSince.op_Implicit(lastRainCheck)), 0, soilSaturationMax);
			RefreshGrowables();
			SendNetworkUpdate();
		}
		lastRainCheck = TimeSince.op_Implicit(0f);
	}

	public float CalculateArtificialTemperature()
	{
		return GrowableEntity.CalculateArtificialTemperature(((Component)this).transform);
	}

	public virtual void OnPlantRemoved(GrowableEntity entity, BasePlayer byPlayer)
	{
	}

	public void OnPlantInserted(GrowableEntity entity, BasePlayer byPlayer)
	{
		if (!GameInfo.HasAchievements)
		{
			return;
		}
		List<uint> list = Pool.Get<List<uint>>();
		foreach (BaseEntity child in children)
		{
			if (child is GrowableEntity growableEntity && !list.Contains(growableEntity.prefabID))
			{
				list.Add(growableEntity.prefabID);
			}
		}
		if (list.Count == 9)
		{
			byPlayer.GiveAchievement("HONEST_WORK");
		}
		Pool.FreeUnmanaged<uint>(ref list);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_RequestSaturationUpdate(RPCMessage msg)
	{
		if ((Object)(object)msg.player != (Object)null)
		{
			ClientRPC(RpcTarget.Player("RPC_ReceiveSaturationUpdate", msg.player), soilSaturation);
		}
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class PlayerHelicopter : BaseHelicopter, IEngineControllerUser, IEntity, SamSite.ISamSiteTarget
{
	[Serializable]
	public class Wheel
	{
		public WheelCollider wheelCollider;

		public Transform visualBone;

		public Flags groundedFlag = Flags.Reserved1;

		[NonSerialized]
		public float wheelVel;

		[NonSerialized]
		public Vector3 wheelRot = Vector3.zero;

		public bool steering;

		public bool IsGrounded(PlayerHelicopter parent)
		{
			if (parent.isServer)
			{
				return wheelCollider.isGrounded;
			}
			return parent.HasFlag(groundedFlag);
		}
	}

	[Header("Player Helicopter")]
	[SerializeField]
	public Wheel[] wheels;

	[SerializeField]
	public Transform waterSample;

	public PlayerHeliSounds playerHeliSounds;

	[SerializeField]
	private Transform joystickPositionLeft;

	[SerializeField]
	private Transform joystickPositionRight;

	[SerializeField]
	private Transform passengerJoystickPositionRight;

	[SerializeField]
	private Transform leftFootPosition;

	[SerializeField]
	private Transform rightFootPosition;

	[SerializeField]
	protected Animator animator;

	[SerializeField]
	public float maxRotorSpeed = 10f;

	[SerializeField]
	public float timeUntilMaxRotorSpeed = 7f;

	[SerializeField]
	private Transform mainRotorBlurBone;

	[SerializeField]
	private Renderer mainRotorBlurMesh;

	[SerializeField]
	public float rotorBlurThreshold = 8f;

	[SerializeField]
	private Transform mainRotorBladesBone;

	[SerializeField]
	private Renderer[] mainRotorBladeMeshes;

	[SerializeField]
	private Transform rearRotorBladesBone;

	[SerializeField]
	private Renderer[] rearRotorBladeMeshes;

	[SerializeField]
	private Transform rearRotorBlurBone;

	[SerializeField]
	private Renderer rearRotorBlurMesh;

	[SerializeField]
	public float motorForceConstant = 150f;

	[SerializeField]
	public float brakeForceConstant = 500f;

	[SerializeField]
	public float maxPitchAnim = 1f;

	[SerializeField]
	private GameObject preventBuildingObject;

	[SerializeField]
	public float maxRollAnim = 1f;

	[SerializeField]
	public float maxYawAnim = 1f;

	[Header("Fuel")]
	[SerializeField]
	public GameObjectRef fuelStoragePrefab;

	[SerializeField]
	public float fuelPerSec = 0.25f;

	[SerializeField]
	public float fuelGaugeMax = 100f;

	[ServerVar(Help = "How long before a player helicopter loses all its health while outside")]
	public static float outsidedecayminutes = 480f;

	[ServerVar(Help = "How long before a player helicopter loses all its health while indoors")]
	public static float insidedecayminutes = 2880f;

	public VehicleEngineController<PlayerHelicopter> engineController;

	public TimeSince timeSinceCachedFuelFraction;

	public float cachedFuelFraction;

	protected const Flags WHEEL_GROUNDED_LR = Flags.Reserved1;

	protected const Flags WHEEL_GROUNDED_RR = Flags.Reserved2;

	protected const Flags WHEEL_GROUNDED_FRONT = Flags.Reserved3;

	protected const Flags RADAR_WARNING_FLAG = Flags.Reserved12;

	protected const Flags RADAR_LOCK_FLAG = Flags.Reserved13;

	protected const Flags ENGINE_STARTING_FLAG = Flags.Reserved4;

	public bool isPushing;

	private float[] recentVelocities = new float[10];

	private int recentVelIndex;

	private bool cacheGrounded;

	public float lastEngineOnTime;

	public VehicleEngineController<PlayerHelicopter>.EngineState CurEngineState
	{
		get
		{
			if (engineController == null)
			{
				return VehicleEngineController<PlayerHelicopter>.EngineState.Off;
			}
			return engineController.CurEngineState;
		}
	}

	public bool IsStartingUp
	{
		get
		{
			if (engineController != null)
			{
				return engineController.IsStarting;
			}
			return false;
		}
	}

	public float cachedPitch { get; set; }

	public float cachedYaw { get; set; }

	public float cachedRoll { get; set; }

	public SamSite.SamTargetType SAMTargetType => SamSite.targetTypeVehicle;

	public override bool ForceMovementHandling
	{
		protected get
		{
			if (isPushing)
			{
				return wheels.Length != 0;
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlayerHelicopter.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1851540757u, "RPC_OpenFuel", this, player, 6f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_OpenFuel(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenFuel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		EntityFuelSystem fuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
		engineController = new VehicleEngineController<PlayerHelicopter>(this, fuelSystem, base.isServer, 5f, waterSample, Flags.Reserved4);
	}

	public float GetFuelFraction(bool force = false)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && (TimeSince.op_Implicit(timeSinceCachedFuelFraction) > 1f || force))
		{
			cachedFuelFraction = Mathf.Clamp01((float)GetFuelSystem().GetFuelAmount() / fuelGaugeMax);
			timeSinceCachedFuelFraction = TimeSince.op_Implicit(0f);
		}
		return cachedFuelFraction;
	}

	public override bool CanPushNow(BasePlayer pusher)
	{
		if (base.CanPushNow(pusher) && pusher.IsOnGround())
		{
			return !pusher.isMounted;
		}
		return false;
	}

	public override float InheritedVelocityScale()
	{
		return 1f;
	}

	public override bool InheritedVelocityDirection()
	{
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.miniCopter != null)
		{
			engineController.FuelSystem.SetInstanceID(info.msg.miniCopter.fuelStorageID);
			cachedFuelFraction = info.msg.miniCopter.fuelFraction;
			cachedPitch = info.msg.miniCopter.pitch * maxPitchAnim;
			cachedRoll = info.msg.miniCopter.roll * maxRollAnim;
			cachedYaw = info.msg.miniCopter.yaw * maxYawAnim;
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			if (CurEngineState == VehicleEngineController<PlayerHelicopter>.EngineState.Off)
			{
				lastEngineOnTime = Time.time;
			}
			if ((Object)(object)rigidBody != (Object)null)
			{
				rigidBody.isKinematic = IsTransferProtected();
			}
		}
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned)
		{
			GetFuelSystem().CheckNewChild(child);
		}
	}

	public override float GetServiceCeiling()
	{
		return HotAirBalloon.serviceCeiling;
	}

	public override float GetMinimumAltitudeTerrain()
	{
		return HotAirBalloon.minimumAltitudeTerrain;
	}

	public override IFuelSystem GetFuelSystem()
	{
		return engineController.FuelSystem;
	}

	public override int StartingFuelUnits()
	{
		return 100;
	}

	public bool IsValidSAMTarget(bool staticRespawn)
	{
		if (rigidBody.IsSleeping() || rigidBody.isKinematic)
		{
			return false;
		}
		if (staticRespawn)
		{
			return true;
		}
		return !InSafeZone();
	}

	public override void PilotInput(InputState inputState, BasePlayer player)
	{
		base.PilotInput(inputState, player);
		if (!IsOn() && !IsStartingUp && inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD))
		{
			engineController.TryStartEngine(player);
		}
		currentInputState.groundControl = inputState.IsDown(BUTTON.DUCK);
		if (currentInputState.groundControl)
		{
			currentInputState.roll = 0f;
			currentInputState.throttle = (inputState.IsDown(BUTTON.FORWARD) ? 1f : 0f);
			currentInputState.throttle -= (inputState.IsDown(BUTTON.BACKWARD) ? 1f : 0f);
		}
		cachedRoll = currentInputState.roll;
		cachedYaw = currentInputState.yaw;
		cachedPitch = currentInputState.pitch;
	}

	public bool IsGrounded()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (IsStationary())
		{
			return cacheGrounded;
		}
		if (wheels.Length == 0)
		{
			flag = Physics.Raycast(((Component)this).transform.position + Vector3.up * 0.1f, Vector3.down, 0.5f);
		}
		else
		{
			float num = 1f;
			Wheel[] array = wheels;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].wheelCollider.isGrounded)
				{
					num -= 1f / (float)wheels.Length;
				}
			}
			flag = num >= 0.5f;
		}
		cacheGrounded = flag;
		return flag;
	}

	public override void SetDefaultInputState()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		currentInputState.Reset();
		cachedRoll = 0f;
		cachedYaw = 0f;
		cachedPitch = 0f;
		if (IsGrounded())
		{
			return;
		}
		if (HasDriver())
		{
			float num = Vector3.Dot(Vector3.up, ((Component)this).transform.right);
			float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
			currentInputState.roll = ((num < 0f) ? 1f : 0f);
			currentInputState.roll -= ((num > 0f) ? 1f : 0f);
			if (num2 < -0f)
			{
				currentInputState.pitch = -1f;
			}
			else if (num2 > 0f)
			{
				currentInputState.pitch = 1f;
			}
		}
		else
		{
			currentInputState.throttle = -1f;
		}
	}

	public void ApplyForceAtWheels()
	{
		if (!((Object)(object)rigidBody == (Object)null))
		{
			float brakeScale;
			float num2;
			float num;
			if (currentInputState.groundControl)
			{
				brakeScale = ((currentInputState.throttle == 0f) ? 50f : 0f);
				num = currentInputState.throttle;
				num2 = currentInputState.yaw;
			}
			else
			{
				brakeScale = 20f;
				num2 = 0f;
				num = 0f;
			}
			num *= (IsOn() ? 1f : 0f);
			if (isPushing)
			{
				brakeScale = 0f;
				num = 0.1f;
				num2 = 0f;
			}
			Wheel[] array = wheels;
			foreach (Wheel wheel in array)
			{
				ApplyWheelForce(wheel.wheelCollider, num, brakeScale, wheel.steering ? num2 : 0f);
			}
		}
	}

	public void ApplyForceWithoutWheels()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (currentInputState.groundControl)
		{
			if (currentInputState.throttle != 0f)
			{
				rigidBody.AddRelativeForce(Vector3.forward * currentInputState.throttle * motorForceConstant * 15f, (ForceMode)0);
			}
			if (currentInputState.yaw != 0f)
			{
				rigidBody.AddRelativeTorque(new Vector3(0f, currentInputState.yaw * torqueScale.y, 0f), (ForceMode)0);
			}
			float num = rigidBody.mass * (0f - Physics.gravity.y);
			rigidBody.AddForce(((Component)this).transform.up * num * hoverForceScale, (ForceMode)0);
		}
	}

	public void ApplyWheelForce(WheelCollider wheel, float gasScale, float brakeScale, float turning)
	{
		if (wheel.isGrounded)
		{
			float num = gasScale * motorForceConstant;
			float num2 = brakeScale * brakeForceConstant;
			float num3 = 45f * turning;
			if (!Mathf.Approximately(wheel.motorTorque, num))
			{
				wheel.motorTorque = num;
			}
			if (!Mathf.Approximately(wheel.brakeTorque, num2))
			{
				wheel.brakeTorque = num2;
			}
			if (!Mathf.Approximately(wheel.steerAngle, num3))
			{
				wheel.steerAngle = num3;
			}
			SetWheelFrictionMultiplier(wheel, 1f);
		}
	}

	public override void MovementUpdate()
	{
		if (IsGrounded())
		{
			if (wheels.Length != 0)
			{
				ApplyForceAtWheels();
			}
			else
			{
				ApplyForceWithoutWheels();
			}
		}
		if (!currentInputState.groundControl || !IsGrounded())
		{
			base.MovementUpdate();
		}
	}

	public override void ServerInit()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		lastEngineOnTime = Time.realtimeSinceStartup;
		rigidBody.inertiaTensor = rigidBody.inertiaTensor;
		preventBuildingObject.SetActive(true);
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateNetwork, 0f, 0.2f, 0.05f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayTick, Random.Range(30f, 60f), 60f, 6f);
	}

	public void DecayTick()
	{
		if (base.healthFraction != 0f && !IsOn() && !(Time.time < lastEngineOnTime + 600f))
		{
			float num = 1f / (IsOutside() ? outsidedecayminutes : insidedecayminutes);
			Hurt(MaxHealth() * num, DamageType.Decay, this, useProtection: false);
		}
	}

	public override bool IsEngineOn()
	{
		return IsOn();
	}

	protected override void TryStartEngine(BasePlayer player)
	{
		engineController.TryStartEngine(player);
	}

	public bool MeetsEngineRequirements()
	{
		if (base.autoHover)
		{
			return true;
		}
		if (engineController.IsOff)
		{
			return HasDriver();
		}
		if (!HasDriver())
		{
			return Time.time <= lastPlayerInputTime + 1f;
		}
		return true;
	}

	public void OnEngineStartFailed()
	{
	}

	public override void VehicleFixedUpdate()
	{
		if (IsTransferProtected())
		{
			return;
		}
		TimeWarning val = TimeWarning.New("PlayerHelicopter.VehicleFixedUpdate", 0);
		try
		{
			if (!IsStationary())
			{
				TryWakeWheels();
			}
			else
			{
				SleepWheels();
			}
			base.VehicleFixedUpdate();
			engineController.CheckEngineState();
			engineController.TickFuel(fuelPerSec);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void UpdateNetwork()
	{
		Flags flags = base.flags;
		Wheel[] array = wheels;
		foreach (Wheel wheel in array)
		{
			SetFlag(wheel.groundedFlag, wheel.wheelCollider.isGrounded, recursive: false, networkupdate: false);
		}
		if (HasDriver())
		{
			SendNetworkUpdate();
		}
		else if (flags != base.flags)
		{
			SendNetworkUpdate_Flags();
		}
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == "RadarLock")
		{
			SetFlag(Flags.Reserved13, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearRadarLock, 1f);
		}
		else if (msg == "RadarWarning")
		{
			SetFlag(Flags.Reserved12, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearRadarWarning, 1f);
		}
		else
		{
			base.OnEntityMessage(from, msg);
		}
	}

	public void ClearRadarLock()
	{
		SetFlag(Flags.Reserved13, b: false);
	}

	public void ClearRadarWarning()
	{
		SetFlag(Flags.Reserved12, b: false);
	}

	public void UpdateCOM()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		rigidBody.centerOfMass = com.localPosition;
	}

	public override void Save(SaveInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.miniCopter = Pool.Get<Minicopter>();
		info.msg.miniCopter.fuelStorageID = engineController.FuelSystem.GetInstanceID();
		info.msg.miniCopter.fuelFraction = GetFuelFraction(force: true);
		info.msg.miniCopter.pitch = currentInputState.pitch;
		info.msg.miniCopter.roll = currentInputState.roll;
		info.msg.miniCopter.yaw = currentInputState.yaw;
	}

	public override void OnDied(HitInfo info)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if ((Object)(object)mountPoint.mountable != (Object)null)
			{
				BasePlayer mounted = mountPoint.mountable.GetMounted();
				if (Object.op_Implicit((Object)(object)mounted))
				{
					HitInfo hitInfo = new HitInfo(info.Initiator, this, DamageType.Explosion, 1000f, ((Component)this).transform.position);
					hitInfo.Weapon = info.Weapon;
					hitInfo.WeaponPrefab = info.WeaponPrefab;
					mounted.Hurt(hitInfo);
				}
			}
		}
		base.OnDied(info);
	}

	public override void DoPushAction(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.Direction2D(((Component)player).transform.position, ((Component)this).transform.position);
		Vector3 val2 = player.eyes.BodyForward();
		val2.y = 0.25f;
		Vector3 val3 = ((Component)this).transform.position + val * 2f;
		float num = rigidBody.mass * 2f;
		rigidBody.AddForceAtPosition(val2 * num, val3, (ForceMode)1);
		rigidBody.AddForce(Vector3.up * 3f, (ForceMode)1);
		isPushing = true;
		((FacepunchBehaviour)this).Invoke((Action)DisablePushing, 0.5f);
	}

	public void DisablePushing()
	{
		isPushing = false;
	}

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return IsOn();
	}

	[RPC_Server.IsVisible(6f)]
	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			BasePlayer driver = GetDriver();
			if ((!((Object)(object)driver != (Object)null) || !((Object)(object)driver != (Object)(object)player)) && (!IsSafe() || !((Object)(object)player != (Object)(object)creatorEntity)))
			{
				engineController.FuelSystem.LootFuel(player);
			}
		}
	}

	public override bool ShouldDisableTransferProtectionOnLoad(BasePlayer player)
	{
		if (!IsDriver(player))
		{
			return !HasDriver();
		}
		return true;
	}

	public override void DisableTransferProtection()
	{
		SwapDriverIfInactive();
		if ((Object)(object)GetDriver() != (Object)null && IsOn())
		{
			SetDefaultInputState();
			lastPlayerInputTime = Time.time;
		}
		base.DisableTransferProtection();
	}

	private void SwapDriverIfInactive()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer driver = GetDriver();
		if ((Object)(object)driver == (Object)null || IsPlayerActive(driver))
		{
			return;
		}
		MountPointInfo mountPoint = GetMountPoint(GetPlayerSeat(driver));
		if (mountPoint == null)
		{
			Debug.LogError((object)"Helicopter driver is inactive but the driver seat was not found");
			return;
		}
		BasePlayer basePlayer = FindActivePassenger();
		if ((Object)(object)basePlayer == (Object)null)
		{
			Debug.LogError((object)"Helicopter driver is inactive and there is no passenger we can swap in");
			return;
		}
		MountPointInfo mountPoint2 = GetMountPoint(GetPlayerSeat(basePlayer));
		BaseEntity entity = basePlayer.GetParentEntity();
		Vector3 position = ((Component)basePlayer).transform.position;
		Quaternion rotation = ((Component)basePlayer).transform.rotation;
		driver.EnsureDismounted();
		basePlayer.EnsureDismounted();
		mountPoint.mountable.MountPlayer(basePlayer);
		if (mountPoint2 == null)
		{
			driver.SetParent(entity);
			driver.MovePosition(position);
			driver.ForceUpdateTriggers();
			((Component)driver).transform.rotation = rotation;
			driver.ServerRotation = rotation;
		}
		else
		{
			mountPoint2.mountable.MountPlayer(driver);
		}
		driver.SendNetworkUpdateImmediate();
		basePlayer.SendNetworkUpdateImmediate();
		BasePlayer FindActivePassenger()
		{
			foreach (MountPointInfo allMountPoint in base.allMountPoints)
			{
				if (!allMountPoint.isDriver && !((Object)(object)allMountPoint.mountable == (Object)null))
				{
					BasePlayer mounted = allMountPoint.mountable.GetMounted();
					if (!((Object)(object)mounted == (Object)null) && IsPlayerActive(mounted))
					{
						return mounted;
					}
				}
			}
			foreach (BaseEntity child in children)
			{
				if (!((Object)(object)child == (Object)null) && child is BasePlayer basePlayer2 && IsPlayerActive(basePlayer2))
				{
					return basePlayer2;
				}
			}
			return null;
		}
		static bool IsPlayerActive(BasePlayer player)
		{
			if (player.IsConnected && !player.IsSleeping())
			{
				return !player.IsLoadingAfterTransfer();
			}
			return false;
		}
	}

	protected override void ApplyHandbrake()
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		if (!IsGrounded() || rigidBody.IsSleeping())
		{
			return;
		}
		Wheel[] array = wheels;
		foreach (Wheel wheel in array)
		{
			wheel.wheelCollider.motorTorque = 0f;
			wheel.wheelCollider.brakeTorque = 10000f;
			SetWheelFrictionMultiplier(wheel.wheelCollider, 3f);
		}
		float[] array2 = recentVelocities;
		int num = recentVelIndex;
		Vector3 velocity = rigidBody.velocity;
		array2[num] = ((Vector3)(ref velocity)).sqrMagnitude;
		recentVelIndex = ++recentVelIndex % recentVelocities.Length;
		bool flag = true;
		float[] array3 = recentVelocities;
		for (int i = 0; i < array3.Length; i++)
		{
			if (array3[i] >= 0.05f)
			{
				flag = false;
				break;
			}
		}
		if (flag && Time.time > lastEngineOnTime + 5f)
		{
			rigidBody.Sleep();
			((FacepunchBehaviour)this).Invoke((Action)SleepWheels, 0.1f, 0f);
		}
	}

	private void TryWakeWheels()
	{
		Wheel[] array = wheels;
		foreach (Wheel wheel in array)
		{
			if (!((Collider)wheel.wheelCollider).enabled)
			{
				((Collider)wheel.wheelCollider).enabled = true;
			}
		}
	}

	private void SleepWheels()
	{
		if (vehicle.disable_wheels_when_sleeping)
		{
			Wheel[] array = wheels;
			for (int i = 0; i < array.Length; i++)
			{
				((Collider)array[i].wheelCollider).enabled = false;
			}
		}
	}

	private void SetWheelFrictionMultiplier(WheelCollider wheel, float multiplier)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		WheelFrictionCurve val = wheel.forwardFriction;
		((WheelFrictionCurve)(ref val)).stiffness = multiplier;
		wheel.forwardFriction = val;
		val = wheel.sidewaysFriction;
		((WheelFrictionCurve)(ref val)).stiffness = multiplier;
		wheel.sidewaysFriction = val;
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


using System;
using UnityEngine;

[Serializable]
public class Wheel
{
	public WheelCollider wheelCollider;

	public Transform visualBone;

	public Flags groundedFlag = Flags.Reserved1;

	[NonSerialized]
	public float wheelVel;

	[NonSerialized]
	public Vector3 wheelRot = Vector3.zero;

	public bool steering;

	public bool IsGrounded(PlayerHelicopter parent)
	{
		if (parent.isServer)
		{
			return wheelCollider.isGrounded;
		}
		return parent.HasFlag(groundedFlag);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class PlayerInventory : EntityComponent<BasePlayer>, IAmmoContainer
{
	public enum Type
	{
		Main,
		Belt,
		Wear,
		BackpackContents
	}

	public interface ICanMoveFrom
	{
		bool CanMoveFrom(BasePlayer player, Item item);
	}

	public enum NetworkInventoryMode
	{
		LocalPlayer,
		Everyone,
		EveryoneButLocal
	}

	private struct WearCheckResult
	{
		public bool Result;

		public List<Item> ChangedItem;
	}

	public ItemContainer containerMain;

	public ItemContainer containerBelt;

	public ItemContainer containerWear;

	public ItemCrafter crafting;

	public PlayerLoot loot;

	public static Phrase BackpackGroundedError = new Phrase("error.backpackGrounded", "You must be on a solid surface to equip a backpack");

	public float inventoryRadioactivity;

	public bool containsRadioactiveItems;

	private Action _deferredServerUpdateAction;

	private List<Item> returnItems;

	[ServerVar]
	public static bool forceBirthday = false;

	[ServerVar]
	public static bool directionalDropEnabled = true;

	private static float nextCheckTime = 0f;

	private static bool wasBirthday = false;

	private Action DeferredServerUpdateAction => DeferredServerUpdate;

	public event Action<float, bool> onRadioactivityChanged;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlayerInventory.OnRpcMessage", 0);
		try
		{
			if (rpc == 3482449460u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ItemCmd "));
				}
				TimeWarning val2 = TimeWarning.New("ItemCmd", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!BaseEntity.RPC_Server.FromOwner.Test(3482449460u, "ItemCmd", GetBaseEntity(), player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							BaseEntity.RPCMessage msg2 = rPCMessage;
							ItemCmd(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ItemCmd");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3041092525u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - MoveItem "));
				}
				TimeWarning val2 = TimeWarning.New("MoveItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!BaseEntity.RPC_Server.FromOwner.Test(3041092525u, "MoveItem", GetBaseEntity(), player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							BaseEntity.RPCMessage msg3 = rPCMessage;
							MoveItem(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in MoveItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	protected void Initialize(BasePlayer owner)
	{
		Debug.Assert(containerMain == null, "Double init of main container!");
		containerMain = Pool.Get<ItemContainer>();
		containerMain.SetFlag(ItemContainer.Flag.IsPlayer, b: true);
		Debug.Assert(containerBelt == null, "Double init of belt container!");
		containerBelt = Pool.Get<ItemContainer>();
		containerBelt.SetFlag(ItemContainer.Flag.IsPlayer, b: true);
		containerBelt.SetFlag(ItemContainer.Flag.Belt, b: true);
		Debug.Assert(containerWear == null, "Double init of wear container!");
		containerWear = Pool.Get<ItemContainer>();
		containerWear.SetFlag(ItemContainer.Flag.IsPlayer, b: true);
		containerWear.SetFlag(ItemContainer.Flag.Clothing, b: true);
		containerWear.containerVolume = 2;
		crafting = ((Component)this).GetComponent<ItemCrafter>();
		if ((Object)(object)crafting != (Object)null)
		{
			crafting.owner = owner;
			crafting.AddContainer(containerMain);
			crafting.AddContainer(containerBelt);
		}
		loot = ((Component)this).GetComponent<PlayerLoot>();
		if (!Object.op_Implicit((Object)(object)loot))
		{
			loot = base.baseEntity.AddComponent<PlayerLoot>();
		}
	}

	public void DoDestroy()
	{
		if (containerMain != null)
		{
			Pool.Free<ItemContainer>(ref containerMain);
		}
		if (containerBelt != null)
		{
			Pool.Free<ItemContainer>(ref containerBelt);
		}
		if (containerWear != null)
		{
			Pool.Free<ItemContainer>(ref containerWear);
		}
	}

	public void SetLockedByRestraint(bool flag)
	{
		containerMain.SetLocked(flag, lockSubItems: true);
		containerWear.SetLocked(flag, lockSubItems: true);
		containerBelt.SetLocked(flag, lockSubItems: true);
		GetContainer(Type.BackpackContents)?.SetLocked(flag, lockSubItems: true);
	}

	public void ServerInit(BasePlayer owner)
	{
		Initialize(owner);
		containerMain.ServerInitialize(null, 24);
		if (!((ItemContainerId)(ref containerMain.uid)).IsValid)
		{
			containerMain.GiveUID();
		}
		containerBelt.ServerInitialize(null, 6);
		if (!((ItemContainerId)(ref containerBelt.uid)).IsValid)
		{
			containerBelt.GiveUID();
		}
		containerWear.ServerInitialize(null, 8);
		if (!((ItemContainerId)(ref containerWear.uid)).IsValid)
		{
			containerWear.GiveUID();
		}
		containerMain.playerOwner = owner;
		containerBelt.playerOwner = owner;
		containerWear.playerOwner = owner;
		containerWear.onItemContentsChanged = OnClothingItemContentsChanged;
		containerWear.onItemAddedRemoved = OnClothingChanged;
		containerWear.canAcceptItem = CanWearItem;
		containerBelt.canAcceptItem = CanEquipItem;
		containerMain.canAcceptItem = CanStoreInInventory;
		containerMain.onPreItemRemove = OnItemRemoved;
		containerWear.onPreItemRemove = OnItemRemoved;
		containerBelt.onPreItemRemove = OnItemRemoved;
		containerMain.onDirty += OnContentsDirty;
		containerBelt.onDirty += OnContentsDirty;
		containerWear.onDirty += OnContentsDirty;
		containerBelt.onItemAddedRemoved = OnItemAddedOrRemoved;
		containerMain.onItemAddedRemoved = OnItemAddedOrRemoved;
		ItemContainer itemContainer = containerWear;
		itemContainer.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(itemContainer.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedOrRemoved));
		containerWear.onItemRadiationChanged = OnItemRadiationChanged;
		containerBelt.onItemRadiationChanged = OnItemRadiationChanged;
		containerMain.onItemRadiationChanged = OnItemRadiationChanged;
		onRadioactivityChanged += owner.PlayerInventoryRadioactivityChange;
		CalculateInventoryRadioactivity();
	}

	public void OnItemAddedOrRemoved(Item item, bool bAdded)
	{
		if (item != null && (item.radioactivity > 0f || item.contents != null))
		{
			CalculateInventoryRadioactivity();
		}
		if (item.info.isHoldable)
		{
			((FacepunchBehaviour)this).Invoke((Action)UpdatedVisibleHolsteredItems, 0.1f);
		}
		if (item.parent == containerBelt)
		{
			OnBeltItemAddedOrRemoved(item, bAdded);
		}
		if (bAdded)
		{
			BasePlayer basePlayer = base.baseEntity;
			if (!basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.DisplaySash) && basePlayer.IsHostileItem(item))
			{
				base.baseEntity.SetPlayerFlag(BasePlayer.PlayerFlags.DisplaySash, b: true);
			}
			if (bAdded)
			{
				basePlayer.ProcessMissionEvent(BaseMission.MissionEventType.ACQUIRE_ITEM, item.info.itemid, item.amount);
			}
		}
	}

	private void OnBeltItemAddedOrRemoved(Item item, bool added)
	{
		if (!added)
		{
			return;
		}
		ItemModForceWearFromBelt component = ((Component)item.info).GetComponent<ItemModForceWearFromBelt>();
		if (!((Object)(object)component == (Object)null) && (!component.IfPlayerRestrained || base.baseEntity.IsRestrained))
		{
			bool num = containerWear.IsLocked();
			if (num)
			{
				containerWear.SetLocked(isLocked: false);
			}
			if (!item.MoveToContainer(containerWear))
			{
				item.MoveToContainer(containerWear, 0, allowStack: false);
			}
			if (num)
			{
				containerWear.SetLocked(isLocked: true);
			}
		}
	}

	public void UpdatedVisibleHolsteredItems()
	{
		List<HeldEntity> list = Pool.Get<List<HeldEntity>>();
		List<Item> list2 = Pool.Get<List<Item>>();
		GetAllItems(list2);
		AddBackpackContentsToList(list2);
		foreach (Item item in list2)
		{
			if (item.info.isHoldable && !((Object)(object)item.GetHeldEntity() == (Object)null))
			{
				HeldEntity component = ((Component)item.GetHeldEntity()).GetComponent<HeldEntity>();
				if (!((Object)(object)component == (Object)null) && (!component.IsShield || containerWear.itemList.Contains(item)))
				{
					list.Add(component);
				}
			}
		}
		Pool.Free<Item>(ref list2, false);
		IOrderedEnumerable<HeldEntity> orderedEnumerable = list.OrderByDescending((HeldEntity x) => x.hostileScore);
		bool flag = true;
		bool flag2 = true;
		bool flag3 = true;
		bool flag4 = true;
		foreach (HeldEntity item2 in orderedEnumerable)
		{
			if (!((Object)(object)item2 == (Object)null) && item2.holsterInfo.displayWhenHolstered)
			{
				if (flag4 && !item2.IsDeployed() && item2.holsterInfo.slot == HeldEntity.HolsterInfo.HolsterSlot.BACK_SHIELD)
				{
					item2.SetVisibleWhileHolstered(visible: true);
					flag4 = false;
				}
				else if (flag3 && !item2.IsDeployed() && item2.holsterInfo.slot == HeldEntity.HolsterInfo.HolsterSlot.BACK)
				{
					item2.SetVisibleWhileHolstered(visible: true);
					flag3 = false;
				}
				else if (flag2 && !item2.IsDeployed() && item2.holsterInfo.slot == HeldEntity.HolsterInfo.HolsterSlot.RIGHT_THIGH)
				{
					item2.SetVisibleWhileHolstered(visible: true);
					flag2 = false;
				}
				else if (flag && !item2.IsDeployed() && item2.holsterInfo.slot == HeldEntity.HolsterInfo.HolsterSlot.LEFT_THIGH)
				{
					item2.SetVisibleWhileHolstered(visible: true);
					flag = false;
				}
				else
				{
					item2.SetVisibleWhileHolstered(visible: false);
				}
			}
		}
		Pool.FreeUnmanaged<HeldEntity>(ref list);
	}

	public void AddBackpackContentsToList(List<Item> items)
	{
		Item backpackWithInventory = GetBackpackWithInventory();
		if (backpackWithInventory != null && backpackWithInventory.contents != null)
		{
			items.AddRange(backpackWithInventory.contents.itemList);
		}
	}

	public void OnContentsDirty()
	{
		if ((Object)(object)base.baseEntity != (Object)null)
		{
			base.baseEntity.InvalidateNetworkCache();
		}
	}

	public bool CanMoveItemsFrom(BaseEntity entity, Item item)
	{
		if (entity is ICanMoveFrom canMoveFrom && !canMoveFrom.CanMoveFrom(base.baseEntity, item))
		{
			return false;
		}
		if (Object.op_Implicit((Object)(object)BaseGameMode.GetActiveGameMode(serverside: true)))
		{
			return BaseGameMode.GetActiveGameMode(serverside: true).CanMoveItemsFrom(this, entity, item);
		}
		return true;
	}

	[BaseEntity.RPC_Server.FromOwner(false)]
	[BaseEntity.RPC_Server]
	private void ItemCmd(BaseEntity.RPCMessage msg)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		if (((Object)(object)msg.player != (Object)null && msg.player.IsWounded()) || base.baseEntity.IsTransferring())
		{
			return;
		}
		ItemId id = msg.read.ItemID();
		string text = msg.read.String(256, false);
		Item item = FindItemByUID(id);
		if (item == null || Interface.CallHook("OnItemAction", (object)item, (object)text, (object)msg.player) != null)
		{
			return;
		}
		BaseEntity entityOwner = item.GetEntityOwner();
		if (((Object)(object)entityOwner != (Object)null && (Object)(object)entityOwner == (Object)(object)msg.player && msg.player.IsRestrainedOrSurrendering) || item.IsLocked() || (item.parent != null && item.parent.IsLocked()) || !CanMoveItemsFrom(item.GetEntityOwner(), item))
		{
			return;
		}
		if (text == "drop")
		{
			int num = item.amount;
			if (msg.read.Unread >= 4)
			{
				num = msg.read.Int32();
			}
			if (!msg.player.isMounted && !msg.player.HasParent() && !GamePhysics.LineOfSight(((Component)msg.player).transform.position, msg.player.eyes.position, 1218519041))
			{
				return;
			}
			base.baseEntity.stats.Add("item_drop", 1, (Stats)5);
			if (num < item.amount)
			{
				Item item2 = item.SplitItem(num);
				ItemContainer parent = item.parent;
				if (item2 != null)
				{
					Vector3 dropVelocity = GetDropVelocity(msg);
					DroppedItem droppedItem = item2.Drop(base.baseEntity.GetDropPosition(), dropVelocity) as DroppedItem;
					if ((Object)(object)droppedItem != (Object)null)
					{
						droppedItem.DropReason = DroppedItem.DropReasonEnum.Player;
						droppedItem.DroppedBy = base.baseEntity.userID;
						droppedItem.DroppedTime = DateTime.UtcNow;
						Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem, DroppedItem.DropReasonEnum.Player);
					}
				}
				parent?.onItemRemovedFromStack?.Invoke(item, num);
			}
			else
			{
				Vector3 dropVelocity2 = GetDropVelocity(msg);
				ItemContainer parent2 = item.parent;
				DroppedItem droppedItem2 = item.Drop(base.baseEntity.GetDropPosition(), dropVelocity2) as DroppedItem;
				if ((Object)(object)droppedItem2 != (Object)null)
				{
					droppedItem2.DropReason = DroppedItem.DropReasonEnum.Player;
					droppedItem2.DroppedBy = base.baseEntity.userID;
					droppedItem2.DroppedTime = DateTime.UtcNow;
					Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem2, DroppedItem.DropReasonEnum.Player);
				}
				parent2?.onItemAddedRemoved?.Invoke(item, arg2: false);
			}
			base.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, "drop_item");
		}
		else
		{
			item.ServerCommand(text, base.baseEntity);
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
	}

	private Vector3 GetDropVelocity(BaseEntity.RPCMessage msg)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		if (msg.read.Unread >= 4)
		{
			num = msg.read.Float();
		}
		if (!directionalDropEnabled)
		{
			num = 0f;
		}
		Vector3 inheritedDropVelocity = base.baseEntity.GetInheritedDropVelocity();
		Vector3 val = base.baseEntity.eyes.BodyForward();
		Vector3 val2 = Quaternion.AngleAxis(num, Vector3.up) * new Vector3(val.x, 0f, val.z);
		val2.y = val.y;
		return inheritedDropVelocity + val2 * 4f + Vector3Ex.Range(-0.5f, 0.5f);
	}

	[BaseEntity.RPC_Server.FromOwner(false)]
	[BaseEntity.RPC_Server]
	public void MoveItem(BaseEntity.RPCMessage msg)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		if (base.baseEntity.IsTransferring())
		{
			return;
		}
		ItemId id = msg.read.ItemID();
		ItemContainerId val = msg.read.ItemContainerID();
		int num = msg.read.Int8();
		int num2 = (int)msg.read.UInt32();
		ItemMoveModifier val2 = (ItemMoveModifier)msg.read.Int32();
		Item item = FindItemByUID(id);
		if (item == null)
		{
			msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidItem, false);
			ConstructionErrors.Log(msg.player, ((object)(ItemId)(ref id)/*cast due to .constrained prefix*/).ToString());
		}
		else
		{
			if (Interface.CallHook("CanMoveItem", (object)item, (object)this, (object)val, (object)num, (object)num2, (object)val2) != null)
			{
				return;
			}
			BaseEntity entityOwner = item.GetEntityOwner();
			if ((Object)(object)entityOwner != (Object)null && (Object)(object)entityOwner == (Object)(object)msg.player && msg.player.IsRestrainedOrSurrendering)
			{
				return;
			}
			if (!CanMoveItemsFrom(entityOwner, item))
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.CannotMoveItem, true);
				return;
			}
			if (num2 <= 0)
			{
				num2 = item.amount;
			}
			num2 = Mathf.Clamp(num2, 1, item.MaxStackable());
			if (msg.player.GetActiveItem() == item)
			{
				msg.player.UpdateActiveItem(default(ItemId));
			}
			if (!((ItemContainerId)(ref val)).IsValid)
			{
				BaseEntity baseEntity = entityOwner;
				if (loot.containers.Count > 0)
				{
					if ((Object)(object)entityOwner == (Object)(object)base.baseEntity)
					{
						if (!((Enum)val2).HasFlag((Enum)(object)(ItemMoveModifier)2))
						{
							baseEntity = loot.entitySource;
						}
					}
					else
					{
						baseEntity = base.baseEntity;
					}
				}
				if (baseEntity is IIdealSlotEntity idealSlotEntity)
				{
					val = idealSlotEntity.GetIdealContainer(base.baseEntity, item, val2);
					if (val == ItemContainerId.Invalid)
					{
						return;
					}
				}
				ItemContainer parent = item.parent;
				if (parent != null && parent.IsLocked())
				{
					msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
					return;
				}
				if (!((ItemContainerId)(ref val)).IsValid)
				{
					if ((Object)(object)baseEntity == (Object)(object)loot.entitySource)
					{
						foreach (ItemContainer container in loot.containers)
						{
							if (!container.PlayerItemInputBlocked() && !container.IsLocked() && item.MoveToContainer(container, -1, allowStack: true, ignoreStackLimit: false, base.baseEntity))
							{
								break;
							}
						}
						return;
					}
					if (!GiveItem(item, val2))
					{
						msg.player.ShowToast(GameTip.Styles.Error, Phrase.op_Implicit("GiveItem failed!"), false);
					}
					return;
				}
			}
			ItemContainer itemContainer = FindContainer(val);
			if (itemContainer == null)
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidContainer, false);
				ConstructionErrors.Log(msg.player, ((object)(ItemContainerId)(ref val)/*cast due to .constrained prefix*/).ToString());
				return;
			}
			if (itemContainer.IsLocked())
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
				return;
			}
			if (itemContainer.PlayerItemInputBlocked())
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.DoesntAcceptPlayerItems, false);
				return;
			}
			if (itemContainer.maxStackSize > 0)
			{
				num2 = Mathf.Clamp(num2, 1, itemContainer.maxStackSize);
			}
			bool allowSwap = !itemContainer.PlayerItemInputBlocked() && item.parent != null && !item.parent.PlayerItemInputBlocked();
			TimeWarning val3 = TimeWarning.New("Split", 0);
			try
			{
				if (item.amount > num2)
				{
					int split_Amount = num2;
					Item item2 = item.SplitItem(split_Amount);
					Item slot = itemContainer.GetSlot(num);
					if (slot != null && !item.CanStack(slot) && item.parent != null && !item2.MoveToContainer(item.parent, -1, allowStack: false, ignoreStackLimit: false, base.baseEntity, allowSwap: false))
					{
						item.amount += item2.amount;
						item2.Remove();
						ItemManager.DoRemoves();
						ServerUpdate(0f);
						return;
					}
					if (!item2.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity, allowSwap))
					{
						item.amount += item2.amount;
						item2.Remove();
					}
					else
					{
						item.parent.onItemRemovedFromStack?.Invoke(item, num2);
					}
					ItemManager.DoRemoves();
					ServerUpdate(0f);
					return;
				}
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
			if (item.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity, allowSwap))
			{
				ItemManager.DoRemoves();
				ServerUpdate(0f);
			}
		}
	}

	private void OnClothingItemContentsChanged(Item item, bool bAdded)
	{
		OnClothingChanged(item, bAdded);
	}

	public void OnClothingChanged(Item item, bool bAdded)
	{
		base.baseEntity.SV_ClothingChanged();
		if (ItemManager.EnablePooling)
		{
			if (!((FacepunchBehaviour)this).IsInvoking(DeferredServerUpdateAction))
			{
				((FacepunchBehaviour)this).Invoke(DeferredServerUpdateAction, 0f);
			}
		}
		else
		{
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
		if (item.position == 7)
		{
			item.RecalulateParentEntity(children: true);
			((FacepunchBehaviour)this).Invoke((Action)UpdatedVisibleHolsteredItems, 0.1f);
			if ((Object)(object)base.baseEntity.GetHeldEntity() != (Object)null)
			{
				base.baseEntity.GetHeldEntity().UpdateShieldState(bHeld: true);
			}
			item?.contents?.onItemAddedRemoved?.Invoke(item, bAdded);
		}
		base.baseEntity.ProcessMissionEvent(BaseMission.MissionEventType.CLOTHINGCHANGED, 0, 0f);
		Interface.CallHook("OnClothingItemChanged", (object)this, (object)item, (object)bAdded);
	}

	private void DeferredServerUpdate()
	{
		ServerUpdate(0f);
	}

	public void OnItemRemoved(Item item)
	{
		base.baseEntity.InvalidateNetworkCache();
	}

	public bool CanStoreInInventory(Item item, int targetSlot)
	{
		return true;
	}

	public bool CanEquipItem(Item item, int targetSlot)
	{
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanEquipItem", (object)this, (object)item, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((item.info.flags & ItemDefinition.Flag.NotAllowedInBelt) != 0)
		{
			return false;
		}
		if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity.IsRestrained)
		{
			Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
			if ((Object)(object)restraintItem != (Object)null && restraintItem.GetItem().position == targetSlot)
			{
				return false;
			}
		}
		ItemModContainerRestriction component = ((Component)item.info).GetComponent<ItemModContainerRestriction>();
		if ((Object)(object)component == (Object)null)
		{
			return true;
		}
		BufferList<Item> val = Pool.Get<BufferList<Item>>();
		val.CopyFrom(containerBelt.itemList);
		Enumerator<Item> enumerator = val.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Item current = enumerator.Current;
				if (current != item)
				{
					ItemModContainerRestriction component2 = ((Component)current.info).GetComponent<ItemModContainerRestriction>();
					if (!((Object)(object)component2 == (Object)null) && !component.CanExistWith(component2) && !current.MoveToContainer(containerMain))
					{
						current.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Pool.Free<Item>(ref val, false);
		return true;
	}

	public bool CanWearItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanWearItem", (object)this, (object)item, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return CanWearItem(item, canAdjustClothing: true, targetSlot);
	}

	public bool CanWearItem(Item item, bool canAdjustClothing, int targetSlot)
	{
		return WearItemCheck(item, canAdjustClothing, targetSlot).Result;
	}

	public bool CanReplaceBackpack(Item itemToWear)
	{
		Item slot = containerWear.GetSlot(7);
		if (slot == null)
		{
			return true;
		}
		ItemContainer contents = slot.contents;
		if (contents != null && contents.itemList?.Count > 0)
		{
			if (base.baseEntity.InSafeZone())
			{
				return false;
			}
			if (!itemToWear.IsDroppedInWorld(serverside: true))
			{
				return false;
			}
		}
		return true;
	}

	public void ServerUpdate(float delta)
	{
		loot.Check();
		if (delta > 0f && !base.baseEntity.IsSleeping() && !base.baseEntity.IsTransferring())
		{
			crafting.ServerUpdate(delta);
		}
		float currentTemperature = base.baseEntity.currentTemperature;
		UpdateContainer(delta, Type.Main, containerMain, bSendInventoryToEveryone: false, currentTemperature);
		UpdateContainer(delta, Type.Belt, containerBelt, bSendInventoryToEveryone: true, currentTemperature);
		UpdateContainer(delta, Type.Wear, containerWear, bSendInventoryToEveryone: true, currentTemperature);
	}

	public void UpdateContainer(float delta, Type type, ItemContainer container, bool bSendInventoryToEveryone, float temperature)
	{
		if (container != null)
		{
			container.temperature = temperature;
			if (delta > 0f)
			{
				container.OnCycle(delta);
			}
			if (container.dirty)
			{
				SendUpdatedInventory(type, container, bSendInventoryToEveryone);
				base.baseEntity.InvalidateNetworkCache();
			}
		}
	}

	public void SendSnapshot()
	{
		TimeWarning val = TimeWarning.New("PlayerInventory.SendSnapshot", 0);
		try
		{
			SendUpdatedInventory(Type.Main, containerMain);
			SendUpdatedInventory(Type.Belt, containerBelt, bSendInventoryToEveryone: true);
			SendUpdatedInventory(Type.Wear, containerWear, bSendInventoryToEveryone: true);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void SendUpdatedInventory(Type type, ItemContainer container, bool bSendInventoryToEveryone = false)
	{
		if (type == Type.Wear)
		{
			if (bSendInventoryToEveryone)
			{
				SendUpdatedInventoryInternal(type, container, NetworkInventoryMode.LocalPlayer);
				SendUpdatedInventoryInternal(type, container, NetworkInventoryMode.EveryoneButLocal);
			}
			else
			{
				SendUpdatedInventoryInternal(type, container, NetworkInventoryMode.LocalPlayer);
			}
		}
		else
		{
			SendUpdatedInventoryInternal(type, container, bSendInventoryToEveryone ? NetworkInventoryMode.Everyone : NetworkInventoryMode.LocalPlayer);
		}
	}

	public void SendUpdatedInventoryInternal(Type type, ItemContainer container, NetworkInventoryMode mode)
	{
		UpdateItemContainer val = Pool.Get<UpdateItemContainer>();
		try
		{
			val.type = (int)type;
			if (base.baseEntity.IsSpectating())
			{
				mode = NetworkInventoryMode.LocalPlayer;
			}
			if (container != null)
			{
				container.dirty = false;
				val.container = Pool.Get<List<ItemContainer>>();
				bool bIncludeContainer = type != Type.Wear || mode == NetworkInventoryMode.LocalPlayer;
				val.container.Add(container.Save(bIncludeContainer));
			}
			if (Interface.CallHook("OnInventoryNetworkUpdate", (object)this, (object)container, (object)val, (object)type, (object)mode) != null)
			{
				return;
			}
			switch (mode)
			{
			case NetworkInventoryMode.Everyone:
				base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("UpdatedItemContainer"), val);
				break;
			case NetworkInventoryMode.LocalPlayer:
				base.baseEntity.ClientRPC(RpcTarget.Player("UpdatedItemContainer", base.baseEntity), val);
				break;
			case NetworkInventoryMode.EveryoneButLocal:
				if (base.baseEntity.net?.group?.subscribers == null)
				{
					break;
				}
				{
					foreach (Connection subscriber in base.baseEntity.net.group.subscribers)
					{
						if (subscriber.player is BasePlayer basePlayer && (Object)(object)basePlayer != (Object)(object)base.baseEntity)
						{
							base.baseEntity.ClientRPC(RpcTarget.Player("UpdatedItemContainer", basePlayer), val);
						}
					}
					break;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private WearCheckResult WearItemCheck(Item item, bool canAdjustClothing, int targetSlot, bool dontMove = false)
	{
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		ItemModWearable component = ((Component)item.info).GetComponent<ItemModWearable>();
		if ((Object)(object)component == (Object)null)
		{
			WearCheckResult result = default(WearCheckResult);
			result.Result = false;
			result.ChangedItem = null;
			return result;
		}
		if (component.npcOnly && !Inventory.disableAttireLimitations)
		{
			BasePlayer basePlayer = base.baseEntity;
			if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsNpc)
			{
				WearCheckResult result = default(WearCheckResult);
				result.Result = false;
				result.ChangedItem = null;
				return result;
			}
		}
		bool flag = item.IsBackpack();
		if (flag)
		{
			if (targetSlot != 7)
			{
				WearCheckResult result = default(WearCheckResult);
				result.Result = false;
				result.ChangedItem = null;
				return result;
			}
			if (!CanReplaceBackpack(item))
			{
				WearCheckResult result = default(WearCheckResult);
				result.Result = false;
				result.ChangedItem = null;
				return result;
			}
		}
		else if (!flag && targetSlot == 7)
		{
			WearCheckResult result = default(WearCheckResult);
			result.Result = false;
			result.ChangedItem = null;
			return result;
		}
		if ((Object)(object)((Component)item.info).GetComponent<ItemModParachute>() != (Object)null && !CanEquipParachute())
		{
			base.baseEntity.ShowToast(GameTip.Styles.Red_Normal, BackpackGroundedError, false);
			WearCheckResult result = default(WearCheckResult);
			result.Result = false;
			result.ChangedItem = null;
			return result;
		}
		if (component.preventsMounting && base.baseEntity.isMounted)
		{
			WearCheckResult result = default(WearCheckResult);
			result.Result = false;
			result.ChangedItem = null;
			return result;
		}
		BufferList<Item> val = Pool.Get<BufferList<Item>>();
		val.CopyFrom(containerWear.itemList);
		Enumerator<Item> enumerator = val.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Item clothingItem = enumerator.Current;
				if (clothingItem == item)
				{
					continue;
				}
				ItemModWearable component2 = ((Component)clothingItem.info).GetComponent<ItemModWearable>();
				if (!((Object)(object)component2 == (Object)null) && !Inventory.disableAttireLimitations && !component.CanExistWith(component2))
				{
					if (!canAdjustClothing)
					{
						Pool.Free<Item>(ref val, false);
						WearCheckResult result = default(WearCheckResult);
						result.Result = false;
						result.ChangedItem = null;
						return result;
					}
					if (!dontMove && (targetSlot != clothingItem.position || targetSlot == 7) && !DirectSwap(containerMain) && !DirectSwap(containerBelt) && !clothingItem.MoveToContainer(containerMain) && !clothingItem.MoveToContainer(containerBelt))
					{
						clothingItem.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
					}
				}
				bool DirectSwap(ItemContainer container)
				{
					if (container.itemList.Count == container.capacity && container.itemList.Contains(item))
					{
						if (!clothingItem.MoveToContainer(container))
						{
							return false;
						}
						item.RemoveFromContainer();
						return true;
					}
					return false;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Pool.Free<Item>(ref val, false);
		WearCheckResult result2 = default(WearCheckResult);
		result2.Result = true;
		result2.ChangedItem = returnItems;
		return result2;
	}

	public Item FindItemByUID(ItemId id)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (!((ItemId)(ref id)).IsValid)
		{
			return null;
		}
		if (containerMain != null)
		{
			Item item = containerMain.FindItemByUID(id);
			if (item != null && item.IsValid())
			{
				return item;
			}
		}
		if (containerBelt != null)
		{
			Item item2 = containerBelt.FindItemByUID(id);
			if (item2 != null && item2.IsValid())
			{
				return item2;
			}
		}
		if (containerWear != null)
		{
			Item item3 = containerWear.FindItemByUID(id);
			if (item3 != null && item3.IsValid())
			{
				return item3;
			}
		}
		return loot.FindItem(id);
	}

	public Item FindItemByItemID(string itemName)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemName);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		return FindItemByItemID(itemDefinition.itemid);
	}

	public Item FindItemByItemID(int id)
	{
		object obj = Interface.CallHook("OnInventoryItemFind", (object)this, (object)id);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (containerMain != null)
		{
			Item item = containerMain.FindItemByItemID(id);
			if (item != null && item.IsValid())
			{
				return item;
			}
		}
		if (containerBelt != null)
		{
			Item item2 = containerBelt.FindItemByItemID(id);
			if (item2 != null && item2.IsValid())
			{
				return item2;
			}
		}
		if (containerWear != null)
		{
			Item item3 = containerWear.FindItemByItemID(id);
			if (item3 != null && item3.IsValid())
			{
				return item3;
			}
		}
		return null;
	}

	public Item FindItemByItemName(string name)
	{
		if (containerMain != null)
		{
			Item item = containerMain.FindItemByItemName(name);
			if (item != null && item.IsValid())
			{
				return item;
			}
		}
		if (containerBelt != null)
		{
			Item item2 = containerBelt.FindItemByItemName(name);
			if (item2 != null && item2.IsValid())
			{
				return item2;
			}
		}
		if (containerWear != null)
		{
			Item item3 = containerWear.FindItemByItemName(name);
			if (item3 != null && item3.IsValid())
			{
				return item3;
			}
		}
		return null;
	}

	public Item FindBySubEntityID(NetworkableId subEntityID)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (containerMain != null)
		{
			Item item = containerMain.FindBySubEntityID(subEntityID);
			if (item != null && item.IsValid())
			{
				return item;
			}
		}
		if (containerBelt != null)
		{
			Item item2 = containerBelt.FindBySubEntityID(subEntityID);
			if (item2 != null && item2.IsValid())
			{
				return item2;
			}
		}
		if (containerWear != null)
		{
			Item item3 = containerWear.FindBySubEntityID(subEntityID);
			if (item3 != null && item3.IsValid())
			{
				return item3;
			}
		}
		return null;
	}

	public void FindItemsByItemID(List<Item> list, int id)
	{
		if (Interface.CallHook("OnInventoryItemsFind", (object)this, (object)id, (object)list) == null)
		{
			if (containerMain != null)
			{
				containerMain.FindItemsByItemID(list, id);
			}
			if (containerBelt != null)
			{
				containerBelt.FindItemsByItemID(list, id);
			}
			if (containerWear != null)
			{
				containerWear.FindItemsByItemID(list, id);
			}
		}
	}

	public ItemContainer FindContainer(ItemContainerId id)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FindContainer", 0);
		try
		{
			ItemContainer itemContainer = containerMain.FindContainer(id);
			if (itemContainer != null)
			{
				return itemContainer;
			}
			itemContainer = containerBelt.FindContainer(id);
			if (itemContainer != null)
			{
				return itemContainer;
			}
			itemContainer = containerWear.FindContainer(id);
			if (itemContainer != null)
			{
				return itemContainer;
			}
			return loot.FindContainer(id);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public ItemContainer GetContainer(Type id)
	{
		if (id == Type.Main)
		{
			return containerMain;
		}
		if (Type.Belt == id)
		{
			return containerBelt;
		}
		if (Type.Wear == id)
		{
			return containerWear;
		}
		if (Type.BackpackContents == id)
		{
			return GetBackpackWithInventory()?.contents;
		}
		return null;
	}

	public Item GetAnyBackpack()
	{
		return containerWear?.GetSlot(7);
	}

	public bool HasBackpackItem()
	{
		return GetAnyBackpack() != null;
	}

	public Item GetBackpackWithInventory()
	{
		Item anyBackpack = GetAnyBackpack();
		if (anyBackpack == null || anyBackpack.contents == null)
		{
			return null;
		}
		return anyBackpack;
	}

	public void DropBackpackOnDeath(bool wounded)
	{
		if (base.baseEntity.InSafeZone())
		{
			return;
		}
		if (wounded)
		{
			if (!Player.dropbackpackondowned)
			{
				return;
			}
		}
		else if (!Player.dropbackpackondeath)
		{
			return;
		}
		Item anyBackpack = GetAnyBackpack();
		if (anyBackpack != null)
		{
			ItemModBackpack component = ((Component)anyBackpack.info).GetComponent<ItemModBackpack>();
			if (!((Object)(object)component == (Object)null) && component.DropWhenDowned)
			{
				TryDropBackpack();
			}
		}
	}

	public Item GetEquippedPrisonerHoodItem()
	{
		return containerWear.FindItemByItemID(Handcuffs.PrisonerHoodItemID);
	}

	public Item GetUsableHoodItem()
	{
		return FindItemByItemID(Handcuffs.PrisonerHoodItemID);
	}

	public bool GiveItem(Item item, ItemContainer container = null)
	{
		return GiveItem(item, (ItemMoveModifier)0, container);
	}

	public bool GiveItem(Item item, ItemMoveModifier modifiers, ItemContainer container = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		bool tryWearClothing = ((Enum)modifiers).HasFlag((Enum)(object)(ItemMoveModifier)2);
		bool flag = ((Enum)modifiers).HasFlag((Enum)(object)(ItemMoveModifier)16);
		if (item == null)
		{
			return false;
		}
		if (container == null)
		{
			container = GetIdealPickupContainer(item, tryWearClothing);
		}
		if (container != null && item.MoveToContainer(container))
		{
			return true;
		}
		if (item.MoveToContainer(containerMain))
		{
			return true;
		}
		if (flag)
		{
			Item backpackWithInventory = GetBackpackWithInventory();
			if (backpackWithInventory != null && item.MoveToContainer(backpackWithInventory.contents))
			{
				return true;
			}
		}
		if (item.MoveToContainer(containerBelt))
		{
			return true;
		}
		return false;
	}

	public ItemContainer GetIdealPickupContainer(Item item, bool tryWearClothing)
	{
		if (item.MaxStackable() > 1)
		{
			if (containerBelt != null && containerBelt.FindItemByItemID(item.info.itemid) != null)
			{
				return containerBelt;
			}
			if (containerMain != null && containerMain.FindItemByItemID(item.info.itemid) != null)
			{
				return containerMain;
			}
		}
		if (item.info.isWearable && item.info.ItemModWearable.equipOnPickup && item.IsDroppedInWorld(serverside: true))
		{
			Item anyBackpack = GetAnyBackpack();
			if ((Object)(object)((Component)item.info).GetComponent<ItemModShield>() != (Object)null && anyBackpack != null && (Object)(object)((Component)anyBackpack.info).GetComponent<ItemModShield>() != (Object)null)
			{
				if (!containerMain.IsFull())
				{
					return containerMain;
				}
				return containerBelt;
			}
			if (anyBackpack != null && anyBackpack.GetItemVolume() > containerMain.containerVolume && item.GetItemVolume() <= containerMain.containerVolume)
			{
				if (!containerMain.IsFull())
				{
					return containerMain;
				}
				return containerBelt;
			}
			return containerWear;
		}
		if (tryWearClothing && item.info.isWearable && CanWearItem(item, canAdjustClothing: false, item.IsBackpack() ? 7 : (-1)))
		{
			return containerWear;
		}
		if (item.info.isUsable && !item.info.HasFlag(ItemDefinition.Flag.NotStraightToBelt))
		{
			return containerBelt;
		}
		return null;
	}

	public void Strip()
	{
		containerMain.Clear();
		containerBelt.Clear();
		containerWear.Clear();
		ItemManager.DoRemoves();
	}

	public static bool IsBirthday()
	{
		if (forceBirthday)
		{
			return true;
		}
		if (Time.time < nextCheckTime)
		{
			return wasBirthday;
		}
		nextCheckTime = Time.time + 60f;
		DateTime now = DateTime.Now;
		wasBirthday = now.Month == 12 && now.Day >= 7 && now.Day <= 16;
		return wasBirthday;
	}

	public static bool IsChristmas()
	{
		return XMas.enabled;
	}

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", (object)this) != null)
		{
			return;
		}
		Strip();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null && activeGameMode.HasLoadouts())
		{
			BaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);
			return;
		}
		GiveDefaultItemWithSkin("client.rockskin", "rock");
		GiveDefaultItemWithSkin("client.torchskin", "torch");
		if (IsBirthday() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("cakefiveyear", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);
			GiveItem(ItemManager.CreateByName("partyhat", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerWear);
		}
		if (IsChristmas() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", (object)this);
		void GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)
		{
			ulong num = 0uL;
			int infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);
			bool flag = false;
			bool flag2 = false;
			flag2 = base.baseEntity?.UnlockAllSkins ?? false;
			if (infoInt > 0 && (base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID) || flag2))
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);
				if ((Object)(object)itemDefinition != (Object)null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)
				{
					IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);
					if (itemDefinition2 != null)
					{
						num = itemDefinition2.WorkshopDownload;
					}
					if (num == 0L && itemDefinition.skins != null)
					{
						ItemSkinDirectory.Skin[] skins = itemDefinition.skins;
						for (int i = 0; i < skins.Length; i++)
						{
							ItemSkinDirectory.Skin skin = skins[i];
							if (skin.id == infoInt && (Object)(object)skin.invItem != (Object)null && skin.invItem is ItemSkin itemSkin && (Object)(object)itemSkin.Redirect != (Object)null)
							{
								GiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (!flag)
			{
				GiveItem(ItemManager.CreateByName(itemShortName, 1, num).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);
			}
		}
	}

	public bool CanEquipParachute()
	{
		if (ConVar.Server.canEquipBackpacksInAir || Parachute.BypassRepack)
		{
			return true;
		}
		if (base.baseEntity.WaterFactor() > 0.5f)
		{
			return true;
		}
		if (!base.baseEntity.IsOnGround())
		{
			return false;
		}
		if (base.baseEntity.isMounted && Object.op_Implicit((Object)(object)base.baseEntity.GetMounted()) && base.baseEntity.GetMounted().VehicleParent() is Parachute)
		{
			return false;
		}
		return true;
	}

	public PlayerInventory Save(bool bForDisk)
	{
		PlayerInventory val = Pool.Get<PlayerInventory>();
		if (bForDisk)
		{
			val.invMain = containerMain.Save();
		}
		val.invBelt = containerBelt.Save();
		val.invWear = containerWear.Save();
		return val;
	}

	public void Load(PlayerInventory msg)
	{
		if (msg.invMain != null)
		{
			containerMain.Load(msg.invMain);
		}
		if (msg.invBelt != null)
		{
			containerBelt.Load(msg.invBelt);
		}
		if (msg.invWear != null)
		{
			containerWear.Load(msg.invWear);
		}
		if (Object.op_Implicit((Object)(object)base.baseEntity) && base.baseEntity.isServer && containerWear.capacity == 7)
		{
			containerWear.capacity = 8;
		}
	}

	public void TryDropBackpack()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Item anyBackpack = GetAnyBackpack();
		if (anyBackpack != null && base.baseEntity.isServer && Interface.CallHook("OnBackpackDrop", (object)anyBackpack, (object)this) == null)
		{
			anyBackpack.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
		}
	}

	public int Take(List<Item> collect, int itemid, int amount)
	{
		object obj = Interface.CallHook("OnInventoryItemsTake", (object)this, (object)collect, (object)itemid, (object)amount);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			int num2 = containerMain.Take(collect, itemid, amount);
			num += num2;
			amount -= num2;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerBelt != null)
		{
			int num3 = containerBelt.Take(collect, itemid, amount);
			num += num3;
			amount -= num3;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerWear != null)
		{
			int num4 = containerWear.Take(collect, itemid, amount);
			num += num4;
			amount -= num4;
		}
		return num;
	}

	public bool HasEmptySlotInBeltOrMain()
	{
		if (containerMain != null && containerMain.capacity > containerMain.itemList.Count)
		{
			return true;
		}
		if (containerBelt != null && containerBelt.capacity > containerBelt.itemList.Count)
		{
			return true;
		}
		return false;
	}

	public bool HasEmptySlots(int requiredSlots)
	{
		int num = 0;
		if (containerMain != null)
		{
			num += containerMain.capacity - containerMain.itemList.Count;
		}
		if (containerBelt != null)
		{
			num += containerBelt.capacity - containerBelt.itemList.Count;
		}
		return num >= requiredSlots;
	}

	public int GetAmount(ItemDefinition definition)
	{
		if (!((Object)(object)definition != (Object)null))
		{
			return 0;
		}
		return GetAmount(definition.itemid);
	}

	public int GetAmount(int itemid)
	{
		if (itemid == 0)
		{
			return 0;
		}
		object obj = Interface.CallHook("OnInventoryItemsCount", (object)this, (object)itemid);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			num += containerMain.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerBelt != null)
		{
			num += containerBelt.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerWear != null)
		{
			num += containerWear.GetAmount(itemid, onlyUsableAmounts: true);
		}
		return num;
	}

	public int GetOkConditionAmount(int itemid)
	{
		if (itemid == 0)
		{
			return 0;
		}
		int num = 0;
		if (containerMain != null)
		{
			num += containerMain.GetOkConditionAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerBelt != null)
		{
			num += containerBelt.GetOkConditionAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerWear != null)
		{
			num += containerWear.GetOkConditionAmount(itemid, onlyUsableAmounts: true);
		}
		return num;
	}

	public bool Contains(Item item)
	{
		bool flag = containerMain?.itemList.Contains(item) ?? false;
		if (!flag)
		{
			flag = containerBelt?.itemList.Contains(item) ?? false;
		}
		if (!flag)
		{
			flag = containerWear?.itemList.Contains(item) ?? false;
		}
		return flag;
	}

	public int GetAllItems(List<Item> items)
	{
		items.Clear();
		if (containerMain != null)
		{
			items.AddRange(containerMain.itemList);
		}
		if (containerBelt != null)
		{
			items.AddRange(containerBelt.itemList);
		}
		if (containerWear != null)
		{
			items.AddRange(containerWear.itemList);
		}
		return items.Count;
	}

	public Item FindAmmo(AmmoTypes ammoType)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnInventoryAmmoItemFind", (object)this, (object)ammoType);
		if (obj is Item)
		{
			return (Item)obj;
		}
		Item item = containerMain?.FindAmmo(ammoType);
		if (item == null)
		{
			item = containerBelt?.FindAmmo(ammoType);
		}
		return item;
	}

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnInventoryAmmoFind", (object)this, (object)list, (object)ammoType) == null)
		{
			containerMain?.FindAmmo(list, ammoType);
			containerBelt?.FindAmmo(list, ammoType);
		}
	}

	public bool HasAmmo(AmmoTypes ammoType)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!containerMain.HasAmmo(ammoType))
		{
			return containerBelt.HasAmmo(ammoType);
		}
		return true;
	}

	private void OnItemRadiationChanged(Item item, float rads)
	{
		CalculateInventoryRadioactivity();
	}

	private void CalculateInventoryRadioactivity()
	{
		float num = 0f;
		if (containerMain != null)
		{
			num += containerMain.GetRadioactiveMaterialInContainer();
		}
		if (containerBelt != null)
		{
			num += containerBelt.GetRadioactiveMaterialInContainer();
		}
		if (containerWear != null)
		{
			num += containerWear.GetRadioactiveMaterialInContainer();
		}
		inventoryRadioactivity = num;
		bool arg = (containsRadioactiveItems = num > 0f);
		this.onRadioactivityChanged?.Invoke(num, arg);
	}

	private void CalculateInventoryRadioactivityCheckFast()
	{
		if (containsRadioactiveItems)
		{
			CalculateInventoryRadioactivity();
		}
	}
}


public enum Type
{
	Main,
	Belt,
	Wear,
	BackpackContents
}


public interface ICanMoveFrom
{
	bool CanMoveFrom(BasePlayer player, Item item);
}


public enum NetworkInventoryMode
{
	LocalPlayer,
	Everyone,
	EveryoneButLocal
}


using System.Collections.Generic;

private struct WearCheckResult
{
	public bool Result;

	public List<Item> ChangedItem;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class PlayerLoot : EntityComponent<BasePlayer>
{
	public BaseEntity entitySource;

	public Item itemSource;

	public List<ItemContainer> containers = new List<ItemContainer>();

	public bool PositionChecks = true;

	private bool isInvokingSendUpdate;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlayerLoot.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsLooting()
	{
		return containers.Count > 0;
	}

	public float GetRadsInPlayerLoot()
	{
		float num = 0f;
		foreach (ItemContainer container in containers)
		{
			num += container.GetRadioactiveMaterialInContainer();
		}
		return num;
	}

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", (object)this);
		base.baseEntity.HasClosedLoot();
		MarkDirty();
		if (Object.op_Implicit((Object)(object)entitySource))
		{
			((Component)entitySource).SendMessage("PlayerStoppedLooting", (object)base.baseEntity, (SendMessageOptions)1);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		ClearContainers();
		entitySource = null;
		itemSource = null;
	}

	public ItemContainer FindContainer(ItemContainerId id)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		Check();
		if (!IsLooting())
		{
			return null;
		}
		foreach (ItemContainer container in containers)
		{
			ItemContainer itemContainer = container.FindContainer(id);
			if (itemContainer != null)
			{
				return itemContainer;
			}
		}
		return null;
	}

	public Item FindItem(ItemId id)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		Check();
		if (!IsLooting())
		{
			return null;
		}
		foreach (ItemContainer container in containers)
		{
			Item item = container.FindItemByUID(id);
			if (item != null && item.IsValid())
			{
				return item;
			}
		}
		return null;
	}

	public void Check()
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (!IsLooting() || !base.baseEntity.isServer)
		{
			return;
		}
		if ((Object)(object)entitySource == (Object)null)
		{
			base.baseEntity.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.LootableDoesntExist, false);
			Clear();
		}
		else if (!entitySource.CanBeLooted(base.baseEntity) || entitySource.IsTransferring())
		{
			Clear();
		}
		else
		{
			if (!PositionChecks)
			{
				return;
			}
			float num = entitySource.Distance(base.baseEntity.eyes.position);
			if (num > 3f)
			{
				LootDistanceOverride component = ((Component)entitySource).GetComponent<LootDistanceOverride>();
				if ((Object)(object)component == (Object)null || num > component.amount)
				{
					Clear();
				}
			}
		}
	}

	public void MarkDirty()
	{
		if (!isInvokingSendUpdate)
		{
			isInvokingSendUpdate = true;
			((FacepunchBehaviour)this).Invoke((Action)SendUpdate, 0.1f);
		}
	}

	public void SendImmediate()
	{
		if (isInvokingSendUpdate)
		{
			isInvokingSendUpdate = false;
			((FacepunchBehaviour)this).CancelInvoke((Action)SendUpdate);
		}
		SendUpdate();
	}

	private void SendUpdate()
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		isInvokingSendUpdate = false;
		if (!base.baseEntity.IsValid() || Interface.CallHook("OnLootNetworkUpdate", (object)this) != null)
		{
			return;
		}
		PlayerUpdateLoot val = Pool.Get<PlayerUpdateLoot>();
		try
		{
			if (Object.op_Implicit((Object)(object)entitySource) && entitySource.net != null)
			{
				val.entityID = entitySource.net.ID;
			}
			if (itemSource != null)
			{
				val.itemID = itemSource.uid;
			}
			if (containers.Count > 0)
			{
				val.containers = Pool.Get<List<ItemContainer>>();
				foreach (ItemContainer container in containers)
				{
					val.containers.Add(container.Save());
				}
			}
			base.baseEntity.ClientRPC(RpcTarget.Player("UpdateLoot", base.baseEntity), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if (!Object.op_Implicit((Object)(object)targetEntity))
		{
			return false;
		}
		if (!targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			return false;
		}
		Assert.IsTrue(targetEntity.isServer, "Assure is server");
		PositionChecks = doPositionChecks;
		entitySource = targetEntity;
		itemSource = null;
		Interface.CallHook("OnLootEntity", (object)((Component)this).GetComponent<BasePlayer>(), (object)targetEntity);
		MarkDirty();
		if (targetEntity is ILootableEntity lootableEntity)
		{
			lootableEntity.LastLootedBy = base.baseEntity.userID;
			lootableEntity.LastLootedByPlayer = base.baseEntity;
		}
		return true;
	}

	public void AddContainer(ItemContainer container)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		if (container != null)
		{
			containers.Add(container);
			container.onDirty += MarkDirty;
			if ((Object)(object)container.entityOwner != (Object)null)
			{
				base.baseEntity.ProcessMissionEvent(BaseMission.MissionEventType.OPEN_STORAGE, new BaseMission.MissionEventPayload
				{
					UintIdentifier = container.entityOwner.prefabID,
					NetworkIdentifier = container.entityOwner.net.ID,
					WorldPosition = ((Component)container.entityOwner).transform.position
				}, 0f);
			}
		}
	}

	public void RemoveContainer(ItemContainer container)
	{
		if (container != null)
		{
			container.onDirty -= MarkDirty;
			containers.Remove(container);
		}
	}

	public bool RemoveContainerAt(int index)
	{
		if (index < 0 || index >= containers.Count)
		{
			return false;
		}
		if (containers[index] != null)
		{
			containers[index].onDirty -= MarkDirty;
		}
		containers.RemoveAt(index);
		return true;
	}

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			Interface.CallHook("OnLootItem", (object)((Component)this).GetComponent<BasePlayer>(), (object)item);
			MarkDirty();
		}
	}

	private void ClearContainers()
	{
		containers.Clear();
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class PlayerMetabolism : BaseMetabolism<BasePlayer>
{
	public const float HotThreshold = 40f;

	public const float ColdThreshold = 5f;

	public const float OxygenHurtThreshold = 0.5f;

	public const float OxygenDepleteTime = 10f;

	public const float OxygenRefillTime = 1f;

	public MetabolismAttribute temperature = new MetabolismAttribute();

	public MetabolismAttribute poison = new MetabolismAttribute();

	public MetabolismAttribute radiation_level = new MetabolismAttribute();

	public MetabolismAttribute radiation_poison = new MetabolismAttribute();

	public MetabolismAttribute wetness = new MetabolismAttribute();

	public MetabolismAttribute dirtyness = new MetabolismAttribute();

	public MetabolismAttribute oxygen = new MetabolismAttribute();

	public MetabolismAttribute bleeding = new MetabolismAttribute();

	public MetabolismAttribute comfort = new MetabolismAttribute();

	public MetabolismAttribute pending_health = new MetabolismAttribute();

	public bool isDirty;

	private float lastConsumeTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlayerMetabolism.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Reset()
	{
		base.Reset();
		poison.Reset();
		radiation_level.Reset();
		radiation_poison.Reset();
		temperature.Reset();
		oxygen.Reset();
		bleeding.Reset();
		wetness.Reset();
		dirtyness.Reset();
		comfort.Reset();
		pending_health.Reset();
		lastConsumeTime = float.NegativeInfinity;
		isDirty = true;
	}

	public override void ServerUpdate(BaseCombatEntity ownerEntity, float delta)
	{
		base.ServerUpdate(ownerEntity, delta);
		Interface.CallHook("OnPlayerMetabolize", (object)this, (object)ownerEntity, (object)delta);
		if (owner.IsConnected)
		{
			SendChangesToClient();
		}
	}

	internal bool HasChanged()
	{
		bool flag = isDirty;
		flag = calories.HasChanged() || flag;
		flag = hydration.HasChanged() || flag;
		flag = heartrate.HasChanged() || flag;
		flag = poison.HasChanged() || flag;
		flag = radiation_level.HasChanged() || flag;
		flag = radiation_poison.HasChanged() || flag;
		flag = temperature.HasChanged() || flag;
		flag = wetness.HasChanged() || flag;
		flag = dirtyness.HasChanged() || flag;
		flag = comfort.HasChanged() || flag;
		return pending_health.HasChanged() || flag;
	}

	protected override void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta)
	{
		if (owner.IsConnected)
		{
			base.DoMetabolismDamage(ownerEntity, delta);
			if (temperature.value < -20f)
			{
				owner.Hurt(Mathf.InverseLerp(1f, -50f, temperature.value) * delta * 1f, DamageType.Cold);
			}
			else if (temperature.value < -10f)
			{
				owner.Hurt(Mathf.InverseLerp(1f, -50f, temperature.value) * delta * 0.3f, DamageType.Cold);
			}
			else if (temperature.value < 1f)
			{
				owner.Hurt(Mathf.InverseLerp(1f, -50f, temperature.value) * delta * 0.1f, DamageType.Cold);
			}
			if (temperature.value > 60f)
			{
				owner.Hurt(Mathf.InverseLerp(60f, 200f, temperature.value) * delta * 5f, DamageType.Heat);
			}
			if (!owner.IsGod() && bleeding.value > 0f)
			{
				float num = delta * (1f / 3f);
				owner.Hurt(num, DamageType.Bleeding);
				bleeding.Subtract(num);
			}
			if (!owner.IsGod() && poison.value > 0f)
			{
				owner.Hurt(poison.value * delta * 0.1f, DamageType.Poison);
			}
			if (ConVar.Server.radiation && radiation_poison.value > 0f)
			{
				float num2 = (1f + Mathf.Clamp01(radiation_poison.value / 25f) * 5f) * (delta / 5f);
				owner.Hurt(num2, DamageType.Radiation);
				radiation_poison.Subtract(num2);
			}
		}
		if (oxygen.value < 0.5f)
		{
			float num3 = (owner.IsConnected ? 1f : 0.01f);
			owner.Hurt(Mathf.InverseLerp(0.5f, 0f, oxygen.value) * delta * 20f * num3, DamageType.Drowned, null, useProtection: false);
		}
	}

	public bool SignificantBleeding()
	{
		return bleeding.value > 0f;
	}

	public void ForceUpdateWorkbenchFlags()
	{
		owner.InvalidateWorkbenchCache();
		UpdateWorkbenchFlags();
	}

	private void UpdateWorkbenchFlags()
	{
		float currentCraftLevel = owner.currentCraftLevel;
		owner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, currentCraftLevel == 1f);
		owner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, currentCraftLevel == 2f);
		owner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, currentCraftLevel == 3f);
	}

	protected override void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
	{
		//IL_04ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fe: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnRunPlayerMetabolism", (object)this, (object)ownerEntity, (object)delta) != null)
		{
			return;
		}
		if (owner.IsConnected)
		{
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
			float num = owner.currentTemperature;
			float fTarget = owner.currentComfort;
			UpdateWorkbenchFlags();
			owner.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, owner.InSafeZone());
			owner.SetPlayerFlag(BasePlayer.PlayerFlags.NoRespawnZone, owner.InNoRespawnZone());
			owner.SetPlayerFlag(BasePlayer.PlayerFlags.ModifyClan, Clan.editsRequireClanTable && owner.CanModifyClan());
			bool num2 = (Object)(object)activeGameMode == (Object)null || activeGameMode.allowTemperature;
			if (owner.IsInTutorial)
			{
				num = 25f;
			}
			if (num2)
			{
				float num3 = num + GetCoreTempAdjustment() - DeltaWet() * 34f;
				float num4 = Mathf.Clamp(owner.baseProtection.amounts[18] * 1.5f, -1f, 1f);
				float num5 = Mathf.InverseLerp(20f, -50f, num);
				float num6 = Mathf.InverseLerp(20f, 30f, num);
				float fTarget2 = Mathf.Clamp(num3 + num5 * 70f * num4 + num6 * 10f * Mathf.Abs(num4) + heartrate.value * 5f, GetCoreTempMin(), GetCoreTempMax());
				temperature.MoveTowards(fTarget2, delta * 5f);
			}
			else
			{
				temperature.value = 25f;
			}
			if (temperature.value >= 40f)
			{
				fTarget = 0f;
			}
			comfort.MoveTowards(fTarget, delta / 5f);
			float num7 = 0.6f + 0.4f * comfort.value;
			if (calories.value > 100f && owner.healthFraction < num7 && radiation_poison.Fraction() < 0.25f && owner.SecondsSinceAttacked > 10f && !SignificantBleeding() && temperature.value >= 10f && hydration.value > 40f)
			{
				float num8 = Mathf.InverseLerp(calories.min, calories.max, calories.value);
				float num9 = 5f;
				float num10 = num9 * owner.MaxHealth() * 0.8f / 600f;
				num10 += num10 * num8 * 0.5f;
				float num11 = num10 / num9;
				num11 += num11 * comfort.value * 6f;
				ownerEntity.Heal(num11 * delta);
				calories.Subtract(num10 * delta);
				hydration.Subtract(num10 * delta * 0.2f);
			}
			float num12 = owner.estimatedSpeed2D / owner.GetMaxSpeed() * 0.75f;
			float fTarget3 = Mathf.Clamp(0.05f + num12, 0f, 1f);
			heartrate.MoveTowards(fTarget3, delta * 0.1f);
			if (!owner.IsGod())
			{
				float num13 = heartrate.Fraction() * 0.375f;
				calories.MoveTowards(0f, delta * num13);
				float num14 = 1f / 120f;
				num14 += Mathf.InverseLerp(40f, 60f, temperature.value) * (1f / 12f);
				num14 += heartrate.value * (1f / 15f);
				hydration.MoveTowards(0f, delta * num14);
			}
			bool b = hydration.Fraction() <= 0f || radiation_poison.value >= 100f;
			owner.SetPlayerFlag(BasePlayer.PlayerFlags.NoSprint, b);
			if (temperature.value > 40f)
			{
				hydration.Add(Mathf.InverseLerp(40f, 200f, temperature.value) * delta * -1f);
			}
			if (temperature.value < 10f)
			{
				float num15 = Mathf.InverseLerp(20f, -100f, temperature.value);
				heartrate.MoveTowards(Mathf.Lerp(0.2f, 1f, num15), delta * 2f * num15);
			}
			float num16 = 0f;
			float num17 = 0f;
			if (owner.IsOutside(owner.eyes.position))
			{
				num16 = Climate.GetRain(owner.eyes.position) * Weather.wetness_rain;
				num17 = Climate.GetSnow(owner.eyes.position) * Weather.wetness_snow;
			}
			bool flag = owner.baseProtection.amounts[4] > 0f;
			float currentEnvironmentalWetness = owner.currentEnvironmentalWetness;
			currentEnvironmentalWetness = Mathf.Clamp(currentEnvironmentalWetness, 0f, 0.8f);
			float num18 = owner.WaterFactor();
			if (!flag && num18 > 0f)
			{
				wetness.value = Mathf.Max(wetness.value, Mathf.Clamp(num18, wetness.min, wetness.max));
			}
			float num19 = Mathx.Max(wetness.value, num16, num17, currentEnvironmentalWetness);
			num19 = Mathf.Min(num19, flag ? 0f : num19);
			wetness.MoveTowards(num19, delta * 0.05f);
			if (num18 < wetness.value && currentEnvironmentalWetness <= 0f)
			{
				wetness.MoveTowards(0f, delta * 0.2f * Mathf.InverseLerp(0f, 100f, num));
			}
			poison.MoveTowards(0f, delta * (5f / 9f));
			if (wetness.Fraction() > 0.4f && owner.estimatedSpeed > 0.25f && radiation_level.Fraction() == 0f)
			{
				radiation_poison.Subtract(radiation_poison.value * 0.2f * wetness.Fraction() * delta * 0.2f);
			}
			if (ConVar.Server.radiation)
			{
				if (!owner.IsGod())
				{
					float radiationAfterProtection = Radiation.GetRadiationAfterProtection(owner.modifiers.GetValue(Modifier.ModifierType.Radiation), ownerEntity.RadiationProtection());
					radiation_level.value = owner.radiationLevel + radiationAfterProtection;
					if (radiation_level.value > 0f)
					{
						radiation_poison.Add(radiation_level.value * delta);
					}
				}
				else if (radiation_level.value > 0f)
				{
					radiation_level.value = 0f;
					radiation_poison.value = 0f;
				}
			}
			if (pending_health.value > 0f)
			{
				float num20 = 1f + owner.modifiers.GetValue(Modifier.ModifierType.MetabolismBooster);
				float num21 = Mathf.Min(1f * delta * num20, pending_health.value);
				ownerEntity.Heal(num21);
				if (ownerEntity.healthFraction == 1f)
				{
					pending_health.value = 0f;
				}
				else
				{
					pending_health.Subtract(num21);
				}
			}
		}
		float num22 = owner.AirFactor();
		float num23 = ((num22 > oxygen.value) ? 1f : 0.1f);
		oxygen.MoveTowards(num22, delta * num23);
	}

	private float GetCoreTempAdjustment()
	{
		if ((Object)(object)owner == (Object)null)
		{
			return 0f;
		}
		PlayerModifiers modifiers = owner.modifiers;
		if ((Object)(object)modifiers == (Object)null)
		{
			return 0f;
		}
		return 0f + modifiers.GetValue(Modifier.ModifierType.Warming) + modifiers.GetValue(Modifier.ModifierType.Cooling);
	}

	private float GetCoreTempMin()
	{
		if ((Object)(object)owner == (Object)null)
		{
			return temperature.min;
		}
		PlayerModifiers modifiers = owner.modifiers;
		if ((Object)(object)modifiers == (Object)null)
		{
			return temperature.min;
		}
		return modifiers.GetValue(Modifier.ModifierType.CoreTemperatureMinAdjustment, temperature.min);
	}

	private float GetCoreTempMax()
	{
		if ((Object)(object)owner == (Object)null)
		{
			return temperature.max;
		}
		PlayerModifiers modifiers = owner.modifiers;
		if ((Object)(object)modifiers == (Object)null)
		{
			return temperature.max;
		}
		return modifiers.GetValue(Modifier.ModifierType.CoreTemperatureMaxAdjustment, temperature.max);
	}

	private float DeltaHot()
	{
		return Mathf.InverseLerp(20f, 100f, temperature.value);
	}

	private float DeltaCold()
	{
		return Mathf.InverseLerp(20f, -50f, temperature.value);
	}

	private float DeltaWet()
	{
		return wetness.value;
	}

	public void UseHeart(float frate)
	{
		if (heartrate.value > frate)
		{
			heartrate.Add(frate);
		}
		else
		{
			heartrate.value = frate;
		}
	}

	public void SendChangesToClient()
	{
		if (!HasChanged())
		{
			return;
		}
		isDirty = false;
		PlayerMetabolism val = Save();
		try
		{
			base.baseEntity.ClientRPC(RpcTarget.PlayerAndSpectators("UpdateMetabolism", base.baseEntity), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void ApplyChange(MetabolismAttribute.Type type, float amount, float time)
	{
		FindAttribute(type)?.Add(amount);
	}

	public bool CanConsume()
	{
		if (Object.op_Implicit((Object)(object)owner) && owner.IsHeadUnderwater())
		{
			return false;
		}
		return Time.time - lastConsumeTime > 1f;
	}

	public void MarkConsumption()
	{
		lastConsumeTime = Time.time;
	}

	public PlayerMetabolism Save()
	{
		PlayerMetabolism val = Pool.Get<PlayerMetabolism>();
		val.calories = calories.value;
		val.hydration = hydration.value;
		val.heartrate = heartrate.value;
		val.temperature = temperature.value;
		val.radiation_level = radiation_level.value;
		val.radiation_poisoning = radiation_poison.value;
		val.wetness = wetness.value;
		val.dirtyness = dirtyness.value;
		val.oxygen = oxygen.value;
		val.bleeding = bleeding.value;
		val.comfort = comfort.value;
		val.poison = poison.value;
		val.pending_health = pending_health.value;
		if (Object.op_Implicit((Object)(object)owner))
		{
			val.health = owner.Health();
		}
		return val;
	}

	public void Load(PlayerMetabolism s)
	{
		calories.SetValue(s.calories);
		hydration.SetValue(s.hydration);
		comfort.SetValue(s.comfort);
		heartrate.value = s.heartrate;
		temperature.value = s.temperature;
		radiation_level.value = s.radiation_level;
		radiation_poison.value = s.radiation_poisoning;
		wetness.value = s.wetness;
		dirtyness.value = s.dirtyness;
		oxygen.value = s.oxygen;
		bleeding.value = s.bleeding;
		poison.value = s.poison;
		pending_health.value = s.pending_health;
		if (Object.op_Implicit((Object)(object)owner))
		{
			owner.health = s.health;
		}
	}

	public void SetAttribute(MetabolismAttribute.Type type, float amount)
	{
		MetabolismAttribute metabolismAttribute = FindAttribute(type);
		if (metabolismAttribute != null)
		{
			float num = metabolismAttribute.value - amount;
			metabolismAttribute.Add(0f - num);
		}
	}

	public override MetabolismAttribute FindAttribute(MetabolismAttribute.Type type)
	{
		return type switch
		{
			MetabolismAttribute.Type.Poison => poison, 
			MetabolismAttribute.Type.Bleeding => bleeding, 
			MetabolismAttribute.Type.Radiation => radiation_poison, 
			MetabolismAttribute.Type.HealthOverTime => pending_health, 
			_ => base.FindAttribute(type), 
		};
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class PlayerModifiers : BaseModifiers<BasePlayer>
{
	public List<ModifierLimits> Limits;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlayerModifiers.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static void AddToPlayer(BasePlayer player, List<ModifierDefintion> modifiers, float effectScale = 1f, float durationScale = 1f)
	{
		if (!((Object)(object)player == (Object)null) && !((Object)(object)player.modifiers == (Object)null) && modifiers != null)
		{
			player.modifiers.Add(modifiers, effectScale, durationScale);
		}
	}

	protected override bool IsCompatible(Modifier.ModifierType modType)
	{
		if ((uint)(modType - 20) <= 1u)
		{
			return false;
		}
		return true;
	}

	public override void ServerUpdate(BaseCombatEntity ownerEntity)
	{
		base.ServerUpdate(ownerEntity);
		SendChangesToClient();
	}

	public PlayerModifiers Save(bool forDisk)
	{
		PlayerModifiers val = Pool.Get<PlayerModifiers>();
		val.modifiers = Pool.Get<List<Modifier>>();
		float value = GetValue(Modifier.ModifierType.DigestionBoost, 1f);
		foreach (Modifier item in All)
		{
			if (item != null && (!forDisk || item.Source != Modifier.ModifierSource.Interaction))
			{
				Modifier val2 = item.Save();
				if (!forDisk && value > 1f && IsModifierCompatibleWithDigestionBoost(item.Type))
				{
					val2.duration *= value - 1f;
					val2.timeRemaining *= (double)(value - 1f);
					val2.value *= value;
				}
				val.modifiers.Add(val2);
			}
		}
		return val;
	}

	public void Load(PlayerModifiers m, bool fromDisk)
	{
		RemoveAll();
		if (m == null || m.modifiers == null)
		{
			return;
		}
		foreach (Modifier modifier2 in m.modifiers)
		{
			if (modifier2 != null && (!fromDisk || modifier2.source != 2))
			{
				Modifier modifier = new Modifier();
				modifier.Init((Modifier.ModifierType)modifier2.type, (Modifier.ModifierSource)modifier2.source, modifier2.value, modifier2.duration, modifier2.timeRemaining);
				Add(modifier);
			}
		}
	}

	protected override int GetMaxModifierCount(Modifier modifier)
	{
		return GetModifierLimitForSourceAndType(modifier)?.MaxApplications ?? base.GetMaxModifierCount(modifier);
	}

	protected override float GetClampedValue(Modifier modifier, float value)
	{
		ModifierLimits modifierLimitsForType = GetModifierLimitsForType(modifier);
		if (modifierLimitsForType != null)
		{
			return Mathf.Clamp(value, modifierLimitsForType.minValue, modifierLimitsForType.maxValue);
		}
		return value;
	}

	protected ModifierLimit GetModifierLimitForSourceAndType(Modifier modifier)
	{
		if (Limits != null)
		{
			foreach (ModifierLimits limit in Limits)
			{
				if (limit == null || limit.type != modifier.Type)
				{
					continue;
				}
				foreach (ModifierLimit limit2 in limit.limits)
				{
					if (limit2 != null && limit2.source == modifier.Source)
					{
						return limit2;
					}
				}
			}
		}
		return null;
	}

	protected ModifierLimits GetModifierLimitsForType(Modifier modifier)
	{
		if (Limits != null)
		{
			foreach (ModifierLimits limit in Limits)
			{
				if (limit != null && limit.type == modifier.Type)
				{
					return limit;
				}
			}
		}
		return null;
	}

	public void SendChangesToClient()
	{
		if (!dirty)
		{
			return;
		}
		SetDirty(flag: false);
		PlayerModifiers val = Save(forDisk: false);
		try
		{
			base.baseEntity.ClientRPC(RpcTarget.Player("UpdateModifiers", base.baseEntity), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;

public class PowerCounter : IOEntity
{
	public int counterNumber;

	public int targetCounterNumber = 10;

	public Canvas canvas;

	public CanvasGroup screenAlpha;

	public Text screenText;

	public const Flags Flag_ShowPassthrough = Flags.Reserved2;

	public GameObjectRef counterConfigPanel;

	public Color passthroughColor;

	public Color counterColor;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PowerCounter.OnRpcMessage", 0);
		try
		{
			if (rpc == 3554226761u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_SetTarget "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_SetTarget", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3554226761u, "SERVER_SetTarget", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_SetTarget(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_SetTarget");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3222475159u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ToggleDisplayMode "));
				}
				TimeWarning val2 = TimeWarning.New("ToggleDisplayMode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3222475159u, "ToggleDisplayMode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ToggleDisplayMode(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ToggleDisplayMode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool DisplayPassthrough()
	{
		return HasFlag(Flags.Reserved2);
	}

	public bool DisplayCounter()
	{
		return !DisplayPassthrough();
	}

	public bool CanPlayerAdmin(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			return player.CanBuild();
		}
		return false;
	}

	public int GetTarget()
	{
		return targetCounterNumber;
	}

	public override void ResetState()
	{
		base.ResetState();
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_SetTarget(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (Interface.CallHook("OnCounterTargetChange", (object)this, (object)msg.player, (object)num) == null && CanPlayerAdmin(msg.player))
		{
			targetCounterNumber = num;
			MarkDirty();
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ToggleDisplayMode(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnCounterModeToggle", (object)this, (object)msg.player, (object)flag) == null && msg.player.CanBuild())
		{
			SetFlag(Flags.Reserved2, flag, recursive: false, networkupdate: false);
			MarkDirty();
			SendNetworkUpdate();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (DisplayPassthrough())
		{
			return GetCurrentEnergy();
		}
		if (counterNumber >= targetCounterNumber)
		{
			return base.GetPassthroughAmount(outputSlot);
		}
		return 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex != 0)
		{
			return false;
		}
		if (DisplayPassthrough())
		{
			return true;
		}
		return counterNumber >= targetCounterNumber;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.ioEntity == null)
		{
			info.msg.ioEntity = Pool.Get<IOEntity>();
		}
		info.msg.ioEntity.genericInt1 = counterNumber;
		info.msg.ioEntity.genericInt2 = GetPassthroughAmount();
		info.msg.ioEntity.genericInt3 = GetTarget();
	}

	public void SetCounterNumber(int newNumber)
	{
		counterNumber = newNumber;
	}

	public override void SendIONetworkUpdate()
	{
		SendNetworkUpdate();
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (DisplayCounter() && inputAmount > 0 && inputSlot != 0)
		{
			int num = counterNumber;
			switch (inputSlot)
			{
			case 1:
				counterNumber++;
				break;
			case 2:
				counterNumber--;
				if (counterNumber < 0)
				{
					counterNumber = 0;
				}
				break;
			case 3:
				counterNumber = 0;
				break;
			}
			counterNumber = Mathf.Clamp(counterNumber, 0, 999);
			if (num != counterNumber)
			{
				MarkDirty();
				SendNetworkUpdate();
			}
		}
		if (inputSlot == 0)
		{
			base.UpdateFromInput(inputAmount, inputSlot);
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			if (base.isServer)
			{
				counterNumber = info.msg.ioEntity.genericInt1;
			}
			targetCounterNumber = info.msg.ioEntity.genericInt3;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class PoweredLightsDeployer : HeldEntity
{
	public GameObjectRef poweredLightsPrefab;

	public EntityRef activeLights;

	public MaterialReplacement guide;

	public GameObject guideObject;

	public float maxPlaceDistance = 5f;

	public float lengthPerAmount = 0.5f;

	private const int placementLayerMask = 10551297;

	public AdvancedChristmasLights active
	{
		get
		{
			BaseEntity baseEntity = activeLights.Get(base.isServer);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				return ((Component)baseEntity).GetComponent<AdvancedChristmasLights>();
			}
			return null;
		}
		set
		{
			activeLights.Set(value);
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PoweredLightsDeployer.OnRpcMessage", 0);
		try
		{
			if (rpc == 447739874 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AddPoint "));
				}
				TimeWarning val2 = TimeWarning.New("AddPoint", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(447739874u, "AddPoint", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AddPoint(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AddPoint");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1975273522 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Finish "));
				}
				TimeWarning val2 = TimeWarning.New("Finish", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1975273522u, "Finish", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Finish(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Finish");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private bool CheckValidPlacement(Vector3 position, float radius, int layerMask)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		bool result = true;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, radius, list, layerMask, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (item is AnimatedBuildingBlock)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}

	public static bool CanPlayerUse(BasePlayer player)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (player.CanBuild())
		{
			return !GamePhysics.CheckSphere(player.eyes.position, 0.1f, 536870912, (QueryTriggerInteraction)2);
		}
		return false;
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	public void AddPoint(RPCMessage msg)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		float num = msg.read.Float();
		BasePlayer player = msg.player;
		if (Vector3Ex.IsNaNOrInfinity(val) || Vector3Ex.IsNaNOrInfinity(val2) || FloatEx.IsNaNOrInfinity(num) || GetItem() == null || GetItem().amount < 1 || !IsVisible(val) || !CanPlayerUse(player) || Vector3.Distance(val, player.eyes.position) > maxPlaceDistance || !CheckValidPlacement(val, 0.1f, 10551297) || Interface.CallHook("OnPoweredLightsPointAdd", (object)this, (object)player, (object)val, (object)val2) != null)
		{
			return;
		}
		int num2 = 1;
		if ((Object)(object)active == (Object)null)
		{
			AdvancedChristmasLights component = ((Component)GameManager.server.CreateEntity(poweredLightsPrefab.resourcePath, val, Quaternion.LookRotation(val2, player.eyes.HeadUp()))).GetComponent<AdvancedChristmasLights>();
			component.Spawn();
			active = component;
			num2 = 1;
			if (player.IsInCreativeMode && Creative.unlimitedIo)
			{
				num2 = 0;
			}
		}
		else
		{
			if (active.IsFinalized())
			{
				return;
			}
			float num3 = 0f;
			Vector3 val3 = ((Component)active).transform.position;
			if (active.points.Count > 0)
			{
				val3 = active.points[active.points.Count - 1].point;
				num3 = Vector3.Distance(val, val3);
			}
			num3 = Mathf.Max(num3, lengthPerAmount);
			float num4 = (float)GetItem().amount * lengthPerAmount;
			if (player.IsInCreativeMode && Creative.unlimitedIo)
			{
				num4 = 200f;
			}
			if (num3 > num4)
			{
				num3 = num4;
				val = val3 + Vector3Ex.Direction(val, val3) * num3;
			}
			num3 = Mathf.Min(num4, num3);
			num2 = Mathf.CeilToInt(num3 / lengthPerAmount);
			if (player.IsInCreativeMode && Creative.unlimitedIo)
			{
				num2 = 0;
			}
		}
		active.AddPoint(val, val2, num);
		SetFlag(Flags.Reserved8, (Object)(object)active != (Object)null);
		int iAmount = num2;
		UseItemAmount(iAmount);
		active.AddLengthUsed(num2);
		SendNetworkUpdate();
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	public void Finish(RPCMessage msg)
	{
		DoFinish();
	}

	public void DoFinish()
	{
		if (Object.op_Implicit((Object)(object)active))
		{
			active.FinishEditing();
		}
		active = null;
		SendNetworkUpdate();
	}

	public override void OnHeldChanged()
	{
		DoFinish();
		active = null;
		base.OnHeldChanged();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.lightDeployer = Pool.Get<LightDeployer>();
			info.msg.lightDeployer.active = activeLights.uid;
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class PoweredRemoteControlEntity : IOEntity, IRemoteControllable
{
	public string rcIdentifier = "";

	public Transform viewEyes;

	public GameObjectRef IDPanelPrefab;

	public RemoteControllableControls rcControls;

	public bool isStatic;

	public bool appendEntityIDToIdentifier;

	public virtual bool RequiresMouse => false;

	public virtual float MaxRange => 10000f;

	public RemoteControllableControls RequiredControls => rcControls;

	public bool CanPing => EntityCanPing;

	protected virtual bool EntityCanPing => false;

	public virtual bool CanAcceptInput => false;

	public int ViewerCount { get; set; }

	public CameraViewerId? ControllingViewerId { get; set; }

	public bool IsBeingControlled
	{
		get
		{
			if (ViewerCount > 0)
			{
				return ControllingViewerId.HasValue;
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PoweredRemoteControlEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 1677685895 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestOpenRCPanel "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestOpenRCPanel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_RequestOpenRCPanel(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_RequestOpenRCPanel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1053317251 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetID "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetID", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1053317251u, "Server_SetID", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_SetID(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_SetID");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsStatic()
	{
		return isStatic;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		UpdateRCAccess(IsPowered());
	}

	public void UpdateRCAccess(bool isOnline)
	{
		if (isOnline)
		{
			RemoteControlEntity.InstallControllable(this);
		}
		else
		{
			RemoteControlEntity.RemoveControllable(this);
		}
	}

	public override void Spawn()
	{
		base.Spawn();
		string text = "#ID";
		if (IsStatic() && rcIdentifier.Contains(text))
		{
			int length = rcIdentifier.IndexOf(text);
			_ = text.Length;
			string text2 = rcIdentifier.Substring(0, length);
			text2 += ((object)(NetworkableId)(ref net.ID)/*cast due to .constrained prefix*/).ToString();
			UpdateIdentifier(text2);
		}
	}

	public virtual bool InitializeControl(CameraViewerId viewerID)
	{
		ViewerCount++;
		if (CanAcceptInput && !ControllingViewerId.HasValue)
		{
			ControllingViewerId = viewerID;
			return true;
		}
		return !CanAcceptInput;
	}

	public virtual void StopControl(CameraViewerId viewerID)
	{
		ViewerCount--;
		if (ControllingViewerId == viewerID)
		{
			ControllingViewerId = null;
		}
	}

	public virtual void UserInput(InputState inputState, CameraViewerId viewerID)
	{
	}

	public Transform GetEyes()
	{
		return viewEyes;
	}

	public virtual float GetFovScale()
	{
		return 1f;
	}

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", (object)this, (object)playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsPowered())
		{
			return IsStatic();
		}
		return true;
	}

	public BaseEntity GetEnt()
	{
		return this;
	}

	public virtual void RCSetup()
	{
	}

	public virtual void RCShutdown()
	{
		if (base.isServer)
		{
			RemoteControlEntity.RemoveControllable(this);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_SetID(RPCMessage msg)
	{
		if (IsStatic())
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!CanChangeID(player))
		{
			return;
		}
		string text = msg.read.String(256, false);
		if (string.IsNullOrEmpty(text) || ComputerStation.IsValidIdentifier(text))
		{
			string text2 = msg.read.String(256, false);
			if (ComputerStation.IsValidIdentifier(text2) && text == GetIdentifier())
			{
				UpdateIdentifier(text2);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.MaxDistance(3f)]
	public void SERVER_RequestOpenRCPanel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanChangeID(player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_OpenRCPanel", player), GetIdentifier());
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk || IsStatic())
		{
			info.msg.rcEntity = Pool.Get<RCEntity>();
			info.msg.rcEntity.identifier = GetIdentifier();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.rcEntity != null && ComputerStation.IsValidIdentifier(info.msg.rcEntity.identifier))
		{
			UpdateIdentifier(info.msg.rcEntity.identifier);
		}
	}

	public void UpdateIdentifier(string newID, bool clientSend = false)
	{
		if (Interface.CallHook("OnRemoteIdentifierUpdate", (object)this, (object)newID) != null)
		{
			return;
		}
		_ = rcIdentifier;
		if (base.isServer)
		{
			if (!RemoteControlEntity.IDInUse(newID))
			{
				rcIdentifier = newID;
			}
			if (!Application.isLoadingSave)
			{
				SendNetworkUpdate();
			}
		}
	}

	public string GetIdentifier()
	{
		return rcIdentifier;
	}

	public override void InitShared()
	{
		base.InitShared();
		RCSetup();
	}

	public override void DestroyShared()
	{
		RCShutdown();
		base.DestroyShared();
	}

	public bool CanChangeID(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null && player.CanBuild())
		{
			return player.IsBuildingAuthed();
		}
		return false;
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class PressButton : IOEntity
{
	public float pressDuration = 5f;

	public float pressPowerTime = 0.5f;

	public int pressPowerAmount = 2;

	public const Flags Flag_EmittingPower = Flags.Reserved3;

	public bool smallBurst;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PressButton.OnRpcMessage", 0);
		try
		{
			if (rpc == 4188121069u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Press "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Press", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4188121069u, "RPC_Press", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Press(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Press");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void ResetIOState()
	{
		base.ResetIOState();
		SetFlag(Flags.On, b: false);
		SetFlag(Flags.Reserved3, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)Unpress);
		((FacepunchBehaviour)this).CancelInvoke((Action)UnpowerTime);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (IsOn())
		{
			if ((Object)(object)sourceItem != (Object)null || smallBurst)
			{
				if (HasFlag(Flags.Reserved3))
				{
					return Mathf.Max(pressPowerAmount, base.GetPassthroughAmount());
				}
				return 0;
			}
			return base.GetPassthroughAmount();
		}
		return 0;
	}

	public void UnpowerTime()
	{
		SetFlag(Flags.Reserved3, b: false);
		MarkDirty();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.On, b: false);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Press(RPCMessage msg)
	{
		if (Interface.CallHook("OnButtonPress", (object)this, (object)msg.player) == null)
		{
			Press();
		}
	}

	public void Press()
	{
		if (!IsOn())
		{
			SetFlag(Flags.On, b: true);
			((FacepunchBehaviour)this).Invoke((Action)UnpowerTime, pressPowerTime);
			SetFlag(Flags.Reserved3, b: true);
			SendNetworkUpdateImmediate();
			MarkDirty();
			((FacepunchBehaviour)this).Invoke((Action)Unpress, pressDuration);
		}
	}

	public void Unpress()
	{
		SetFlag(Flags.On, b: false);
		MarkDirty();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericFloat1 = pressDuration;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			pressDuration = info.msg.ioEntity.genericFloat1;
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class ProceduralLift : BaseEntity
{
	public float movementSpeed = 1f;

	public float resetDelay = 5f;

	public ProceduralLiftCabin cabin;

	public ProceduralLiftStop[] stops;

	public GameObjectRef triggerPrefab;

	public string triggerBone;

	private int floorIndex = -1;

	public SoundDefinition startSoundDef;

	public SoundDefinition stopSoundDef;

	public SoundDefinition movementLoopSoundDef;

	private Sound movementLoopSound;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ProceduralLift.OnRpcMessage", 0);
		try
		{
			if (rpc == 2657791441u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_UseLift "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_UseLift", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2657791441u, "RPC_UseLift", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_UseLift(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_UseLift");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Spawn()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(triggerPrefab.resourcePath, Vector3.zero, Quaternion.identity);
			baseEntity.Spawn();
			baseEntity.SetParent(this, triggerBone);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_UseLift(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && Interface.CallHook("OnLiftUse", (object)this, (object)rpc.player) == null && !IsBusy())
		{
			MoveToFloor((floorIndex + 1) % stops.Length);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SnapToFloor(0);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.lift = Pool.Get<Lift>();
		info.msg.lift.floor = floorIndex;
	}

	public override void Load(LoadInfo info)
	{
		if (info.msg.lift != null)
		{
			if (floorIndex == -1)
			{
				SnapToFloor(info.msg.lift.floor);
			}
			else
			{
				MoveToFloor(info.msg.lift.floor);
			}
		}
		base.Load(info);
	}

	private void ResetLift()
	{
		MoveToFloor(0);
	}

	private void MoveToFloor(int floor)
	{
		floorIndex = Mathf.Clamp(floor, 0, stops.Length - 1);
		if (base.isServer)
		{
			SetFlag(Flags.Busy, b: true);
			SendNetworkUpdateImmediate();
			((FacepunchBehaviour)this).CancelInvoke((Action)ResetLift);
		}
	}

	private void SnapToFloor(int floor)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		floorIndex = Mathf.Clamp(floor, 0, stops.Length - 1);
		ProceduralLiftStop proceduralLiftStop = stops[floorIndex];
		((Component)cabin).transform.position = ((Component)proceduralLiftStop).transform.position;
		if (base.isServer)
		{
			SetFlag(Flags.Busy, b: false);
			SendNetworkUpdateImmediate();
			((FacepunchBehaviour)this).CancelInvoke((Action)ResetLift);
		}
	}

	private void OnFinishedMoving()
	{
		if (base.isServer)
		{
			SetFlag(Flags.Busy, b: false);
			SendNetworkUpdateImmediate();
			if (floorIndex != 0)
			{
				((FacepunchBehaviour)this).Invoke((Action)ResetLift, resetDelay);
			}
		}
	}

	protected void Update()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (floorIndex < 0 || floorIndex > stops.Length - 1)
		{
			return;
		}
		ProceduralLiftStop proceduralLiftStop = stops[floorIndex];
		if (!(((Component)cabin).transform.position == ((Component)proceduralLiftStop).transform.position))
		{
			((Component)cabin).transform.position = Vector3.MoveTowards(((Component)cabin).transform.position, ((Component)proceduralLiftStop).transform.position, movementSpeed * Time.deltaTime);
			if (((Component)cabin).transform.position == ((Component)proceduralLiftStop).transform.position)
			{
				OnFinishedMoving();
			}
		}
	}

	public void StartMovementSounds()
	{
	}

	public void StopMovementSounds()
	{
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ProjectileWeaponMod : BaseEntity
{
	public enum SilencerType
	{
		Military,
		OilFilter,
		SodaCan
	}

	[Serializable]
	public struct Modifier
	{
		public bool enabled;

		[Tooltip("1 means no change. 0.5 is half.")]
		public float scalar;

		[Tooltip("Added after the scalar is applied.")]
		public float offset;
	}

	public float ConditionLossMultiplier = 1f;

	[Header("AttackEffectAdditive")]
	public GameObjectRef additiveEffect;

	[Header("Silencer")]
	public GameObjectRef defaultSilencerEffect;

	public bool isSilencer;

	public SilencerType silencerType;

	private static TimeSince lastADSTime;

	private static TimeSince lastToastTime;

	public static Phrase ToggleZoomToastPhrase = new Phrase("toast.toggle_zoom", "Press [PageUp] and [PageDown] to toggle scope zoom level");

	[Header("Weapon Basics")]
	public Modifier repeatDelay;

	public Modifier projectileVelocity;

	public Modifier projectileDamage;

	public Modifier projectileDistance;

	[Header("Recoil")]
	public Modifier aimsway;

	public Modifier aimswaySpeed;

	public Modifier recoil;

	[Header("Aim Cone")]
	public Modifier sightAimCone;

	public Modifier hipAimCone;

	[Header("Light Effects")]
	public bool isLight;

	[Header("MuzzleBrake")]
	public bool isMuzzleBrake;

	[Header("MuzzleBoost")]
	public bool isMuzzleBoost;

	[Header("Scope")]
	public bool isScope;

	public float zoomAmountDisplayOnly;

	[Header("Magazine")]
	public Modifier magazineCapacity;

	[Header("Toggling")]
	public bool needsOnForEffects;

	[Header("Burst")]
	public int burstCount = -1;

	public float timeBetweenBursts;

	[Header("Zoom")]
	public float[] zoomLevels;

	public GameObjectRef fovChangeEffect;

	[Header("Targeting")]
	public bool allowPings;

	private int serverZoomLevel;

	private bool hasZoomBeenInit;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ProjectileWeaponMod.OnRpcMessage", 0);
		try
		{
			if (rpc == 3713130066u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetZoomLevel "));
				}
				TimeWarning val2 = TimeWarning.New("SetZoomLevel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(3713130066u, "SetZoomLevel", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							int zoomLevel = msg.read.Int32();
							SetZoomLevel(zoomLevel);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetZoomLevel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		SetFlag(Flags.Disabled, b: true);
		base.ServerInit();
	}

	public override void PostServerLoad()
	{
		base.limitNetworking = HasFlag(Flags.Disabled);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.projectileWeaponMod = Pool.Get<GunWeaponMod>();
		info.msg.projectileWeaponMod.zoomLevel = serverZoomLevel;
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void SetZoomLevel(int zoomLevel)
	{
		serverZoomLevel = zoomLevel;
		SendNetworkUpdate();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.projectileWeaponMod != null)
		{
			serverZoomLevel = info.msg.projectileWeaponMod.zoomLevel;
		}
	}

	public static float Mult(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (parentEnt.children == null)
		{
			return def;
		}
		return Mult(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value, def, bypassModToggles);
	}

	public static float Mult(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (mods == null)
		{
			return def;
		}
		return Multiply(GetMods(mods, selector_modifier, selector_value, bypassModToggles));
	}

	private static float Multiply(IEnumerable<float> scalars)
	{
		float num = 1f;
		foreach (float scalar in scalars)
		{
			num *= scalar;
		}
		return num;
	}

	public static float Sum(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (parentEnt.children == null)
		{
			return def;
		}
		return Sum(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value, def);
	}

	public static float Sum(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (mods == null)
		{
			return def;
		}
		IEnumerable<float> mods2 = GetMods(mods, selector_modifier, selector_value, bypassModToggles);
		if (mods2.Count() != 0)
		{
			return mods2.Sum();
		}
		return def;
	}

	public static float Average(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (parentEnt.children == null)
		{
			return def;
		}
		return Average(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value, def);
	}

	public static float Average(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (mods == null)
		{
			return def;
		}
		IEnumerable<float> mods2 = GetMods(mods, selector_modifier, selector_value, bypassModToggles);
		if (mods2.Count() != 0)
		{
			return mods2.Average();
		}
		return def;
	}

	public static float Max(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (parentEnt.children == null)
		{
			return def;
		}
		return Max(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value, def);
	}

	public static float Max(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (mods == null)
		{
			return def;
		}
		IEnumerable<float> mods2 = GetMods(mods, selector_modifier, selector_value, bypassModToggles);
		if (mods2.Count() != 0)
		{
			return mods2.Max();
		}
		return def;
	}

	public static float Min(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (parentEnt.children == null)
		{
			return def;
		}
		return Min(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value, def);
	}

	public static float Min(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (mods == null)
		{
			return def;
		}
		IEnumerable<float> mods2 = GetMods(mods, selector_modifier, selector_value, bypassModToggles);
		if (mods2.Count() != 0)
		{
			return mods2.Min();
		}
		return def;
	}

	public static IEnumerable<float> GetMods(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value)
	{
		return GetMods(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value);
	}

	public static IEnumerable<float> GetMods(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, bool bypassModToggles = false)
	{
		return (from x in mods.Where((ProjectileWeaponMod x) => (Object)(object)x != (Object)null && (!x.needsOnForEffects || bypassModToggles || x.HasFlag(Flags.On))).Select(selector_modifier)
			where x.enabled
			select x).Select(selector_value);
	}

	public static bool HasBrokenWeaponMod(BaseEntity parentEnt)
	{
		if (parentEnt.children == null)
		{
			return false;
		}
		if (parentEnt.children.Cast<ProjectileWeaponMod>().Any((ProjectileWeaponMod x) => (Object)(object)x != (Object)null && x.IsBroken()))
		{
			return true;
		}
		return false;
	}
}


public enum SilencerType
{
	Military,
	OilFilter,
	SodaCan
}


using System;
using UnityEngine;

[Serializable]
public struct Modifier
{
	public bool enabled;

	[Tooltip("1 means no change. 0.5 is half.")]
	public float scalar;

	[Tooltip("Added after the scalar is applied.")]
	public float offset;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Utility;
using Network;
using ProtoBuf;
using UnityEngine;

public class Ragdoll : EntityComponent<BaseEntity>, IPrefabPreProcess
{
	[Header("Ragdoll")]
	[Tooltip("If true, ragdoll physics are simulated on the server instead of the client")]
	public bool simOnServer;

	public float lerpToServerSimTime = 0.5f;

	public Transform eyeTransform;

	public Rigidbody primaryBody;

	[ReadOnly]
	public SpringJoint corpseJoint;

	[SerializeField]
	private PhysicMaterial physicMaterial;

	[SerializeField]
	private Skeleton skeleton;

	[SerializeField]
	private Model model;

	[ReadOnly]
	public List<Rigidbody> rigidbodies = new List<Rigidbody>();

	[ReadOnly]
	[SerializeField]
	private List<Transform> rbTransforms = new List<Transform>();

	[ReadOnly]
	[SerializeField]
	private List<Joint> joints = new List<Joint>();

	[ReadOnly]
	[SerializeField]
	private List<CharacterJoint> characterJoints = new List<CharacterJoint>();

	[SerializeField]
	[ReadOnly]
	private List<ConfigurableJoint> configurableJoints = new List<ConfigurableJoint>();

	[SerializeField]
	[ReadOnly]
	private List<Collider> colliders = new List<Collider>();

	[SerializeField]
	[ReadOnly]
	private int[] boneIndex;

	[SerializeField]
	[ReadOnly]
	private Vector3[] genericBonePos;

	[ReadOnly]
	[SerializeField]
	private Quaternion[] genericBoneRot;

	[SerializeField]
	private GameObject GibEffect;

	protected bool isSetUp;

	private const float MAX_JOINT_DIST = 2f;

	private bool wasSyncingJoints = true;

	protected bool IsClient => false;

	protected bool isServer => !IsClient;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public bool IsSleeping => !rigidbodies[0].IsSleeping();

	public bool IsKinematic => rigidbodies[0].isKinematic;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Ragdoll.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private void SetUpPhysics(bool isServer)
	{
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		if (isSetUp)
		{
			return;
		}
		isSetUp = true;
		if (isServer != simOnServer)
		{
			return;
		}
		foreach (Joint joint in joints)
		{
			joint.enablePreprocessing = false;
		}
		foreach (CharacterJoint characterJoint in characterJoints)
		{
			characterJoint.enableProjection = true;
		}
		foreach (ConfigurableJoint configurableJoint in configurableJoints)
		{
			configurableJoint.projectionMode = (JointProjectionMode)1;
		}
		SetInterpolationMode(((Component)this).transform.parent, isServer);
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			SetCollisionMode(rigidbody, isServer);
			rigidbody.excludeLayers = LayerMask.op_Implicit(LayerMask.op_Implicit(rigidbody.excludeLayers) | 0x1200);
			rigidbody.angularDrag = 1f;
			rigidbody.drag = 1f;
			rigidbody.detectCollisions = true;
			if (isServer)
			{
				rigidbody.solverIterations = 40;
			}
			else
			{
				rigidbody.solverIterations = 20;
			}
			rigidbody.solverVelocityIterations = 10;
			rigidbody.maxDepenetrationVelocity = 2f;
			rigidbody.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
			if (rigidbody.mass < 1f)
			{
				rigidbody.mass = 1f;
			}
			Vector3 val = rigidbody.velocity;
			if (((Vector3)(ref val)).sqrMagnitude < 0.25f)
			{
				rigidbody.velocity += Random.onUnitSphere * 2.5f;
			}
			val = rigidbody.angularVelocity;
			if (((Vector3)(ref val)).sqrMagnitude < 0.25f)
			{
				rigidbody.angularVelocity += Random.onUnitSphere * 2.5f;
			}
		}
	}

	public void ParentChanging(BaseCorpse corpse, Transform newParent)
	{
		SetInterpolationMode(newParent, corpse.isServer);
	}

	private void SetInterpolationMode(Transform parent, bool isServer)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (isServer != simOnServer)
		{
			return;
		}
		RigidbodyInterpolation interpolation = (simOnServer ? ((RigidbodyInterpolation)0) : (((Object)(object)parent == (Object)null) ? ((RigidbodyInterpolation)1) : ((!AnyParentMoves(parent)) ? ((RigidbodyInterpolation)1) : ((RigidbodyInterpolation)0))));
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			rigidbody.interpolation = interpolation;
		}
	}

	private bool AnyParentMoves(Transform parent)
	{
		while ((Object)(object)parent != (Object)null)
		{
			BaseEntity component = ((Component)parent).GetComponent<BaseEntity>();
			if ((Object)(object)component != (Object)null && component.syncPosition)
			{
				return true;
			}
			parent = parent.parent;
		}
		return false;
	}

	private static void SetCollisionMode(Rigidbody rigidBody, bool isServer)
	{
		int serverragdollmode = Physics.serverragdollmode;
		if (serverragdollmode <= 0)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)0;
		}
		if (serverragdollmode == 1)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)1;
		}
		if (serverragdollmode == 2)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)2;
		}
		if (serverragdollmode >= 3)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)3;
		}
	}

	public void MoveRigidbodiesToRoot()
	{
		foreach (Transform rbTransform in rbTransforms)
		{
			rbTransform.SetParent(((Component)this).transform, true);
		}
	}

	public override void LoadComponent(BaseNetworkable.LoadInfo info)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		if (simOnServer && info.msg.ragdoll != null && isServer)
		{
			for (int i = 0; i < rbTransforms.Count; i++)
			{
				rbTransforms[i].localPosition = Compression.UnpackVector3FromInt(info.msg.ragdoll.positions[i], -2f, 2f);
				rbTransforms[i].localEulerAngles = Compression.UnpackVector3FromInt(info.msg.ragdoll.rotations[i], -360f, 360f);
			}
		}
	}

	public void CopyTo(Skeleton to)
	{
		skeleton.CopyTo(to);
	}

	public void GetCurrentBoneState(GameObject[] bones, ref Vector3[] bonePos, ref Quaternion[] boneRot)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		int num = bones.Length;
		bonePos = (Vector3[])(object)new Vector3[num];
		boneRot = (Quaternion[])(object)new Quaternion[num];
		for (int i = 0; i < num; i++)
		{
			if ((Object)(object)bones[i] != (Object)null)
			{
				Transform transform = bones[i].transform;
				bonePos[i] = transform.localPosition;
				boneRot[i] = transform.localRotation;
			}
		}
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		joints.Clear();
		rbTransforms.Clear();
		characterJoints.Clear();
		configurableJoints.Clear();
		rigidbodies.Clear();
		colliders.Clear();
		((Component)this).GetComponentsInChildren<Rigidbody>(true, rigidbodies);
		for (int i = 0; i < rigidbodies.Count; i++)
		{
			if (!((Object)(object)((Component)rigidbodies[i]).transform == (Object)(object)((Component)this).transform))
			{
				rbTransforms.Add(((Component)rigidbodies[i]).transform);
			}
		}
		((Component)this).GetComponentsInChildren<Joint>(true, joints);
		((Component)this).GetComponentsInChildren<CharacterJoint>(true, characterJoints);
		((Component)this).GetComponentsInChildren<ConfigurableJoint>(true, configurableJoints);
		((Component)this).GetComponentsInChildren<Collider>(true, colliders);
		rbTransforms.Sort((Transform t1, Transform t2) => TransformEx.GetDepth(t1).CompareTo(TransformEx.GetDepth(t2)));
		if (skeleton.Bones != null && skeleton.Bones.Length != 0)
		{
			GetCurrentBoneState(skeleton.Bones, ref genericBonePos, ref genericBoneRot);
			int num = skeleton.Bones.Length;
			boneIndex = new int[num];
			for (int j = 0; j < num; j++)
			{
				boneIndex[j] = -1;
				GameObject val = skeleton.Bones[j];
				for (int k = 0; k < rbTransforms.Count; k++)
				{
					if ((Object)(object)((Component)rbTransforms[k]).gameObject == (Object)(object)val)
					{
						boneIndex[j] = k;
						break;
					}
				}
			}
		}
		if (!clientside || !simOnServer)
		{
			return;
		}
		foreach (Joint joint in joints)
		{
			Object.DestroyImmediate((Object)(object)joint, true);
		}
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			Object.DestroyImmediate((Object)(object)rigidbody, true);
		}
	}

	private void RemoveRootBoneOffset()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (simOnServer)
		{
			Transform rootBone = model.rootBone;
			if ((Object)(object)rootBone != (Object)null && !((Component)(object)rootBone).HasComponent<Rigidbody>())
			{
				((Component)this).transform.position = rootBone.position;
				((Component)this).transform.rotation = rootBone.rotation;
				rootBone.localPosition = Vector3.zero;
				rootBone.localRotation = Quaternion.identity;
			}
		}
	}

	public virtual void ServerInit()
	{
		if (simOnServer)
		{
			RemoveRootBoneOffset();
			((FacepunchBehaviour)this).InvokeRepeating((Action)SyncJointsToClients, 0f, 0.1f);
		}
		else
		{
			MoveRigidbodiesToRoot();
		}
		SetUpPhysics(isServer: true);
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		if (simOnServer)
		{
			info.msg.ragdoll = Pool.Get<Ragdoll>();
			SetRagdollMessageVals(info.msg.ragdoll);
		}
	}

	public bool IsFullySleeping()
	{
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			if (!rigidbody.IsSleeping())
			{
				return false;
			}
		}
		return true;
	}

	private void SyncJointsToClients()
	{
		if (!ShouldSyncJoints())
		{
			return;
		}
		Ragdoll val = Pool.Get<Ragdoll>();
		try
		{
			SetRagdollMessageVals(val);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("RPCSyncJoints"), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool ShouldSyncJoints()
	{
		bool result = false;
		if (wasSyncingJoints)
		{
			if (!IsFullySleeping())
			{
				result = true;
			}
		}
		else
		{
			result = !primaryBody.IsSleeping();
		}
		wasSyncingJoints = result;
		return result;
	}

	private void SetRagdollMessageVals(Ragdoll ragdollMsg)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		List<int> list = Pool.Get<List<int>>();
		List<int> list2 = Pool.Get<List<int>>();
		foreach (Transform rbTransform in rbTransforms)
		{
			int item = Compression.PackVector3ToInt(rbTransform.localPosition, -2f, 2f);
			int item2 = Compression.PackVector3ToInt(rbTransform.localEulerAngles, -360f, 360f);
			list.Add(item);
			list2.Add(item2);
		}
		ragdollMsg.time = base.baseEntity.GetNetworkTime();
		ragdollMsg.positions = list;
		ragdollMsg.rotations = list2;
	}

	public void BecomeActive()
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		if (!IsKinematic)
		{
			return;
		}
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			rigidbody.isKinematic = false;
			SetCollisionMode(rigidbody, isServer);
			rigidbody.WakeUp();
			if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity.HasParent())
			{
				Rigidbody component = ((Component)base.baseEntity.GetParentEntity()).GetComponent<Rigidbody>();
				if ((Object)(object)component != (Object)null)
				{
					rigidbody.velocity = component.velocity;
					rigidbody.angularVelocity = component.angularVelocity;
				}
			}
			foreach (Collider collider in colliders)
			{
				((Component)collider).gameObject.layer = 9;
			}
		}
	}

	public void BecomeInactive()
	{
		if (IsKinematic)
		{
			return;
		}
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			rigidbody.collisionDetectionMode = (CollisionDetectionMode)0;
			rigidbody.isKinematic = true;
		}
		foreach (Collider collider in colliders)
		{
			((Component)collider).gameObject.layer = 19;
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class ReactiveTarget : IOEntity
{
	public Animator myAnimator;

	public GameObjectRef bullseyeEffect;

	public GameObjectRef knockdownEffect;

	public float activationPowerTime = 0.5f;

	public int activationPowerAmount = 1;

	private float lastToggleTime = float.NegativeInfinity;

	public const Flags Flag_KnockedDown = Flags.Reserved1;

	public float knockdownHealth = 100f;

	private int inputAmountReset;

	private int inputAmountLower;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ReactiveTarget.OnRpcMessage", 0);
		try
		{
			if (rpc == 1798082523 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Lower "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Lower", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_Lower(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_Lower");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2169477377u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Reset "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Reset", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						RPC_Reset(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in RPC_Reset");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void OnHitShared(HitInfo info)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		if (IsKnockedDown() || IsLowered())
		{
			return;
		}
		bool num = info.HitBone == StringPool.Get("target_collider");
		bool flag = info.HitBone == StringPool.Get("target_collider_bullseye");
		if ((num || flag) && base.isServer)
		{
			float num2 = info.damageTypes.Total();
			if (flag)
			{
				num2 *= 2f;
				Effect.server.Run(bullseyeEffect.resourcePath, this, StringPool.Get("target_collider_bullseye"), Vector3.zero, Vector3.zero);
			}
			knockdownHealth -= num2;
			if (knockdownHealth <= 0f)
			{
				Effect.server.Run(knockdownEffect.resourcePath, this, StringPool.Get("target_collider_bullseye"), Vector3.zero, Vector3.zero);
				SetFlag(Flags.On, b: false);
				SetFlag(Flags.Reserved1, b: true);
				QueueReset();
				SendPowerBurst();
				SendNetworkUpdate();
			}
			else
			{
				ClientRPC(RpcTarget.NetworkGroup("HitEffect"), info.Initiator.net.ID);
			}
			Hurt(1f, DamageType.Suicide, info.Initiator, useProtection: false);
		}
	}

	public bool IsKnockedDown()
	{
		if (IsLowered())
		{
			return HasFlag(Flags.Reserved1);
		}
		return false;
	}

	public bool IsLowered()
	{
		return !HasFlag(Flags.On);
	}

	public override void OnAttacked(HitInfo info)
	{
		OnHitShared(info);
		base.OnAttacked(info);
	}

	public bool CanToggle()
	{
		float num = 1f;
		num = ((inputAmountReset > 0) ? 0.25f : 1f);
		return Time.time > lastToggleTime + num;
	}

	public bool CanLower()
	{
		if (inputAmountLower <= inputAmountReset)
		{
			return inputAmountReset == 0;
		}
		return true;
	}

	public bool CanReset()
	{
		if (inputAmountReset <= inputAmountLower)
		{
			return inputAmountLower == 0;
		}
		return true;
	}

	public void QueueReset()
	{
		float num = ((inputAmountReset > 0) ? 0.25f : 6f);
		((FacepunchBehaviour)this).Invoke((Action)ResetTarget, num);
	}

	public void ResetTarget()
	{
		if (IsLowered() && CanToggle() && CanReset())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ResetTarget);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved1, b: false);
			knockdownHealth = 100f;
			SendPowerBurst();
			Interface.CallHook("OnReactiveTargetReset", (object)this);
		}
	}

	private void LowerTarget()
	{
		if (!IsKnockedDown() && CanToggle() && CanLower())
		{
			SetFlag(Flags.On, b: false);
			SendPowerBurst();
		}
	}

	private void SendPowerBurst()
	{
		lastToggleTime = Time.time;
		MarkDirtyForceUpdateOutputs();
		((FacepunchBehaviour)this).Invoke((Action)base.MarkDirtyForceUpdateOutputs, activationPowerTime * 1.01f);
	}

	public override int ConsumptionAmount()
	{
		return 1;
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		switch (inputSlot)
		{
		case 0:
			base.UpdateFromInput(inputAmount, inputSlot);
			break;
		case 1:
			inputAmountReset = inputAmount;
			if (inputAmount > 0)
			{
				ResetTarget();
			}
			break;
		case 2:
			inputAmountLower = inputAmount;
			if (inputAmount > 0)
			{
				LowerTarget();
			}
			break;
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (IsLowered())
		{
			if (IsPowered())
			{
				return base.GetPassthroughAmount();
			}
			if (IsKnockedDown() && Time.time < lastToggleTime + activationPowerTime)
			{
				return activationPowerAmount;
			}
		}
		return 0;
	}

	[RPC_Server]
	public void RPC_Reset(RPCMessage msg)
	{
		ResetTarget();
	}

	[RPC_Server]
	public void RPC_Lower(RPCMessage msg)
	{
		LowerTarget();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ReclaimTerminal : StorageContainer
{
	public int itemCount;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ReclaimTerminal.OnRpcMessage", 0);
		try
		{
			if (rpc == 2609933020u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReloadLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReloadLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2609933020u, "RPC_ReloadLoot", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2609933020u, "RPC_ReloadLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_ReloadLoot(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_ReloadLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	public void RPC_ReloadLoot(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !((Object)(object)ReclaimManager.instance == (Object)null) && !((Object)(object)player.inventory.loot.entitySource != (Object)(object)this))
		{
			LoadReclaimLoot(player);
		}
	}

	public void LoadReclaimLoot(BasePlayer player)
	{
		if ((Object)(object)ReclaimManager.instance == (Object)null)
		{
			return;
		}
		List<ReclaimManager.PlayerReclaimEntry> list = Pool.Get<List<ReclaimManager.PlayerReclaimEntry>>();
		ReclaimManager.instance.GetReclaim(player.userID);
		itemCount = 0;
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			if (base.inventory.GetSlot(i) != null)
			{
				itemCount++;
			}
		}
		foreach (ReclaimManager.PlayerReclaimEntry item2 in list)
		{
			for (int num = item2.mainInventory.itemList.Count - 1; num >= 0; num--)
			{
				Item item = item2.mainInventory.itemList[num];
				itemCount++;
				item.MoveToContainer(base.inventory);
			}
		}
		Pool.Free<ReclaimManager.PlayerReclaimEntry>(ref list, false);
		SendNetworkUpdate();
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if ((Object)(object)ReclaimManager.instance == (Object)null)
		{
			return false;
		}
		LoadReclaimLoot(player);
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		if (!((Object)(object)ReclaimManager.instance == (Object)null))
		{
			if (base.inventory.itemList.Count > 0)
			{
				ReclaimManager.instance.AddPlayerReclaim(player.userID, null, null, base.inventory.itemList, null);
			}
			base.PlayerStoppedLooting(player);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.reclaimTerminal = Pool.Get<ReclaimTerminal>();
			info.msg.reclaimTerminal.itemCount = itemCount;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk && info.msg.reclaimTerminal != null)
		{
			itemCount = info.msg.reclaimTerminal.itemCount;
		}
	}
}


using System;
using System.IO;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class RecorderTool : ThrownWeapon, ICassettePlayer
{
	[ClientVar(Saved = true)]
	public static bool debugRecording;

	public AudioSource RecorderAudioSource;

	public SoundDefinition RecordStartSfx;

	public SoundDefinition RewindSfx;

	public SoundDefinition RecordFinishedSfx;

	public SoundDefinition PlayTapeSfx;

	public SoundDefinition StopTapeSfx;

	public float ThrowScale = 3f;

	public Cassette cachedCassette { get; set; }

	public Sprite LoadedCassetteIcon
	{
		get
		{
			if (!((Object)(object)cachedCassette != (Object)null))
			{
				return null;
			}
			return cachedCassette.HudSprite;
		}
	}

	public BaseEntity ToBaseEntity => this;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RecorderTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 4278517885u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - OnCassetteRecordingEnded "));
				}
				TimeWarning val2 = TimeWarning.New("OnCassetteRecordingEnded", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4278517885u, "OnCassetteRecordingEnded", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(4278517885u, "OnCassetteRecordingEnded", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							OnCassetteRecordingEnded(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in OnCassetteRecordingEnded");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3075830603u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_TogglePlaying "));
				}
				TimeWarning val2 = TimeWarning.New("Server_TogglePlaying", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3075830603u, "Server_TogglePlaying", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3075830603u, "Server_TogglePlaying", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_TogglePlaying(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_TogglePlaying");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private bool HasCassette()
	{
		return (Object)(object)cachedCassette != (Object)null;
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.FromOwner(false)]
	public void Server_TogglePlaying(RPCMessage msg)
	{
		bool b = ((Stream)(object)msg.read).ReadByte() == 1;
		SetFlag(Flags.On, b);
	}

	public void OnCassetteInserted(Cassette c)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		cachedCassette = c;
		ClientRPC(RpcTarget.NetworkGroup("Client_OnCassetteInserted"), c.net.ID);
	}

	public void OnCassetteRemoved(Cassette c)
	{
		cachedCassette = null;
		ClientRPC(RpcTarget.NetworkGroup("Client_OnCassetteRemoved"));
	}

	protected override void SetUpThrownWeapon(BaseEntity ent)
	{
		base.SetUpThrownWeapon(ent);
		Item item = GetItem();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			ent.OwnerID = ownerPlayer.userID;
		}
		if (ent is DeployedRecorder deployedRecorder)
		{
			if ((Object)(object)cachedCassette != (Object)null)
			{
				item.contents.itemList[0].SetParent(deployedRecorder.inventory);
			}
			deployedRecorder.ItemOwnership = item.TakeOwnershipShare();
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(3uL)]
	public void OnCassetteRecordingEnded(RPCMessage rpc)
	{
		if (GetItem() != null)
		{
			GetItem().contents.itemList[0].SetItemOwnership(rpc.player, ItemOwnershipPhrases.Recorded);
		}
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		if (IsDisabled())
		{
			SetFlag(Flags.On, b: false);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Recycler : StorageContainer
{
	private static readonly int Param_On = Animator.StringToHash("on");

	public Animator Animator;

	[Tooltip("Depreciated")]
	public float recycleEfficiency = 0.6f;

	public float safezoneRecycleEfficiency = 0.4f;

	public float radtownRecycleEfficiency = 0.6f;

	public SoundDefinition grindingLoopDef;

	public SoundDefinition grindingLoopDef_Slow;

	public GameObjectRef startSound;

	public GameObjectRef stopSound;

	public const Flags SafeZone = Flags.Reserved9;

	public float scrapRemainder;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Recycler.OnRpcMessage", 0);
		try
		{
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SVSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4167839872u, "SVSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SVSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SVSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
	}

	private bool CanBeRecycled(Item item)
	{
		object obj = Interface.CallHook("CanBeRecycled", (object)item, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item != null)
		{
			return (Object)(object)item.info.Blueprint != (Object)null;
		}
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(RecyclerItemFilter));
		UpdateInSafeZone();
	}

	public bool RecyclerItemFilter(Item item, int targetSlot)
	{
		int num = Mathf.CeilToInt((float)base.inventory.capacity * 0.5f);
		if (targetSlot == -1)
		{
			bool flag = false;
			for (int i = 0; i < num; i++)
			{
				if (!base.inventory.SlotTaken(item, i))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return false;
			}
		}
		if (targetSlot < num)
		{
			return CanBeRecycled(item);
		}
		return true;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag == IsOn() || (Object)(object)msg.player == (Object)null || Interface.CallHook("OnRecyclerToggle", (object)this, (object)msg.player) != null || (!flag && onlyOneUser && (Object)(object)msg.player.inventory.loot.entitySource != (Object)(object)this) || (flag && !HasRecyclable()))
		{
			return;
		}
		if (flag)
		{
			foreach (Item item in base.inventory.itemList)
			{
				item.CollectedForCrafting(msg.player);
			}
			StartRecycling();
		}
		else
		{
			StopRecycling();
		}
	}

	public bool MoveItemToOutput(Item newItem)
	{
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		for (int i = 6; i < 12; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot == null)
			{
				num = i;
				break;
			}
			if (slot.CanStack(newItem))
			{
				if (slot.amount + newItem.amount <= slot.MaxStackable())
				{
					num = i;
					break;
				}
				int num2 = Mathf.Min(slot.MaxStackable() - slot.amount, newItem.amount);
				newItem.UseItem(num2);
				slot.amount += num2;
				slot.MarkDirty();
				newItem.MarkDirty();
			}
			if (newItem.amount <= 0)
			{
				return true;
			}
		}
		if (num != -1 && newItem.MoveToContainer(base.inventory, num))
		{
			return true;
		}
		newItem.Drop(((Component)this).transform.position + new Vector3(0f, 2f, 0f), GetInheritedDropVelocity() + ((Component)this).transform.forward * 2f);
		return false;
	}

	public bool HasRecyclable()
	{
		for (int i = 0; i < 6; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				object obj = Interface.CallHook("CanRecycle", (object)this, (object)slot);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if ((Object)(object)slot.info.Blueprint != (Object)null)
				{
					return true;
				}
			}
		}
		return false;
	}

	public void RecycleThink()
	{
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		float num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);
		int num2 = 0;
		while (true)
		{
			if (num2 < 6)
			{
				Item slot = base.inventory.GetSlot(num2);
				if (!CanBeRecycled(slot))
				{
					num2++;
					continue;
				}
				if (Interface.CallHook("OnItemRecycle", (object)slot, (object)this) != null)
				{
					if (!HasRecyclable())
					{
						StopRecycling();
					}
					break;
				}
				if (slot.hasCondition)
				{
					num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
				}
				int num3 = 1;
				if (slot.amount > 1)
				{
					num3 = Mathf.CeilToInt(Mathf.Min((float)slot.amount, (float)slot.MaxStackable() * 0.1f));
				}
				object obj = Interface.CallHook("OnItemRecycleAmount", (object)slot, (object)num3, (object)this);
				if (obj is int)
				{
					num3 = (int)obj;
				}
				if (slot.info.Blueprint.scrapFromRecycle > 0)
				{
					float num4 = slot.info.Blueprint.scrapFromRecycle * num3;
					if (slot.MaxStackable() == 1 && slot.hasCondition)
					{
						num4 *= slot.conditionNormalized;
					}
					float num5 = num / 0.5f;
					num4 *= num5;
					int num6 = Mathf.FloorToInt(num4);
					float num7 = num4 - (float)num6;
					scrapRemainder += num7;
					if (scrapRemainder >= 1f)
					{
						int num8 = Mathf.FloorToInt(scrapRemainder);
						scrapRemainder -= num8;
						num6 += num8;
					}
					if (num6 >= 1)
					{
						Item item = ItemManager.CreateByName("scrap", num6, 0uL);
						if ((Object)(object)base.LastLootedByPlayer != (Object)null)
						{
							item.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);
						}
						Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);
						MoveItemToOutput(item);
					}
				}
				if (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))
				{
					List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
					Vis.Entities(((Component)this).transform.position, 3f, list, 131072, (QueryTriggerInteraction)2);
					foreach (BasePlayer item3 in list)
					{
						if (item3.IsAlive() && !item3.IsSleeping() && (Object)(object)item3.inventory.loot.entitySource == (Object)(object)this)
						{
							item3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);
							item3.stats.Save();
						}
					}
					Pool.FreeUnmanaged<BasePlayer>(ref list);
				}
				Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);
				slot.UseItem(num3);
				foreach (ItemAmount ingredient in slot.info.Blueprint.GetIngredients())
				{
					if (ingredient.itemDef.shortname == "scrap")
					{
						continue;
					}
					float num9 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num3;
					int num10 = Mathf.FloorToInt(num9);
					float num11 = num9 - (float)num10;
					if (num11 > float.Epsilon && Random.Range(0f, 1f) <= num11)
					{
						num10++;
					}
					if (num10 <= 0)
					{
						continue;
					}
					int num12 = Mathf.CeilToInt((float)num10 / (float)ingredient.itemDef.stackable);
					for (int i = 0; i < num12; i++)
					{
						if (ingredient.itemDef.IsAllowed((EraRestriction)16))
						{
							int num13 = ((num10 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num10);
							Item item2 = ItemManager.Create(ingredient.itemDef, num13, 0uL);
							if ((Object)(object)base.LastLootedByPlayer != (Object)null)
							{
								item2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);
							}
							Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);
							if (!MoveItemToOutput(item2))
							{
								flag = true;
							}
							num10 -= num13;
							if (num10 <= 0)
							{
								break;
							}
						}
					}
				}
			}
			if (flag || !HasRecyclable())
			{
				StopRecycling();
			}
			break;
		}
	}

	public float GetRecycleThinkDuration()
	{
		if (IsSafezoneRecycler())
		{
			return 8f;
		}
		return 5f;
	}

	public void StartRecycling()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (!IsOn())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)RecycleThink, GetRecycleThinkDuration(), GetRecycleThinkDuration());
			Effect.server.Run(startSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdateImmediate();
		}
	}

	public void StopRecycling()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		((FacepunchBehaviour)this).CancelInvoke((Action)RecycleThink);
		if (IsOn())
		{
			Effect.server.Run(stopSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetFlag(Flags.On, b: false);
			SendNetworkUpdateImmediate();
		}
	}

	public void UpdateInSafeZone()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(base.isServer);
		if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.safeZone)
		{
			SetFlag(Flags.Reserved9, b: false);
			return;
		}
		bool b = false;
		List<TriggerBase> list = Pool.Get<List<TriggerBase>>();
		GamePhysics.OverlapSphere<TriggerBase>(((Component)this).transform.position, 1f, list, 262144, (QueryTriggerInteraction)2);
		foreach (TriggerBase item in list)
		{
			if ((Object)(object)item != (Object)null && Object.op_Implicit((Object)(object)((Component)item).GetComponent<TriggerSafeZone>()))
			{
				b = true;
				break;
			}
		}
		if (base.isServer)
		{
			SetFlag(Flags.Reserved9, b);
		}
		Pool.FreeUnmanaged<TriggerBase>(ref list);
	}

	public bool IsSafezoneRecycler()
	{
		return HasFlag(Flags.Reserved9);
	}

	public void PlayAnim()
	{
	}

	public void StopAnim()
	{
	}

	private void ToggleAnim(bool toggle)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class RelationshipManager : BaseEntity
{
	public enum RelationshipType
	{
		NONE,
		Acquaintance,
		Friend,
		Enemy
	}

	public class PlayerRelationshipInfo : IPooled, IServerFileReceiver, IPlayerInfo
	{
		public string displayName;

		public ulong player;

		public RelationshipType type;

		public int weight;

		public uint mugshotCrc;

		public string notes;

		public float lastSeenTime;

		[NonSerialized]
		public float lastMugshotTime;

		public ulong UserId => player;

		public string UserName => displayName;

		public bool IsOnline => false;

		public bool IsMe => false;

		public bool IsFriend => false;

		public bool IsPlayingThisGame => true;

		public string ServerEndpoint => string.Empty;

		public void EnterPool()
		{
			Reset();
		}

		public void LeavePool()
		{
			Reset();
		}

		private void Reset()
		{
			displayName = null;
			player = 0uL;
			type = RelationshipType.NONE;
			weight = 0;
			mugshotCrc = 0u;
			notes = "";
			lastMugshotTime = 0f;
		}

		public PlayerRelationshipInfo ToProto()
		{
			PlayerRelationshipInfo obj = Pool.Get<PlayerRelationshipInfo>();
			obj.playerID = player;
			obj.type = (int)type;
			obj.weight = weight;
			obj.mugshotCrc = mugshotCrc;
			obj.displayName = displayName;
			obj.notes = notes;
			obj.timeSinceSeen = Time.realtimeSinceStartup - lastSeenTime;
			return obj;
		}

		public static PlayerRelationshipInfo FromProto(PlayerRelationshipInfo proto)
		{
			return new PlayerRelationshipInfo
			{
				type = (RelationshipType)proto.type,
				weight = proto.weight,
				displayName = proto.displayName,
				mugshotCrc = proto.mugshotCrc,
				notes = proto.notes,
				player = proto.playerID,
				lastSeenTime = Time.realtimeSinceStartup - proto.timeSinceSeen
			};
		}
	}

	public class PlayerRelationships : IPooled
	{
		public bool dirty;

		public ulong ownerPlayer;

		public Dictionary<ulong, PlayerRelationshipInfo> relations;

		public bool Forget(ulong player)
		{
			if (relations.TryGetValue(player, out var value))
			{
				relations.Remove(player);
				if (value.mugshotCrc != 0)
				{
					ServerInstance.DeleteMugshot(ownerPlayer, player, value.mugshotCrc);
				}
				Pool.Free<PlayerRelationshipInfo>(ref value);
				return true;
			}
			return false;
		}

		public PlayerRelationshipInfo GetRelations(ulong player)
		{
			BasePlayer basePlayer = FindByID(player);
			if (relations.TryGetValue(player, out var value))
			{
				if ((Object)(object)basePlayer != (Object)null)
				{
					value.displayName = basePlayer.displayName;
				}
				return value;
			}
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			if ((Object)(object)basePlayer != (Object)null)
			{
				playerRelationshipInfo.displayName = basePlayer.displayName;
			}
			playerRelationshipInfo.player = player;
			relations.Add(player, playerRelationshipInfo);
			return playerRelationshipInfo;
		}

		public PlayerRelationships()
		{
			LeavePool();
		}

		public void EnterPool()
		{
			ownerPlayer = 0uL;
			if (relations != null)
			{
				Pool.Free<ulong, PlayerRelationshipInfo>(ref relations, true);
			}
		}

		public void LeavePool()
		{
			ownerPlayer = 0uL;
			relations = Pool.Get<Dictionary<ulong, PlayerRelationshipInfo>>();
		}

		public void ClearRelations()
		{
			foreach (KeyValuePair<ulong, PlayerRelationshipInfo> relation in relations)
			{
				var (_, playerRelationshipInfo2) = (KeyValuePair<ulong, PlayerRelationshipInfo>)(ref relation);
				Pool.Free<PlayerRelationshipInfo>(ref playerRelationshipInfo2);
			}
			relations.Clear();
		}
	}

	public class PlayerTeam : IPooled
	{
		public ulong teamID;

		public string joinKey;

		public string teamName;

		public ulong teamLeader;

		public Vector3 firstSpawnLocation;

		public bool usePartySpawn;

		public List<ulong> members = new List<ulong>();

		public List<ulong> invites = new List<ulong>();

		public float teamStartTime;

		public List<Connection> onlineMemberConnections = new List<Connection>();

		public float teamLifetime => Time.realtimeSinceStartup - teamStartTime;

		public BasePlayer GetLeader()
		{
			return FindByID(teamLeader);
		}

		public void SendInvite(BasePlayer player)
		{
			if (invites.Count > 8)
			{
				invites.RemoveRange(0, 1);
			}
			BasePlayer basePlayer = FindByID(teamLeader);
			if (!((Object)(object)basePlayer == (Object)null))
			{
				ulong item = player.userID.Get();
				if (!invites.Contains(item))
				{
					invites.Add(item);
				}
				player.ClientRPC(RpcTarget.Player("CLIENT_PendingInvite", player), basePlayer.displayName, teamLeader, teamID);
			}
		}

		public void SendInvite(BasePlayer player, ulong id)
		{
			if (invites.Count > 8)
			{
				invites.RemoveRange(0, 1);
			}
			BasePlayer basePlayer = FindByID(teamLeader);
			if (!((Object)(object)basePlayer == (Object)null))
			{
				if (!invites.Contains(id))
				{
					invites.Add(id);
				}
				if ((Object)(object)player != (Object)null)
				{
					player.ClientRPC(RpcTarget.Player("CLIENT_PendingInvite", player), basePlayer.displayName, teamLeader, teamID);
				}
			}
		}

		public void AcceptInvite(BasePlayer player)
		{
			if (invites.Contains(player.userID))
			{
				invites.Remove(player.userID);
				AddPlayer(player);
				player.ClearPendingInvite();
			}
		}

		public void RejectInvite(BasePlayer player)
		{
			player.ClearPendingInvite();
			invites.Remove(player.userID);
		}

		public bool AddPlayer(BasePlayer player, bool skipDirtyUpdate = false)
		{
			if (player.currentTeam != 0L)
			{
				return false;
			}
			if (!AddPlayer(player.userID, skipDirtyUpdate))
			{
				return false;
			}
			player.currentTeam = teamID;
			player.SendNetworkUpdate();
			return true;
		}

		public bool AddPlayer(ulong playerId, bool skipDirtyUpdate = false)
		{
			if (members.Contains(playerId))
			{
				return false;
			}
			if (members.Count >= maxTeamSize)
			{
				return false;
			}
			bool num = members.Count == 0;
			members.Add(playerId);
			ServerInstance.playerToTeam.Add(playerId, this);
			if (!skipDirtyUpdate)
			{
				MarkDirty();
			}
			if (!num)
			{
				Analytics.Azure.OnTeamChanged("added", teamID, teamLeader, playerId, members);
			}
			return true;
		}

		public bool RemovePlayer(ulong playerID)
		{
			if (members.Contains(playerID))
			{
				members.Remove(playerID);
				ServerInstance.playerToTeam.Remove(playerID);
				BasePlayer basePlayer = FindByID(playerID);
				if ((Object)(object)basePlayer != (Object)null)
				{
					basePlayer.ClearTeam();
					basePlayer.BroadcastAppTeamRemoval();
					basePlayer.SendNetworkUpdate();
				}
				if (teamLeader == playerID)
				{
					if (members.Count > 0)
					{
						SetTeamLeader(members[0]);
						Analytics.Azure.OnTeamChanged("removed", teamID, teamLeader, playerID, members);
					}
					else
					{
						Analytics.Azure.OnTeamChanged("disband", teamID, teamLeader, playerID, members);
						Disband();
					}
				}
				MarkDirty();
				return true;
			}
			return false;
		}

		public void SetTeamLeader(ulong newTeamLeader)
		{
			if (Interface.CallHook("OnTeamMemberPromote", (object)this, (object)newTeamLeader) == null)
			{
				Analytics.Azure.OnTeamChanged("promoted", teamID, teamLeader, newTeamLeader, members);
				teamLeader = newTeamLeader;
				MarkDirty();
			}
		}

		public void Disband()
		{
			ServerInstance.DisbandTeam(this);
			CompanionServer.Server.TeamChat.Remove(teamID);
		}

		public void MarkDirty()
		{
			foreach (ulong member in members)
			{
				BasePlayer basePlayer = FindByID(member);
				if ((Object)(object)basePlayer != (Object)null)
				{
					basePlayer.UpdateTeam(teamID);
				}
			}
			this.BroadcastAppTeamUpdate();
		}

		public List<Connection> GetOnlineMemberConnections()
		{
			if (members.Count == 0)
			{
				return null;
			}
			onlineMemberConnections.Clear();
			foreach (ulong member in members)
			{
				BasePlayer basePlayer = FindByID(member);
				if (!((Object)(object)basePlayer == (Object)null) && basePlayer.Connection != null)
				{
					onlineMemberConnections.Add(basePlayer.Connection);
				}
			}
			return onlineMemberConnections;
		}

		void IPooled.EnterPool()
		{
			teamID = 0uL;
			teamName = string.Empty;
			teamLeader = 0uL;
			teamStartTime = 0f;
			joinKey = null;
			members.Clear();
			invites.Clear();
			onlineMemberConnections.Clear();
		}

		void IPooled.LeavePool()
		{
		}
	}

	[ReplicatedVar(Default = "true")]
	public static bool contacts = true;

	public const FileStorage.Type MugshotFileFormat = FileStorage.Type.jpg;

	private const int MugshotResolution = 256;

	private const int MugshotMaxFileSize = 65536;

	private const float MugshotMaxDistance = 50f;

	public Dictionary<ulong, PlayerRelationships> relationships = new Dictionary<ulong, PlayerRelationships>();

	private int lastReputationUpdateIndex;

	private const int seenReputationSeconds = 60;

	private int startingReputation;

	[ServerVar]
	public static int forgetafterminutes = 960;

	[ServerVar]
	public static int maxplayerrelationships = 128;

	[ServerVar]
	public static float seendistance = 10f;

	[ServerVar]
	public static float mugshotUpdateInterval = 300f;

	private static List<BasePlayer> _dirtyRelationshipPlayers = new List<BasePlayer>();

	private static Phrase RemoteInvitesBlocked = new Phrase("remote.invites.blocked", "That player has remote invites turned off");

	public static int maxTeamSize_Internal = 8;

	public Dictionary<ulong, BasePlayer> cachedPlayers = new Dictionary<ulong, BasePlayer>();

	public Dictionary<ulong, PlayerTeam> playerToTeam = new Dictionary<ulong, PlayerTeam>();

	public Dictionary<ulong, PlayerTeam> teams = new Dictionary<ulong, PlayerTeam>();

	public ulong lastTeamIndex = 1uL;

	[ServerVar]
	public static int maxTeamSize
	{
		get
		{
			return maxTeamSize_Internal;
		}
		set
		{
			maxTeamSize_Internal = value;
			if (Object.op_Implicit((Object)(object)ServerInstance))
			{
				ServerInstance.SendNetworkUpdate();
			}
		}
	}

	public static RelationshipManager ServerInstance { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RelationshipManager.OnRpcMessage", 0);
		try
		{
			if (rpc == 532372582 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BagQuotaRequest_SERVER "));
				}
				TimeWarning val2 = TimeWarning.New("BagQuotaRequest_SERVER", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(532372582u, "BagQuotaRequest_SERVER", this, player, 2uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							BagQuotaRequest_SERVER();
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BagQuotaRequest_SERVER");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1684577101 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_ChangeRelationship "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_ChangeRelationship", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1684577101u, "SERVER_ChangeRelationship", this, player, 2uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_ChangeRelationship(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_ChangeRelationship");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1239936737 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_ReceiveMugshot "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_ReceiveMugshot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1239936737u, "SERVER_ReceiveMugshot", this, player, 10uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_ReceiveMugshot(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SERVER_ReceiveMugshot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2178173141u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_SendFreshContacts "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_SendFreshContacts", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2178173141u, "SERVER_SendFreshContacts", this, player, 1uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SERVER_SendFreshContacts(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in SERVER_SendFreshContacts");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 290196604 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_UpdatePlayerNote "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_UpdatePlayerNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(290196604u, "SERVER_UpdatePlayerNote", this, player, 10uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							SERVER_UpdatePlayerNote(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in SERVER_UpdatePlayerNote");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	public void BagQuotaRequest_SERVER()
	{
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (contacts)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateContactsTick, 0f, 1f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateReputations, 0f, 0.05f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)SendRelationships, 0f, 5f);
		}
	}

	public void UpdateReputations()
	{
		if (contacts && BasePlayer.activePlayerList.Count != 0)
		{
			if (lastReputationUpdateIndex >= BasePlayer.activePlayerList.Count)
			{
				lastReputationUpdateIndex = 0;
			}
			BasePlayer basePlayer = BasePlayer.activePlayerList[lastReputationUpdateIndex];
			if (basePlayer.reputation != (basePlayer.reputation = GetReputationFor(basePlayer.userID)))
			{
				basePlayer.SendNetworkUpdate();
			}
			lastReputationUpdateIndex++;
		}
	}

	public void UpdateContactsTick()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (!contacts)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				UpdateAcquaintancesFor(current, 1f);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public int GetReputationFor(ulong playerID)
	{
		int num = startingReputation;
		foreach (PlayerRelationships value2 in relationships.Values)
		{
			if (!value2.relations.TryGetValue(playerID, out var value))
			{
				continue;
			}
			if (value.type == RelationshipType.Friend)
			{
				num++;
			}
			else if (value.type == RelationshipType.Acquaintance)
			{
				if (value.weight > 60)
				{
					num++;
				}
			}
			else if (value.type == RelationshipType.Enemy)
			{
				num--;
			}
		}
		return num;
	}

	[ServerVar]
	public static void wipecontacts(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && !((Object)(object)ServerInstance == (Object)null))
		{
			ulong num = basePlayer.userID.Get();
			if (ServerInstance.relationships.ContainsKey(num))
			{
				Debug.Log((object)("Wiped contacts for :" + num));
				ServerInstance.relationships.Remove(num);
				ServerInstance.MarkRelationshipsDirtyFor(num);
			}
			else
			{
				Debug.Log((object)("No contacts for :" + num));
			}
		}
	}

	[ServerVar]
	public static void wipe_all_contacts(Arg arg)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)arg.Player() == (Object)null || (Object)(object)ServerInstance == (Object)null)
		{
			return;
		}
		if (!arg.HasArgs(1) || arg.Args[0] != "confirm")
		{
			Debug.Log((object)"Please append the word 'confirm' at the end of the console command to execute");
			return;
		}
		ServerInstance.relationships.Clear();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				ServerInstance.MarkRelationshipsDirtyFor(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Debug.Log((object)"Wiped all contacts.");
	}

	public float GetAcquaintanceMaxDist()
	{
		return seendistance;
	}

	public void UpdateAcquaintancesFor(BasePlayer player, float deltaSeconds)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		PlayerRelationships playerRelationships = GetRelationships(player.userID);
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		BaseNetworkable.GetCloseConnections(((Component)player).transform.position, GetAcquaintanceMaxDist(), list);
		foreach (BasePlayer item in list)
		{
			if ((Object)(object)item == (Object)(object)player || item.isClient || !item.IsAlive() || item.IsSleeping() || item.limitNetworking)
			{
				continue;
			}
			PlayerRelationshipInfo relations = playerRelationships.GetRelations(item.userID);
			if (!(Vector3.Distance(((Component)player).transform.position, ((Component)item).transform.position) <= GetAcquaintanceMaxDist()))
			{
				continue;
			}
			relations.lastSeenTime = Time.realtimeSinceStartup;
			if ((relations.type == RelationshipType.NONE || relations.type == RelationshipType.Acquaintance) && player.IsPlayerVisibleToUs(item, Vector3.zero, 1218519041))
			{
				int num = Mathf.CeilToInt(deltaSeconds);
				if (player.InSafeZone() || item.InSafeZone())
				{
					num = 0;
				}
				if (relations.type != RelationshipType.Acquaintance || (relations.weight < 60 && num > 0))
				{
					SetRelationship(player, item, RelationshipType.Acquaintance, num);
				}
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	public void SetSeen(BasePlayer player, BasePlayer otherPlayer)
	{
		ulong player2 = player.userID.Get();
		ulong player3 = otherPlayer.userID.Get();
		PlayerRelationshipInfo relations = GetRelationships(player2).GetRelations(player3);
		if (relations.type != 0)
		{
			relations.lastSeenTime = Time.realtimeSinceStartup;
		}
	}

	public bool CleanupOldContacts(PlayerRelationships ownerRelationships, ulong playerID, RelationshipType relationshipType = RelationshipType.Acquaintance)
	{
		int numberRelationships = GetNumberRelationships(playerID);
		if (numberRelationships < maxplayerrelationships)
		{
			return true;
		}
		List<ulong> list = Pool.Get<List<ulong>>();
		foreach (KeyValuePair<ulong, PlayerRelationshipInfo> relation in ownerRelationships.relations)
		{
			if (relation.Value.type == relationshipType && Time.realtimeSinceStartup - relation.Value.lastSeenTime > (float)forgetafterminutes * 60f)
			{
				list.Add(relation.Key);
			}
		}
		int count = list.Count;
		foreach (ulong item in list)
		{
			ownerRelationships.Forget(item);
		}
		Pool.FreeUnmanaged<ulong>(ref list);
		return numberRelationships - count < maxplayerrelationships;
	}

	public void ForceRelationshipByID(BasePlayer player, ulong otherPlayerID, RelationshipType newType, int weight, bool sendImmediate = false)
	{
		if (!contacts || (Object)(object)player == (Object)null || (ulong)player.userID == otherPlayerID || player.IsNpc)
		{
			return;
		}
		ulong player2 = player.userID.Get();
		if (HasRelations(player2, otherPlayerID))
		{
			PlayerRelationshipInfo relations = GetRelationships(player2).GetRelations(otherPlayerID);
			if (relations.type != newType)
			{
				relations.weight = 0;
			}
			relations.type = newType;
			relations.weight += weight;
			if (sendImmediate)
			{
				SendRelationshipsFor(player);
			}
			else
			{
				MarkRelationshipsDirtyFor(player);
			}
		}
	}

	public void SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight = 1, bool sendImmediate = false)
	{
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		if (!contacts)
		{
			return;
		}
		ulong num = player.userID.Get();
		ulong num2 = otherPlayer.userID.Get();
		if ((Object)(object)player == (Object)null || (Object)(object)player == (Object)(object)otherPlayer || player.IsNpc || ((Object)(object)otherPlayer != (Object)null && otherPlayer.IsNpc) || Interface.CallHook("CanSetRelationship", (object)player, (object)otherPlayer, (object)type, (object)weight) != null)
		{
			return;
		}
		PlayerRelationships playerRelationships = GetRelationships(num);
		if (!CleanupOldContacts(playerRelationships, num))
		{
			CleanupOldContacts(playerRelationships, num, RelationshipType.Enemy);
		}
		PlayerRelationshipInfo relations = playerRelationships.GetRelations(num2);
		bool flag = false;
		if (relations.type != type)
		{
			flag = true;
			relations.weight = 0;
		}
		relations.type = type;
		relations.weight += weight;
		float num3 = Time.realtimeSinceStartup - relations.lastMugshotTime;
		if (flag || relations.mugshotCrc == 0 || num3 >= mugshotUpdateInterval)
		{
			bool flag2 = otherPlayer.IsAlive();
			bool num4 = player.SecondsSinceAttacked > 10f && !player.IsAiming;
			float num5 = 100f;
			if (num4)
			{
				Vector3 val = otherPlayer.eyes.position - player.eyes.position;
				Vector3 normalized = ((Vector3)(ref val)).normalized;
				bool flag3 = Vector3.Dot(player.eyes.HeadForward(), normalized) >= 0.6f;
				float num6 = Vector3Ex.Distance2D(((Component)player).transform.position, ((Component)otherPlayer).transform.position);
				if (flag2 && num6 < num5 && flag3)
				{
					ClientRPC(RpcTarget.Player("CLIENT_DoMugshot", player), num2);
					relations.lastMugshotTime = Time.realtimeSinceStartup;
				}
			}
		}
		if (sendImmediate)
		{
			SendRelationshipsFor(player);
		}
		else
		{
			MarkRelationshipsDirtyFor(player);
		}
	}

	public PlayerRelationships GetRelationshipSaveByID(ulong playerID)
	{
		PlayerRelationships val = Pool.Get<PlayerRelationships>();
		PlayerRelationships playerRelationships = GetRelationships(playerID);
		if (playerRelationships != null)
		{
			val.playerID = playerID;
			val.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			{
				foreach (KeyValuePair<ulong, PlayerRelationshipInfo> relation in playerRelationships.relations)
				{
					val.relations.Add(relation.Value.ToProto());
				}
				return val;
			}
		}
		return null;
	}

	public void MarkRelationshipsDirtyFor(ulong playerID)
	{
		BasePlayer basePlayer = FindByID(playerID);
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			MarkRelationshipsDirtyFor(basePlayer);
		}
	}

	public static void ForceSendRelationships(BasePlayer player)
	{
		if (Object.op_Implicit((Object)(object)ServerInstance))
		{
			ServerInstance.MarkRelationshipsDirtyFor(player);
		}
	}

	public void MarkRelationshipsDirtyFor(BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) && !_dirtyRelationshipPlayers.Contains(player))
		{
			_dirtyRelationshipPlayers.Add(player);
		}
	}

	public void SendRelationshipsFor(BasePlayer player)
	{
		if (!contacts)
		{
			return;
		}
		ulong playerID = player.userID.Get();
		PlayerRelationships relationshipSaveByID = GetRelationshipSaveByID(playerID);
		try
		{
			ClientRPC(RpcTarget.Player("CLIENT_RecieveLocalRelationships", player), relationshipSaveByID);
		}
		finally
		{
			((IDisposable)relationshipSaveByID)?.Dispose();
		}
	}

	public void SendRelationships()
	{
		if (!contacts)
		{
			return;
		}
		foreach (BasePlayer dirtyRelationshipPlayer in _dirtyRelationshipPlayers)
		{
			if (!((Object)(object)dirtyRelationshipPlayer == (Object)null) && dirtyRelationshipPlayer.IsConnected && !dirtyRelationshipPlayer.IsSleeping())
			{
				SendRelationshipsFor(dirtyRelationshipPlayer);
			}
		}
		_dirtyRelationshipPlayers.Clear();
	}

	public int GetNumberRelationships(ulong player)
	{
		if (relationships.TryGetValue(player, out var value))
		{
			return value.relations.Count;
		}
		return 0;
	}

	public bool HasRelations(ulong player, ulong otherPlayer)
	{
		if (relationships.TryGetValue(player, out var value) && value.relations.ContainsKey(otherPlayer))
		{
			return true;
		}
		return false;
	}

	public PlayerRelationships GetRelationships(ulong player)
	{
		if (relationships.TryGetValue(player, out var value))
		{
			return value;
		}
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		playerRelationships.ownerPlayer = player;
		relationships.Add(player, playerRelationships);
		return playerRelationships;
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void SERVER_SendFreshContacts(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (Object.op_Implicit((Object)(object)player))
		{
			SendRelationshipsFor(player);
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	public void SERVER_ChangeRelationship(RPCMessage msg)
	{
		EncryptedValue<ulong> userID = msg.player.userID;
		ulong num = msg.read.UInt64();
		int num2 = Mathf.Clamp(msg.read.Int32(), 0, 3);
		PlayerRelationships playerRelationships = GetRelationships(userID);
		playerRelationships.GetRelations(num);
		BasePlayer player = msg.player;
		RelationshipType relationshipType = (RelationshipType)num2;
		if (num2 == 0)
		{
			if (playerRelationships.Forget(num))
			{
				SendRelationshipsFor(player);
			}
			return;
		}
		BasePlayer basePlayer = FindByID(num);
		if ((Object)(object)basePlayer == (Object)null)
		{
			ForceRelationshipByID(player, num, relationshipType, 0, sendImmediate: true);
		}
		else
		{
			SetRelationship(player, basePlayer, relationshipType, 1, sendImmediate: true);
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(10uL)]
	public void SERVER_UpdatePlayerNote(RPCMessage msg)
	{
		EncryptedValue<ulong> userID = msg.player.userID;
		ulong player = msg.read.UInt64();
		string notes = msg.read.String(256, false);
		GetRelationships(userID).GetRelations(player).notes = notes;
		MarkRelationshipsDirtyFor(userID);
	}

	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server]
	public void SERVER_ReceiveMugshot(RPCMessage msg)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		EncryptedValue<ulong> userID = msg.player.userID;
		ulong num = msg.read.UInt64();
		uint num2 = msg.read.UInt32();
		byte[] array = msg.read.BytesWithSize(65536u, false);
		if (array != null && ImageProcessing.IsValidJPG(array, 256, 512) && relationships.TryGetValue(userID, out var value) && value.relations.TryGetValue(num, out var value2))
		{
			uint steamIdHash = GetSteamIdHash(userID, num);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.jpg, net.ID, steamIdHash);
			if (num3 != num2)
			{
				Debug.LogWarning((object)"Client/Server FileStorage CRC differs");
			}
			if (num3 != value2.mugshotCrc)
			{
				FileStorage.server.RemoveExact(value2.mugshotCrc, FileStorage.Type.jpg, net.ID, steamIdHash);
			}
			value2.mugshotCrc = num3;
			MarkRelationshipsDirtyFor(userID);
		}
	}

	private void DeleteMugshot(ulong steamId, ulong targetSteamId, uint crc)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (crc != 0)
		{
			uint steamIdHash = GetSteamIdHash(steamId, targetSteamId);
			FileStorage.server.RemoveExact(crc, FileStorage.Type.jpg, net.ID, steamIdHash);
		}
	}

	public static uint GetSteamIdHash(ulong requesterSteamId, ulong targetSteamId)
	{
		return (uint)(((requesterSteamId & 0xFFFF) << 16) | (targetSteamId & 0xFFFF));
	}

	public int GetMaxTeamSize()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode))
		{
			return activeGameMode.GetMaxRelationshipTeamSize();
		}
		return maxTeamSize;
	}

	public void OnEnable()
	{
		if (base.isServer)
		{
			if ((Object)(object)ServerInstance != (Object)null)
			{
				Debug.LogError((object)"Major fuckup! RelationshipManager spawned twice, Contact Developers!");
				Object.Destroy((Object)(object)((Component)this).gameObject);
			}
			else
			{
				ServerInstance = this;
			}
		}
	}

	public void OnDestroy()
	{
		if (base.isServer)
		{
			ServerInstance = null;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.relationshipManager = Pool.Get<RelationshipManager>();
		info.msg.relationshipManager.maxTeamSize = maxTeamSize;
		if (!info.forDisk)
		{
			return;
		}
		info.msg.relationshipManager.lastTeamIndex = lastTeamIndex;
		info.msg.relationshipManager.teamList = Pool.Get<List<PlayerTeam>>();
		foreach (KeyValuePair<ulong, PlayerTeam> team in teams)
		{
			PlayerTeam value = team.Value;
			if (value == null)
			{
				continue;
			}
			PlayerTeam val = Pool.Get<PlayerTeam>();
			val.teamLeader = value.teamLeader;
			val.teamID = value.teamID;
			val.teamName = value.teamName;
			val.joinKey = value.joinKey;
			val.members = Pool.Get<List<TeamMember>>();
			val.invites = Pool.Get<List<ulong>>();
			foreach (ulong invite in value.invites)
			{
				val.invites.Add(invite);
			}
			foreach (ulong member in value.members)
			{
				TeamMember val2 = Pool.Get<TeamMember>();
				BasePlayer basePlayer = FindByID(member);
				val2.displayName = (((Object)(object)basePlayer != (Object)null) ? basePlayer.displayName : (SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member) ?? "DEAD"));
				val2.userID = member;
				val.members.Add(val2);
			}
			info.msg.relationshipManager.teamList.Add(val);
		}
		info.msg.relationshipManager.relationships = Pool.Get<List<PlayerRelationships>>();
		foreach (ulong key in relationships.Keys)
		{
			_ = relationships[key];
			PlayerRelationships relationshipSaveByID = GetRelationshipSaveByID(key);
			info.msg.relationshipManager.relationships.Add(relationshipSaveByID);
		}
	}

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", (object)teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", (object)teamToDisband);
			Pool.Free<PlayerTeam>(ref teamToDisband);
		}
	}

	public static BasePlayer FindByID(ulong userID)
	{
		BasePlayer value = null;
		if (ServerInstance.cachedPlayers.TryGetValue(userID, out value))
		{
			if ((Object)(object)value != (Object)null)
			{
				return value;
			}
			ServerInstance.cachedPlayers.Remove(userID);
		}
		BasePlayer basePlayer = BasePlayer.FindByID(userID);
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer = BasePlayer.FindSleeping(userID);
		}
		if ((Object)(object)basePlayer != (Object)null)
		{
			ServerInstance.cachedPlayers.Add(userID, basePlayer);
		}
		return basePlayer;
	}

	public PlayerTeam FindTeam(ulong TeamID)
	{
		if (teams.ContainsKey(TeamID))
		{
			return teams[TeamID];
		}
		return null;
	}

	public PlayerTeam FindPlayersTeam(ulong userID)
	{
		if (playerToTeam.TryGetValue(userID, out var value))
		{
			return value;
		}
		return null;
	}

	public bool IsPlayerInTeam(ulong userId)
	{
		return playerToTeam.ContainsKey(userId);
	}

	public PlayerTeam FindByJoinKey(string key)
	{
		if (string.IsNullOrEmpty(key))
		{
			return null;
		}
		return teams.Values.FirstOrDefault((PlayerTeam x) => x.joinKey == key);
	}

	public PlayerTeam CreatePartyTeam(string joinKey)
	{
		PlayerTeam playerTeam = CreateTeam();
		playerTeam.usePartySpawn = true;
		playerTeam.joinKey = joinKey;
		return playerTeam;
	}

	public PlayerTeam CreateTeam()
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		playerTeam.teamID = lastTeamIndex++;
		playerTeam.teamStartTime = Time.realtimeSinceStartup;
		teams.Add(playerTeam.teamID, playerTeam);
		return playerTeam;
	}

	private PlayerTeam CreateTeam(ulong customId)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		playerTeam.teamID = customId;
		playerTeam.teamStartTime = Time.realtimeSinceStartup;
		teams.Add(playerTeam.teamID, playerTeam);
		return playerTeam;
	}

	[ServerUserVar]
	public static void trycreateteam(Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.currentTeam == 0L && Interface.CallHook("OnTeamCreate", (object)basePlayer) == null)
		{
			PlayerTeam playerTeam = ServerInstance.CreateTeam();
			PlayerTeam playerTeam2 = playerTeam;
			playerTeam2.teamLeader = basePlayer.userID;
			playerTeam2.AddPlayer(basePlayer);
			Analytics.Azure.OnTeamChanged("created", playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);
			Interface.CallHook("OnTeamCreated", (object)basePlayer, (object)playerTeam);
		}
	}

	[ServerUserVar]
	public static void promote(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.currentTeam == 0L)
		{
			return;
		}
		BasePlayer lookingAtPlayer = GetLookingAtPlayer(basePlayer);
		if (!((Object)(object)lookingAtPlayer == (Object)null) && !lookingAtPlayer.IsDead() && !((Object)(object)lookingAtPlayer == (Object)(object)basePlayer) && lookingAtPlayer.currentTeam == basePlayer.currentTeam)
		{
			PlayerTeam playerTeam = ServerInstance.teams[basePlayer.currentTeam];
			if (playerTeam != null && playerTeam.teamLeader == (ulong)basePlayer.userID)
			{
				playerTeam.SetTeamLeader(lookingAtPlayer.userID);
			}
		}
	}

	[ServerUserVar]
	public static void promote_id(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.currentTeam == 0L)
		{
			return;
		}
		BasePlayer playerOrSleeperOrBot = arg.GetPlayerOrSleeperOrBot(0);
		if (!((Object)(object)playerOrSleeperOrBot == (Object)null) && !playerOrSleeperOrBot.IsDead() && !((Object)(object)playerOrSleeperOrBot == (Object)(object)basePlayer) && playerOrSleeperOrBot.currentTeam == basePlayer.currentTeam)
		{
			PlayerTeam playerTeam = ServerInstance.teams[basePlayer.currentTeam];
			if (playerTeam != null && playerTeam.teamLeader == (ulong)basePlayer.userID)
			{
				playerTeam.SetTeamLeader(playerOrSleeperOrBot.userID);
			}
		}
	}

	[ServerUserVar]
	public static void leaveteam(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && basePlayer.currentTeam != 0L)
		{
			PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
			if (playerTeam != null && Interface.CallHook("OnTeamLeave", (object)playerTeam, (object)basePlayer) == null)
			{
				playerTeam.RemovePlayer(basePlayer.userID);
				basePlayer.ClearTeam();
			}
		}
	}

	[ServerUserVar]
	public static void acceptinvite(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamAcceptInvite", (object)playerTeam, (object)basePlayer) == null)
			{
				playerTeam.AcceptInvite(basePlayer);
			}
		}
	}

	[ServerUserVar]
	public static void rejectinvite(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamRejectInvite", (object)basePlayer, (object)playerTeam) == null)
			{
				playerTeam.RejectInvite(basePlayer);
			}
		}
	}

	public static BasePlayer GetLookingAtPlayer(BasePlayer source)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit hit = default(RaycastHit);
		if (Physics.Raycast(source.eyes.position, source.eyes.HeadForward(), ref hit, 5f, 1218652417, (QueryTriggerInteraction)1))
		{
			BaseEntity entity = hit.GetEntity();
			if (Object.op_Implicit((Object)(object)entity))
			{
				return ((Component)entity).GetComponent<BasePlayer>();
			}
		}
		return null;
	}

	[ServerVar]
	public static void sleeptoggle(Arg arg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		RaycastHit hit = default(RaycastHit);
		if ((Object)(object)basePlayer == (Object)null || !Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 1218652417, (QueryTriggerInteraction)1))
		{
			return;
		}
		BaseEntity entity = hit.GetEntity();
		if (!Object.op_Implicit((Object)(object)entity))
		{
			return;
		}
		BasePlayer component = ((Component)entity).GetComponent<BasePlayer>();
		if (Object.op_Implicit((Object)(object)component) && (Object)(object)component != (Object)(object)basePlayer && !component.IsNpc)
		{
			if (component.IsSleeping())
			{
				component.EndSleeping();
			}
			else
			{
				component.StartSleeping();
			}
		}
	}

	[ServerUserVar]
	public static void kickmember(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam != null && !((Object)(object)playerTeam.GetLeader() != (Object)(object)basePlayer))
		{
			ulong uLong = arg.GetULong(0, 0uL);
			if ((ulong)basePlayer.userID != uLong && Interface.CallHook("OnTeamKick", (object)playerTeam, (object)basePlayer, (object)uLong) == null)
			{
				playerTeam.RemovePlayer(uLong);
			}
		}
	}

	[ServerUserVar]
	public static void sendinvite(Arg arg)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam == null || (Object)(object)playerTeam.GetLeader() == (Object)null || (Object)(object)playerTeam.GetLeader() != (Object)(object)basePlayer)
		{
			return;
		}
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			return;
		}
		BasePlayer basePlayer2 = BaseNetworkable.serverEntities.Find(new NetworkableId(uLong)) as BasePlayer;
		if (Object.op_Implicit((Object)(object)basePlayer2) && (Object)(object)basePlayer2 != (Object)(object)basePlayer && !basePlayer2.IsNpc && basePlayer2.currentTeam == 0L)
		{
			float num = 7f;
			if (!(Vector3.Distance(((Component)basePlayer2).transform.position, ((Component)basePlayer).transform.position) > num) && Interface.CallHook("OnTeamInvite", (object)basePlayer, (object)basePlayer2) == null)
			{
				playerTeam.SendInvite(basePlayer2);
			}
		}
	}

	public bool HasPendingInvite(ulong forPlayer, out ulong foundTeamID)
	{
		foundTeamID = 0uL;
		foreach (KeyValuePair<ulong, PlayerTeam> team in teams)
		{
			if (team.Value.invites.Contains(forPlayer))
			{
				foundTeamID = team.Key;
				return true;
			}
		}
		return false;
	}

	public bool GetTeamLeaderInfo(ulong teamID, out string leaderDisplayName, out ulong leaderID)
	{
		leaderDisplayName = string.Empty;
		leaderID = 0uL;
		if (teams.TryGetValue(teamID, out var value))
		{
			BasePlayer basePlayer = BasePlayer.FindAwakeOrSleepingByID(value.teamLeader);
			if ((Object)(object)basePlayer != (Object)null)
			{
				leaderDisplayName = basePlayer.displayName;
				leaderID = basePlayer.userID;
				return true;
			}
		}
		return false;
	}

	[ServerUserVar]
	public static void sendofflineinvite(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam == null || (Object)(object)playerTeam.GetLeader() == (Object)null || (Object)(object)playerTeam.GetLeader() != (Object)(object)basePlayer)
		{
			return;
		}
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong != 0L)
		{
			BasePlayer basePlayer2 = BasePlayer.FindAwakeOrSleepingByID(uLong);
			if ((Object)(object)basePlayer2 != (Object)null && !basePlayer2.GetInfoBool("client.allowteaminvitesremoteplayers", defaultVal: true))
			{
				basePlayer.ShowToast(GameTip.Styles.Error, RemoteInvitesBlocked, false);
			}
			else if ((Object)(object)basePlayer2 == (Object)null || (!basePlayer2.IsNpc && basePlayer2.currentTeam == 0L))
			{
				playerTeam.SendInvite(basePlayer2, uLong);
			}
		}
	}

	[ServerVar]
	public static void fakeinvite(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		ulong uLong = arg.GetULong(0, 0uL);
		PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
		if (playerTeam != null)
		{
			if (basePlayer.currentTeam != 0L)
			{
				Debug.Log((object)"already in team");
			}
			playerTeam.SendInvite(basePlayer);
			Debug.Log((object)"sent bot invite");
		}
	}

	[ServerVar]
	public static void addtoteam(Arg arg)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		RaycastHit hit = default(RaycastHit);
		if (playerTeam == null || (Object)(object)playerTeam.GetLeader() == (Object)null || (Object)(object)playerTeam.GetLeader() != (Object)(object)basePlayer || !Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 1218652417, (QueryTriggerInteraction)1))
		{
			return;
		}
		BaseEntity entity = hit.GetEntity();
		if (Object.op_Implicit((Object)(object)entity))
		{
			BasePlayer component = ((Component)entity).GetComponent<BasePlayer>();
			if (Object.op_Implicit((Object)(object)component) && (Object)(object)component != (Object)(object)basePlayer && !component.IsNpc)
			{
				playerTeam.AddPlayer(component);
			}
		}
	}

	[ServerVar]
	public static string createAndAddToTeam(Arg arg)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		uint uInt = arg.GetUInt(0, 0u);
		RaycastHit hit = default(RaycastHit);
		if (Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 1218652417, (QueryTriggerInteraction)1))
		{
			BaseEntity entity = hit.GetEntity();
			if (Object.op_Implicit((Object)(object)entity))
			{
				BasePlayer component = ((Component)entity).GetComponent<BasePlayer>();
				if (Object.op_Implicit((Object)(object)component) && (Object)(object)component != (Object)(object)basePlayer && !component.IsNpc)
				{
					if (component.currentTeam != 0L)
					{
						return component.displayName + " is already in a team";
					}
					if (ServerInstance.FindTeam(uInt) != null)
					{
						ServerInstance.FindTeam(uInt).AddPlayer(component);
						return $"Added {component.displayName} to existing team {uInt}";
					}
					PlayerTeam playerTeam = ServerInstance.CreateTeam(uInt);
					playerTeam.teamLeader = component.userID;
					playerTeam.AddPlayer(component);
					return $"Added {component.displayName} to team {uInt}";
				}
			}
		}
		return "Unable to find valid player in front";
	}

	public static bool TeamsEnabled()
	{
		return maxTeamSize > 0;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk || info.msg.relationshipManager == null)
		{
			return;
		}
		lastTeamIndex = info.msg.relationshipManager.lastTeamIndex;
		foreach (PlayerTeam team in info.msg.relationshipManager.teamList)
		{
			PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
			playerTeam.teamLeader = team.teamLeader;
			playerTeam.teamID = team.teamID;
			playerTeam.teamName = team.teamName;
			playerTeam.joinKey = team.joinKey;
			playerTeam.members = new List<ulong>();
			playerTeam.invites = new List<ulong>();
			foreach (ulong invite in team.invites)
			{
				playerTeam.invites.Add(invite);
			}
			foreach (TeamMember member in team.members)
			{
				playerTeam.members.Add(member.userID);
			}
			teams[playerTeam.teamID] = playerTeam;
		}
		foreach (PlayerTeam value2 in teams.Values)
		{
			foreach (ulong member2 in value2.members)
			{
				playerToTeam[member2] = value2;
				BasePlayer basePlayer = FindByID(member2);
				if ((Object)(object)basePlayer != (Object)null && basePlayer.currentTeam != value2.teamID)
				{
					Debug.LogWarning((object)$"Player {member2} has the wrong teamID: got {basePlayer.currentTeam}, expected {value2.teamID}. Fixing automatically.");
					basePlayer.currentTeam = value2.teamID;
				}
			}
		}
		foreach (PlayerRelationships relationship in info.msg.relationshipManager.relationships)
		{
			ulong playerID = relationship.playerID;
			PlayerRelationships playerRelationships = GetRelationships(playerID);
			playerRelationships.ClearRelations();
			foreach (PlayerRelationshipInfo relation in relationship.relations)
			{
				PlayerRelationshipInfo value = PlayerRelationshipInfo.FromProto(relation);
				playerRelationships.relations.Add(relation.playerID, value);
			}
		}
	}
}


public enum RelationshipType
{
	NONE,
	Acquaintance,
	Friend,
	Enemy
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class PlayerRelationshipInfo : IPooled, IServerFileReceiver, IPlayerInfo
{
	public string displayName;

	public ulong player;

	public RelationshipType type;

	public int weight;

	public uint mugshotCrc;

	public string notes;

	public float lastSeenTime;

	[NonSerialized]
	public float lastMugshotTime;

	public ulong UserId => player;

	public string UserName => displayName;

	public bool IsOnline => false;

	public bool IsMe => false;

	public bool IsFriend => false;

	public bool IsPlayingThisGame => true;

	public string ServerEndpoint => string.Empty;

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
		Reset();
	}

	private void Reset()
	{
		displayName = null;
		player = 0uL;
		type = RelationshipType.NONE;
		weight = 0;
		mugshotCrc = 0u;
		notes = "";
		lastMugshotTime = 0f;
	}

	public PlayerRelationshipInfo ToProto()
	{
		PlayerRelationshipInfo obj = Pool.Get<PlayerRelationshipInfo>();
		obj.playerID = player;
		obj.type = (int)type;
		obj.weight = weight;
		obj.mugshotCrc = mugshotCrc;
		obj.displayName = displayName;
		obj.notes = notes;
		obj.timeSinceSeen = Time.realtimeSinceStartup - lastSeenTime;
		return obj;
	}

	public static PlayerRelationshipInfo FromProto(PlayerRelationshipInfo proto)
	{
		return new PlayerRelationshipInfo
		{
			type = (RelationshipType)proto.type,
			weight = proto.weight,
			displayName = proto.displayName,
			mugshotCrc = proto.mugshotCrc,
			notes = proto.notes,
			player = proto.playerID,
			lastSeenTime = Time.realtimeSinceStartup - proto.timeSinceSeen
		};
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PlayerRelationships : IPooled
{
	public bool dirty;

	public ulong ownerPlayer;

	public Dictionary<ulong, PlayerRelationshipInfo> relations;

	public bool Forget(ulong player)
	{
		if (relations.TryGetValue(player, out var value))
		{
			relations.Remove(player);
			if (value.mugshotCrc != 0)
			{
				ServerInstance.DeleteMugshot(ownerPlayer, player, value.mugshotCrc);
			}
			Pool.Free<PlayerRelationshipInfo>(ref value);
			return true;
		}
		return false;
	}

	public PlayerRelationshipInfo GetRelations(ulong player)
	{
		BasePlayer basePlayer = FindByID(player);
		if (relations.TryGetValue(player, out var value))
		{
			if ((Object)(object)basePlayer != (Object)null)
			{
				value.displayName = basePlayer.displayName;
			}
			return value;
		}
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		if ((Object)(object)basePlayer != (Object)null)
		{
			playerRelationshipInfo.displayName = basePlayer.displayName;
		}
		playerRelationshipInfo.player = player;
		relations.Add(player, playerRelationshipInfo);
		return playerRelationshipInfo;
	}

	public PlayerRelationships()
	{
		LeavePool();
	}

	public void EnterPool()
	{
		ownerPlayer = 0uL;
		if (relations != null)
		{
			Pool.Free<ulong, PlayerRelationshipInfo>(ref relations, true);
		}
	}

	public void LeavePool()
	{
		ownerPlayer = 0uL;
		relations = Pool.Get<Dictionary<ulong, PlayerRelationshipInfo>>();
	}

	public void ClearRelations()
	{
		foreach (KeyValuePair<ulong, PlayerRelationshipInfo> relation in relations)
		{
			var (_, playerRelationshipInfo2) = (KeyValuePair<ulong, PlayerRelationshipInfo>)(ref relation);
			Pool.Free<PlayerRelationshipInfo>(ref playerRelationshipInfo2);
		}
		relations.Clear();
	}
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;

public class PlayerTeam : IPooled
{
	public ulong teamID;

	public string joinKey;

	public string teamName;

	public ulong teamLeader;

	public Vector3 firstSpawnLocation;

	public bool usePartySpawn;

	public List<ulong> members = new List<ulong>();

	public List<ulong> invites = new List<ulong>();

	public float teamStartTime;

	public List<Connection> onlineMemberConnections = new List<Connection>();

	public float teamLifetime => Time.realtimeSinceStartup - teamStartTime;

	public BasePlayer GetLeader()
	{
		return FindByID(teamLeader);
	}

	public void SendInvite(BasePlayer player)
	{
		if (invites.Count > 8)
		{
			invites.RemoveRange(0, 1);
		}
		BasePlayer basePlayer = FindByID(teamLeader);
		if (!((Object)(object)basePlayer == (Object)null))
		{
			ulong item = player.userID.Get();
			if (!invites.Contains(item))
			{
				invites.Add(item);
			}
			player.ClientRPC(RpcTarget.Player("CLIENT_PendingInvite", player), basePlayer.displayName, teamLeader, teamID);
		}
	}

	public void SendInvite(BasePlayer player, ulong id)
	{
		if (invites.Count > 8)
		{
			invites.RemoveRange(0, 1);
		}
		BasePlayer basePlayer = FindByID(teamLeader);
		if (!((Object)(object)basePlayer == (Object)null))
		{
			if (!invites.Contains(id))
			{
				invites.Add(id);
			}
			if ((Object)(object)player != (Object)null)
			{
				player.ClientRPC(RpcTarget.Player("CLIENT_PendingInvite", player), basePlayer.displayName, teamLeader, teamID);
			}
		}
	}

	public void AcceptInvite(BasePlayer player)
	{
		if (invites.Contains(player.userID))
		{
			invites.Remove(player.userID);
			AddPlayer(player);
			player.ClearPendingInvite();
		}
	}

	public void RejectInvite(BasePlayer player)
	{
		player.ClearPendingInvite();
		invites.Remove(player.userID);
	}

	public bool AddPlayer(BasePlayer player, bool skipDirtyUpdate = false)
	{
		if (player.currentTeam != 0L)
		{
			return false;
		}
		if (!AddPlayer(player.userID, skipDirtyUpdate))
		{
			return false;
		}
		player.currentTeam = teamID;
		player.SendNetworkUpdate();
		return true;
	}

	public bool AddPlayer(ulong playerId, bool skipDirtyUpdate = false)
	{
		if (members.Contains(playerId))
		{
			return false;
		}
		if (members.Count >= maxTeamSize)
		{
			return false;
		}
		bool num = members.Count == 0;
		members.Add(playerId);
		ServerInstance.playerToTeam.Add(playerId, this);
		if (!skipDirtyUpdate)
		{
			MarkDirty();
		}
		if (!num)
		{
			Analytics.Azure.OnTeamChanged("added", teamID, teamLeader, playerId, members);
		}
		return true;
	}

	public bool RemovePlayer(ulong playerID)
	{
		if (members.Contains(playerID))
		{
			members.Remove(playerID);
			ServerInstance.playerToTeam.Remove(playerID);
			BasePlayer basePlayer = FindByID(playerID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.ClearTeam();
				basePlayer.BroadcastAppTeamRemoval();
				basePlayer.SendNetworkUpdate();
			}
			if (teamLeader == playerID)
			{
				if (members.Count > 0)
				{
					SetTeamLeader(members[0]);
					Analytics.Azure.OnTeamChanged("removed", teamID, teamLeader, playerID, members);
				}
				else
				{
					Analytics.Azure.OnTeamChanged("disband", teamID, teamLeader, playerID, members);
					Disband();
				}
			}
			MarkDirty();
			return true;
		}
		return false;
	}

	public void SetTeamLeader(ulong newTeamLeader)
	{
		if (Interface.CallHook("OnTeamMemberPromote", (object)this, (object)newTeamLeader) == null)
		{
			Analytics.Azure.OnTeamChanged("promoted", teamID, teamLeader, newTeamLeader, members);
			teamLeader = newTeamLeader;
			MarkDirty();
		}
	}

	public void Disband()
	{
		ServerInstance.DisbandTeam(this);
		Server.TeamChat.Remove(teamID);
	}

	public void MarkDirty()
	{
		foreach (ulong member in members)
		{
			BasePlayer basePlayer = FindByID(member);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.UpdateTeam(teamID);
			}
		}
		this.BroadcastAppTeamUpdate();
	}

	public List<Connection> GetOnlineMemberConnections()
	{
		if (members.Count == 0)
		{
			return null;
		}
		onlineMemberConnections.Clear();
		foreach (ulong member in members)
		{
			BasePlayer basePlayer = FindByID(member);
			if (!((Object)(object)basePlayer == (Object)null) && basePlayer.Connection != null)
			{
				onlineMemberConnections.Add(basePlayer.Connection);
			}
		}
		return onlineMemberConnections;
	}

	void IPooled.EnterPool()
	{
		teamID = 0uL;
		teamName = string.Empty;
		teamLeader = 0uL;
		teamStartTime = 0f;
		joinKey = null;
		members.Clear();
		invites.Clear();
		onlineMemberConnections.Clear();
	}

	void IPooled.LeavePool()
	{
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class RemoteControlEntity : BaseCombatEntity, IRemoteControllable
{
	public static List<IRemoteControllable> allControllables = new List<IRemoteControllable>();

	[Header("RC Entity")]
	public string rcIdentifier = "";

	public Transform viewEyes;

	public GameObjectRef IDPanelPrefab;

	public RemoteControllableControls rcControls;

	public bool CanPing => true;

	public virtual bool CanAcceptInput => false;

	public int ViewerCount { get; set; }

	public CameraViewerId? ControllingViewerId { get; set; }

	public bool IsBeingControlled
	{
		get
		{
			if (ViewerCount > 0)
			{
				return ControllingViewerId.HasValue;
			}
			return false;
		}
	}

	public virtual bool RequiresMouse => false;

	public virtual float MaxRange => 10000f;

	public RemoteControllableControls RequiredControls => rcControls;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RemoteControlEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 1677685895 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestOpenRCPanel "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestOpenRCPanel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_RequestOpenRCPanel(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_RequestOpenRCPanel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1053317251 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetID "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetID", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1053317251u, "Server_SetID", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_SetID(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_SetID");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public Transform GetEyes()
	{
		return viewEyes;
	}

	public float GetFovScale()
	{
		return 1f;
	}

	public BaseEntity GetEnt()
	{
		return this;
	}

	public string GetIdentifier()
	{
		return rcIdentifier;
	}

	public virtual bool InitializeControl(CameraViewerId viewerID)
	{
		ViewerCount++;
		if (CanAcceptInput && !ControllingViewerId.HasValue)
		{
			ControllingViewerId = viewerID;
			return true;
		}
		return !CanAcceptInput;
	}

	public virtual void StopControl(CameraViewerId viewerID)
	{
		ViewerCount--;
		if (ControllingViewerId == viewerID)
		{
			ControllingViewerId = null;
		}
	}

	public virtual void UserInput(InputState inputState, CameraViewerId viewerID)
	{
	}

	public void UpdateIdentifier(string newID, bool clientSend = false)
	{
		_ = rcIdentifier;
		if (base.isServer)
		{
			if (!IDInUse(newID))
			{
				rcIdentifier = newID;
			}
			SendNetworkUpdate();
		}
	}

	public virtual void RCSetup()
	{
		if (base.isServer)
		{
			InstallControllable(this);
		}
	}

	public virtual void RCShutdown()
	{
		if (base.isServer)
		{
			RemoveControllable(this);
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		RCSetup();
	}

	public override void DestroyShared()
	{
		RCShutdown();
		base.DestroyShared();
	}

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", (object)this, (object)playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Server_SetID(RPCMessage msg)
	{
		if ((Object)(object)msg.player == (Object)null || !CanControl(msg.player.userID) || !CanChangeID(msg.player))
		{
			return;
		}
		string text = msg.read.String(256, false);
		if (string.IsNullOrEmpty(text) || ComputerStation.IsValidIdentifier(text))
		{
			string text2 = msg.read.String(256, false);
			if (ComputerStation.IsValidIdentifier(text2) && text == GetIdentifier())
			{
				Debug.Log((object)"SetID success!");
				UpdateIdentifier(text2);
			}
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public void SERVER_RequestOpenRCPanel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanChangeID(player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_OpenRCPanel", player), GetIdentifier());
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.rcEntity = Pool.Get<RCEntity>();
			info.msg.rcEntity.identifier = GetIdentifier();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.rcEntity != null && ComputerStation.IsValidIdentifier(info.msg.rcEntity.identifier))
		{
			UpdateIdentifier(info.msg.rcEntity.identifier);
		}
	}

	public virtual bool CanChangeID(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null && player.CanBuild() && player.IsBuildingAuthed())
		{
			return player.IsHoldingEntity<Hammer>();
		}
		return false;
	}

	public static bool IDInUse(string id)
	{
		return FindByID(id) != null;
	}

	public static IRemoteControllable FindByID(string id)
	{
		foreach (IRemoteControllable allControllable in allControllables)
		{
			if (allControllable != null && allControllable.GetIdentifier() == id)
			{
				return allControllable;
			}
		}
		return null;
	}

	public static bool InstallControllable(IRemoteControllable newControllable)
	{
		if (allControllables.Contains(newControllable))
		{
			return false;
		}
		allControllables.Add(newControllable);
		return true;
	}

	public static bool RemoveControllable(IRemoteControllable newControllable)
	{
		if (!allControllables.Contains(newControllable))
		{
			return false;
		}
		allControllables.Remove(newControllable);
		return true;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class RepairBench : StorageContainer
{
	public float maxConditionLostOnRepair = 0.2f;

	public GameObjectRef skinchangeEffect;

	public const float REPAIR_COST_FRACTION = 0.2f;

	private float nextSkinChangeAudioTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RepairBench.OnRpcMessage", 0);
		try
		{
			if (rpc == 1942825351 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ChangeSkin "));
				}
				TimeWarning val2 = TimeWarning.New("ChangeSkin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1942825351u, "ChangeSkin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ChangeSkin(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ChangeSkin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1178348163 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RepairItem "));
				}
				TimeWarning val2 = TimeWarning.New("RepairItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1178348163u, "RepairItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RepairItem(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RepairItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static float GetRepairFraction(Item itemToRepair)
	{
		return GetRepairFraction(itemToRepair.condition, itemToRepair.maxCondition);
	}

	public static float GetRepairFraction(float condition, float maxCondition)
	{
		return 1f - condition / maxCondition;
	}

	public static float RepairCostFraction(Item itemToRepair)
	{
		return GetRepairFraction(itemToRepair) * 0.2f;
	}

	public static float RepairCostFraction(float condition, float maxCondition)
	{
		return GetRepairFraction(condition, maxCondition) * 0.2f;
	}

	public static void GetRepairCostList(ItemBlueprint bp, List<ItemAmount> allIngredients)
	{
		ItemDefinition targetItem = bp.targetItem;
		ItemModRepair itemModRepair = ((targetItem != null) ? ((Component)targetItem).GetComponent<ItemModRepair>() : null);
		if ((Object)(object)itemModRepair != (Object)null && itemModRepair.canUseRepairBench)
		{
			return;
		}
		foreach (ItemAmount ingredient in bp.GetIngredients())
		{
			allIngredients.Add(new ItemAmount(ingredient.itemDef, ingredient.amount));
		}
		StripComponentRepairCost(allIngredients);
	}

	public static void StripComponentRepairCost(List<ItemAmount> allIngredients, float repairCostMultiplier = 1f)
	{
		if (allIngredients == null)
		{
			return;
		}
		for (int i = 0; i < allIngredients.Count; i++)
		{
			ItemAmount itemAmount = allIngredients[i];
			if (itemAmount.itemDef.category != ItemCategory.Component && !itemAmount.itemDef.treatAsComponentForRepairs)
			{
				continue;
			}
			if ((Object)(object)itemAmount.itemDef.Blueprint != (Object)null)
			{
				bool flag = false;
				ItemAmount itemAmount2 = itemAmount.itemDef.Blueprint.GetIngredients()[0];
				foreach (ItemAmount allIngredient in allIngredients)
				{
					if ((Object)(object)allIngredient.itemDef == (Object)(object)itemAmount2.itemDef)
					{
						allIngredient.amount += Mathf.Max(itemAmount2.amount * itemAmount.amount * repairCostMultiplier, 1f);
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					allIngredients.Add(new ItemAmount(itemAmount2.itemDef, Mathf.Max(itemAmount2.amount * itemAmount.amount * repairCostMultiplier, 1f)));
				}
			}
			allIngredients.RemoveAt(i);
			i--;
		}
	}

	public void debugprint(string toPrint)
	{
		if (Global.developer > 0)
		{
			Debug.LogWarning((object)toPrint);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void ChangeSkin(RPCMessage msg)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c6: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		int inventoryId = msg.read.Int32();
		ItemId val = ((msg.read.Unread > 0) ? new ItemId(msg.read.UInt64()) : default(ItemId));
		bool isValid = ((ItemId)(ref val)).IsValid;
		bool flag = !isValid || Time.realtimeSinceStartup > nextSkinChangeAudioTime;
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || Interface.CallHook("OnItemSkinChange", (object)inventoryId, (object)slot, (object)this, (object)player) != null || (isValid && slot.uid != val))
		{
			return;
		}
		bool flag2 = false;
		if (msg.player.UnlockAllSkins)
		{
			flag2 = true;
		}
		if (inventoryId != 0 && !flag2 && !player.blueprints.CheckSkinOwnership(inventoryId, player.userID))
		{
			debugprint("RepairBench.ChangeSkin player does not have item :" + inventoryId + ":");
			return;
		}
		ulong Skin = ItemDefinition.FindSkin(slot.info.itemid, inventoryId);
		if (Skin == slot.skin && (Object)(object)slot.info.isRedirectOf == (Object)null)
		{
			debugprint("RepairBench.ChangeSkin cannot apply same skin twice : " + Skin + ": " + slot.skin);
			return;
		}
		ItemSkinDirectory.Skin skin = slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		ItemDefinition itemDefinition = slot.info;
		int num = 0;
		if ((Object)(object)slot.info.isRedirectOf != (Object)null)
		{
			Skin = ItemDefinition.FindSkin(slot.info.isRedirectOf.itemid, inventoryId);
			skin = slot.info.isRedirectOf.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
			if ((Object)(object)skin.invItem == (Object)null)
			{
				if (((IEnumerable<IPlayerItemDefinition>)slot.info.isRedirectOf.skins2).FirstOrDefault((Func<IPlayerItemDefinition, bool>)((IPlayerItemDefinition x) => x.DefinitionId == inventoryId)) != null)
				{
					itemDefinition = slot.info.isRedirectOf;
					num = inventoryId;
				}
				else
				{
					itemDefinition = slot.info.isRedirectOf;
					num = 0;
				}
			}
			else
			{
				num = skin.invItem.id;
				if (skin.invItem is ItemSkin itemSkin)
				{
					if ((Object)(object)itemSkin.Redirect != (Object)null)
					{
						itemDefinition = itemSkin.Redirect;
						num = 0;
					}
					else if ((Object)(object)itemSkin.Redirect == (Object)null && (Object)(object)slot.info.isRedirectOf != (Object)null)
					{
						itemDefinition = slot.info.isRedirectOf;
					}
				}
			}
		}
		else if (slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin).invItem is ItemSkin itemSkin2 && (Object)(object)itemSkin2.Redirect != (Object)null)
		{
			itemDefinition = itemSkin2.Redirect;
		}
		if ((Object)(object)itemDefinition == (Object)(object)slot.info && (Object)(object)itemDefinition.isRedirectOf != (Object)null && num == 0)
		{
			return;
		}
		if (flag)
		{
			nextSkinChangeAudioTime = Time.realtimeSinceStartup + 0.75f;
		}
		if ((Object)(object)itemDefinition != (Object)(object)slot.info)
		{
			bool flag3 = false;
			flag3 = num != 0;
			float condition = slot.condition;
			float maxCondition = slot.maxCondition;
			int amount = slot.amount;
			int ammoCount = 0;
			int num2 = 0;
			ItemModContainerArmorSlot component = ((Component)slot.info).GetComponent<ItemModContainerArmorSlot>();
			if ((Object)(object)component != (Object)null && slot.contents != null)
			{
				num2 = slot.contents.capacity;
			}
			ItemDefinition ammoType = null;
			if ((Object)(object)slot.GetHeldEntity() != (Object)null && slot.GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)
			{
				ammoCount = baseProjectile.primaryMagazine.contents;
				ammoType = baseProjectile.primaryMagazine.ammoType;
			}
			List<Item> list = Pool.Get<List<Item>>();
			if (slot.contents != null && slot.contents.itemList != null && slot.contents.itemList.Count > 0)
			{
				if (slot.contents.itemList.Count > list.Capacity)
				{
					list.Capacity = slot.contents.itemList.Count;
				}
				foreach (Item item2 in slot.contents.itemList)
				{
					list.Add(item2);
				}
				foreach (Item item3 in list)
				{
					item3.RemoveFromContainer();
				}
			}
			Item item = ItemManager.Create(itemDefinition, 1, 0uL);
			item.ownershipShares = slot.ownershipShares;
			slot.ownershipShares = null;
			slot.Remove();
			ItemManager.DoRemoves();
			item.MoveToContainer(base.inventory, 0, allowStack: false);
			item.maxCondition = maxCondition;
			item.condition = condition;
			item.amount = amount;
			if ((Object)(object)item.GetHeldEntity() != (Object)null && item.GetHeldEntity() is BaseProjectile baseProjectile2)
			{
				if (baseProjectile2.primaryMagazine != null)
				{
					baseProjectile2.SetAmmoCount(ammoCount);
					baseProjectile2.primaryMagazine.ammoType = ammoType;
				}
				baseProjectile2.ForceModsChanged();
			}
			if (num2 > 0)
			{
				component = ((Component)item.info).GetComponent<ItemModContainerArmorSlot>();
				component.CreateAtCapacity(num2, item);
			}
			if (list.Count > 0 && item.contents != null)
			{
				if ((Object)(object)component != (Object)null)
				{
					for (int i = 0; i < list.Count; i++)
					{
						list[i]?.MoveToContainer(item.contents, i, allowStack: false);
					}
				}
				else
				{
					foreach (Item item4 in list)
					{
						item4.MoveToContainer(item.contents);
					}
				}
			}
			Pool.Free<Item>(ref list, false);
			if (flag3)
			{
				ApplySkinToItem(item, Skin);
			}
			Analytics.Azure.OnSkinChanged(player, this, item, Skin);
		}
		else
		{
			ApplySkinToItem(slot, Skin);
			Analytics.Azure.OnSkinChanged(player, this, slot, Skin);
		}
		if (flag && skinchangeEffect.isValid)
		{
			Effect.server.Run(skinchangeEffect.resourcePath, this, 0u, new Vector3(0f, 1.5f, 0f), Vector3.zero);
		}
	}

	private void ApplySkinToItem(Item item, ulong Skin)
	{
		item.skin = Skin;
		item.MarkDirty();
		BaseEntity heldEntity = item.GetHeldEntity();
		if ((Object)(object)heldEntity != (Object)null)
		{
			heldEntity.skinID = Skin;
			heldEntity.SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RepairItem(RPCMessage msg)
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot != null)
		{
			BasePlayer player = msg.player;
			float conditionLost = maxConditionLostOnRepair;
			ItemModRepair component = ((Component)slot.info).GetComponent<ItemModRepair>();
			if ((Object)(object)component != (Object)null)
			{
				conditionLost = component.conditionLost;
			}
			RepairAnItem(slot, player, this, conditionLost, mustKnowBlueprint: true);
		}
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return 0;
	}

	public static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)
	{
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		if (itemToRepair == null)
		{
			return;
		}
		ItemDefinition info = itemToRepair.info;
		ItemBlueprint blueprint = info.Blueprint;
		if (!Object.op_Implicit((Object)(object)blueprint))
		{
			return;
		}
		ItemModRepair component = ((Component)itemToRepair.info).GetComponent<ItemModRepair>();
		if (!info.condition.repairable || itemToRepair.condition == itemToRepair.maxCondition)
		{
			return;
		}
		if (mustKnowBlueprint)
		{
			ItemDefinition itemDefinition = (((Object)(object)info.isRedirectOf != (Object)null) ? info.isRedirectOf : info);
			bool flag = player.blueprints.HasUnlocked(itemDefinition) || ((Object)(object)itemDefinition.Blueprint != (Object)null && !itemDefinition.Blueprint.isResearchable);
			if (!flag && (Object)(object)BaseGameMode.svActiveGameMode != (Object)null && BaseGameMode.svActiveGameMode.canRepairIfCraftingBanned && !itemDefinition.IsAllowed((EraRestriction)4))
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
		}
		if (Interface.CallHook("OnItemRepair", (object)player, (object)itemToRepair) != null)
		{
			return;
		}
		float num = RepairCostFraction(itemToRepair);
		bool flag2 = false;
		List<ItemAmount> list = Pool.Get<List<ItemAmount>>();
		GetRepairCostList(blueprint, list);
		foreach (ItemAmount item in list)
		{
			if (item.itemDef.category != ItemCategory.Component)
			{
				int amount = player.inventory.GetAmount(item.itemDef.itemid);
				if (Mathf.CeilToInt(item.amount * num) > amount)
				{
					flag2 = true;
					break;
				}
			}
		}
		if (flag2)
		{
			Pool.FreeUnmanaged<ItemAmount>(ref list);
			return;
		}
		foreach (ItemAmount item2 in list)
		{
			if (item2.itemDef.category != ItemCategory.Component)
			{
				int amount2 = Mathf.CeilToInt(item2.amount * num);
				player.inventory.Take(null, item2.itemid, amount2);
				Analytics.Azure.LogResource(Analytics.Azure.ResourceMode.Consumed, "repair", item2.itemDef.shortname, amount2, repairBenchEntity, null, safezone: false, null, 0uL, null, itemToRepair);
			}
		}
		Pool.FreeUnmanaged<ItemAmount>(ref list);
		float conditionNormalized = itemToRepair.conditionNormalized;
		float maxConditionNormalized = itemToRepair.maxConditionNormalized;
		itemToRepair.DoRepair(maxConditionLostOnRepair);
		Analytics.Azure.OnItemRepaired(player, repairBenchEntity, itemToRepair, conditionNormalized, maxConditionNormalized);
		if (Global.developer > 0)
		{
			Debug.Log((object)("Item repaired! condition : " + itemToRepair.condition + "/" + itemToRepair.maxCondition));
		}
		string strName = "assets/bundled/prefabs/fx/repairbench/itemrepair.prefab";
		if ((Object)(object)component != (Object)null && (Object)(object)component.successEffect?.Get() != (Object)null)
		{
			strName = component.successEffect.resourcePath;
		}
		Effect.server.Run(strName, repairBenchEntity, 0u, Vector3.zero, Vector3.zero);
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class ResearchTable : StorageContainer
{
	public enum ResearchType
	{
		ResearchTable,
		TechTree
	}

	[NonSerialized]
	public float researchFinishedTime;

	public float researchCostFraction = 1f;

	public float researchDuration = 10f;

	public int requiredPaper = 10;

	public GameObjectRef researchStartEffect;

	public GameObjectRef researchFailEffect;

	public GameObjectRef researchSuccessEffect;

	public ItemDefinition researchResource;

	public BasePlayer user;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ResearchTable.OnRpcMessage", 0);
		try
		{
			if (rpc == 3177710095u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoResearch "));
				}
				TimeWarning val2 = TimeWarning.New("DoResearch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3177710095u, "DoResearch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoResearch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoResearch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		researchFinishedTime = 0f;
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		if (item.info.shortname == "scrap")
		{
			Item slot = base.inventory.GetSlot(1);
			if (slot == null)
			{
				return 1;
			}
			if (slot.amount < item.MaxStackable())
			{
				return 1;
			}
		}
		return base.GetIdealSlot(player, container, item);
	}

	public bool IsResearching()
	{
		return HasFlag(Flags.On);
	}

	public int RarityMultiplier(Rarity rarity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Invalid comparison between Unknown and I4
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Invalid comparison between Unknown and I4
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Invalid comparison between Unknown and I4
		if ((int)rarity == 1)
		{
			return 20;
		}
		if ((int)rarity == 2)
		{
			return 15;
		}
		if ((int)rarity == 3)
		{
			return 10;
		}
		return 5;
	}

	public int GetBlueprintStacksize(Item sourceItem)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		int result = RarityMultiplier(sourceItem.info.rarity);
		if (sourceItem.info.category == ItemCategory.Ammunition)
		{
			result = Mathf.FloorToInt((float)sourceItem.MaxStackable() / (float)sourceItem.info.Blueprint.amountToCreate) * 2;
		}
		return result;
	}

	public static int ScrapForResearch(Item item)
	{
		object obj = Interface.CallHook("OnResearchCostDetermine", (object)item);
		if (obj is int)
		{
			return (int)obj;
		}
		return ScrapForResearch(item.info);
	}

	public static int ScrapForResearch(ItemDefinition info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Invalid comparison between Unknown and I4
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Invalid comparison between Unknown and I4
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Invalid comparison between Unknown and I4
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Invalid comparison between Unknown and I4
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnResearchCostDetermine", (object)info);
		if (obj is int)
		{
			return (int)obj;
		}
		if ((Object)(object)info.isRedirectOf != (Object)null)
		{
			return ScrapForResearch(info.isRedirectOf);
		}
		int result = 0;
		if ((int)info.rarity == 1)
		{
			result = 20;
		}
		if ((int)info.rarity == 2)
		{
			result = 75;
		}
		if ((int)info.rarity == 3)
		{
			result = 125;
		}
		if ((int)info.rarity == 4 || (int)info.rarity == 0)
		{
			result = 500;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(info);
		if ((Object)(object)itemBlueprint != (Object)null && itemBlueprint.defaultBlueprint)
		{
			return ConVar.Server.defaultBlueprintResearchCost;
		}
		return result;
	}

	public bool IsItemResearchable(Item item)
	{
		ItemDefinition itemDefinition = (((Object)(object)item.info.isRedirectOf != (Object)null) ? item.info.isRedirectOf : item.info);
		if (!itemDefinition.IsAllowed((EraRestriction)4))
		{
			return false;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(itemDefinition);
		if ((Object)(object)itemBlueprint != (Object)null && itemBlueprint.defaultBlueprint)
		{
			return true;
		}
		if ((Object)(object)itemBlueprint == (Object)null || !itemBlueprint.isResearchable)
		{
			return false;
		}
		return true;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.canAcceptItem = ItemFilter;
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (targetSlot == 1 && (Object)(object)item.info != (Object)(object)researchResource)
		{
			return false;
		}
		return base.ItemFilter(item, targetSlot);
	}

	public Item GetTargetItem()
	{
		return base.inventory.GetSlot(0);
	}

	public Item GetScrapItem()
	{
		Item slot = base.inventory.GetSlot(1);
		if (slot == null || (Object)(object)slot.info != (Object)(object)researchResource)
		{
			return null;
		}
		return slot;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (HasFlag(Flags.On))
		{
			((FacepunchBehaviour)this).Invoke((Action)ResearchAttemptFinished, researchDuration);
		}
		base.inventory.SetLocked(isLocked: false);
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		user = player;
		return base.PlayerOpenLoot(player);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		user = null;
		base.PlayerStoppedLooting(player);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", (object)player, (object)targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", (object)this, (object)targetItem, (object)player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = Time.realtimeSinceStartup + researchDuration;
			((FacepunchBehaviour)this).Invoke((Action)ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			int scrapCost = ScrapForResearch(targetItem);
			Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

	public void ResearchAttemptFinished()
	{
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		Item targetItem = GetTargetItem();
		Item scrapItem = GetScrapItem();
		if (targetItem != null && scrapItem != null)
		{
			int num = ScrapForResearch(targetItem);
			object obj = Interface.CallHook("OnItemResearched", (object)this, (object)num);
			if (obj is int)
			{
				num = (int)obj;
			}
			if (scrapItem.amount >= num)
			{
				if (scrapItem.amount == num)
				{
					base.inventory.Remove(scrapItem);
					scrapItem.RemoveFromContainer();
					scrapItem.Remove();
				}
				else
				{
					scrapItem.UseItem(num);
				}
				base.inventory.Remove(targetItem);
				targetItem.Remove();
				Item item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);
				if ((Object)(object)base.LastLootedByPlayer != (Object)null)
				{
					item.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.ResearchTable);
				}
				item.blueprintTarget = (((Object)(object)targetItem.info.isRedirectOf != (Object)null) ? targetItem.info.isRedirectOf.itemid : targetItem.info.itemid);
				if (!item.MoveToContainer(base.inventory, 0))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
				if (researchSuccessEffect.isValid)
				{
					Effect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		SendNetworkUpdateImmediate();
		if ((Object)(object)user != (Object)null)
		{
			user.inventory.loot.SendImmediate();
		}
		EndResearch();
	}

	public void CancelResearch()
	{
	}

	public void EndResearch()
	{
		base.inventory.SetLocked(isLocked: false);
		SetFlag(Flags.On, b: false);
		researchFinishedTime = 0f;
		SendNetworkUpdate();
		if ((Object)(object)user != (Object)null)
		{
			user.inventory.loot.SendImmediate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.researchTable = Pool.Get<ResearchTable>();
		info.msg.researchTable.researchTimeLeft = researchFinishedTime - Time.realtimeSinceStartup;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.researchTable != null)
		{
			researchFinishedTime = Time.realtimeSinceStartup + info.msg.researchTable.researchTimeLeft;
		}
	}
}


public enum ResearchType
{
	ResearchTable,
	TechTree
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class ResourceContainer : EntityComponent<BaseEntity>
{
	public bool lootable = true;

	[NonSerialized]
	public ItemContainer container;

	[NonSerialized]
	public float lastAccessTime;

	public int accessedSecondsAgo => (int)(Time.realtimeSinceStartup - lastAccessTime);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ResourceContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 548378753 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartLootingContainer "));
				}
				TimeWarning val2 = TimeWarning.New("StartLootingContainer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!BaseEntity.RPC_Server.IsVisible.Test(548378753u, "StartLootingContainer", GetBaseEntity(), player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							BaseEntity.RPCMessage msg2 = rPCMessage;
							StartLootingContainer(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in StartLootingContainer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[BaseEntity.RPC_Server.IsVisible(3f)]
	[BaseEntity.RPC_Server]
	private void StartLootingContainer(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (Object.op_Implicit((Object)(object)player) && player.CanInteract() && lootable && Interface.CallHook("CanLootEntity", (object)player, (object)this) == null && player.inventory.loot.StartLootingEntity(base.baseEntity))
		{
			lastAccessTime = Time.realtimeSinceStartup;
			player.inventory.loot.AddContainer(container);
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class RFBroadcaster : IOEntity, IRFObject
{
	public int frequency;

	public GameObjectRef frequencyPanelPrefab;

	public const Flags Flag_Broadcasting = Flags.Reserved3;

	public bool playerUsable = true;

	private float nextChangeTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RFBroadcaster.OnRpcMessage", 0);
		try
		{
			if (rpc == 1052196345 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestOpenPanel "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestOpenPanel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_RequestOpenPanel(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_RequestOpenPanel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2778616053u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSetFrequency "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSetFrequency", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2778616053u, "ServerSetFrequency", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2778616053u, "ServerSetFrequency", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ServerSetFrequency(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerSetFrequency");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public int GetFrequency()
	{
		return frequency;
	}

	public override bool WantsPower(int inputIndex)
	{
		return true;
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public float GetMaxRange()
	{
		return float.PositiveInfinity;
	}

	public void RFSignalUpdate(bool on)
	{
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.IsVisible(3f)]
	public void ServerSetFrequency(RPCMessage msg)
	{
		if (!CanChangeFrequency(msg.player) || Time.time < nextChangeTime)
		{
			return;
		}
		nextChangeTime = Time.time + 2f;
		int freq = msg.read.Int32();
		freq = RFManager.ClampFrequency(freq);
		if (RFManager.IsReserved(freq))
		{
			RFManager.ReserveErrorPrint(msg.player);
			return;
		}
		RFManager.ChangeFrequency(frequency, freq, this, isListener: false, IsPowered());
		if (Interface.CallHook("OnRfFrequencyChange", (object)this, (object)freq, (object)msg.player) == null)
		{
			frequency = freq;
			MarkDirty();
			SendNetworkUpdate();
			Hurt(MaxHealth() * 0.01f, DamageType.Decay, this);
			Interface.CallHook("OnRfFrequencyChanged", (object)this, (object)freq, (object)msg.player);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.ioEntity.genericInt1 = frequency;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			frequency = info.msg.ioEntity.genericInt1;
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputAmount > 0)
		{
			RFManager.AddBroadcaster(frequency, this);
			SetFlag(Flags.Reserved3, b: true, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
		else
		{
			StopBroadcasting();
		}
	}

	public void StopBroadcasting()
	{
		SetFlag(Flags.Reserved3, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		RFManager.RemoveBroadcaster(frequency, this);
	}

	internal override void DoServerDestroy()
	{
		RFManager.RemoveBroadcaster(frequency, this);
		base.DoServerDestroy();
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	public void SERVER_RequestOpenPanel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanChangeFrequency(player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_OpenPanel", player), frequency);
		}
	}

	private bool CanChangeFrequency(BasePlayer player)
	{
		if (playerUsable && (Object)(object)player != (Object)null)
		{
			return player.CanBuild();
		}
		return false;
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class RFReceiver : IOEntity, IRFObject
{
	public int frequency;

	public GameObjectRef frequencyPanelPrefab;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RFReceiver.OnRpcMessage", 0);
		try
		{
			if (rpc == 1052196345 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestOpenPanel "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestOpenPanel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_RequestOpenPanel(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_RequestOpenPanel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2778616053u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSetFrequency "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSetFrequency", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2778616053u, "ServerSetFrequency", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2778616053u, "ServerSetFrequency", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ServerSetFrequency(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerSetFrequency");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public int GetFrequency()
	{
		return frequency;
	}

	public override bool WantsPower(int inputIndex)
	{
		return IsOn();
	}

	public override void ResetIOState()
	{
		SetFlag(Flags.On, b: false);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsOn())
		{
			return 0;
		}
		return GetCurrentEnergy();
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public float GetMaxRange()
	{
		return 100000f;
	}

	internal override void DoServerDestroy()
	{
		RFManager.RemoveListener(frequency, this);
		base.DoServerDestroy();
	}

	public void RFSignalUpdate(bool on)
	{
		if (!base.IsDestroyed && IsOn() != on && !(!IsPowered() && on))
		{
			SetFlag(Flags.On, on, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
			MarkDirty();
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputAmount > 0 && !IsOn())
		{
			RFManager.AddListener(frequency, this);
		}
		else if (inputAmount == 0)
		{
			RFManager.RemoveListener(frequency, this);
			SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ServerSetFrequency(RPCMessage msg)
	{
		if (!((Object)(object)msg.player == (Object)null) && msg.player.CanBuild())
		{
			int num = msg.read.Int32();
			if (Interface.CallHook("OnRfFrequencyChange", (object)this, (object)num, (object)msg.player) == null)
			{
				num = RFManager.ClampFrequency(num);
				RFManager.ChangeFrequency(frequency, num, this, isListener: true);
				frequency = num;
				MarkDirty();
				SendNetworkUpdate();
				Interface.CallHook("OnRfFrequencyChanged", (object)this, (object)num, (object)msg.player);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	public void SERVER_RequestOpenPanel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanChangeFrequency(player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_OpenPanel", player), frequency);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.ioEntity.genericInt1 = frequency;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			frequency = info.msg.ioEntity.genericInt1;
		}
	}

	private bool CanChangeFrequency(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			return player.CanBuild();
		}
		return false;
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class RFTimedExplosive : TimedExplosive, IRFObject
{
	private const float pickupTime = 5f;

	public SoundPlayer beepLoop;

	private ulong creatorPlayerID;

	public ItemDefinition pickupDefinition;

	public float minutesUntilDecayed = 1440f;

	private float startPickupTime;

	private int RFFrequency = -1;

	private float decayTickDuration = 3600f;

	private float minutesDecayed;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RFTimedExplosive.OnRpcMessage", 0);
		try
		{
			if (rpc == 2778075470u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Pickup "));
				}
				TimeWarning val2 = TimeWarning.New("Pickup", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2778075470u, "Pickup", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Pickup(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Pickup");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2145528377 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - PickupTimer "));
				}
				TimeWarning val2 = TimeWarning.New("PickupTimer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2145528377u, "PickupTimer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							PickupTimer(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in PickupTimer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public float GetMaxRange()
	{
		return float.PositiveInfinity;
	}

	public void RFSignalUpdate(bool on)
	{
		if (IsArmed() && on && !((FacepunchBehaviour)this).IsInvoking((Action)Explode))
		{
			((FacepunchBehaviour)this).Invoke((Action)Explode, Random.Range(0f, 0.2f));
		}
	}

	public void SetFrequency(int newFreq)
	{
		RFManager.RemoveListener(RFFrequency, this);
		RFFrequency = newFreq;
		if (RFFrequency > 0)
		{
			RFManager.AddListener(RFFrequency, this);
		}
	}

	public int GetFrequency()
	{
		return RFFrequency;
	}

	public override void SetFuse(float fuseLength)
	{
		if (!base.isServer)
		{
			return;
		}
		if (GetFrequency() > 0)
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)Explode))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Explode);
			}
			((FacepunchBehaviour)this).Invoke((Action)ArmRF, fuseLength);
			SetFlag(Flags.Reserved1, b: true, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, b: true);
		}
		else
		{
			base.SetFuse(fuseLength);
		}
	}

	public void ArmRF()
	{
		SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, b: false);
		SendNetworkUpdate();
	}

	public void DisarmRF()
	{
		SetFlag(Flags.On, b: false);
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.explosive == null)
		{
			info.msg.explosive = Pool.Get<TimedExplosive>();
		}
		if (info.forDisk)
		{
			info.msg.explosive.freq = GetFrequency();
		}
		info.msg.explosive.creatorID = creatorPlayerID;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFrequency(RFFrequency);
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayCheck, decayTickDuration, decayTickDuration, 10f);
	}

	public void DecayCheck()
	{
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
		BasePlayer basePlayer = BasePlayer.FindByID(creatorPlayerID);
		if ((Object)(object)basePlayer != (Object)null && ((Object)(object)buildingPrivilege == (Object)null || !buildingPrivilege.IsAuthed(basePlayer)))
		{
			minutesDecayed += decayTickDuration / 60f;
		}
		if (minutesDecayed >= minutesUntilDecayed)
		{
			Kill();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (RFFrequency > 0)
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)Explode))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Explode);
			}
			SetFrequency(RFFrequency);
			ArmRF();
		}
	}

	internal override void DoServerDestroy()
	{
		if (RFFrequency > 0)
		{
			RFManager.RemoveListener(RFFrequency, this);
		}
		base.DoServerDestroy();
	}

	public void ChangeFrequency(int newFreq)
	{
		RFManager.ChangeFrequency(RFFrequency, newFreq, this, isListener: true);
		RFFrequency = newFreq;
	}

	public override void SetCreatorEntity(BaseEntity newCreatorEntity)
	{
		base.SetCreatorEntity(newCreatorEntity);
		BasePlayer component = ((Component)newCreatorEntity).GetComponent<BasePlayer>();
		if (Object.op_Implicit((Object)(object)component))
		{
			creatorPlayerID = component.userID;
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (Interface.CallHook("ICanPickupEntity", (object)msg.player, (object)this) != null || !msg.player.CanInteract() || !IsArmed())
		{
			return;
		}
		Item item = ItemManager.Create(pickupDefinition, 1, 0uL);
		if (item != null)
		{
			if (ItemOwnership.IsValid())
			{
				item.SetItemOwnership(ItemOwnership);
			}
			if (!(Mathf.Abs(startPickupTime + 5f - Time.realtimeSinceStartup) > ConVar.AntiHack.rpc_timer_forgiveness))
			{
				item.instanceData.dataInt = GetFrequency();
				item.SetFlag(Item.Flag.IsOn, IsArmed());
				msg.player.GiveItem(item, GiveItemReason.PickedUp);
				Kill();
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void PickupTimer(RPCMessage msg)
	{
		if (msg.player.CanInteract() && IsArmed())
		{
			startPickupTime = Time.realtimeSinceStartup;
		}
	}

	public bool IsArmed()
	{
		return HasFlag(Flags.On);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.explosive == null)
		{
			return;
		}
		creatorPlayerID = info.msg.explosive.creatorID;
		if (base.isServer)
		{
			if (info.fromDisk)
			{
				RFFrequency = info.msg.explosive.freq;
			}
			creatorEntity = BasePlayer.FindByID(creatorPlayerID);
		}
	}

	public bool CanPickup(BasePlayer player)
	{
		return IsArmed();
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class RHIB : MotorRowboat
{
	public Transform steeringWheelLeftHandTarget;

	public Transform steeringWheelRightHandTarget;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float rhibpopulation;

	private float targetGasPedal;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RHIB.OnRpcMessage", 0);
		try
		{
			if (rpc == 1382282393 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_Release "));
				}
				TimeWarning val2 = TimeWarning.New("Server_Release", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1382282393u, "Server_Release", this, player, 6f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_Release(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_Release");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(6f)]
	public void Server_Release(RPCMessage msg)
	{
		if (!((Object)(object)GetParentEntity() == (Object)null))
		{
			SetParent(null, worldPositionStays: true, sendImmediate: true);
			SetToNonKinematic();
		}
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("RHIB.VehicleFixedUpdate", 0);
		try
		{
			gasPedal = Mathf.MoveTowards(gasPedal, targetGasPedal, Time.fixedDeltaTime * 1f);
			base.VehicleFixedUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override bool EngineOn()
	{
		return base.EngineOn();
	}

	public override void DriverInput(InputState inputState, BasePlayer player)
	{
		base.DriverInput(inputState, player);
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			targetGasPedal = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			targetGasPedal = -0.5f;
		}
		else
		{
			targetGasPedal = 0f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			steering = 1f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			steering = -1f;
		}
		else
		{
			steering = 0f;
		}
	}

	public void AddFuel(int amount)
	{
		fuelSystem.AddFuel(amount);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using FIMSpace.FProceduralAnimation;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class RidableHorse : BaseVehicle, IInventoryProvider, IDetector, HitchTrough.IHitchable, TriggerHurtNotChild.IHurtTriggerUser, IAnimalRagdollCollisionReceiver, ITowing
{
	public enum GaitType : byte
	{
		Walk,
		Trot,
		Canter,
		Gallop
	}

	[Serializable]
	public struct Gait
	{
		public GaitType gaitType;

		public float minSpeed;

		public float maxSpeed;

		public float accelerationForce;

		public float brakingForce;

		public float turnSpeed;

		public float staminaReplenishRatio;

		public bool equipmentScalesMaxSpeed;

		public bool breedScalesMaxSpeed;
	}

	[Serializable]
	public struct PurchaseOption
	{
		public ItemDefinition tokenItem;

		public Phrase title;

		public Phrase description;

		public Sprite icon;

		public int order;
	}

	public enum HorseAvoidanceState
	{
		Normal,
		AvoidingObstacle
	}

	[Header("Breed")]
	public HorseBreed[] breeds;

	public SkinnedMeshRenderer[] bodyRenderers;

	public SkinnedMeshRenderer[] hairRenderers;

	private int currentBreedIndex = -1;

	public HorseBreed currentBreed;

	public FakePhysicsRope leadingRope;

	public FakePhysicsRope leadingRope2;

	[Header("Container")]
	public ItemDefinition onlyAllowedItem;

	public ItemContainer.ContentsType allowedContents = ItemContainer.ContentsType.Generic;

	[Space]
	public int maxStackSize;

	public int numStorageSlots;

	public int equipmentSlots = 4;

	public string lootPanelName = "animal";

	public string storagePanelName = "animal-storage";

	public bool needsBuildingPrivilegeToUse;

	public bool isLootable = true;

	public ItemContainer storageInventory;

	public ItemContainer equipmentInventory;

	public ProtectionProperties riderProtection;

	public ProtectionProperties baseHorseProtection;

	public float equipmentSpeedMod;

	[SerializeField]
	[Header("Horse")]
	private Animator animator;

	[SerializeField]
	private Transform centreOfMassTransform;

	[SerializeField]
	private RidableHorseAudio horseAudio;

	[SerializeField]
	private RidableHorseAnimation horseAnimation;

	[SerializeField]
	private LegsAnimator serverLegsAnimator;

	[SerializeField]
	private ScaleBySpeed scaleBySpeedWater;

	public WheelCollider wheelCollider;

	public GameObjectRef corpsePrefab;

	[Space]
	public Collider playerServerCollider;

	public Collider playerServerColliderRear;

	public CapsuleCollider clippingMountCheckCollider;

	public Gait[] gaits;

	public GaitType currentGait;

	public float gaitProgressionInterval = 1f;

	public float gravity = 10f;

	public float waterGravity = 1f;

	public float groundAlignmentSpeed = 50f;

	public float roadSpeedBonus = 1f;

	[Space]
	public float reverseSpeedFactor = 0.5f;

	public float reverseAccelerationForce = 4000f;

	[Space]
	public float rotationResponsiveness = 1f;

	[Tooltip("The factor applied to rotationResponsiveness, based on the current speed ratio (0 = stopped, 1 = full speed)")]
	public AnimationCurve rotationResponsivenessCurve;

	public Transform[] groundSampleOffsets;

	public Vector2 minMaxSlopeAngle = new Vector2(10f, 60f);

	public AnimationCurve slopeAngleSpeedFactor;

	[SerializeField]
	[Header("Collision Damage")]
	[Space]
	private GameObjectRef collisionEffect;

	[Tooltip("Ignore low magnitude so e.g. Players running into stationary vehicles doesn't trigger damage or FX")]
	[SerializeField]
	private float minCollisionDamageForce = 20000f;

	[Tooltip("Cap max magnitude so unusual events can't cause mega damage")]
	[SerializeField]
	private float maxCollisionDamageForce = 2500000f;

	[SerializeField]
	[Tooltip("Adjust this away from 1.0 if collision damage to this vehicle seems too high or low")]
	private float collisionDamageMultiplier = 1f;

	[SerializeField]
	private float playerDamageThreshold = 40f;

	[SerializeField]
	private float playerRagdollThreshold = 75f;

	[SerializeField]
	private float maxAirTimeBeforeRagdoll = 1.5f;

	[Header("Towing")]
	public TriggerTowing towingTrigger;

	public Transform towingPoint;

	public TowingVisuals towingVisuals;

	private NetworkableId towingEntityId;

	public GameObjectRef towingAttachEffect;

	public GameObjectRef towingDetachEffect;

	[SerializeField]
	private float towingAccelerationBoost = 2f;

	[SerializeField]
	private float towingMaxSpeedBoost = 1f;

	[SerializeField]
	private GaitType maxTowingGait = GaitType.Trot;

	[Header("Stamina")]
	public float currentStamina = 10f;

	public float currentMaxStamina = 10f;

	public float maxStamina = 20f;

	public float staminaCoreLossRatio = 0.1f;

	public float staminaCoreSpeedBonus = 3f;

	public float calorieToStaminaRatio = 0.1f;

	public float hydrationToStaminaRatio = 0.5f;

	public float maxStaminaCoreFromWater = 0.5f;

	[Header("Purchase")]
	public List<PurchaseOption> PurchaseOptions;

	[Header("Saddle")]
	public Phrase SwapToSingleTitle;

	public Phrase SwapToSingleDescription;

	public Sprite SwapToSingleIcon;

	public Phrase SwapToDoubleTitle;

	public Phrase SwapToDoubleDescription;

	public Sprite SwapToDoubleIcon;

	[HideInInspector]
	[SerializeField]
	protected bool[] hasItemTokenCache;

	[Space]
	public SoundPlayer standSound;

	public SoundPlayer slidingSound;

	private TimeSince timeSinceSlidingSoundPlayed;

	public ParticleSystemContainer skidDust;

	public GameObjectRef ragdollPrefab;

	[SerializeField]
	[Header("Pulling")]
	private List<ModifierDefintion> pullingPlayerModifiers;

	[Header("Avoidance")]
	public float avoidanceSphereRadius = 0.5f;

	public Vector2 avoidanceDetectionDistance = new Vector2(3f, 8f);

	public LayerMask avoidanceObstacleMask;

	[Header("Sliding")]
	public float groundAngleSlideThresholdForced = 50f;

	public float groundAngleSlideThreshold = 37f;

	public float groundAngleToRecoverFromSlide = 24f;

	public float normalVariationSlideThreshold = 2.5f;

	[HideInInspector]
	public float normalVariation;

	public const Flags Flag_ForSale = Flags.Reserved2;

	public const Flags Flag_Hitched = Flags.Reserved3;

	public const Flags Flag_HideHair = Flags.Reserved4;

	public const Flags Flag_WoodArmor = Flags.Reserved5;

	public const Flags Flag_RoadsignArmor = Flags.Reserved6;

	public const Flags Flag_Lead = Flags.Reserved16;

	public const Flags Flag_HasSingleSaddle = Flags.Reserved9;

	public const Flags Flag_HasDoubleSaddle = Flags.Reserved10;

	public const Flags Flag_IsRagdolling = Flags.Reserved12;

	public const Flags Flag_IsSwimming = Flags.Reserved13;

	public const Flags Flag_IsSliding = Flags.Reserved18;

	public const Flags Flag_IsInWater = Flags.Reserved19;

	private static readonly Phrase TowAngleErrorPhrase = new Phrase("horse_tow_error", "Straighten up to tow");

	private NetworkableId playerLeadingId;

	[ServerVar(Saved = true, ClientAdmin = true)]
	public static bool debug = false;

	[ServerVar(Saved = true, ClientAdmin = true)]
	public static bool autoAvoidance = true;

	[ServerVar(Saved = true, ClientAdmin = true, Default = "1")]
	public static bool throttledGroundAngleUpdate = true;

	[ServerVar(Saved = true, ClientAdmin = true, Default = "0.05")]
	public static float groundAngleUpdateRate = 0.05f;

	[ServerVar(Help = "How long before a horse dies unattended")]
	public static float decayMinutes = 180f;

	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 2f;

	public Transform rootBone;

	public Transform[] allBones;

	private static Vector3[] bonesInitialLocalPos;

	[Header("Dung")]
	public TriggerBase foodTrigger;

	public ItemDefinition dungItem;

	public Transform dungSpawnPoint;

	public float caloriesToDigestPerHour = 100f;

	public float dungProducedPerCalorie = 0.1f;

	[NonSerialized]
	public HorseModifiers modifiers;

	[ServerVar]
	[Help("Scale all rideable animal dung production rates by this value. 0 will disable dung production.")]
	public static float dungTimeScale = 1f;

	private float nextEatTime;

	private float lastEatTime = float.NegativeInfinity;

	private float pendingDungCalories;

	private float dungProduction;

	public HitchTrough currentHitch;

	private VehicleTerrainHandler terrainHandler;

	private readonly Dictionary<BaseEntity, float> damageSinceLastTick = new Dictionary<BaseEntity, float>();

	private float nextCollisionDamageTime;

	private float steerInput;

	private float steerInputDownTime;

	private float throttleInput;

	private bool forwardInputDown;

	private bool backwardInputDown;

	private bool duckInputDown;

	private float doubleTapTime = 0.25f;

	private float lastDuckTapTime = -1f;

	private bool duckDoubleTapped;

	private float sprintInputHoldTime;

	private bool sprintInputJustPressed;

	private Vector3 targetUp = Vector3.up;

	private Vector3 averagedUp = Vector3.up;

	private float groundAngle;

	protected bool onIdealTerrain;

	protected bool onWaterTopology;

	private float nextTerrainCheckTime;

	private float nextAutoAvoidanceCheckTime;

	private float nextGroundNormalCheckTime;

	private TimeSince timeSinceWaterCheck;

	private TimeSince timeSinceDrowningDamage;

	private bool wasSleeping;

	private float lastMovingTime;

	private const float SLEEP_DELAY = 5f;

	private const float SLEEP_SPEED = 0.5f;

	private WaterLevel.WaterInfo lastWaterInfo;

	private float currentWaterFactor;

	private float airTime;

	private float slidingTime;

	private float lastCrashDamage;

	private Vector3 lastPullerPosition;

	private float lastYVelocity;

	public float kmDistance;

	public float tempDistanceTravelled;

	private float lastRoughTerrainTime;

	private bool wasGrounded;

	private bool isSubmerged;

	[HideInInspector]
	[SerializeField]
	private float baseDrag;

	[SerializeField]
	[HideInInspector]
	private float baseAngularDrag;

	private HorseAvoidanceState currentAvoidanceState;

	private int avoidanceSteeringInput;

	private Vector3 avoidanceScanDirection;

	private float nextStandTime;

	private IHorseInputProvider inputProvider;

	private TowingAttachment<RidableHorse> towingAttachment;

	private ITowing towableEntity;

	private float lastRiddenTime;

	private float nextDecayTime;

	public bool HasSingleSaddle => HasFlag(Flags.Reserved9);

	public bool HasDoubleSaddle => HasFlag(Flags.Reserved10);

	public bool HasSaddle
	{
		get
		{
			if (!HasSingleSaddle)
			{
				return HasDoubleSaddle;
			}
			return true;
		}
	}

	public bool IsForSale => HasFlag(Flags.Reserved2);

	public bool IsTowing => HasFlag(Flags.Reserved14);

	public bool IsLeading => HasFlag(Flags.Reserved16);

	public bool IsSwimming => HasFlag(Flags.Reserved13);

	public bool IsSliding => HasFlag(Flags.Reserved18);

	public BasePlayer leadingPlayer { get; private set; }

	public override bool IsNpc => true;

	public bool isGrounded { get; private set; }

	public bool isStanding { get; private set; }

	public bool isSkidding { get; private set; }

	private VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (terrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return terrainHandler.OnSurface;
		}
	}

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public BaseEntity TowEntity => this;

	public Transform TowAnchor => towingPoint;

	public Rigidbody TowBody => rigidBody;

	public bool IsTowingAllowed => !IsTowing;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RidableHorse.OnRpcMessage", 0);
		try
		{
			if (rpc == 2663053610u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_Claim "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_Claim", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2663053610u, "SERVER_Claim", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_Claim(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_Claim");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 299778156 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_Lead "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_Lead", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(299778156u, "SERVER_Lead", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(299778156u, "SERVER_Lead", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_Lead(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_Lead");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3442949235u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3442949235u, "SERVER_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							SERVER_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SERVER_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3395302925u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestDetach "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestDetach", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3395302925u, "SERVER_RequestDetach", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3395302925u, "SERVER_RequestDetach", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3395302925u, "SERVER_RequestDetach", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SERVER_RequestDetach(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in SERVER_RequestDetach");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 294213070 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestSaddleSwap "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestSaddleSwap", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(294213070u, "SERVER_RequestSaddleSwap", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							SERVER_RequestSaddleSwap(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in SERVER_RequestSaddleSwap");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3979037781u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestTow "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestTow", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3979037781u, "SERVER_RequestTow", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3979037781u, "SERVER_RequestTow", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3979037781u, "SERVER_RequestTow", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							SERVER_RequestTow(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in SERVER_RequestTow");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void ApplyBreed(int index)
	{
		if (currentBreedIndex != index)
		{
			if (index >= breeds.Length || index < 0)
			{
				Debug.LogError((object)("ApplyBreed issue! index is " + index + " breed length is : " + breeds.Length));
				return;
			}
			ApplyBreedInternal(breeds[index]);
			currentBreed = breeds[index];
			currentBreedIndex = index;
		}
	}

	protected void ApplyBreedInternal(HorseBreed breed)
	{
		if (base.isServer)
		{
			SetMaxHealth(StartHealth() * breed.maxHealth);
			base.health = MaxHealth();
		}
	}

	public HorseBreed GetBreed()
	{
		if (currentBreedIndex == -1 || currentBreedIndex >= breeds.Length)
		{
			return null;
		}
		return breeds[currentBreedIndex];
	}

	public void SetBreed(int index)
	{
		ApplyBreed(index);
		SendNetworkUpdate();
	}

	private bool ItemIsSaddle(Item item)
	{
		if (item == null)
		{
			return false;
		}
		ItemModAnimalEquipment component = ((Component)item.info).GetComponent<ItemModAnimalEquipment>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		ItemModAnimalEquipment.SlotType slot = component.slot;
		return slot == ItemModAnimalEquipment.SlotType.Saddle || slot == ItemModAnimalEquipment.SlotType.SaddleDouble;
	}

	private bool CanOpenStorage(BasePlayer player)
	{
		if (!AnyMounted() || PlayerIsMounted(player))
		{
			return true;
		}
		return false;
	}

	public int GetStorageSlotCount()
	{
		return numStorageSlots;
	}

	public void InitContainers()
	{
		if (storageInventory == null)
		{
			CreateStorageInventory(giveUID: true);
		}
		if (equipmentInventory == null)
		{
			CreateEquipmentInventory(giveUID: true);
		}
	}

	private void CreateInventories(bool giveUID)
	{
		CreateStorageInventory(giveUID);
		CreateEquipmentInventory(giveUID);
	}

	private void CreateStorageInventory(bool giveUID)
	{
		Debug.Assert(storageInventory == null, "Double init of inventory!");
		storageInventory = CreateInventory(giveUID, 48);
		storageInventory.canAcceptItem = StorageItemFilter;
	}

	private void CreateEquipmentInventory(bool giveUID)
	{
		Debug.Assert(equipmentInventory == null, "Double init of inventory!");
		equipmentInventory = CreateInventory(giveUID, equipmentSlots);
		equipmentInventory.canAcceptItem = EquipmentItemFilter;
	}

	private ItemContainer CreateInventory(bool giveUID, int slots)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.entityOwner = this;
		itemContainer.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
		itemContainer.SetOnlyAllowedItem(onlyAllowedItem);
		itemContainer.maxStackSize = maxStackSize;
		itemContainer.ServerInitialize(null, slots);
		if (giveUID)
		{
			itemContainer.GiveUID();
		}
		itemContainer.onItemAddedRemoved = OnItemAddedOrRemoved;
		itemContainer.onDirty += OnInventoryDirty;
		return itemContainer;
	}

	public bool StorageItemFilter(Item item, int targetSlot)
	{
		return true;
	}

	public bool EquipmentItemFilter(Item item, int targetSlot)
	{
		if (IsForSale && ItemIsSaddle(item))
		{
			return false;
		}
		ItemModAnimalEquipment component = ((Component)item.info).GetComponent<ItemModAnimalEquipment>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			return false;
		}
		if (ItemIsSaddle(item) && HasSaddle)
		{
			return false;
		}
		if (component.slot == ItemModAnimalEquipment.SlotType.Basic)
		{
			return true;
		}
		for (int i = 0; i < equipmentInventory.capacity; i++)
		{
			Item slot = equipmentInventory.GetSlot(i);
			if (slot != null)
			{
				ItemModAnimalEquipment component2 = ((Component)slot.info).GetComponent<ItemModAnimalEquipment>();
				if (!((Object)(object)component2 == (Object)null) && component2.slot == component.slot)
				{
					int slot2 = (int)component2.slot;
					string text = slot2.ToString();
					slot2 = (int)component.slot;
					Debug.Log((object)("Rejecting because slot same, found : " + text + " new : " + slot2));
					return false;
				}
			}
		}
		return true;
	}

	private void OnInventoryDirty()
	{
		EquipmentUpdate();
	}

	private void OnItemAddedOrRemoved(Item arg1, bool arg2)
	{
	}

	private void ReleaseInventories()
	{
		Pool.Free<ItemContainer>(ref equipmentInventory);
		Pool.Free<ItemContainer>(ref storageInventory);
	}

	public void EquipmentUpdate()
	{
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Reserved4, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved5, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		riderProtection.Clear();
		baseProtection.Clear();
		equipmentSpeedMod = 0f;
		numStorageSlots = 0;
		for (int i = 0; i < equipmentInventory.capacity; i++)
		{
			Item slot = equipmentInventory.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			ItemModAnimalEquipment component = ((Component)slot.info).GetComponent<ItemModAnimalEquipment>();
			if ((Object)(object)component != (Object)null)
			{
				SetFlag(component.WearableFlag, b: true, recursive: false, networkupdate: false);
				if (component.hideHair)
				{
					SetFlag(Flags.Reserved4, b: true);
				}
				if (Object.op_Implicit((Object)(object)component.riderProtection))
				{
					riderProtection.Add(component.riderProtection, 1f);
				}
				if (Object.op_Implicit((Object)(object)component.animalProtection))
				{
					baseProtection.Add(component.animalProtection, 1f);
				}
				equipmentSpeedMod += component.speedModifier;
				numStorageSlots += component.additionalInventorySlots;
			}
		}
		for (int j = 0; j < storageInventory.capacity; j++)
		{
			if (j >= numStorageSlots)
			{
				Item slot2 = storageInventory.GetSlot(j);
				if (slot2 != null)
				{
					slot2.RemoveFromContainer();
					slot2.Drop(((Component)this).transform.position + Vector3.up + Random.insideUnitSphere * 0.25f, Vector3.zero);
				}
			}
		}
		storageInventory.capacity = numStorageSlots;
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void SERVER_OpenLoot(RPCMessage rpc)
	{
		if (storageInventory == null)
		{
			return;
		}
		BasePlayer player = rpc.player;
		string text = rpc.read.String(256, false);
		if (!((Object)(object)player == (Object)null) && player.CanInteract() && CanOpenStorage(player) && (!needsBuildingPrivilegeToUse || player.CanBuild()) && Interface.CallHook("CanLootEntity", (object)player, (object)this) == null && player.inventory.loot.StartLootingEntity(this))
		{
			ItemContainer container = equipmentInventory;
			string arg = lootPanelName;
			if (text == "storage")
			{
				arg = storagePanelName;
				container = storageInventory;
			}
			player.inventory.loot.AddContainer(container);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), arg);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_RequestSaddleSwap(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !IsForSale && HasSaddle && !AnyMounted())
		{
			int tokenItemID = msg.read.Int32();
			Item purchaseToken = GetPurchaseToken(player, tokenItemID);
			if (purchaseToken != null && ItemIsSaddle(purchaseToken))
			{
				ItemDefinition template = (HasSingleSaddle ? PurchaseOptions[0].tokenItem : PurchaseOptions[1].tokenItem);
				OnClaimedWithToken(purchaseToken);
				purchaseToken.UseItem();
				Item item = ItemManager.Create(template, 1, 0uL);
				player.GiveItem(item);
				SendNetworkUpdateImmediate();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && IsForSale)
		{
			int tokenItemID = msg.read.Int32();
			Item purchaseToken = GetPurchaseToken(player, tokenItemID);
			if (purchaseToken != null && Interface.CallHook("OnRidableAnimalClaim", (object)this, (object)player, (object)purchaseToken) == null && ItemIsSaddle(purchaseToken))
			{
				SetFlag(Flags.Reserved2, b: false);
				OnClaimedWithToken(purchaseToken);
				purchaseToken.UseItem();
				Analytics.Azure.OnVehiclePurchased(msg.player, this);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", (object)this, (object)player);
			}
		}
	}

	public void OnClaimedWithToken(Item tokenItem)
	{
		int saddleItemSeatCount = GetSaddleItemSeatCount(tokenItem);
		SetSeatCount(saddleItemSeatCount);
	}

	public int GetSaddleItemSeatCount(Item item)
	{
		if (!ItemIsSaddle(item))
		{
			return 0;
		}
		ItemModAnimalEquipment component = ((Component)item.info).GetComponent<ItemModAnimalEquipment>();
		if ((Object)(object)component != (Object)null)
		{
			if (component.slot == ItemModAnimalEquipment.SlotType.Saddle)
			{
				return 1;
			}
			if (component.slot == ItemModAnimalEquipment.SlotType.SaddleDouble)
			{
				return 2;
			}
		}
		return 0;
	}

	public void GetAllInventories(List<ItemContainer> list)
	{
		list.Add(storageInventory);
		list.Add(equipmentInventory);
	}

	public Item GetPurchaseToken(BasePlayer player, int tokenItemID)
	{
		return player.inventory.FindItemByItemID(tokenItemID);
	}

	public bool PlayerHasToken(BasePlayer player, int tokenItemID)
	{
		return GetPurchaseToken(player, tokenItemID) != null;
	}

	public void SaveContainer(SaveInfo info, Horse msgHorse)
	{
		if (info.forDisk)
		{
			if (storageInventory != null)
			{
				msgHorse.storageContainer = storageInventory.Save();
			}
			if (equipmentInventory != null)
			{
				msgHorse.equipmentContainer = equipmentInventory.Save();
			}
		}
	}

	public void LoadContainer(LoadInfo info)
	{
		if (info.fromDisk && info.msg.horse != null)
		{
			if (equipmentInventory != null && info.msg.horse.equipmentContainer != null)
			{
				equipmentInventory.Load(info.msg.horse.equipmentContainer);
				equipmentInventory.capacity = equipmentSlots;
			}
			else
			{
				Debug.LogWarning((object)("Horse didn't have saved equipment inventory: " + ((object)this).ToString()));
			}
			if (storageInventory != null && info.msg.horse.storageContainer != null)
			{
				storageInventory.Load(info.msg.horse.storageContainer);
				storageInventory.capacity = numStorageSlots;
			}
			else
			{
				Debug.LogWarning((object)("Horse didn't have savevd storage inventorry: " + ((object)this).ToString()));
			}
		}
	}

	public override void PreInitShared()
	{
		base.PreInitShared();
		modifiers = ((Component)this).GetComponent<HorseModifiers>();
	}

	public bool HasSeatAvailable()
	{
		if (HasSaddle)
		{
			return !HasFlag(Flags.Reserved11);
		}
		return false;
	}

	public bool IsPlayerTooHeavy(BasePlayer player)
	{
		return player.Weight >= 10f;
	}

	public static float UnitsToKPH(float unitsPerSecond)
	{
		return unitsPerSecond * 60f * 60f / 1000f;
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		hasItemTokenCache = new bool[PurchaseOptions.Count];
		if (serverside || bundling)
		{
			baseDrag = rigidBody.drag;
			baseAngularDrag = rigidBody.angularDrag;
		}
		bonesInitialLocalPos = (Vector3[])(object)new Vector3[allBones.Length];
		for (int i = 0; i < allBones.Length; i++)
		{
			bonesInitialLocalPos[i] = allBones[i].localPosition;
		}
	}

	public void ResetBonesPositions()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < allBones.Length; i++)
		{
			allBones[i].localPosition = bonesInitialLocalPos[i];
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			ServerFlagsChanged(old, next);
		}
	}

	public override bool AnyMounted()
	{
		return base.AnyMounted();
	}

	private bool CanPlayerSeeSaddlePoint(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (!GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position, 0.25f, 2162688, (QueryTriggerInteraction)0))
		{
			return !GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position + Vector3.up * 0.5f, 0.25f, 2162688, (QueryTriggerInteraction)0);
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.horse = Pool.Get<Horse>();
		SaveContainer(info, info.msg.horse);
		info.msg.horse.stamina = currentStamina;
		info.msg.horse.maxStamina = currentMaxStamina;
		info.msg.horse.towEntityId = towingEntityId;
		info.msg.horse.breedIndex = currentBreedIndex;
		info.msg.horse.numStorageSlots = numStorageSlots;
		if (!info.forDisk)
		{
			info.msg.horse.gait = (int)currentGait;
			info.msg.horse.equipmentSpeedMod = equipmentSpeedMod;
			info.msg.horse.playerLeadingId = playerLeadingId;
		}
		info.msg.horse.modifiers = null;
		if ((Object)(object)modifiers != (Object)null)
		{
			info.msg.horse.modifiers = modifiers.Save(info.forDisk);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.horse != null)
		{
			LoadContainer(info);
			currentStamina = info.msg.horse.stamina;
			currentMaxStamina = info.msg.horse.maxStamina;
			if (info.fromDisk)
			{
				towingEntityId = info.msg.horse.towEntityId;
				ValidateTowableEntity();
				TowAttach();
			}
			if (info.msg.horse.modifiers != null && (Object)(object)modifiers != (Object)null)
			{
				modifiers.Load(info.msg.horse.modifiers, info.fromDisk);
			}
			ApplyBreed(info.msg.horse.breedIndex);
		}
	}

	public bool ShouldTrigger()
	{
		if (IsStopped() && isGrounded && !IsSwimming)
		{
			return !HasFlag(Flags.Reserved19);
		}
		return false;
	}

	public void OnObjects()
	{
	}

	public void OnObjectAdded(GameObject obj, Collider col)
	{
		if (ShouldTrigger() && !base.isClient)
		{
			BaseEntity baseEntity = obj.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !baseEntity.isClient && baseEntity is DroppedItem { item: not null } droppedItem && droppedItem.item.info.category == ItemCategory.Food)
			{
				OnFoodDetected(droppedItem);
			}
		}
	}

	public void OnEmpty()
	{
	}

	private void OnFoodDetected(DroppedItem droppedItem)
	{
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			EatDroppedFood(droppedItem);
		}, Random.Range(1f, 2f));
	}

	private void EatDroppedFood(DroppedItem droppedItem)
	{
		if ((Object)(object)droppedItem == (Object)null || !foodTrigger.HasAnyEntityContents || (GetMaxStaminaFraction() >= 1f && base.healthFraction >= 1f))
		{
			return;
		}
		if (Time.time < nextEatTime)
		{
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				OnFoodDetected(droppedItem);
			}, nextEatTime - Time.time);
		}
		else
		{
			if (!foodTrigger.entityContents.Contains(droppedItem))
			{
				return;
			}
			ItemModConsumable component = ((Component)droppedItem.item.info).GetComponent<ItemModConsumable>();
			if ((Object)(object)component == (Object)null)
			{
				return;
			}
			droppedItem.item.UseItem();
			if (droppedItem.item.amount <= 0)
			{
				droppedItem.Kill();
			}
			else
			{
				((FacepunchBehaviour)this).Invoke((Action)delegate
				{
					EatDroppedFood(droppedItem);
				}, nextEatTime - Time.time);
			}
			nextEatTime = Time.time + Random.Range(2f, 3f) + Mathf.InverseLerp(0.5f, 1f, GetMaxStaminaFraction()) * 4f;
			ReplenishFromFood(component);
		}
	}

	public void ReplenishFromFood(ItemModConsumable consumable)
	{
		if (!((Object)(object)consumable == (Object)null))
		{
			HorseModifiers.AddToHorse(this, consumable.modifiers);
			lastEatTime = Time.time;
			float ifType = consumable.GetIfType(MetabolismAttribute.Type.Calories);
			float ifType2 = consumable.GetIfType(MetabolismAttribute.Type.Hydration);
			float num = consumable.GetIfType(MetabolismAttribute.Type.Health) + consumable.GetIfType(MetabolismAttribute.Type.HealthOverTime);
			ApplyDungCalories(ifType);
			ReplenishStaminaCore(ifType, ifType2);
			Heal(num * 4f);
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_HorseEat"));
		}
	}

	private void UpdateDung(float deltaTime)
	{
		if (pendingDungCalories < 0.01f || (Object)(object)dungItem == (Object)null)
		{
			return;
		}
		deltaTime *= dungTimeScale;
		float num = (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.HorseDungProductionBoost, 1f) : 1f);
		deltaTime *= num;
		if (!(deltaTime < 0.01f))
		{
			float num2 = Mathf.Min(pendingDungCalories * deltaTime, caloriesToDigestPerHour / 3600f * deltaTime) * dungProducedPerCalorie;
			dungProduction += num2;
			pendingDungCalories -= num2;
			if (dungProduction >= 1f)
			{
				DoDung();
			}
		}
	}

	public void ApplyDungCalories(float calories)
	{
		pendingDungCalories += calories;
	}

	private void DoDung()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		dungProduction -= 1f;
		if (Interface.CallHook("OnAnimalDungProduce", (object)this) == null)
		{
			Quaternion rotation = Quaternion.Euler(Random.Range(-180f, 180f), Random.Range(-180f, 180f), Random.Range(-180f, 180f));
			Vector3 vVelocity = default(Vector3);
			((Vector3)(ref vVelocity))..ctor(Random.Range(-0.5f, 0.5f), Random.Range(-1f, -3f), Random.Range(-0.5f, 0.5f));
			Item item = ItemManager.Create(dungItem, 1, 0uL);
			item.SetItemOwnership(currentBreed.breedName.english, ItemOwnershipPhrases.Pooped);
			item.Drop(dungSpawnPoint.position + Random.insideUnitSphere * 0.1f, vVelocity, rotation);
			Interface.CallHook("OnAnimalDungProduced", (object)this, (object)item);
		}
	}

	public bool IsHitched()
	{
		return (Object)(object)currentHitch != (Object)null;
	}

	public void TryToHitch()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		List<HitchTrough> list = Pool.Get<List<HitchTrough>>();
		Vis.Entities(((Component)this).transform.position, 2.5f, list, 256, (QueryTriggerInteraction)1);
		foreach (HitchTrough item in list)
		{
			if (!item.isClient && !(Vector3.Dot(Vector3Ex.Direction2D(((Component)item).transform.position, ((Component)this).transform.position), ((Component)this).transform.forward) < 0.4f) && item.HasSpace() && item.IsValidHitchPosition(((Component)this).transform.position) && item.AttemptToHitch(this))
			{
				break;
			}
		}
		Pool.FreeUnmanaged<HitchTrough>(ref list);
	}

	public void SetHitch(HitchTrough hitch, HitchTrough.HitchSpot spot)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		currentHitch = hitch;
		SetFlag(Flags.Reserved3, (Object)(object)currentHitch != (Object)null);
		if ((Object)(object)hitch != (Object)null)
		{
			((Component)this).transform.SetPositionAndRotation(spot.tr.position, spot.tr.rotation);
			DismountAllPlayers();
		}
	}

	private void EatFromHitch()
	{
		if (!IsHitched())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)EatFromHitch);
		}
		else
		{
			if (Time.time < nextEatTime || (GetMaxStaminaFraction() >= 1f && base.healthFraction >= 1f))
			{
				return;
			}
			Item foodItem = currentHitch.GetFoodItem();
			if (foodItem != null && foodItem.amount > 0)
			{
				ItemModConsumable component = ((Component)foodItem.info).GetComponent<ItemModConsumable>();
				if (Object.op_Implicit((Object)(object)component))
				{
					float time = component.GetIfType(MetabolismAttribute.Type.Calories) * currentHitch.caloriesToDecaySeconds;
					AddDecayDelay(time);
					ReplenishFromFood(component);
					foodItem.UseItem();
					nextEatTime = Time.time + Random.Range(2f, 3f) + Mathf.InverseLerp(0.5f, 1f, GetMaxStaminaFraction()) * 4f;
				}
			}
		}
	}

	public void TryLeaveHitch()
	{
		if ((Object)(object)currentHitch != (Object)null)
		{
			currentHitch.UnHitch(this);
		}
	}

	public bool IsReversing()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		if (base.isServer)
		{
			val = rigidBody.velocity;
		}
		return Vector3.Dot(val, ((Component)this).transform.forward) < -0.1f;
	}

	private float GetCurrentSpeed()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			Vector3 velocity = rigidBody.velocity;
			return ((Vector3)(ref velocity)).magnitude;
		}
		return 0f;
	}

	public float GetCurrentGaitSpeedFraction()
	{
		return Mathf.Clamp01(GetCurrentSpeed() / GetCurrentMaxSpeed());
	}

	public float GetSpeedFraction()
	{
		return Mathf.Clamp01(GetCurrentSpeed() / GetTopSpeed());
	}

	private float GetTurnSpeed()
	{
		float turnSpeed = GetCurrentGait().turnSpeed;
		if (IsSwimming)
		{
			return turnSpeed * 0.8f;
		}
		if (IsReversing())
		{
			return turnSpeed * 0.7f;
		}
		return turnSpeed;
	}

	private float GetCurrentAcceleration()
	{
		float num = GetCurrentGait().accelerationForce;
		if (IsTowing)
		{
			num *= towingAccelerationBoost;
		}
		return num;
	}

	private float GetCurrentMaxSpeed()
	{
		Gait gait = GetCurrentGait();
		float num = gait.maxSpeed;
		if (onIdealTerrain && gait.gaitType == GaitType.Gallop)
		{
			num += roadSpeedBonus;
		}
		if (gait.equipmentScalesMaxSpeed)
		{
			num += equipmentSpeedMod;
			float num2 = (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.HorseGallopSpeed) : 0f);
			num += num2;
		}
		if (gait.breedScalesMaxSpeed)
		{
			num *= currentBreed.maxSpeed;
		}
		if (IsTowing)
		{
			num *= towingMaxSpeedBoost;
		}
		return num;
	}

	public float GetTopSpeed()
	{
		float num = (gaits[gaits.Length - 1].maxSpeed + equipmentSpeedMod) * currentBreed.maxSpeed;
		float num2 = (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.HorseGallopSpeed) : 0f);
		return num + num2;
	}

	private Gait GetCurrentGait()
	{
		return gaits[(uint)currentGait];
	}

	private bool IsStopped()
	{
		if (!IsSliding)
		{
			return GetSpeedFraction() < 0.05f;
		}
		return false;
	}

	public float GetMaxStaminaFraction()
	{
		return Mathf.InverseLerp(0f, maxStamina, currentMaxStamina);
	}

	public float GetStaminaFraction()
	{
		return Mathf.InverseLerp(0f, maxStamina, currentStamina);
	}

	public bool IsDrowning()
	{
		if (IsSwimming)
		{
			return GetStaminaFraction() < 0.02f;
		}
		return false;
	}

	public bool CanLead(BasePlayer player)
	{
		if (!AnyMounted() && NearMountPoint(player) && DirectlyMountable() && !HasFlag(Flags.Reserved12) && !player.isMounted && !IsLeading && !IsTowing)
		{
			return !IsForSale;
		}
		return false;
	}

	public bool CanStopLead(BasePlayer player)
	{
		if (IsLeading && (Object)(object)leadingPlayer == (Object)(object)player)
		{
			return NearMountPoint(player);
		}
		return false;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (!IsDriver(player))
		{
			return;
		}
		if (inputProvider != null)
		{
			throttleInput = inputProvider.GetMoveInput();
			steerInput = inputProvider.GetSteerInput();
		}
		float num = steerInput;
		if (num == 1f || num == -1f)
		{
			if (steerInputDownTime == 0f)
			{
				steerInputDownTime = Time.time;
			}
		}
		else
		{
			steerInputDownTime = 0f;
		}
		forwardInputDown = throttleInput == 1f;
		backwardInputDown = throttleInput == -1f;
		sprintInputJustPressed = inputState.WasJustPressed(BUTTON.SPRINT);
		bool flag = inputState.IsDown(BUTTON.SPRINT);
		if (sprintInputJustPressed)
		{
			IncrementGait(flag);
		}
		if (inputState.WasJustReleased(BUTTON.SPRINT) && currentGait == GaitType.Gallop)
		{
			RetrogradeGait();
		}
		if (flag)
		{
			if (sprintInputHoldTime == 0f)
			{
				sprintInputHoldTime = Time.time;
			}
			if (Time.time - sprintInputHoldTime >= gaitProgressionInterval && (int)currentGait < 3)
			{
				sprintInputHoldTime = Time.time;
				IncrementGait(sprintHeld: true);
			}
		}
		else
		{
			sprintInputHoldTime = 0f;
		}
		duckInputDown = inputState.IsDown(BUTTON.DUCK);
		if (inputState.WasJustReleased(BUTTON.DUCK))
		{
			float time = Time.time;
			if (time - lastDuckTapTime <= doubleTapTime)
			{
				duckDoubleTapped = true;
			}
			else
			{
				duckDoubleTapped = false;
			}
			lastDuckTapTime = time;
		}
		else if (duckDoubleTapped)
		{
			duckDoubleTapped = false;
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		if (HasFlag(Flags.Reserved12))
		{
			return;
		}
		base.VehicleFixedUpdate();
		TimeWarning val = TimeWarning.New("RidableHorse.VehicleFixedUpdate", 0);
		try
		{
			if ((Object)(object)modifiers != (Object)null)
			{
				modifiers.ServerUpdate(this);
			}
			float fixedDeltaTime = Time.fixedDeltaTime;
			UpdateStamina(fixedDeltaTime);
			UpdateDung(fixedDeltaTime);
			if (IsDrowning() && TimeSince.op_Implicit(timeSinceDrowningDamage) > 2f)
			{
				timeSinceDrowningDamage = TimeSince.op_Implicit(0f);
				Hurt(75f, DamageType.Drowned, null, useProtection: false);
			}
			if (Time.time >= nextCollisionDamageTime)
			{
				nextCollisionDamageTime = Time.time + 0.33f;
				foreach (KeyValuePair<BaseEntity, float> item in damageSinceLastTick)
				{
					DoCollisionDamage(item.Key, item.Value);
				}
				damageSinceLastTick.Clear();
			}
			bool flag = AnyMounted();
			if ((!IsLeading && !HasDoubleSaddle && !flag) || (HasDoubleSaddle && !HasDriver()))
			{
				throttleInput = 0f;
				steerInput = 0f;
			}
			if (IsLeading)
			{
				if ((Object)(object)leadingPlayer == (Object)null || leadingPlayer.IsDead() || leadingPlayer.IsSleeping() || leadingPlayer.IsDestroyed)
				{
					SetLeading(null);
				}
				else
				{
					throttleInput = inputProvider.GetMoveInput();
					steerInput = inputProvider.GetSteerInput();
				}
			}
			if ((flag || IsLeading) && rigidBody.IsSleeping())
			{
				((Collider)wheelCollider).enabled = true;
				rigidBody.WakeUp();
			}
			if (rigidBody.IsSleeping())
			{
				wasSleeping = true;
				((Behaviour)serverLegsAnimator).enabled = false;
				((Collider)wheelCollider).enabled = false;
				return;
			}
			((Collider)wheelCollider).enabled = true;
			((Behaviour)serverLegsAnimator).enabled = true;
			serverLegsAnimator.HipsHeightStepSpeed = Mathf.Lerp(0.7f, 0.05f, Mathf.InverseLerp(0f, 10f, normalVariation));
			if (IsTowing)
			{
				towingAttachment.FixedUpdate();
			}
			if (!wasSleeping && !(GetCurrentSpeed() > 0.5f))
			{
				Vector3 angularVelocity = rigidBody.angularVelocity;
				if (!(Mathf.Abs(((Vector3)(ref angularVelocity)).magnitude) > 0.5f))
				{
					goto IL_0296;
				}
			}
			lastMovingTime = Time.time;
			goto IL_0296;
			IL_0296:
			float num = GetCurrentSpeed() * Time.fixedDeltaTime;
			if (!flag && !IsLeading && !IsTowing && Time.time > lastMovingTime + 5f)
			{
				airTime = 0f;
				wheelCollider.motorTorque = 0f;
				((Behaviour)serverLegsAnimator).enabled = false;
				((Collider)wheelCollider).enabled = false;
				rigidBody.Sleep();
			}
			else
			{
				if (autoAvoidance)
				{
					AutoAvoidObstacles();
				}
				MovementsUpdate();
			}
			wasSleeping = false;
			tempDistanceTravelled += num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override float MaxVelocity()
	{
		return GetTopSpeed() * 1.3f;
	}

	private void MovementsUpdate()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ad9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0adf: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b09: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b21: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b29: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b52: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b57: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b35: Unknown result type (might be due to invalid IL or missing references)
		//IL_0403: Unknown result type (might be due to invalid IL or missing references)
		//IL_0405: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b94: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b9f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b6f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b74: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b78: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bf3: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0438: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c4f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c23: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c28: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0868: Unknown result type (might be due to invalid IL or missing references)
		//IL_086d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0816: Unknown result type (might be due to invalid IL or missing references)
		//IL_075b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08df: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0900: Unknown result type (might be due to invalid IL or missing references)
		//IL_0905: Unknown result type (might be due to invalid IL or missing references)
		//IL_0784: Unknown result type (might be due to invalid IL or missing references)
		//IL_0789: Unknown result type (might be due to invalid IL or missing references)
		//IL_0776: Unknown result type (might be due to invalid IL or missing references)
		//IL_0925: Unknown result type (might be due to invalid IL or missing references)
		//IL_092a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0937: Unknown result type (might be due to invalid IL or missing references)
		//IL_093d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0942: Unknown result type (might be due to invalid IL or missing references)
		//IL_0947: Unknown result type (might be due to invalid IL or missing references)
		//IL_0955: Unknown result type (might be due to invalid IL or missing references)
		//IL_095a: Unknown result type (might be due to invalid IL or missing references)
		//IL_095f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0967: Unknown result type (might be due to invalid IL or missing references)
		//IL_096c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0971: Unknown result type (might be due to invalid IL or missing references)
		//IL_0975: Unknown result type (might be due to invalid IL or missing references)
		//IL_097c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0981: Unknown result type (might be due to invalid IL or missing references)
		//IL_0983: Unknown result type (might be due to invalid IL or missing references)
		//IL_0600: Unknown result type (might be due to invalid IL or missing references)
		//IL_0602: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0635: Unknown result type (might be due to invalid IL or missing references)
		//IL_0637: Unknown result type (might be due to invalid IL or missing references)
		//IL_0648: Unknown result type (might be due to invalid IL or missing references)
		//IL_064d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0655: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09de: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_09f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_09fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0716: Unknown result type (might be due to invalid IL or missing references)
		//IL_071a: Unknown result type (might be due to invalid IL or missing references)
		//IL_071f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0721: Unknown result type (might be due to invalid IL or missing references)
		//IL_0726: Unknown result type (might be due to invalid IL or missing references)
		//IL_072a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0737: Unknown result type (might be due to invalid IL or missing references)
		//IL_073c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0744: Unknown result type (might be due to invalid IL or missing references)
		//IL_069d: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0701: Unknown result type (might be due to invalid IL or missing references)
		//IL_0709: Unknown result type (might be due to invalid IL or missing references)
		if (currentGait == GaitType.Canter && !CanCanter())
		{
			RetrogradeGait();
		}
		else if (currentGait == GaitType.Gallop && !CanGallop())
		{
			RetrogradeGait();
		}
		CheckSpeedForRetrograde();
		UpdateOnTerrain();
		bool isSwimming = IsSwimming;
		if (onWaterTopology)
		{
			if (TimeSince.op_Implicit(timeSinceWaterCheck) > (isSwimming ? 0.05f : 0.25f))
			{
				OBB val = WorldSpaceBounds();
				Bounds val2 = ((OBB)(ref val)).ToBounds();
				lastWaterInfo = WaterLevel.GetWaterInfo(val2, waves: true, volumes: true, this);
				currentWaterFactor = (lastWaterInfo.isValid ? Mathf.InverseLerp(((Bounds)(ref val2)).min.y, ((Bounds)(ref val2)).max.y, lastWaterInfo.surfaceLevel) : 0f);
				isSubmerged = currentWaterFactor > 0.65f;
				bool flag = (currentWaterFactor > 0.5f && !isGrounded) || isSubmerged;
				if (isSwimming != flag)
				{
					SetFlag(Flags.Reserved13, flag);
				}
				bool flag2 = currentWaterFactor > 0.32f;
				if (HasFlag(Flags.Reserved19) != flag2)
				{
					SetFlag(Flags.Reserved19, flag2);
				}
				rigidBody.drag = Mathf.Max(baseDrag, currentWaterFactor * 3f);
				rigidBody.angularDrag = Mathf.Max(baseAngularDrag, currentWaterFactor * 2f);
				timeSinceWaterCheck = TimeSince.op_Implicit(0f);
			}
		}
		else
		{
			if (HasFlag(Flags.Reserved19))
			{
				SetFlag(Flags.Reserved19, b: false);
			}
			currentWaterFactor = 0f;
		}
		wasGrounded = isGrounded;
		if (throttledGroundAngleUpdate)
		{
			if (Time.time > nextGroundNormalCheckTime)
			{
				UpdateGroundNormal();
				nextGroundNormalCheckTime = Time.time + Random.Range(groundAngleUpdateRate, groundAngleUpdateRate + 0.1f);
			}
		}
		else
		{
			UpdateGroundNormal();
		}
		bool flag3;
		Vector3 force;
		if (isGrounded || isSwimming)
		{
			if (!wasGrounded)
			{
				OnLanded(Mathf.Abs(lastYVelocity));
			}
			airTime = 0f;
			flag3 = IsStopped();
			force = rigidBody.velocity;
			if (((Vector3)(ref force)).magnitude > 0.5f && !isSwimming)
			{
				Vector3 val3 = -((Component)this).transform.up;
				force = rigidBody.velocity;
				Vector3 val4 = val3 * ((Vector3)(ref force)).magnitude * 20f;
				rigidBody.AddForce(val4, (ForceMode)0);
			}
			AlignWithNormal(averagedUp);
			Vector3 forward = ((Component)this).transform.forward;
			Vector3 velocity = rigidBody.velocity;
			if (ShouldSlide())
			{
				SetWheelStiffness(0.1f, 0f);
				SetFlag(Flags.Reserved18, b: true);
			}
			float currentSpeed = GetCurrentSpeed();
			if (IsSliding)
			{
				if ((groundAngle < groundAngleToRecoverFromSlide && currentSpeed < 7f) || (currentSpeed < 1f && slidingTime > Time.fixedDeltaTime * 10f))
				{
					SetWheelStiffness(1f, 1f);
					SetFlag(Flags.Reserved18, b: false);
					slidingTime = 0f;
				}
				slidingTime += Time.fixedDeltaTime;
				float num = Vector3.Dot(rigidBody.velocity, -((Component)this).transform.forward);
				if (slidingTime > Time.fixedDeltaTime * 5f && num > 7f)
				{
					if (groundAngle > groundAngleToRecoverFromSlide + 5f)
					{
						force = default(Vector3);
						RagdollAllRiders(force);
					}
					RagdollHorse();
				}
			}
			Vector3 val5 = Vector3.Project(velocity, forward);
			Vector3 val6 = velocity - val5;
			if (((Vector3)(ref val6)).magnitude > 1f)
			{
				Vector3 val7 = -val6 * (isSkidding ? 1f : 3f);
				rigidBody.AddForce(val7 * rigidBody.mass, (ForceMode)0);
			}
			float num2 = Mathf.Clamp01(currentSpeed / GetTopSpeed());
			if (num2 > 0.9f && duckInputDown && !isSkidding && currentWaterFactor < 0.1f && groundAngle < 10f)
			{
				isSkidding = true;
				SetWheelStiffness(0.1f, 0.3f);
				ClientRPC(RpcTarget.NetworkGroup("CLIENT_Skid"));
			}
			if (isSkidding)
			{
				SetWheelStiffness(0f, 0f);
				Brake(1.25f);
				if (num2 <= 0.01f || Vector3.Dot(forward, ((Vector3)(ref velocity)).normalized) < 0.2f)
				{
					isSkidding = false;
				}
			}
			else if (!IsSliding)
			{
				SetWheelStiffness(1f, 1f);
			}
			if (Mathf.Abs(steerInput) > 0f && num2 < 0.3f && !IsReversing() && !backwardInputDown && !forwardInputDown && !isSkidding && !duckInputDown && Time.time - steerInputDownTime > 1f)
			{
				throttleInput = 1f;
			}
			if (!isStanding && !IsSliding && !isSkidding)
			{
				if (duckInputDown && !flag3)
				{
					float multiplier = (((int)currentGait <= 1) ? 0.15f : 1f);
					Brake(multiplier);
				}
				if (throttleInput != 0f && !duckInputDown)
				{
					wheelCollider.motorTorque = 1E-05f * Mathf.Sign(throttleInput);
					if (throttleInput < 0f)
					{
						if (Vector3.Dot(velocity, forward) < -0.1f || flag3)
						{
							float num3 = GetCurrentMaxSpeed() * reverseSpeedFactor;
							float num4 = Mathf.Max(num3 - currentSpeed, 0f);
							Vector3 val8 = -forward * (reverseAccelerationForce * (num4 / num3));
							rigidBody.AddForce(val8, (ForceMode)0);
						}
						else
						{
							Brake();
						}
					}
					else if (throttleInput > 0f)
					{
						float currentMaxSpeed = GetCurrentMaxSpeed();
						float currentAcceleration = GetCurrentAcceleration();
						if (((Vector3)(ref velocity)).magnitude < currentMaxSpeed)
						{
							Vector3 val9 = forward * currentAcceleration;
							if (currentGait != 0 || IsTowing)
							{
								float num5 = slopeAngleSpeedFactor.Evaluate(Mathf.InverseLerp(minMaxSlopeAngle.x, minMaxSlopeAngle.y, groundAngle));
								if (IsTowing)
								{
									num5 += 1f;
								}
								val9 *= num5;
							}
							rigidBody.AddForce(val9, (ForceMode)0);
						}
						else
						{
							Vector3 val10 = forward * currentMaxSpeed - velocity;
							Vector3 val11 = ((Vector3)(ref val10)).normalized * (currentAcceleration * 0.2f);
							rigidBody.AddForce(val11, (ForceMode)0);
						}
					}
				}
				else
				{
					float num6 = 0.1f;
					force = rigidBody.velocity;
					if (((Vector3)(ref force)).sqrMagnitude < num6 * num6)
					{
						rigidBody.velocity = Vector3.zero;
					}
					else
					{
						Vector3 val12 = -((Vector3)(ref velocity)).normalized * (rigidBody.mass * (AnyMounted() ? 1.1f : 3f));
						rigidBody.AddForce(val12, (ForceMode)0);
					}
				}
			}
			if (!isStanding && !IsSliding)
			{
				float num7 = GetTurnSpeed();
				if (duckInputDown && (int)currentGait < 2)
				{
					num7 *= 1.5f;
				}
				float num8 = ((steerInput + (float)avoidanceSteeringInput) * num7 * (MathF.PI / 180f) - rigidBody.angularVelocity.y) * rotationResponsiveness * rotationResponsivenessCurve.Evaluate(num2);
				rigidBody.AddRelativeTorque(0f, num8, 0f, (ForceMode)5);
			}
			if (Mathf.Abs(throttleInput) <= 0f)
			{
				force = rigidBody.velocity;
				if (((Vector3)(ref force)).magnitude < 2.5f && groundAngle < minMaxSlopeAngle.y && !isSwimming && !IsSliding)
				{
					goto IL_08ac;
				}
			}
			if (IsLeading && currentSpeed > 6f)
			{
				goto IL_08ac;
			}
			wheelCollider.brakeTorque = 0f;
			goto IL_08c4;
		}
		airTime += Time.fixedDeltaTime;
		if (airTime > maxAirTimeBeforeRagdoll)
		{
			force = default(Vector3);
			RagdollAllRiders(force);
			RagdollHorse();
		}
		float num9 = ((currentWaterFactor != 0f) ? waterGravity : gravity);
		Vector3 val13 = Vector3.down * (rigidBody.mass * num9);
		rigidBody.AddForce(val13, (ForceMode)0);
		goto IL_0b31;
		IL_0b31:
		if (isSwimming)
		{
			AlignWithNormal(Vector3.up);
			ApplyBuoyancy();
		}
		float num10 = 10000f;
		force = rigidBody.velocity;
		if (((Vector3)(ref force)).magnitude > num10)
		{
			Rigidbody obj = rigidBody;
			force = rigidBody.velocity;
			obj.velocity = ((Vector3)(ref force)).normalized * num10;
		}
		float num11 = -1.3f;
		float num12 = Vector3.Dot(rigidBody.velocity, ((Component)this).transform.forward);
		if (num12 <= num11)
		{
			float num13 = num11 - num12;
			float num14 = Mathf.Lerp(1f, 0.2f, Mathf.InverseLerp(10f, 40f, groundAngle));
			rigidBody.AddForce(((Component)this).transform.forward * num13 * num14, (ForceMode)5);
		}
		if (Mathf.Abs(steerInput) == 0f && !rigidBody.isKinematic)
		{
			force = rigidBody.angularVelocity;
			if (((Vector3)(ref force)).magnitude < 0.2f)
			{
				rigidBody.angularVelocity = Vector3.zero;
			}
		}
		lastYVelocity = rigidBody.velocity.y;
		return;
		IL_08c4:
		if (IsLeading)
		{
			Vector3 val14 = ((Component)this).transform.TransformPoint(Vector3.up * 1.8f + Vector3.forward);
			float num15 = Vector3.Distance(((Component)leadingPlayer).transform.position, val14);
			if (num15 > 3.5f)
			{
				Vector3 position = ((Component)leadingPlayer).transform.position;
				Vector3 val15 = ((Component)leadingPlayer).transform.position - lastPullerPosition;
				lastPullerPosition = ((Component)leadingPlayer).transform.position;
				force = position - ((Component)this).transform.position;
				Vector3 normalized = ((Vector3)(ref force)).normalized;
				Vector3 normalized2 = ((Vector3)(ref val15)).normalized;
				if (Vector3.Dot(normalized, normalized2) > 0.5f)
				{
					float value = Mathf.Lerp(0f, -0.9f, Mathf.Clamp01(Mathf.InverseLerp(3.5f, 7f, num15)));
					leadingPlayer.modifiers.SetValue(Modifier.ModifierSource.Interaction, Modifier.ModifierType.MoveSpeed, value);
					if (num15 > 5f)
					{
						force = position - val14;
						Vector3 normalized3 = ((Vector3)(ref force)).normalized;
						rigidBody.AddForceAtPosition(normalized3 * 5000f, val14, (ForceMode)0);
					}
				}
				else
				{
					leadingPlayer.modifiers.SetValue(Modifier.ModifierSource.Interaction, Modifier.ModifierType.MoveSpeed, 0f);
				}
			}
			else
			{
				leadingPlayer.modifiers.SetValue(Modifier.ModifierSource.Interaction, Modifier.ModifierType.MoveSpeed, 0f);
			}
			if (num15 > 7f)
			{
				leadingPlayer.modifiers.RemoveFromSource(Modifier.ModifierSource.Interaction);
				SetLeading(null);
			}
		}
		if (flag3 && duckDoubleTapped && CanStand())
		{
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_Stand"));
			nextStandTime = Time.time + 4f;
			isStanding = true;
		}
		if (isStanding && nextStandTime < Time.time)
		{
			isStanding = false;
		}
		goto IL_0b31;
		IL_08ac:
		ApplyHandBrake();
		goto IL_08c4;
	}

	private void Brake(float multiplier = 1f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero - rigidBody.velocity;
		Vector3 val2 = ((Vector3)(ref val)).normalized * GetCurrentGait().brakingForce * multiplier;
		rigidBody.AddForce(val2, (ForceMode)0);
	}

	private bool ShouldSlide()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if ((IsSliding || !(groundAngle > groundAngleSlideThreshold) || !(normalVariation < normalVariationSlideThreshold)) && !(groundAngle > groundAngleSlideThresholdForced))
		{
			return Vector3.Dot(rigidBody.velocity, -((Component)this).transform.forward) > 4f;
		}
		return true;
	}

	private void ApplyBuoyancy()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		float num = lastWaterInfo.surfaceLevel - (IsDrowning() ? (centreOfMassTransform.position.y + 3f) : (centreOfMassTransform.position.y - 0.5f));
		num = Mathf.Clamp(num, 0f, 5f);
		if (num > 0f)
		{
			float num2 = Mathf.Sin(Time.time * 2f) * 0.3f;
			float num3 = 1f + num2;
			Vector3 val = Vector3.up * (10f * num * num3);
			rigidBody.AddForce(val, (ForceMode)5);
			Vector3 val2 = Vector3.ProjectOnPlane(rigidBody.velocity, Vector3.up);
			Vector3 val3 = Vector3.Project(rigidBody.velocity, Vector3.up);
			val3 *= 1f - Time.fixedDeltaTime * 6f;
			rigidBody.velocity = val2 + val3;
		}
	}

	private void CheckSpeedForRetrograde()
	{
		float currentSpeed = GetCurrentSpeed();
		Gait gait = GetCurrentGait();
		if ((int)currentGait > 0 && currentSpeed < gait.minSpeed)
		{
			RetrogradeGait();
		}
		if (IsSwimming && currentGait != 0)
		{
			RetrogradeGait();
		}
	}

	public void IncrementGait(bool sprintHeld)
	{
		if (!IsTowing || currentGait != maxTowingGait)
		{
			GaitType gaitType = currentGait + 1;
			if ((gaitType != GaitType.Gallop || (sprintHeld && CanStartGalloping())) && (gaitType != GaitType.Trot || !IsSwimming) && (int)currentGait < 3)
			{
				currentGait++;
			}
		}
	}

	private bool CanGallop()
	{
		if (GetStaminaFraction() > 0f)
		{
			return Time.time - lastRoughTerrainTime > 2.5f;
		}
		return false;
	}

	private bool CanCanter()
	{
		return Time.time - lastRoughTerrainTime > 1.5f;
	}

	private bool CanStartGalloping()
	{
		return GetStaminaFraction() > 0.04f;
	}

	public void RetrogradeGait()
	{
		if ((int)currentGait > 0)
		{
			currentGait--;
		}
	}

	private void ApplyHandBrake()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.ProjectOnPlane(Vector3.down, averagedUp);
		rigidBody.AddForce(-val * rigidBody.mass * 10f, (ForceMode)0);
		wheelCollider.brakeTorque = 10000f;
		wheelCollider.motorTorque = 0f;
	}

	private void AlignWithNormal(Vector3 normal, bool force = false)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normalized = ((Vector3)(ref normal)).normalized;
		Vector3 val = Vector3.ProjectOnPlane(((Component)this).transform.forward, normalized);
		Vector3 val2 = ((Vector3)(ref val)).normalized;
		if (val2 == Vector3.zero)
		{
			val2 = ((Component)this).transform.forward;
		}
		Quaternion val3 = Quaternion.LookRotation(val2, Vector3.up);
		Quaternion val4 = (force ? val3 : Quaternion.Slerp(rigidBody.rotation, val3, 5f * Time.fixedDeltaTime));
		rigidBody.MoveRotation(val4);
	}

	public void UpdateGroundNormal()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("RidableHorse.UpdateGroundNormal", 0);
		try
		{
			int num = 0;
			bool flag = false;
			List<Vector3> list = Pool.Get<List<Vector3>>();
			Vector3 val2 = Vector3.zero;
			Vector3 val3 = averagedUp;
			for (int i = 0; i < groundSampleOffsets.Length; i++)
			{
				Vector3 val4 = groundSampleOffsets[i].position + Vector3.up;
				if (GamePhysics.Trace(new Ray(val4, Vector3.down), 0f, out var hitInfo, 1.2f, 429989889, (QueryTriggerInteraction)1, this))
				{
					Vector3 normal = ((RaycastHit)(ref hitInfo)).normal;
					num++;
					if (i == groundSampleOffsets.Length - 1)
					{
						flag = true;
					}
					val3 += normal;
					list.Add(normal);
					val2 += normal;
				}
				else
				{
					val3 += Vector3.up;
					list.Add(Vector3.up);
					val2 += Vector3.up;
				}
			}
			isGrounded = num >= 2;
			if (!IsSwimming && !flag && throttleInput == 0f)
			{
				throttleInput = 1f;
			}
			Vector3 val5 = val2 / (float)list.Count;
			Vector3 normalized = ((Vector3)(ref val5)).normalized;
			float num2 = 0f;
			for (int j = 0; j < list.Count; j++)
			{
				float num3 = Vector3.Angle(list[j], normalized);
				num2 += num3;
			}
			normalVariation = num2 / (float)list.Count;
			if (normalVariation > 25f && !onIdealTerrain)
			{
				lastRoughTerrainTime = Time.time;
			}
			val3 += Vector3.up;
			val3 /= (float)(groundSampleOffsets.Length + 1);
			((Vector3)(ref val3)).Normalize();
			if (normalVariation < 10f || Vector3.Dot(targetUp, val3) < 0.99f)
			{
				targetUp = val3;
			}
			averagedUp = Vector3.Lerp(averagedUp, targetUp, Time.fixedDeltaTime * groundAlignmentSpeed);
			groundAngle = Vector3.Angle(normalized, Vector3.up);
			Pool.FreeUnmanaged<Vector3>(ref list);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SetWheelStiffness(float forward, float sideways)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		WheelFrictionCurve forwardFriction = wheelCollider.forwardFriction;
		WheelFrictionCurve sidewaysFriction = wheelCollider.sidewaysFriction;
		((WheelFrictionCurve)(ref forwardFriction)).stiffness = forward;
		((WheelFrictionCurve)(ref sidewaysFriction)).stiffness = sideways;
		wheelCollider.forwardFriction = forwardFriction;
		wheelCollider.sidewaysFriction = sidewaysFriction;
	}

	private void AutoAvoidObstacles()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		if (currentAvoidanceState == HorseAvoidanceState.Normal && GetSpeedFraction() < 0.1f)
		{
			avoidanceSteeringInput = 0;
			return;
		}
		float num = Mathf.Lerp(avoidanceDetectionDistance.x, avoidanceDetectionDistance.y, GetSpeedFraction());
		Vector3 val = rigidBody.velocity;
		Vector3 val2;
		if (!(((Vector3)(ref val)).sqrMagnitude > 0.01f))
		{
			val2 = ((Component)this).transform.forward;
		}
		else
		{
			val = rigidBody.velocity;
			val2 = ((Vector3)(ref val)).normalized;
		}
		Vector3 val3 = ((Component)this).transform.right * steerInput * 0.4f;
		val = val2 + val3 * 0.4f;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = Vector3.Lerp(avoidanceScanDirection, normalized, Time.deltaTime * 5f);
		avoidanceScanDirection = ((Vector3)(ref val)).normalized;
		if (currentAvoidanceState == HorseAvoidanceState.Normal && Time.time < nextAutoAvoidanceCheckTime)
		{
			return;
		}
		nextAutoAvoidanceCheckTime = Time.time + Random.Range(0.1f, 0.2f);
		switch (currentAvoidanceState)
		{
		case HorseAvoidanceState.Normal:
		{
			if (DetectObstacleAhead(num, avoidanceScanDirection, out var _))
			{
				currentAvoidanceState = HorseAvoidanceState.AvoidingObstacle;
			}
			avoidanceSteeringInput = 0;
			break;
		}
		case HorseAvoidanceState.AvoidingObstacle:
		{
			int num2 = DetermineAvoidanceDirection(num);
			avoidanceSteeringInput = num2;
			if (!DetectObstacleAhead(num, ((Component)this).transform.forward, out var _))
			{
				if (steerInput != 0f && steerInput != (float)avoidanceSteeringInput)
				{
					currentAvoidanceState = HorseAvoidanceState.Normal;
					avoidanceSteeringInput = 0;
				}
				else
				{
					currentAvoidanceState = HorseAvoidanceState.Normal;
					avoidanceSteeringInput = 0;
				}
			}
			break;
		}
		}
	}

	private bool DetectObstacleAhead(float distance, Vector3 direction, out BaseEntity avoidedEnt)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		avoidedEnt = null;
		RaycastHit val = default(RaycastHit);
		if (Physics.SphereCast(((Component)this).transform.position + ((Component)this).transform.forward + Vector3.up * 1f, avoidanceSphereRadius, direction, ref val, distance, LayerMask.op_Implicit(avoidanceObstacleMask)))
		{
			BaseEntity baseEntity = ((RaycastHit)(ref val)).collider.ToBaseEntity();
			if (baseEntity is TreeEntity)
			{
				avoidedEnt = baseEntity;
				return true;
			}
			if (baseEntity is ResourceEntity)
			{
				Physics.IgnoreCollision((Collider)(object)wheelCollider, ((RaycastHit)(ref val)).collider);
			}
		}
		return false;
	}

	private int DetermineAvoidanceDirection(float detectDistance)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.forward + ((Component)this).transform.right * 0.5f;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = ((Component)this).transform.forward - ((Component)this).transform.right * 0.5f;
		Vector3 normalized2 = ((Vector3)(ref val)).normalized;
		float num = CheckSideClearance(normalized, detectDistance);
		float num2 = CheckSideClearance(normalized2, detectDistance);
		if (!(num > num2))
		{
			return -1;
		}
		return 1;
	}

	private float CheckSideClearance(Vector3 direction, float distance)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.SphereCast(((Component)this).transform.position + Vector3.up * 1f, avoidanceSphereRadius, direction, ref val, distance, LayerMask.op_Implicit(avoidanceObstacleMask)))
		{
			if (((RaycastHit)(ref val)).collider.ToBaseEntity() is TreeEntity)
			{
				return ((RaycastHit)(ref val)).distance;
			}
			return distance;
		}
		return distance;
	}

	public void OnRagdollCollisionEnter(Collision collision)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		OnLanded(Mathf.Abs(collision.relativeVelocity.y));
	}

	protected void OnCollisionEnter(Collision collision)
	{
		if (base.isServer)
		{
			ProcessCollision(collision, rigidBody);
		}
	}

	protected void ProcessCollision(Collision collision, Rigidbody ourRigidbody)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && collision != null && !((Object)(object)collision.gameObject == (Object)null) && !((Object)(object)collision.gameObject == (Object)null))
		{
			Vector3 relativeVelocity = collision.relativeVelocity;
			float num = ((Vector3)(ref relativeVelocity)).magnitude * rigidBody.mass;
			float num2 = Vector3.Dot(-((ContactPoint)(ref collision.contacts[0])).normal, ((Component)this).transform.forward);
			float num3 = Mathf.Lerp(0.2f, 1f, Mathf.Clamp01(num2));
			num *= num3;
			if (QueueCollisionDamage(this, num) > 0f)
			{
				TryShowCollisionFX(collision);
			}
		}
	}

	private float QueueCollisionDamage(BaseEntity hitEntity, float forceMagnitude)
	{
		float num = Mathf.InverseLerp(minCollisionDamageForce, maxCollisionDamageForce, forceMagnitude);
		if (num > 0f)
		{
			float num2 = Mathf.Lerp(1f, 200f, num) * collisionDamageMultiplier;
			if (damageSinceLastTick.TryGetValue(hitEntity, out var value))
			{
				if (value < num2)
				{
					damageSinceLastTick[hitEntity] = num2;
				}
			}
			else
			{
				damageSinceLastTick[hitEntity] = num2;
			}
		}
		return num;
	}

	protected virtual void DoCollisionDamage(BaseEntity hitEntity, float damage)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		lastCrashDamage = damage;
		if (damage > playerDamageThreshold)
		{
			float damage2 = (damage - playerDamageThreshold) / 4f;
			DamageAllRiders(damage2);
		}
		if (damage > playerRagdollThreshold)
		{
			Vector3 mountRagdollVelocity = GetMountRagdollVelocity(GetDriver());
			RagdollAllRiders(mountRagdollVelocity);
		}
		Hurt(damage, DamageType.Collision, this, useProtection: false);
		if (damage > playerRagdollThreshold && !IsDead() && !HasFlag(Flags.Reserved12))
		{
			RagdollHorse();
		}
	}

	private void OnLanded(float impactSpeed)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		float num = DamageFromFalling(impactSpeed, checkAirtime: true);
		if (num != 0f)
		{
			Hurt(num, DamageType.Fall, this, useProtection: false);
			TryShowCollisionFX(((Component)this).transform.position);
			if (num > playerDamageThreshold)
			{
				float damage = (num - playerDamageThreshold) / 4f;
				DamageAllRiders(damage);
			}
			if (num > 100f)
			{
				RagdollAllRiders();
			}
		}
	}

	private float DamageFromFalling(float impactSpeed, bool checkAirtime)
	{
		float result = 0f;
		if (impactSpeed > 5f && (!checkAirtime || airTime > 0.4f))
		{
			result = (impactSpeed - 5f) * 10f;
		}
		return result;
	}

	private void DamageAllRiders(float damage)
	{
		BasePlayer driver = GetDriver();
		if ((Object)(object)driver != (Object)null && !driver.IsDead())
		{
			driver.Hurt(damage, DamageType.Collision, this, useProtection: false);
		}
		BasePlayer passenger = GetPassenger();
		if ((Object)(object)passenger != (Object)null && !passenger.IsDead())
		{
			passenger.Hurt(damage, DamageType.Collision, this, useProtection: false);
		}
	}

	private void RagdollAllRiders(Vector3 force = default(Vector3))
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer driver = GetDriver();
		if ((Object)(object)driver != (Object)null && !driver.IsDead())
		{
			driver.Ragdoll(force);
		}
		BasePlayer passenger = GetPassenger();
		if ((Object)(object)passenger != (Object)null && !passenger.IsDead())
		{
			passenger.Ragdoll(force);
		}
	}

	public override GameObjectRef GetCollisionFX()
	{
		return collisionEffect;
	}

	public override Vector3 GetMountRagdollVelocity(BasePlayer player)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Clamp(lastCrashDamage, 0f, 75f);
		return ((Component)this).transform.forward * num * 0.25f;
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return Mathf.Abs(GetSpeed()) * 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	[ServerVar]
	public static void Ragdoll(Arg arg)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		List<RidableHorse> list = Pool.Get<List<RidableHorse>>();
		Vis.Entities(basePlayer.eyes.position, basePlayer.eyes.position + basePlayer.eyes.HeadForward() * 5f, 0f, list, -1, (QueryTriggerInteraction)2);
		foreach (RidableHorse item in list)
		{
			item.RagdollHorse();
		}
		Pool.FreeUnmanaged<RidableHorse>(ref list);
	}

	public void RagdollHorse()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (!Physics.allowhorsetempragdoll)
		{
			DismountAllPlayers();
		}
		else if (!HasFlag(Flags.Reserved12))
		{
			DismountAllPlayers();
			CreateRagdoll(((Component)this).transform.position, ((Component)this).transform.rotation);
			SetFlag(Flags.Reserved12, b: true);
			SendNetworkUpdateImmediate();
		}
	}

	private void CreateRagdoll(Vector3 position, Quaternion rotation)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		BaseAnimalRagdoll baseAnimalRagdoll = GameManager.server.CreateEntity(ragdollPrefab.resourcePath) as BaseAnimalRagdoll;
		if (baseAnimalRagdoll != null)
		{
			((Component)baseAnimalRagdoll).transform.SetPositionAndRotation(position, rotation);
		}
		Ragdoll ragdoll = ((baseAnimalRagdoll != null) ? ((Component)baseAnimalRagdoll).GetComponent<Ragdoll>() : null);
		if ((Object)(object)ragdoll != (Object)null)
		{
			ragdoll.simOnServer = true;
		}
		baseAnimalRagdoll?.InitFromEnt(this);
		baseAnimalRagdoll?.Spawn();
		GameObjectExtensions.SetIgnoreCollisions(((Component)this).gameObject, ((Component)baseAnimalRagdoll).gameObject, true);
	}

	private void OnRagdollStartServer()
	{
		TowDetach();
		SetLeading(null);
		rigidBody.isKinematic = true;
		((Collider)wheelCollider).enabled = false;
		SetWorldColliders(enabled: false);
		((Behaviour)serverLegsAnimator).enabled = false;
	}

	private void OnRagdollEndServer()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		rigidBody.isKinematic = false;
		((Collider)wheelCollider).enabled = true;
		currentGait = GaitType.Walk;
		UpdateGroundNormal();
		averagedUp = targetUp;
		AlignWithNormal(targetUp, force: true);
		isGrounded = true;
		airTime = 0f;
		lastMovingTime = Time.time;
		SetWorldColliders(enabled: true);
		ResetBonesPositions();
		((Behaviour)serverLegsAnimator).enabled = true;
		damageSinceLastTick.Clear();
		rigidBody.WakeUp();
	}

	private void SetWorldColliders(bool enabled)
	{
		List<Collider> list = Pool.Get<List<Collider>>();
		((Component)this).GetComponentsInChildren<Collider>(list);
		foreach (Collider item in list)
		{
			if (item.IsOnLayer((Layer)15))
			{
				item.enabled = enabled;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	private void UpdateOnTerrain()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time < nextTerrainCheckTime)
		{
			return;
		}
		nextTerrainCheckTime = Time.time + Random.Range(0.5f, 1f);
		onIdealTerrain = false;
		onWaterTopology = false;
		if ((Object)(object)TerrainMeta.TopologyMap != (Object)null)
		{
			int topology = TerrainMeta.TopologyMap.GetTopology(((Component)this).transform.position);
			if ((topology & 0x80800) != 0)
			{
				onIdealTerrain = true;
			}
			if ((topology & 0x14080) != 0)
			{
				onWaterTopology = true;
			}
		}
	}

	public void UpdateStamina(float delta)
	{
		if (currentGait == GaitType.Gallop)
		{
			UseStamina(delta);
		}
		else if (IsSwimming)
		{
			UseStamina(delta * 0.5f);
		}
		else if (currentStamina != currentMaxStamina)
		{
			ReplenishStamina(GetStaminaReplenishRatio() * delta);
		}
	}

	public void UseStamina(float amount)
	{
		if (onIdealTerrain)
		{
			amount *= 0.5f;
		}
		currentStamina -= amount;
		if (currentStamina <= 0f)
		{
			currentStamina = 0f;
		}
	}

	private float GetStaminaReplenishRatio()
	{
		return GetCurrentGait().staminaReplenishRatio;
	}

	public void ReplenishStamina(float amount)
	{
		float num = 1f + Mathf.InverseLerp(maxStamina * 0.5f, maxStamina, currentMaxStamina);
		amount *= num;
		amount = Mathf.Min(currentMaxStamina - currentStamina, amount);
		float num2 = Mathf.Min(currentMaxStamina - staminaCoreLossRatio * amount, amount * staminaCoreLossRatio);
		currentMaxStamina = Mathf.Clamp(currentMaxStamina - num2, 0f, maxStamina);
		currentStamina = Mathf.Clamp(currentStamina + num2 / staminaCoreLossRatio, 0f, currentMaxStamina);
		if (currentStamina == currentMaxStamina)
		{
			OnStaminaReplenished();
		}
	}

	private void OnStaminaReplenished()
	{
		UpdateClients(force: true);
	}

	public void ReplenishStaminaCore(float calories, float hydration)
	{
		float num = calories * calorieToStaminaRatio;
		float num2 = hydration * hydrationToStaminaRatio;
		num2 = Mathf.Min(maxStaminaCoreFromWater - currentMaxStamina, num2);
		if (num2 < 0f)
		{
			num2 = 0f;
		}
		float num3 = num + num2;
		currentMaxStamina = Mathf.Clamp(currentMaxStamina + num3, 0f, maxStamina);
		currentStamina = Mathf.Clamp(currentStamina + num3, 0f, currentMaxStamina);
	}

	public void SetLeading(BasePlayer target)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Reserved16, (Object)(object)target != (Object)null);
		if (!((Object)(object)target == (Object)(object)leadingPlayer))
		{
			if ((Object)(object)target != (Object)null)
			{
				playerLeadingId = target.net.ID;
				inputProvider = new AIHorseInputProvider(this, ((Component)target).transform, 3f);
				PlayerModifiers.AddToPlayer(target, pullingPlayerModifiers);
			}
			else
			{
				leadingPlayer.modifiers.RemoveFromSource(Modifier.ModifierSource.Interaction);
				playerLeadingId = default(NetworkableId);
			}
			leadingPlayer = target;
			SendNetworkUpdateImmediate();
			LeadingChanged();
			if ((Object)(object)leadingPlayer == (Object)null)
			{
				ClientRPC(RpcTarget.NetworkGroup("CLIENT_StopLeading"));
			}
			else
			{
				ClientRPC(RpcTarget.NetworkGroup("CLIENT_StartLeading"));
			}
		}
	}

	public void LeadingChanged()
	{
		if (!IsLeading)
		{
			TryToHitch();
		}
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_Lead(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		bool flag = msg.read.Bool();
		if (flag)
		{
			if (!CanLead(player))
			{
				return;
			}
		}
		else if (!CanStopLead(player))
		{
			return;
		}
		if (Interface.CallHook("OnHorseLead", (object)this, (object)player) == null)
		{
			SetLeading(flag ? player : null);
		}
	}

	public bool CanStand()
	{
		if (nextStandTime > Time.time)
		{
			return false;
		}
		if ((Object)(object)mountPoints[0].mountable == (Object)null)
		{
			return false;
		}
		return IsStandCollisionClear();
	}

	public virtual bool IsStandCollisionClear()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(((Component)mountPoints[0].mountable.eyePositionOverride).transform.position - ((Component)this).transform.forward * 1f, 2f, list, 2162689, (QueryTriggerInteraction)2);
		bool num = list.Count > 0;
		Pool.FreeUnmanaged<Collider>(ref list);
		return !num;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		InitContainers();
		SetBreed(Random.Range(0, breeds.Length));
		SetFlag(Flags.Reserved16, b: false);
		baseHorseProtection = baseProtection;
		riderProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
		baseProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
		baseProtection.Add(baseHorseProtection, 1f);
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		terrainHandler = new VehicleTerrainHandler(this);
		towingTrigger.OnEntityEnterTrigger = HandleTowTrigger;
		towingTrigger.OnEntityLeaveTrigger = HandleTowTriggerLeave;
		towingAttachment = new TowingAttachment<RidableHorse>(this);
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.333f, 0.1f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)HorseDecay, Random.Range(30f, 60f), 60f, 6f);
		SpawnWildSaddle();
		EquipmentUpdate();
		if ((Object)(object)modifiers != (Object)null)
		{
			modifiers.ServerInit(this);
		}
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		CreateInventories(giveUID: false);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		ReleaseInventories();
	}

	private void ServerFlagsChanged(Flags old, Flags next)
	{
		if ((old & Flags.Reserved3) != 0 && (next & Flags.Reserved3) != 0)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)EatFromHitch, Random.Range(1f, 2f), 2f);
		}
		if ((next & Flags.Reserved13) != 0 && (next & Flags.Reserved14) != 0)
		{
			TowDetach();
		}
		bool flag = (old & Flags.Reserved12) != 0;
		bool flag2 = (next & Flags.Reserved12) != 0;
		if (!flag && flag2)
		{
			OnRagdollStartServer();
		}
		else if (flag && !flag2)
		{
			OnRagdollEndServer();
		}
	}

	private void SpawnWildSaddle()
	{
		SetSeatCount(1);
	}

	public void SetForSale()
	{
		SetFlag(Flags.Reserved2, b: true);
		SetSeatCount(0);
	}

	protected override int GetClipCheckMask()
	{
		return base.GetClipCheckMask() & -1073741825;
	}

	private bool IsHorseClipping()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = ((Component)clippingMountCheckCollider).transform.localToWorldMatrix;
		Vector3 val = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(clippingMountCheckCollider.center);
		Vector3 val2 = Vector3.zero;
		((Vector3)(ref val2))[clippingMountCheckCollider.direction] = 1f;
		val2 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyVector(val2);
		float num = clippingMountCheckCollider.radius * 0.9f;
		float num2 = 0.5f * clippingMountCheckCollider.height * 0.9f - num;
		Vector3 point = val + val2 * num2;
		Vector3 point2 = val - val2 * num2;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapCapsule(point, point2, num, list, 1235583233, (QueryTriggerInteraction)1);
		for (int i = 0; i < list.Count; i++)
		{
			BaseEntity baseEntity = list[i].ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null && (baseEntity.isClient != base.isClient || (Object)(object)baseEntity == (Object)(object)this))
			{
				ListEx.RemoveUnordered<Collider>(list, i);
				i--;
			}
		}
		bool result = list.Count > 0;
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (IsForSale || !MountEligable(player) || HasFlag(Flags.Reserved12) || IsPlayerTooHeavy(player) || !CanPlayerSeeSaddlePoint(player) || IsHorseClipping())
		{
			return;
		}
		BaseMountable baseMountable = null;
		if (HasSingleSaddle && !player.IsRestrained)
		{
			baseMountable = mountPoints[0].mountable;
		}
		else
		{
			if (!HasDoubleSaddle)
			{
				return;
			}
			baseMountable = ((HasDriver() || player.IsRestrained) ? mountPoints[2].mountable : mountPoints[1].mountable);
		}
		if ((Object)(object)baseMountable != (Object)null)
		{
			baseMountable.AttemptMount(player, doMountChecks);
		}
	}

	public override void PlayerMounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerMounted(player, seat);
		UpdateClients();
		TryLeaveHitch();
		if (IsLeading)
		{
			SetLeading(null);
		}
		if (IsDriver(player))
		{
			((Component)playerServerCollider).gameObject.SetActive(true);
			inputProvider = new PlayerHorseInputProvider(player);
		}
		if (IsPassenger(player))
		{
			((Component)playerServerColliderRear).gameObject.SetActive(true);
		}
		((FacepunchBehaviour)this).InvokeRepeating((Action)SaveTraveledDistance, 10f, 10f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)PostPlayerLateUpdate, 0f, 0f);
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerDismounted(player, seat);
		UpdateClients(force: true);
		if (NumMounted() == 0)
		{
			TryToHitch();
		}
		if ((Object)(object)GetDriver() == (Object)null)
		{
			((Component)playerServerCollider).gameObject.SetActive(false);
			inputProvider = null;
		}
		if ((Object)(object)GetPassenger() == (Object)null)
		{
			((Component)playerServerColliderRear).gameObject.SetActive(false);
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)SaveTraveledDistance);
		((FacepunchBehaviour)this).CancelInvoke((Action)PostPlayerLateUpdate);
		lastRiddenTime = Time.time;
	}

	private void PostPlayerLateUpdate()
	{
		if (!AnyMounted())
		{
			return;
		}
		foreach (MountPointInfo allMountPoint in base.allMountPoints)
		{
			if (!((Object)(object)allMountPoint.mountable == (Object)null) && !((Object)(object)allMountPoint.mountable.GetMounted() == (Object)null))
			{
				allMountPoint.mountable.MountedPlayerSync();
			}
		}
	}

	private void SetSeatCount(int count)
	{
		SetFlag(Flags.Reserved9, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved10, b: false, recursive: false, networkupdate: false);
		switch (count)
		{
		case 1:
			SetFlag(Flags.Reserved9, b: true, recursive: false, networkupdate: false);
			break;
		case 2:
			SetFlag(Flags.Reserved10, b: true, recursive: false, networkupdate: false);
			break;
		}
		UpdateMountFlags();
	}

	public override bool IsPlayerSeatSwapValid(BasePlayer player, int fromIndex, int toIndex, bool ignoreRestraint)
	{
		if (!base.IsPlayerSeatSwapValid(player, fromIndex, toIndex, ignoreRestraint))
		{
			return false;
		}
		if (!HasSaddle)
		{
			return false;
		}
		if (HasSingleSaddle)
		{
			return false;
		}
		if (HasDoubleSaddle && toIndex == 0)
		{
			return false;
		}
		return true;
	}

	public override int MaxMounted()
	{
		return GetSeatCapacity();
	}

	public int GetSeatCapacity()
	{
		if (HasDoubleSaddle)
		{
			return 2;
		}
		if (HasSingleSaddle)
		{
			return 1;
		}
		return 0;
	}

	public override int NumSwappableSeats()
	{
		return mountPoints.Count;
	}

	public override void OnDied(HitInfo hitInfo)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		BaseCorpse baseCorpse = DropCorpse(corpsePrefab.resourcePath);
		if (Object.op_Implicit((Object)(object)baseCorpse))
		{
			SetupCorpse(baseCorpse);
			baseCorpse.Spawn();
			baseCorpse.TakeChildren(this);
		}
		SaveTraveledDistance();
		TryLeaveHitch();
		TowDetach();
		RagdollAllRiders();
		((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.5f);
		base.OnDied(hitInfo);
	}

	public override void AdminKill()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		SaveTraveledDistance();
		TryLeaveHitch();
		TowDetach();
		RagdollAllRiders();
		((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.5f);
		base.AdminKill();
	}

	public virtual void SetupCorpse(BaseCorpse corpse)
	{
		corpse.flags = flags;
		LootableCorpse component = ((Component)corpse).GetComponent<LootableCorpse>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.TakeFrom(this, storageInventory);
		}
		HorseCorpse component2 = ((Component)corpse).GetComponent<HorseCorpse>();
		if (Object.op_Implicit((Object)(object)component2))
		{
			component2.breedIndex = currentBreedIndex;
		}
	}

	private void UpdateClients()
	{
		UpdateClients(force: true);
	}

	private void UpdateClients(bool force = false)
	{
		if (force || AnyMounted() || IsLeading)
		{
			byte num = (byte)((duckInputDown ? (-1f) : throttleInput) + 1f);
			byte b = (byte)(steerInput + 1f);
			byte b2 = (byte)(avoidanceSteeringInput + 1);
			byte arg = (byte)(num | (b << 2) | (b2 << 4));
			byte arg2 = (byte)Mathf.Clamp(normalVariation / 100f * 255f, 0f, 255f);
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_HorseUpdate"), currentStamina, currentMaxStamina, (byte)currentGait, arg, arg2);
		}
	}

	public override void OnMountedPlayerWeightChanged(BasePlayer player)
	{
		base.OnMountedPlayerWeightChanged(player);
		if (IsPlayerTooHeavy(player))
		{
			player.EnsureDismounted();
		}
	}

	private void SaveTraveledDistance()
	{
		BasePlayer driver = GetDriver();
		if ((Object)(object)driver == (Object)null)
		{
			tempDistanceTravelled = 0f;
			return;
		}
		kmDistance += tempDistanceTravelled / 1000f;
		if (kmDistance >= 1f)
		{
			driver.stats.Add("horse_distance_ridden_km", 1, (Stats)5);
			kmDistance -= 1f;
		}
		driver.stats.Add("horse_distance_ridden", Mathf.FloorToInt(tempDistanceTravelled));
		driver.stats.Save();
		tempDistanceTravelled = 0f;
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		riderProtection.Scale(info.damageTypes);
	}

	public void OnTowAttach()
	{
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			ComponentExtensions.SetActive<TriggerTowing>(towingTrigger, false);
		}, 0f);
	}

	public void OnTowDetach()
	{
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			ComponentExtensions.SetActive<TriggerTowing>(towingTrigger, true);
		}, 1f);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	public void SERVER_RequestTow(RPCMessage msg)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (towableEntity != null && !IsTowing && !HasFlag(Flags.Reserved12))
		{
			TowAttach(msg.player);
			Effect.server.Run(towingAttachEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_RequestDetach(RPCMessage msg)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (IsTowing)
		{
			BasePlayer player = msg.player;
			if (!((Object)(object)player == (Object)null) && (!AnyMounted() || !((Object)(object)player.GetMounted().VehicleParent() != (Object)(object)this)))
			{
				TowDetach();
				Effect.server.Run(towingDetachEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

	private void TowAttach(BasePlayer requester = null)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		if (towableEntity == null || !towableEntity.IsTowingAllowed)
		{
			return;
		}
		if (Vector3.Dot(TowAnchor.forward, ((Component)towableEntity.TowAnchor).transform.forward) <= 0.5f)
		{
			if ((Object)(object)requester != (Object)null)
			{
				requester.ShowToast(GameTip.Styles.Error, TowAngleErrorPhrase, false);
			}
			return;
		}
		towingEntityId = towableEntity.TowEntity.net.ID;
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_SetTowId"), towableEntity.TowEntity.net.ID);
		towingAttachment.AttachTo(towableEntity);
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			ComponentExtensions.SetActive<TriggerTowing>(towingTrigger, false);
		}, 0f);
	}

	private void TowDetach()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (IsTowing)
		{
			towingEntityId = default(NetworkableId);
			((BaseEntity)this).ClientRPC(RpcTarget.NetworkGroup("CLIENT_SetTowId"), default(NetworkableId));
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: false);
			towableEntity = null;
			towingAttachment.Detach();
		}
	}

	private void ValidateTowableEntity()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (towableEntity != null)
		{
			towingEntityId = towableEntity.TowEntity.net.ID;
		}
		else
		{
			towableEntity = BaseNetworkable.serverEntities.Find(towingEntityId) as ITowing;
		}
	}

	private void HandleTowTrigger(BaseNetworkable networkable)
	{
		if (networkable is ITowing { IsTowing: false } towing)
		{
			towableEntity = towing;
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: true);
		}
		else
		{
			towableEntity = null;
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: false);
		}
	}

	private void HandleTowTriggerLeave(BaseNetworkable networkable)
	{
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: false);
		towableEntity = null;
	}

	public void OnJointBreak(float breakForce)
	{
		TowDetach();
	}

	private void HorseDecay()
	{
		if (base.healthFraction != 0f && !base.IsDestroyed && !(Time.time < lastRiddenTime + 600f) && !(Time.time < lastEatTime + 600f) && !IsForSale && !(Time.time < nextDecayTime))
		{
			float num = 1f / decayMinutes;
			float num2 = ((!IsOutside()) ? 1f : 0.5f);
			Hurt(MaxHealth() * num * num2, DamageType.Decay, this, useProtection: false);
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (!IsForSale)
		{
			base.Hurt(info);
		}
	}

	private void AddDecayDelay(float time)
	{
		if (nextDecayTime < Time.time)
		{
			nextDecayTime = Time.time + 5f;
		}
		nextDecayTime += time;
	}

	[ServerVar]
	public static void SetHorseBreed(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		int @int = arg.GetInt(0, 0);
		List<RidableHorse> list = Pool.Get<List<RidableHorse>>();
		Vis.Entities(basePlayer.eyes.position, basePlayer.eyes.position + basePlayer.eyes.HeadForward() * 5f, 0f, list, -1, (QueryTriggerInteraction)2);
		foreach (RidableHorse item in list)
		{
			item.SetBreed(@int);
		}
		Pool.FreeUnmanaged<RidableHorse>(ref list);
	}

	[ServerVar]
	public static void SetForSale(Arg arg)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		List<RidableHorse> list = Pool.Get<List<RidableHorse>>();
		Vis.Entities(basePlayer.eyes.position, basePlayer.eyes.position + basePlayer.eyes.HeadForward() * 5f, 0f, list, -1, (QueryTriggerInteraction)2);
		foreach (RidableHorse item in list)
		{
			item.SetForSale();
		}
		Pool.FreeUnmanaged<RidableHorse>(ref list);
	}

	public override bool AdminFixUp(int tier)
	{
		if (IsDead())
		{
			return false;
		}
		ReplenishStamina(1000f);
		ReplenishStaminaCore(10000f, 10000f);
		return base.AdminFixUp(tier);
	}
}


public enum GaitType : byte
{
	Walk,
	Trot,
	Canter,
	Gallop
}


using System;

[Serializable]
public struct Gait
{
	public GaitType gaitType;

	public float minSpeed;

	public float maxSpeed;

	public float accelerationForce;

	public float brakingForce;

	public float turnSpeed;

	public float staminaReplenishRatio;

	public bool equipmentScalesMaxSpeed;

	public bool breedScalesMaxSpeed;
}


using System;
using UnityEngine;

[Serializable]
public struct PurchaseOption
{
	public ItemDefinition tokenItem;

	public Phrase title;

	public Phrase description;

	public Sprite icon;

	public int order;
}


public enum HorseAvoidanceState
{
	Normal,
	AvoidingObstacle
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class RustigeEgg : BaseCombatEntity
{
	public const Flags Flag_Spin = Flags.Reserved1;

	public Transform eggRotationTransform;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RustigeEgg.OnRpcMessage", 0);
		try
		{
			if (rpc == 4254195175u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4254195175u, "RPC_Open", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Open(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Open");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1455840454 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Spin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Spin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1455840454u, "RPC_Spin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_Spin(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Spin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsSpinning()
	{
		return HasFlag(Flags.Reserved1);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Spin(RPCMessage msg)
	{
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Open(RPCMessage msg)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null)
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag != IsOpen())
		{
			if (flag)
			{
				ClientRPC(RpcTarget.NetworkGroup("FaceEggPosition"), msg.player.eyes.position);
				((FacepunchBehaviour)this).Invoke((Action)CloseEgg, 60f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)CloseEgg);
			}
			SetFlag(Flags.Open, flag, recursive: false, networkupdate: false);
			if (IsSpinning() && flag)
			{
				SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
			}
			SendNetworkUpdateImmediate();
		}
	}

	public void CloseEgg()
	{
		SetFlag(Flags.Open, b: false);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SamSite : ContainerIOEntity
{
	public interface ISamSiteTarget
	{
		static List<ISamSiteTarget> serverList;

		SamTargetType SAMTargetType { get; }

		bool isClient { get; }

		bool IsValidSAMTarget(bool staticRespawn);

		Vector3 CenterPoint();

		Vector3 GetWorldVelocity();

		bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

		static ISamSiteTarget()
		{
			serverList = new List<ISamSiteTarget>();
		}
	}

	public class SamTargetType
	{
		public readonly float scanRadius;

		public readonly float speedMultiplier;

		public readonly float timeBetweenBursts;

		public SamTargetType(float scanRadius, float speedMultiplier, float timeBetweenBursts)
		{
			this.scanRadius = scanRadius;
			this.speedMultiplier = speedMultiplier;
			this.timeBetweenBursts = timeBetweenBursts;
		}
	}

	public Animator pitchAnimator;

	public GameObject yaw;

	public GameObject pitch;

	public GameObject gear;

	public Transform eyePoint;

	public float gearEpislonDegrees = 20f;

	public float turnSpeed = 1f;

	public float clientLerpSpeed = 1f;

	public Vector3 currentAimDir = Vector3.forward;

	public Vector3 targetAimDir = Vector3.forward;

	public float vehicleScanRadius = 350f;

	public float missileScanRadius = 500f;

	public GameObjectRef projectileTest;

	public GameObjectRef muzzleFlashTest;

	public bool staticRespawn;

	public ItemDefinition ammoType;

	public Transform[] tubes;

	[ServerVar(Help = "how long until static sam sites auto repair")]
	public static float staticrepairseconds = 1200f;

	public SoundDefinition yawMovementLoopDef;

	public float yawGainLerp = 8f;

	public float yawGainMovementSpeedMult = 0.1f;

	public SoundDefinition pitchMovementLoopDef;

	public float pitchGainLerp = 10f;

	public float pitchGainMovementSpeedMult = 0.5f;

	public int lowAmmoThreshold = 5;

	public Flags Flag_TargetMode = Flags.Reserved9;

	public Flags Flag_ManuallySetMode = Flags.Reserved10;

	public static SamTargetType targetTypeUnknown;

	public static SamTargetType targetTypeVehicle;

	public static SamTargetType targetTypeMissile;

	public ISamSiteTarget currentTarget;

	public SamTargetType mostRecentTargetType;

	public Item ammoItem;

	public float lockOnTime;

	public float lastTargetVisibleTime;

	public int lastAmmoCount;

	public int currentTubeIndex;

	public int firedCount;

	public float nextBurstTime;

	private int input1Amount;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SamSite.OnRpcMessage", 0);
		try
		{
			if (rpc == 3160662357u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ToggleDefenderMode "));
				}
				TimeWarning val2 = TimeWarning.New("ToggleDefenderMode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3160662357u, "ToggleDefenderMode", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3160662357u, "ToggleDefenderMode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ToggleDefenderMode(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ToggleDefenderMode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool IsPowered()
	{
		if (!staticRespawn)
		{
			return HasFlag(Flags.Reserved8);
		}
		return true;
	}

	public override int ConsumptionAmount()
	{
		return 25;
	}

	public bool IsInDefenderMode()
	{
		return HasFlag(Flag_TargetMode);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	public void SetTarget(ISamSiteTarget target)
	{
		bool num = currentTarget != target;
		currentTarget = target;
		if (!target.IsUnityNull())
		{
			mostRecentTargetType = target.SAMTargetType;
		}
		if (num)
		{
			MarkIODirty();
		}
	}

	public void MarkIODirty()
	{
		if (!staticRespawn)
		{
			lastPassthroughEnergy = -1;
			MarkDirtyForceUpdateOutputs();
		}
	}

	public void ClearTarget()
	{
		SetTarget(null);
	}

	public override void ServerInit()
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		targetTypeUnknown = new SamTargetType(vehicleScanRadius, 1f, 5f);
		targetTypeVehicle = new SamTargetType(vehicleScanRadius, 1f, 5f);
		targetTypeMissile = new SamTargetType(missileScanRadius, 2.25f, 3.5f);
		mostRecentTargetType = targetTypeUnknown;
		ClearTarget();
		((FacepunchBehaviour)this).InvokeRandomized((Action)TargetScan, 1f, 3f, 0.2f);
		currentAimDir = ((Component)this).transform.forward;
		if (base.inventory != null && !staticRespawn)
		{
			base.inventory.onItemAddedRemoved = OnItemAddedRemoved;
		}
	}

	public void OnItemAddedRemoved(Item arg1, bool arg2)
	{
		EnsureReloaded();
		if (IsPowered())
		{
			MarkIODirty();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.samSite = Pool.Get<SAMSite>();
		info.msg.samSite.aimDir = GetAimDir();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (staticRespawn && HasFlag(Flags.Reserved1))
		{
			((FacepunchBehaviour)this).Invoke((Action)SelfHeal, staticrepairseconds);
		}
	}

	public void SelfHeal()
	{
		lifestate = LifeState.Alive;
		base.health = startHealth;
		SetFlag(Flags.Reserved1, b: false);
	}

	public override void Die(HitInfo info = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (staticRespawn)
		{
			ClearTarget();
			Quaternion val = Quaternion.LookRotation(currentAimDir, Vector3.up);
			val = Quaternion.Euler(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f);
			currentAimDir = val * Vector3.forward;
			((FacepunchBehaviour)this).Invoke((Action)SelfHeal, staticrepairseconds);
			lifestate = LifeState.Dead;
			base.health = 0f;
			SetFlag(Flags.Reserved1, b: true);
		}
		else
		{
			base.Die(info);
		}
	}

	public void FixedUpdate()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = currentAimDir;
		if (!currentTarget.IsUnityNull() && IsPowered())
		{
			float num = projectileTest.Get().GetComponent<ServerProjectile>().speed * currentTarget.SAMTargetType.speedMultiplier;
			Vector3 val2 = currentTarget.CenterPoint();
			float num2 = Vector3.Distance(val2, ((Component)eyePoint).transform.position);
			float num3 = num2 / num;
			Vector3 val3 = val2 + currentTarget.GetWorldVelocity() * num3;
			num3 = Vector3.Distance(val3, ((Component)eyePoint).transform.position) / num;
			val3 = val2 + currentTarget.GetWorldVelocity() * num3;
			Vector3 val4 = currentTarget.GetWorldVelocity();
			if (((Vector3)(ref val4)).magnitude > 0.1f)
			{
				float num4 = Mathf.Sin(Time.time * 3f) * (1f + num3 * 0.5f);
				Vector3 val5 = val3;
				val4 = currentTarget.GetWorldVelocity();
				val3 = val5 + ((Vector3)(ref val4)).normalized * num4;
			}
			val4 = val3 - ((Component)eyePoint).transform.position;
			currentAimDir = ((Vector3)(ref val4)).normalized;
			if (num2 > currentTarget.SAMTargetType.scanRadius)
			{
				ClearTarget();
			}
		}
		Quaternion val6 = Quaternion.LookRotation(currentAimDir, ((Component)this).transform.up);
		Vector3 eulerAngles = ((Quaternion)(ref val6)).eulerAngles;
		eulerAngles = BaseMountable.ConvertVector(eulerAngles);
		float num5 = Mathf.InverseLerp(0f, 90f, 0f - eulerAngles.x);
		float num6 = Mathf.Lerp(15f, -75f, num5);
		Quaternion localRotation = Quaternion.Euler(0f, eulerAngles.y, 0f);
		yaw.transform.localRotation = localRotation;
		Quaternion localRotation2 = pitch.transform.localRotation;
		float x = ((Quaternion)(ref localRotation2)).eulerAngles.x;
		localRotation2 = pitch.transform.localRotation;
		Quaternion localRotation3 = Quaternion.Euler(x, ((Quaternion)(ref localRotation2)).eulerAngles.y, num6);
		pitch.transform.localRotation = localRotation3;
		if (currentAimDir != val)
		{
			SendNetworkUpdate();
		}
	}

	public Vector3 GetAimDir()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return currentAimDir;
	}

	public bool HasValidTarget()
	{
		return !currentTarget.IsUnityNull();
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (!base.CanPickup(player))
		{
			return false;
		}
		if (base.isServer && pickup.requireEmptyInv && base.inventory != null && base.inventory.itemList.Count > 0)
		{
			return false;
		}
		return !HasAmmo();
	}

	private void AddTargetSet(List<ISamSiteTarget> allTargets, float scanRadius)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		foreach (ISamSiteTarget server in ISamSiteTarget.serverList)
		{
			if (!(server is MLRSRocket) && Vector3.Distance(server.CenterPoint(), ((Component)eyePoint).transform.position) < scanRadius)
			{
				allTargets.Add(server);
			}
		}
	}

	private void AddMLRSRockets(List<ISamSiteTarget> allTargets, float scanRadius)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (MLRSRocket.serverList.Count == 0)
		{
			return;
		}
		foreach (MLRSRocket server in MLRSRocket.serverList)
		{
			if (Vector3.Distance(((Component)server).transform.position, ((Component)this).transform.position) < scanRadius)
			{
				allTargets.Add(server);
			}
		}
	}

	public void TargetScan()
	{
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (Time.time > lastTargetVisibleTime + 3f)
		{
			ClearTarget();
		}
		if (!staticRespawn)
		{
			int num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);
			bool flag = lastAmmoCount < lowAmmoThreshold;
			bool flag2 = num < lowAmmoThreshold;
			if (num != lastAmmoCount && flag != flag2)
			{
				MarkIODirty();
			}
			lastAmmoCount = num;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<ISamSiteTarget> list = Pool.Get<List<ISamSiteTarget>>();
		if (Interface.CallHook("OnSamSiteTargetScan", (object)this, (object)list) == null)
		{
			if (!IsInDefenderMode())
			{
				AddTargetSet(list, targetTypeVehicle.scanRadius);
			}
			AddMLRSRockets(list, targetTypeMissile.scanRadius);
		}
		ISamSiteTarget samSiteTarget = null;
		foreach (ISamSiteTarget item in list)
		{
			if (!item.isClient && !(item.CenterPoint().y < ((Component)eyePoint).transform.position.y) && item.IsVisible(((Component)eyePoint).transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn) && Interface.CallHook("OnSamSiteTarget", (object)this, (object)item) == null)
			{
				samSiteTarget = item;
				break;
			}
		}
		if (!samSiteTarget.IsUnityNull() && currentTarget != samSiteTarget)
		{
			lockOnTime = Time.time + 0.5f;
		}
		SetTarget(samSiteTarget);
		if (!currentTarget.IsUnityNull())
		{
			lastTargetVisibleTime = Time.time;
		}
		Pool.FreeUnmanaged<ISamSiteTarget>(ref list);
		if (currentTarget.IsUnityNull())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)WeaponTick);
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)WeaponTick, 0f, 0.5f, 0.2f);
		}
	}

	public virtual bool HasAmmo()
	{
		if (!staticRespawn)
		{
			if (ammoItem != null && ammoItem.amount > 0)
			{
				return ammoItem.parent == base.inventory;
			}
			return false;
		}
		return true;
	}

	public void Reload()
	{
		if (staticRespawn)
		{
			return;
		}
		for (int i = 0; i < base.inventory.itemList.Count; i++)
		{
			Item item = base.inventory.itemList[i];
			if (item != null && item.info.itemid == ammoType.itemid && item.amount > 0)
			{
				ammoItem = item;
				return;
			}
		}
		ammoItem = null;
	}

	public void EnsureReloaded()
	{
		if (!HasAmmo())
		{
			Reload();
		}
	}

	public bool IsReloading()
	{
		return ((FacepunchBehaviour)this).IsInvoking((Action)Reload);
	}

	public void WeaponTick()
	{
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		if (IsDead() || Time.time < lockOnTime || Time.time < nextBurstTime)
		{
			return;
		}
		if (!IsPowered())
		{
			firedCount = 0;
			return;
		}
		if (firedCount >= 6)
		{
			float timeBetweenBursts = mostRecentTargetType.timeBetweenBursts;
			nextBurstTime = Time.time + timeBetweenBursts;
			firedCount = 0;
			return;
		}
		EnsureReloaded();
		if (Interface.CallHook("CanSamSiteShoot", (object)this) == null && HasAmmo())
		{
			bool num = ammoItem != null && ammoItem.amount == lowAmmoThreshold;
			if (!staticRespawn && ammoItem != null)
			{
				ammoItem.UseItem();
			}
			firedCount++;
			float speedMultiplier = 1f;
			if (!currentTarget.IsUnityNull())
			{
				speedMultiplier = currentTarget.SAMTargetType.speedMultiplier;
			}
			FireProjectile(tubes[currentTubeIndex].position, currentAimDir, speedMultiplier);
			Effect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get("Tube " + (currentTubeIndex + 1)), Vector3.zero, Vector3.up);
			currentTubeIndex++;
			if (currentTubeIndex >= tubes.Length)
			{
				currentTubeIndex = 0;
			}
			if (num)
			{
				MarkIODirty();
			}
		}
	}

	public void FireProjectile(Vector3 origin, Vector3 direction, float speedMultiplier)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(projectileTest.resourcePath, origin, Quaternion.LookRotation(direction, Vector3.up));
		if (!((Object)(object)baseEntity == (Object)null))
		{
			baseEntity.creatorEntity = this;
			ServerProjectile component = ((Component)baseEntity).GetComponent<ServerProjectile>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.InitializeVelocity(GetInheritedProjectileVelocity(direction) + direction * component.speed * speedMultiplier);
			}
			baseEntity.Spawn();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int result = Mathf.Min(1, GetCurrentEnergy());
		switch (outputSlot)
		{
		case 0:
			if (currentTarget.IsUnityNull())
			{
				return 0;
			}
			return result;
		case 1:
			if (ammoItem == null || ammoItem.amount >= lowAmmoThreshold || ammoItem.parent != base.inventory)
			{
				return 0;
			}
			return result;
		case 2:
			if (HasAmmo())
			{
				return 0;
			}
			return result;
		default:
			return GetCurrentEnergy();
		}
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ToggleDefenderMode(RPCMessage msg)
	{
		if (staticRespawn)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && player.CanBuild())
		{
			bool flag = msg.read.Bit();
			if (flag != IsInDefenderMode() && Interface.CallHook("OnSamSiteModeToggle", (object)this, (object)player, (object)flag) == null)
			{
				SetFlag(Flag_ManuallySetMode, flag);
				SetFlag(Flag_TargetMode, flag);
			}
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		switch (inputSlot)
		{
		case 0:
			base.UpdateFromInput(inputAmount, inputSlot);
			break;
		case 1:
			if (input1Amount != inputAmount)
			{
				bool flag = HasFlag(Flag_ManuallySetMode);
				SetFlag(Flag_TargetMode, (inputAmount == 0) ? flag : (!flag));
			}
			input1Amount = inputAmount;
			break;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public interface ISamSiteTarget
{
	static List<ISamSiteTarget> serverList;

	SamTargetType SAMTargetType { get; }

	bool isClient { get; }

	bool IsValidSAMTarget(bool staticRespawn);

	Vector3 CenterPoint();

	Vector3 GetWorldVelocity();

	bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

	static ISamSiteTarget()
	{
		serverList = new List<ISamSiteTarget>();
	}
}


public class SamTargetType
{
	public readonly float scanRadius;

	public readonly float speedMultiplier;

	public readonly float timeBetweenBursts;

	public SamTargetType(float scanRadius, float speedMultiplier, float timeBetweenBursts)
	{
		this.scanRadius = scanRadius;
		this.speedMultiplier = speedMultiplier;
		this.timeBetweenBursts = timeBetweenBursts;
	}
}


using System;
using Network;
using UnityEngine;

public class SantaSleigh : BaseEntity
{
	public GameObjectRef prefabDrop;

	public SpawnFilter filter;

	public Transform dropOrigin;

	[ServerVar]
	public static float altitudeAboveTerrain = 50f;

	[ServerVar]
	public static float desiredAltitude = 60f;

	public Light bigLight;

	public SoundPlayer hohoho;

	public float hohohospacing = 4f;

	public float hohoho_additional_spacing = 2f;

	public Vector3 swimScale;

	public Vector3 swimSpeed;

	public float appliedSwimScale = 1f;

	public float appliedSwimRotation = 20f;

	private Vector3 startPos;

	private Vector3 endPos;

	private float secondsToTake;

	private float secondsTaken;

	private bool dropped;

	public Vector3 dropPosition = Vector3.zero;

	private float swimRandom;

	private const string path = "assets/prefabs/misc/xmas/sleigh/santasleigh.prefab";

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SantaSleigh.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public void InitDropPosition(Vector3 newDropPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		dropPosition = newDropPosition;
		dropPosition.y = 0f;
	}

	public override void ServerInit()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (dropPosition == Vector3.zero)
		{
			dropPosition = RandomDropPosition();
		}
		UpdateDropPosition(dropPosition);
		((FacepunchBehaviour)this).Invoke((Action)SendHoHoHo, 0f);
	}

	public void SendHoHoHo()
	{
		((FacepunchBehaviour)this).Invoke((Action)SendHoHoHo, hohohospacing + Random.Range(0f, hohoho_additional_spacing));
		ClientRPC(RpcTarget.NetworkGroup("ClientPlayHoHoHo"));
	}

	public Vector3 RandomDropPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		float num = 100f;
		float x = TerrainMeta.Size.x;
		do
		{
			zero = Vector3Ex.Range(0f - x / 3f, x / 3f);
		}
		while (filter.GetFactor(zero) == 0f && (num -= 1f) > 0f);
		zero.y = 0f;
		return zero;
	}

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float y = altitudeAboveTerrain;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		((Vector3)(ref startPos)).Normalize();
		startPos *= x * 1.25f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 25f;
		secondsToTake *= Random.Range(0.95f, 1.05f);
		((Component)this).transform.SetPositionAndRotation(startPos, Quaternion.LookRotation(endPos - startPos));
		dropPosition = newDropPosition;
	}

	private void FixedUpdate()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		secondsTaken += Time.deltaTime;
		float num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
		if (!dropped && num >= 0.5f)
		{
			dropped = true;
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, ((Component)dropOrigin).transform.position);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.globalBroadcast = true;
				baseEntity.Spawn();
			}
		}
		position = Vector3.Lerp(startPos, endPos, num);
		Vector3 val = endPos - startPos;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Vector3.zero;
		if (swimScale != Vector3.zero)
		{
			if (swimRandom == 0f)
			{
				swimRandom = Random.Range(0f, 20f);
			}
			float num2 = Time.time + swimRandom;
			((Vector3)(ref val2))..ctor(Mathf.Sin(num2 * swimSpeed.x) * swimScale.x, Mathf.Cos(num2 * swimSpeed.y) * swimScale.y, Mathf.Sin(num2 * swimSpeed.z) * swimScale.z);
			val2 = ((Component)this).transform.InverseTransformDirection(val2);
			position += val2 * appliedSwimScale;
		}
		rotation = Quaternion.LookRotation(normalized) * Quaternion.Euler(Mathf.Cos(Time.time * swimSpeed.y) * appliedSwimRotation, 0f, Mathf.Sin(Time.time * swimSpeed.x) * appliedSwimRotation);
		Vector3 val3 = position;
		float height = TerrainMeta.HeightMap.GetHeight(val3 + ((Component)this).transform.forward * 30f);
		float height2 = TerrainMeta.HeightMap.GetHeight(val3);
		float num3 = Mathf.Max(height, height2);
		float num4 = Mathf.Max(desiredAltitude, num3 + altitudeAboveTerrain);
		val3.y = Mathf.Lerp(((Component)this).transform.position.y, num4, Time.fixedDeltaTime * 0.5f);
		position = val3;
		((Component)this).transform.hasChanged = true;
		if (num >= 1f)
		{
			Kill();
		}
		((Component)this).transform.SetPositionAndRotation(position, rotation);
	}

	[ServerVar]
	public static void drop(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Debug.Log((object)"Santa Inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/misc/xmas/sleigh/santasleigh.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<SantaSleigh>().InitDropPosition(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f));
				baseEntity.Spawn();
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using VLB;

public class SearchLight : IOEntity
{
	public static class SearchLightFlags
	{
		public const Flags PlayerUsing = Flags.Reserved5;
	}

	public GameObject pitchObject;

	public GameObject yawObject;

	public GameObject eyePoint;

	public SoundPlayer turnLoop;

	public bool needsBuildingPrivilegeToUse = true;

	[SerializeField]
	private GameObject lightParent;

	[SerializeField]
	private Light[] lights;

	[SerializeField]
	private float[] initialLightIntensity;

	[SerializeField]
	private VolumetricLightBeam vlb;

	[SerializeField]
	private GameObject flare;

	[SerializeField]
	private SoundPlayer humLoopSound;

	[SerializeField]
	private SoundPlayer turnOffSound;

	[SerializeField]
	private SoundPlayer turnOnSound;

	[SerializeField]
	private AnimationCurve lightLerpCurve;

	public Vector3 aimDir = Vector3.zero;

	public BasePlayer mountedPlayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SearchLight.OnRpcMessage", 0);
		try
		{
			if (rpc == 3611615802u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_UseLight "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_UseLight", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3611615802u, "RPC_UseLight", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_UseLight(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_UseLight");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		aimDir = Vector3.zero;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && !old.HasFlag(Flags.Reserved8) && next.HasFlag(Flags.Reserved8) && IsFlickering())
		{
			Hurt(25f);
		}
	}

	public override int ConsumptionAmount()
	{
		return 10;
	}

	public void Update()
	{
		if (base.isServer && IsMounted())
		{
			MountedUpdate();
		}
	}

	public void PlayerEnter(BasePlayer player)
	{
		if (!IsMounted() || !((Object)(object)player != (Object)(object)mountedPlayer))
		{
			PlayerExit();
			if ((Object)(object)player != (Object)null)
			{
				mountedPlayer = player;
				SetFlag(Flags.Reserved5, b: true);
			}
		}
	}

	public void PlayerExit()
	{
		if (Object.op_Implicit((Object)(object)mountedPlayer))
		{
			mountedPlayer = null;
		}
		SetFlag(Flags.Reserved5, b: false);
	}

	public void MountedUpdate()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)mountedPlayer == (Object)null || mountedPlayer.IsSleeping() || !mountedPlayer.IsAlive() || mountedPlayer.IsWounded() || Vector3.Distance(((Component)mountedPlayer).transform.position, ((Component)this).transform.position) > 2f)
		{
			PlayerExit();
			return;
		}
		Vector3 targetAimpoint = eyePoint.transform.position + mountedPlayer.eyes.BodyForward() * 100f;
		SetTargetAimpoint(targetAimpoint);
		SendNetworkUpdate();
	}

	public void SetTargetAimpoint(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = worldPos - eyePoint.transform.position;
		aimDir = ((Vector3)(ref val)).normalized;
	}

	public bool IsMounted()
	{
		return (Object)(object)mountedPlayer != (Object)null;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_UseLight(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool flag = msg.read.Bit();
		if ((!flag || !IsMounted()) && (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))
		{
			if (flag)
			{
				PlayerEnter(player);
			}
			else
			{
				PlayerExit();
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		SetFlag(Flags.On, b: false);
		base.OnDied(info);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.autoturret = Pool.Get<AutoTurret>();
		info.msg.autoturret.aimDir = aimDir;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.autoturret != null)
		{
			aimDir = info.msg.autoturret.aimDir;
		}
	}
}


public static class SearchLightFlags
{
	public const Flags PlayerUsing = Flags.Reserved5;
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SeismicSensor : IOEntity
{
	public static int MinRange = 1;

	public static int MaxRange = 30;

	public int range = 30;

	public GameObjectRef sensorPanelPrefab;

	private int vibrationLevel;

	private const int holdTime = 3;

	private static readonly BaseEntity[] resultBuffer = new BaseEntity[128];

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SeismicSensor.OnRpcMessage", 0);
		try
		{
			if (rpc == 128851379 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetRange "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetRange", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(128851379u, "RPC_SetRange", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(128851379u, "RPC_SetRange", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_SetRange(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_SetRange");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void SetVibrationLevel(int value)
	{
		float num = value;
		if (num <= 0f)
		{
			SetOff();
			return;
		}
		if (num > (float)vibrationLevel)
		{
			vibrationLevel = Mathf.RoundToInt(num);
			SetFlag(Flags.On, b: true);
			MarkDirty();
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)SetOff))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SetOff);
		}
		((FacepunchBehaviour)this).Invoke((Action)SetOff, 3f);
	}

	private void SetOff()
	{
		if (vibrationLevel != 0)
		{
			vibrationLevel = 0;
			SetFlag(Flags.On, b: false);
			MarkDirty();
		}
	}

	public void SetRange(int value)
	{
		value = Mathf.Clamp(value, MinRange, MaxRange);
		range = value;
		SendNetworkUpdate();
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void RPC_SetRange(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && player.CanBuild())
		{
			int num = msg.read.Int32();
			SetRange(num);
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputAmount == 0)
		{
			ResetIOState();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsPowered())
		{
			return 0;
		}
		return vibrationLevel;
	}

	public override void ResetIOState()
	{
		vibrationLevel = 0;
		SetFlag(Flags.On, b: false);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericInt1 = range;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			range = info.msg.ioEntity.genericInt1;
		}
	}

	public static void Notify(Vector3 position, int value)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (value == 0)
		{
			return;
		}
		int inSphereFast = Query.Server.GetInSphereFast(position, MaxRange, resultBuffer, FilterOutSensors);
		for (int i = 0; i < inSphereFast; i++)
		{
			SeismicSensor seismicSensor = resultBuffer[i] as SeismicSensor;
			Vector3 position2 = ((Component)seismicSensor).transform.position;
			Vector3 val = position - position2;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			float num = (float)seismicSensor.range + 0.5f;
			if (sqrMagnitude < num * num)
			{
				seismicSensor.SetVibrationLevel(value);
			}
		}
	}

	private static bool FilterOutSensors(BaseEntity entity)
	{
		SeismicSensor seismicSensor = entity as SeismicSensor;
		if ((Object)(object)seismicSensor != (Object)null && seismicSensor.IsValidEntityReference())
		{
			return seismicSensor.HasFlag(Flags.Reserved8);
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class Shield : HeldEntity
{
	public const Flags Blocking = Flags.Reserved6;

	public float DeployDelay = 1f;

	public ProtectionProperties Protection;

	[Range(0f, 1f)]
	public float DamageMitigationFactor;

	public Collider ShieldCollider;

	public float MaxBlockTime = 4f;

	public float MinBlockTime = 1f;

	public GameObjectRef MeleeLocalPlayerImpactFxPrefab;

	public GameObjectRef RangedLocalPlayerImpactFxPrefab;

	[ReplicatedVar]
	public static bool InfiniteShieldBlock = false;

	private Action shieldBlockTick;

	private bool serverWantsBlock;

	private static Vector3 MaximumLocalPosition = new Vector3(0.39f, 1.62f, 0.41f);

	private static Vector3 MinimumLocalPosition = new Vector3(-0.66f, 0.66f, -0.44f);

	private static Vector3 MaximumLocalRotation = new Vector3(360f, 360f, 360f);

	private static Vector3 MinimumLocalRotation = new Vector3(2.5f, 2.14f, 0.04f);

	private TimeSince serverSideShieldBlockStarted;

	private float serverSideBlockPower;

	private TimeSince lastLocalPlayerUpdateTick;

	private HeldEntity tickingHeldEntity;

	public override bool IsShield => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Shield.OnRpcMessage", 0);
		try
		{
			if (rpc == 2238556937u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerToggleBlock "));
				}
				TimeWarning val2 = TimeWarning.New("ServerToggleBlock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2238556937u, "ServerToggleBlock", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2238556937u, "ServerToggleBlock", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerToggleBlock(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerToggleBlock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsBlocking()
	{
		return HasFlag(Flags.Reserved6);
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer)
		{
			ServerSideAttack(info);
		}
	}

	public bool RaycastAgainstColliders(Ray r, float maxDistance)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if ((Object)(object)ShieldCollider != (Object)null)
		{
			return ShieldCollider.Raycast(r, ref val, maxDistance);
		}
		return false;
	}

	public bool SphereCastAgainstColliders(Vector3 center, float radius)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Distance(ClosestPoint(center), center) <= radius;
	}

	public string GetHitMaterialString()
	{
		return ShieldCollider.sharedMaterial.GetName();
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(10uL)]
	private void ServerToggleBlock(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		serverWantsBlock = flag;
		if (shieldBlockTick == null)
		{
			shieldBlockTick = ShieldBlockTick;
		}
		if (!((FacepunchBehaviour)this).IsInvoking(shieldBlockTick))
		{
			((FacepunchBehaviour)this).InvokeRepeating(shieldBlockTick, 0f, 0f);
		}
	}

	private void ServerSideAttack(HitInfo info)
	{
		Item item = GetItem();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (item != null)
		{
			Protection.Scale(info.damageTypes);
			info.HitBone = 0u;
			float num = info.damageTypes.Total();
			info.damageTypes.ScaleAll(Mathf.Clamp01(1f - DamageMitigationFactor));
			float amount = num - info.damageTypes.Total();
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				ownerPlayer.OnAttacked(info);
			}
			item.LoseCondition(amount);
		}
		bool arg = (Object)(object)info.Weapon != (Object)null && info.Weapon is BaseMelee;
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			ClientRPC(RpcTarget.NetworkGroup("ClientShieldHit", ownerPlayer), arg, ((Object)(object)info.InitiatorPlayer != (Object)null) ? info.InitiatorPlayer.userID.Get() : 0);
		}
	}

	private void DestroyShield()
	{
		List<BaseEntity> list = Pool.GetList<BaseEntity>();
		foreach (BaseEntity child in children)
		{
			list.Add(child);
		}
		foreach (BaseEntity item in list)
		{
			item.SetParent(null, worldPositionStays: true);
		}
		Pool.FreeList<BaseEntity>(ref list);
	}

	public override float BoundsPadding()
	{
		if ((Object)(object)GetOwnerPlayer() != (Object)null && GetOwnerPlayer().IsBot)
		{
			return 3f;
		}
		return 0.75f;
	}

	public override void SetHeld(bool bHeld)
	{
		base.SetHeld(bHeld);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			ownerPlayer.modelState.blocking = false;
		}
	}

	private void ShieldBlockTick()
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (IsDisabled() || (Object)(object)ownerPlayer == (Object)null)
		{
			return;
		}
		HeldEntity heldEntity = ownerPlayer.GetHeldEntity();
		if ((Object)(object)heldEntity != (Object)(object)tickingHeldEntity)
		{
			tickingHeldEntity = heldEntity;
			serverSideBlockPower = 0f;
		}
		if (serverWantsBlock)
		{
			if (!IsBlocking() && serverSideBlockPower < MaxBlockTime - MinBlockTime)
			{
				serverSideShieldBlockStarted = TimeSince.op_Implicit(0f);
				SetFlag(Flags.Reserved6, b: true);
			}
		}
		else if (IsBlocking() && TimeSince.op_Implicit(serverSideShieldBlockStarted) > MinBlockTime)
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		ownerPlayer.modelState.blocking = IsBlocking();
		serverSideBlockPower = Mathf.MoveTowards(serverSideBlockPower, IsBlocking() ? MaxBlockTime : 0f, Time.deltaTime);
		if (TimeSince.op_Implicit(lastLocalPlayerUpdateTick) > 0.5f)
		{
			ClientRPC(RpcTarget.Player("ClientUpdateShieldPowerTime", ownerPlayer), serverSideBlockPower / MaxBlockTime);
			lastLocalPlayerUpdateTick = TimeSince.op_Implicit(0f);
		}
		if (HasFlag(Flags.Reserved6) && serverSideBlockPower >= MaxBlockTime && !InfiniteShieldBlock)
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		if (!IsBlocking() && serverSideBlockPower <= 0f)
		{
			((FacepunchBehaviour)this).CancelInvoke(shieldBlockTick);
		}
	}

	public override void ServerTick(BasePlayer byPlayer)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerTick(byPlayer);
		if (!IsDisabled() && byPlayer.modelState != null)
		{
			Vector3 val = byPlayer.modelState.localShieldPos;
			if (Vector3Ex.IsNaNOrInfinity(val))
			{
				val = Vector3.Lerp(MinimumLocalPosition, MaximumLocalPosition, 0.5f);
			}
			Vector3 val2 = byPlayer.modelState.localShieldRot;
			if (Vector3Ex.IsNaNOrInfinity(val2))
			{
				val2 = Vector3.Lerp(MinimumLocalRotation, MaximumLocalRotation, 0.5f);
			}
			val.x = Mathf.Clamp(val.x, MinimumLocalPosition.x, MaximumLocalPosition.x);
			val.y = Mathf.Clamp(val.y, MinimumLocalPosition.y, MaximumLocalPosition.y);
			val.z = Mathf.Clamp(val.z, MinimumLocalPosition.z, MaximumLocalPosition.z);
			val2.x = Mathf.Clamp(val2.x, MinimumLocalRotation.x, MaximumLocalRotation.x);
			val2.y = Mathf.Clamp(val2.y, MinimumLocalRotation.y, MaximumLocalRotation.y);
			val2.z = Mathf.Clamp(val2.z, MinimumLocalRotation.z, MaximumLocalRotation.z);
			((Component)this).transform.SetLocalPositionAndRotation(val, Quaternion.Euler(val2));
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer)
		{
			return;
		}
		if (old.HasFlag(Flags.Broken) != next.HasFlag(Flags.Broken))
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if (!((Object)(object)ownerPlayer != (Object)null))
			{
				return;
			}
			HeldEntity heldEntity = ownerPlayer.GetHeldEntity();
			if ((Object)(object)heldEntity != (Object)null)
			{
				heldEntity.UpdateShieldState(bHeld: true);
			}
			if (next.HasFlag(Flags.Broken))
			{
				DestroyShield();
				if ((Object)(object)heldEntity != (Object)null)
				{
					heldEntity.UpdateShieldState(bHeld: false);
				}
			}
		}
		else if (old.HasFlag(Flags.Reserved4) && !next.HasFlag(Flags.Reserved4))
		{
			SetFlag(Flags.Reserved6, b: false);
			serverWantsBlock = false;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class ShopFront : StorageContainer
{
	public static class ShopFrontFlags
	{
		public const Flags VendorAccepted = Flags.Reserved1;

		public const Flags CustomerAccepted = Flags.Reserved2;

		public const Flags Exchanging = Flags.Reserved3;
	}

	public float maxUseAngle = 27f;

	public BasePlayer vendorPlayer;

	public BasePlayer customerPlayer;

	public GameObjectRef transactionCompleteEffect;

	[NonSerialized]
	public ItemContainer customerInventory;

	private bool swappingItems;

	private float AngleDotProduct => 1f - maxUseAngle / 90f;

	public ItemContainer vendorInventory => base.inventory;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ShopFront.OnRpcMessage", 0);
		try
		{
			if (rpc == 1159607245 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AcceptClicked "));
				}
				TimeWarning val2 = TimeWarning.New("AcceptClicked", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1159607245u, "AcceptClicked", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AcceptClicked(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AcceptClicked");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3168107540u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CancelClicked "));
				}
				TimeWarning val2 = TimeWarning.New("CancelClicked", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3168107540u, "CancelClicked", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							CancelClicked(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in CancelClicked");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool TradeLocked()
	{
		return false;
	}

	public bool IsTradingPlayer(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			if (!IsPlayerCustomer(player))
			{
				return IsPlayerVendor(player);
			}
			return true;
		}
		return false;
	}

	public bool IsPlayerCustomer(BasePlayer player)
	{
		return (Object)(object)player == (Object)(object)customerPlayer;
	}

	public bool IsPlayerVendor(BasePlayer player)
	{
		return (Object)(object)player == (Object)(object)vendorPlayer;
	}

	public bool PlayerInVendorPos(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 right = ((Component)this).transform.right;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(right, ((Vector3)(ref val)).normalized) <= 0f - AngleDotProduct;
	}

	public bool PlayerInCustomerPos(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 right = ((Component)this).transform.right;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(right, ((Vector3)(ref val)).normalized) >= AngleDotProduct;
	}

	public bool LootEligable(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (PlayerInVendorPos(player) && (Object)(object)vendorPlayer == (Object)null)
		{
			return true;
		}
		if (PlayerInCustomerPos(player) && (Object)(object)customerPlayer == (Object)null)
		{
			return true;
		}
		return false;
	}

	public void ResetTrade()
	{
		SetFlag(Flags.Reserved1, b: false);
		SetFlag(Flags.Reserved2, b: false);
		SetFlag(Flags.Reserved3, b: false);
		vendorInventory.SetLocked(isLocked: false);
		customerInventory.SetLocked(isLocked: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)CompleteTrade);
	}

	public void CompleteTrade()
	{
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)vendorPlayer != (Object)null && (Object)(object)customerPlayer != (Object)null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", (object)this) != null)
			{
				return;
			}
			try
			{
				swappingItems = true;
				for (int num = vendorInventory.capacity - 1; num >= 0; num--)
				{
					Item slot = vendorInventory.GetSlot(num);
					Item slot2 = customerInventory.GetSlot(num);
					if (Object.op_Implicit((Object)(object)customerPlayer) && slot != null)
					{
						customerPlayer.GiveItem(slot);
					}
					if (Object.op_Implicit((Object)(object)vendorPlayer) && slot2 != null)
					{
						vendorPlayer.GiveItem(slot2);
					}
				}
			}
			finally
			{
				swappingItems = false;
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AcceptClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && !((Object)(object)vendorPlayer == (Object)null) && !((Object)(object)customerPlayer == (Object)null) && Interface.CallHook("OnShopAcceptClick", (object)this, (object)msg.player) == null)
		{
			if (IsPlayerVendor(msg.player))
			{
				SetFlag(Flags.Reserved1, b: true);
				vendorInventory.SetLocked(isLocked: true);
			}
			else if (IsPlayerCustomer(msg.player))
			{
				SetFlag(Flags.Reserved2, b: true);
				customerInventory.SetLocked(isLocked: true);
			}
			if (HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
			{
				SetFlag(Flags.Reserved3, b: true);
				((FacepunchBehaviour)this).Invoke((Action)CompleteTrade, 2f);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void CancelClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && Interface.CallHook("OnShopCancelClick", (object)this, (object)msg.player) == null)
		{
			Object.op_Implicit((Object)(object)vendorPlayer);
			Object.op_Implicit((Object)(object)customerPlayer);
			ResetTrade();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = vendorInventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptVendorItem));
		if (customerInventory == null)
		{
			customerInventory = Pool.Get<ItemContainer>();
			customerInventory.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
			customerInventory.SetOnlyAllowedItem(allowedItem);
			customerInventory.entityOwner = this;
			customerInventory.maxStackSize = maxStackSize;
			customerInventory.ServerInitialize(null, inventorySlots);
			customerInventory.GiveUID();
			customerInventory.onDirty += OnInventoryDirty;
			customerInventory.onItemAddedRemoved = OnItemAddedOrRemoved;
			ItemContainer itemContainer2 = customerInventory;
			itemContainer2.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer2.canAcceptItem, new Func<Item, int, bool>(CanAcceptCustomerItem));
			OnInventoryFirstCreated(customerInventory);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Pool.Free<ItemContainer>(ref customerInventory);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		ResetTrade();
	}

	private bool CanAcceptVendorItem(Item item, int targetSlot)
	{
		if (swappingItems || ((Object)(object)vendorPlayer != (Object)null && (Object)(object)item.GetOwnerPlayer() == (Object)(object)vendorPlayer) || vendorInventory.itemList.Contains(item))
		{
			return true;
		}
		return false;
	}

	private bool CanAcceptCustomerItem(Item item, int targetSlot)
	{
		if (swappingItems || ((Object)(object)customerPlayer != (Object)null && (Object)(object)item.GetOwnerPlayer() == (Object)(object)customerPlayer) || customerInventory.itemList.Contains(item))
		{
			return true;
		}
		return false;
	}

	public override bool CanMoveFrom(BasePlayer player, Item item)
	{
		if (TradeLocked())
		{
			return false;
		}
		if (IsTradingPlayer(player))
		{
			if (IsPlayerCustomer(player) && customerInventory.itemList.Contains(item) && !customerInventory.IsLocked())
			{
				return true;
			}
			if (IsPlayerVendor(player) && vendorInventory.itemList.Contains(item) && !vendorInventory.IsLocked())
			{
				return true;
			}
		}
		return false;
	}

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		if (base.CanOpenLootPanel(player, panelName))
		{
			return LootEligable(player);
		}
		return false;
	}

	public void ReturnPlayerItems(BasePlayer player)
	{
		if (!IsTradingPlayer(player))
		{
			return;
		}
		ItemContainer itemContainer = null;
		if (IsPlayerVendor(player))
		{
			itemContainer = vendorInventory;
		}
		else if (IsPlayerCustomer(player))
		{
			itemContainer = customerInventory;
		}
		if (itemContainer != null)
		{
			for (int num = itemContainer.itemList.Count - 1; num >= 0; num--)
			{
				Item item = itemContainer.itemList[num];
				player.GiveItem(item);
			}
		}
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		if (IsTradingPlayer(player))
		{
			ReturnPlayerItems(player);
			if ((Object)(object)player == (Object)(object)vendorPlayer)
			{
				vendorPlayer = null;
			}
			if ((Object)(object)player == (Object)(object)customerPlayer)
			{
				customerPlayer = null;
			}
			UpdatePlayers();
			ResetTrade();
			base.PlayerStoppedLooting(player);
		}
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		bool flag = base.PlayerOpenLoot(player, panelToOpen);
		if (flag)
		{
			player.inventory.loot.AddContainer(customerInventory);
			player.inventory.loot.SendImmediate();
		}
		if (PlayerInVendorPos(player) && (Object)(object)vendorPlayer == (Object)null)
		{
			vendorPlayer = player;
		}
		else
		{
			if (!PlayerInCustomerPos(player) || !((Object)(object)customerPlayer == (Object)null))
			{
				return false;
			}
			customerPlayer = player;
		}
		ResetTrade();
		UpdatePlayers();
		return flag;
	}

	public void UpdatePlayers()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_ReceivePlayers"), (NetworkableId)(((Object)(object)vendorPlayer == (Object)null) ? default(NetworkableId) : vendorPlayer.net.ID), (NetworkableId)(((Object)(object)customerPlayer == (Object)null) ? default(NetworkableId) : customerPlayer.net.ID));
	}

	public override void GetAllInventories(List<ItemContainer> list)
	{
		base.GetAllInventories(list);
		list.Add(customerInventory);
	}
}


public static class ShopFrontFlags
{
	public const Flags VendorAccepted = Flags.Reserved1;

	public const Flags CustomerAccepted = Flags.Reserved2;

	public const Flags Exchanging = Flags.Reserved3;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SiegeTower : BaseSiegeWeapon
{
	[SerializeField]
	[Header("Siege Tower")]
	private SiegeTowerDoor drawBridgePrefab;

	[SerializeField]
	private SiegeTowerDoor drawBridge2Prefab;

	[SerializeField]
	private SiegeTowerDoor drawBridge3Prefab;

	private EntityRef<SiegeTowerDoor> drawBridgeRef;

	private EntityRef<SiegeTowerDoor> drawBridge2Ref;

	private EntityRef<SiegeTowerDoor> drawBridge3Ref;

	private const Flags Flag_IsTipping = Flags.Reserved18;

	private const Flags Flag_IsTipped = Flags.Reserved16;

	[Header("Raise Command")]
	public float torqueForce = 10f;

	public float uprightAngle = 10f;

	private bool shouldRaise;

	private float raiseTimer;

	public override float DriveWheelVelocity { get; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SiegeTower.OnRpcMessage", 0);
		try
		{
			if (rpc == 886085783 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_RequestRaise "));
				}
				TimeWarning val2 = TimeWarning.New("SV_RequestRaise", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(886085783u, "SV_RequestRaise", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_RequestRaise(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_RequestRaise");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.siegeTower != null && base.isServer)
		{
			drawBridgeRef.uid = info.msg.siegeTower.drawBridgeID;
			drawBridge2Ref.uid = info.msg.siegeTower.drawBridge2ID;
			drawBridge3Ref.uid = info.msg.siegeTower.drawBridge3ID;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.siegeTower = Pool.Get<SiegeTower>();
		info.msg.siegeTower.drawBridgeID = drawBridgeRef.uid;
		info.msg.siegeTower.drawBridge2ID = drawBridge2Ref.uid;
		info.msg.siegeTower.drawBridge3ID = drawBridge3Ref.uid;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && !Application.isLoadingSave)
		{
			if (child.prefabID == drawBridgePrefab.GetEntity().prefabID)
			{
				SiegeTowerDoor siegeTowerDoor = (SiegeTowerDoor)child;
				drawBridgeRef.Set(siegeTowerDoor);
				SetupDoor(siegeTowerDoor);
			}
			if (child.prefabID == drawBridge2Prefab.GetEntity().prefabID)
			{
				SiegeTowerDoor siegeTowerDoor2 = (SiegeTowerDoor)child;
				drawBridge2Ref.Set(siegeTowerDoor2);
				SetupDoor(siegeTowerDoor2);
			}
			if (child.prefabID == drawBridge3Prefab.GetEntity().prefabID)
			{
				SiegeTowerDoor siegeTowerDoor3 = (SiegeTowerDoor)child;
				drawBridge3Ref.Set(siegeTowerDoor3);
				SetupDoor(siegeTowerDoor3);
			}
			UpdateDoorHp();
		}
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (HasFlag(Flags.Reserved16))
		{
			return false;
		}
		if (base.isServer)
		{
			BaseEntity baseEntity = pusher.parentEntity.Get(serverside: true);
			if (baseEntity.IsValid())
			{
				BaseEntity baseEntity2 = baseEntity.parentEntity.Get(serverside: true);
				if (baseEntity2.IsValid() && (Object)(object)baseEntity2 == (Object)(object)this)
				{
					return false;
				}
			}
			if (!IsYValid(pusher))
			{
				return false;
			}
		}
		return true;
	}

	private bool IsYValid(BasePlayer pusher)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return !(Mathf.Abs(((Component)this).transform.position.y - ((Component)pusher).transform.position.y) > 2f);
	}

	protected override void CreateEngineController()
	{
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool ForceDeployableSetParent()
	{
		return true;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		DisablePhysics();
		((FacepunchBehaviour)this).Invoke((Action)base.EnablePhysics, 1f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckIfTipped, 0f, 2f);
	}

	public void GetDoors(List<SiegeTowerDoor> doors)
	{
		SiegeTowerDoor siegeTowerDoor = drawBridgeRef.Get(base.isServer);
		if (siegeTowerDoor.IsValid())
		{
			doors.Add(siegeTowerDoor);
		}
		siegeTowerDoor = drawBridge2Ref.Get(base.isServer);
		if (siegeTowerDoor.IsValid())
		{
			doors.Add(siegeTowerDoor);
		}
		siegeTowerDoor = drawBridge3Ref.Get(base.isServer);
		if (siegeTowerDoor.IsValid())
		{
			doors.Add(siegeTowerDoor);
		}
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			if ((Object)(object)item != (Object)null)
			{
				item.ProtectedHurt(info);
			}
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			if (!item.IsDead())
			{
				item.Die();
			}
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateDoorHp();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateDoorHp();
	}

	private void UpdateDoorHp()
	{
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			item.SetMaxHealth(MaxHealth());
			item.SetHealth(base.health);
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	public void ProtectedSetHealth(float health)
	{
		SetHealth(health);
		UpdateDoorHp();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			SetupDoor(item);
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
		UpdateDoorHp();
	}

	private void SetupDoor(SiegeTowerDoor door)
	{
		door.SetupDoor(this);
		door.SetMaxHealth(MaxHealth());
		door.SetHealth(MaxHealth());
		door.OwnerID = base.OwnerID;
		door.startHealth = MaxHealth();
	}

	private void CheckIfTipped()
	{
		bool flag = IsFlipping();
		if (HasFlag(Flags.Reserved18) != flag)
		{
			SetFlag(Flags.Reserved18, flag);
		}
		bool flag2 = IsFlipped();
		if (HasFlag(Flags.Reserved16) != flag2)
		{
			SetFlag(Flags.Reserved16, flag2);
		}
	}

	public override bool CheckTowingAllowed()
	{
		if (!base.CheckTowingAllowed())
		{
			return false;
		}
		if (HasFlag(Flags.Reserved18) || HasFlag(Flags.Reserved16))
		{
			return false;
		}
		return true;
	}

	private void FixedUpdate()
	{
		if (!base.isClient && !rigidBody.isKinematic)
		{
			UprightIfRaise();
		}
	}

	private void UprightIfRaise()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (shouldRaise)
		{
			if (Mathf.Abs(((Component)this).transform.up.y) > uprightAngle || raiseTimer > 5f)
			{
				rigidBody.angularDrag = 0.95f;
			}
			else if (Mathf.Abs(((Component)this).transform.up.y) > 1f || raiseTimer > 15f)
			{
				shouldRaise = false;
				rigidBody.angularDrag = 0.05f;
			}
			Vector3 angularVelocity = rigidBody.angularVelocity;
			Vector3 val = Quaternion.AngleAxis(((Vector3)(ref angularVelocity)).magnitude * 57.29578f * 100f / 350f, rigidBody.angularVelocity) * ((Component)this).transform.up;
			Vector3 up = Vector3.up;
			Vector3 val2 = Vector3.Cross(val, up);
			float num = Vector3.Dot(((Vector3)(ref val)).normalized, up);
			num = Mathf.Clamp01((num + 1f) / 2f);
			Vector3 val3 = val2 * (1f - num) * 350f * 350f;
			rigidBody.AddTorque(val3);
			raiseTimer += Time.fixedDeltaTime;
		}
	}

	private void AlignRotationToZero()
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null || !HasFlag(Flags.Reserved16))
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)AlignRotationToZero))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)AlignRotationToZero);
			}
			if ((Object)(object)rigidBody != (Object)null && !HasFlag(Flags.Reserved16))
			{
				rigidBody.angularVelocity = Vector3.zero;
			}
		}
	}

	public override void OnEngineStartFailed()
	{
	}

	public override bool MeetsEngineRequirements()
	{
		return false;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SV_RequestRaise(RPCMessage msg)
	{
		if (HasFlag(Flags.Reserved16) && !((FacepunchBehaviour)this).IsInvoking((Action)AlignRotationToZero))
		{
			if (rigidBody.IsSleeping())
			{
				rigidBody.WakeUp();
			}
			raiseTimer = 0f;
			shouldRaise = true;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Signage : IOEntity, ILOD, ISignage, IUGCBrowserEntity
{
	public ItemDefinition RequiredHeldEntity;

	private List<ulong> editHistory = new List<ulong>();

	private const float TextureRequestTimeout = 15f;

	public GameObjectRef changeTextDialog;

	public MeshPaintableSource[] paintableSources;

	[NonSerialized]
	public uint[] textureIDs;

	public NetworkableId NetworkID => net.ID;

	public FileStorage.Type FileType => FileStorage.Type.png;

	public UGCType ContentType => UGCType.ImagePng;

	public List<ulong> EditingHistory => editHistory;

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public uint[] GetContentCRCs => GetTextureCRCs();

	public override bool ShouldTransferAssociatedFiles => true;

	public Vector2i TextureSize
	{
		get
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			if (paintableSources == null || paintableSources.Length == 0)
			{
				return Vector2i.zero;
			}
			MeshPaintableSource meshPaintableSource = paintableSources[0];
			return new Vector2i(meshPaintableSource.texWidth, meshPaintableSource.texHeight);
		}
	}

	public int TextureCount
	{
		get
		{
			MeshPaintableSource[] array = paintableSources;
			if (array == null)
			{
				return 0;
			}
			return array.Length;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Signage.OnRpcMessage", 0);
		try
		{
			if (rpc == 1455609404 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - LockSign "));
				}
				TimeWarning val2 = TimeWarning.New("LockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455609404u, "LockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							LockSign(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in LockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4149904254u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UnLockSign "));
				}
				TimeWarning val2 = TimeWarning.New("UnLockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4149904254u, "UnLockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							UnLockSign(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UnLockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1255380462 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateSign "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1255380462u, "UpdateSign", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1255380462u, "UpdateSign", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							UpdateSign(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in UpdateSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return true;
	}

	public bool CanUnlockSign(BasePlayer player)
	{
		if (!IsLocked())
		{
			return false;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	public bool CanLockSign(BasePlayer player)
	{
		if (IsLocked())
		{
			return false;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	public override void Load(LoadInfo info)
	{
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		EnsureInitialized();
		bool flag = false;
		if (info.msg.sign != null)
		{
			uint num = textureIDs[0];
			if (info.msg.sign.imageIds != null && info.msg.sign.imageIds.Count > 0)
			{
				int num2 = Mathf.Min(info.msg.sign.imageIds.Count, textureIDs.Length);
				for (int i = 0; i < num2; i++)
				{
					uint num3 = info.msg.sign.imageIds[i];
					bool flag2 = num3 != textureIDs[i];
					flag = flag || flag2;
					textureIDs[i] = num3;
				}
			}
			else
			{
				flag = num != info.msg.sign.imageid;
				textureIDs[0] = info.msg.sign.imageid;
			}
		}
		if (!base.isServer)
		{
			return;
		}
		bool flag3 = false;
		for (int j = 0; j < paintableSources.Length; j++)
		{
			uint num4 = textureIDs[j];
			if (num4 != 0)
			{
				byte[] array = FileStorage.server.Get(num4, FileStorage.Type.png, net.ID, (uint)j);
				if (array == null)
				{
					Log($"Frame {j} (id={num4}) doesn't exist, clearing");
					textureIDs[j] = 0u;
				}
				flag3 = flag3 || array != null;
			}
		}
		if (!flag3)
		{
			SetFlag(Flags.Locked, b: false);
		}
		if (info.msg.sign == null)
		{
			return;
		}
		if (info.msg.sign.editHistory != null)
		{
			if (editHistory == null)
			{
				editHistory = Pool.Get<List<ulong>>();
			}
			editHistory.Clear();
			{
				foreach (ulong item in info.msg.sign.editHistory)
				{
					editHistory.Add(item);
				}
				return;
			}
		}
		if (editHistory != null)
		{
			Pool.FreeUnmanaged<ulong>(ref editHistory);
		}
	}

	private bool HeldEntityCheck(BasePlayer player)
	{
		if ((Object)(object)RequiredHeldEntity != (Object)null && (!Object.op_Implicit((Object)(object)player.GetHeldEntity()) || (Object)(object)player.GetHeldEntity().GetItem().info != (Object)(object)RequiredHeldEntity))
		{
			return false;
		}
		return true;
	}

	public uint[] GetTextureCRCs()
	{
		return textureIDs;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", (object)this, (object)msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void UnLockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUnlockSign(msg.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		EnsureInitialized();
		List<uint> list = Pool.Get<List<uint>>();
		uint[] array = textureIDs;
		foreach (uint item in array)
		{
			list.Add(item);
		}
		info.msg.sign = Pool.Get<Sign>();
		info.msg.sign.imageid = 0u;
		info.msg.sign.imageIds = list;
		if (editHistory == null || editHistory.Count <= 0 || !info.forDisk)
		{
			return;
		}
		info.msg.sign.editHistory = Pool.Get<List<ulong>>();
		foreach (ulong item2 in editHistory)
		{
			info.msg.sign.editHistory.Add(item2);
		}
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (net != null)
		{
			FileStorage.server.RemoveAllByEntity(net.ID);
		}
		if (textureIDs != null)
		{
			Array.Clear(textureIDs, 0, textureIDs.Length);
		}
		base.OnDied(info);
	}

	public override void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
	{
		base.OnPickedUpPreItemMove(createdItem, player);
		bool flag = false;
		uint[] array = textureIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != 0)
			{
				flag = true;
				break;
			}
		}
		ItemModSign itemModSign = default(ItemModSign);
		if (flag && ((Component)createdItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			itemModSign.OnSignPickedUp(this, this, createdItem);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		ItemModSign itemModSign = default(ItemModSign);
		if (((Component)fromItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			SignContent associatedEntity = ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(fromItem);
			if ((Object)(object)associatedEntity != (Object)null)
			{
				associatedEntity.CopyInfoToSign(this, this);
			}
		}
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public void SetTextureCRCs(uint[] crcs)
	{
		textureIDs = new uint[crcs.Length];
		crcs.CopyTo(textureIDs, 0);
		SendNetworkUpdate();
	}

	public void LogEdit(BasePlayer byPlayer)
	{
		if (!editHistory.Contains(byPlayer.userID))
		{
			editHistory.Insert(0, byPlayer.userID);
			int num = 0;
			while (editHistory.Count > 5 && num < 10)
			{
				editHistory.RemoveAt(5);
				num++;
			}
		}
	}

	public void ClearContent()
	{
		SetTextureCRCs(Array.Empty<uint>());
	}

	public override string Admin_Who()
	{
		if (editHistory == null || editHistory.Count == 0)
		{
			return base.Admin_Who();
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine(base.Admin_Who());
		for (int i = 0; i < editHistory.Count; i++)
		{
			stringBuilder.AppendLine($"Edit {i}: {editHistory[i]}");
		}
		return stringBuilder.ToString();
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override string Categorize()
	{
		return "sign";
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (clientside && paintableSources != null && paintableSources.Length > 1)
		{
			MeshPaintableSource meshPaintableSource = paintableSources[0];
			for (int i = 1; i < paintableSources.Length; i++)
			{
				MeshPaintableSource obj = paintableSources[i];
				obj.texWidth = meshPaintableSource.texWidth;
				obj.texHeight = meshPaintableSource.texHeight;
			}
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(5f)]
	public void UpdateSign(RPCMessage msg)
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			Debug.LogWarning((object)$"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", (object)this, (object)msg.player, (object)num);
	}

	public void EnsureInitialized()
	{
		int num = Mathf.Max(paintableSources.Length, 1);
		if (textureIDs == null || textureIDs.Length != num)
		{
			Array.Resize(ref textureIDs, num);
		}
	}

	[Conditional("SIGN_DEBUG")]
	private static void SignDebugLog(string str)
	{
		Debug.Log((object)str);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SimpleBuildingBlock : StabilityEntity, ISimpleUpgradable, ISprayCallback
{
	public List<ItemDefinition> UpgradeItems;

	public Menu.Option UpgradeMenu;

	private GameObject currentModel;

	private SimpleBuildingBlockModelVariant[] variants;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SimpleBuildingBlock.OnRpcMessage", 0);
		try
		{
			if (rpc == 2824056853u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoSimpleUpgrade "));
				}
				TimeWarning val2 = TimeWarning.New("DoSimpleUpgrade", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2824056853u, "DoSimpleUpgrade", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2824056853u, "DoSimpleUpgrade", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoSimpleUpgrade(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoSimpleUpgrade");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		variants = PrefabAttribute.server.FindAll<SimpleBuildingBlockModelVariant>(prefabID);
	}

	public List<ItemDefinition> GetUpgradeItems()
	{
		return UpgradeItems;
	}

	public bool CanUpgrade(BasePlayer player, ItemDefinition upgradeItem)
	{
		return SimpleUpgrade.CanUpgrade(this, upgradeItem, player);
	}

	public void DoUpgrade(BasePlayer player, ItemDefinition upgradeItem)
	{
		SimpleUpgrade.DoUpgrade(this, player, upgradeItem);
	}

	public Menu.Option GetUpgradeMenuOption()
	{
		return UpgradeMenu;
	}

	public bool UpgradingEnabled()
	{
		if (UpgradeItems != null)
		{
			return UpgradeItems.Count > 0;
		}
		return false;
	}

	public bool CostIsItem()
	{
		return true;
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void DoSimpleUpgrade(RPCMessage msg)
	{
		if (base.SecondsSinceAttacked < 30f)
		{
			msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString("N0"));
			return;
		}
		int num = msg.read.Int32();
		if (num >= 0 && num < UpgradeItems.Count)
		{
			ItemDefinition upgradeItem = UpgradeItems[num];
			if (CanUpgrade(msg.player, upgradeItem))
			{
				DoUpgrade(msg.player, upgradeItem);
			}
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		PopulateVariants();
	}

	private void PopulateVariants()
	{
		if (base.isServer && variants.Any())
		{
			ulong value = net.ID.Value;
			SeedRandom.Wanghash(ref value);
			SeedRandom.Wanghash(ref value);
			SeedRandom.Wanghash(ref value);
			int num = (int)(value % (ulong)variants.Length);
			SetFlag(variants[num].Flag, b: true);
		}
	}

	public void OnReskinned(BasePlayer byPlayer)
	{
		PopulateVariants();
	}

	public void SetVariant(int index)
	{
		int num = index % variants.Length;
		SimpleBuildingBlockModelVariant[] array = variants;
		foreach (SimpleBuildingBlockModelVariant simpleBuildingBlockModelVariant in array)
		{
			SetFlag(simpleBuildingBlockModelVariant.Flag, b: false, recursive: false, networkupdate: false);
		}
		SetFlag(variants[num].Flag, b: true);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if (!base.isServer)
		{
			return;
		}
		SimpleBuildingBlockModelVariant[] array = variants;
		foreach (SimpleBuildingBlockModelVariant simpleBuildingBlockModelVariant in array)
		{
			if (HasFlag(simpleBuildingBlockModelVariant.Flag))
			{
				SetFlag(simpleBuildingBlockModelVariant.Flag, b: false);
			}
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (variants != null)
		{
			RefreshVariant();
		}
	}

	private void RefreshVariant()
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		if (variants == null)
		{
			return;
		}
		base.gameManager.Retire(currentModel);
		SimpleBuildingBlockModelVariant[] array = variants;
		foreach (SimpleBuildingBlockModelVariant simpleBuildingBlockModelVariant in array)
		{
			if (HasFlag(simpleBuildingBlockModelVariant.Flag))
			{
				GameObject val = base.gameManager.CreatePrefab(simpleBuildingBlockModelVariant.prefab.resourcePath, ((Component)this).transform);
				if (Object.op_Implicit((Object)(object)val))
				{
					val.transform.localPosition = simpleBuildingBlockModelVariant.localPosition;
					val.transform.localRotation = simpleBuildingBlockModelVariant.localRotation;
				}
				currentModel = val;
			}
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		base.gameManager.Retire(currentModel);
		currentModel = null;
	}
}


