using System;
using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Rendering;

public class FishShoal : IDisposable
{
	[Serializable]
	public struct FishType
	{
		public Mesh mesh;

		public Material material;

		public int castsPerFrame;

		public int maxCount;

		public float minSpeed;

		public float maxSpeed;

		public float idealDepth;

		public float minTurnSpeed;

		public float maxTurnSpeed;

		public float minScale;

		public float maxScale;
	}

	public struct FishData
	{
		public bool isAlive;

		public float updateTime;

		public float startleTime;

		public float spawnX;

		public float spawnZ;

		public float destinationX;

		public float destinationZ;

		public float directionX;

		public float directionZ;

		public float speed;

		public float scale;
	}

	public struct FishRenderData
	{
		public float3 position;

		public float rotation;

		public float scale;

		public float distance;

		public float seed;
	}

	public struct FishCollisionGatherJob : IJob
	{
		public int layerMask;

		public uint seed;

		public int castCount;

		public int fishCount;

		public NativeArray<RaycastCommand> castCommands;

		public NativeArray<FishData> fishDataArray;

		public NativeArray<FishRenderData> fishRenderDataArray;

		public NativeArray<int> fishCastIndices;

		public void Execute()
		{
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			Random val = default(Random);
			((Random)(ref val))..ctor(seed);
			int length = castCommands.Length;
			for (int i = 0; i < length; i++)
			{
				RaycastCommand val3;
				if (i >= castCount)
				{
					val3 = (castCommands[i] = default(RaycastCommand));
					continue;
				}
				int num = ((Random)(ref val)).NextInt(0, fishCount);
				FishData fishData = fishDataArray[num];
				FishRenderData fishRenderData = fishRenderDataArray[num];
				ref NativeArray<RaycastCommand> reference = ref castCommands;
				int num2 = i;
				val3 = default(RaycastCommand);
				((RaycastCommand)(ref val3)).from = float3.op_Implicit(fishRenderData.position);
				((RaycastCommand)(ref val3)).direction = float3.op_Implicit(new float3(fishData.directionX, 0f, fishData.directionZ));
				((RaycastCommand)(ref val3)).distance = 4f;
				((RaycastCommand)(ref val3)).layerMask = layerMask;
				((RaycastCommand)(ref val3)).maxHits = 1;
				reference[num2] = val3;
				fishCastIndices[i] = num;
			}
		}
	}

	public struct FishCollisionProcessJob : IJob
	{
		public int castCount;

		public NativeArray<FishData> fishDataArray;

		[ReadOnly]
		public NativeArray<RaycastHit> castResults;

		[ReadOnly]
		public NativeArray<int> fishCastIndices;

		[ReadOnly]
		public NativeArray<FishRenderData> fishRenderDataArray;

		public void Execute()
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < castCount; i++)
			{
				RaycastHit val = castResults[i];
				if (((RaycastHit)(ref val)).normal != default(Vector3))
				{
					int num = fishCastIndices[i];
					FishData fishData = fishDataArray[num];
					if (fishData.startleTime <= 0f)
					{
						FishRenderData fishRenderData = fishRenderDataArray[num];
						float2 xz = ((float3)(ref fishRenderData.position)).xz;
						val = castResults[i];
						float x = ((RaycastHit)(ref val)).point.x;
						val = castResults[i];
						float2 val2 = math.normalize(new float2(x, ((RaycastHit)(ref val)).point.z) - xz);
						float2 val3 = xz - val2 * 8f;
						fishData.destinationX = val3.x;
						fishData.destinationZ = val3.y;
						fishData.startleTime = 2f;
						fishData.updateTime = 6f;
						fishDataArray[num] = fishData;
					}
				}
			}
		}
	}

	public struct FishUpdateJob : IJobParallelFor
	{
		[ReadOnly]
		public float3 cameraPosition;

		[ReadOnly]
		public uint seed;

		[ReadOnly]
		public float dt;

		[ReadOnly]
		public float minSpeed;

		[ReadOnly]
		public float maxSpeed;

		[ReadOnly]
		public float minTurnSpeed;

		[ReadOnly]
		public float maxTurnSpeed;

		[ReadOnly]
		public float minDepth;

		[NativeDisableUnsafePtrRestriction]
		public unsafe FishData* fishDataArray;

		[NativeDisableUnsafePtrRestriction]
		public unsafe FishRenderData* fishRenderDataArray;

		public unsafe void Execute(int i)
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_011b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_017c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0181: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_018d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0194: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_0206: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0226: Unknown result type (might be due to invalid IL or missing references)
			//IL_022b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0233: Unknown result type (might be due to invalid IL or missing references)
			//IL_023e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0243: Unknown result type (might be due to invalid IL or missing references)
			//IL_0248: Unknown result type (might be due to invalid IL or missing references)
			FishData* ptr = fishDataArray + i;
			FishRenderData* ptr2 = fishRenderDataArray + i;
			Random random = default(Random);
			((Random)(ref random))..ctor((uint)(i * 3245 + seed));
			float num = math.distancesq(cameraPosition, ptr2->position);
			bool flag = ptr->startleTime > 0f;
			if (num > math.pow(40f, 2f) || ((float3)(&ptr2->position)).y > minDepth)
			{
				ptr->isAlive = false;
				return;
			}
			if (!flag && num < 100f)
			{
				ptr->startleTime = 2f;
				flag = true;
			}
			float3 val = default(float3);
			((float3)(ref val))..ctor(ptr->destinationX, ((float3)(&ptr2->position)).y, ptr->destinationZ);
			if (ptr->updateTime >= 8f || math.distancesq(val, ptr2->position) < 1f)
			{
				float3 target = GetTarget(new float3(ptr->spawnX, 0f, ptr->spawnZ), ref random);
				ptr->updateTime = 0f;
				ptr->destinationX = target.x;
				ptr->destinationZ = target.z;
			}
			ptr2->scale = math.lerp(ptr2->scale, ptr->scale, dt * 5f);
			ptr->speed = math.lerp(ptr->speed, flag ? maxSpeed : minSpeed, dt * 4f);
			float3 val2 = math.normalize(val - ptr2->position);
			float a = math.atan2(val2.z, val2.x);
			ptr2->rotation = 0f - ptr2->rotation + MathF.PI / 2f;
			float num2 = (flag ? maxTurnSpeed : minTurnSpeed);
			ptr2->rotation = LerpAngle(ptr2->rotation, a, dt * num2);
			float3 zero = float3.zero;
			math.sincos(ptr2->rotation, ref zero.z, ref zero.x);
			ptr->directionX = zero.x;
			ptr->directionZ = zero.z;
			float3* position = &ptr2->position;
			Unsafe.Write(position, *position + zero * ptr->speed * dt);
			ptr2->rotation = 0f - ptr2->rotation + MathF.PI / 2f;
			ptr2->distance += ptr->speed * dt;
			ptr->updateTime += dt;
			ptr->startleTime -= dt;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static float LerpAngle(float a0, float a1, float t)
		{
			float num = a1 - a0;
			num = math.clamp(num - math.floor(num / (MathF.PI * 2f)) * (MathF.PI * 2f), 0f, MathF.PI * 2f);
			return math.lerp(a0, a0 + ((num > MathF.PI) ? (num - MathF.PI * 2f) : num), t);
		}
	}

	public struct KillFish : IJob
	{
		public NativeArray<FishData> fishDataArray;

		public NativeArray<FishRenderData> fishRenderDataArray;

		public NativeArray<int> fishCount;

		public void Execute()
		{
			int num = fishCount[0];
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				if (!fishDataArray[num2].isAlive)
				{
					if (num2 < num - 1)
					{
						fishDataArray[num2] = fishDataArray[num - 1];
						fishRenderDataArray[num2] = fishRenderDataArray[num - 1];
					}
					num--;
				}
			}
			fishCount[0] = num;
		}
	}

	private const float maxFishDistance = 40f;

	private FishType fishType;

	private JobHandle jobHandle;

	private NativeArray<RaycastCommand> castCommands;

	private NativeArray<RaycastHit> castResults;

	private NativeArray<int> fishCastIndices;

	private NativeArray<FishData> fishData;

	private NativeArray<FishRenderData> fishRenderData;

	private NativeArray<int> fishCount;

	private MaterialPropertyBlock materialPropertyBlock;

	private ComputeBuffer fishBuffer;

	public FishShoal(FishType fishType)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Expected O, but got Unknown
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Expected O, but got Unknown
		this.fishType = fishType;
		castCommands = new NativeArray<RaycastCommand>(fishType.castsPerFrame, (Allocator)4, (NativeArrayOptions)1);
		castResults = new NativeArray<RaycastHit>(fishType.castsPerFrame, (Allocator)4, (NativeArrayOptions)1);
		fishCastIndices = new NativeArray<int>(fishType.castsPerFrame, (Allocator)4, (NativeArrayOptions)1);
		fishData = new NativeArray<FishData>(fishType.maxCount, (Allocator)4, (NativeArrayOptions)1);
		fishRenderData = new NativeArray<FishRenderData>(fishType.maxCount, (Allocator)4, (NativeArrayOptions)1);
		fishCount = new NativeArray<int>(1, (Allocator)4, (NativeArrayOptions)1);
		fishBuffer = new ComputeBuffer(fishType.maxCount, UnsafeUtility.SizeOf<FishRenderData>());
		materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.SetBuffer("_FishData", fishBuffer);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static float3 GetTarget(float3 spawnPos, ref Random random)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		float2 val = ((Random)(ref random)).NextFloat2Direction();
		return spawnPos + new float3(val.x, 0f, val.y) * ((Random)(ref random)).NextFloat(10f, 15f);
	}

	private int GetPopulationScaleForPoint(float3 cameraPosition)
	{
		return 1;
	}

	public void TrySpawn(float3 cameraPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(float3.op_Implicit(cameraPosition), waves: false, volumes: false);
		float item = waterAndTerrainSurface.Item1;
		float item2 = waterAndTerrainSurface.Item2;
		item -= 3f;
		if (math.abs(item - item2) < 4f || item < item2)
		{
			return;
		}
		int num = fishCount[0];
		int num2 = Mathf.Min(Mathf.CeilToInt((float)(fishType.maxCount * GetPopulationScaleForPoint(cameraPosition))) - num, 5);
		if (num2 <= 0)
		{
			return;
		}
		uint num3 = (uint)(Time.frameCount + fishType.mesh.vertexCount);
		int num4 = fishCount[0];
		int num5 = math.min(num4 + num2, fishType.maxCount);
		Random random = default(Random);
		for (int i = num4; i < num5; i++)
		{
			((Random)(ref random))..ctor((uint)(i * 3245 + num3));
			float3 val = cameraPosition + ((Random)(ref random)).NextFloat3Direction() * ((Random)(ref random)).NextFloat(40f);
			val.y = ((Random)(ref random)).NextFloat(math.max(item2 + 1f, cameraPosition.y - 30f), math.min(item, cameraPosition.y + 30f));
			if (!((Object)(object)WaterSystem.Instance == (Object)null) && WaterLevel.Test(float3.op_Implicit(val), waves: false, volumes: false) && !(TerrainMeta.HeightMap.GetHeight(float3.op_Implicit(val)) > val.y) && !EnvironmentManager.Check(float3.op_Implicit(val), EnvironmentType.UnderwaterLab, 30f))
			{
				float3 target = GetTarget(val, ref random);
				float3 val2 = math.normalize(target - val);
				fishData[num] = new FishData
				{
					isAlive = true,
					spawnX = val.x,
					spawnZ = val.z,
					destinationX = target.x,
					destinationZ = target.z,
					scale = ((Random)(ref random)).NextFloat(fishType.minScale, fishType.maxScale)
				};
				fishRenderData[num] = new FishRenderData
				{
					position = val,
					rotation = math.atan2(val2.z, val2.x),
					scale = 0f,
					seed = ((Random)(ref random)).NextFloat(0f, 2f)
				};
				num++;
			}
		}
		fishCount[0] = num;
	}

	public void OnUpdate(float3 cameraPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		UpdateJobs(cameraPosition);
	}

	private unsafe void UpdateJobs(float3 cameraPosition)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		((JobHandle)(ref jobHandle)).Complete();
		int num = fishCount[0];
		if (num != 0)
		{
			float item = WaterLevel.GetWaterAndTerrainSurface(float3.op_Implicit(cameraPosition), waves: false, volumes: false).Item1;
			item -= 3f;
			int castCount = math.min(fishType.castsPerFrame, num);
			uint seed = (uint)(Time.frameCount + fishType.mesh.vertexCount);
			FishCollisionGatherJob fishCollisionGatherJob = default(FishCollisionGatherJob);
			fishCollisionGatherJob.layerMask = -1;
			fishCollisionGatherJob.seed = seed;
			fishCollisionGatherJob.castCount = castCount;
			fishCollisionGatherJob.fishCount = num;
			fishCollisionGatherJob.castCommands = castCommands;
			fishCollisionGatherJob.fishCastIndices = fishCastIndices;
			fishCollisionGatherJob.fishDataArray = fishData;
			fishCollisionGatherJob.fishRenderDataArray = fishRenderData;
			FishCollisionGatherJob fishCollisionGatherJob2 = fishCollisionGatherJob;
			FishCollisionProcessJob fishCollisionProcessJob = default(FishCollisionProcessJob);
			fishCollisionProcessJob.castCount = castCount;
			fishCollisionProcessJob.castResults = castResults;
			fishCollisionProcessJob.fishCastIndices = fishCastIndices;
			fishCollisionProcessJob.fishDataArray = fishData;
			fishCollisionProcessJob.fishRenderDataArray = fishRenderData;
			FishCollisionProcessJob fishCollisionProcessJob2 = fishCollisionProcessJob;
			FishUpdateJob fishUpdateJob = default(FishUpdateJob);
			fishUpdateJob.cameraPosition = cameraPosition;
			fishUpdateJob.seed = seed;
			fishUpdateJob.dt = Time.deltaTime;
			fishUpdateJob.minSpeed = fishType.minSpeed;
			fishUpdateJob.maxSpeed = fishType.maxSpeed;
			fishUpdateJob.minTurnSpeed = fishType.minTurnSpeed;
			fishUpdateJob.maxTurnSpeed = fishType.maxTurnSpeed;
			fishUpdateJob.fishDataArray = (FishData*)NativeArrayUnsafeUtility.GetUnsafePtr<FishData>(fishData);
			fishUpdateJob.fishRenderDataArray = (FishRenderData*)NativeArrayUnsafeUtility.GetUnsafePtr<FishRenderData>(fishRenderData);
			fishUpdateJob.minDepth = item - 3f;
			FishUpdateJob fishUpdateJob2 = fishUpdateJob;
			KillFish killFish = default(KillFish);
			killFish.fishCount = fishCount;
			killFish.fishDataArray = fishData;
			killFish.fishRenderDataArray = fishRenderData;
			KillFish killFish2 = killFish;
			jobHandle = IJobExtensions.Schedule<FishCollisionGatherJob>(fishCollisionGatherJob2, default(JobHandle));
			jobHandle = RaycastCommand.ScheduleBatch(castCommands, castResults, 5, jobHandle);
			jobHandle = IJobExtensions.Schedule<FishCollisionProcessJob>(fishCollisionProcessJob2, jobHandle);
			jobHandle = IJobParallelForExtensions.Schedule<FishUpdateJob>(fishUpdateJob2, num, 10, jobHandle);
			jobHandle = IJobExtensions.Schedule<KillFish>(killFish2, jobHandle);
		}
	}

	public void OnLateUpdate(float3 cameraPosition)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		((JobHandle)(ref jobHandle)).Complete();
		if (fishCount[0] != 0)
		{
			Bounds val = default(Bounds);
			((Bounds)(ref val))..ctor(float3.op_Implicit(cameraPosition), Vector3.one * 40f);
			fishBuffer.SetData<FishRenderData>(fishRenderData);
			Graphics.DrawMeshInstancedProcedural(fishType.mesh, 0, fishType.material, val, fishCount[0], materialPropertyBlock, (ShadowCastingMode)1, true, 0, (Camera)null, (LightProbeUsage)1, (LightProbeProxyVolume)null);
		}
	}

	public void Dispose()
	{
		((JobHandle)(ref jobHandle)).Complete();
		castCommands.Dispose();
		castResults.Dispose();
		fishCastIndices.Dispose();
		fishData.Dispose();
		fishRenderData.Dispose();
		fishCount.Dispose();
		fishBuffer.Dispose();
	}

	public void OnDrawGizmosSelected()
	{
		((JobHandle)(ref jobHandle)).Complete();
		_ = fishCount[0];
	}
}


using System;
using UnityEngine;

[Serializable]
public struct FishType
{
	public Mesh mesh;

	public Material material;

	public int castsPerFrame;

	public int maxCount;

	public float minSpeed;

	public float maxSpeed;

	public float idealDepth;

	public float minTurnSpeed;

	public float maxTurnSpeed;

	public float minScale;

	public float maxScale;
}


public struct FishData
{
	public bool isAlive;

	public float updateTime;

	public float startleTime;

	public float spawnX;

	public float spawnZ;

	public float destinationX;

	public float destinationZ;

	public float directionX;

	public float directionZ;

	public float speed;

	public float scale;
}


using Unity.Mathematics;

public struct FishRenderData
{
	public float3 position;

	public float rotation;

	public float scale;

	public float distance;

	public float seed;
}


using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public struct FishCollisionGatherJob : IJob
{
	public int layerMask;

	public uint seed;

	public int castCount;

	public int fishCount;

	public NativeArray<RaycastCommand> castCommands;

	public NativeArray<FishData> fishDataArray;

	public NativeArray<FishRenderData> fishRenderDataArray;

	public NativeArray<int> fishCastIndices;

	public void Execute()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Random val = default(Random);
		((Random)(ref val))..ctor(seed);
		int length = castCommands.Length;
		for (int i = 0; i < length; i++)
		{
			RaycastCommand val3;
			if (i >= castCount)
			{
				val3 = (castCommands[i] = default(RaycastCommand));
				continue;
			}
			int num = ((Random)(ref val)).NextInt(0, fishCount);
			FishData fishData = fishDataArray[num];
			FishRenderData fishRenderData = fishRenderDataArray[num];
			ref NativeArray<RaycastCommand> reference = ref castCommands;
			int num2 = i;
			val3 = default(RaycastCommand);
			((RaycastCommand)(ref val3)).from = float3.op_Implicit(fishRenderData.position);
			((RaycastCommand)(ref val3)).direction = float3.op_Implicit(new float3(fishData.directionX, 0f, fishData.directionZ));
			((RaycastCommand)(ref val3)).distance = 4f;
			((RaycastCommand)(ref val3)).layerMask = layerMask;
			((RaycastCommand)(ref val3)).maxHits = 1;
			reference[num2] = val3;
			fishCastIndices[i] = num;
		}
	}
}


using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public struct FishCollisionProcessJob : IJob
{
	public int castCount;

	public NativeArray<FishData> fishDataArray;

	[ReadOnly]
	public NativeArray<RaycastHit> castResults;

	[ReadOnly]
	public NativeArray<int> fishCastIndices;

	[ReadOnly]
	public NativeArray<FishRenderData> fishRenderDataArray;

	public void Execute()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < castCount; i++)
		{
			RaycastHit val = castResults[i];
			if (((RaycastHit)(ref val)).normal != default(Vector3))
			{
				int num = fishCastIndices[i];
				FishData fishData = fishDataArray[num];
				if (fishData.startleTime <= 0f)
				{
					FishRenderData fishRenderData = fishRenderDataArray[num];
					float2 xz = ((float3)(ref fishRenderData.position)).xz;
					val = castResults[i];
					float x = ((RaycastHit)(ref val)).point.x;
					val = castResults[i];
					float2 val2 = math.normalize(new float2(x, ((RaycastHit)(ref val)).point.z) - xz);
					float2 val3 = xz - val2 * 8f;
					fishData.destinationX = val3.x;
					fishData.destinationZ = val3.y;
					fishData.startleTime = 2f;
					fishData.updateTime = 6f;
					fishDataArray[num] = fishData;
				}
			}
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;

public struct FishUpdateJob : IJobParallelFor
{
	[ReadOnly]
	public float3 cameraPosition;

	[ReadOnly]
	public uint seed;

	[ReadOnly]
	public float dt;

	[ReadOnly]
	public float minSpeed;

	[ReadOnly]
	public float maxSpeed;

	[ReadOnly]
	public float minTurnSpeed;

	[ReadOnly]
	public float maxTurnSpeed;

	[ReadOnly]
	public float minDepth;

	[NativeDisableUnsafePtrRestriction]
	public unsafe FishData* fishDataArray;

	[NativeDisableUnsafePtrRestriction]
	public unsafe FishRenderData* fishRenderDataArray;

	public unsafe void Execute(int i)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		FishData* ptr = fishDataArray + i;
		FishRenderData* ptr2 = fishRenderDataArray + i;
		Random random = default(Random);
		((Random)(ref random))..ctor((uint)(i * 3245 + seed));
		float num = math.distancesq(cameraPosition, ptr2->position);
		bool flag = ptr->startleTime > 0f;
		if (num > math.pow(40f, 2f) || ((float3)(&ptr2->position)).y > minDepth)
		{
			ptr->isAlive = false;
			return;
		}
		if (!flag && num < 100f)
		{
			ptr->startleTime = 2f;
			flag = true;
		}
		float3 val = default(float3);
		((float3)(ref val))..ctor(ptr->destinationX, ((float3)(&ptr2->position)).y, ptr->destinationZ);
		if (ptr->updateTime >= 8f || math.distancesq(val, ptr2->position) < 1f)
		{
			float3 target = GetTarget(new float3(ptr->spawnX, 0f, ptr->spawnZ), ref random);
			ptr->updateTime = 0f;
			ptr->destinationX = target.x;
			ptr->destinationZ = target.z;
		}
		ptr2->scale = math.lerp(ptr2->scale, ptr->scale, dt * 5f);
		ptr->speed = math.lerp(ptr->speed, flag ? maxSpeed : minSpeed, dt * 4f);
		float3 val2 = math.normalize(val - ptr2->position);
		float a = math.atan2(val2.z, val2.x);
		ptr2->rotation = 0f - ptr2->rotation + MathF.PI / 2f;
		float num2 = (flag ? maxTurnSpeed : minTurnSpeed);
		ptr2->rotation = LerpAngle(ptr2->rotation, a, dt * num2);
		float3 zero = float3.zero;
		math.sincos(ptr2->rotation, ref zero.z, ref zero.x);
		ptr->directionX = zero.x;
		ptr->directionZ = zero.z;
		float3* position = &ptr2->position;
		Unsafe.Write(position, *position + zero * ptr->speed * dt);
		ptr2->rotation = 0f - ptr2->rotation + MathF.PI / 2f;
		ptr2->distance += ptr->speed * dt;
		ptr->updateTime += dt;
		ptr->startleTime -= dt;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static float LerpAngle(float a0, float a1, float t)
	{
		float num = a1 - a0;
		num = math.clamp(num - math.floor(num / (MathF.PI * 2f)) * (MathF.PI * 2f), 0f, MathF.PI * 2f);
		return math.lerp(a0, a0 + ((num > MathF.PI) ? (num - MathF.PI * 2f) : num), t);
	}
}


using Unity.Collections;
using Unity.Jobs;

public struct KillFish : IJob
{
	public NativeArray<FishData> fishDataArray;

	public NativeArray<FishRenderData> fishRenderDataArray;

	public NativeArray<int> fishCount;

	public void Execute()
	{
		int num = fishCount[0];
		for (int num2 = num - 1; num2 >= 0; num2--)
		{
			if (!fishDataArray[num2].isAlive)
			{
				if (num2 < num - 1)
				{
					fishDataArray[num2] = fishDataArray[num - 1];
					fishRenderDataArray[num2] = fishRenderDataArray[num - 1];
				}
				num--;
			}
		}
		fishCount[0] = num;
	}
}


using UnityEngine;
using UnityEngine.AI;

public class FishNavigator : BaseNavigator
{
	public BaseNpc NPC { get; private set; }

	public override void Init(BaseCombatEntity entity, NavMeshAgent agent)
	{
		base.Init(entity, agent);
		NPC = entity as BaseNpc;
	}

	protected override bool SetCustomDestination(Vector3 pos, float speedFraction = 1f, float updateInterval = 0f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!base.SetCustomDestination(pos, speedFraction, updateInterval))
		{
			return false;
		}
		base.Destination = pos;
		return true;
	}

	protected override void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.position = Vector3.MoveTowards(((Component)this).transform.position, moveToPosition, GetTargetSpeed() * delta);
		base.BaseEntity.ServerPosition = ((Component)this).transform.localPosition;
		if (ReachedPosition(moveToPosition))
		{
			Stop();
		}
		else
		{
			UpdateRotation(moveToPosition, delta);
		}
	}

	private void UpdateRotation(Vector3 moveToPosition, float delta)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		base.BaseEntity.ServerRotation = Quaternion.LookRotation(Vector3Ex.Direction(moveToPosition, ((Component)this).transform.position));
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Spatial;
using UnityEngine;

public class NpcFireManager : SingletonComponent<NpcFireManager>, IServerComponent
{
	private const float maxFireMeleeAge = 1f;

	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private Grid<BaseEntity> fireGrid = new Grid<BaseEntity>(32, 8096f);

	private Dictionary<BaseEntity, double> recentFireMeleeEvents = new Dictionary<BaseEntity, double>();

	private double nextTickTime;

	public void Add(BaseEntity entity)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		fireGrid.Add(entity, ((Component)entity).transform.position.x, ((Component)entity).transform.position.z);
	}

	public void Move(BaseEntity entity)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFireManager.Move", 0);
		try
		{
			if (IsOnFire(entity))
			{
				Vector3 position = ((Component)entity).transform.position;
				fireGrid.Move(entity, position.x, position.z);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Remove(BaseEntity entity)
	{
		fireGrid.Remove(entity);
	}

	public void GetFiresAround(Vector3 position, float range, List<BaseEntity> results)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFireManager.GetFiresAround", 0);
		try
		{
			if (fireGrid == null)
			{
				return;
			}
			fireGrid.Query<BaseEntity>(position.x, position.z, range, results);
			for (int num = results.Count - 1; num >= 0; num--)
			{
				if (!results[num].IsValid())
				{
					if (AI.logIssues)
					{
						Debug.LogWarning((object)$"Removed null fire from results list near {position}, this is unusual as fires should be removed from the grid when destroyed.");
					}
					results.RemoveAt(num);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnReceivedSignalServer(BaseEntity entity, BaseEntity.Signal signal, string arg)
	{
		if (signal != 0)
		{
			return;
		}
		if (entity is HeldEntity heldEntity && IsOnFire(heldEntity))
		{
			BasePlayer ownerPlayer = heldEntity.GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				recentFireMeleeEvents[ownerPlayer] = Time.timeAsDouble;
			}
		}
		if (entity is BasePlayer basePlayer && IsOnFire(basePlayer.GetHeldEntity()) && (Object)(object)entity != (Object)null)
		{
			recentFireMeleeEvents[entity] = Time.timeAsDouble;
		}
	}

	public bool DidMeleeWithFireRecently(BaseEntity querier, BaseEntity target, out double meleeTime, float maxDistance = 10f)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFireManager.DidMeleeWithFireRecently", 0);
		try
		{
			if (recentFireMeleeEvents.TryGetValue(target, out var value) && Vector3.Distance(((Component)querier).transform.position, ((Component)target).transform.position) <= maxDistance)
			{
				meleeTime = value;
				return true;
			}
			meleeTime = 0.0;
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsOnFire(BaseEntity entity)
	{
		if (!entity.IsValid())
		{
			return false;
		}
		if (entity.IsOnFire())
		{
			return true;
		}
		if (entity is BaseOven baseOven && baseOven.IsOn() && baseOven.hasOpenFlame)
		{
			return true;
		}
		return false;
	}

	public void Tick()
	{
		if (Time.timeAsDouble < nextTickTime)
		{
			return;
		}
		nextTickTime = Time.timeAsDouble + (double)Random.Range(4f, 6f);
		TimeWarning val = TimeWarning.New("NpcFireManager.RemoveStaleEntries", 0);
		try
		{
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				foreach (var (baseEntity2, num2) in recentFireMeleeEvents)
				{
					if (!baseEntity2.IsValid() || Time.timeAsDouble - num2 > 1.0)
					{
						((List<BaseEntity>)(object)val2).Add(baseEntity2);
					}
				}
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					recentFireMeleeEvents.Remove(item);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Spatial;
using UnityEngine;

public class NpcFoodManager : SingletonComponent<NpcFoodManager>, IServerComponent
{
	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private Grid<BaseEntity> foodGrid = new Grid<BaseEntity>(32, 8096f);

	public bool Add(BaseEntity food)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (!IsFood(food))
		{
			return false;
		}
		if (!foodGrid.AddUnique(food, ((Component)food).transform.position.x, ((Component)food).transform.position.z))
		{
			if (AI.logIssues)
			{
				Debug.LogWarning((object)$"Failed to add food to grid: {food.ShortPrefabName}_{food.net.ID}");
			}
			return false;
		}
		return true;
	}

	public void Move(BaseEntity food)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFoodManager.Move", 0);
		try
		{
			if (IsFood(food))
			{
				Vector3 position = ((Component)food).transform.position;
				foodGrid.Move(food, position.x, position.z);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool Contains(BaseEntity food)
	{
		if (!IsFood(food))
		{
			return false;
		}
		return foodGrid.Contains(food);
	}

	public bool Remove(BaseEntity food)
	{
		if (!IsFood(food))
		{
			return false;
		}
		if (!foodGrid.Remove(food))
		{
			return false;
		}
		return true;
	}

	public void GetFoodAround(Vector3 position, float range, List<BaseEntity> results)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFoodManager.GetFoodAround", 0);
		try
		{
			if (foodGrid != null)
			{
				foodGrid.Query<BaseEntity>(position.x, position.z, range, results);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsFood(BaseEntity entity)
	{
		if (entity is DroppedItem droppedItem)
		{
			if (droppedItem.item == null)
			{
				return false;
			}
			return droppedItem.item.info.Traits.HasFlag(BaseEntity.TraitFlag.Meat);
		}
		return entity is BaseCorpse;
	}

	public static bool IsFoodImmobile(BaseEntity entity)
	{
		if (entity is DroppedItem { IsSleeping: not false })
		{
			return true;
		}
		if (entity is BaseCorpse { IsSleeping: not false })
		{
			return true;
		}
		return false;
	}
}


public enum NpcNoiseIntensity
{
	None,
	Low,
	Medium,
	High
}


using Facepunch;
using UnityEngine;

public class NpcNoiseEvent : IPooled
{
	public BaseEntity Initiator;

	public Vector3 Position;

	public NpcNoiseIntensity Intensity;

	public double EventTime;

	public void EnterPool()
	{
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using Facepunch;
using Spatial;
using UnityEngine;

public class NpcNoiseManager : SingletonComponent<NpcNoiseManager>, IServerComponent
{
	private const float voiceChatEventMaxAge = 1f;

	private const float noiseMaxAge = 10f;

	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private ConcurrentDictionary<BasePlayer, double> recentVoiceChatEvents = new ConcurrentDictionary<BasePlayer, double>();

	private Grid<NpcNoiseEvent> noiseGrid = new Grid<NpcNoiseEvent>(32, 8096f);

	private Queue<NpcNoiseEvent> noises = new Queue<NpcNoiseEvent>();

	private double nextTickTime;

	public void AddNoise(BaseEntity initiator, Vector3 position, NpcNoiseIntensity intensity)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (!((FacepunchBehaviour)this).IsInvoking((Action)RemoveOldNoises))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)RemoveOldNoises, 0f, 0f);
		}
		NpcNoiseEvent npcNoiseEvent = Pool.Get<NpcNoiseEvent>();
		npcNoiseEvent.Initiator = initiator;
		npcNoiseEvent.Position = position;
		npcNoiseEvent.Intensity = intensity;
		npcNoiseEvent.EventTime = Time.timeAsDouble;
		noiseGrid.Add(npcNoiseEvent, npcNoiseEvent.Position.x, npcNoiseEvent.Position.z);
		noises.Enqueue(npcNoiseEvent);
	}

	private void RemoveOldNoises()
	{
		TimeWarning val = TimeWarning.New("RemoveOldNoises", 0);
		try
		{
			while (noises.Count > 0)
			{
				NpcNoiseEvent npcNoiseEvent = noises.Peek();
				if (Time.timeAsDouble - npcNoiseEvent.EventTime <= 10.0)
				{
					break;
				}
				noises.Dequeue();
				noiseGrid.Remove(npcNoiseEvent);
				Pool.Free<NpcNoiseEvent>(ref npcNoiseEvent);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetNoisesAround(Vector3 position, float range, List<NpcNoiseEvent> results)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (noiseGrid != null)
		{
			noiseGrid.Query<NpcNoiseEvent>(position.x, position.z, range, results);
		}
	}

	public void OnServerProjectileHit(BaseEntity entity, ServerProjectile projectile, RaycastHit hit)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		AddNoise(entity, ((Component)projectile).transform.position, NpcNoiseIntensity.High);
	}

	public void OnProjectileHit(BaseEntity entity, HitInfo hit)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		AddNoise(entity, hit.HitPositionWorld, (hit.Weapon is BowWeapon || hit.Weapon is BaseMelee) ? NpcNoiseIntensity.Medium : NpcNoiseIntensity.High);
	}

	public void OnWeaponShot(BasePlayer player, BaseProjectile weapon)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		AddNoise(player, ((Component)player).transform.position, (weapon is BowWeapon) ? NpcNoiseIntensity.Low : NpcNoiseIntensity.High);
	}

	public void OnWeaponThrown(BasePlayer player, BaseMelee weapon, bool canAiHearIt)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (canAiHearIt)
		{
			AddNoise(player, ((Component)player).transform.position, NpcNoiseIntensity.Low);
		}
	}

	public void OnVoiceChat(BasePlayer player)
	{
		recentVoiceChatEvents[player] = Time.timeAsDouble;
	}

	public void OnMeleeHit(BaseMelee weapon, HitInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = weapon.GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			AddNoise(ownerPlayer, ((Component)ownerPlayer).transform.position, NpcNoiseIntensity.Medium);
		}
	}

	public bool HasPlayerSpokenNear(BaseEntity querier, BasePlayer targetPlayer, float maxDistance = 16f)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcNoiseManager.HasPlayerSpokenNear", 0);
		try
		{
			double value;
			return recentVoiceChatEvents.TryGetValue(targetPlayer, out value) && Vector3.Distance(((Component)querier).transform.position, ((Component)targetPlayer).transform.position) <= maxDistance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Tick()
	{
		if (Time.timeAsDouble < nextTickTime)
		{
			return;
		}
		nextTickTime = Time.timeAsDouble + (double)Random.Range(4f, 6f);
		TimeWarning val = TimeWarning.New("NpcNoiseManager.RemoveStaleEntries", 0);
		try
		{
			PooledList<BasePlayer> val2 = Pool.Get<PooledList<BasePlayer>>();
			try
			{
				double value;
				foreach (KeyValuePair<BasePlayer, double> recentVoiceChatEvent in recentVoiceChatEvents)
				{
					recentVoiceChatEvent.Deconstruct(out var key, out value);
					BasePlayer basePlayer = key;
					double num = value;
					if (!basePlayer.IsValid() || Time.timeAsDouble - num > 1.0)
					{
						((List<BasePlayer>)(object)val2).Add(basePlayer);
					}
				}
				foreach (BasePlayer item in (List<BasePlayer>)(object)val2)
				{
					recentVoiceChatEvents.Remove(item, out value);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Rust;
using Rust.Ai;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class DungeonNavmesh : FacepunchBehaviour, IServerComponent
{
	public int NavMeshAgentTypeIndex;

	[Tooltip("The default area associated with the NavMeshAgent index.")]
	public string DefaultAreaName = "HumanNPC";

	public float NavmeshResolutionModifier = 1.25f;

	[Tooltip("Bounds which are auto calculated from CellSize * CellCount")]
	public Bounds Bounds;

	public NavMeshData NavMeshData;

	public NavMeshDataInstance NavMeshDataInstance;

	public LayerMask LayerMask;

	public NavMeshCollectGeometry NavMeshCollectGeometry;

	public static List<DungeonNavmesh> Instances = new List<DungeonNavmesh>();

	[ServerVar]
	public static bool use_baked_terrain_mesh = true;

	private List<NavMeshBuildSource> sources;

	private AsyncOperation BuildingOperation;

	private bool HasBuildOperationStarted;

	private Stopwatch BuildTimer = new Stopwatch();

	private int defaultArea;

	private int agentTypeId;

	public bool IsBuilding
	{
		get
		{
			if (!HasBuildOperationStarted || BuildingOperation != null)
			{
				return true;
			}
			return false;
		}
	}

	public static bool NavReady()
	{
		if (Instances == null || Instances.Count == 0)
		{
			return true;
		}
		foreach (DungeonNavmesh instance in Instances)
		{
			if (instance.IsBuilding)
			{
				return false;
			}
		}
		return true;
	}

	private void OnEnable()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
		agentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		NavMeshData = new NavMeshData(agentTypeId);
		sources = new List<NavMeshBuildSource>();
		defaultArea = NavMesh.GetAreaFromName(DefaultAreaName);
		((FacepunchBehaviour)this).InvokeRepeating((Action)FinishBuildingNavmesh, 0f, 1f);
		Instances.Add(this);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FinishBuildingNavmesh);
			((NavMeshDataInstance)(ref NavMeshDataInstance)).Remove();
			Instances.Remove(this);
		}
	}

	[ContextMenu("Update Monument Nav Mesh")]
	public void UpdateNavMeshAsync()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (!HasBuildOperationStarted && !AiManager.nav_disable && AI.npc_enable)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			Debug.Log((object)("Starting Dungeon Navmesh Build with " + sources.Count + " sources"));
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
			((NavMeshBuildSettings)(ref settingsByIndex)).overrideVoxelSize = true;
			((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize = ((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize * NavmeshResolutionModifier;
			BuildingOperation = NavMeshBuilder.UpdateNavMeshDataAsync(NavMeshData, settingsByIndex, sources, Bounds);
			BuildTimer.Reset();
			BuildTimer.Start();
			HasBuildOperationStarted = true;
			float num = Time.realtimeSinceStartup - realtimeSinceStartup;
			if (num > 0.1f)
			{
				Debug.LogWarning((object)("Calling UpdateNavMesh took " + num));
			}
			NotifyInformationZonesOfCompletion();
		}
	}

	public void NotifyInformationZonesOfCompletion()
	{
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			zone.NavmeshBuildingComplete();
		}
	}

	public void SourcesCollected()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		int count = sources.Count;
		Debug.Log((object)("Source count Pre cull : " + sources.Count));
		Vector3 val = default(Vector3);
		for (int num = sources.Count - 1; num >= 0; num--)
		{
			NavMeshBuildSource item = sources[num];
			Matrix4x4 transform = ((NavMeshBuildSource)(ref item)).transform;
			((Vector3)(ref val))..ctor(((Matrix4x4)(ref transform))[0, 3], ((Matrix4x4)(ref transform))[1, 3], ((Matrix4x4)(ref transform))[2, 3]);
			bool flag = false;
			foreach (AIInformationZone zone in AIInformationZone.zones)
			{
				if (Vector3Ex.Distance2D(zone.ClosestPointTo(val), val) <= 50f)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				sources.Remove(item);
			}
		}
		Debug.Log((object)("Source count post cull : " + sources.Count + " total removed : " + (count - sources.Count)));
	}

	public IEnumerator UpdateNavMeshAndWait()
	{
		if (HasBuildOperationStarted || AiManager.nav_disable || !AI.npc_enable)
		{
			yield break;
		}
		HasBuildOperationStarted = false;
		((Bounds)(ref Bounds)).center = ((Component)this).transform.position;
		((Bounds)(ref Bounds)).size = new Vector3(1000000f, 100000f, 100000f);
		IEnumerator enumerator = NavMeshTools.CollectSourcesAsync(((Component)this).transform, ((LayerMask)(ref LayerMask)).value, NavMeshCollectGeometry, defaultArea, sources, AppendModifierVolumes, UpdateNavMeshAsync);
		if (AiManager.nav_wait)
		{
			yield return enumerator;
		}
		else
		{
			((MonoBehaviour)this).StartCoroutine(enumerator);
		}
		if (!AiManager.nav_wait)
		{
			Debug.Log((object)"nav_wait is false, so we're not waiting for the navmesh to finish generating. This might cause your server to sputter while it's generating.");
			yield break;
		}
		int lastPct = 0;
		while (!HasBuildOperationStarted)
		{
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
		}
		while (BuildingOperation != null)
		{
			int num = (int)(BuildingOperation.progress * 100f);
			if (lastPct != num)
			{
				Debug.LogFormat("{0}%", new object[1] { num });
				lastPct = num;
			}
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
			FinishBuildingNavmesh();
		}
	}

	private void AppendModifierVolumes(List<NavMeshBuildSource> sources)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		Vector3 size = default(Vector3);
		foreach (NavMeshModifierVolume activeModifier in NavMeshModifierVolume.activeModifiers)
		{
			if ((LayerMask.op_Implicit(LayerMask) & (1 << ((Component)activeModifier).gameObject.layer)) != 0 && activeModifier.AffectsAgentType(agentTypeId))
			{
				Vector3 val = ((Component)activeModifier).transform.TransformPoint(activeModifier.center);
				if (((Bounds)(ref Bounds)).Contains(val))
				{
					Vector3 lossyScale = ((Component)activeModifier).transform.lossyScale;
					((Vector3)(ref size))..ctor(activeModifier.size.x * Mathf.Abs(lossyScale.x), activeModifier.size.y * Mathf.Abs(lossyScale.y), activeModifier.size.z * Mathf.Abs(lossyScale.z));
					NavMeshBuildSource item = default(NavMeshBuildSource);
					((NavMeshBuildSource)(ref item)).shape = (NavMeshBuildSourceShape)5;
					((NavMeshBuildSource)(ref item)).transform = Matrix4x4.TRS(val, ((Component)activeModifier).transform.rotation, Vector3.one);
					((NavMeshBuildSource)(ref item)).size = size;
					((NavMeshBuildSource)(ref item)).area = activeModifier.area;
					sources.Add(item);
				}
			}
		}
	}

	public void FinishBuildingNavmesh()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (BuildingOperation != null && BuildingOperation.isDone)
		{
			if (!((NavMeshDataInstance)(ref NavMeshDataInstance)).valid)
			{
				NavMeshDataInstance = NavMesh.AddNavMeshData(NavMeshData);
			}
			Debug.Log((object)$"Monument Navmesh Build took {BuildTimer.Elapsed.TotalSeconds:0.00} seconds");
			BuildingOperation = null;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using Rust;
using Rust.Ai;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class DynamicNavMesh : SingletonComponent<DynamicNavMesh>, IServerComponent
{
	public int NavMeshAgentTypeIndex;

	[Tooltip("The default area associated with the NavMeshAgent index.")]
	public string DefaultAreaName = "Walkable";

	public int AsyncTerrainNavMeshBakeCellSize = 80;

	public int AsyncTerrainNavMeshBakeCellHeight = 100;

	public Bounds Bounds;

	public NavMeshData NavMeshData;

	public NavMeshDataInstance NavMeshDataInstance;

	public LayerMask LayerMask;

	public NavMeshCollectGeometry NavMeshCollectGeometry;

	[ServerVar]
	public static bool use_baked_terrain_mesh;

	private List<NavMeshBuildSource> sources;

	private AsyncOperation BuildingOperation;

	private bool HasBuildOperationStarted;

	private Stopwatch BuildTimer = new Stopwatch();

	private int defaultArea;

	private int agentTypeId;

	public bool IsBuilding
	{
		get
		{
			if (!HasBuildOperationStarted || BuildingOperation != null)
			{
				return true;
			}
			return false;
		}
	}

	private void OnEnable()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
		agentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		NavMeshData = new NavMeshData(agentTypeId);
		sources = new List<NavMeshBuildSource>();
		defaultArea = NavMesh.GetAreaFromName(DefaultAreaName);
		((FacepunchBehaviour)this).InvokeRepeating((Action)FinishBuildingNavmesh, 0f, 1f);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FinishBuildingNavmesh);
			((NavMeshDataInstance)(ref NavMeshDataInstance)).Remove();
		}
	}

	[ContextMenu("Update Nav Mesh")]
	public void UpdateNavMeshAsync()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		if (!HasBuildOperationStarted && !AiManager.nav_disable)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			Debug.Log((object)("Starting Navmesh Build with " + sources.Count + " sources"));
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
			((NavMeshBuildSettings)(ref settingsByIndex)).overrideVoxelSize = true;
			((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize = ((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize * 2f;
			BuildingOperation = NavMeshBuilder.UpdateNavMeshDataAsync(NavMeshData, settingsByIndex, sources, Bounds);
			BuildTimer.Reset();
			BuildTimer.Start();
			HasBuildOperationStarted = true;
			float num = Time.realtimeSinceStartup - realtimeSinceStartup;
			if (num > 0.1f)
			{
				Debug.LogWarning((object)("Calling UpdateNavMesh took " + num));
			}
		}
	}

	public IEnumerator UpdateNavMeshAndWait()
	{
		if (HasBuildOperationStarted || AiManager.nav_disable)
		{
			yield break;
		}
		HasBuildOperationStarted = false;
		((Bounds)(ref Bounds)).size = TerrainMeta.Size;
		NavMesh.pathfindingIterationsPerFrame = AiManager.pathfindingIterationsPerFrame;
		IEnumerator enumerator = NavMeshTools.CollectSourcesAsync(Bounds, LayerMask.op_Implicit(LayerMask), NavMeshCollectGeometry, defaultArea, use_baked_terrain_mesh, AsyncTerrainNavMeshBakeCellSize, sources, AppendModifierVolumes, UpdateNavMeshAsync, null);
		if (AiManager.nav_wait)
		{
			yield return enumerator;
		}
		else
		{
			((MonoBehaviour)this).StartCoroutine(enumerator);
		}
		if (!AiManager.nav_wait)
		{
			Debug.Log((object)"nav_wait is false, so we're not waiting for the navmesh to finish generating. This might cause your server to sputter while it's generating.");
			yield break;
		}
		int lastPct = 0;
		while (!HasBuildOperationStarted)
		{
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
		}
		while (BuildingOperation != null)
		{
			int num = (int)(BuildingOperation.progress * 100f);
			if (lastPct != num)
			{
				Debug.LogFormat("{0}%", new object[1] { num });
				lastPct = num;
			}
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
			FinishBuildingNavmesh();
		}
	}

	private void AppendModifierVolumes(List<NavMeshBuildSource> sources)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 size = default(Vector3);
		foreach (NavMeshModifierVolume activeModifier in NavMeshModifierVolume.activeModifiers)
		{
			if ((LayerMask.op_Implicit(LayerMask) & (1 << ((Component)activeModifier).gameObject.layer)) != 0 && activeModifier.AffectsAgentType(agentTypeId))
			{
				Vector3 val = ((Component)activeModifier).transform.TransformPoint(activeModifier.center);
				Vector3 lossyScale = ((Component)activeModifier).transform.lossyScale;
				((Vector3)(ref size))..ctor(activeModifier.size.x * Mathf.Abs(lossyScale.x), activeModifier.size.y * Mathf.Abs(lossyScale.y), activeModifier.size.z * Mathf.Abs(lossyScale.z));
				NavMeshBuildSource item = default(NavMeshBuildSource);
				((NavMeshBuildSource)(ref item)).shape = (NavMeshBuildSourceShape)5;
				((NavMeshBuildSource)(ref item)).transform = Matrix4x4.TRS(val, ((Component)activeModifier).transform.rotation, Vector3.one);
				((NavMeshBuildSource)(ref item)).size = size;
				((NavMeshBuildSource)(ref item)).area = activeModifier.area;
				sources.Add(item);
			}
		}
	}

	public void FinishBuildingNavmesh()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (BuildingOperation != null && BuildingOperation.isDone)
		{
			if (!((NavMeshDataInstance)(ref NavMeshDataInstance)).valid)
			{
				NavMeshDataInstance = NavMesh.AddNavMeshData(NavMeshData);
			}
			Debug.Log((object)$"Navmesh Build took {BuildTimer.Elapsed.TotalSeconds:0.00} seconds");
			BuildingOperation = null;
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class Eqs
{
	public sealed class PooledScoreList : BasePooledList<(Vector3 pos, float score), PooledScoreList>
	{
		public void SortByScoreDesc(BaseEntity baseEntity = null)
		{
			TimeWarning val = TimeWarning.New("SortByScoreDesc", 0);
			try
			{
				((List<(Vector3, float)>)(object)this).Sort((Comparison<(Vector3, float)>)(((Vector3 pos, float score) a, (Vector3 pos, float score) b) => b.score.CompareTo(a.score)));
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public void Reorder(List<Vector3> positions)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("Reorder", 0);
			try
			{
				for (int i = 0; i < positions.Count; i++)
				{
					positions[i] = ((List<(Vector3, float)>)(object)this)[i].Item1;
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static void SamplePositionsInDonutShape(Vector3 center, List<Vector3> sampledPositions, float radius = 10f, int numRings = 1, int itemsPerRing = 8)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePositionsInDonutShape", 0);
		try
		{
			for (int i = 0; i < itemsPerRing; i++)
			{
				float num = MathF.PI * 2f * (float)i / (float)itemsPerRing;
				Vector3 item = center + new Vector3(Mathf.Cos(num), 0f, Mathf.Sin(num)) * radius;
				sampledPositions.Add(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void SamplePositionsInMultiDonutShape(Vector3 center, List<Vector3> sampledPositions, float outerRadius = 10f, float innerRadius = 10f, int numRings = 1, int itemsPerRing = 8)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePositionsInMultiDonutShape", 0);
		try
		{
			for (int i = 0; i < numRings; i++)
			{
				float num = ((numRings != 1) ? Mathf.Lerp(innerRadius, outerRadius, (float)i / (float)(numRings - 1)) : outerRadius);
				for (int j = 0; j < itemsPerRing; j++)
				{
					float num2 = (float)i * MathF.PI / (float)numRings;
					float num3 = MathF.PI * 2f * (float)j / (float)itemsPerRing + num2;
					Vector3 item = center + new Vector3(Mathf.Cos(num3), 0f, Mathf.Sin(num3)) * num;
					sampledPositions.Add(item);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public sealed class PooledScoreList : BasePooledList<(Vector3 pos, float score), PooledScoreList>
{
	public void SortByScoreDesc(BaseEntity baseEntity = null)
	{
		TimeWarning val = TimeWarning.New("SortByScoreDesc", 0);
		try
		{
			((List<(Vector3, float)>)(object)this).Sort((Comparison<(Vector3, float)>)(((Vector3 pos, float score) a, (Vector3 pos, float score) b) => b.score.CompareTo(a.score)));
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Reorder(List<Vector3> positions)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Reorder", 0);
		try
		{
			for (int i = 0; i < positions.Count; i++)
			{
				positions[i] = ((List<(Vector3, float)>)(object)this)[i].Item1;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Rust;
using Rust.Ai;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class MonumentNavMesh : FacepunchBehaviour, IServerComponent
{
	public int NavMeshAgentTypeIndex;

	[Tooltip("The default area associated with the NavMeshAgent index.")]
	public string DefaultAreaName = "HumanNPC";

	[Tooltip("How many cells to use squared")]
	public int CellCount = 1;

	[Tooltip("The size of each cell for async object gathering")]
	public int CellSize = 80;

	public int Height = 100;

	public float NavmeshResolutionModifier = 0.5f;

	[Tooltip("Use the bounds specified in editor instead of generating it from cellsize * cellcount")]
	public bool overrideAutoBounds;

	[Tooltip("Bounds which are auto calculated from CellSize * CellCount")]
	public Bounds Bounds;

	public NavMeshData NavMeshData;

	public NavMeshDataInstance NavMeshDataInstance;

	public LayerMask LayerMask;

	public NavMeshCollectGeometry NavMeshCollectGeometry;

	public bool forceCollectTerrain;

	public bool shouldNotifyAIZones = true;

	public Transform CustomNavMeshRoot;

	public bool IgnoreTerrain;

	[ServerVar]
	public static bool use_baked_terrain_mesh = true;

	private List<NavMeshBuildSource> sources;

	private AsyncOperation BuildingOperation;

	private bool HasBuildOperationStarted;

	private Stopwatch BuildTimer = new Stopwatch();

	private int defaultArea;

	private int agentTypeId;

	public bool IsBuilding
	{
		get
		{
			if (!HasBuildOperationStarted || BuildingOperation != null)
			{
				return true;
			}
			return false;
		}
	}

	private void OnEnable()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
		agentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		NavMeshData = new NavMeshData(agentTypeId);
		sources = new List<NavMeshBuildSource>();
		defaultArea = NavMesh.GetAreaFromName(DefaultAreaName);
		((FacepunchBehaviour)this).InvokeRepeating((Action)FinishBuildingNavmesh, 0f, 1f);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FinishBuildingNavmesh);
			((NavMeshDataInstance)(ref NavMeshDataInstance)).Remove();
		}
	}

	[ContextMenu("Update Monument Nav Mesh")]
	public void UpdateNavMeshAsync()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (!HasBuildOperationStarted && !AiManager.nav_disable && AI.npc_enable)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			Debug.Log((object)("Starting Monument Navmesh Build with " + sources.Count + " sources"));
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
			((NavMeshBuildSettings)(ref settingsByIndex)).overrideVoxelSize = true;
			((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize = ((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize * NavmeshResolutionModifier;
			BuildingOperation = NavMeshBuilder.UpdateNavMeshDataAsync(NavMeshData, settingsByIndex, sources, Bounds);
			BuildTimer.Reset();
			BuildTimer.Start();
			HasBuildOperationStarted = true;
			float num = Time.realtimeSinceStartup - realtimeSinceStartup;
			if (num > 0.1f)
			{
				Debug.LogWarning((object)("Calling UpdateNavMesh took " + num));
			}
			if (shouldNotifyAIZones)
			{
				NotifyInformationZonesOfCompletion();
			}
		}
	}

	public IEnumerator UpdateNavMeshAndWait()
	{
		if (HasBuildOperationStarted || AiManager.nav_disable || !AI.npc_enable)
		{
			yield break;
		}
		HasBuildOperationStarted = false;
		((Bounds)(ref Bounds)).center = ((Component)this).transform.position;
		if (!overrideAutoBounds)
		{
			((Bounds)(ref Bounds)).size = new Vector3((float)(CellSize * CellCount), (float)Height, (float)(CellSize * CellCount));
		}
		IEnumerator enumerator = NavMeshTools.CollectSourcesAsync(Bounds, LayerMask.op_Implicit(LayerMask), NavMeshCollectGeometry, defaultArea, use_baked_terrain_mesh && !forceCollectTerrain && !IgnoreTerrain, CellSize, sources, AppendModifierVolumes, UpdateNavMeshAsync, CustomNavMeshRoot);
		if (AiManager.nav_wait)
		{
			yield return enumerator;
		}
		else
		{
			((MonoBehaviour)this).StartCoroutine(enumerator);
		}
		if (!AiManager.nav_wait)
		{
			Debug.Log((object)"nav_wait is false, so we're not waiting for the navmesh to finish generating. This might cause your server to sputter while it's generating.");
			yield break;
		}
		int lastPct = 0;
		while (!HasBuildOperationStarted)
		{
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
		}
		while (BuildingOperation != null)
		{
			int num = (int)(BuildingOperation.progress * 100f);
			if (lastPct != num)
			{
				Debug.LogFormat("{0}%", new object[1] { num });
				lastPct = num;
			}
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
			FinishBuildingNavmesh();
		}
	}

	public void NotifyInformationZonesOfCompletion()
	{
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			zone.NavmeshBuildingComplete();
		}
	}

	private void AppendModifierVolumes(List<NavMeshBuildSource> sources)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		Vector3 size = default(Vector3);
		foreach (NavMeshModifierVolume activeModifier in NavMeshModifierVolume.activeModifiers)
		{
			if ((LayerMask.op_Implicit(LayerMask) & (1 << ((Component)activeModifier).gameObject.layer)) != 0 && activeModifier.AffectsAgentType(agentTypeId))
			{
				Vector3 val = ((Component)activeModifier).transform.TransformPoint(activeModifier.center);
				if (((Bounds)(ref Bounds)).Contains(val))
				{
					Vector3 lossyScale = ((Component)activeModifier).transform.lossyScale;
					((Vector3)(ref size))..ctor(activeModifier.size.x * Mathf.Abs(lossyScale.x), activeModifier.size.y * Mathf.Abs(lossyScale.y), activeModifier.size.z * Mathf.Abs(lossyScale.z));
					NavMeshBuildSource item = default(NavMeshBuildSource);
					((NavMeshBuildSource)(ref item)).shape = (NavMeshBuildSourceShape)5;
					((NavMeshBuildSource)(ref item)).transform = Matrix4x4.TRS(val, ((Component)activeModifier).transform.rotation, Vector3.one);
					((NavMeshBuildSource)(ref item)).size = size;
					((NavMeshBuildSource)(ref item)).area = activeModifier.area;
					sources.Add(item);
				}
			}
		}
	}

	public void FinishBuildingNavmesh()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (BuildingOperation != null && BuildingOperation.isDone)
		{
			if (!((NavMeshDataInstance)(ref NavMeshDataInstance)).valid)
			{
				NavMeshDataInstance = NavMesh.AddNavMeshData(NavMeshData);
			}
			Debug.Log((object)$"Monument Navmesh Build took {BuildTimer.Elapsed.TotalSeconds:0.00} seconds");
			BuildingOperation = null;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public static class NavMeshTools
{
	public static IEnumerator CollectSourcesAsync(Bounds bounds, int mask, NavMeshCollectGeometry geometry, int area, bool useBakedTerrainMesh, int cellSize, List<NavMeshBuildSource> sources, Action<List<NavMeshBuildSource>> append, Action callback, Transform customNavMeshDataRoot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		while (!AI.move && !AiManager.nav_wait)
		{
			yield return CoroutineEx.waitForSeconds(1f);
		}
		if ((Object)(object)customNavMeshDataRoot != (Object)null)
		{
			((Component)customNavMeshDataRoot).gameObject.SetActive(true);
			yield return (object)new WaitForEndOfFrame();
		}
		float time = Time.realtimeSinceStartup;
		Debug.Log((object)"Starting Navmesh Source Collecting");
		mask = ((!useBakedTerrainMesh) ? (mask | 0x800000) : (mask & -8388609));
		List<NavMeshBuildMarkup> list = new List<NavMeshBuildMarkup>();
		NavMeshBuilder.CollectSources(bounds, mask, geometry, area, list, sources);
		if (useBakedTerrainMesh && (Object)(object)TerrainMeta.HeightMap != (Object)null)
		{
			for (float x = 0f - ((Bounds)(ref bounds)).extents.x; x < ((Bounds)(ref bounds)).extents.x - (float)(cellSize / 2); x += (float)cellSize)
			{
				for (float z = 0f - ((Bounds)(ref bounds)).extents.z; z < ((Bounds)(ref bounds)).extents.z - (float)(cellSize / 2); z += (float)cellSize)
				{
					AsyncTerrainNavMeshBake terrainSource = new AsyncTerrainNavMeshBake(new Vector3(x, 0f, z), cellSize, cellSize, normal: false, alpha: true);
					yield return terrainSource;
					sources.Add(terrainSource.CreateNavMeshBuildSource(area));
				}
			}
		}
		append?.Invoke(sources);
		Debug.Log((object)$"Navmesh Source Collecting took {Time.realtimeSinceStartup - time:0.00} seconds");
		if ((Object)(object)customNavMeshDataRoot != (Object)null)
		{
			((Component)customNavMeshDataRoot).gameObject.SetActive(false);
		}
		callback?.Invoke();
	}

	public static IEnumerator CollectSourcesAsync(Transform root, int mask, NavMeshCollectGeometry geometry, int area, List<NavMeshBuildSource> sources, Action<List<NavMeshBuildSource>> append, Action callback)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		while (!AI.move && !AiManager.nav_wait)
		{
			yield return CoroutineEx.waitForSeconds(1f);
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log((object)"Starting Navmesh Source Collecting");
		List<NavMeshBuildMarkup> list = new List<NavMeshBuildMarkup>();
		NavMeshBuilder.CollectSources(root, mask, geometry, area, list, sources);
		append?.Invoke(sources);
		Debug.Log((object)$"Navmesh Source Collecting took {Time.realtimeSinceStartup - realtimeSinceStartup:0.00} seconds");
		callback?.Invoke();
	}
}


using ConVar;
using UnityEngine;

public class NPCBarricadeTriggerBox : MonoBehaviour
{
	private Barricade target;

	private static int playerServerLayer = -1;

	public void Setup(Barricade t)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		target = t;
		((Component)this).transform.SetParent(((Component)target).transform, false);
		((Component)this).gameObject.layer = 18;
		BoxCollider obj = ((Component)this).gameObject.AddComponent<BoxCollider>();
		((Collider)obj).isTrigger = true;
		obj.center = Vector3.zero;
		obj.size = Vector3.one * AI.npc_door_trigger_size + Vector3.right * ((Bounds)(ref target.bounds)).size.x;
	}

	private void OnTriggerEnter(Collider other)
	{
		if ((Object)(object)target == (Object)null || target.isClient)
		{
			return;
		}
		if (playerServerLayer < 0)
		{
			playerServerLayer = LayerMask.NameToLayer("Player (Server)");
		}
		if ((((Component)other).gameObject.layer & playerServerLayer) > 0)
		{
			BasePlayer component = ((Component)other).gameObject.GetComponent<BasePlayer>();
			if ((Object)(object)component != (Object)null && component.IsNpc && !(component is BasePet))
			{
				target.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}
}


using ConVar;
using UnityEngine;

public class NPCDoorTriggerBox : MonoBehaviour
{
	private Door door;

	private static int playerServerLayer = -1;

	public void Setup(Door d)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		door = d;
		((Component)this).transform.SetParent(((Component)door).transform, false);
		((Component)this).gameObject.layer = 18;
		BoxCollider obj = ((Component)this).gameObject.AddComponent<BoxCollider>();
		((Collider)obj).isTrigger = true;
		obj.center = Vector3.zero;
		obj.size = Vector3.one * AI.npc_door_trigger_size;
	}

	private void OnTriggerEnter(Collider other)
	{
		if ((Object)(object)door == (Object)null || door.isClient || door.IsLocked() || (!door.isSecurityDoor && door.IsOpen()) || (door.isSecurityDoor && !door.IsOpen()))
		{
			return;
		}
		if (playerServerLayer < 0)
		{
			playerServerLayer = LayerMask.NameToLayer("Player (Server)");
		}
		if ((((Component)other).gameObject.layer & playerServerLayer) > 0)
		{
			BasePlayer component = ((Component)other).gameObject.GetComponent<BasePlayer>();
			if ((Object)(object)component != (Object)null && component.IsNpc && !door.isSecurityDoor)
			{
				door.SetOpen(open: true);
			}
		}
	}
}


using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class RealmedNavMeshObstacle : BasePrefab
{
	public NavMeshObstacle Obstacle;

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (bundling)
		{
			return;
		}
		base.PreProcess(process, rootObj, name, serverside, clientside, bundling: false);
		if (base.isServer && Object.op_Implicit((Object)(object)Obstacle))
		{
			if (AiManager.nav_disable)
			{
				process.RemoveComponent((Component)(object)Obstacle);
				Obstacle = null;
			}
			else if (AiManager.nav_obstacles_carve_state >= 2)
			{
				Obstacle.carving = true;
			}
			else if (AiManager.nav_obstacles_carve_state == 1)
			{
				Obstacle.carving = ((Component)Obstacle).gameObject.layer == 21;
			}
			else
			{
				Obstacle.carving = false;
			}
		}
		process.RemoveComponent((Component)(object)this);
	}
}


using System;
using UnityEngine;

public class BaseAnimalNPC : BaseNpc, IAIAttack, IAITirednessAbove, IAISleep, IAIHungerAbove, IAISenses, IThinker
{
	public string deathStatName = "";

	public AnimalBrain brain;

	private TimeSince lastBrainError;

	public override void ServerInit()
	{
		base.ServerInit();
		brain = ((Component)this).GetComponent<AnimalBrain>();
		if (!base.isClient)
		{
			AIThinkManager.AddAnimal(this);
		}
	}

	internal override void DoServerDestroy()
	{
		if (!base.isClient)
		{
			AIThinkManager.RemoveAnimal(this);
			base.DoServerDestroy();
		}
	}

	public virtual void TryThink()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)brain != (Object)null && HasBrain && brain.ShouldServerThink())
		{
			brain.DoThink();
		}
		else if ((Object)(object)brain == (Object)null && TimeSince.op_Implicit(lastBrainError) > 10f)
		{
			lastBrainError = TimeSince.op_Implicit(0f);
			Debug.LogWarning((object)(((Object)((Component)this).gameObject).name + " is missing a brain"));
		}
	}

	public override void OnDied(HitInfo hitInfo = null)
	{
		if (hitInfo != null)
		{
			BasePlayer initiatorPlayer = hitInfo.InitiatorPlayer;
			if ((Object)(object)initiatorPlayer != (Object)null)
			{
				initiatorPlayer.GiveAchievement("KILL_ANIMAL");
				if (!string.IsNullOrEmpty(deathStatName))
				{
					initiatorPlayer.stats.Add(deathStatName, 1, (Stats)5);
					initiatorPlayer.stats.Save();
				}
				initiatorPlayer.LifeStoryKill(this);
			}
		}
		base.OnDied((HitInfo)null);
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer && Object.op_Implicit((Object)(object)info.InitiatorPlayer) && !info.damageTypes.IsMeleeType())
		{
			info.InitiatorPlayer.LifeStoryShotHit(info.Weapon);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Kill();
	}

	public bool CanAttack(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (NeedsToReload())
		{
			return false;
		}
		if (IsOnCooldown())
		{
			return false;
		}
		if (!IsTargetInRange(entity, out var _))
		{
			return false;
		}
		if (!CanSeeTarget(entity))
		{
			return false;
		}
		BasePlayer basePlayer = entity as BasePlayer;
		BaseVehicle baseVehicle = (((Object)(object)basePlayer != (Object)null) ? basePlayer.GetMountedVehicle() : null);
		if ((Object)(object)baseVehicle != (Object)null && baseVehicle is BaseModularVehicle)
		{
			return false;
		}
		return true;
	}

	public bool NeedsToReload()
	{
		return false;
	}

	public float EngagementRange()
	{
		return AttackRange * brain.AttackRangeMultiplier;
	}

	public bool IsTargetInRange(BaseEntity entity, out float dist)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		dist = Vector3.Distance(((Component)entity).transform.position, base.AttackPosition);
		return dist <= EngagementRange();
	}

	public bool CanSeeTarget(BaseEntity entity)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.IsVisible(GetEntity().CenterPoint(), entity.CenterPoint());
	}

	public bool Reload()
	{
		throw new NotImplementedException();
	}

	public bool StartAttacking(BaseEntity target)
	{
		BaseCombatEntity baseCombatEntity = target as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity == (Object)null)
		{
			return false;
		}
		Attack(baseCombatEntity);
		return true;
	}

	public void StopAttacking()
	{
	}

	public float CooldownDuration()
	{
		return AttackRate;
	}

	public bool IsOnCooldown()
	{
		return !AttackReady();
	}

	public bool IsTirednessAbove(float value)
	{
		return 1f - Sleep > value;
	}

	public void StartSleeping()
	{
		SetFact(Facts.IsSleeping, 1);
	}

	public void StopSleeping()
	{
		SetFact(Facts.IsSleeping, 0);
	}

	public bool IsHungerAbove(float value)
	{
		return 1f - Energy.Level > value;
	}

	public bool IsThreat(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null)
		{
			if (baseNpc.Stats.Family == Stats.Family)
			{
				return false;
			}
			return IsAfraidOf(baseNpc.Stats.Family);
		}
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			return IsAfraidOf(basePlayer.Family);
		}
		return false;
	}

	public bool IsTarget(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null && baseNpc.Stats.Family == Stats.Family)
		{
			return false;
		}
		return !IsThreat(entity);
	}

	public bool IsFriendly(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.prefabID == prefabID;
	}

	public float GetAmmoFraction()
	{
		return 1f;
	}

	public BaseEntity GetBestTarget()
	{
		return null;
	}

	public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
	{
	}
}


using UnityEngine;

public class BaseFishNPC : BaseNpc, IAIAttack, IAISenses, IThinker
{
	protected FishBrain brain;

	public override void ServerInit()
	{
		base.ServerInit();
		brain = ((Component)this).GetComponent<FishBrain>();
		if (!base.isClient)
		{
			AIThinkManager.AddAnimal(this);
		}
	}

	internal override void DoServerDestroy()
	{
		if (!base.isClient)
		{
			AIThinkManager.RemoveAnimal(this);
			base.DoServerDestroy();
		}
	}

	public virtual void TryThink()
	{
		if (brain.ShouldServerThink())
		{
			brain.DoThink();
		}
	}

	public bool CanAttack(BaseEntity entity)
	{
		if (IsOnCooldown())
		{
			return false;
		}
		if (!IsTargetInRange(entity, out var _))
		{
			return false;
		}
		if (!CanSeeTarget(entity))
		{
			return false;
		}
		return true;
	}

	public bool NeedsToReload()
	{
		return false;
	}

	public float EngagementRange()
	{
		return AttackRange * brain.AttackRangeMultiplier;
	}

	public bool IsTargetInRange(BaseEntity entity, out float dist)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		dist = Vector3.Distance(((Component)entity).transform.position, base.AttackPosition);
		return dist <= EngagementRange();
	}

	public bool CanSeeTarget(BaseEntity entity)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.IsVisible(GetEntity().CenterPoint(), entity.CenterPoint());
	}

	public bool Reload()
	{
		return true;
	}

	public bool StartAttacking(BaseEntity target)
	{
		BaseCombatEntity baseCombatEntity = target as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity == (Object)null)
		{
			return false;
		}
		Attack(baseCombatEntity);
		return true;
	}

	public void StopAttacking()
	{
	}

	public float CooldownDuration()
	{
		return AttackRate;
	}

	public bool IsOnCooldown()
	{
		return !AttackReady();
	}

	public bool IsThreat(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null)
		{
			if (baseNpc.Stats.Family == Stats.Family)
			{
				return false;
			}
			return IsAfraidOf(baseNpc.Stats.Family);
		}
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			return IsAfraidOf(basePlayer.Family);
		}
		return false;
	}

	public bool IsTarget(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null && baseNpc.Stats.Family == Stats.Family)
		{
			return false;
		}
		return !IsThreat(entity);
	}

	public bool IsFriendly(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.prefabID == prefabID;
	}

	public float GetAmmoFraction()
	{
		return 1f;
	}

	public BaseEntity GetBestTarget()
	{
		return null;
	}

	public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
	{
	}
}


using System;
using UnityEngine;

[Serializable]
public struct StateTimer
{
	public float ReleaseTime;

	public Action OnFinished;

	public bool IsActive
	{
		get
		{
			bool num = ReleaseTime > Time.time;
			if (!num && OnFinished != null)
			{
				OnFinished();
				OnFinished = null;
			}
			return num;
		}
	}

	public void Activate(float seconds, Action onFinished = null)
	{
		ReleaseTime = Time.time + seconds;
		OnFinished = onFinished;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct VitalLevel
{
	public float Level;

	private float lastUsedTime;

	public float TimeSinceUsed => Time.time - lastUsedTime;

	internal void Add(float f)
	{
		Level += f;
		if (Level > 1f)
		{
			Level = 1f;
		}
		if (Level < 0f)
		{
			Level = 0f;
		}
	}

	internal void Use(float f)
	{
		if (!Mathf.Approximately(f, 0f))
		{
			Level -= Mathf.Abs(f);
			if (Level < 0f)
			{
				Level = 0f;
			}
			lastUsedTime = Time.time;
		}
	}
}


using ConVar;
using UnityEngine;
using UnityEngine.AI;

public class NPCNavigator : BaseNavigator
{
	public int DestroyOnFailedSampleCount = 5;

	private int sampleFailCount;

	public BaseNpc NPC { get; private set; }

	public override void Init(BaseCombatEntity entity, NavMeshAgent agent)
	{
		base.Init(entity, agent);
		NPC = entity as BaseNpc;
		sampleFailCount = 0;
	}

	public override void OnFailedToPlaceOnNavmesh()
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		base.OnFailedToPlaceOnNavmesh();
		if ((Object)(object)SingletonComponent<DynamicNavMesh>.Instance == (Object)null || SingletonComponent<DynamicNavMesh>.Instance.IsBuilding)
		{
			return;
		}
		sampleFailCount++;
		if (DestroyOnFailedSampleCount > 0 && sampleFailCount >= DestroyOnFailedSampleCount)
		{
			string[] obj = new string[6]
			{
				"Failed to sample navmesh ",
				sampleFailCount.ToString(),
				" times in a row at: ",
				null,
				null,
				null
			};
			Vector3 position = ((Component)this).transform.position;
			obj[3] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
			obj[4] = ". Destroying: ";
			obj[5] = ((Object)((Component)this).gameObject).name;
			Debug.LogWarning((object)string.Concat(obj));
			if ((Object)(object)NPC != (Object)null && !NPC.IsDestroyed)
			{
				NPC.Kill();
			}
		}
	}

	public override void OnPlacedOnNavmesh()
	{
		base.OnPlacedOnNavmesh();
		sampleFailCount = 0;
	}

	protected override bool CanEnableNavMeshNavigation()
	{
		if (!base.CanEnableNavMeshNavigation())
		{
			return false;
		}
		return true;
	}

	protected override bool CanUpdateMovement()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanUpdateMovement())
		{
			return false;
		}
		if ((Object)(object)NPC != (Object)null && (NPC.IsDormant || !NPC.syncPosition) && ((Behaviour)base.Agent).enabled)
		{
			SetDestination(NPC.ServerPosition);
			return false;
		}
		return true;
	}

	protected override void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		base.UpdatePositionAndRotation(moveToPosition, delta);
		UpdateRotation(moveToPosition, delta);
	}

	private void UpdateRotation(Vector3 moveToPosition, float delta)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		if (overrideFacingDirectionMode != 0)
		{
			return;
		}
		if (traversingNavMeshLink)
		{
			Vector3 val = base.Agent.destination - base.BaseEntity.ServerPosition;
			if (((Vector3)(ref val)).sqrMagnitude > 1f)
			{
				val = currentNavMeshLinkEndPos - base.BaseEntity.ServerPosition;
			}
			_ = ((Vector3)(ref val)).sqrMagnitude;
			_ = 0.001f;
			return;
		}
		Vector3 val2 = base.Agent.destination - base.BaseEntity.ServerPosition;
		if (((Vector3)(ref val2)).sqrMagnitude > 1f)
		{
			val2 = base.Agent.desiredVelocity;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			if (((Vector3)(ref normalized)).sqrMagnitude > 0.001f)
			{
				base.BaseEntity.ServerRotation = Quaternion.LookRotation(normalized);
			}
		}
	}

	public override void ApplyFacingDirectionOverride()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyFacingDirectionOverride();
		base.BaseEntity.ServerRotation = Quaternion.LookRotation(base.FacingDirectionOverride);
	}

	public override bool IsSwimming()
	{
		if (!AI.npcswimming)
		{
			return false;
		}
		if ((Object)(object)NPC != (Object)null)
		{
			return NPC.swimming;
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.AI;

public class NPCPlayerNavigator : BaseNavigator
{
	public NPCPlayer NPCPlayerEntity { get; private set; }

	public override void Init(BaseCombatEntity entity, NavMeshAgent agent)
	{
		base.Init(entity, agent);
		NPCPlayerEntity = entity as NPCPlayer;
	}

	protected override bool CanEnableNavMeshNavigation()
	{
		if (!base.CanEnableNavMeshNavigation())
		{
			return false;
		}
		if (NPCPlayerEntity.isMounted && !CanNavigateMounted)
		{
			return false;
		}
		return true;
	}

	protected override bool CanUpdateMovement()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanUpdateMovement())
		{
			return false;
		}
		if (NPCPlayerEntity.IsWounded())
		{
			return false;
		}
		if (base.CurrentNavigationType == NavigationType.NavMesh && (NPCPlayerEntity.IsDormant || !NPCPlayerEntity.syncPosition) && ((Behaviour)base.Agent).enabled)
		{
			SetDestination(NPCPlayerEntity.ServerPosition);
			return false;
		}
		return true;
	}

	protected override void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		base.UpdatePositionAndRotation(moveToPosition, delta);
		if (overrideFacingDirectionMode == OverrideFacingDirectionMode.None)
		{
			if (base.CurrentNavigationType == NavigationType.NavMesh)
			{
				NPCPlayer nPCPlayerEntity = NPCPlayerEntity;
				Vector3 desiredVelocity = base.Agent.desiredVelocity;
				nPCPlayerEntity.SetAimDirection(((Vector3)(ref desiredVelocity)).normalized);
			}
			else if (base.CurrentNavigationType == NavigationType.AStar || base.CurrentNavigationType == NavigationType.Base)
			{
				NPCPlayerEntity.SetAimDirection(Vector3Ex.Direction2D(moveToPosition, ((Component)this).transform.position));
			}
		}
	}

	public override void ApplyFacingDirectionOverride()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyFacingDirectionOverride();
		if (overrideFacingDirectionMode != 0 && !NPCPlayerEntity.IsUnityNull())
		{
			if (overrideFacingDirectionMode == OverrideFacingDirectionMode.Direction)
			{
				NPCPlayerEntity.SetAimDirection(facingDirectionOverride);
			}
			else if ((Object)(object)facingDirectionEntity != (Object)null)
			{
				Vector3 aimDirection = GetAimDirection(NPCPlayerEntity, facingDirectionEntity);
				facingDirectionOverride = aimDirection;
				NPCPlayerEntity.SetAimDirection(facingDirectionOverride);
			}
		}
	}

	private static Vector3 GetAimDirection(BasePlayer aimingPlayer, BaseEntity target)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		if (target.IsUnityNull())
		{
			return Vector3Ex.Direction2D(((Component)aimingPlayer).transform.position + (((Object)(object)aimingPlayer.eyes != (Object)null) ? aimingPlayer.eyes.BodyForward() : ((Component)aimingPlayer).transform.forward) * 1000f, ((Component)aimingPlayer).transform.position);
		}
		if (Vector3Ex.Distance2D(((Component)aimingPlayer).transform.position, ((Component)target).transform.position) <= 0.75f)
		{
			return Vector3Ex.Direction2D(((Component)target).transform.position, ((Component)aimingPlayer).transform.position);
		}
		Vector3 val = TargetAimPositionOffset(target) - (((Object)(object)aimingPlayer.eyes != (Object)null) ? aimingPlayer.eyes.position : ((Component)aimingPlayer).transform.position);
		return ((Vector3)(ref val)).normalized;
	}

	private static Vector3 TargetAimPositionOffset(BaseEntity target)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = target as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsSleeping() || basePlayer.IsWounded())
			{
				return ((Component)basePlayer).transform.position + Vector3.up * 0.1f;
			}
			if ((Object)(object)basePlayer.eyes != (Object)null)
			{
				return basePlayer.eyes.position - Vector3.up * 0.15f;
			}
		}
		return target.CenterPoint();
	}
}


using UnityEngine;

public class NPCPlayerNavigatorTester : BaseMonoBehaviour
{
	public BasePathNode TargetNode;

	private BasePathNode currentNode;

	private void Update()
	{
		if ((Object)(object)TargetNode != (Object)(object)currentNode)
		{
			((Component)this).GetComponent<BaseNavigator>().SetDestination(TargetNode.Path, TargetNode, 0.5f);
			currentNode = TargetNode;
		}
	}
}


using UnityEngine;

public class NavPathTester : MonoBehaviour
{
	[SerializeField]
	private Transform target;

	private void OnDrawGizmosSelected()
	{
		if (!((Object)(object)target == (Object)null) && ((Object)(object)((Component)target).GetComponent<NavPathTester>()).Is<NavPathTester>(out NavPathTester entAsT) && (Object)(object)entAsT.target == (Object)null)
		{
			entAsT.target = ((Component)this).transform;
		}
	}

	public static void GizmosDrawPath(Vector3[] corners, Color color)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		for (int i = 0; i < corners.Length - 1; i++)
		{
			Gizmos.DrawSphere(corners[i], 0.01f);
			Gizmos.DrawLine(corners[i], corners[i + 1]);
		}
		Gizmos.color = color2;
	}
}


using UnityEngine;
using UnityEngine.AI;

public static class NPCOverwatchSpot
{
	public static (Vector3 loc, Vector3 dir)? Find(Vector3[] corners)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		if (corners.Length < 3)
		{
			return null;
		}
		NavMeshHit val9 = default(NavMeshHit);
		RaycastHit val14 = default(RaycastHit);
		RaycastHit val15 = default(RaycastHit);
		for (int num = corners.Length - 1; num >= 2; num--)
		{
			Vector3 val = corners[num];
			Vector3 val2 = corners[num - 1];
			Vector3 val3 = corners[num - 2];
			Gizmos.color = Color.red;
			Vector3 val4 = Vector3Ex.NormalizeXZ(val - val2);
			Vector3 val5 = Vector3Ex.NormalizeXZ(val3 - val2);
			Vector3 val6 = -Vector3Ex.NormalizeXZ(val4 + val5);
			Gizmos.DrawLine(val2, val2 + val6);
			Gizmos.color = Color.blue;
			Vector3 val7 = val6 * 0.01f;
			val += val7;
			val2 += val7;
			Vector3 val8 = Vector3Ex.NormalizeXZ(val2 - val) * 100f;
			if (NavMesh.Raycast(val, val + val8, ref val9, -1))
			{
				Vector3 val10 = val;
				Vector3 val11 = val;
				Vector3 val12 = ((NavMeshHit)(ref val9)).position - val;
				Gizmos.DrawLine(val10, val11 + ((Vector3)(ref val12)).normalized * 100f);
				if (((NavMeshHit)(ref val9)).distance >= 7f)
				{
					Vector3 val13 = corners[^1];
					Vector3 position = ((NavMeshHit)(ref val9)).position;
					bool flag = Physics.Linecast(val13 + 1.7f * Vector3.up, position + 1.7f * Vector3.up, ref val14, 1218652417);
					Gizmos.color = Color.red;
					Gizmos.DrawLine(val13 + 1.7f * Vector3.up, position + 1.7f * Vector3.up);
					if (flag)
					{
						bool flag2 = Physics.Linecast(val13 + 0.2f * Vector3.up, position + 0.2f * Vector3.up, ref val15, 1218652417);
						Gizmos.DrawLine(val13 + 0.2f * Vector3.up, position + 0.2f * Vector3.up);
						if (flag2)
						{
							Gizmos.color = Color.blue;
							Gizmos.DrawWireSphere(((NavMeshHit)(ref val9)).position, 0.1f);
							Vector3 position2 = ((NavMeshHit)(ref val9)).position;
							val12 = val - ((NavMeshHit)(ref val9)).position;
							return (position2, ((Vector3)(ref val12)).normalized);
						}
					}
				}
			}
		}
		return null;
	}
}


using UnityEngine;
using UnityEngine.AI;

public static class NPCFlankSpot
{
	public readonly struct FlankRoute
	{
		public readonly Vector3 FlankPoint;

		public readonly NavMeshPath ToFlankPoint;

		public readonly NavMeshPath FromFlankPointToEnemy;

		public FlankRoute(Vector3 flankPoint, NavMeshPath toFlankPoint, NavMeshPath fromFlankPointToEnemy)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			FlankPoint = flankPoint;
			ToFlankPoint = toFlankPoint;
			FromFlankPointToEnemy = fromFlankPointToEnemy;
		}
	}

	public static bool Find(Vector3[] pathToEnemy, float pathDistance, out FlankRoute flank)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		flank = default(FlankRoute);
		if (!FindMiddlePoint(pathToEnemy, pathDistance, out var middlePoint, out var dir))
		{
			return false;
		}
		Gizmos.color = Color.white;
		Gizmos.DrawSphere(middlePoint, 0.1f);
		Vector3 val = dir * pathDistance * 0.5f;
		val.y = 0f;
		if (TryBuildFlankPath(pathToEnemy, middlePoint, middlePoint + Quaternion.AngleAxis(90f, Vector3.up) * val, out flank))
		{
			return true;
		}
		if (TryBuildFlankPath(pathToEnemy, middlePoint, middlePoint + Quaternion.AngleAxis(-90f, Vector3.up) * val, out flank))
		{
			return true;
		}
		return false;
	}

	private static bool TryBuildFlankPath(Vector3[] pathToEnemy, Vector3 pathMiddle, Vector3 approximateFlankPoint, out FlankRoute flank)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected O, but got Unknown
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Expected O, but got Unknown
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Expected O, but got Unknown
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.white;
		Gizmos.DrawLine(pathMiddle, approximateFlankPoint);
		flank = default(FlankRoute);
		NavMeshHit val = default(NavMeshHit);
		if (!NavMesh.SamplePosition(approximateFlankPoint, ref val, 10f, -1))
		{
			return false;
		}
		Gizmos.DrawLine(approximateFlankPoint, ((NavMeshHit)(ref val)).position);
		NavMeshPath val2 = new NavMeshPath();
		if (!NavMesh.CalculatePath(pathMiddle, ((NavMeshHit)(ref val)).position, -1, val2))
		{
			return false;
		}
		Vector3 val3 = val2.corners[^1];
		NavMeshPath val4 = new NavMeshPath();
		if (!NavMesh.CalculatePath(pathToEnemy[0], val3, -1, val4))
		{
			return false;
		}
		Vector3[] corners = val4.corners;
		NavMeshPath val5 = new NavMeshPath();
		if (!NavMesh.CalculatePath(val3, pathToEnemy[^1], -1, val5))
		{
			return false;
		}
		Vector3[] corners2 = val5.corners;
		if (!ArePathsDifferent(pathToEnemy, corners2))
		{
			NavPathTester.GizmosDrawPath(corners, Color.grey);
			NavPathTester.GizmosDrawPath(corners2, Color.yellow);
			return false;
		}
		if (!ArePathsDifferent(pathToEnemy, corners))
		{
			NavPathTester.GizmosDrawPath(corners, Color.yellow);
			NavPathTester.GizmosDrawPath(corners2, Color.grey);
			return false;
		}
		if (!ArePathsDifferent(corners, corners2))
		{
			NavPathTester.GizmosDrawPath(corners, Color.yellow);
			NavPathTester.GizmosDrawPath(corners2, Color.grey);
			return false;
		}
		if (Vector3.Angle(pathToEnemy[^1] - pathToEnemy[^2], corners2[^1] - corners2[^2]) < 30f)
		{
			NavPathTester.GizmosDrawPath(corners, Color.grey);
			NavPathTester.GizmosDrawPath(corners2, Color.red);
			return false;
		}
		flank = new FlankRoute(val3, val4, val5);
		return true;
	}

	private static bool ArePathsDifferent(Vector3[] path1, Vector3[] path2, float minRatio = 0.25f)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (path1.Length < 3 || path2.Length < 3)
		{
			if (!(path1[0] != path2[0]))
			{
				return path1[^1] != path2[^1];
			}
			return true;
		}
		int num = 0;
		for (int i = 1; i < path1.Length - 1; i++)
		{
			for (int j = 1; j < path2.Length - 1; j++)
			{
				if (path1[i] == path2[j])
				{
					num++;
					break;
				}
			}
		}
		int num2 = Mathf.Min(path1.Length - 2, path2.Length - 2);
		return (float)num / (float)num2 <= minRatio;
	}

	private static bool FindMiddlePoint(Vector3[] corners, float pathLength, out Vector3 middlePoint, out Vector3 dir)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		float num = pathLength * 0.5f;
		float num2 = 0f;
		for (int i = 0; i < corners.Length - 1; i++)
		{
			Vector3 val = corners[i];
			Vector3 val2 = corners[i + 1];
			float num3 = Vector3.Distance(val, val2);
			if (num2 + num3 >= num)
			{
				float num4 = (num - num2) / num3;
				middlePoint = Vector3.Lerp(val, val2, num4);
				Vector3 val3 = val2 - val;
				dir = ((Vector3)(ref val3)).normalized;
				return true;
			}
			num2 += num3;
		}
		middlePoint = default(Vector3);
		dir = default(Vector3);
		return false;
	}
}


using UnityEngine;
using UnityEngine.AI;

public readonly struct FlankRoute
{
	public readonly Vector3 FlankPoint;

	public readonly NavMeshPath ToFlankPoint;

	public readonly NavMeshPath FromFlankPointToEnemy;

	public FlankRoute(Vector3 flankPoint, NavMeshPath toFlankPoint, NavMeshPath fromFlankPointToEnemy)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		FlankPoint = flankPoint;
		ToFlankPoint = toFlankPoint;
		FromFlankPointToEnemy = fromFlankPointToEnemy;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

public static class NPCDynamicCover
{
	public static bool Find(Vector3 pos, Vector3 enemyPos, out NavMeshPath path, out Vector3 coverDir, float radius = 10f, int itemsPerRing = 8, float offset = 0f)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Expected O, but got Unknown
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		path = null;
		coverDir = default(Vector3);
		float num = Vector3.SignedAngle(enemyPos - pos, Vector3.forward, Vector3.up) * (MathF.PI / 180f) + offset;
		NavMeshHit val2 = default(NavMeshHit);
		for (int i = 0; i < itemsPerRing; i++)
		{
			float num2 = MathF.PI * -2f * (float)i / (float)itemsPerRing + num;
			Vector3 val = pos + new Vector3(Mathf.Cos(num2), 0f, Mathf.Sin(num2)) * radius;
			Gizmos.color = Color.white;
			Gizmos.DrawLine(pos, val);
			if (!NavMesh.SamplePosition(val, ref val2, 3f, -1))
			{
				continue;
			}
			Gizmos.DrawLine(val, ((NavMeshHit)(ref val2)).position);
			val = ((NavMeshHit)(ref val2)).position;
			Vector3 val3 = enemyPos - val;
			Vector3 val4 = Vector3.Cross(((Vector3)(ref val3)).normalized, Vector3.up) * 0.5f;
			if (IsPositionVisibleFrom(val + val4, enemyPos) || IsPositionVisibleFrom(val - val4, enemyPos))
			{
				continue;
			}
			if (path == null)
			{
				path = new NavMeshPath();
			}
			if (NavMesh.CalculatePath(pos, val, -1, path) && (int)path.status == 0)
			{
				Gizmos.color = Color.black;
				NavPathTester.GizmosDrawPath(path.corners, Color.black);
				if (!(path.GetPathLength() > radius * 2f))
				{
					Gizmos.color = Color.yellow;
					Gizmos.DrawSphere(val, 0.5f);
					val3 = enemyPos - val;
					coverDir = ((Vector3)(ref val3)).normalized;
					return true;
				}
			}
		}
		path = null;
		return false;
	}

	private static bool IsPositionVisibleFrom(Vector3 pos, Vector3 enemyPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.up * 1.7f;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Linecast(pos + val, enemyPos + val, ref val2, 1218652417))
		{
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(pos + val, ((RaycastHit)(ref val2)).point);
			Gizmos.DrawSphere(((RaycastHit)(ref val2)).point, 0.1f);
			Gizmos.color = Color.red;
			Gizmos.DrawLine(((RaycastHit)(ref val2)).point, enemyPos + val);
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class RootMotionData : BaseScriptableObject
{
	public AnimationCurve xMotionCurve;

	public AnimationCurve yMotionCurve;

	public AnimationCurve zMotionCurve;

	public AnimationCurve yRotationCurve;

	public AnimationClip inPlaceAnimation;
}


using UnityEngine;

public class TraceTester : MonoBehaviour
{
}


using UnityEngine;

public class WaterDepthTester : MonoBehaviour
{
	private void Update()
	{
	}
}


using UnityEngine;

public class WorkshopRenderSettings : MonoBehaviour
{
	public ItemDefinition ItemDefinition;

	public bool ToggleLightingRig;

	public Transform LightingRig;
}


using UnityEngine;

public class AccessbilityMaterialPropertyBlock : AccessibilityComponent
{
	public Renderer TargetRenderer;

	public string TagName;

	public AccessibilityColourCollection ForData;
}


public abstract class AccessibilityComponent : ListComponent<AccessibilityComponent>, IClientComponent
{
}


using UnityEngine;

public class AccessibilityDecalMaterial : AccessibilityComponent
{
	public DeferredDecal DecalRenderer;

	public AccessibilityMaterialCollection TargetData;

	public Material NightVisionTeaMaterial;
}


using UnityEngine.UI;

public class AccessibilityMaterialSprite : AccessibilityComponent
{
	public Image TargetImage;

	public AccessibilityMaterialCollection TargetData;
}


using UnityEngine;

public class AccessibilityMaterialSwap : AccessibilityComponent
{
	public AccessibilityMaterialCollection ForData;

	public Renderer ForRenderer;
}


public class AccessibilityMaterialSwap_NVG : AccessibilityMaterialSwap
{
}


using UnityEngine.UI;

public class AccessibilitySpriteColour : AccessibilityComponent
{
	public AccessibilityColourCollection TargetData;

	public Image SpriteA;

	public Image SpriteB;
}


public class AccessibilityCollection<T> : BaseScriptableObject
{
	public string convarName;

	public T[] AllOptions;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Accessibility/Colour Collection")]
public class AccessibilityColourCollection : AccessibilityCollection<AccessibilityColourCollection.ColourPair>
{
	[Serializable]
	public struct ColourPair
	{
		public Color A;

		public Color B;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ColourPair
{
	public Color A;

	public Color B;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Accessibility/Material Collection")]
public class AccessibilityMaterialCollection : AccessibilityCollection<AccessibilityMaterialCollection.MaterialOption>
{
	[Serializable]
	public struct MaterialOption
	{
		public Material TargetMaterial;

		public Color HudColour;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct MaterialOption
{
	public Material TargetMaterial;

	public Color HudColour;
}


public enum AIState
{
	None,
	Idle,
	Roam,
	Chase,
	Cover,
	Combat,
	Mounted,
	Exfil,
	Patrol,
	Orbit,
	Egress,
	Land,
	DropCrate,
	MoveTowards,
	Flee,
	Attack,
	Sleep,
	Reload,
	TakeCover,
	Dismounted,
	FollowPath,
	NavigateHome,
	CombatStationary,
	Cooldown,
	MoveToPoint,
	MoveToVector3,
	Blinded,
	KillSelf,
	MountAPC
}


public enum AIThinkMode
{
	FixedUpdate,
	Interval
}


using System;
using UnityEngine;

public class BasePathFinder
{
	private static Vector3[] preferedTopologySamples = (Vector3[])(object)new Vector3[4];

	private static Vector3[] topologySamples = (Vector3[])(object)new Vector3[4];

	private Vector3 chosenPosition;

	private const float halfPI = MathF.PI / 180f;

	public virtual Vector3 GetRandomPatrolPoint()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.zero;
	}

	public virtual AIMovePoint GetBestRoamPoint(Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float anchorClampDistance, float lookupMaxRange = 20f)
	{
		return null;
	}

	public void DebugDraw()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Color color = Gizmos.color;
		Gizmos.color = Color.green;
		Gizmos.DrawSphere(chosenPosition, 5f);
		Gizmos.color = Color.blue;
		Vector3[] array = topologySamples;
		for (int i = 0; i < array.Length; i++)
		{
			Gizmos.DrawSphere(array[i], 2.5f);
		}
		Gizmos.color = color;
	}

	public virtual Vector3 GetRandomPositionAround(Vector3 position, float minDistFrom = 0f, float maxDistFrom = 2f)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		if (maxDistFrom < 0f)
		{
			maxDistFrom = 0f;
		}
		Vector2 val = Random.insideUnitCircle * maxDistFrom;
		float num = Mathf.Clamp(Mathf.Max(Mathf.Abs(val.x), minDistFrom), minDistFrom, maxDistFrom) * Mathf.Sign(val.x);
		float num2 = Mathf.Clamp(Mathf.Max(Mathf.Abs(val.y), minDistFrom), minDistFrom, maxDistFrom) * Mathf.Sign(val.y);
		return position + new Vector3(num, 0f, num2);
	}

	public virtual Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		float radius = Random.Range(minRange, maxRange);
		int num = 0;
		int num2 = 0;
		float num3 = Random.Range(0f, 90f);
		for (float num4 = 0f; num4 < 360f; num4 += 90f)
		{
			Vector3 pointOnCircle = GetPointOnCircle(anchorPos, radius, num4 + num3);
			if (navigator.GetNearestNavmeshPosition(pointOnCircle, out var position, 10f) && navigator.IsPositionABiomeRequirement(position) && navigator.IsAcceptableWaterDepth(position) && !navigator.IsPositionPreventTopology(position))
			{
				topologySamples[num] = position;
				num++;
				if (navigator.IsPositionABiomePreference(position) && navigator.IsPositionATopologyPreference(position))
				{
					preferedTopologySamples[num2] = position;
					num2++;
				}
			}
		}
		if (num2 > 0)
		{
			chosenPosition = preferedTopologySamples[Random.Range(0, num2)];
		}
		else if (num > 0)
		{
			chosenPosition = topologySamples[Random.Range(0, num)];
		}
		else
		{
			chosenPosition = fallbackPos;
		}
		return chosenPosition;
	}

	public virtual Vector3 GetBestRoamPositionFromAnchor(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		float radius = Random.Range(minRange, maxRange);
		int num = 0;
		int num2 = 0;
		float num3 = Random.Range(0f, 90f);
		for (float num4 = 0f; num4 < 360f; num4 += 90f)
		{
			Vector3 pointOnCircle = GetPointOnCircle(anchorPos, radius, num4 + num3);
			if (navigator.GetNearestNavmeshPosition(pointOnCircle, out var position, 10f) && navigator.IsAcceptableWaterDepth(position))
			{
				topologySamples[num] = position;
				num++;
				if (navigator.IsPositionABiomePreference(position) && navigator.IsPositionATopologyPreference(position))
				{
					preferedTopologySamples[num2] = position;
					num2++;
				}
			}
		}
		if (Random.Range(0f, 1f) <= 0.9f && num2 > 0)
		{
			chosenPosition = preferedTopologySamples[Random.Range(0, num2)];
		}
		else if (num > 0)
		{
			chosenPosition = topologySamples[Random.Range(0, num)];
		}
		else
		{
			chosenPosition = fallbackPos;
		}
		return chosenPosition;
	}

	public virtual bool GetBestFleePosition(BaseNavigator navigator, AIBrainSenses senses, BaseEntity fleeFrom, Vector3 fallbackPos, float minRange, float maxRange, out Vector3 result)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)fleeFrom == (Object)null)
		{
			result = ((Component)navigator).transform.position;
			return false;
		}
		Vector3 dirFromThreat = Vector3Ex.Direction2D(((Component)navigator).transform.position, ((Component)fleeFrom).transform.position);
		if (TestFleeDirection(navigator, dirFromThreat, 0f, minRange, maxRange, out result))
		{
			return true;
		}
		bool flag = Random.Range(0, 2) == 1;
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 45f : 315f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 315f : 45f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 90f : 270f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 270f : 90f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, 135f + Random.Range(0f, 90f), minRange, maxRange, out result))
		{
			return true;
		}
		return false;
	}

	private bool TestFleeDirection(BaseNavigator navigator, Vector3 dirFromThreat, float offsetDegrees, float minRange, float maxRange, out Vector3 result)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		result = ((Component)navigator).transform.position;
		Vector3 val = Quaternion.Euler(0f, offsetDegrees, 0f) * dirFromThreat;
		Vector3 target = ((Component)navigator).transform.position + val * Random.Range(minRange, maxRange);
		if (!navigator.GetNearestNavmeshPosition(target, out var position, 20f))
		{
			return false;
		}
		if (!navigator.IsAcceptableWaterDepth(position))
		{
			return false;
		}
		result = position;
		return true;
	}

	public static Vector3 GetPointOnCircle(Vector3 center, float radius, float degrees)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		float num = center.x + radius * Mathf.Cos(degrees * (MathF.PI / 180f));
		float num2 = center.z + radius * Mathf.Sin(degrees * (MathF.PI / 180f));
		return new Vector3(num, center.y, num2);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class UnderwaterPathFinder : BasePathFinder
{
	private BaseEntity npc;

	public void Init(BaseEntity npc)
	{
		this.npc = npc;
	}

	public override Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		List<Vector3> list = Pool.Get<List<Vector3>>();
		(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(((Component)navigator).transform.position, waves: false, volumes: false);
		float item = waterAndTerrainSurface.Item1;
		float item2 = waterAndTerrainSurface.Item2;
		for (int i = 0; i < 8; i++)
		{
			Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(fallbackPos, Random.Range(1f, navigator.MaxRoamDistanceFromHome), Random.Range(0f, 359f));
			pointOnCircle.y += Random.Range(-2f, 2f);
			pointOnCircle.y = Mathf.Clamp(pointOnCircle.y, item2, item);
			list.Add(pointOnCircle);
		}
		float num = -1f;
		int num2 = -1;
		for (int j = 0; j < list.Count; j++)
		{
			Vector3 val = list[j];
			if (npc.IsVisible(val))
			{
				float num3 = 0f;
				Vector3 val2 = Vector3Ex.Direction2D(val, ((Component)navigator).transform.position);
				float num4 = Vector3.Dot(((Component)navigator).transform.forward, val2);
				num3 += Mathf.InverseLerp(0.25f, 0.8f, num4) * 5f;
				float num5 = Mathf.Abs(val.y - ((Component)navigator).transform.position.y);
				num3 += 1f - Mathf.InverseLerp(1f, 3f, num5) * 5f;
				if (num3 > num || num2 == -1)
				{
					num = num3;
					num2 = j;
				}
			}
		}
		Vector3 result = list[num2];
		Pool.FreeUnmanaged<Vector3>(ref list);
		return result;
	}

	public override bool GetBestFleePosition(BaseNavigator navigator, AIBrainSenses senses, BaseEntity fleeFrom, Vector3 fallbackPos, float minRange, float maxRange, out Vector3 result)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)fleeFrom == (Object)null)
		{
			result = ((Component)navigator).transform.position;
			return false;
		}
		Vector3 val = Vector3Ex.Direction2D(((Component)navigator).transform.position, ((Component)fleeFrom).transform.position);
		result = ((Component)navigator).transform.position + val * Random.Range(minRange, maxRange);
		return true;
	}
}


using UnityEngine;

public class AimConeUtil
{
	public static Vector3 GetModifiedAimConeDirection(float aimCone, Vector3 inputVec, bool anywhereInside = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.LookRotation(inputVec);
		aimCone = Mathf.Max(aimCone, 0f);
		Vector2 val2;
		if (!anywhereInside)
		{
			Vector2 insideUnitCircle = Random.insideUnitCircle;
			val2 = ((Vector2)(ref insideUnitCircle)).normalized;
		}
		else
		{
			val2 = Random.insideUnitCircle;
		}
		Vector2 val3 = val2;
		return val * Quaternion.Euler(val3.x * aimCone * 0.5f, val3.y * aimCone * 0.5f, 0f) * Vector3.forward;
	}

	public static Quaternion GetAimConeQuat(float aimCone)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 insideUnitSphere = Random.insideUnitSphere;
		return Quaternion.Euler(insideUnitSphere.x * aimCone * 0.5f, insideUnitSphere.y * aimCone * 0.5f, 0f);
	}
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch.Network.Raknet;
using Facepunch.Rust;
using Network;

public static class PlayerNetworkingProfiler
{
	public static int level = 0;

	public static TimeSpan MinFlushInterval = TimeSpan.FromSeconds(1.0);

	public static int ConnectionsPerFrame = 30;

	private static int currentIndex;

	private static DateTime flushCooldown;

	public static void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp)
	{
		if (level == 0)
		{
			return;
		}
		if (currentIndex >= Net.sv.connections.Count)
		{
			if (flushCooldown > DateTime.UtcNow)
			{
				return;
			}
			flushCooldown = DateTime.UtcNow + MinFlushInterval;
			currentIndex = 0;
		}
		Server sv = Net.sv;
		Server val = (Server)(object)((sv is Server) ? sv : null);
		if (val != null)
		{
			SerializeRaknet(uploader, frameIndex, timestamp, val);
		}
	}

	private static void SerializeRaknet(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp, Server server)
	{
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		int num = Math.Min(((Server)server).connections.Count, currentIndex + ConnectionsPerFrame);
		RaknetStats val2 = default(RaknetStats);
		while (currentIndex < num)
		{
			Connection val = ((Server)server).connections[currentIndex];
			if (server.TryGetConnectionStats(val, ref val2))
			{
				string ipaddress = val.ipaddress;
				string value = ipaddress.Split(':')[0];
				string value2 = ipaddress.Split(':')[1];
				int latestPing = server.GetLatestPing(val);
				EventRecord eventRecord = EventRecord.CSV().AddField("", timestamp).AddField("", frameIndex)
					.AddField("", Server.server_id)
					.AddField("", val.guid)
					.AddField("", val.userid)
					.AddField("", value)
					.AddField("", value2)
					.AddField("", latestPing)
					.AddField("", val2.connectionStartTime)
					.AddField("", val2.isLimitedByCongestionControl)
					.AddField("", val2.isLimitedByOutgoingBandwidthLimit)
					.AddField("", val2.BPSLimitByCongestionControl)
					.AddField("", val2.BPSLimitByOutgoingBandwidthLimit)
					.AddField("", val2.messagesInResendBuffer)
					.AddField("", val2.bytesInResendBuffer)
					.AddField("", val2.packetlossLastSecond)
					.AddField("", val2.packetlossTotal);
				for (int i = 0; i < 4; i++)
				{
					eventRecord.AddField("", (ulong)Unsafe.Add(ref val2.bytesInSendBuffer.FixedElementField, i));
				}
				for (int j = 0; j < 4; j++)
				{
					eventRecord.AddField("", (ulong)Unsafe.Add(ref val2.messageInSendBuffer.FixedElementField, j));
				}
				eventRecord.AddField("", val2.runningTotal.FixedElementField);
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 1));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 2));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 3));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 4));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 5));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 6));
				uploader.Append(eventRecord);
			}
			currentIndex++;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

public static class TypeNameCache
{
	private static Dictionary<Type, string> cache = new Dictionary<Type, string>();

	private static Regex genericPrefixRegex = new Regex("`\\d+\\[");

	public static string GetName(Type type)
	{
		if (!cache.TryGetValue(type, out var value))
		{
			value = CalculateName(type);
			cache[type] = value;
		}
		return value;
	}

	private static string CalculateName(Type type)
	{
		string input = type.ToString();
		input = genericPrefixRegex.Replace(input, "<");
		return input.Replace("]", ">");
	}

	public static void ClearCache()
	{
		cache.Clear();
	}
}


using System;
using UnityEngine;

public class HorseIdleMultiConditionCrossfade : StateMachineBehaviour
{
	[Serializable]
	public struct Condition
	{
		public enum CondtionOperator
		{
			GreaterThan,
			LessThan
		}

		public int FloatParameter;

		public CondtionOperator Operator;

		public float Value;
	}

	public string TargetState = "breathe";

	public float NormalizedTransitionDuration = 0.1f;
}


using System;

[Serializable]
public struct Condition
{
	public enum CondtionOperator
	{
		GreaterThan,
		LessThan
	}

	public int FloatParameter;

	public CondtionOperator Operator;

	public float Value;
}


public enum CondtionOperator
{
	GreaterThan,
	LessThan
}


using UnityEngine;

public class TriggerResetter : StateMachineBehaviour
{
	public string triggerName;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Invalid comparison between Unknown and I4
		AnimatorControllerParameter[] parameters = animator.parameters;
		foreach (AnimatorControllerParameter val in parameters)
		{
			if ((int)val.type == 9 && val.name == triggerName)
			{
				animator.ResetTrigger(val.name);
			}
		}
	}
}


using System;
using UnityEngine;

public class WeightedAnimationRandomiser : StateMachineBehaviour
{
	[Serializable]
	public struct IdleChance
	{
		public string StateName;

		[Range(0f, 100f)]
		public int Chance;
	}

	public int LoopRangeMin = 3;

	public int LoopRangeMax = 5;

	public float NormalizedTransitionDuration;

	public IdleChance[] IdleTransitions = new IdleChance[0];

	public bool AllowRepeats;
}


using System;
using UnityEngine;

[Serializable]
public struct IdleChance
{
	public string StateName;

	[Range(0f, 100f)]
	public int Chance;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Ambience Definition")]
public class AmbienceDefinition : ScriptableObject
{
	[Serializable]
	public class ValueRange
	{
		public float min;

		public float max;

		public ValueRange(float min, float max)
		{
			this.min = min;
			this.max = max;
		}
	}

	[Header("Sound")]
	public List<SoundDefinition> sounds;

	[Horizontal(2, -1)]
	public ValueRange stingFrequency = new ValueRange(15f, 30f);

	[InspectorFlags]
	[Header("Environment")]
	public Enum biomes = (Enum)(-1);

	[InspectorFlags]
	public Enum topologies = (Enum)(-1);

	public EnvironmentType environmentType = EnvironmentType.Underground;

	public bool useEnvironmentType;

	public AnimationCurve time = AnimationCurve.Linear(0f, 0f, 24f, 0f);

	[Horizontal(2, -1)]
	public ValueRange rain = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange wind = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange snow = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange waves = new ValueRange(0f, 10f);
}


using System;

[Serializable]
public class ValueRange
{
	public float min;

	public float max;

	public ValueRange(float min, float max)
	{
		this.min = min;
		this.max = max;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Ambience Definition List")]
public class AmbienceDefinitionList : ScriptableObject
{
	public List<AmbienceDefinition> defs;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class AmbienceEmitter : MonoBehaviour, IClientComponent, IComparable<AmbienceEmitter>
{
	public AmbienceDefinitionList baseAmbience;

	public AmbienceDefinitionList stings;

	public bool isStatic = true;

	public bool followCamera;

	public bool isBaseEmitter;

	public bool active;

	public float cameraDistanceSq = float.PositiveInfinity;

	public BoundingSphere boundingSphere;

	public float crossfadeTime = 2f;

	public Dictionary<AmbienceDefinition, float> nextStingTime = new Dictionary<AmbienceDefinition, float>();

	public float deactivateTime = float.PositiveInfinity;

	public bool playUnderwater = true;

	public bool playAbovewater = true;

	public Enum currentTopology { get; private set; }

	public Enum currentBiome { get; private set; }

	public int CompareTo(AmbienceEmitter other)
	{
		return cameraDistanceSq.CompareTo(other.cameraDistanceSq);
	}
}


using UnityEngine;

public class AmbienceLocalStings : MonoBehaviour
{
	public float maxDistance = 100f;

	public float stingRadius = 10f;

	public float stingFrequency = 30f;

	public float stingFrequencyVariance = 15f;

	public SoundDefinition[] stingSounds;
}


using System;
using System.Collections.Generic;

public class AmbienceManager : SingletonComponent<AmbienceManager>, IClientComponent
{
	[Serializable]
	public class EmitterTypeLimit
	{
		public List<AmbienceDefinitionList> ambience;

		public int limit = 1;

		public int active;
	}

	public List<EmitterTypeLimit> localEmitterLimits = new List<EmitterTypeLimit>();

	public EmitterTypeLimit catchallEmitterLimit = new EmitterTypeLimit();

	public int maxActiveLocalEmitters = 5;

	public int activeLocalEmitters;

	public List<AmbienceEmitter> cameraEmitters = new List<AmbienceEmitter>();

	public List<AmbienceEmitter> emittersInRange = new List<AmbienceEmitter>();

	public List<AmbienceEmitter> activeEmitters = new List<AmbienceEmitter>();

	public float localEmitterRange = 30f;

	public List<AmbienceZone> currentAmbienceZones = new List<AmbienceZone>();

	public bool isUnderwater;

	public float ambienceZoneGain { get; private set; } = 1f;
}


using System;
using System.Collections.Generic;

[Serializable]
public class EmitterTypeLimit
{
	public List<AmbienceDefinitionList> ambience;

	public int limit = 1;

	public int active;
}


using UnityEngine;

public class AmbienceSpawnEmitters : MonoBehaviour, IClientComponent
{
	public int baseEmitterCount = 5;

	public int baseEmitterDistance = 10;

	public GameObjectRef emitterPrefab;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class AmbienceWaveSounds : SingletonComponent<AmbienceWaveSounds>, IClientComponent
{
	[Serializable]
	public class WaveLayer
	{
		public SoundDefinition soundDefinition;

		public AnimationCurve oceanScaleGainCurve;
	}

	public int emitterCount = 3;

	public float emitterDistance = 10f;

	public List<WaveLayer> waveLayers = new List<WaveLayer>();
}


using System;
using UnityEngine;

[Serializable]
public class WaveLayer
{
	public SoundDefinition soundDefinition;

	public AnimationCurve oceanScaleGainCurve;
}


using UnityEngine;

public class AmbienceWaveSoundZone : TriggerBase, IClientComponentEx
{
	public float priority;

	public float gain = 1f;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}
}


using UnityEngine;

public class AmbienceZone : TriggerBase, IClientComponentEx
{
	public AmbienceDefinitionList baseAmbience;

	public AmbienceDefinitionList stings;

	public float priority;

	public bool overrideCrossfadeTime;

	public float crossfadeTime = 1f;

	public float ambienceGain = 1f;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class RainSurfaceAmbience : SingletonComponent<RainSurfaceAmbience>, IClientComponent
{
	[Serializable]
	public class SurfaceSound
	{
		public AmbienceDefinitionList baseAmbience;

		public List<PhysicMaterial> materials = new List<PhysicMaterial>();
	}

	public List<SurfaceSound> surfaces = new List<SurfaceSound>();

	public GameObjectRef emitterPrefab;

	public Dictionary<ParticlePatch, AmbienceEmitter> spawnedEmitters = new Dictionary<ParticlePatch, AmbienceEmitter>();
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class SurfaceSound
{
	public AmbienceDefinitionList baseAmbience;

	public List<PhysicMaterial> materials = new List<PhysicMaterial>();
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Blended Engine Loop Definition")]
public class BlendedEngineLoopDefinition : ScriptableObject
{
	[Serializable]
	public class EngineLoopDefinition
	{
		public SoundDefinition soundDefinition;

		public float RPM;

		public float startRPM;

		public float startFullRPM;

		public float stopFullRPM;

		public float stopRPM;

		public float GetPitchForRPM(float targetRPM)
		{
			return targetRPM / RPM;
		}
	}

	public EngineLoopDefinition[] engineLoops;

	public float minRPM;

	public float maxRPM;

	public float RPMChangeRateUp = 0.5f;

	public float RPMChangeRateDown = 0.2f;
}


using System;

[Serializable]
public class EngineLoopDefinition
{
	public SoundDefinition soundDefinition;

	public float RPM;

	public float startRPM;

	public float startFullRPM;

	public float stopFullRPM;

	public float stopRPM;

	public float GetPitchForRPM(float targetRPM)
	{
		return targetRPM / RPM;
	}
}


using UnityEngine;

public class BlendedLoopEngineSound : MonoBehaviour, IClientComponent
{
	public class EngineLoop
	{
		public BlendedEngineLoopDefinition.EngineLoopDefinition definition;

		public BlendedLoopEngineSound parent;

		public Sound sound;

		public SoundModulation.Modulator gainMod;

		public SoundModulation.Modulator pitchMod;
	}

	public BlendedEngineLoopDefinition loopDefinition;

	public bool engineOn;

	[Range(0f, 1f)]
	public float RPMControl;

	public float smoothedRPMControl;

	private EngineLoop[] engineLoops;

	public bool debugPlayImmediately;

	public float maxDistance => loopDefinition.engineLoops[0].soundDefinition.maxDistance;

	public EngineLoop[] GetEngineLoops()
	{
		return engineLoops;
	}

	public float GetLoopGain(int idx)
	{
		if (engineLoops != null && engineLoops[idx] != null && engineLoops[idx].gainMod != null)
		{
			return engineLoops[idx].gainMod.value;
		}
		return 0f;
	}

	public float GetLoopPitch(int idx)
	{
		if (engineLoops != null && engineLoops[idx] != null && engineLoops[idx].pitchMod != null)
		{
			return engineLoops[idx].pitchMod.value;
		}
		return 0f;
	}
}


public class EngineLoop
{
	public BlendedEngineLoopDefinition.EngineLoopDefinition definition;

	public BlendedLoopEngineSound parent;

	public Sound sound;

	public SoundModulation.Modulator gainMod;

	public SoundModulation.Modulator pitchMod;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class BlendedSoundLoops : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class Loop
	{
		public SoundDefinition soundDef;

		public AnimationCurve gainCurve;

		public AnimationCurve pitchCurve;

		[HideInInspector]
		public Sound sound;

		[HideInInspector]
		public SoundModulation.Modulator gainMod;

		[HideInInspector]
		public SoundModulation.Modulator pitchMod;
	}

	[Range(0f, 1f)]
	public float blend;

	public float blendSmoothing = 1f;

	public float loopFadeOutTime = 0.5f;

	public float loopFadeInTime = 0.5f;

	public float gainModSmoothing = 1f;

	public float pitchModSmoothing = 1f;

	public bool shouldPlay = true;

	public float gain = 1f;

	public List<Loop> loops = new List<Loop>();

	public float maxDistance;
}


using System;
using UnityEngine;

[Serializable]
public class Loop
{
	public SoundDefinition soundDef;

	public AnimationCurve gainCurve;

	public AnimationCurve pitchCurve;

	[HideInInspector]
	public Sound sound;

	[HideInInspector]
	public SoundModulation.Modulator gainMod;

	[HideInInspector]
	public SoundModulation.Modulator pitchMod;
}


using UnityEngine;

public class BlendedSoundLoopSpeedControl : MonoBehaviour, IClientComponent
{
	public BlendedSoundLoops loops;

	public float speed;

	public float speedMax = 10f;
}


using System;
using System.Collections.Generic;
using Facepunch;
using JSON;
using UnityEngine;

public class EngineAudioClip : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class EngineCycle
	{
		public int RPM;

		public int startSample;

		public int endSample;

		public float period;

		public int id;

		public EngineCycle(int RPM, int startSample, int endSample, float period, int id)
		{
			this.RPM = RPM;
			this.startSample = startSample;
			this.endSample = endSample;
			this.period = period;
			this.id = id;
		}
	}

	public class EngineCycleBucket
	{
		public int RPM;

		public List<EngineCycle> cycles = new List<EngineCycle>();

		public List<int> remainingCycles = new List<int>();

		public EngineCycleBucket(int RPM)
		{
			this.RPM = RPM;
		}

		public EngineCycle GetCycle(Random random, int lastCycleId)
		{
			if (remainingCycles.Count == 0)
			{
				ResetRemainingCycles(random);
			}
			int index = Extensions.Pop<int>(remainingCycles);
			if (cycles[index].id == lastCycleId)
			{
				if (remainingCycles.Count == 0)
				{
					ResetRemainingCycles(random);
				}
				index = Extensions.Pop<int>(remainingCycles);
			}
			return cycles[index];
		}

		private void ResetRemainingCycles(Random random)
		{
			for (int i = 0; i < cycles.Count; i++)
			{
				remainingCycles.Add(i);
			}
			ListEx.Shuffle<int>(remainingCycles, (uint)random.Next());
		}

		public void Add(EngineCycle cycle)
		{
			if (!cycles.Contains(cycle))
			{
				cycles.Add(cycle);
			}
		}
	}

	public class Grain : IPooled
	{
		private float[] sourceData;

		private int startSample;

		private int currentSample;

		private int attackTimeSamples;

		private int sustainTimeSamples;

		private int releaseTimeSamples;

		private float gain;

		private float gainPerSampleAttack;

		private float gainPerSampleRelease;

		private int attackEndSample;

		private int releaseStartSample;

		private int endSample;

		public bool finished => currentSample >= endSample;

		public void Init(float[] source, EngineCycle cycle, int cyclePadding)
		{
			sourceData = source;
			startSample = cycle.startSample - cyclePadding;
			currentSample = startSample;
			attackTimeSamples = cyclePadding;
			sustainTimeSamples = cycle.endSample - cycle.startSample;
			releaseTimeSamples = cyclePadding;
			gainPerSampleAttack = 1f / (float)attackTimeSamples;
			gainPerSampleRelease = -1f / (float)releaseTimeSamples;
			attackEndSample = startSample + attackTimeSamples;
			releaseStartSample = attackEndSample + sustainTimeSamples;
			endSample = releaseStartSample + releaseTimeSamples;
			gain = 0f;
		}

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			sourceData = null;
			startSample = 0;
			currentSample = 0;
			attackTimeSamples = 0;
			sustainTimeSamples = 0;
			releaseTimeSamples = 0;
			gain = 0f;
			gainPerSampleAttack = 0f;
			gainPerSampleRelease = 0f;
			attackEndSample = 0;
			releaseStartSample = 0;
			endSample = 0;
		}

		public float GetSample()
		{
			if (currentSample >= sourceData.Length)
			{
				return 0f;
			}
			float num = sourceData[currentSample];
			if (currentSample <= attackEndSample)
			{
				gain += gainPerSampleAttack;
				if (gain > 0.8f)
				{
					gain = 0.8f;
				}
			}
			else if (currentSample >= releaseStartSample)
			{
				gain += gainPerSampleRelease;
				if (gain < 0f)
				{
					gain = 0f;
				}
			}
			currentSample++;
			return num * gain;
		}
	}

	public AudioClip granularClip;

	public AudioClip accelerationClip;

	public TextAsset accelerationCyclesJson;

	public List<EngineCycle> accelerationCycles = new List<EngineCycle>();

	public List<EngineCycleBucket> cycleBuckets = new List<EngineCycleBucket>();

	public Dictionary<int, EngineCycleBucket> accelerationCyclesByRPM = new Dictionary<int, EngineCycleBucket>();

	public Dictionary<int, int> rpmBucketLookup = new Dictionary<int, int>();

	public int sampleRate = 44100;

	public int samplesUntilNextGrain;

	public int lastCycleId;

	public List<Grain> grains = new List<Grain>();

	public int currentRPM;

	public int targetRPM = 1500;

	public int minRPM;

	public int maxRPM;

	public int cyclePadding;

	[Range(0f, 1f)]
	public float RPMControl;

	public AudioSource source;

	public float rpmLerpSpeed = 0.025f;

	public float rpmLerpSpeedDown = 0.01f;

	private int GetBucketRPM(int RPM)
	{
		return Mathf.RoundToInt((float)(RPM / 25)) * 25;
	}
}


using System;

[Serializable]
public class EngineCycle
{
	public int RPM;

	public int startSample;

	public int endSample;

	public float period;

	public int id;

	public EngineCycle(int RPM, int startSample, int endSample, float period, int id)
	{
		this.RPM = RPM;
		this.startSample = startSample;
		this.endSample = endSample;
		this.period = period;
		this.id = id;
	}
}


using System;
using System.Collections.Generic;
using JSON;

public class EngineCycleBucket
{
	public int RPM;

	public List<EngineCycle> cycles = new List<EngineCycle>();

	public List<int> remainingCycles = new List<int>();

	public EngineCycleBucket(int RPM)
	{
		this.RPM = RPM;
	}

	public EngineCycle GetCycle(Random random, int lastCycleId)
	{
		if (remainingCycles.Count == 0)
		{
			ResetRemainingCycles(random);
		}
		int index = Extensions.Pop<int>(remainingCycles);
		if (cycles[index].id == lastCycleId)
		{
			if (remainingCycles.Count == 0)
			{
				ResetRemainingCycles(random);
			}
			index = Extensions.Pop<int>(remainingCycles);
		}
		return cycles[index];
	}

	private void ResetRemainingCycles(Random random)
	{
		for (int i = 0; i < cycles.Count; i++)
		{
			remainingCycles.Add(i);
		}
		ListEx.Shuffle<int>(remainingCycles, (uint)random.Next());
	}

	public void Add(EngineCycle cycle)
	{
		if (!cycles.Contains(cycle))
		{
			cycles.Add(cycle);
		}
	}
}


using Facepunch;

public class Grain : IPooled
{
	private float[] sourceData;

	private int startSample;

	private int currentSample;

	private int attackTimeSamples;

	private int sustainTimeSamples;

	private int releaseTimeSamples;

	private float gain;

	private float gainPerSampleAttack;

	private float gainPerSampleRelease;

	private int attackEndSample;

	private int releaseStartSample;

	private int endSample;

	public bool finished => currentSample >= endSample;

	public void Init(float[] source, EngineCycle cycle, int cyclePadding)
	{
		sourceData = source;
		startSample = cycle.startSample - cyclePadding;
		currentSample = startSample;
		attackTimeSamples = cyclePadding;
		sustainTimeSamples = cycle.endSample - cycle.startSample;
		releaseTimeSamples = cyclePadding;
		gainPerSampleAttack = 1f / (float)attackTimeSamples;
		gainPerSampleRelease = -1f / (float)releaseTimeSamples;
		attackEndSample = startSample + attackTimeSamples;
		releaseStartSample = attackEndSample + sustainTimeSamples;
		endSample = releaseStartSample + releaseTimeSamples;
		gain = 0f;
	}

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		sourceData = null;
		startSample = 0;
		currentSample = 0;
		attackTimeSamples = 0;
		sustainTimeSamples = 0;
		releaseTimeSamples = 0;
		gain = 0f;
		gainPerSampleAttack = 0f;
		gainPerSampleRelease = 0f;
		attackEndSample = 0;
		releaseStartSample = 0;
		endSample = 0;
	}

	public float GetSample()
	{
		if (currentSample >= sourceData.Length)
		{
			return 0f;
		}
		float num = sourceData[currentSample];
		if (currentSample <= attackEndSample)
		{
			gain += gainPerSampleAttack;
			if (gain > 0.8f)
			{
				gain = 0.8f;
			}
		}
		else if (currentSample >= releaseStartSample)
		{
			gain += gainPerSampleRelease;
			if (gain < 0f)
			{
				gain = 0f;
			}
		}
		currentSample++;
		return num * gain;
	}
}


using UnityEngine;

public class FlybySound : MonoBehaviour, IClientComponent
{
	public SoundDefinition flybySound;

	public float flybySoundDistance = 7f;

	public SoundDefinition closeFlybySound;

	public float closeFlybyDistance = 3f;
}


using UnityEngine;

public class FootstepSound : MonoBehaviour, IClientComponent
{
	public enum Hardness
	{
		Light = 1,
		Medium,
		Hard
	}

	public SoundDefinition lightSound;

	public SoundDefinition medSound;

	public SoundDefinition hardSound;

	private const float panAmount = 0.05f;
}


public enum Hardness
{
	Light = 1,
	Medium,
	Hard
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class GranularAudioClip : MonoBehaviour
{
	public class Grain : IPooled
	{
		private float[] sourceData;

		private int sourceDataLength;

		private int startSample;

		private int currentSample;

		private int attackTimeSamples;

		private int sustainTimeSamples;

		private int releaseTimeSamples;

		private float gain;

		private float gainPerSampleAttack;

		private float gainPerSampleRelease;

		private int attackEndSample;

		private int releaseStartSample;

		private int endSample;

		public bool finished => currentSample >= endSample;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			sourceData = null;
			sourceDataLength = 0;
			startSample = 0;
			currentSample = 0;
			attackTimeSamples = 0;
			sustainTimeSamples = 0;
			releaseTimeSamples = 0;
			gain = 0f;
			gainPerSampleAttack = 0f;
			gainPerSampleRelease = 0f;
			attackEndSample = 0;
			releaseStartSample = 0;
			endSample = 0;
		}

		public void Init(float[] source, int start, int attack, int sustain, int release)
		{
			sourceData = source;
			sourceDataLength = sourceData.Length;
			startSample = start;
			currentSample = start;
			attackTimeSamples = attack;
			sustainTimeSamples = sustain;
			releaseTimeSamples = release;
			gainPerSampleAttack = 1f / (float)attackTimeSamples;
			gainPerSampleRelease = -1f / (float)releaseTimeSamples;
			attackEndSample = startSample + attackTimeSamples;
			releaseStartSample = attackEndSample + sustainTimeSamples;
			endSample = releaseStartSample + releaseTimeSamples;
			gain = 0f;
		}

		public float GetSample()
		{
			int num = currentSample % sourceDataLength;
			if (num < 0)
			{
				num += sourceDataLength;
			}
			float num2 = sourceData[num];
			if (currentSample <= attackEndSample)
			{
				gain += gainPerSampleAttack;
			}
			else if (currentSample >= releaseStartSample)
			{
				gain += gainPerSampleRelease;
			}
			currentSample++;
			return num2 * gain;
		}
	}

	public AudioClip sourceClip;

	private float[] sourceAudioData;

	private int sourceChannels = 1;

	public AudioClip granularClip;

	public int sampleRate = 44100;

	public float sourceTime = 0.5f;

	public float sourceTimeVariation = 0.1f;

	public float grainAttack = 0.1f;

	public float grainSustain = 0.1f;

	public float grainRelease = 0.1f;

	public float grainFrequency = 0.1f;

	public int grainAttackSamples;

	public int grainSustainSamples;

	public int grainReleaseSamples;

	public int grainFrequencySamples;

	public int samplesUntilNextGrain;

	public List<Grain> grains = new List<Grain>();

	private Random random = new Random();

	private bool inited;

	private void Update()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Invalid comparison between Unknown and I4
		if (!inited && (int)sourceClip.loadState == 2)
		{
			sampleRate = sourceClip.frequency;
			sourceAudioData = new float[sourceClip.samples * sourceClip.channels];
			sourceClip.GetData(sourceAudioData, 0);
			InitAudioClip();
			AudioSource component = ((Component)this).GetComponent<AudioSource>();
			component.clip = granularClip;
			component.loop = true;
			component.Play();
			inited = true;
		}
		RefreshCachedData();
	}

	private void RefreshCachedData()
	{
		grainAttackSamples = Mathf.FloorToInt(grainAttack * (float)sampleRate * (float)sourceChannels);
		grainSustainSamples = Mathf.FloorToInt(grainSustain * (float)sampleRate * (float)sourceChannels);
		grainReleaseSamples = Mathf.FloorToInt(grainRelease * (float)sampleRate * (float)sourceChannels);
		grainFrequencySamples = Mathf.FloorToInt(grainFrequency * (float)sampleRate * (float)sourceChannels);
	}

	private void InitAudioClip()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Expected O, but got Unknown
		int num = 1;
		int num2 = 1;
		AudioSettings.GetDSPBufferSize(ref num, ref num2);
		granularClip = AudioClip.Create(((Object)sourceClip).name + " (granular)", num, sourceClip.channels, sampleRate, true, new PCMReaderCallback(OnAudioRead));
		sourceChannels = sourceClip.channels;
	}

	private void OnAudioRead(float[] data)
	{
		for (int i = 0; i < data.Length; i++)
		{
			if (samplesUntilNextGrain <= 0)
			{
				SpawnGrain();
			}
			float num = 0f;
			for (int j = 0; j < grains.Count; j++)
			{
				num += grains[j].GetSample();
			}
			data[i] = num;
			samplesUntilNextGrain--;
		}
		CleanupFinishedGrains();
	}

	private void SpawnGrain()
	{
		if (grainFrequencySamples != 0)
		{
			float num = (float)(random.NextDouble() * (double)sourceTimeVariation * 2.0) - sourceTimeVariation;
			int start = Mathf.FloorToInt((sourceTime + num) * (float)sampleRate / (float)sourceChannels);
			Grain grain = Pool.Get<Grain>();
			grain.Init(sourceAudioData, start, grainAttackSamples, grainSustainSamples, grainReleaseSamples);
			grains.Add(grain);
			samplesUntilNextGrain = grainFrequencySamples;
		}
	}

	private void CleanupFinishedGrains()
	{
		for (int num = grains.Count - 1; num >= 0; num--)
		{
			Grain grain = grains[num];
			if (grain.finished)
			{
				Pool.Free<Grain>(ref grain);
				grains.RemoveAt(num);
			}
		}
	}
}


using Facepunch;

public class Grain : IPooled
{
	private float[] sourceData;

	private int sourceDataLength;

	private int startSample;

	private int currentSample;

	private int attackTimeSamples;

	private int sustainTimeSamples;

	private int releaseTimeSamples;

	private float gain;

	private float gainPerSampleAttack;

	private float gainPerSampleRelease;

	private int attackEndSample;

	private int releaseStartSample;

	private int endSample;

	public bool finished => currentSample >= endSample;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		sourceData = null;
		sourceDataLength = 0;
		startSample = 0;
		currentSample = 0;
		attackTimeSamples = 0;
		sustainTimeSamples = 0;
		releaseTimeSamples = 0;
		gain = 0f;
		gainPerSampleAttack = 0f;
		gainPerSampleRelease = 0f;
		attackEndSample = 0;
		releaseStartSample = 0;
		endSample = 0;
	}

	public void Init(float[] source, int start, int attack, int sustain, int release)
	{
		sourceData = source;
		sourceDataLength = sourceData.Length;
		startSample = start;
		currentSample = start;
		attackTimeSamples = attack;
		sustainTimeSamples = sustain;
		releaseTimeSamples = release;
		gainPerSampleAttack = 1f / (float)attackTimeSamples;
		gainPerSampleRelease = -1f / (float)releaseTimeSamples;
		attackEndSample = startSample + attackTimeSamples;
		releaseStartSample = attackEndSample + sustainTimeSamples;
		endSample = releaseStartSample + releaseTimeSamples;
		gain = 0f;
	}

	public float GetSample()
	{
		int num = currentSample % sourceDataLength;
		if (num < 0)
		{
			num += sourceDataLength;
		}
		float num2 = sourceData[num];
		if (currentSample <= attackEndSample)
		{
			gain += gainPerSampleAttack;
		}
		else if (currentSample >= releaseStartSample)
		{
			gain += gainPerSampleRelease;
		}
		currentSample++;
		return num2 * gain;
	}
}


public interface ISoundBudgetedUpdate
{
	void DoUpdate();

	bool IsSyncedToParent();
}


using UnityEngine.Audio;

public class MixerSnapshotManager : SingletonComponent<MixerSnapshotManager>, IClientComponent
{
	public AudioMixerSnapshot defaultSnapshot;

	public AudioMixerSnapshot underwaterSnapshot;

	public AudioMixerSnapshot loadingSnapshot;

	public AudioMixerSnapshot woundedSnapshot;

	public AudioMixerSnapshot cctvSnapshot;

	public AudioMixerSnapshot fadeToBlackSnapshot;

	public SoundDefinition underwaterInSound;

	public SoundDefinition underwaterOutSound;

	public AudioMixerSnapshot recordingSnapshot;

	public SoundDefinition woundedLoop;

	private Sound woundedLoopSound;

	public SoundDefinition cctvModeLoopDef;

	private Sound cctvModeLoop;

	public SoundDefinition cctvModeStartDef;

	public SoundDefinition cctvModeStopDef;

	public AudioMixerSnapshot predatorNearbySnapshot;

	public float deafness;
}


using UnityEngine;

public class MovementSoundTrigger : TriggerBase, IClientComponentEx, ILOD
{
	public SoundDefinition softSound;

	public SoundDefinition medSound;

	public SoundDefinition hardSound;

	public Collider collider;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)collider);
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class MusicChangeIntensity : MonoBehaviour
{
	[Serializable]
	public class DistanceIntensity
	{
		public float distance = 60f;

		public float raiseTo;

		public bool forceStartMusicInSuppressedMusicZones;
	}

	public float raiseTo;

	public List<DistanceIntensity> distanceIntensities = new List<DistanceIntensity>();

	public float tickInterval = 0.2f;
}


using System;

[Serializable]
public class DistanceIntensity
{
	public float distance = 60f;

	public float raiseTo;

	public bool forceStartMusicInSuppressedMusicZones;
}


using System.Collections.Generic;
using UnityEngine;

public class MusicClip : ScriptableObject
{
	public AudioClip audioClip;

	public int lengthInBars = 1;

	public int lengthInBarsWithTail;

	public List<float> fadeInPoints = new List<float>();

	public float GetNextFadeInPoint(float currentClipTimeBars)
	{
		if (fadeInPoints.Count == 0)
		{
			return currentClipTimeBars + 0.125f;
		}
		float result = -1f;
		float num = float.PositiveInfinity;
		for (int i = 0; i < fadeInPoints.Count; i++)
		{
			float num2 = fadeInPoints[i];
			float num3 = num2 - currentClipTimeBars;
			if (!(num2 <= 0.01f) && num3 > 0f && num3 < num)
			{
				num = num3;
				result = num2;
			}
		}
		return result;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class MusicClipLoader
{
	public class LoadedAudioClip : IPooled
	{
		public AudioClip clip;

		public float unloadTime;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			clip = null;
			unloadTime = 0f;
		}
	}

	public List<LoadedAudioClip> loadedClips = new List<LoadedAudioClip>();

	public Dictionary<AudioClip, LoadedAudioClip> loadedClipDict = new Dictionary<AudioClip, LoadedAudioClip>();

	public List<AudioClip> clipsToLoad = new List<AudioClip>();

	public List<AudioClip> clipsToUnload = new List<AudioClip>();

	public void Update()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Invalid comparison between Unknown and I4
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Invalid comparison between Unknown and I4
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Invalid comparison between Unknown and I4
		for (int num = clipsToLoad.Count - 1; num >= 0; num--)
		{
			AudioClip val = clipsToLoad[num];
			if ((int)val.loadState != 2 && (int)val.loadState != 1)
			{
				val.LoadAudioData();
				clipsToLoad.RemoveAt(num);
				return;
			}
		}
		for (int num2 = clipsToUnload.Count - 1; num2 >= 0; num2--)
		{
			AudioClip val2 = clipsToUnload[num2];
			if ((int)val2.loadState == 2)
			{
				val2.UnloadAudioData();
				clipsToUnload.RemoveAt(num2);
				break;
			}
		}
	}

	public void Refresh()
	{
		for (int i = 0; i < SingletonComponent<MusicManager>.Instance.activeMusicClips.Count; i++)
		{
			MusicTheme.PositionedClip positionedClip = SingletonComponent<MusicManager>.Instance.activeMusicClips[i];
			LoadedAudioClip loadedAudioClip = FindLoadedClip(positionedClip.musicClip.audioClip);
			if (loadedAudioClip == null)
			{
				loadedAudioClip = Pool.Get<LoadedAudioClip>();
				loadedAudioClip.clip = positionedClip.musicClip.audioClip;
				loadedAudioClip.unloadTime = (float)AudioSettings.dspTime + loadedAudioClip.clip.length + 1f;
				loadedClips.Add(loadedAudioClip);
				loadedClipDict.Add(loadedAudioClip.clip, loadedAudioClip);
				clipsToLoad.Add(loadedAudioClip.clip);
			}
			else
			{
				loadedAudioClip.unloadTime = (float)AudioSettings.dspTime + loadedAudioClip.clip.length + 1f;
				clipsToUnload.Remove(loadedAudioClip.clip);
			}
		}
		for (int num = loadedClips.Count - 1; num >= 0; num--)
		{
			LoadedAudioClip loadedAudioClip2 = loadedClips[num];
			if (AudioSettings.dspTime > (double)loadedAudioClip2.unloadTime)
			{
				clipsToUnload.Add(loadedAudioClip2.clip);
				loadedClips.Remove(loadedAudioClip2);
				loadedClipDict.Remove(loadedAudioClip2.clip);
				Pool.Free<LoadedAudioClip>(ref loadedAudioClip2);
			}
		}
	}

	private LoadedAudioClip FindLoadedClip(AudioClip clip)
	{
		if (loadedClipDict.ContainsKey(clip))
		{
			return loadedClipDict[clip];
		}
		return null;
	}
}


using Facepunch;
using UnityEngine;

public class LoadedAudioClip : IPooled
{
	public AudioClip clip;

	public float unloadTime;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		clip = null;
		unloadTime = 0f;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.Audio;

public class MusicManager : SingletonComponent<MusicManager>, IClientComponent
{
	[Serializable]
	public class ClipPlaybackData : IPooled
	{
		public AudioSource source;

		public MusicTheme.PositionedClip positionedClip;

		public bool isActive;

		public bool fadingIn;

		public bool fadingOut;

		public double fadeStarted;

		public bool needsSync;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			source = null;
			positionedClip = null;
			isActive = false;
			fadingIn = false;
			fadingOut = false;
			fadeStarted = 0.0;
			needsSync = false;
		}
	}

	public AudioMixerGroup mixerGroup;

	public List<MusicTheme> themes;

	public MusicTheme currentTheme;

	public List<AudioSource> sources = new List<AudioSource>();

	public double nextMusic;

	public double nextMusicFromIntensityRaise;

	[Range(0f, 1f)]
	public float intensity;

	public Dictionary<MusicTheme.PositionedClip, ClipPlaybackData> clipPlaybackData = new Dictionary<MusicTheme.PositionedClip, ClipPlaybackData>();

	public int holdIntensityUntilBar;

	public bool musicPlaying;

	public bool loadingFirstClips;

	public MusicTheme nextTheme;

	public double lastClipUpdate;

	public float clipUpdateInterval = 0.1f;

	public double themeStartTime;

	public int lastActiveClipRefresh = -10;

	public int activeClipRefreshInterval = 1;

	public bool forceThemeChange;

	public float randomIntensityJumpChance;

	public int clipScheduleBarsEarly = 1;

	public List<MusicTheme.PositionedClip> activeClips = new List<MusicTheme.PositionedClip>();

	public List<MusicTheme.PositionedClip> activeMusicClips = new List<MusicTheme.PositionedClip>();

	public List<MusicTheme.PositionedClip> activeControlClips = new List<MusicTheme.PositionedClip>();

	public List<MusicZone> currentMusicZones = new List<MusicZone>();

	public int currentBar;

	public int barOffset;

	public double currentThemeTime => AudioSettings.dspTime - themeStartTime;

	public int themeBar => currentBar + barOffset;

	public static void RaiseIntensityTo(float amount, int holdLengthBars = 0)
	{
	}

	public void StopMusic()
	{
	}
}


using System;
using Facepunch;
using UnityEngine;

[Serializable]
public class ClipPlaybackData : IPooled
{
	public AudioSource source;

	public MusicTheme.PositionedClip positionedClip;

	public bool isActive;

	public bool fadingIn;

	public bool fadingOut;

	public double fadeStarted;

	public bool needsSync;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		source = null;
		positionedClip = null;
		isActive = false;
		fadingIn = false;
		fadingOut = false;
		fadeStarted = 0.0;
		needsSync = false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MusicTheme")]
public class MusicTheme : ScriptableObject
{
	[Serializable]
	public class Layer
	{
		public string name = "layer";
	}

	[Serializable]
	public class PositionedClip
	{
		public MusicTheme theme;

		public MusicClip musicClip;

		public int startingBar;

		public int layerId;

		public float minIntensity;

		public float maxIntensity = 1f;

		public bool allowFadeIn = true;

		public bool allowFadeOut = true;

		public float fadeInTime = 1f;

		public float fadeOutTime = 0.5f;

		public float intensityReduction;

		public int jumpBarCount;

		public float jumpMinimumIntensity = 0.5f;

		public float jumpMaximumIntensity = 0.5f;

		public int endingBar
		{
			get
			{
				if (!((Object)(object)musicClip == (Object)null))
				{
					return startingBar + musicClip.lengthInBarsWithTail;
				}
				return startingBar;
			}
		}

		public bool isControlClip => (Object)(object)musicClip == (Object)null;

		public bool CanPlay(float intensity)
		{
			if (intensity > minIntensity || (minIntensity == 0f && intensity == 0f))
			{
				return intensity <= maxIntensity;
			}
			return false;
		}

		public void CopySettingsFrom(PositionedClip otherClip)
		{
			if (isControlClip == otherClip.isControlClip && otherClip != this)
			{
				allowFadeIn = otherClip.allowFadeIn;
				fadeInTime = otherClip.fadeInTime;
				allowFadeOut = otherClip.allowFadeOut;
				fadeOutTime = otherClip.fadeOutTime;
				maxIntensity = otherClip.maxIntensity;
				minIntensity = otherClip.minIntensity;
				intensityReduction = otherClip.intensityReduction;
			}
		}
	}

	[Serializable]
	public class ValueRange
	{
		public float min;

		public float max;

		public ValueRange(float min, float max)
		{
			this.min = min;
			this.max = max;
		}
	}

	[Header("Basic info")]
	public float tempo = 80f;

	public int intensityHoldBars = 4;

	public int lengthInBars;

	[Header("Playback restrictions")]
	public bool canPlayInMenus = true;

	[Horizontal(2, -1)]
	public ValueRange rain = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange wind = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange snow = new ValueRange(0f, 1f);

	[InspectorFlags]
	public Enum biomes = (Enum)(-1);

	[InspectorFlags]
	public Enum topologies = (Enum)(-1);

	public AnimationCurve time = AnimationCurve.Linear(0f, 0f, 24f, 0f);

	[Header("Clip data")]
	public List<PositionedClip> clips = new List<PositionedClip>();

	public List<Layer> layers = new List<Layer>();

	private Dictionary<int, List<PositionedClip>> activeClips = new Dictionary<int, List<PositionedClip>>();

	private List<AudioClip> firstAudioClips = new List<AudioClip>();

	private Dictionary<AudioClip, bool> audioClipDict = new Dictionary<AudioClip, bool>();

	public int layerCount => layers.Count;

	public int samplesPerBar => MusicUtil.BarsToSamples(tempo, 1f, 44100);

	private void OnValidate()
	{
		audioClipDict.Clear();
		activeClips.Clear();
		UpdateLengthInBars();
		for (int i = 0; i < clips.Count; i++)
		{
			PositionedClip positionedClip = clips[i];
			int num = ActiveClipCollectionID(positionedClip.startingBar - 8);
			int num2 = ActiveClipCollectionID(positionedClip.endingBar);
			for (int j = num; j <= num2; j++)
			{
				if (!activeClips.ContainsKey(j))
				{
					activeClips.Add(j, new List<PositionedClip>());
				}
				if (!activeClips[j].Contains(positionedClip))
				{
					activeClips[j].Add(positionedClip);
				}
			}
			if ((Object)(object)positionedClip.musicClip != (Object)null)
			{
				AudioClip audioClip = positionedClip.musicClip.audioClip;
				if (!audioClipDict.ContainsKey(audioClip))
				{
					audioClipDict.Add(audioClip, value: true);
				}
				if (positionedClip.startingBar < 8 && !firstAudioClips.Contains(audioClip))
				{
					firstAudioClips.Add(audioClip);
				}
				positionedClip.musicClip.lengthInBarsWithTail = Mathf.CeilToInt(MusicUtil.SecondsToBars(tempo, positionedClip.musicClip.audioClip.length));
			}
		}
	}

	public List<PositionedClip> GetActiveClipsForBar(int bar)
	{
		int key = ActiveClipCollectionID(bar);
		if (!activeClips.ContainsKey(key))
		{
			return null;
		}
		return activeClips[key];
	}

	private int ActiveClipCollectionID(int bar)
	{
		return Mathf.FloorToInt(Mathf.Max((float)(bar / 4), 0f));
	}

	public Layer LayerById(int id)
	{
		if (layers.Count <= id)
		{
			return null;
		}
		return layers[id];
	}

	public void AddLayer()
	{
		Layer layer = new Layer();
		layer.name = "layer " + layers.Count;
		layers.Add(layer);
	}

	private void UpdateLengthInBars()
	{
		int num = 0;
		for (int i = 0; i < clips.Count; i++)
		{
			PositionedClip positionedClip = clips[i];
			if (!((Object)(object)positionedClip.musicClip == (Object)null))
			{
				int num2 = positionedClip.startingBar + positionedClip.musicClip.lengthInBars;
				if (num2 > num)
				{
					num = num2;
				}
			}
		}
		lengthInBars = num;
	}

	public bool CanPlayInEnvironment(int currentBiome, int currentTopology, float currentRain, float currentSnow, float currentWind)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Invalid comparison between Unknown and I4
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Invalid comparison between Unknown and I4
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance) && time.Evaluate(TOD_Sky.Instance.Cycle.Hour) < 0f)
		{
			return false;
		}
		if ((int)biomes != -1 && (biomes & currentBiome) == 0)
		{
			return false;
		}
		if ((int)topologies != -1 && (topologies & currentTopology) != 0)
		{
			return false;
		}
		if (((rain.min > 0f || rain.max < 1f) && currentRain < rain.min) || currentRain > rain.max)
		{
			return false;
		}
		if (((snow.min > 0f || snow.max < 1f) && currentSnow < snow.min) || currentSnow > snow.max)
		{
			return false;
		}
		if (((wind.min > 0f || wind.max < 1f) && currentWind < wind.min) || currentWind > wind.max)
		{
			return false;
		}
		return true;
	}

	public bool FirstClipsLoaded()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		for (int i = 0; i < firstAudioClips.Count; i++)
		{
			if ((int)firstAudioClips[i].loadState != 2)
			{
				return false;
			}
		}
		return true;
	}

	public bool ContainsAudioClip(AudioClip clip)
	{
		return audioClipDict.ContainsKey(clip);
	}
}


using System;

[Serializable]
public class Layer
{
	public string name = "layer";
}


using System;
using UnityEngine;

[Serializable]
public class PositionedClip
{
	public MusicTheme theme;

	public MusicClip musicClip;

	public int startingBar;

	public int layerId;

	public float minIntensity;

	public float maxIntensity = 1f;

	public bool allowFadeIn = true;

	public bool allowFadeOut = true;

	public float fadeInTime = 1f;

	public float fadeOutTime = 0.5f;

	public float intensityReduction;

	public int jumpBarCount;

	public float jumpMinimumIntensity = 0.5f;

	public float jumpMaximumIntensity = 0.5f;

	public int endingBar
	{
		get
		{
			if (!((Object)(object)musicClip == (Object)null))
			{
				return startingBar + musicClip.lengthInBarsWithTail;
			}
			return startingBar;
		}
	}

	public bool isControlClip => (Object)(object)musicClip == (Object)null;

	public bool CanPlay(float intensity)
	{
		if (intensity > minIntensity || (minIntensity == 0f && intensity == 0f))
		{
			return intensity <= maxIntensity;
		}
		return false;
	}

	public void CopySettingsFrom(PositionedClip otherClip)
	{
		if (isControlClip == otherClip.isControlClip && otherClip != this)
		{
			allowFadeIn = otherClip.allowFadeIn;
			fadeInTime = otherClip.fadeInTime;
			allowFadeOut = otherClip.allowFadeOut;
			fadeOutTime = otherClip.fadeOutTime;
			maxIntensity = otherClip.maxIntensity;
			minIntensity = otherClip.minIntensity;
			intensityReduction = otherClip.intensityReduction;
		}
	}
}


using System;

[Serializable]
public class ValueRange
{
	public float min;

	public float max;

	public ValueRange(float min, float max)
	{
		this.min = min;
		this.max = max;
	}
}


using UnityEngine;

public class MusicUtil
{
	public const float OneSixteenth = 0.0625f;

	public static double BeatsToSeconds(float tempo, float beats)
	{
		return 60.0 / (double)tempo * (double)beats;
	}

	public static double BarsToSeconds(float tempo, float bars)
	{
		return BeatsToSeconds(tempo, bars * 4f);
	}

	public static int SecondsToSamples(double seconds)
	{
		return SecondsToSamples(seconds, AudioSettings.outputSampleRate);
	}

	public static int SecondsToSamples(double seconds, int sampleRate)
	{
		return (int)((double)sampleRate * seconds);
	}

	public static int SecondsToSamples(float seconds)
	{
		return SecondsToSamples(seconds, AudioSettings.outputSampleRate);
	}

	public static int SecondsToSamples(float seconds, int sampleRate)
	{
		return (int)((float)sampleRate * seconds);
	}

	public static int BarsToSamples(float tempo, float bars, int sampleRate)
	{
		return SecondsToSamples(BarsToSeconds(tempo, bars), sampleRate);
	}

	public static int BarsToSamples(float tempo, float bars)
	{
		return SecondsToSamples(BarsToSeconds(tempo, bars));
	}

	public static int BeatsToSamples(float tempo, float beats)
	{
		return SecondsToSamples(BeatsToSeconds(tempo, beats));
	}

	public static float SecondsToBeats(float tempo, double seconds)
	{
		return tempo / 60f * (float)seconds;
	}

	public static float SecondsToBars(float tempo, double seconds)
	{
		return SecondsToBeats(tempo, seconds) / 4f;
	}

	public static float Quantize(float position, float gridSize)
	{
		return Mathf.Round(position / gridSize) * gridSize;
	}

	public static float FlooredQuantize(float position, float gridSize)
	{
		return Mathf.Floor(position / gridSize) * gridSize;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class MusicZone : MonoBehaviour, IClientComponent
{
	public List<MusicTheme> themes;

	public float priority;

	public bool suppressAutomaticMusic;

	public bool startOnEnter;
}


using UnityEngine;

public class OnePoleLowpassFilter : MonoBehaviour
{
	[Range(10f, 20000f)]
	public float frequency = 20000f;
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Reverb Settings")]
public class ReverbSettings : ScriptableObject
{
	[Range(-10000f, 0f)]
	public int room;

	[Range(-10000f, 0f)]
	public int roomHF;

	[Range(-10000f, 0f)]
	public int roomLF;

	[Range(0.1f, 20f)]
	public float decayTime;

	[Range(0.1f, 2f)]
	public float decayHFRatio;

	[Range(-10000f, 1000f)]
	public int reflections;

	[Range(0f, 0.3f)]
	public float reflectionsDelay;

	[Range(-10000f, 2000f)]
	public int reverb;

	[Range(0f, 0.1f)]
	public float reverbDelay;

	[Range(1000f, 20000f)]
	public float HFReference;

	[Range(20f, 1000f)]
	public float LFReference;

	[Range(0f, 100f)]
	public float diffusion;

	[Range(0f, 100f)]
	public float density;
}


using UnityEngine;

public class ReverbZoneTrigger : TriggerBase, IClientComponentEx, ILOD
{
	public Collider trigger;

	public AudioReverbZone reverbZone;

	public float lodDistance = 100f;

	public bool inRange;

	public ReverbSettings reverbSettings;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)trigger);
		p.RemoveComponent((Component)(object)reverbZone);
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}

	public bool IsSyncedToParent()
	{
		return false;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ShoutcastStreamer : MonoBehaviour, IClientComponent
{
	public string Host = "http://listen.57fm.com:80/rcxmas";

	public AudioSource Source;

	public static RadioPlaylist[] BuiltinRadios;

	public static Dictionary<string, string> ParsedLocalRadioList;

	public static void CheckBuiltInRadios()
	{
		if (BuiltinRadios == null)
		{
			BuiltinRadios = FileSystem.LoadAll<RadioPlaylist>("assets/prefabs/voiceaudio/boombox/sound/builtinplaylists", "");
			ParsedLocalRadioList = new Dictionary<string, string>();
			RadioPlaylist[] builtinRadios = BuiltinRadios;
			foreach (RadioPlaylist radioPlaylist in builtinRadios)
			{
				ParsedLocalRadioList.Add(radioPlaylist.LocalName, radioPlaylist.Url);
			}
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SlicedGranularAudioClip : MonoBehaviour, IClientComponent
{
	public class Grain : IPooled
	{
		private float[] sourceData;

		private int startSample;

		private int currentSample;

		private int attackTimeSamples;

		private int sustainTimeSamples;

		private int releaseTimeSamples;

		private float gain;

		private float gainPerSampleAttack;

		private float gainPerSampleRelease;

		private int attackEndSample;

		private int releaseStartSample;

		private int endSample;

		public bool finished => currentSample >= endSample;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			sourceData = null;
			startSample = 0;
			currentSample = 0;
			attackTimeSamples = 0;
			sustainTimeSamples = 0;
			releaseTimeSamples = 0;
			gain = 0f;
			gainPerSampleAttack = 0f;
			gainPerSampleRelease = 0f;
			attackEndSample = 0;
			releaseStartSample = 0;
			endSample = 0;
		}

		public void Init(float[] source, int start, int attack, int sustain, int release)
		{
			sourceData = source;
			startSample = start;
			currentSample = start;
			attackTimeSamples = attack;
			sustainTimeSamples = sustain;
			releaseTimeSamples = release;
			gainPerSampleAttack = 0.5f / (float)attackTimeSamples;
			gainPerSampleRelease = -0.5f / (float)releaseTimeSamples;
			attackEndSample = startSample + attackTimeSamples;
			releaseStartSample = attackEndSample + sustainTimeSamples;
			endSample = releaseStartSample + releaseTimeSamples;
			gain = 0f;
		}

		public float GetSample()
		{
			if (currentSample >= sourceData.Length)
			{
				return 0f;
			}
			float num = sourceData[currentSample];
			if (currentSample <= attackEndSample)
			{
				gain += gainPerSampleAttack;
				if (gain > 0.5f)
				{
					gain = 0.5f;
				}
			}
			else if (currentSample >= releaseStartSample)
			{
				gain += gainPerSampleRelease;
				if (gain < 0f)
				{
					gain = 0f;
				}
			}
			currentSample++;
			return num * gain;
		}

		public void FadeOut()
		{
			releaseStartSample = currentSample;
			endSample = releaseStartSample + releaseTimeSamples;
		}
	}

	public AudioSource source;

	public AudioClip sourceClip;

	public AudioClip granularClip;

	public int sampleRate = 44100;

	public float grainAttack = 0.1f;

	public float grainSustain = 0.1f;

	public float grainRelease = 0.1f;

	public float grainFrequency = 0.1f;

	public int grainAttackSamples;

	public int grainSustainSamples;

	public int grainReleaseSamples;

	public int grainFrequencySamples;

	public int samplesUntilNextGrain;

	public List<Grain> grains = new List<Grain>();

	public List<int> startPositions = new List<int>();

	public int lastStartPositionIdx = int.MaxValue;

	public bool playOnAwake = true;
}


using Facepunch;

public class Grain : IPooled
{
	private float[] sourceData;

	private int startSample;

	private int currentSample;

	private int attackTimeSamples;

	private int sustainTimeSamples;

	private int releaseTimeSamples;

	private float gain;

	private float gainPerSampleAttack;

	private float gainPerSampleRelease;

	private int attackEndSample;

	private int releaseStartSample;

	private int endSample;

	public bool finished => currentSample >= endSample;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		sourceData = null;
		startSample = 0;
		currentSample = 0;
		attackTimeSamples = 0;
		sustainTimeSamples = 0;
		releaseTimeSamples = 0;
		gain = 0f;
		gainPerSampleAttack = 0f;
		gainPerSampleRelease = 0f;
		attackEndSample = 0;
		releaseStartSample = 0;
		endSample = 0;
	}

	public void Init(float[] source, int start, int attack, int sustain, int release)
	{
		sourceData = source;
		startSample = start;
		currentSample = start;
		attackTimeSamples = attack;
		sustainTimeSamples = sustain;
		releaseTimeSamples = release;
		gainPerSampleAttack = 0.5f / (float)attackTimeSamples;
		gainPerSampleRelease = -0.5f / (float)releaseTimeSamples;
		attackEndSample = startSample + attackTimeSamples;
		releaseStartSample = attackEndSample + sustainTimeSamples;
		endSample = releaseStartSample + releaseTimeSamples;
		gain = 0f;
	}

	public float GetSample()
	{
		if (currentSample >= sourceData.Length)
		{
			return 0f;
		}
		float num = sourceData[currentSample];
		if (currentSample <= attackEndSample)
		{
			gain += gainPerSampleAttack;
			if (gain > 0.5f)
			{
				gain = 0.5f;
			}
		}
		else if (currentSample >= releaseStartSample)
		{
			gain += gainPerSampleRelease;
			if (gain < 0f)
			{
				gain = 0f;
			}
		}
		currentSample++;
		return num * gain;
	}

	public void FadeOut()
	{
		releaseStartSample = currentSample;
		endSample = releaseStartSample + releaseTimeSamples;
	}
}


using UnityEngine;

public class Sound : MonoBehaviour, IClientComponent
{
	public static float volumeExponent = Mathf.Log(Mathf.Sqrt(10f), 2f);

	public SoundDefinition definition;

	public SoundModifier[] modifiers;

	public SoundSource soundSource;

	public AudioSource[] audioSources = (AudioSource[])(object)new AudioSource[2];

	[SerializeField]
	private SoundFade _fade;

	[SerializeField]
	private SoundModulation _modulation;

	[SerializeField]
	private SoundOcclusion _occlusion;

	public SoundFade fade => _fade;

	public SoundModulation modulation => _modulation;

	public SoundOcclusion occlusion => _occlusion;
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

[CreateAssetMenu(menuName = "Rust/Sound Class")]
public class SoundClass : ScriptableObject
{
	[Header("Mixer Settings")]
	public AudioMixerGroup output;

	public AudioMixerGroup firstPersonOutput;

	[Header("Occlusion Settings")]
	public bool enableOcclusion;

	public bool playIfOccluded = true;

	public float occlusionGain = 1f;

	[Tooltip("Use this mixer group when the sound is occluded to save DSP CPU usage. Only works for non-looping sounds.")]
	public AudioMixerGroup occludedOutput;

	[Header("Voice Limiting")]
	public int globalVoiceMaxCount = 100;

	public int priority = 128;

	public List<SoundDefinition> definitions = new List<SoundDefinition>();
}


using UnityEngine;

public class SoundClassTest : MonoBehaviour
{
	public SoundClass soundClass;

	public float soundInterval = 0.5f;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SoundDefinition : ScriptableObject
{
	[Serializable]
	public class DistanceAudioClipList
	{
		public int distance;

		[Horizontal(2, -1)]
		public List<WeightedAudioClip> audioClips;
	}

	public GameObjectRef template;

	[Horizontal(2, -1)]
	public List<WeightedAudioClip> weightedAudioClips = new List<WeightedAudioClip>
	{
		new WeightedAudioClip()
	};

	public List<DistanceAudioClipList> distanceAudioClips;

	public SoundClass soundClass;

	public bool defaultToFirstPerson;

	public bool loop;

	public bool randomizeStartPosition;

	public bool useHighQualityFades;

	[Range(0f, 1f)]
	public float volume = 1f;

	[Range(0f, 1f)]
	public float volumeVariation;

	[Range(-3f, 3f)]
	public float pitch = 1f;

	[Range(0f, 1f)]
	public float pitchVariation;

	[Header("Voice limiting")]
	public bool dontVoiceLimit;

	public int globalVoiceMaxCount = 100;

	public int localVoiceMaxCount = 100;

	public float localVoiceRange = 10f;

	public float voiceLimitFadeOutTime = 0.05f;

	public float localVoiceDebounceTime = 0.1f;

	[Header("Occlusion Settings")]
	public bool forceOccludedPlayback;

	[Header("Doppler")]
	public bool enableDoppler;

	public float dopplerAmount = 0.18f;

	public float dopplerScale = 1f;

	public float dopplerAdjustmentRate = 1f;

	[Header("Custom curves")]
	public AnimationCurve falloffCurve;

	public bool useCustomFalloffCurve;

	public AnimationCurve spatialBlendCurve;

	public bool useCustomSpatialBlendCurve;

	public AnimationCurve spreadCurve;

	public bool useCustomSpreadCurve;

	public float maxDistance
	{
		get
		{
			if (template == null)
			{
				return 0f;
			}
			AudioSource component = template.Get().GetComponent<AudioSource>();
			if ((Object)(object)component == (Object)null)
			{
				return 0f;
			}
			return component.maxDistance;
		}
	}

	public float GetLength()
	{
		float num = 0f;
		for (int i = 0; i < weightedAudioClips.Count; i++)
		{
			AudioClip audioClip = weightedAudioClips[i].audioClip;
			if (Object.op_Implicit((Object)(object)audioClip))
			{
				num = Mathf.Max(audioClip.length, num);
			}
		}
		for (int j = 0; j < distanceAudioClips.Count; j++)
		{
			List<WeightedAudioClip> audioClips = distanceAudioClips[j].audioClips;
			for (int k = 0; k < audioClips.Count; k++)
			{
				AudioClip audioClip2 = audioClips[k].audioClip;
				if (Object.op_Implicit((Object)(object)audioClip2))
				{
					num = Mathf.Max(audioClip2.length, num);
				}
			}
		}
		float num2 = 1f / (pitch - pitchVariation);
		return num * num2;
	}

	public Sound Play()
	{
		return null;
	}

	public Sound Play(GameObject forGameObject)
	{
		return null;
	}
}


using System;
using System.Collections.Generic;

[Serializable]
public class DistanceAudioClipList
{
	public int distance;

	[Horizontal(2, -1)]
	public List<WeightedAudioClip> audioClips;
}


using UnityEngine;

public class SoundFade : MonoBehaviour, IClientComponent
{
	public enum Direction
	{
		In,
		Out
	}

	public SoundFadeHQAudioFilter hqFadeFilter;

	public float currentGain = 1f;

	public float startingGain;

	public float finalGain = 1f;

	public int sampleRate = 44100;

	public bool highQualityFadeCompleted;

	public float length;

	public Direction currentDirection;
}


public enum Direction
{
	In,
	Out
}


using UnityEngine;

public class SoundFadeHQAudioFilter : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class SoundFollowCollider : MonoBehaviour, IClientComponent
{
	public SoundDefinition soundDefinition;

	public Sound sound;

	public Bounds soundFollowBounds;

	public bool startImmediately;
}


public class SoundManager : SingletonComponent<SoundManager>, IClientComponent
{
	public SoundClass defaultSoundClass;
}


using UnityEngine;

public class SoundModifier : MonoBehaviour
{
	[HideInInspector]
	public Sound sound;
}


using System;
using Facepunch;
using UnityEngine;

public class SoundModulation : MonoBehaviour, IClientComponent
{
	public enum Parameter
	{
		Gain,
		Pitch,
		Spread,
		MaxDistance
	}

	[Serializable]
	public class Modulator : IPooled
	{
		public Parameter param;

		public float value = 1f;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			param = Parameter.Gain;
			value = 1f;
		}
	}

	private const int parameterCount = 4;
}


public enum Parameter
{
	Gain,
	Pitch,
	Spread,
	MaxDistance
}


using System;
using Facepunch;

[Serializable]
public class Modulator : IPooled
{
	public Parameter param;

	public float value = 1f;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		param = Parameter.Gain;
		value = 1f;
	}
}


using UnityEngine;

public class SoundOcclusion : MonoBehaviour
{
	public LayerMask occlusionLayerMask;
}


using UnityEngine;

public class SoundPlayer : BaseMonoBehaviour, IClientComponent
{
	public SoundDefinition soundDefinition;

	public bool playImmediately = true;

	public float minStartDelay;

	public float maxStartDelay;

	public bool debugRepeat;

	public bool pending;

	public Vector3 soundOffset = Vector3.zero;
}


using UnityEngine;

public class SoundPlayerCull : MonoBehaviour, IClientComponent, ILOD
{
	public SoundPlayer soundPlayer;

	public float cullDistance = 100f;
}


using UnityEngine;

public class SoundPlayerCullLODComponent : LODComponent
{
	public float Distance = 100f;

	public SoundPlayer TargetSoundPlayer;

	private void OnValidate()
	{
		if ((Object)(object)TargetSoundPlayer == (Object)null)
		{
			TargetSoundPlayer = ((Component)this).GetComponent<SoundPlayer>();
		}
	}
}


public class SoundRandomizer
{
}


using UnityEngine;

[RequireComponent(typeof(SoundPlayer))]
public class SoundRepeater : MonoBehaviour
{
	public float interval = 5f;

	public SoundPlayer player;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SoundSource : MonoBehaviour, IClientComponentEx, ILOD
{
	[Serializable]
	public class OcclusionPoint
	{
		public Vector3 offset = Vector3.zero;

		public bool isOccluded;
	}

	[Header("Occlusion")]
	public bool handleOcclusionChecks;

	public LayerMask occlusionLayerMask;

	public List<OcclusionPoint> occlusionPoints = new List<OcclusionPoint>();

	public bool isOccluded;

	public float occlusionAmount;

	public float lodDistance = 100f;

	public bool inRange;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)this);
	}

	public bool IsSyncedToParent()
	{
		return false;
	}
}


using System;
using UnityEngine;

[Serializable]
public class OcclusionPoint
{
	public Vector3 offset = Vector3.zero;

	public bool isOccluded;
}


using UnityEngine;

public class SoundVoiceLimiter : MonoBehaviour, IClientComponent
{
	public int maxSimultaneousSounds = 5;
}


using UnityEngine;

public class TimeBasedSoundSpread : SoundModifier
{
	public AnimationCurve spreadCurve;

	public AnimationCurve wanderIntensityCurve;
}


using System;
using UnityEngine;

[Serializable]
public class WeightedAudioClip
{
	public AudioClip audioClip;

	public int weight = 1;
}


using System;

public class AttractionPoint : PrefabAttribute
{
	public string groupName;

	protected override Type GetIndexedType()
	{
		return typeof(AttractionPoint);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BuildingProximity : PrefabAttribute
{
	public struct ProximityInfo
	{
		public bool hit;

		public bool connection;

		public Line line;

		public float sqrDist;
	}

	private const float check_radius = 2f;

	private const float check_forgiveness = 0.01f;

	private const float foundation_width = 3f;

	private const float foundation_extents = 1.5f;

	public static bool Check(BasePlayer player, Construction construction, Vector3 position, Quaternion rotation)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(position, rotation, construction.bounds);
		float radius = ((Vector3)(ref val.extents)).magnitude + 2f;
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(val.position, radius, list, 2097152, (QueryTriggerInteraction)2);
		uint num = 0u;
		for (int i = 0; i < list.Count; i++)
		{
			BuildingBlock buildingBlock = list[i];
			Construction blockDefinition = buildingBlock.blockDefinition;
			Vector3 position2 = ((Component)buildingBlock).transform.position;
			Quaternion rotation2 = ((Component)buildingBlock).transform.rotation;
			ProximityInfo proximity = GetProximity(construction, position, rotation, blockDefinition, position2, rotation2);
			ProximityInfo proximity2 = GetProximity(blockDefinition, position2, rotation2, construction, position, rotation);
			ProximityInfo proximityInfo = default(ProximityInfo);
			proximityInfo.hit = proximity.hit || proximity2.hit;
			proximityInfo.connection = proximity.connection || proximity2.connection;
			if (proximity.sqrDist <= proximity2.sqrDist)
			{
				proximityInfo.line = proximity.line;
				proximityInfo.sqrDist = proximity.sqrDist;
			}
			else
			{
				proximityInfo.line = proximity2.line;
				proximityInfo.sqrDist = proximity2.sqrDist;
			}
			if (proximityInfo.connection)
			{
				BuildingManager.Building building = buildingBlock.GetBuilding();
				if (building != null)
				{
					BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
					if ((Object)(object)dominatingBuildingPrivilege != (Object)null)
					{
						if (!construction.canBypassBuildingPermission && !dominatingBuildingPrivilege.CanBuild(player))
						{
							Construction.lastPlacementError = Phrase.op_Implicit(ConstructionErrors.CannotAttachToUnauthorized.translated);
							Pool.FreeUnmanaged<BuildingBlock>(ref list);
							return true;
						}
						if (num == 0)
						{
							num = building.ID;
						}
						else if (num != building.ID)
						{
							if (!dominatingBuildingPrivilege.CanBuild(player))
							{
								Construction.lastPlacementError = ConstructionErrors.CannotAttachToUnauthorized;
							}
							else
							{
								Construction.lastPlacementError = ConstructionErrors.CannotConnectTwoBuildings;
							}
							Pool.FreeUnmanaged<BuildingBlock>(ref list);
							return true;
						}
					}
				}
			}
			if (proximityInfo.hit)
			{
				Vector3 val2 = proximityInfo.line.point1 - proximityInfo.line.point0;
				if (!(Mathf.Abs(val2.y) > 1.49f) && !(Vector3Ex.Magnitude2D(val2) > 1.49f))
				{
					string translated = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID).info.name.translated;
					Construction.lastPlacementError = Phrase.op_Implicit(string.Format(ConstructionErrors.TooCloseTo.translated, translated));
					Construction.lastPlacementErrorIsDetailed = true;
					Pool.FreeUnmanaged<BuildingBlock>(ref list);
					return true;
				}
			}
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
		return false;
	}

	public static ProximityInfo GetProximity(Construction construction1, Vector3 position1, Quaternion rotation1, Construction construction2, Vector3 position2, Quaternion rotation2)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		ProximityInfo result = default(ProximityInfo);
		result.hit = false;
		result.connection = false;
		result.line = default(Line);
		result.sqrDist = float.MaxValue;
		for (int i = 0; i < construction1.allSockets.Length; i++)
		{
			ConstructionSocket constructionSocket = construction1.allSockets[i] as ConstructionSocket;
			if (constructionSocket == null)
			{
				continue;
			}
			for (int j = 0; j < construction2.allSockets.Length; j++)
			{
				Socket_Base socket = construction2.allSockets[j];
				if (constructionSocket.CanConnect(position1, rotation1, socket, position2, rotation2))
				{
					result.connection = true;
					return result;
				}
			}
		}
		if (construction1.isServer)
		{
			for (int k = 0; k < construction1.allSockets.Length; k++)
			{
				Socket_Base socket_Base = construction1.allSockets[k];
				if (!(socket_Base is NeighbourSocket) && !(socket_Base is StabilitySocket))
				{
					continue;
				}
				for (int l = 0; l < construction2.allSockets.Length; l++)
				{
					Socket_Base socket2 = construction2.allSockets[l];
					if (socket_Base.CanConnect(position1, rotation1, socket2, position2, rotation2))
					{
						result.connection = true;
						return result;
					}
				}
			}
		}
		if (!result.connection && construction1.allProximities.Length != 0)
		{
			Line val = default(Line);
			for (int m = 0; m < construction1.allSockets.Length; m++)
			{
				ConstructionSocket constructionSocket2 = construction1.allSockets[m] as ConstructionSocket;
				if (constructionSocket2 == null || constructionSocket2.socketType != ConstructionSocket.Type.Wall)
				{
					continue;
				}
				Vector3 selectPivot = constructionSocket2.GetSelectPivot(position1, rotation1);
				for (int n = 0; n < construction2.allProximities.Length; n++)
				{
					Vector3 selectPivot2 = construction2.allProximities[n].GetSelectPivot(position2, rotation2);
					((Line)(ref val))..ctor(selectPivot, selectPivot2);
					Vector3 val2 = val.point1 - val.point0;
					float sqrMagnitude = ((Vector3)(ref val2)).sqrMagnitude;
					if (sqrMagnitude < result.sqrDist)
					{
						result.hit = true;
						result.line = val;
						result.sqrDist = sqrMagnitude;
					}
				}
			}
		}
		return result;
	}

	public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return position + rotation * worldPosition;
	}

	protected override Type GetIndexedType()
	{
		return typeof(BuildingProximity);
	}
}


public struct ProximityInfo
{
	public bool hit;

	public bool connection;

	public Line line;

	public float sqrDist;
}


using System;
using UnityEngine;

public class ConditionalModel : PrefabAttribute
{
	public GameObjectRef prefab;

	public bool onClient = true;

	public bool onServer = true;

	public bool IsImportant;

	[NonSerialized]
	public ModelConditionTest[] conditions;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		conditions = ((Component)this).GetComponentsInChildren<ModelConditionTest>(true);
	}

	public bool RunTests(BaseEntity parent)
	{
		for (int i = 0; i < conditions.Length; i++)
		{
			if (!conditions[i].DoTest(parent))
			{
				return false;
			}
		}
		return true;
	}

	public bool RunTestsExceptFoundationSide(BaseEntity parent)
	{
		for (int i = 0; i < conditions.Length; i++)
		{
			if (!(conditions[i] is ModelConditionTest_FoundationSide) && !conditions[i].DoTest(parent))
			{
				return false;
			}
		}
		return true;
	}

	public virtual GameObject InstantiateSkin(BaseEntity parent)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (!onServer && isServer)
		{
			return null;
		}
		GameObject val = gameManager.CreatePrefab(prefab.resourcePath, ((Component)parent).transform, active: false);
		if (Object.op_Implicit((Object)(object)val))
		{
			val.transform.localPosition = worldPosition;
			val.transform.localRotation = worldRotation;
			val.AwakeFromInstantiate();
		}
		return val;
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConditionalModel);
	}
}


using System;
using UnityEngine;

public class ConditionalModelWallpaper : ConditionalModel
{
	public bool softSide;

	public override GameObject InstantiateSkin(BaseEntity parent)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if (!onServer && isServer)
		{
			return null;
		}
		GameObject val = gameManager.CreatePrefab(prefab.resourcePath, ((Component)parent).transform, active: false);
		if ((Object)(object)val != (Object)null)
		{
			val.transform.localPosition = worldPosition;
			val.transform.localRotation = worldRotation;
			BuildingBlock buildingBlock = parent as BuildingBlock;
			if ((Object)(object)buildingBlock != (Object)null)
			{
				ItemDefinition itemDefForCategory = WallpaperSettings.GetItemDefForCategory(WallpaperPlanner.Settings.GetCategory(buildingBlock, (!softSide) ? 1 : 0));
				SkinHelpers.SetSkin(val, itemDefForCategory, softSide ? buildingBlock.wallpaperID : buildingBlock.wallpaperID2);
				float num = (softSide ? buildingBlock.wallpaperRotation : buildingBlock.wallpaperRotation2);
				if (num != 0f)
				{
					Vector3 localEulerAngles = val.transform.localEulerAngles;
					localEulerAngles.y += num;
					val.transform.localRotation = Quaternion.Euler(localEulerAngles);
				}
				val.AwakeFromInstantiate();
			}
		}
		return val;
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConditionalModel);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Serialization;

public class Construction : PrefabAttribute
{
	public class Grade
	{
		public BuildingGrade grade;

		public float maxHealth;

		public List<ItemAmount> costToBuild;

		public PhysicMaterial physicMaterial => grade.physicMaterial;

		public ProtectionProperties damageProtecton => grade.damageProtecton;
	}

	public struct Target
	{
		public bool valid;

		public Ray ray;

		public BaseEntity entity;

		public Socket_Base socket;

		public bool onTerrain;

		public Vector3 position;

		public Vector3 normal;

		public Vector3 rotation;

		public BasePlayer player;

		public bool buildingBlocked;

		public bool isHoldingShift;

		public Quaternion GetWorldRotation(bool female)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			Quaternion val = socket.rotation;
			if (socket.male && socket.female && female)
			{
				val = socket.rotation * Quaternion.Euler(180f, 0f, 180f);
			}
			return ((Component)entity).transform.rotation * val;
		}

		public Vector3 GetWorldPosition()
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			Matrix4x4 localToWorldMatrix = ((Component)entity).transform.localToWorldMatrix;
			return ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(socket.position);
		}
	}

	public struct Placement
	{
		public Vector3 position;

		public Quaternion rotation;

		public bool isPopulated;

		public readonly bool isHoldingShift;

		public Transform transform;

		public Placement(Target target)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			isHoldingShift = target.isHoldingShift;
			position = Vector3.zero;
			rotation = Quaternion.identity;
			isPopulated = true;
			transform = null;
			if ((Object)(object)target.entity != (Object)null)
			{
				transform = ((Component)target.entity).transform;
			}
		}
	}

	public BaseEntity.Menu.Option info;

	public bool canBypassBuildingPermission;

	public bool showBuildingBlockedPreview = true;

	[InspectorName("Can bypass road checks")]
	public bool canPlaceOnRoads;

	[FormerlySerializedAs("canRotate")]
	public bool canRotateBeforePlacement;

	[FormerlySerializedAs("canRotate")]
	public bool canRotateAfterPlacement;

	public bool checkVolumeOnRotate;

	public bool checkVolumeOnUpgrade;

	public bool canPlaceAtMaxDistance;

	public bool placeOnWater;

	public bool overridePlacementLayer;

	public LayerMask overridedPlacementLayer;

	public LayerMask additionalPlacementLayer;

	public Vector3 rotationAmount = new Vector3(0f, 90f, 0f);

	public Vector3 applyStartingRotation = Vector3.zero;

	public Transform deployOffset;

	public bool enforceLineOfSightCheckAgainstParentEntity;

	[Tooltip("Axis Snapping for IO Entities.")]
	public bool canSnap;

	public float holdToPlaceDuration;

	public bool canFloodFillSockets;

	[Space]
	public bool alternativeLOSChecks;

	public Vector3[] alternativeLOSPositions;

	public bool canUseLastValidPosition = true;

	[Range(0f, 10f)]
	public float healthMultiplier = 1f;

	[Range(0f, 10f)]
	public float costMultiplier = 1f;

	[Range(1f, 50f)]
	public float maxplaceDistance = 4f;

	[Range(0f, 10f)]
	public float minPlaceDistance = 1f;

	public Mesh guideMesh;

	[NonSerialized]
	public Socket_Base[] allSockets;

	[NonSerialized]
	public BuildingProximity[] allProximities;

	[NonSerialized]
	public ConstructionGrade defaultGrade;

	[NonSerialized]
	public SocketHandle socketHandle;

	[NonSerialized]
	public Bounds bounds;

	[NonSerialized]
	public bool isBuildingPrivilege;

	[NonSerialized]
	public bool isSleepingBag;

	[NonSerialized]
	public ConstructionGrade[] grades;

	[NonSerialized]
	public Deployable deployable;

	[NonSerialized]
	public ConstructionPlaceholder placeholder;

	[ReplicatedVar]
	public static bool alternativeLOSChecks_enabled = true;

	public static Phrase lastPlacementError = Phrase.op_Implicit(string.Empty);

	public static bool lastPlacementErrorIsDetailed;

	public static string lastPlacementErrorDebug;

	public static BuildingBlock lastBuildingBlockError;

	public BaseEntity CreateConstruction(Target target, bool bNeedsValidPlacement = false)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = GameManager.server.CreatePrefab(fullName, Vector3.zero, Quaternion.identity, active: false);
		bool flag = UpdatePlacement(val.transform, this, ref target);
		BaseEntity baseEntity = val.ToBaseEntity();
		if (bNeedsValidPlacement && !flag)
		{
			if (baseEntity.IsValid())
			{
				baseEntity.Kill();
			}
			else
			{
				GameManager.Destroy(val);
			}
			return null;
		}
		DecayEntity decayEntity = baseEntity as DecayEntity;
		if (Object.op_Implicit((Object)(object)decayEntity))
		{
			decayEntity.AttachToBuilding(target.entity as DecayEntity);
		}
		return baseEntity;
	}

	public bool HasMaleSockets(Target target)
	{
		Socket_Base[] array = allSockets;
		foreach (Socket_Base socket_Base in array)
		{
			if (socket_Base.male && !socket_Base.maleDummy && socket_Base.TestTarget(target))
			{
				return true;
			}
		}
		return false;
	}

	public void FindMaleSockets(Target target, List<Socket_Base> sockets)
	{
		Socket_Base[] array = allSockets;
		foreach (Socket_Base socket_Base in array)
		{
			if (socket_Base.male && !socket_Base.maleDummy && socket_Base.TestTarget(target))
			{
				sockets.Add(socket_Base);
			}
		}
	}

	public ConstructionGrade GetGrade(BuildingGrade.Enum iGrade, ulong iSkin)
	{
		ConstructionGrade[] array = grades;
		foreach (ConstructionGrade constructionGrade in array)
		{
			if (constructionGrade.gradeBase.type == iGrade && constructionGrade.gradeBase.skin == iSkin)
			{
				return constructionGrade;
			}
		}
		return defaultGrade;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		isBuildingPrivilege = Object.op_Implicit((Object)(object)rootObj.GetComponent<BuildingPrivlidge>());
		isSleepingBag = Object.op_Implicit((Object)(object)rootObj.GetComponent<SleepingBag>());
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
		deployable = ((Component)this).GetComponent<Deployable>();
		placeholder = ((Component)this).GetComponentInChildren<ConstructionPlaceholder>();
		allSockets = ((Component)this).GetComponentsInChildren<Socket_Base>(true);
		allProximities = ((Component)this).GetComponentsInChildren<BuildingProximity>(true);
		socketHandle = ((Component)this).GetComponentsInChildren<SocketHandle>(true).FirstOrDefault();
		grades = rootObj.GetComponents<ConstructionGrade>();
		ConstructionGrade[] array = grades;
		foreach (ConstructionGrade constructionGrade in array)
		{
			if (!(constructionGrade == null))
			{
				constructionGrade.construction = this;
				if (!(defaultGrade != null))
				{
					defaultGrade = constructionGrade;
				}
			}
		}
	}

	protected override Type GetIndexedType()
	{
		return typeof(Construction);
	}

	public bool HasAlternativeLOSChecks()
	{
		if (alternativeLOSChecks_enabled && alternativeLOSChecks && alternativeLOSPositions != null)
		{
			return alternativeLOSPositions.Length != 0;
		}
		return false;
	}

	public bool UpdatePlacement(Transform transform, Construction common, ref Target target)
	{
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_045e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0464: Unknown result type (might be due to invalid IL or missing references)
		//IL_046a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_041d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		//IL_0491: Unknown result type (might be due to invalid IL or missing references)
		//IL_0533: Unknown result type (might be due to invalid IL or missing references)
		//IL_053a: Unknown result type (might be due to invalid IL or missing references)
		//IL_054d: Unknown result type (might be due to invalid IL or missing references)
		if (!target.valid)
		{
			if (common.placeOnWater)
			{
				lastPlacementError = ConstructionErrors.WantsWater;
			}
			return false;
		}
		if (!common.canBypassBuildingPermission && !target.player.CanBuild())
		{
			lastPlacementError = ConstructionErrors.NoPermission;
			return false;
		}
		List<Socket_Base> list = Pool.Get<List<Socket_Base>>();
		common.FindMaleSockets(target, list);
		foreach (Socket_Base item in list)
		{
			Placement placement = default(Placement);
			if ((Object)(object)target.entity != (Object)null && target.socket != null && target.entity.IsOccupied(target.socket))
			{
				continue;
			}
			if (!placement.isPopulated)
			{
				placement = item.DoPlacement(target);
			}
			if ((Object)(object)target.player != (Object)null && target.player.IsInTutorial)
			{
				TutorialIsland currentTutorialIsland = target.player.GetCurrentTutorialIsland();
				if ((Object)(object)currentTutorialIsland != (Object)null && !currentTutorialIsland.CheckPlacement(common, target, ref placement))
				{
					placement = default(Placement);
				}
			}
			if (!placement.isPopulated)
			{
				continue;
			}
			if (target.player.IsInCreativeMode && Creative.freePlacement)
			{
				transform.SetPositionAndRotation(placement.position, placement.rotation);
				return true;
			}
			if (!item.CheckSocketMods(ref placement))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				continue;
			}
			if (!TestPlacingThroughRock(ref placement, target))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.ThroughRock;
				continue;
			}
			if (common.HasAlternativeLOSChecks())
			{
				if (target.socket == null && !TestPlacingThroughWall(ref placement, transform, common, target))
				{
					transform.position = placement.position;
					transform.rotation = placement.rotation;
					lastPlacementError = ConstructionErrors.ThroughWalls;
					lastPlacementErrorDebug = "Placing through walls";
					continue;
				}
				if (!Planner.HasLineOfSight(ref placement, common, target))
				{
					transform.position = placement.position;
					transform.rotation = placement.rotation;
					lastPlacementError = ConstructionErrors.LineOfSightBlocked;
					continue;
				}
			}
			else if (!TestPlacingThroughWall(ref placement, transform, common, target))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.ThroughWalls;
				lastPlacementErrorDebug = "Placing through walls";
				continue;
			}
			if (!TestPlacingCloseToRoad(ref placement, target, common))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.TooCloseToRoad;
				continue;
			}
			if (target.entity is Door && target.socket == null)
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.CantDeployOnDoor;
				continue;
			}
			if (Vector3.Distance(placement.position, target.player.eyes.position) > common.maxplaceDistance + 1f)
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.TooFarAway;
				continue;
			}
			DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(prefabID);
			if (DeployVolume.Check(placement.position, placement.rotation, volumes))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				if ((Object)(object)DeployVolume.LastDeployHit != (Object)null)
				{
					lastPlacementErrorDebug = ((Object)DeployVolume.LastDeployHit).name;
					string blockedByErrorFromCollider = ConstructionErrors.GetBlockedByErrorFromCollider(DeployVolume.LastDeployHit, target.player);
					if (!string.IsNullOrEmpty(blockedByErrorFromCollider))
					{
						lastPlacementError = Phrase.op_Implicit(blockedByErrorFromCollider);
						lastPlacementErrorIsDetailed = true;
						continue;
					}
				}
				lastPlacementError = ConstructionErrors.NotEnoughSpace;
				continue;
			}
			if (BuildingProximity.Check(target.player, this, placement.position, placement.rotation))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				continue;
			}
			if (common.isBuildingPrivilege && !target.player.CanPlaceBuildingPrivilege(placement.position, placement.rotation, common.bounds))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.StackPrivilege;
				continue;
			}
			bool flag = target.player.IsBuildingBlocked(placement.position, placement.rotation, common.bounds, cached: false);
			if (!common.canBypassBuildingPermission && flag)
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.NoPermission;
				continue;
			}
			target.buildingBlocked = flag;
			transform.SetPositionAndRotation(placement.position, placement.rotation);
			if ((!((Object)(object)target.player != (Object)null) || !target.player.IsInCreativeMode || !Creative.bypassHoldToPlaceDuration) && common.holdToPlaceDuration > 0f && (Object)(object)target.player != (Object)null && isServer && target.player.GetHeldEntity() is Planner planner && (Vector3.Distance(((Component)target.player).transform.position, planner.serverStartDurationPlacementPosition) > 1f || Mathf.Abs(TimeSince.op_Implicit(planner.serverStartDurationPlacementTime) - common.holdToPlaceDuration) > 0.5f))
			{
				return false;
			}
			Pool.FreeUnmanaged<Socket_Base>(ref list);
			return true;
		}
		Pool.FreeUnmanaged<Socket_Base>(ref list);
		return false;
	}

	private bool TestPlacingThroughRock(ref Placement placement, Target target)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(placement.position, Vector3.one, placement.rotation, bounds);
		Vector3 center = target.player.GetCenter(ducked: true);
		Vector3 origin = ((Ray)(ref target.ray)).origin;
		if (Physics.Linecast(center, origin, 65536, (QueryTriggerInteraction)1))
		{
			return false;
		}
		RaycastHit val2 = default(RaycastHit);
		Vector3 val3 = (((OBB)(ref val)).Trace(target.ray, ref val2, float.PositiveInfinity) ? ((RaycastHit)(ref val2)).point : ((OBB)(ref val)).ClosestPoint(origin));
		if (Physics.Linecast(origin, val3, 65536, (QueryTriggerInteraction)1))
		{
			return false;
		}
		return true;
	}

	private static bool TestPlacingThroughWall(ref Placement placement, Transform transform, Construction common, Target target)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = placement.position;
		if ((Object)(object)common.deployOffset != (Object)null)
		{
			val += placement.rotation * common.deployOffset.localPosition;
		}
		Vector3 val2 = val - ((Ray)(ref target.ray)).origin;
		RaycastHit hit = default(RaycastHit);
		if (!Physics.Raycast(((Ray)(ref target.ray)).origin, ((Vector3)(ref val2)).normalized, ref hit, ((Vector3)(ref val2)).magnitude, 2097152))
		{
			return true;
		}
		StabilityEntity stabilityEntity = hit.GetEntity() as StabilityEntity;
		if (!common.enforceLineOfSightCheckAgainstParentEntity && (Object)(object)stabilityEntity != (Object)null && (Object)(object)target.entity == (Object)(object)stabilityEntity)
		{
			return true;
		}
		if (((Vector3)(ref val2)).magnitude - ((RaycastHit)(ref hit)).distance < 0.2f)
		{
			return true;
		}
		transform.SetPositionAndRotation(((RaycastHit)(ref hit)).point, placement.rotation);
		return false;
	}

	private bool TestPlacingCloseToRoad(ref Placement placement, Target target, Construction construction)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		if (construction.canPlaceOnRoads)
		{
			return true;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		if ((Object)(object)heightMap == (Object)null)
		{
			return true;
		}
		if ((Object)(object)topologyMap == (Object)null)
		{
			return true;
		}
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(placement.position, Vector3.one, placement.rotation, bounds);
		float num = Mathf.Abs(heightMap.GetHeight(val.position) - val.position.y);
		if (num > 9f)
		{
			return true;
		}
		float radius = Mathf.Lerp(3f, 0f, num / 9f);
		Vector3 position = val.position;
		Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
		Vector3 point2 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
		Vector3 point3 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
		Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
		int topology = topologyMap.GetTopology(position, radius);
		int topology2 = topologyMap.GetTopology(point, radius);
		int topology3 = topologyMap.GetTopology(point2, radius);
		int topology4 = topologyMap.GetTopology(point3, radius);
		int topology5 = topologyMap.GetTopology(point4, radius);
		if (((topology | topology2 | topology3 | topology4 | topology5) & 0x80800) == 0)
		{
			return true;
		}
		return false;
	}

	public virtual bool ShowAsNeutral(Target target)
	{
		return target.buildingBlocked;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class Grade
{
	public BuildingGrade grade;

	public float maxHealth;

	public List<ItemAmount> costToBuild;

	public PhysicMaterial physicMaterial => grade.physicMaterial;

	public ProtectionProperties damageProtecton => grade.damageProtecton;
}


using UnityEngine;

public struct Target
{
	public bool valid;

	public Ray ray;

	public BaseEntity entity;

	public Socket_Base socket;

	public bool onTerrain;

	public Vector3 position;

	public Vector3 normal;

	public Vector3 rotation;

	public BasePlayer player;

	public bool buildingBlocked;

	public bool isHoldingShift;

	public Quaternion GetWorldRotation(bool female)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = socket.rotation;
		if (socket.male && socket.female && female)
		{
			val = socket.rotation * Quaternion.Euler(180f, 0f, 180f);
		}
		return ((Component)entity).transform.rotation * val;
	}

	public Vector3 GetWorldPosition()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = ((Component)entity).transform.localToWorldMatrix;
		return ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(socket.position);
	}
}


using UnityEngine;

public struct Placement
{
	public Vector3 position;

	public Quaternion rotation;

	public bool isPopulated;

	public readonly bool isHoldingShift;

	public Transform transform;

	public Placement(Target target)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		isHoldingShift = target.isHoldingShift;
		position = Vector3.zero;
		rotation = Quaternion.identity;
		isPopulated = true;
		transform = null;
		if ((Object)(object)target.entity != (Object)null)
		{
			transform = ((Component)target.entity).transform;
		}
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public static class ConstructionErrors
{
	public static readonly Phrase NoPermission = new Phrase("error_buildpermission", "You don't have permission to build here");

	public static readonly Phrase StackPrivilege = new Phrase("error_stackprivilege", "Cannot stack building privileges");

	public static readonly Phrase CantBuildWhileMoving = new Phrase("error_whilemoving", "You can't build this while moving");

	public static readonly Phrase ThroughRock = new Phrase("error_throughrock", "Placing through rock");

	public static readonly Phrase ThroughWalls = new Phrase("error_throughwalls", "Placing through walls");

	public static readonly Phrase InsideObjects = new Phrase("error_insideobjects", "Can't deploy inside objects");

	public static readonly Phrase TooCloseToRoad = new Phrase("error_tooclosetoroad", "Placing too close to road");

	public static readonly Phrase TooFarAway = new Phrase("error_toofar", "Too far away");

	public static readonly Phrase BlockedBy = new Phrase("error_blockedby", "Blocked by {0}");

	public static readonly Phrase BlockedByPlayer = new Phrase("error_blockedbyplayer", "Blocked by Player {0}");

	public static readonly Phrase BlockedByVehicle = new Phrase("error_blockedbyvehicle", "Blocked by Vehicle");

	public static readonly Phrase TooCloseTo = new Phrase("error_toocloseto", "Too close to {0}");

	public static readonly Phrase TooCloseToMonument = new Phrase("error_tooclosetomonument", "Cannot build this close to {0}");

	public static readonly Phrase BlockedByTree = new Phrase("error_blockedbytree", "Blocked by tree");

	public static readonly Phrase BlockedByTerrain = new Phrase("error_blockedbyterrain", "Blocked by terrain");

	public static readonly Phrase SkinNotOwned = new Phrase("error_skinnotowned", "Skin not owned");

	public static readonly Phrase CannotBuildInThisArea = new Phrase("error_cannotbuildarea", "Cannot build in this area");

	public static readonly Phrase NotEnoughSpace = new Phrase("error_notenoughspace", "Not enough space");

	public static readonly Phrase NotStableEnough = new Phrase("error_notstableenough", "Not stable enough");

	public static readonly Phrase MustPlaceOnConstruction = new Phrase("error_wantsconstruction", "Must be placed on a construction");

	public static readonly Phrase CantPlaceOnConstruction = new Phrase("error_doesnotwantconstruction", "Cannot be placed on constructions");

	public static readonly Phrase CantPlaceOnMonument = new Phrase("error_cantplaceonmonument", "Cannot be placed on monument");

	public static readonly Phrase NotInTerrain = new Phrase("error_notinterrain", "Not in terrain");

	public static readonly Phrase MustPlaceOnRoad = new Phrase("error_placement_needs_road", "Must be placed on road");

	public static readonly Phrase CantPlaceOnRoad = new Phrase("error_placement_no_road", "Cannot be placed on road");

	public static readonly Phrase InvalidAreaVehicleLarge = new Phrase("error_invalidarea_vehiclelarge", "Cannot deploy near a large vehicle");

	public static readonly Phrase InvalidAngle = new Phrase("error_invalidangle", "Invalid angle");

	public static readonly Phrase InvalidEntity = new Phrase("error_invalidentitycheck", "Invalid entity");

	public static readonly Phrase InvalidEntityType = new Phrase("error_invalidentitytype", "Invalid entity type");

	public static readonly Phrase WantsWater = new Phrase("error_inwater_wants", "Must be placed in water");

	public static readonly Phrase WantsWaterBody = new Phrase("error_inwater_wants_body", "Must be placed in a body of water");

	public static readonly Phrase InWater = new Phrase("error_inwater", "Can't be placed in water");

	public static readonly Phrase TooDeep = new Phrase("error_toodeep", "Water is too deep");

	public static readonly Phrase TooShallow = new Phrase("error_shallow", "Water is too shallow");

	public static readonly Phrase CouldntFindConstruction = new Phrase("error_counlndfindconstruction", "Couldn't find construction");

	public static readonly Phrase CouldntFindEntity = new Phrase("error_counlndfindentity", "Couldn't find entity");

	public static readonly Phrase CouldntFindSocket = new Phrase("error_counlndfindsocket", "Couldn't find socket");

	public static readonly Phrase Antihack = new Phrase("error_antihack", "Anti hack!");

	public static readonly Phrase AntihackWithReason = new Phrase("error_antihack_reason", "Anti hack! ({0})");

	public static readonly Phrase CantDeployOnDoor = new Phrase("error_cantdeployondoor", "Can't deploy on door");

	public static readonly Phrase DeployableMismatch = new Phrase("error_deployablemismatch", "Deployable mismatch!");

	public static readonly Phrase LineOfSightBlocked = new Phrase("error_lineofsightblocked", "Line of sight blocked");

	public static readonly Phrase ParentTooFar = new Phrase("error_parenttoofar", "Parent too far away");

	public static readonly Phrase SocketOccupied = new Phrase("error_sockectoccupied", "Target socket is occupied");

	public static readonly Phrase SocketNotFemale = new Phrase("error_socketnotfemale", "Target socket is not female");

	public static readonly Phrase WantsInside = new Phrase("error_wantsinside", "Must be placed inside your base");

	public static readonly Phrase WantsOutside = new Phrase("error_wantsoutside", "Can't be placed inside a base");

	public static readonly Phrase PlayerName = new Phrase("error_name_player", "Player {0}");

	public static readonly Phrase HorseName = new Phrase("error_name_horse", "Horse");

	public static readonly Phrase ModularCarName = new Phrase("error_name_modularcar", "Modular Car");

	public static readonly Phrase TreeName = new Phrase("error_name_tree", "Tree");

	public static readonly Phrase DebrisName = new Phrase("error_name_debris", "Debris");

	public static readonly Phrase OreName = new Phrase("error_name_ore", "Ore");

	public static readonly Phrase DroppedItemName = new Phrase("error_dropped_item", "Dropped item");

	public static readonly Phrase CannotAttachToUnauthorized = new Phrase("error_cannotattachtounauth", "Cannot attach to unauthorized building");

	public static readonly Phrase CannotConnectTwoBuildings = new Phrase("error_connecttwobuildings", "Cannot connect two buildings with cupboards");

	public static readonly Phrase CantUpgradeRecentlyDamaged = new Phrase("error_upgraderecentlydamaged", "Recently damaged, upgradable in {0} seconds");

	public static readonly Phrase CantRotateAnymore = new Phrase("grade_rotationblocked", "Can't rotate this block anymore");

	public static readonly Phrase CantDemolishAnymore = new Phrase("grade_demolishblocked", "Can't demolish this block anymore");

	public static string GetTranslatedNameFromEntity(BaseEntity entity, BasePlayer fromPlayer = null)
	{
		if (entity is ModularCar || entity is BaseVehicleModule)
		{
			return ModularCarName.translated;
		}
		if (entity is BaseVehicleSeat && entity.parentEntity.Get(serverside: false) is RidableHorse)
		{
			return HorseName.translated;
		}
		if (entity is BaseNPC2 baseNPC)
		{
			return baseNPC.displayName;
		}
		if (entity is RidableHorse || entity is HorseSaddle)
		{
			return HorseName.translated;
		}
		if (entity is HumanNPC humanNPC)
		{
			return humanNPC.displayName;
		}
		if (entity is BasePlayer { displayName: var arg } basePlayer)
		{
			if ((Object)(object)fromPlayer != (Object)null)
			{
				arg = NameHelper.GetPlayerNameStreamSafe(fromPlayer, basePlayer);
			}
			return string.Format(PlayerName.translated, arg);
		}
		if (entity is BuildingBlock buildingBlock)
		{
			return PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID).info.name.translated;
		}
		if (entity is DebrisEntity)
		{
			return DebrisName.translated;
		}
		if (entity is TreeEntity)
		{
			return TreeName.translated;
		}
		if (entity is OreResourceEntity)
		{
			return OreName.translated;
		}
		if (entity is DroppedItem)
		{
			return DroppedItemName.translated;
		}
		SprayCan.GetItemDefinitionForEntity(entity, out var def);
		if ((Object)(object)def != (Object)null)
		{
			return def.displayName.translated;
		}
		return string.Empty;
	}

	public static string GetBlockedByErrorFromEntity(BaseEntity entity, BasePlayer fromPlayer = null)
	{
		string translatedNameFromEntity = GetTranslatedNameFromEntity(entity, fromPlayer);
		if (!string.IsNullOrEmpty(translatedNameFromEntity))
		{
			return string.Format(BlockedBy.translated, translatedNameFromEntity);
		}
		return null;
	}

	public static string GetBlockedByErrorFromCollider(Collider col, BasePlayer fromPlayer = null)
	{
		PreventBuildingMonumentTag preventBuildingMonumentTag = GetPreventBuildingMonumentTag(col);
		if ((Object)(object)preventBuildingMonumentTag != (Object)null)
		{
			return string.Format(TooCloseToMonument.translated, preventBuildingMonumentTag.GetAttachedMonument().displayPhrase.translated);
		}
		BaseEntity baseEntity = col.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			return GetBlockedByErrorFromEntity(baseEntity, fromPlayer);
		}
		if (col is TerrainCollider)
		{
			return BlockedByTerrain.translated;
		}
		return null;
	}

	public static PreventBuildingMonumentTag GetPreventBuildingMonumentTag(Collider col)
	{
		PreventBuildingMonumentTag preventBuildingMonumentTag = default(PreventBuildingMonumentTag);
		if ((Object)(object)col != (Object)null && ((Component)col).TryGetComponent<PreventBuildingMonumentTag>(ref preventBuildingMonumentTag) && (Object)(object)preventBuildingMonumentTag.GetAttachedMonument() != (Object)null && !((Component)preventBuildingMonumentTag).gameObject.HasCustomTag(GameObjectTag.BlockPlacement))
		{
			return preventBuildingMonumentTag;
		}
		return null;
	}

	public static void Log(BasePlayer player, string message)
	{
		if (!((Object)(object)player == (Object)null) && !string.IsNullOrEmpty(message) && player.isServer && player.net.connection.info.GetBool("client.errortoasts_debug", false))
		{
			player.ChatMessage(message);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

public class ConstructionGrade : PrefabAttribute
{
	private struct CachedAmount
	{
		public List<ItemAmount> costs;

		public float cachedConVarMultiplier;
	}

	[NonSerialized]
	public Construction construction;

	public BuildingGrade gradeBase;

	public GameObjectRef skinObject;

	private Dictionary<BuildingGrade.Enum, CachedAmount> _costs;

	private float _costBuildPercent;

	public float maxHealth
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)gradeBase) || !construction)
			{
				return 0f;
			}
			return gradeBase.baseHealth * construction.healthMultiplier;
		}
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		_costs = new Dictionary<BuildingGrade.Enum, CachedAmount>();
		foreach (BuildingGrade.Enum value in Enum.GetValues(typeof(BuildingGrade.Enum)))
		{
			UpdateCosts(value);
		}
	}

	private void UpdateCosts(BuildingGrade.Enum grade)
	{
		List<ItemAmount> list = new List<ItemAmount>();
		float num = ((grade == gradeBase.type) ? 0.2f : 1f);
		float costMultiplier = ConVar.Decay.GetCostMultiplier(gradeBase.type);
		foreach (ItemAmount item in gradeBase.baseCost)
		{
			list.Add(new ItemAmount(item.itemDef, Mathf.Ceil(item.amount * construction.costMultiplier * num * costMultiplier)));
		}
		_costs[grade] = new CachedAmount
		{
			cachedConVarMultiplier = costMultiplier,
			costs = list
		};
	}

	public List<ItemAmount> CostToBuild(BuildingGrade.Enum fromGrade = BuildingGrade.Enum.None)
	{
		if (ConVar.Decay.GetCostMultiplier(gradeBase.type) != _costs[fromGrade].cachedConVarMultiplier)
		{
			UpdateCosts(fromGrade);
		}
		return _costs[fromGrade].costs;
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConstructionGrade);
	}
}


using System.Collections.Generic;

private struct CachedAmount
{
	public List<ItemAmount> costs;

	public float cachedConVarMultiplier;
}


using System;
using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode]
public class ConstructionPlaceholder : PrefabAttribute, IPrefabPreProcess
{
	public Mesh mesh;

	public Material material;

	public bool renderer;

	public bool collider;

	[NonSerialized]
	public MeshRenderer MeshRenderer;

	[NonSerialized]
	public MeshFilter MeshFilter;

	[NonSerialized]
	public MeshCollider MeshCollider;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		if (!clientside || !((Behaviour)this).enabled)
		{
			return;
		}
		if (renderer)
		{
			MeshFilter = rootObj.GetComponent<MeshFilter>();
			MeshRenderer = rootObj.GetComponent<MeshRenderer>();
			if (!Object.op_Implicit((Object)(object)MeshFilter))
			{
				MeshFilter = rootObj.AddComponent<MeshFilter>();
				MeshFilter.sharedMesh = mesh;
			}
			if (!Object.op_Implicit((Object)(object)MeshRenderer))
			{
				MeshRenderer = rootObj.AddComponent<MeshRenderer>();
				((Renderer)MeshRenderer).sharedMaterial = material;
				((Renderer)MeshRenderer).shadowCastingMode = (ShadowCastingMode)0;
			}
		}
		if (collider)
		{
			MeshCollider = rootObj.GetComponent<MeshCollider>();
			if (!Object.op_Implicit((Object)(object)MeshCollider))
			{
				MeshCollider = rootObj.AddComponent<MeshCollider>();
				MeshCollider.sharedMesh = mesh;
			}
		}
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConstructionPlaceholder);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ConstructionSkin : BasePrefab
{
	public List<GameObject> conditionals;

	public ulong DetermineConditionalModelState(BuildingBlock parent)
	{
		ConditionalModel[] array = PrefabAttribute.server.FindAll<ConditionalModel>(prefabID);
		if (array.Length > 64)
		{
			Debug.LogError((object)("Too many ConditionalModels on " + ((Object)parent).name + "! Maximum supported is 64"));
		}
		ulong num = 0uL;
		for (int i = 0; i < array.Length && i < 64; i++)
		{
			if (array[i].RunTests(parent))
			{
				num |= (ulong)(1L << i);
			}
		}
		return num;
	}

	private void CreateConditionalModels(BuildingBlock parent)
	{
		ConditionalModel[] array = PrefabAttribute.server.FindAll<ConditionalModel>(prefabID);
		for (int i = 0; i < array.Length; i++)
		{
			if (!parent.GetConditionalModel(i))
			{
				continue;
			}
			GameObject val = array[i].InstantiateSkin(parent);
			if (!((Object)(object)val == (Object)null))
			{
				if (conditionals == null)
				{
					conditionals = new List<GameObject>();
				}
				conditionals.Add(val);
			}
		}
	}

	private void DestroyConditionalModels(BuildingBlock parent)
	{
		if (conditionals != null)
		{
			for (int i = 0; i < conditionals.Count; i++)
			{
				parent.gameManager.Retire(conditionals[i]);
			}
			conditionals.Clear();
		}
	}

	public virtual void Refresh(BuildingBlock parent)
	{
		DestroyConditionalModels(parent);
		CreateConditionalModels(parent);
	}

	public void Destroy(BuildingBlock parent)
	{
		DestroyConditionalModels(parent);
		parent.gameManager.Retire(((Component)this).gameObject);
	}

	public virtual uint GetStartingDetailColour(uint playerColourIndex)
	{
		return 0u;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Construction Colour Lookup")]
public class ConstructionSkin_ColourLookup : ScriptableObject
{
	public Texture2D Sample;

	public Color[] AllColours;
}


using UnityEngine;

public class ConstructionSkin_CustomDetail : ConstructionSkin
{
	public ConstructionSkin_ColourLookup ColourLookup;

	public override uint GetStartingDetailColour(uint playerColourIndex)
	{
		if (playerColourIndex != 0)
		{
			return (uint)Mathf.Clamp((float)playerColourIndex, 1f, (float)(ColourLookup.AllColours.Length + 1));
		}
		return (uint)Random.Range(1, ColourLookup.AllColours.Length + 1);
	}
}


using UnityEngine;

public class ConstructionSocket : Socket_Base
{
	public enum Type
	{
		None,
		Foundation,
		Floor,
		Misc,
		Doorway,
		Wall,
		Block,
		Ramp,
		StairsTriangle,
		Stairs,
		FloorFrameTriangle,
		Window,
		Shutters,
		WallFrame,
		FloorFrame,
		WindowDressing,
		DoorDressing,
		Elevator,
		DoubleDoorDressing
	}

	public Type socketType;

	public int rotationDegrees;

	public int rotationOffset;

	public bool restrictPlacementRotation;

	public bool restrictPlacementAngle;

	public float faceAngle;

	public float angleAllowed = 150f;

	public bool wantsInside;

	[Range(0f, 1f)]
	public float support = 1f;

	private static readonly Vector3[] outsideLookupDirs;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.6f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	private void OnDrawGizmosSelected()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (female)
		{
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.DrawWireCube(selectCenter, selectSize);
		}
	}

	public override bool TestTarget(Construction.Target target)
	{
		if (!base.TestTarget(target))
		{
			return false;
		}
		return IsCompatible(target.socket);
	}

	public override bool IsCompatible(Socket_Base socket)
	{
		if (!base.IsCompatible(socket))
		{
			return false;
		}
		ConstructionSocket constructionSocket = socket as ConstructionSocket;
		if (constructionSocket == null)
		{
			return false;
		}
		if (constructionSocket.socketType == Type.None || socketType == Type.None)
		{
			return false;
		}
		if (constructionSocket.socketType != socketType)
		{
			return false;
		}
		return true;
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		Matrix4x4 val = Matrix4x4.TRS(position, rotation, Vector3.one);
		Matrix4x4 val2 = Matrix4x4.TRS(socketPosition, socketRotation, Vector3.one);
		Vector3 val3 = ((Matrix4x4)(ref val)).MultiplyPoint3x4(worldPosition);
		Vector3 val4 = ((Matrix4x4)(ref val2)).MultiplyPoint3x4(socket.worldPosition);
		if (Vector3.Distance(val3, val4) > 0.02f)
		{
			return false;
		}
		Vector3 val5 = ((Matrix4x4)(ref val)).MultiplyVector(worldRotation * Vector3.forward);
		Vector3 val6 = ((Matrix4x4)(ref val2)).MultiplyVector(socket.worldRotation * Vector3.forward);
		float num = Vector3.Angle(val5, val6);
		if (male && female)
		{
			num = Mathf.Min(num, Vector3.Angle(-val5, val6));
		}
		if (socket.male && socket.female)
		{
			num = Mathf.Min(num, Vector3.Angle(val5, -val6));
		}
		if (num > 2f)
		{
			return false;
		}
		return true;
	}

	public bool TestRestrictedAngles(Vector3 suggestedPos, Quaternion suggestedAng, Construction.Target target)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (restrictPlacementAngle)
		{
			Quaternion val = Quaternion.Euler(0f, faceAngle, 0f) * suggestedAng;
			float num = Vector3Ex.DotDegrees(Vector3Ex.XZ3D(((Ray)(ref target.ray)).direction), val * Vector3.forward);
			if (num > angleAllowed * 0.5f)
			{
				return false;
			}
			if (num < angleAllowed * -0.5f)
			{
				return false;
			}
		}
		return true;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)target.entity) || !Object.op_Implicit((Object)(object)((Component)target.entity).transform))
		{
			return default(Construction.Placement);
		}
		if (!CanConnectToEntity(target))
		{
			return default(Construction.Placement);
		}
		ConstructionSocket constructionSocket = target.socket as ConstructionSocket;
		Vector3 val = target.GetWorldPosition();
		Quaternion val2 = target.GetWorldRotation(female: true);
		if (constructionSocket != null && !IsCompatible(constructionSocket))
		{
			return default(Construction.Placement);
		}
		if (wantsInside)
		{
			Vector3 pos = ((Component)target.entity).transform.position + localPosition + ((Component)target.entity).transform.right * 0.2f;
			if (IsOutside(pos, ((Component)target.entity).transform))
			{
				Construction.lastPlacementError = ConstructionErrors.WantsInside;
				return default(Construction.Placement);
			}
		}
		if (rotationDegrees > 0 && (constructionSocket == null || !constructionSocket.restrictPlacementRotation))
		{
			Construction.Placement placement = new Construction.Placement(target);
			float num = float.MaxValue;
			float num2 = 0f;
			for (int i = 0; i < 360; i += rotationDegrees)
			{
				Quaternion val3 = Quaternion.Euler(0f, (float)(rotationOffset + i), 0f);
				Vector3 direction = ((Ray)(ref target.ray)).direction;
				Vector3 val4 = val3 * val2 * Vector3.up;
				float num3 = Vector3.Angle(direction, val4);
				if (num3 < num)
				{
					num = num3;
					num2 = i;
				}
			}
			for (int j = 0; j < 360; j += rotationDegrees)
			{
				Quaternion val5 = val2 * Quaternion.Inverse(rotation);
				Quaternion val6 = Quaternion.Euler(target.rotation);
				Quaternion val7 = Quaternion.Euler(0f, (float)(rotationOffset + j) + num2, 0f);
				Quaternion val8 = val6 * val7 * val5;
				Vector3 val9 = val8 * position;
				placement.position = val - val9;
				placement.rotation = val8;
				if (CheckSocketMods(ref placement))
				{
					return placement;
				}
			}
		}
		Construction.Placement result = new Construction.Placement(target);
		Quaternion val10 = val2 * Quaternion.Inverse(rotation);
		if (ShouldInheritFemaleSocketRotation(socketType))
		{
			Quaternion val11 = Quaternion.Euler(target.rotation);
			val10 *= val11;
		}
		Vector3 val12 = val10 * position;
		result.position = val - val12;
		result.rotation = val10;
		if (!TestRestrictedAngles(val, val2, target))
		{
			return default(Construction.Placement);
		}
		return result;
	}

	protected virtual bool CanConnectToEntity(Construction.Target target)
	{
		return true;
	}

	private bool ShouldInheritFemaleSocketRotation(Type type)
	{
		if (type != Type.WallFrame && type != Type.Doorway && type != Type.FloorFrameTriangle && type != Type.FloorFrame)
		{
			return type == Type.Shutters;
		}
		return true;
	}

	public bool IsOutside(Vector3 pos, Transform tr)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		float num = 5f;
		for (int i = 0; i < outsideLookupDirs.Length; i++)
		{
			Vector3 val = tr.TransformDirection(outsideLookupDirs[i]);
			Vector3 val2 = pos + val * num;
			if (!Physics.Raycast(new Ray(val2, -val), num - 0.5f, 2097152))
			{
				return true;
			}
		}
		return false;
	}

	static ConstructionSocket()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = new Vector3[4];
		Vector3 val = new Vector3(0f, 1f, 0f);
		array[0] = ((Vector3)(ref val)).normalized;
		val = new Vector3(1f, 0f, 0f);
		array[1] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, 1f);
		array[2] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, -1f);
		array[3] = ((Vector3)(ref val)).normalized;
		outsideLookupDirs = (Vector3[])(object)array;
	}
}


public enum Type
{
	None,
	Foundation,
	Floor,
	Misc,
	Doorway,
	Wall,
	Block,
	Ramp,
	StairsTriangle,
	Stairs,
	FloorFrameTriangle,
	Window,
	Shutters,
	WallFrame,
	FloorFrame,
	WindowDressing,
	DoorDressing,
	Elevator,
	DoubleDoorDressing
}


using UnityEngine;

public class ConstructionSocket_Elevator : ConstructionSocket
{
	public int MaxFloor = 5;

	protected override bool CanConnectToEntity(Construction.Target target)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (target.entity is Elevator elevator && elevator.Floor >= MaxFloor)
		{
			return false;
		}
		Vector3 val = target.GetWorldPosition();
		Quaternion val2 = target.GetWorldRotation(female: true);
		if (GamePhysics.CheckOBB(new OBB(val, new Vector3(2f, 0.5f, 2f), val2), 2097152, (QueryTriggerInteraction)0))
		{
			return false;
		}
		return base.CanConnectToEntity(target);
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		Matrix4x4 val = Matrix4x4.TRS(position, rotation, Vector3.one);
		Vector3 val2 = ((Matrix4x4)(ref val)).MultiplyPoint3x4(worldPosition);
		return !GamePhysics.CheckOBB(new OBB(val2, new Vector3(2f, 0.5f, 2f), rotation), 2097152, (QueryTriggerInteraction)0);
	}
}


public class Construction_SleepingBag : Construction
{
}


using System;
using UnityEngine;

public class DecayPoint : PrefabAttribute
{
	[Tooltip("If this point is occupied this will take this % off the power of the decay")]
	public float protection = 0.25f;

	public Socket_Base socket;

	public bool IsOccupied(BaseEntity entity)
	{
		return entity.IsOccupied(socket);
	}

	protected override Type GetIndexedType()
	{
		return typeof(DecayPoint);
	}
}


using System;
using UnityEngine;

public class DirectionProperties : PrefabAttribute
{
	private const float radius = 200f;

	public Bounds bounds = new Bounds(Vector3.zero, Vector3.zero);

	public ProtectionProperties extraProtection;

	protected override Type GetIndexedType()
	{
		return typeof(DirectionProperties);
	}

	public bool IsWeakspot(Transform tx, HitInfo info)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if (((Bounds)(ref bounds)).size == Vector3.zero)
		{
			return false;
		}
		BasePlayer initiatorPlayer = info.InitiatorPlayer;
		if ((Object)(object)initiatorPlayer == (Object)null)
		{
			return false;
		}
		BaseEntity hitEntity = info.HitEntity;
		if ((Object)(object)hitEntity == (Object)null)
		{
			return false;
		}
		Matrix4x4 worldToLocalMatrix = tx.worldToLocalMatrix;
		Vector3 val = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(info.PointStart) - worldPosition;
		float num = Vector3Ex.DotDegrees(worldForward, val);
		Vector3 val2 = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(info.HitPositionWorld);
		OBB val3 = default(OBB);
		((OBB)(ref val3))..ctor(worldPosition, worldRotation, bounds);
		Vector3 position = initiatorPlayer.eyes.position;
		WeakpointProperties[] array = PrefabAttribute.server.FindAll<WeakpointProperties>(hitEntity.prefabID);
		if (array != null && array.Length != 0)
		{
			bool flag = false;
			WeakpointProperties[] array2 = array;
			foreach (WeakpointProperties weakpointProperties in array2)
			{
				if ((!weakpointProperties.BlockWhenRoofAttached || CheckWeakpointRoof(hitEntity)) && IsWeakspotVisible(hitEntity, position, tx.TransformPoint(weakpointProperties.worldPosition)))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return false;
			}
		}
		else if (!IsWeakspotVisible(hitEntity, position, tx.TransformPoint(val3.position)))
		{
			return false;
		}
		if (num > 100f)
		{
			return ((OBB)(ref val3)).Contains(val2);
		}
		return false;
	}

	private bool CheckWeakpointRoof(BaseEntity hitEntity)
	{
		foreach (EntityLink entityLink in hitEntity.GetEntityLinks())
		{
			if (!(entityLink.socket is NeighbourSocket))
			{
				continue;
			}
			foreach (EntityLink connection in entityLink.connections)
			{
				if (connection.owner is BuildingBlock buildingBlock && (buildingBlock.ShortPrefabName == "roof" || buildingBlock.ShortPrefabName == "roof.triangle"))
				{
					return false;
				}
			}
		}
		return true;
	}

	private bool IsWeakspotVisible(BaseEntity hitEntity, Vector3 playerEyes, Vector3 weakspotPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		if (!hitEntity.IsVisible(playerEyes, weakspotPos))
		{
			return false;
		}
		return true;
	}
}


using System;

public abstract class ModelConditionTest : PrefabAttribute
{
	public abstract bool DoTest(BaseEntity ent);

	protected override Type GetIndexedType()
	{
		return typeof(ModelConditionTest);
	}
}


public class ModelConditionTest_False : ModelConditionTest
{
	public ConditionalModel reference;

	public override bool DoTest(BaseEntity ent)
	{
		return !reference.RunTests(ent);
	}
}


using UnityEngine;

public class ModelConditionTest_FoundationSide : ModelConditionTest
{
	private const string square_south = "foundation/sockets/foundation-top/1";

	private const string square_north = "foundation/sockets/foundation-top/3";

	private const string square_west = "foundation/sockets/foundation-top/2";

	private const string square_east = "foundation/sockets/foundation-top/4";

	private const string triangle_south = "foundation.triangle/sockets/foundation-top/1";

	private const string triangle_northwest = "foundation.triangle/sockets/foundation-top/2";

	private const string triangle_northeast = "foundation.triangle/sockets/foundation-top/3";

	private string socket = string.Empty;

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(1.5f, 1.5f, 0f), new Vector3(3f, 3f, 3f));
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = worldRotation * Vector3.right;
		if (name.Contains("foundation.triangle"))
		{
			if (val.z < -0.9f)
			{
				socket = "foundation.triangle/sockets/foundation-top/1";
			}
			if (val.x < -0.1f)
			{
				socket = "foundation.triangle/sockets/foundation-top/2";
			}
			if (val.x > 0.1f)
			{
				socket = "foundation.triangle/sockets/foundation-top/3";
			}
			return;
		}
		if (val.z < -0.9f)
		{
			socket = "foundation/sockets/foundation-top/1";
		}
		if (val.z > 0.9f)
		{
			socket = "foundation/sockets/foundation-top/3";
		}
		if (val.x < -0.9f)
		{
			socket = "foundation/sockets/foundation-top/2";
		}
		if (val.x > 0.9f)
		{
			socket = "foundation/sockets/foundation-top/4";
		}
	}

	public override bool DoTest(BaseEntity ent)
	{
		EntityLink entityLink = ent.FindLink(socket);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock == (Object)null) && !(buildingBlock.blockDefinition.info.name.token == "foundation_steps"))
			{
				if (buildingBlock.grade == BuildingGrade.Enum.TopTier)
				{
					return false;
				}
				if (buildingBlock.grade == BuildingGrade.Enum.Metal)
				{
					return false;
				}
				if (buildingBlock.grade == BuildingGrade.Enum.Stone)
				{
					return false;
				}
			}
		}
		return true;
	}
}


public class ModelConditionTest_Inside : ModelConditionTest
{
	public override bool DoTest(BaseEntity ent)
	{
		return !ModelConditionTest_Outside.CheckCondition(ent);
	}
}


public class ModelConditionTest_Outside : ModelConditionTest
{
	public override bool DoTest(BaseEntity ent)
	{
		return CheckCondition(ent);
	}

	public static bool CheckCondition(BaseEntity ent)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		OBB val = ent.WorldSpaceBounds();
		return ent.IsOutside(((OBB)(ref val)).GetPoint(0f, 1f, 0f));
	}
}


using UnityEngine;

public class ModelConditionTest_RampHigh : ModelConditionTest
{
	private const string socket = "ramp/sockets/block-male/1";

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, 0.75f, 0f), new Vector3(3f, 1.5f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		return ent.FindLink("ramp/sockets/block-male/1")?.IsEmpty() ?? false;
	}
}


using UnityEngine;

public class ModelConditionTest_RampLow : ModelConditionTest
{
	private const string socket = "ramp/sockets/block-male/1";

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, 0.375f, 0f), new Vector3(3f, 0.75f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		EntityLink entityLink = ent.FindLink("ramp/sockets/block-male/1");
		if (entityLink == null)
		{
			return false;
		}
		return !entityLink.IsEmpty();
	}
}


using UnityEngine;

public class ModelConditionTest_RoofBottom : ModelConditionTest
{
	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_bot_right = "sockets/neighbour/3";

	private const string socket_bot_left = "sockets/neighbour/4";

	private const string socket_top_right = "sockets/neighbour/5";

	private const string socket_top_left = "sockets/neighbour/6";

	private static string[] sockets_bot_right = new string[2] { "roof/sockets/neighbour/3", "roof.triangle/sockets/neighbour/3" };

	private static string[] sockets_bot_left = new string[2] { "roof/sockets/neighbour/4", "roof.triangle/sockets/neighbour/4" };

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, -1.5f, 3f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		bool flag = false;
		bool flag2 = false;
		EntityLink entityLink = ent.FindLink(sockets_bot_right);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			if (entityLink.connections[i].name.EndsWith("sockets/neighbour/5"))
			{
				flag = true;
				break;
			}
		}
		EntityLink entityLink2 = ent.FindLink(sockets_bot_left);
		if (entityLink2 == null)
		{
			return false;
		}
		for (int j = 0; j < entityLink2.connections.Count; j++)
		{
			if (entityLink2.connections[j].name.EndsWith("sockets/neighbour/6"))
			{
				flag2 = true;
				break;
			}
		}
		if (flag && flag2)
		{
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class ModelConditionTest_RoofLeft : ModelConditionTest
{
	public enum AngleType
	{
		None = -1,
		Straight = 0,
		Convex60 = 60,
		Convex90 = 90,
		Convex120 = 120,
		Concave30 = -30,
		Concave60 = -60,
		Concave90 = -90,
		Concave120 = -120
	}

	public enum ShapeType
	{
		Any = -1,
		Square,
		Triangle
	}

	public AngleType angle = AngleType.None;

	public ShapeType shape = ShapeType.Any;

	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_right = "sockets/neighbour/3";

	private const string socket_left = "sockets/neighbour/4";

	private static string[] sockets_left = new string[2] { "roof/sockets/neighbour/4", "roof.triangle/sockets/neighbour/4" };

	private bool IsConvex => angle > (AngleType)10;

	private bool IsConcave => angle < (AngleType)(-10);

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(3f, 1.5f, 0f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink(sockets_left);
		if (entityLink == null)
		{
			return false;
		}
		if (angle == AngleType.None)
		{
			for (int i = 0; i < entityLink.connections.Count; i++)
			{
				if (entityLink.connections[i].name.EndsWith("sockets/neighbour/3"))
				{
					return false;
				}
			}
			return true;
		}
		if (entityLink.IsEmpty())
		{
			return false;
		}
		bool result = false;
		for (int j = 0; j < entityLink.connections.Count; j++)
		{
			EntityLink entityLink2 = entityLink.connections[j];
			if (!entityLink2.name.EndsWith("sockets/neighbour/3") || (shape == ShapeType.Square && !entityLink2.name.StartsWith("roof/")) || (shape == ShapeType.Triangle && !entityLink2.name.StartsWith("roof.triangle/")))
			{
				continue;
			}
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null || buildingBlock2.grade != buildingBlock.grade)
			{
				continue;
			}
			int num = (int)angle;
			float num2 = Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (num2 < (float)(num - 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else if (num2 > (float)(num + 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else
			{
				result = true;
			}
		}
		return result;
	}
}


public enum AngleType
{
	None = -1,
	Straight = 0,
	Convex60 = 60,
	Convex90 = 90,
	Convex120 = 120,
	Concave30 = -30,
	Concave60 = -60,
	Concave90 = -90,
	Concave120 = -120
}


public enum ShapeType
{
	Any = -1,
	Square,
	Triangle
}


using UnityEngine;

public class ModelConditionTest_RoofRight : ModelConditionTest
{
	public enum AngleType
	{
		None = -1,
		Straight = 0,
		Convex60 = 60,
		Convex90 = 90,
		Convex120 = 120,
		Concave30 = -30,
		Concave60 = -60,
		Concave90 = -90,
		Concave120 = -120
	}

	public enum ShapeType
	{
		Any = -1,
		Square,
		Triangle
	}

	public AngleType angle = AngleType.None;

	public ShapeType shape = ShapeType.Any;

	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_right = "sockets/neighbour/3";

	private const string socket_left = "sockets/neighbour/4";

	private static string[] sockets_right = new string[2] { "roof/sockets/neighbour/3", "roof.triangle/sockets/neighbour/3" };

	private bool IsConvex => angle > (AngleType)10;

	private bool IsConcave => angle < (AngleType)(-10);

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(-3f, 1.5f, 0f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink(sockets_right);
		if (entityLink == null)
		{
			return false;
		}
		if (angle == AngleType.None)
		{
			for (int i = 0; i < entityLink.connections.Count; i++)
			{
				if (entityLink.connections[i].name.EndsWith("sockets/neighbour/4"))
				{
					return false;
				}
			}
			return true;
		}
		if (entityLink.IsEmpty())
		{
			return false;
		}
		bool result = false;
		for (int j = 0; j < entityLink.connections.Count; j++)
		{
			EntityLink entityLink2 = entityLink.connections[j];
			if (!entityLink2.name.EndsWith("sockets/neighbour/4") || (shape == ShapeType.Square && !entityLink2.name.StartsWith("roof/")) || (shape == ShapeType.Triangle && !entityLink2.name.StartsWith("roof.triangle/")))
			{
				continue;
			}
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null || buildingBlock2.grade != buildingBlock.grade)
			{
				continue;
			}
			int num = (int)angle;
			float num2 = 0f - Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (num2 < (float)(num - 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else if (num2 > (float)(num + 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else
			{
				result = true;
			}
		}
		return result;
	}
}


public enum AngleType
{
	None = -1,
	Straight = 0,
	Convex60 = 60,
	Convex90 = 90,
	Convex120 = 120,
	Concave30 = -30,
	Concave60 = -60,
	Concave90 = -90,
	Concave120 = -120
}


public enum ShapeType
{
	Any = -1,
	Square,
	Triangle
}


using UnityEngine;

public class ModelConditionTest_RoofTop : ModelConditionTest
{
	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_bot_right = "sockets/neighbour/3";

	private const string socket_bot_left = "sockets/neighbour/4";

	private const string socket_top_right = "sockets/neighbour/5";

	private const string socket_top_left = "sockets/neighbour/6";

	private static string[] sockets_top_right = new string[2] { "roof/sockets/neighbour/5", "roof.triangle/sockets/neighbour/5" };

	private static string[] sockets_top_left = new string[2] { "roof/sockets/neighbour/6", "roof.triangle/sockets/neighbour/6" };

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, -1.5f, 3f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		bool flag = false;
		bool flag2 = false;
		EntityLink entityLink = ent.FindLink(sockets_top_right);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			if (entityLink.connections[i].name.EndsWith("sockets/neighbour/3"))
			{
				flag = true;
				break;
			}
		}
		EntityLink entityLink2 = ent.FindLink(sockets_top_left);
		if (entityLink2 == null)
		{
			return false;
		}
		for (int j = 0; j < entityLink2.connections.Count; j++)
		{
			if (entityLink2.connections[j].name.EndsWith("sockets/neighbour/4"))
			{
				flag2 = true;
				break;
			}
		}
		if (flag && flag2)
		{
			return false;
		}
		return true;
	}
}


public class ModelConditionTest_RoofTriangle : ModelConditionTest
{
	private const string socket = "roof/sockets/wall-female";

	public override bool DoTest(BaseEntity ent)
	{
		EntityLink entityLink = ent.FindLink("roof/sockets/wall-female");
		if (entityLink == null)
		{
			return true;
		}
		if (!entityLink.IsEmpty())
		{
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class ModelConditionTest_SpiralStairs : ModelConditionTest
{
	private const string stairs_socket_female = "sockets/stairs-female/1";

	private static string[] stairs_sockets_female = new string[2] { "block.stair.spiral/sockets/stairs-female/1", "block.stair.spiral.triangle/sockets/stairs-female/1" };

	private const string floor_socket_female = "sockets/floor-female/1";

	private static string[] floor_sockets_female = new string[2] { "block.stair.spiral/sockets/floor-female/1", "block.stair.spiral.triangle/sockets/floor-female/1" };

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, 2.35f, 0f), new Vector3(3f, 1.5f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink(stairs_sockets_female);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock2 = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock2 == (Object)null) && buildingBlock2.grade == buildingBlock.grade)
			{
				return false;
			}
		}
		EntityLink entityLink2 = ent.FindLink(floor_sockets_female);
		if (entityLink2 == null)
		{
			return true;
		}
		if (!entityLink2.IsEmpty())
		{
			return false;
		}
		return true;
	}
}


public class ModelConditionTest_True : ModelConditionTest
{
	public ConditionalModel reference;

	public override bool DoTest(BaseEntity ent)
	{
		return reference.RunTests(ent);
	}
}


public class ModelConditionTest_Variant : ModelConditionTest
{
	public ulong VariantSeed;

	public ulong VariantIndex;

	public ulong VariantCount = 3uL;

	public override bool DoTest(BaseEntity ent)
	{
		ulong num = ent.net.ID.Value + VariantSeed;
		SeedRandom.Wanghash(ref num);
		SeedRandom.Wanghash(ref num);
		SeedRandom.Wanghash(ref num);
		return num % VariantCount == VariantIndex;
	}
}


public class ModelConditionTest_Wall : ModelConditionTest
{
	public override bool DoTest(BaseEntity ent)
	{
		if (!ModelConditionTest_WallTriangleLeft.CheckCondition(ent))
		{
			return !ModelConditionTest_WallTriangleRight.CheckCondition(ent);
		}
		return false;
	}
}


using UnityEngine;

public class ModelConditionTest_WallCornerLeft : ModelConditionTest
{
	private const string socket = "sockets/stability/2";

	private static string[] sockets = new string[5] { "wall/sockets/stability/2", "wall.half/sockets/stability/2", "wall.low/sockets/stability/2", "wall.doorway/sockets/stability/2", "wall.window/sockets/stability/2" };

	public override bool DoTest(BaseEntity ent)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		EntityLink entityLink = ent.FindLink(sockets);
		if (entityLink == null)
		{
			return false;
		}
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		bool result = false;
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			EntityLink entityLink2 = entityLink.connections[i];
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null)
			{
				continue;
			}
			float num = Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (entityLink2.name.EndsWith("sockets/stability/2"))
			{
				if (num > -10f || num < -100f)
				{
					return false;
				}
				continue;
			}
			if (num < 10f && num > -10f)
			{
				return false;
			}
			if (num < -10f)
			{
				return false;
			}
			if (buildingBlock2.grade == buildingBlock.grade)
			{
				result = true;
			}
		}
		return result;
	}
}


using UnityEngine;

public class ModelConditionTest_WallCornerRight : ModelConditionTest
{
	private const string socket = "sockets/stability/1";

	private static string[] sockets = new string[5] { "wall/sockets/stability/1", "wall.half/sockets/stability/1", "wall.low/sockets/stability/1", "wall.doorway/sockets/stability/1", "wall.window/sockets/stability/1" };

	public override bool DoTest(BaseEntity ent)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		EntityLink entityLink = ent.FindLink(sockets);
		if (entityLink == null)
		{
			return false;
		}
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		bool result = false;
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			EntityLink entityLink2 = entityLink.connections[i];
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null)
			{
				continue;
			}
			float num = Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (entityLink2.name.EndsWith("sockets/stability/1"))
			{
				if (num < 10f || num > 100f)
				{
					return false;
				}
				continue;
			}
			if (num < 10f && num > -10f)
			{
				return false;
			}
			if (num > 10f)
			{
				return false;
			}
			if (buildingBlock2.grade == buildingBlock.grade)
			{
				result = true;
			}
		}
		return result;
	}
}


using UnityEngine;

public class ModelConditionTest_Wallpaper : ModelConditionTest
{
	public bool wantsWallpaper = true;

	public bool softSide;

	public override bool DoTest(BaseEntity ent)
	{
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		bool flag = buildingBlock.HasWallpaper((!softSide) ? 1 : 0);
		if (!wantsWallpaper)
		{
			return !flag;
		}
		return flag;
	}
}


using UnityEngine;

public class ModelConditionTest_WallTriangleLeft : ModelConditionTest
{
	private const string socket_1 = "wall/sockets/wall-female";

	private const string socket_2 = "wall/sockets/floor-female/1";

	private const string socket_3 = "wall/sockets/floor-female/2";

	private const string socket_4 = "wall/sockets/floor-female/3";

	private const string socket_5 = "wall/sockets/floor-female/4";

	private const string socket_6 = "wall/sockets/stability/1";

	private const string socket = "wall/sockets/neighbour/1";

	public static bool CheckCondition(BaseEntity ent)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		if (CheckSocketOccupied(ent, "wall/sockets/wall-female"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/1"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/2"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/3"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/4"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/stability/1"))
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink("wall/sockets/neighbour/1");
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock == (Object)null))
			{
				if (buildingBlock.blockDefinition.info.name.token == "roof" && Vector3.Angle(((Component)ent).transform.forward, ((Component)buildingBlock).transform.forward) < 10f)
				{
					return true;
				}
				if (buildingBlock.blockDefinition.info.name.token == "roof_triangle" && Vector3.Angle(((Component)ent).transform.forward, ((Component)buildingBlock).transform.forward) < 40f)
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool CheckSocketOccupied(BaseEntity ent, string socket)
	{
		EntityLink entityLink = ent.FindLink(socket);
		if (entityLink == null)
		{
			return false;
		}
		return !entityLink.IsEmpty();
	}

	public override bool DoTest(BaseEntity ent)
	{
		return CheckCondition(ent);
	}
}


using UnityEngine;

public class ModelConditionTest_WallTriangleRight : ModelConditionTest
{
	private const string socket_1 = "wall/sockets/wall-female";

	private const string socket_2 = "wall/sockets/floor-female/1";

	private const string socket_3 = "wall/sockets/floor-female/2";

	private const string socket_4 = "wall/sockets/floor-female/3";

	private const string socket_5 = "wall/sockets/floor-female/4";

	private const string socket_6 = "wall/sockets/stability/2";

	private const string socket = "wall/sockets/neighbour/1";

	public static bool CheckCondition(BaseEntity ent)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		if (CheckSocketOccupied(ent, "wall/sockets/wall-female"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/1"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/2"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/3"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/4"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/stability/2"))
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink("wall/sockets/neighbour/1");
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock == (Object)null))
			{
				if (buildingBlock.blockDefinition.info.name.token == "roof" && Vector3.Angle(((Component)ent).transform.forward, -((Component)buildingBlock).transform.forward) < 10f)
				{
					return true;
				}
				if (buildingBlock.blockDefinition.info.name.token == "roof_triangle" && Vector3.Angle(((Component)ent).transform.forward, -((Component)buildingBlock).transform.forward) < 40f)
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool CheckSocketOccupied(BaseEntity ent, string socket)
	{
		EntityLink entityLink = ent.FindLink(socket);
		if (entityLink == null)
		{
			return false;
		}
		return !entityLink.IsEmpty();
	}

	public override bool DoTest(BaseEntity ent)
	{
		return CheckCondition(ent);
	}
}


using UnityEngine;

public class NeighbourSocket : Socket_Base
{
	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.DrawWireCube(selectCenter, selectSize);
	}

	public override bool TestTarget(Construction.Target target)
	{
		return false;
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		OBB selectBounds = GetSelectBounds(position, rotation);
		OBB selectBounds2 = socket.GetSelectBounds(socketPosition, socketRotation);
		return ((OBB)(ref selectBounds)).Intersects(selectBounds2);
	}
}


using System;
using UnityEngine;

public class SocketHandle : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(SocketHandle);
	}

	internal void AdjustTarget(ref Construction.Target target, float maxplaceDistance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = worldPosition;
		Vector3 val2 = ((Ray)(ref target.ray)).origin + ((Ray)(ref target.ray)).direction * maxplaceDistance - val;
		ref Ray ray = ref target.ray;
		Vector3 val3 = val2 - ((Ray)(ref target.ray)).origin;
		((Ray)(ref ray)).direction = ((Vector3)(ref val3)).normalized;
	}
}


using System;
using UnityEngine;

public abstract class SocketMod : PrefabAttribute
{
	[NonSerialized]
	public Socket_Base baseSocket;

	public Phrase FailedPhrase;

	public SocketMod_Grouping SocketGrouping { get; private set; }

	protected virtual Phrase ErrorPhrase => Phrase.op_Implicit(string.Empty);

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		Transform parent = ((Component)this).transform.parent;
		SocketGrouping = ((parent != null) ? ((Component)parent).GetComponent<SocketMod_Grouping>() : null);
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
	}

	public virtual Phrase GetTranslatedErrorMessage()
	{
		if (!string.IsNullOrEmpty(FailedPhrase.token))
		{
			return FailedPhrase;
		}
		return ErrorPhrase;
	}

	public virtual string GetDebugErrorMessage()
	{
		return hierachyName ?? "";
	}

	public virtual bool DoCheck(Construction.Placement place)
	{
		return false;
	}

	public virtual void ModifyPlacement(ref Construction.Placement place)
	{
	}

	protected override Type GetIndexedType()
	{
		return typeof(SocketMod);
	}
}


using UnityEngine;

public class SocketMod_AngleCheck : SocketMod
{
	public bool wantsAngle = true;

	public Vector3 worldNormal = Vector3.up;

	public float withinDegrees = 45f;

	public bool usePlacementNormal;

	protected override Phrase ErrorPhrase => ConstructionErrors.InvalidAngle;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = (usePlacementNormal ? Vector3.forward : Vector3.up);
		float num = Vector3Ex.DotDegrees(worldNormal, place.rotation * val);
		if (!usePlacementNormal)
		{
			return num < withinDegrees;
		}
		return num >= withinDegrees;
	}
}


using UnityEngine;

public class SocketMod_AreaCheck : SocketMod
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 0.1f);

	public LayerMask layerMask;

	public bool wantsInside = true;

	private Phrase lastError = new Phrase("", "");

	protected override Phrase ErrorPhrase => lastError;

	public static bool IsInArea(Vector3 position, Quaternion rotation, Bounds bounds, LayerMask layerMask, BaseEntity entity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckOBBAndEntity(new OBB(position, rotation, bounds), ((LayerMask)(ref layerMask)).value, (QueryTriggerInteraction)0, entity);
	}

	public bool DoCheck(Vector3 position, Quaternion rotation, BaseEntity entity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position2 = position + rotation * worldPosition;
		Quaternion rotation2 = rotation * worldRotation;
		return IsInArea(position2, rotation2, bounds, layerMask, entity) == wantsInside;
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		bool flag = DoCheck(place.position, place.rotation);
		if (!flag)
		{
			lastError = ConstructionErrors.NotStableEnough;
			if (LayerMask.op_Implicit(layerMask) == 2097152 || LayerMask.op_Implicit(layerMask) == 136314880)
			{
				lastError = (wantsInside ? ConstructionErrors.MustPlaceOnConstruction : ConstructionErrors.CantPlaceOnConstruction);
			}
		}
		else if (wantsInside && (LayerMask.op_Implicit(layerMask) & 0x8000000) == 0)
		{
			flag = !GamePhysics.CheckSphere(place.position, 5f, 134217728, (QueryTriggerInteraction)0);
			if (!flag)
			{
				lastError = ConstructionErrors.InvalidAreaVehicleLarge;
			}
		}
		if (flag)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_Attraction : SocketMod
{
	public float outerRadius = 1f;

	public float innerRadius = 0.1f;

	public string groupName = "wallbottom";

	public bool lockRotation;

	public bool bypassPlayerRotation;

	public bool ignoreRotationForRadiusCheck;

	public bool shiftDisableSnap = true;

	public bool shiftEnableSnap;

	public bool applyPostRotationSnapping;

	private static float[] PostSnapRotations = new float[4] { 0f, 90f, 180f, 270f };

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
		Gizmos.DrawSphere(Vector3.zero, outerRadius);
		Gizmos.color = new Color(0f, 1f, 0f, 0.6f);
		Gizmos.DrawSphere(Vector3.zero, innerRadius);
	}

	public override bool DoCheck(Construction.Placement place)
	{
		return true;
	}

	public override void ModifyPlacement(ref Construction.Placement place)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		if ((shiftEnableSnap && !place.isHoldingShift) || (shiftDisableSnap && place.isHoldingShift))
		{
			return;
		}
		Vector3 val = place.position + place.rotation * worldPosition;
		Quaternion rotation = place.rotation;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(val, outerRadius * 2f, list, -1, (QueryTriggerInteraction)2);
		Vector3 position = Vector3.zero;
		float num = float.MaxValue;
		Vector3 position2 = place.position;
		Quaternion rotation2 = Quaternion.identity;
		foreach (BaseEntity item in list)
		{
			if (item.isServer != isServer)
			{
				continue;
			}
			AttractionPoint[] array = prefabAttribute.FindAll<AttractionPoint>(item.prefabID);
			if (array == null)
			{
				continue;
			}
			AttractionPoint[] array2 = array;
			foreach (AttractionPoint attractionPoint in array2)
			{
				if (attractionPoint.groupName != groupName)
				{
					continue;
				}
				Vector3 val2 = ((Component)item).transform.position + ((Component)item).transform.rotation * attractionPoint.worldPosition;
				Vector3 val3 = val2 - val;
				float magnitude = ((Vector3)(ref val3)).magnitude;
				if (ignoreRotationForRadiusCheck)
				{
					Vector3 val4 = ((Component)item).transform.TransformPoint(Vector3.LerpUnclamped(Vector3.zero, Vector3Ex.WithY(attractionPoint.worldPosition, 0f), 2f));
					float num2 = Vector3.Distance(val4, position2);
					if (num2 < num)
					{
						num = num2;
						position = val4;
						rotation2 = ((Component)item).transform.rotation;
					}
				}
				if (magnitude > outerRadius)
				{
					continue;
				}
				Quaternion val5 = ((lockRotation && bypassPlayerRotation) ? (((Component)item).transform.rotation * attractionPoint.localRotation) : QuaternionEx.LookRotationWithOffset(worldPosition, val2 - place.position, Vector3.up));
				float num3 = Mathf.InverseLerp(outerRadius, innerRadius, magnitude);
				if (lockRotation)
				{
					num3 = 1f;
				}
				if (lockRotation)
				{
					if (bypassPlayerRotation)
					{
						place.rotation = ((Component)item).transform.rotation * attractionPoint.localRotation;
					}
					else
					{
						Vector3 eulerAngles = ((Quaternion)(ref place.rotation)).eulerAngles;
						eulerAngles -= new Vector3(eulerAngles.x % 90f, eulerAngles.y % 90f, eulerAngles.z % 90f);
						place.rotation = Quaternion.Euler(eulerAngles + ((Component)item).transform.eulerAngles);
					}
				}
				else
				{
					place.rotation = Quaternion.Lerp(place.rotation, val5, num3);
				}
				val = place.position + place.rotation * worldPosition;
				val3 = val2 - val;
				place.position += val3 * num3;
			}
		}
		if (num < float.MaxValue && ignoreRotationForRadiusCheck)
		{
			place.position = position;
			place.rotation = rotation2;
		}
		if (applyPostRotationSnapping)
		{
			Quaternion rotation3 = place.rotation;
			float num4 = float.MaxValue;
			float[] postSnapRotations = PostSnapRotations;
			foreach (float num5 in postSnapRotations)
			{
				Quaternion val6 = place.rotation * Quaternion.Euler(0f, num5, 0f);
				float num6 = Quaternion.Angle(val6, rotation);
				if (num6 < num4)
				{
					num4 = num6;
					rotation3 = val6;
				}
			}
			if (num4 < float.MaxValue)
			{
				place.rotation = rotation3;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_BuildingBlock : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public bool wantsCollide;

	protected override Phrase ErrorPhrase => ConstructionErrors.MustPlaceOnConstruction;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		bool flag = list.Count > 0;
		if (flag && wantsCollide)
		{
			Pool.FreeUnmanaged<BuildingBlock>(ref list);
			return true;
		}
		if (flag && !wantsCollide)
		{
			Pool.FreeUnmanaged<BuildingBlock>(ref list);
			return false;
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
		return !wantsCollide;
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public class SocketMod_EntityCheck : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public BaseEntity[] entityTypes;

	public bool wantsCollide;

	protected override Phrase ErrorPhrase => ConstructionErrors.InvalidEntity;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		bool result = !wantsCollide;
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		foreach (BaseEntity ent in list)
		{
			bool flag = entityTypes.Any((BaseEntity x) => x.prefabID == ent.prefabID);
			if (flag && wantsCollide)
			{
				result = true;
				break;
			}
			if (flag && !wantsCollide)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_EntityType : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public BaseEntity searchType;

	public bool wantsCollide;

	protected override Phrase ErrorPhrase => ConstructionErrors.InvalidEntityType;

	public override string GetDebugErrorMessage()
	{
		return base.GetDebugErrorMessage() + $" {searchType}";
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		bool result = !wantsCollide;
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		foreach (BaseEntity item in list)
		{
			bool flag = ((object)item).GetType().IsAssignableFrom(((object)searchType).GetType());
			if (flag && wantsCollide)
			{
				result = true;
				break;
			}
			if (flag && !wantsCollide)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


public class SocketMod_EnvironmentVolume : SocketMod
{
	[InspectorFlags]
	public EnvironmentType environmentNone;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		EnvironmentType environmentType = EnvironmentManager.Get(place.position + place.rotation * worldPosition);
		if (environmentNone != 0 && (environmentType & environmentNone) != 0)
		{
			EnvironmentType blockedTypes = environmentType & environmentNone;
			Construction.lastPlacementError = Phrase.op_Implicit(GetErrorMessage(blockedTypes));
			return false;
		}
		return true;
	}

	private string GetErrorMessage(EnvironmentType blockedTypes)
	{
		string text = "Can't be placed ";
		if (blockedTypes.HasFlag(EnvironmentType.TrainTunnels))
		{
			return text + "In Train Tunnels";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Underground))
		{
			return text + "Underground";
		}
		if (blockedTypes.HasFlag(EnvironmentType.NoSunlight))
		{
			return text + "In The Dark";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Submarine))
		{
			return text + "In A Submarine";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Outdoor))
		{
			return text + "Outdoors";
		}
		if (blockedTypes.HasFlag(EnvironmentType.PlayerConstruction))
		{
			return text + "Near Player Construction";
		}
		if (blockedTypes.HasFlag(EnvironmentType.UnderwaterLab))
		{
			return text + "In Underwater Labs";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Elevator))
		{
			return text + "Near Elevators";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Building) || blockedTypes.HasFlag(EnvironmentType.BuildingDark) || blockedTypes.HasFlag(EnvironmentType.BuildingVeryDark))
		{
			return text + "In A Building";
		}
		return text + "(Unknown Environment)";
	}
}


using System.Collections.Generic;
using UnityEngine;

public class SocketMod_Grouping : SocketMod
{
	private List<SocketMod> SocketMods;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		SocketMods = new List<SocketMod>();
		foreach (Transform child in ((Component)this).transform.GetChildren())
		{
			SocketMods.AddRange(((Component)child).GetComponents<SocketMod>());
		}
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
	}

	public override bool DoCheck(Construction.Placement place)
	{
		if (SocketMods == null || SocketMods.Count == 0)
		{
			return true;
		}
		foreach (SocketMod socketMod in SocketMods)
		{
			if (socketMod.DoCheck(place))
			{
				return true;
			}
		}
		return false;
	}
}


using UnityEngine;

public class SocketMod_HotSpot : SocketMod
{
	public float spotSize = 0.1f;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = new Color(1f, 1f, 0f, 0.5f);
		Gizmos.DrawSphere(Vector3.zero, spotSize);
	}

	public override void ModifyPlacement(ref Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		place.position = position;
	}
}


using System;
using Rust;
using UnityEngine;

public class SocketMod_Inside : SocketMod
{
	public bool wantsInside = true;

	public bool customDirections;

	public Vector3[] customRayDirections;

	private static readonly Vector3[] outsideLookupDirs;

	protected override Phrase ErrorPhrase
	{
		get
		{
			if (!wantsInside)
			{
				return ConstructionErrors.WantsOutside;
			}
			return ConstructionErrors.WantsInside;
		}
	}

	private Vector3[] directions
	{
		get
		{
			if (!customDirections)
			{
				return outsideLookupDirs;
			}
			return customRayDirections;
		}
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = place.position + place.rotation * baseSocket.localPosition;
		Quaternion val2 = place.rotation * baseSocket.localRotation;
		Vector3 pos = val + val2 * localPosition;
		Quaternion rotation = val2 * localRotation;
		bool flag = IsOutside(pos, rotation, directions);
		return !wantsInside == flag;
	}

	public static bool IsOutside(Vector3 pos, Transform tr, int layerMask = 2162688)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return IsOutside(pos, tr.rotation, outsideLookupDirs, layerMask);
	}

	public static bool IsOutside(Vector3 pos, Transform tr, Vector3[] dirs, int layerMask = 2162688)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return IsOutside(pos, tr.rotation, dirs, layerMask);
	}

	public static bool IsOutside(Vector3 pos, Quaternion rotation, Vector3[] dirs, int layerMask = 2162688)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SocketMod_Inside.IsOutside", 0);
		try
		{
			float num = 20f;
			int num2 = 0;
			bool flag = true;
			RaycastHit val3 = default(RaycastHit);
			for (int i = 0; i < dirs.Length; i++)
			{
				Vector3 val2 = rotation * dirs[i];
				if (Physics.Raycast(new Ray(pos, val2), ref val3, num - 0.5f, layerMask))
				{
					if (((Component)((RaycastHit)(ref val3)).collider).gameObject.IsOnLayer((Layer)21))
					{
						num2++;
					}
				}
				else
				{
					flag = false;
				}
			}
			if (flag)
			{
				return num2 < 2;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	static SocketMod_Inside()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = new Vector3[8];
		Vector3 val = new Vector3(1f, 1f, 0f);
		array[0] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, -1f, 0f);
		array[1] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 1f, 1f);
		array[2] = ((Vector3)(ref val)).normalized;
		val = new Vector3(-1f, 1f, 0f);
		array[3] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, 1f);
		array[4] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 1f, 0f);
		array[5] = ((Vector3)(ref val)).normalized;
		val = new Vector3(1f, 0f, 0.5f);
		array[6] = ((Vector3)(ref val)).normalized;
		val = new Vector3(-1f, 0f, 0.5f);
		array[7] = ((Vector3)(ref val)).normalized;
		outsideLookupDirs = (Vector3[])(object)array;
	}
}


using UnityEngine;

public class SocketMod_InWater : SocketMod
{
	public bool wantsInWater = true;

	public bool excludeArtificialWater;

	protected override Phrase ErrorPhrase
	{
		get
		{
			if (!wantsInWater)
			{
				return ConstructionErrors.InWater;
			}
			if (!excludeArtificialWater)
			{
				return ConstructionErrors.WantsWater;
			}
			return ConstructionErrors.WantsWaterBody;
		}
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(place.position + place.rotation * worldPosition - new Vector3(0f, 0.1f, 0f), waves: true, volumes: true);
		bool isValid = waterInfo.isValid;
		bool artificalWater = waterInfo.artificalWater;
		if (isValid == wantsInWater)
		{
			if (artificalWater)
			{
				return !excludeArtificialWater;
			}
			return true;
		}
		return false;
	}
}


using UnityEngine;

public class SocketMod_PhysicMaterial : SocketMod
{
	public PhysicMaterial[] ValidMaterials;

	private PhysicMaterial foundMaterial;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position;
		Vector3 eulerAngles = ((Quaternion)(ref place.rotation)).eulerAngles;
		Vector3 val = position + ((Vector3)(ref eulerAngles)).normalized * 0.5f;
		eulerAngles = ((Quaternion)(ref place.rotation)).eulerAngles;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val, -((Vector3)(ref eulerAngles)).normalized, ref val2, 1f, 161546240, (QueryTriggerInteraction)1))
		{
			foundMaterial = ((RaycastHit)(ref val2)).collider.GetMaterialAt(((RaycastHit)(ref val2)).point);
			PhysicMaterial[] validMaterials = ValidMaterials;
			for (int i = 0; i < validMaterials.Length; i++)
			{
				if ((Object)(object)validMaterials[i] == (Object)(object)foundMaterial)
				{
					return true;
				}
			}
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_PlantCheck : SocketMod
{
	public bool CanBePotted = true;

	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public bool wantsCollide;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if (!CanBePotted && (Object)(object)place.transform != (Object)null)
		{
			PlanterBox planterBox = place.transform.ToBaseEntity() as PlanterBox;
			if ((Object)(object)planterBox != (Object)null && planterBox.PlantPot)
			{
				return false;
			}
		}
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		bool result = !wantsCollide;
		foreach (BaseEntity item in list)
		{
			GrowableEntity component = ((Component)item).GetComponent<GrowableEntity>();
			if (Object.op_Implicit((Object)(object)component) && wantsCollide)
			{
				result = true;
				break;
			}
			if (Object.op_Implicit((Object)(object)component) && !wantsCollide)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_RoadCheck : SocketMod
{
	public float sphereRadius = 1f;

	public bool wantsCollide;

	public LayerMask layerMask = LayerMask.op_Implicit(65536);

	protected override Phrase ErrorPhrase
	{
		get
		{
			if (!wantsCollide)
			{
				return ConstructionErrors.CantPlaceOnRoad;
			}
			return ConstructionErrors.MustPlaceOnRoad;
		}
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, (QueryTriggerInteraction)2);
		bool flag = false;
		for (int i = 0; i < list.Count; i++)
		{
			Collider val = list[i];
			if ((Object)(object)val != (Object)null && ((Component)val).gameObject.HasCustomTag(GameObjectTag.Road))
			{
				flag = true;
				break;
			}
		}
		bool num = wantsCollide == flag;
		Pool.FreeUnmanaged<Collider>(ref list);
		if (num)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_SphereCheck : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public bool wantsCollide;

	public bool requireMonument;

	[Space]
	public BaseEntity[] entityWhitelist;

	private Phrase lastError = new Phrase("", "");

	protected override Phrase ErrorPhrase => lastError;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, (QueryTriggerInteraction)2);
		if (requireMonument)
		{
			for (int i = 0; i < list.Count; i++)
			{
				Collider val = list[i];
				if (!((Component)val).gameObject.HasCustomTag(GameObjectTag.BlockBarricadePlacement) && ((Object)(object)val.GetMonument() == (Object)null || ((Component)val).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement)))
				{
					list.RemoveAt(i);
					i--;
				}
			}
		}
		bool flag = wantsCollide == list.Count > 0;
		if (entityWhitelist.Length != 0)
		{
			foreach (Collider item in list)
			{
				BaseEntity baseEntity = item.ToBaseEntity();
				if ((Object)(object)baseEntity != (Object)null)
				{
					flag = DeployVolume.CheckEntityList(baseEntity, entityWhitelist, trueIfAnyFound: true);
				}
			}
		}
		if (!flag)
		{
			lastError = ConstructionErrors.NotStableEnough;
			if (LayerMask.op_Implicit(layerMask) == 2097152 || LayerMask.op_Implicit(layerMask) == 136314880)
			{
				lastError = (wantsCollide ? ConstructionErrors.MustPlaceOnConstruction : ConstructionErrors.CantPlaceOnConstruction);
			}
			else if (!wantsCollide && requireMonument)
			{
				lastError = ConstructionErrors.CantPlaceOnMonument;
			}
			else if (!wantsCollide && list.Count > 0)
			{
				using List<Collider>.Enumerator enumerator = list.GetEnumerator();
				while (enumerator.MoveNext())
				{
					string blockedByErrorFromCollider = ConstructionErrors.GetBlockedByErrorFromCollider(DeployVolume.LastDeployHit = enumerator.Current);
					if (!string.IsNullOrEmpty(blockedByErrorFromCollider))
					{
						Construction.lastPlacementErrorIsDetailed = true;
						lastError = Phrase.op_Implicit(blockedByErrorFromCollider);
						break;
					}
				}
			}
		}
		else if (wantsCollide && (LayerMask.op_Implicit(layerMask) & 0x8000000) == 0)
		{
			flag = !GamePhysics.CheckSphere(place.position, 5f, 134217728, (QueryTriggerInteraction)0);
			if (!flag)
			{
				lastError = ConstructionErrors.InvalidAreaVehicleLarge;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		if (flag)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_TerrainCheck : SocketMod
{
	public bool wantsInTerrain = true;

	public bool preventWorldLayerInMonuments;

	private static Phrase lastError = new Phrase("", "");

	protected override Phrase ErrorPhrase => lastError;

	public static bool IsInTerrain(Vector3 vPoint, bool worldLayerInMonuments)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.OutOfBounds(vPoint))
		{
			if (TerrainMeta.IsPointWithinTutorialBounds(vPoint))
			{
				return Physics.Raycast(new Ray(vPoint + Vector3.up * 3f, Vector3.down), 3f, 65536);
			}
			return false;
		}
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAllUnordered(new Ray(vPoint + Vector3.up * 3f, Vector3.down), 0f, list, 3f, 65536, (QueryTriggerInteraction)0);
		using (List<RaycastHit>.Enumerator enumerator = list.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				RaycastHit current = enumerator.Current;
				if (worldLayerInMonuments)
				{
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return true;
				}
				if (((Component)((RaycastHit)(ref current)).collider).gameObject.HasCustomTag(GameObjectTag.BlockBarricadePlacement))
				{
					lastError = ConstructionErrors.CantPlaceOnMonument;
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return false;
				}
				if (((Component)((RaycastHit)(ref current)).collider).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement))
				{
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return true;
				}
				MonumentInfo monument = ((RaycastHit)(ref current)).collider.GetMonument();
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				if ((Object)(object)monument == (Object)null)
				{
					return true;
				}
				lastError = ConstructionErrors.CantPlaceOnMonument;
				return false;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		if (!Object.op_Implicit((Object)(object)TerrainMeta.Collision) || !TerrainMeta.Collision.GetIgnore(vPoint))
		{
			Terrain[] activeTerrains = Terrain.activeTerrains;
			foreach (Terrain val in activeTerrains)
			{
				if (val.SampleHeight(vPoint) + ((Component)val).transform.position.y > vPoint.y)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vPoint = place.position + place.rotation * worldPosition;
		lastError = null;
		if (IsInTerrain(vPoint, !preventWorldLayerInMonuments) == wantsInTerrain)
		{
			return true;
		}
		if (lastError == null)
		{
			lastError = ConstructionErrors.NotInTerrain;
		}
		return false;
	}
}


using UnityEngine;

public class SocketMod_WaterDepth : SocketMod
{
	public float MinimumWaterDepth = 2f;

	public float MaximumWaterDepth = 4f;

	public bool BlockArtificialWaterVolumes;

	private Phrase lastError = new Phrase("", "");

	private float lastDepth;

	protected override Phrase ErrorPhrase => lastError;

	public override string GetDebugErrorMessage()
	{
		return base.GetDebugErrorMessage() + $" {lastDepth}m";
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = place.position + place.rotation * worldPosition;
		pos.y -= 0.2f;
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(pos, waves: false, volumes: true);
		if (BlockArtificialWaterVolumes && waterInfo.artificalWater)
		{
			return false;
		}
		if (waterInfo.overallDepth > MinimumWaterDepth && waterInfo.overallDepth < MaximumWaterDepth)
		{
			return true;
		}
		lastError = ((waterInfo.overallDepth <= MinimumWaterDepth) ? ConstructionErrors.TooShallow : ConstructionErrors.TooDeep);
		return false;
	}
}


using System;
using UnityEngine;

public class Socket_Base : PrefabAttribute
{
	[Serializable]
	public class OccupiedSocketCheck
	{
		public Socket_Base Socket;

		public bool FemaleDummy;
	}

	public bool male = true;

	public bool maleDummy;

	public bool female;

	public bool femaleDummy;

	public bool femaleNoStability;

	public bool monogamous;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Quaternion rotation;

	private Type cachedType;

	public Vector3 selectSize = new Vector3(2f, 0.1f, 2f);

	public Vector3 selectCenter = new Vector3(0f, 0f, 1f);

	[ReadOnly]
	public string socketName;

	[NonSerialized]
	public SocketMod[] socketMods;

	public OccupiedSocketCheck[] checkOccupiedSockets;

	public Socket_Base()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		cachedType = ((object)this).GetType();
	}

	public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return position + rotation * worldPosition;
	}

	public virtual OBB GetSelectBounds(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(position + rotation * worldPosition, Vector3.one, rotation * worldRotation, new Bounds(selectCenter, selectSize));
	}

	protected override Type GetIndexedType()
	{
		return typeof(Socket_Base);
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		position = ((Component)this).transform.position;
		rotation = ((Component)this).transform.rotation;
		socketMods = ((Component)this).GetComponentsInChildren<SocketMod>(true);
		SocketMod[] array = socketMods;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].baseSocket = this;
		}
	}

	public virtual bool TestTarget(Construction.Target target)
	{
		return target.socket != null;
	}

	public virtual bool IsCompatible(Socket_Base socket)
	{
		if (socket == null)
		{
			return false;
		}
		if (!socket.male && !male)
		{
			return false;
		}
		if (!socket.female && !female)
		{
			return false;
		}
		return socket.cachedType == cachedType;
	}

	public virtual bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		return IsCompatible(socket);
	}

	public virtual Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.LookRotation(target.normal, Vector3.up) * Quaternion.Euler(target.rotation);
		Vector3 val2 = target.position;
		val2 -= val * position;
		Construction.Placement result = new Construction.Placement(target);
		result.rotation = val;
		result.position = val2;
		return result;
	}

	public virtual bool CheckSocketMods(ref Construction.Placement placement)
	{
		SocketMod[] array = socketMods;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ModifyPlacement(ref placement);
		}
		array = socketMods;
		foreach (SocketMod socketMod in array)
		{
			if (!(socketMod.SocketGrouping != null) && !socketMod.DoCheck(placement))
			{
				Construction.lastPlacementError = socketMod.GetTranslatedErrorMessage();
				return false;
			}
		}
		return true;
	}
}


using System;

[Serializable]
public class OccupiedSocketCheck
{
	public Socket_Base Socket;

	public bool FemaleDummy;
}


using UnityEngine;

public class Socket_Free : Socket_Base
{
	public Vector3 idealPlacementNormal = Vector3.up;

	public bool useTargetNormal = true;

	public bool blendAimAngle = true;

	public override bool TestTarget(Construction.Target target)
	{
		return target.onTerrain;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		Vector3 val2;
		if (useTargetNormal)
		{
			Vector3 normal = target.normal;
			Vector3 val = idealPlacementNormal;
			if (blendAimAngle || Mathf.Abs(target.normal.y) > 0.98f)
			{
				val2 = target.position - ((Ray)(ref target.ray)).origin;
				Vector3 normalized = ((Vector3)(ref val2)).normalized;
				float num = Mathf.Abs(Vector3.Dot(normalized, normal));
				val = Vector3.Lerp(normalized, idealPlacementNormal, num);
			}
			identity = Quaternion.LookRotation(normal, val) * Quaternion.Inverse(rotation) * Quaternion.Euler(target.rotation);
		}
		else
		{
			val2 = target.position - ((Ray)(ref target.ray)).origin;
			Vector3 normalized2 = ((Vector3)(ref val2)).normalized;
			normalized2.y = 0f;
			identity = Quaternion.LookRotation(normalized2, idealPlacementNormal) * Quaternion.Euler(target.rotation);
		}
		Vector3 val3 = target.position;
		val3 -= identity * position;
		Construction.Placement result = new Construction.Placement(target);
		result.rotation = identity;
		result.position = val3;
		return result;
	}
}


public enum DeployableSnappingMode
{
	Off,
	Simple,
	Advanced
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class Socket_Free_Snappable : Socket_Free
{
	private struct SnapResult
	{
		public bool Valid;

		public float Score;

		public Construction.Placement Placement;

		public string Label;

		public static SnapResult Invalid
		{
			get
			{
				SnapResult result = default(SnapResult);
				result.Valid = false;
				result.Score = float.MaxValue;
				return result;
			}
		}
	}

	private struct BuildingBlockPadding
	{
		public enum PaddingType
		{
			WeaksideOnly,
			StrongsideOnly,
			Both
		}

		public float YPadding;

		public float NormalPadding;

		public PaddingType PaddingMode;
	}

	[ClientVar(Saved = true, Help = "The current snapping mode for deployables.")]
	public static int SnappingMode = 2;

	[ClientVar]
	public static bool DebugSnapping = false;

	[Header("Snapping - General")]
	[SerializeField]
	private float generalPadding;

	[SerializeField]
	[Header("Snapping - Walls")]
	private float snappingPadding;

	[SerializeField]
	[Header("Snapping - Corners")]
	private bool allowSnappingToCorners = true;

	[SerializeField]
	private float cornerPadding = -0.01f;

	[SerializeField]
	[Header("Snapping - Same Deployable")]
	private bool allowSnappingToSameDeployable = true;

	[SerializeField]
	private float sameDeployablePadding;

	private BaseEntity staticEntity;

	private Construction staticConstruction;

	private static List<SnapResult> results = new List<SnapResult>();

	private static readonly Dictionary<string, BuildingBlockPadding> _buildingBlockPaddingDatabase = new Dictionary<string, BuildingBlockPadding>
	{
		{
			"assets/prefabs/building core/foundation/foundation.container.prefab",
			new BuildingBlockPadding
			{
				YPadding = 0.02f,
				NormalPadding = 0f,
				PaddingMode = BuildingBlockPadding.PaddingType.Both
			}
		},
		{
			"assets/prefabs/building core/wall/wall.wood.full.prefab",
			new BuildingBlockPadding
			{
				YPadding = 0f,
				NormalPadding = 0.1f,
				PaddingMode = BuildingBlockPadding.PaddingType.StrongsideOnly
			}
		},
		{
			"assets/prefabs/building core/wall/wall.twig.prefab",
			new BuildingBlockPadding
			{
				YPadding = 0f,
				NormalPadding = 0.1f,
				PaddingMode = BuildingBlockPadding.PaddingType.Both
			}
		}
	};

	private void AddDirections(Construction.Target target, PooledList<Vector3> directions, bool rayAligned)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		((List<Vector3>)(object)directions).Clear();
		Vector3 val;
		Vector3 val2;
		if (rayAligned)
		{
			val = ((Ray)(ref target.ray)).direction;
			val.y = 0f;
			val2 = -Vector3.Cross(val, Vector3.up);
		}
		else
		{
			val = ((Component)target.entity).transform.forward;
			val2 = ((Component)target.entity).transform.right;
		}
		((List<Vector3>)(object)directions).Add(val);
		((List<Vector3>)(object)directions).Add(-val);
		((List<Vector3>)(object)directions).Add(val2);
		((List<Vector3>)(object)directions).Add(-val2);
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		staticEntity = rootObj.GetComponent<BaseEntity>();
		staticConstruction = rootObj.GetComponent<Construction>();
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		if (SnappingMode == 0)
		{
			return base.DoPlacement(target);
		}
		if (!target.isHoldingShift || (Object)(object)target.entity == (Object)null)
		{
			return base.DoPlacement(target);
		}
		if (target.buildingBlocked)
		{
			return base.DoPlacement(target);
		}
		TimeWarning val = TimeWarning.New("Socket_Free_Snappable.DoPlacement", 0);
		try
		{
			Vector3 val2 = target.position + target.normal * 0.05f;
			Ray ray = new Ray(val2, Vector3.down);
			PooledList<RaycastHit> val3 = Pool.Get<PooledList<RaycastHit>>();
			try
			{
				GamePhysics.TraceAll(ray, 0f, (List<RaycastHit>)(object)val3, 2f, 2097152, (QueryTriggerInteraction)0);
				if (((List<RaycastHit>)(object)val3).Count > 0)
				{
					foreach (RaycastHit item in (List<RaycastHit>)(object)val3)
					{
						RaycastHit current = item;
						if (GamePhysics.LineOfSight(((Ray)(ref target.ray)).origin, ((RaycastHit)(ref current)).point + Vector3.up * 0.1f, 2097152) && !(Vector3Ex.Distance2D(((Ray)(ref target.ray)).origin, ((RaycastHit)(ref current)).point) > staticConstruction.maxplaceDistance))
						{
							float num = ((Bounds)(ref staticEntity.bounds)).extents.y - ((Bounds)(ref staticEntity.bounds)).center.y;
							Vector3 val4 = Vector3.up * num;
							target.position = ((RaycastHit)(ref current)).point + val4;
							float buildingBlockPadding = GetBuildingBlockPadding(((Object)((RaycastHit)(ref current)).collider).name, yPadding: true, ((Component)((RaycastHit)(ref current)).collider).transform, ((RaycastHit)(ref current)).normal);
							ref Vector3 reference = ref target.position;
							reference += Vector3.up * buildingBlockPadding;
						}
					}
					results.Clear();
					if (SnappingMode == 2)
					{
						results.Add(TryCornerSnap(target));
						results.Add(TryMatchingDeployableSnap(target));
					}
					results.Add(TryWallSnap(target));
					SnapResult snapResult = SnapResult.Invalid;
					foreach (SnapResult result in results)
					{
						if (DebugSnapping && result.Valid)
						{
							Debug.Log((object)$"[Snapping] Placement:{result.Label} (score: {result.Score:F3} (valid: {result.Valid})");
						}
						if (result.Valid && result.Score < snapResult.Score && ContainerCorpse.IsValidPointForEntity(staticEntity.prefabID, result.Placement.position, result.Placement.rotation))
						{
							if (DebugSnapping)
							{
								Debug.Log((object)$"Selected best: {result.Label}, Score: {result.Score}");
							}
							snapResult = result;
						}
					}
					if (DebugSnapping)
					{
						Debug.Log((object)$"Final Best Valid: {snapResult.Valid}, Score: {snapResult.Score}, Label: {snapResult.Label}");
					}
					if (snapResult.Valid)
					{
						if (DebugSnapping)
						{
							Debug.Log((object)$"[Snapping] Best placement: {snapResult.Label} (score: {snapResult.Score:F3})");
						}
						return snapResult.Placement;
					}
					target.valid = false;
					return base.DoPlacement(target);
				}
				target.valid = false;
				return base.DoPlacement(target);
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private float GetMaxDistance()
	{
		return 2.5f;
	}

	private float GetBuildingBlockPadding(string name, bool yPadding, Transform buildingBlockTransform, Vector3 rayNormal)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (_buildingBlockPaddingDatabase.TryGetValue(name, out var value))
		{
			if (yPadding)
			{
				return value.YPadding;
			}
			if (ShouldAddPadding(buildingBlockTransform, rayNormal, value.PaddingMode))
			{
				return value.NormalPadding;
			}
		}
		return 0f;
	}

	private bool ShouldAddPadding(Transform buildingBlockTransform, Vector3 rayNormal, BuildingBlockPadding.PaddingType type)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (type == BuildingBlockPadding.PaddingType.Both)
		{
			return true;
		}
		Matrix4x4 worldToLocalMatrix = buildingBlockTransform.worldToLocalMatrix;
		Vector3 val = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyVector(-rayNormal);
		float num = Vector3Ex.DotDegrees(worldForward, val);
		return type switch
		{
			BuildingBlockPadding.PaddingType.WeaksideOnly => num > 90f, 
			BuildingBlockPadding.PaddingType.StrongsideOnly => num < 90f, 
			_ => false, 
		};
	}

	private SnapResult TryWallSnap(Construction.Target target)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Socket_Free_Snappable.DoPlacement.TryWallSnap", 0);
		try
		{
			if (TryFindBestSnappingHit(target, out var bestHit))
			{
				Quaternion targetRotation = ComputeSnappedRotation(target, bestHit);
				Vector3 val2 = ComputeSnappedPosition(target, bestHit, targetRotation);
				float score = Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref bestHit)).point);
				SnapResult result = default(SnapResult);
				result.Valid = true;
				result.Score = score;
				result.Placement = new Construction.Placement(target)
				{
					position = val2,
					rotation = targetRotation
				};
				result.Label = "Wall";
				return result;
			}
			return SnapResult.Invalid;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool TryFindBestSnappingHit(Construction.Target target, out RaycastHit bestHit)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		bestHit = default(RaycastHit);
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			AddDirections(target, val, rayAligned: false);
			Vector3 val2 = target.position + Vector3.up * 0.05f;
			PooledList<RaycastHit> val3 = Pool.Get<PooledList<RaycastHit>>();
			try
			{
				Ray ray = default(Ray);
				foreach (Vector3 item in (List<Vector3>)(object)val)
				{
					((Ray)(ref ray))..ctor(val2, item);
					PooledList<RaycastHit> val4 = Pool.Get<PooledList<RaycastHit>>();
					try
					{
						GamePhysics.TraceAll(ray, 0f, (List<RaycastHit>)(object)val4, GetMaxDistance(), 2097152, (QueryTriggerInteraction)0);
						if (((List<RaycastHit>)(object)val4).Count <= 0)
						{
							continue;
						}
						foreach (RaycastHit item2 in (List<RaycastHit>)(object)val4)
						{
							((List<RaycastHit>)(object)val3).Add(item2);
						}
					}
					finally
					{
						((IDisposable)val4)?.Dispose();
					}
				}
				float num = float.MaxValue;
				foreach (RaycastHit item3 in (List<RaycastHit>)(object)val3)
				{
					RaycastHit current3 = item3;
					if (!(Vector3.Distance(((RaycastHit)(ref current3)).point, ((Ray)(ref target.ray)).origin) > staticConstruction.maxplaceDistance))
					{
						float num2 = Vector3Ex.Distance2D(val2, ((RaycastHit)(ref current3)).point);
						if (num2 < num)
						{
							num = num2;
							bestHit = current3;
						}
					}
				}
				return Math.Abs(num - float.MaxValue) > Mathf.Epsilon;
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private Quaternion ComputeSnappedRotation(Construction.Target target, RaycastHit bestHit)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((RaycastHit)(ref bestHit)).normal;
		normal.y = 0f;
		Quaternion val = ((normal == Vector3.zero) ? Quaternion.identity : Quaternion.LookRotation(normal, Vector3.up));
		Vector3 val2 = ((RaycastHit)(ref bestHit)).point - ((Ray)(ref target.ray)).origin;
		Vector3 val3 = -((Vector3)(ref val2)).normalized;
		val3.y = 0f;
		Quaternion val4 = Quaternion.LookRotation(val3, Vector3.up) * Quaternion.Euler(target.rotation);
		Quaternion val5 = val * Quaternion.Euler(target.rotation);
		Vector3 val6 = val5 * ((RaycastHit)(ref bestHit)).normal;
		Vector3 val7 = val4 * ((RaycastHit)(ref bestHit)).normal;
		if (Mathf.Abs(Vector3.Dot(val7, val6)) < 0.5f)
		{
			Quaternion val8 = Quaternion.AngleAxis(Mathf.Round(Vector3.SignedAngle(val6, val7, Vector3.up) / 90f) * 90f, Vector3.up);
			val5 *= val8;
		}
		return val5;
	}

	private Vector3 ComputeSnappedPosition(Construction.Target target, RaycastHit bestHit, Quaternion targetRotation)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((RaycastHit)(ref bestHit)).normal;
		normal.y = 0f;
		Matrix4x4 val = Matrix4x4.TRS(target.position, targetRotation, ((Component)staticEntity).transform.lossyScale);
		Matrix4x4 inverse = ((Matrix4x4)(ref val)).inverse;
		Vector3 val2 = Vector3.Scale(((Matrix4x4)(ref inverse)).MultiplyVector(normal), ((Bounds)(ref staticEntity.bounds)).extents);
		Vector3 val3 = ((Matrix4x4)(ref val)).MultiplyVector(val2);
		Vector3 val4 = targetRotation * ((Bounds)(ref staticEntity.bounds)).center;
		val4.y = 0f;
		float num = Vector3.Dot(val4, normal);
		Vector3 val5 = ((RaycastHit)(ref bestHit)).point + normal * snappingPadding + val3 - normal * num;
		val5 += normal * generalPadding;
		if ((Object)(object)((RaycastHit)(ref bestHit)).collider != (Object)null)
		{
			float buildingBlockPadding = GetBuildingBlockPadding(((Object)((RaycastHit)(ref bestHit)).collider).name, yPadding: false, ((Component)((RaycastHit)(ref bestHit)).collider).transform, ((RaycastHit)(ref bestHit)).normal);
			val5 += normal * buildingBlockPadding;
		}
		val5.y = target.position.y;
		return val5;
	}

	private SnapResult TryCornerSnap(Construction.Target target)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		if (!allowSnappingToCorners)
		{
			return SnapResult.Invalid;
		}
		TimeWarning val = TimeWarning.New("Socket_Free_Snappable.DoPlacement.TryCornerSnap", 0);
		try
		{
			if (TryFindCornerHits(target, out var hitA, out var hitB))
			{
				RaycastHit bestHit = ((Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref hitA)).point) < Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref hitB)).point)) ? hitA : hitB);
				Quaternion targetRotation = ComputeSnappedRotation(target, bestHit);
				Vector3 val2 = ComputeCornerSnappedPosition(target, hitA, hitB, targetRotation);
				float num = Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref hitA)).point);
				float num2 = Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref hitB)).point);
				float num3 = Mathf.Min(num, num2);
				num3 *= 0.7f;
				SnapResult result = default(SnapResult);
				result.Valid = true;
				result.Score = num3;
				result.Placement = new Construction.Placement(target)
				{
					position = val2,
					rotation = targetRotation
				};
				result.Label = "Corner";
				return result;
			}
			return SnapResult.Invalid;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool TryFindCornerHits(Construction.Target target, out RaycastHit hitA, out RaycastHit hitB)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		hitA = default(RaycastHit);
		hitB = default(RaycastHit);
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			AddDirections(target, val, rayAligned: false);
			Vector3 val2 = target.position + Vector3.up * 0.5f;
			float num = float.MaxValue;
			PooledList<RaycastHit> val3 = Pool.Get<PooledList<RaycastHit>>();
			try
			{
				Ray ray = default(Ray);
				foreach (Vector3 item in (List<Vector3>)(object)val)
				{
					((Ray)(ref ray))..ctor(val2, item);
					PooledList<RaycastHit> val4 = Pool.Get<PooledList<RaycastHit>>();
					try
					{
						GamePhysics.TraceAll(ray, 0f, (List<RaycastHit>)(object)val4, GetMaxDistance() / 2.5f, 2097408, (QueryTriggerInteraction)0);
						if (((List<RaycastHit>)(object)val4).Count <= 0)
						{
							continue;
						}
						foreach (RaycastHit item2 in (List<RaycastHit>)(object)val4)
						{
							((List<RaycastHit>)(object)val3).Add(item2);
						}
					}
					finally
					{
						((IDisposable)val4)?.Dispose();
					}
				}
				for (int i = 0; i < ((List<RaycastHit>)(object)val3).Count; i++)
				{
					for (int j = i + 1; j < ((List<RaycastHit>)(object)val3).Count; j++)
					{
						RaycastHit val5 = ((List<RaycastHit>)(object)val3)[i];
						Vector3 normal = ((RaycastHit)(ref val5)).normal;
						val5 = ((List<RaycastHit>)(object)val3)[j];
						Vector3 normal2 = ((RaycastHit)(ref val5)).normal;
						if (!(((List<RaycastHit>)(object)val3)[i].GetEntity().net.ID == ((List<RaycastHit>)(object)val3)[j].GetEntity().net.ID))
						{
							float num2 = Mathf.Abs(Vector3.Dot(((Vector3)(ref normal)).normalized, ((Vector3)(ref normal2)).normalized));
							val5 = ((List<RaycastHit>)(object)val3)[i];
							float num3 = Vector3Ex.Distance2D(val2, ((RaycastHit)(ref val5)).point);
							float num4 = num3;
							val5 = ((List<RaycastHit>)(object)val3)[j];
							num3 = num4 + Vector3Ex.Distance2D(val2, ((RaycastHit)(ref val5)).point);
							if (num2 < 0.3f && num3 < num)
							{
								hitA = ((List<RaycastHit>)(object)val3)[i];
								hitB = ((List<RaycastHit>)(object)val3)[j];
								num = num3;
							}
						}
					}
				}
				return Math.Abs(num - float.MaxValue) > Mathf.Epsilon;
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private Vector3 GetPlaneIntersectionPoint(Vector3 normal1, Vector3 point1, Vector3 normal2, Vector3 point2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(normal1, normal2);
		if (((Vector3)(ref val)).sqrMagnitude < Mathf.Epsilon)
		{
			return Vector3.zero;
		}
		float num = Vector3.Dot(normal1, point1);
		float num2 = Vector3.Dot(normal2, point2);
		Vector3 val2 = Vector3.Cross(normal2, val) * num + Vector3.Cross(val, normal1) * num2;
		float num3 = ((Vector3)(ref val)).magnitude * ((Vector3)(ref val)).magnitude;
		return val2 / num3;
	}

	private Vector3 ComputeCornerSnappedPosition(Construction.Target target, RaycastHit hitA, RaycastHit hitB, Quaternion targetRotation)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((RaycastHit)(ref hitA)).normal;
		Vector3 normal2 = ((RaycastHit)(ref hitB)).normal;
		normal.y = 0f;
		normal2.y = 0f;
		Vector3 planeIntersectionPoint = GetPlaneIntersectionPoint(normal, ((RaycastHit)(ref hitA)).point, normal2, ((RaycastHit)(ref hitB)).point);
		planeIntersectionPoint.y = target.position.y;
		Vector3 val = normal + normal2;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = targetRotation * ((Bounds)(ref staticEntity.bounds)).center;
		Matrix4x4 val3 = Matrix4x4.TRS(planeIntersectionPoint + val2, targetRotation, ((Component)staticEntity).transform.lossyScale);
		Matrix4x4 inverse = ((Matrix4x4)(ref val3)).inverse;
		Vector3 val4 = Vector3.Scale(((Matrix4x4)(ref inverse)).MultiplyVector(normal), ((Bounds)(ref staticEntity.bounds)).extents);
		inverse = ((Matrix4x4)(ref val3)).inverse;
		Vector3 val5 = Vector3.Scale(((Matrix4x4)(ref inverse)).MultiplyVector(normal2), ((Bounds)(ref staticEntity.bounds)).extents);
		Vector3 val6 = ((Matrix4x4)(ref val3)).MultiplyVector(val4 + val5);
		Vector3 val7 = planeIntersectionPoint + val6;
		val7 += normalized * cornerPadding;
		val7 += normalized * generalPadding;
		float num = 0f;
		if ((Object)(object)((RaycastHit)(ref hitA)).collider != (Object)null)
		{
			num = Mathf.Max(num, GetBuildingBlockPadding(((Object)((RaycastHit)(ref hitA)).collider).name, yPadding: false, ((Component)((RaycastHit)(ref hitA)).collider).transform, ((RaycastHit)(ref hitA)).normal));
		}
		if ((Object)(object)((RaycastHit)(ref hitB)).collider != (Object)null)
		{
			num = Mathf.Max(num, GetBuildingBlockPadding(((Object)((RaycastHit)(ref hitB)).collider).name, yPadding: false, ((Component)((RaycastHit)(ref hitB)).collider).transform, ((RaycastHit)(ref hitB)).normal));
		}
		val7 += normalized * num;
		val7.y = target.position.y;
		return val7;
	}

	private SnapResult TryMatchingDeployableSnap(Construction.Target target)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (!allowSnappingToSameDeployable)
		{
			return SnapResult.Invalid;
		}
		TimeWarning val = TimeWarning.New("Socket_Free_Snappable.DoPlacement.TryMatchingDeployableSnap", 0);
		try
		{
			if (TryFindMatchingDeployables(target, out var bestHit))
			{
				Quaternion targetRotation = ((RaycastHit)(ref bestHit)).transform.root.rotation;
				Vector3 val2 = ComputeSnappedMatchingDeployablePosition(target, bestHit, targetRotation);
				float num = Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref bestHit)).point);
				if (target.entity.prefabID == staticEntity.prefabID)
				{
					num *= 0.9f;
				}
				SnapResult result = default(SnapResult);
				result.Valid = true;
				result.Score = num;
				result.Placement = new Construction.Placement(target)
				{
					position = val2,
					rotation = targetRotation
				};
				result.Label = "Deployable";
				return result;
			}
			return SnapResult.Invalid;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private Vector3 ComputeSnappedMatchingDeployablePosition(Construction.Target target, RaycastHit bestHit, Quaternion targetRotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity entity = bestHit.GetEntity();
		if ((Object)(object)entity == (Object)null)
		{
			return target.position;
		}
		OBB val = entity.WorldSpaceBounds();
		Vector3 val2 = ((RaycastHit)(ref bestHit)).point - val.position;
		val2.y = 0f;
		Vector3[] obj = new Vector3[4]
		{
			val.right,
			-val.right,
			val.forward,
			-val.forward
		};
		Vector3 val3 = val.forward;
		float num = -1f;
		Vector3[] array = (Vector3[])(object)obj;
		foreach (Vector3 val4 in array)
		{
			float num2 = Vector3.Dot(val2, val4);
			if (num2 > num)
			{
				num = num2;
				val3 = val4;
			}
		}
		Matrix4x4 val5 = Matrix4x4.TRS(target.position, targetRotation, ((Component)staticEntity).transform.lossyScale);
		Matrix4x4 inverse = ((Matrix4x4)(ref val5)).inverse;
		Vector3 val6 = Vector3.Scale(((Matrix4x4)(ref inverse)).MultiplyVector(((Vector3)(ref val3)).normalized), ((Bounds)(ref staticEntity.bounds)).size);
		Vector3 val7 = ((Matrix4x4)(ref val5)).MultiplyVector(val6);
		Vector3 val8 = targetRotation * ((Bounds)(ref staticEntity.bounds)).center;
		val8.y = 0f;
		float num3 = Vector3.Dot(val8, val3);
		return ((Component)entity).transform.position + val3 * sameDeployablePadding + val7 - val3 * num3 + val3 * generalPadding;
	}

	private bool TryFindMatchingDeployables(Construction.Target target, out RaycastHit bestHit)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		bestHit = default(RaycastHit);
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			AddDirections(target, val, rayAligned: false);
			Vector3 val2 = target.position + Vector3.up * 0.05f;
			PooledList<RaycastHit> val3 = Pool.Get<PooledList<RaycastHit>>();
			try
			{
				Ray ray = default(Ray);
				foreach (Vector3 item in (List<Vector3>)(object)val)
				{
					((Ray)(ref ray))..ctor(val2, item);
					PooledList<RaycastHit> val4 = Pool.Get<PooledList<RaycastHit>>();
					try
					{
						GamePhysics.TraceAll(ray, 0f, (List<RaycastHit>)(object)val4, GetMaxDistance() * 1.5f, 256, (QueryTriggerInteraction)0);
						if (((List<RaycastHit>)(object)val4).Count <= 0)
						{
							continue;
						}
						foreach (RaycastHit item2 in (List<RaycastHit>)(object)val4)
						{
							RaycastHit current2 = item2;
							if (!((Object)(object)((RaycastHit)(ref current2)).collider == (Object)null) && current2.GetEntity().prefabID == staticEntity.prefabID)
							{
								((List<RaycastHit>)(object)val3).Add(current2);
							}
						}
					}
					finally
					{
						((IDisposable)val4)?.Dispose();
					}
				}
				float num = float.MaxValue;
				foreach (RaycastHit item3 in (List<RaycastHit>)(object)val3)
				{
					RaycastHit current3 = item3;
					if (!(Vector3.Distance(((RaycastHit)(ref current3)).point, ((Ray)(ref target.ray)).origin) > staticConstruction.maxplaceDistance))
					{
						float num2 = Vector3Ex.Distance2D(val2, ((RaycastHit)(ref current3)).point);
						if (num2 < num)
						{
							num = num2;
							bestHit = current3;
						}
					}
				}
				return Math.Abs(num - float.MaxValue) > Mathf.Epsilon;
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


private struct SnapResult
{
	public bool Valid;

	public float Score;

	public Construction.Placement Placement;

	public string Label;

	public static SnapResult Invalid
	{
		get
		{
			SnapResult result = default(SnapResult);
			result.Valid = false;
			result.Score = float.MaxValue;
			return result;
		}
	}
}


private struct BuildingBlockPadding
{
	public enum PaddingType
	{
		WeaksideOnly,
		StrongsideOnly,
		Both
	}

	public float YPadding;

	public float NormalPadding;

	public PaddingType PaddingMode;
}


public enum PaddingType
{
	WeaksideOnly,
	StrongsideOnly,
	Both
}


using UnityEngine;

public class Socket_Specific : Socket_Base
{
	public bool useFemaleRotation = true;

	public string targetSocketName;

	public bool blockPlacementOnChildEntities;

	public bool canRotate;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.2f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	public override bool TestTarget(Construction.Target target)
	{
		if (!base.TestTarget(target))
		{
			return false;
		}
		Socket_Specific_Female socket_Specific_Female = target.socket as Socket_Specific_Female;
		if (socket_Specific_Female == null)
		{
			return false;
		}
		if (blockPlacementOnChildEntities && (Object)(object)target.entity != (Object)null && (Object)(object)target.entity.GetParentEntity() != (Object)null)
		{
			return false;
		}
		return socket_Specific_Female.CanAccept(this);
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = target.socket.rotation;
		if (target.socket.male && target.socket.female)
		{
			val = target.socket.rotation * Quaternion.Euler(180f, 0f, 180f);
		}
		Socket_Specific_Female socket_Specific_Female = target.socket as Socket_Specific_Female;
		Transform val2 = (socket_Specific_Female.parentToBone ? target.entity.FindBone(socket_Specific_Female.boneName) : ((Component)target.entity).transform);
		Matrix4x4 localToWorldMatrix = val2.localToWorldMatrix;
		Vector3 val3 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(target.socket.localPosition);
		Quaternion val4;
		if (useFemaleRotation)
		{
			val4 = val2.rotation * val;
		}
		else
		{
			Vector3 val5 = new Vector3(val3.x, 0f, val3.z);
			Vector3 val6 = default(Vector3);
			((Vector3)(ref val6))..ctor(target.player.eyes.position.x, 0f, target.player.eyes.position.z);
			Vector3 val7 = val5 - val6;
			val4 = Quaternion.LookRotation(((Vector3)(ref val7)).normalized) * val;
		}
		Construction.Placement result = new Construction.Placement(target);
		Quaternion val8 = val4 * Quaternion.Inverse(rotation);
		if (canRotate)
		{
			val8 *= Quaternion.Euler(target.rotation);
		}
		Vector3 val9 = val8 * position;
		result.position = val3 - val9;
		result.rotation = val8;
		return result;
	}
}


using UnityEngine;

public class Socket_Specific_Female : Socket_Base
{
	public int rotationDegrees;

	public int rotationOffset;

	public string[] allowedMaleSockets;

	public bool parentToBone;

	public string boneName;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.2f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.DrawWireCube(selectCenter, selectSize);
	}

	public bool CanAccept(Socket_Specific socket)
	{
		string[] array = allowedMaleSockets;
		foreach (string text in array)
		{
			if (socket.targetSocketName == text)
			{
				return true;
			}
		}
		return false;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		return base.DoPlacement(target);
	}
}


using UnityEngine;

public class Socket_Terrain : Socket_Base
{
	public float placementHeight;

	public bool alignToNormal;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.2f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.color = new Color(0f, 1f, 0f, 0.2f);
		Gizmos.DrawCube(Vector3.zero, new Vector3(0.1f, 0.1f, placementHeight));
		Gizmos.color = new Color(0f, 1f, 0f, 0.5f);
		Gizmos.DrawWireCube(Vector3.zero, new Vector3(0.1f, 0.1f, placementHeight));
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	public override bool TestTarget(Construction.Target target)
	{
		return target.onTerrain;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		Vector3 direction = ((Ray)(ref target.ray)).direction;
		direction.y = 0f;
		((Vector3)(ref direction)).Normalize();
		Vector3 val = Vector3.up;
		if (alignToNormal)
		{
			val = target.normal;
		}
		Quaternion val2 = Quaternion.LookRotation(direction, val) * Quaternion.Euler(0f, eulerAngles.y, 0f) * Quaternion.Euler(target.rotation);
		Vector3 val3 = target.position;
		val3 -= val2 * position;
		Construction.Placement result = new Construction.Placement(target);
		result.rotation = val2;
		result.position = val3;
		return result;
	}
}


using UnityEngine;

public class StabilitySocket : Socket_Base
{
	[Range(0f, 1f)]
	public float support = 1f;

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.DrawWireCube(selectCenter, selectSize);
	}

	public override bool TestTarget(Construction.Target target)
	{
		return false;
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		OBB selectBounds = GetSelectBounds(position, rotation);
		OBB selectBounds2 = socket.GetSelectBounds(socketPosition, socketRotation);
		return ((OBB)(ref selectBounds)).Intersects(selectBounds2);
	}
}


using System;

public class WeakpointProperties : PrefabAttribute
{
	public bool BlockWhenRoofAttached;

	protected override Type GetIndexedType()
	{
		return typeof(WeakpointProperties);
	}
}


using UnityEngine;

public class CanvasOrderHack : MonoBehaviour
{
	private void OnEnable()
	{
		Canvas[] componentsInChildren = ((Component)this).GetComponentsInChildren<Canvas>(true);
		foreach (Canvas val in componentsInChildren)
		{
			if (val.overrideSorting)
			{
				int sortingOrder = val.sortingOrder;
				val.sortingOrder = sortingOrder + 1;
			}
		}
		componentsInChildren = ((Component)this).GetComponentsInChildren<Canvas>(true);
		foreach (Canvas val2 in componentsInChildren)
		{
			if (val2.overrideSorting)
			{
				int sortingOrder = val2.sortingOrder;
				val2.sortingOrder = sortingOrder - 1;
			}
		}
	}
}


using UnityEngine;

public class AnimalSkin : MonoBehaviour, IClientComponent
{
	public SkinnedMeshRenderer[] animalMesh;

	public AnimalMultiSkin[] animalSkins;

	private Model model;

	public bool dontRandomizeOnStart;

	private void Start()
	{
		model = ((Component)this).gameObject.GetComponent<Model>();
		if (!dontRandomizeOnStart)
		{
			int iSkin = Mathf.FloorToInt((float)Random.Range(0, animalSkins.Length));
			ChangeSkin(iSkin);
		}
	}

	public void ChangeSkin(int iSkin)
	{
		if (animalSkins.Length == 0)
		{
			return;
		}
		iSkin = Mathf.Clamp(iSkin, 0, animalSkins.Length - 1);
		SkinnedMeshRenderer[] array = animalMesh;
		foreach (SkinnedMeshRenderer val in array)
		{
			Material[] sharedMaterials = ((Renderer)val).sharedMaterials;
			if (sharedMaterials != null)
			{
				for (int j = 0; j < sharedMaterials.Length; j++)
				{
					sharedMaterials[j] = animalSkins[iSkin].multiSkin[j];
				}
				((Renderer)val).sharedMaterials = sharedMaterials;
			}
		}
		if ((Object)(object)model != (Object)null)
		{
			model.skin = iSkin;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class AnimalMultiSkin
{
	public Material[] multiSkin;
}


using UnityEngine;

public class AnimalAnimation : MonoBehaviour, IClientComponent
{
	public BaseEntity Entity;

	public BaseNpc Target;

	public Animator Animator;

	public MaterialEffect FootstepEffects;

	public Transform[] Feet;

	[Tooltip("Ensure there is a float param called idleOffset if this is enabled")]
	public bool hasIdleOffset;

	[Tooltip("Check animation clip weights when playing sounds so we don't play sounds for clips that are blended out")]
	public bool enforceClipWeights;

	[ReadOnly]
	public string BaseFolder;

	public string OverrideBaseFolder;

	public float RequiredCameraDistanceForSfx;
}


using UnityEngine;

public class AnimalFootIK : MonoBehaviour
{
	public Transform[] Feet;

	public Animator animator;

	public float maxWeightDistance = 0.1f;

	public float minWeightDistance = 0.025f;

	public float actualFootOffset = 0.01f;

	public bool GroundSample(Vector3 origin, out RaycastHit hit)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (Physics.Raycast(origin + Vector3.up * 0.5f, Vector3.down, ref hit, 1f, 455155969))
		{
			return true;
		}
		return false;
	}

	public void Start()
	{
	}

	public AvatarIKGoal GoalFromIndex(int index)
	{
		return (AvatarIKGoal)(index switch
		{
			0 => 2, 
			1 => 3, 
			2 => 0, 
			3 => 1, 
			_ => 2, 
		});
	}

	private void OnAnimatorIK(int layerIndex)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"animal ik!");
		for (int i = 0; i < 4; i++)
		{
			Transform val = Feet[i];
			AvatarIKGoal val2 = GoalFromIndex(i);
			_ = Vector3.up;
			Vector3 position = ((Component)val).transform.position;
			float iKPositionWeight = animator.GetIKPositionWeight(val2);
			if (GroundSample(((Component)val).transform.position - Vector3.down * actualFootOffset, out var hit))
			{
				_ = ((RaycastHit)(ref hit)).normal;
				position = ((RaycastHit)(ref hit)).point;
				float num = Vector3.Distance(((Component)val).transform.position - Vector3.down * actualFootOffset, position);
				iKPositionWeight = 1f - Mathf.InverseLerp(minWeightDistance, maxWeightDistance, num);
				animator.SetIKPosition(val2, position + Vector3.up * actualFootOffset);
			}
			else
			{
				iKPositionWeight = 0f;
			}
			animator.SetIKPositionWeight(val2, iKPositionWeight);
		}
	}
}


using UnityEngine;

public class AvatarSwitcher : StateMachineBehaviour
{
	public Avatar ToApply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateEnter(animator, stateInfo, layerIndex);
		if ((Object)(object)ToApply != (Object)null)
		{
			animator.avatar = ToApply;
			animator.Play(((AnimatorStateInfo)(ref stateInfo)).shortNameHash, layerIndex);
		}
	}
}


using System;
using UnityEngine;

public class BlendShapeController : MonoBehaviour
{
	public enum BlendMode
	{
		Idle,
		Happy,
		Angry
	}

	[Serializable]
	public struct BlendState
	{
		[Range(0f, 100f)]
		public float[] States;

		public BlendMode Mode;
	}

	public SkinnedMeshRenderer TargetRenderer;

	public BlendState[] States;

	public float LerpSpeed = 0.25f;

	public BlendMode CurrentMode;
}


public enum BlendMode
{
	Idle,
	Happy,
	Angry
}


using System;
using UnityEngine;

[Serializable]
public struct BlendState
{
	[Range(0f, 100f)]
	public float[] States;

	public BlendMode Mode;
}


using UnityEngine;

public class BlendTreeEventSender : StateMachineBehaviour
{
	[Tooltip("The name of the Blend Parameter to monitor.")]
	public string blendParameter = "BlendParameter";

	[Tooltip("The blend value threshold to trigger the event.")]
	public float triggerThreshold = 0.5f;

	[Tooltip("The event name that will be sent via SendMessage.")]
	public string eventName = "OnAnimationEvent";

	[Tooltip("Custom string parameter to send along with the event.")]
	public string eventParameter = "";

	[Tooltip("Should the event only fire once per entry?")]
	public bool fireOnce = true;

	private bool eventTriggered;

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		float @float = animator.GetFloat(blendParameter);
		if (@float >= triggerThreshold && (!fireOnce || !eventTriggered))
		{
			FireEvent(animator);
			eventTriggered = true;
		}
		if (@float < triggerThreshold)
		{
			eventTriggered = false;
		}
	}

	private void FireEvent(Animator animator)
	{
		((Component)animator).gameObject.SendMessage(eventName, (object)eventParameter, (SendMessageOptions)1);
	}
}


using UnityEngine;
using UnityEngine.Animations;

public class CurveStateSpeed : StateMachineBehaviour
{
	public AnimationCurve SpeedCurve = AnimationCurve.Constant(0f, 1f, 1f);

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex, controller);
		float speed = 1f;
		if (!animator.IsInTransition(layerIndex))
		{
			speed = SpeedCurve.Evaluate(((AnimatorStateInfo)(ref stateInfo)).normalizedTime);
		}
		animator.speed = speed;
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateExit(animator, stateInfo, layerIndex);
		animator.speed = 1f;
	}
}


using UnityEngine;

public class GameObjectToggleState : StateMachineBehaviour
{
	public bool UseCurve;

	[Tooltip("The normalised range in the animation in which to apply the TargetState")]
	[MinMax(0f, 1f)]
	public Vector2 ValidNormalisedRange;

	public AnimationCurve CurveRange = AnimationCurve.Linear(0f, 0f, 1f, 0f);

	[Tooltip("What state to set the target object to, true = enabled, false = disabled")]
	public bool TargetState;

	[Tooltip("What gameObject to toggle (ensure it's a unique name in the hierarchy)")]
	public string GameObjectName;

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex);
		bool flag = (UseCurve ? (CurveRange.Evaluate(((AnimatorStateInfo)(ref stateInfo)).normalizedTime) > 0f) : (((AnimatorStateInfo)(ref stateInfo)).normalizedTime > ValidNormalisedRange.x && ((AnimatorStateInfo)(ref stateInfo)).normalizedTime < ValidNormalisedRange.y));
		Model model = ((Component)animator).gameObject.GetComponent<Model>();
		if ((Object)(object)model == (Object)null)
		{
			model = ((Component)animator).gameObject.GetComponentInParent<Model>();
		}
		if ((Object)(object)model != (Object)null)
		{
			Transform val = model.FindBone(GameObjectName);
			if ((Object)(object)val != (Object)null)
			{
				((Component)val).gameObject.SetActive(flag ? TargetState : (!TargetState));
			}
		}
	}
}


using UnityEngine;

public class AverageVelocity
{
	private Vector3 pos;

	private float time;

	private float lastEntry;

	private float averageSpeed;

	private Vector3 averageVelocity;

	public float Speed => averageSpeed;

	public Vector3 Average => averageVelocity;

	public void Record(Vector3 newPos)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - time;
		if (!(num < 0.1f))
		{
			if (((Vector3)(ref pos)).sqrMagnitude > 0f)
			{
				Vector3 val = newPos - pos;
				averageVelocity = val * (1f / num);
				averageSpeed = ((Vector3)(ref averageVelocity)).magnitude;
			}
			time = Time.time;
			pos = newPos;
		}
	}
}


using UnityEngine;

public class NpcWalkAnimation : MonoBehaviour, IClientComponent
{
	public Vector3 HipFudge = new Vector3(-90f, 0f, 90f);

	public BaseNpc Npc;

	public Animator Animator;

	public Transform HipBone;

	public Transform LookBone;

	public bool UpdateWalkSpeed = true;

	public bool UpdateFacingDirection = true;

	public bool UpdateGroundNormal = true;

	public Transform alignmentRoot;

	public bool LaggyAss = true;

	public bool LookAtTarget;

	public float MaxLaggyAssRotation = 70f;

	public float MaxWalkAnimSpeed = 25f;

	public bool UseDirectionBlending;

	public bool useTurnPosing;

	public float turnPoseScale = 0.5f;

	public float laggyAssLerpScale = 15f;

	public bool skeletonChainInverted;
}


using UnityEngine;

public class ReliableEventSender : StateMachineBehaviour
{
	[Header("State Enter")]
	public string StateEnter;

	[Header("Mid State")]
	public string MidStateEvent;

	[Range(0f, 1f)]
	public float TargetEventTime;
}


using UnityEngine;

public class ShieldBlockStateBehaviour : StateMachineBehaviour
{
}


using UnityEngine;

public class StateLayerController : StateMachineBehaviour
{
	public int TargetLayer = 2;
}


using UnityEngine;

public class SuppressEyeMovement : StateMachineBehaviour
{
}


using UnityEngine;

public class AnimationEventForward : MonoBehaviour
{
	public GameObject targetObject;

	public void Event(string type)
	{
		targetObject.SendMessage(type);
	}
}


using ConVar;
using UnityEngine;
using UnityEngine.Audio;

public class AudioSettings : MonoBehaviour
{
	public static float duckingFactor = 1f;

	public AudioMixer mixer;

	private void Update()
	{
		if (!((Object)(object)mixer == (Object)null))
		{
			mixer.SetFloat("MasterVol", LinearToDecibel(Audio.master * duckingFactor));
			float num = default(float);
			mixer.GetFloat("MusicVol", ref num);
			if (!LevelManager.isLoaded || !MainCamera.isValid)
			{
				mixer.SetFloat("MusicVol", Mathf.Lerp(num, LinearToDecibel(Audio.musicvolumemenu), Time.deltaTime));
			}
			else
			{
				mixer.SetFloat("MusicVol", Mathf.Lerp(num, LinearToDecibel(Audio.musicvolume), Time.deltaTime));
			}
			float num2 = 1f - (((Object)(object)SingletonComponent<MixerSnapshotManager>.Instance == (Object)null) ? 0f : SingletonComponent<MixerSnapshotManager>.Instance.deafness);
			mixer.SetFloat("WorldVol", LinearToDecibel(Audio.game * num2));
			mixer.SetFloat("UIVol", LinearToDecibel(Audio.ui * num2));
			mixer.SetFloat("WorldVolFlashbang", LinearToDecibel(Audio.game));
			mixer.SetFloat("VoiceVol", LinearToDecibel(Audio.voices * num2));
			mixer.SetFloat("InstrumentVol", LinearToDecibel(Audio.instruments * num2));
			float num3 = LinearToDecibel(Audio.voiceProps * num2) - 28.7f;
			mixer.SetFloat("VoicePropsVol", num3 * num2);
			mixer.SetFloat("SeasonalEventsVol", LinearToDecibel(Audio.eventAudio * num2));
		}
	}

	private float LinearToDecibel(float linear)
	{
		if (linear > 0f)
		{
			return 20f * Mathf.Log10(linear);
		}
		return -144f;
	}
}


using System;
using System.Text;
using Facepunch;
using Rust.Workshop;
using TMPro;
using UnityEngine;

public class BenchmarkInfo : SingletonComponent<BenchmarkInfo>
{
	public static string BenchmarkTitle;

	public static string BenchmarkSubtitle;

	public TextMeshProUGUI PerformanceText;

	public TextMeshProUGUI SystemInfoText;

	private StringBuilder sb = new StringBuilder();

	private RealTimeSince timeSinceUpdated;

	private void Start()
	{
		string text = Environment.MachineName + "\n";
		text = text + SystemInfo.operatingSystem + "\n";
		text += $"{(double)SystemInfo.systemMemorySize / 1024.0:0}GB RAM\n";
		text = text + SystemInfo.processorType + "\n";
		text += $"{SystemInfo.graphicsDeviceName} ({(double)SystemInfo.graphicsMemorySize / 1024.0:0}GB)\n";
		text += "\n";
		text = text + BuildInfo.Current.Build.Node + " / " + BuildInfo.Current.Scm.Date + "\n";
		text = text + BuildInfo.Current.Scm.Repo + "/" + BuildInfo.Current.Scm.Branch + "#" + BuildInfo.Current.Scm.ChangeId + "\n";
		text = text + BuildInfo.Current.Scm.Author + " - " + BuildInfo.Current.Scm.Comment + "\n";
		((TMP_Text)SystemInfoText).text = text;
	}

	private void Update()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (!(RealTimeSince.op_Implicit(timeSinceUpdated) < 0.25f))
		{
			timeSinceUpdated = RealTimeSince.op_Implicit(0f);
			sb.Clear();
			sb.AppendLine(BenchmarkTitle);
			sb.AppendLine(BenchmarkSubtitle);
			sb.AppendLine();
			sb.Append(Performance.current.frameRate).Append(" FPS");
			sb.Append(" / ").Append(Performance.current.frameTime.ToString("0.0")).Append("ms");
			sb.AppendLine().Append(Performance.current.memoryAllocations).Append(" MB");
			sb.Append(" / ").Append(Performance.current.memoryCollections).Append(" GC");
			sb.AppendLine().Append(Performance.current.memoryUsageSystem).Append(" RAM");
			sb.AppendLine().Append(Performance.current.loadBalancerTasks).Append(" TASKS");
			sb.Append(" / ").Append(WorkshopSkin.QueuedCount).Append(" SKINS");
			sb.Append(" / ").Append(Performance.current.invokeHandlerTasks).Append(" INVOKES");
			sb.AppendLine();
			sb.AppendLine(DateTime.Now.ToShortDateString() + " " + DateTime.Now.ToLongTimeString());
			((TMP_Text)PerformanceText).text = sb.ToString();
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class BoneDictionary
{
	public Transform transform;

	public Transform[] transforms;

	public string[] names;

	private Dictionary<string, Transform> nameDict = new Dictionary<string, Transform>(StringComparer.OrdinalIgnoreCase);

	private Dictionary<uint, Transform> hashDict = new Dictionary<uint, Transform>();

	private Dictionary<Transform, uint> transformDict = new Dictionary<Transform, uint>();

	public int Count => transforms.Length;

	public BoneDictionary(Transform rootBone)
	{
		transform = rootBone;
		transforms = ((Component)rootBone).GetComponentsInChildren<Transform>(true);
		names = new string[transforms.Length];
		for (int i = 0; i < transforms.Length; i++)
		{
			Transform val = transforms[i];
			if ((Object)(object)val != (Object)null)
			{
				names[i] = ((Object)val).name;
			}
		}
		BuildBoneDictionary();
	}

	public BoneDictionary(Transform rootBone, Transform[] boneTransforms, string[] boneNames)
	{
		transform = rootBone;
		transforms = boneTransforms;
		names = boneNames;
		BuildBoneDictionary();
	}

	private void BuildBoneDictionary()
	{
		for (int i = 0; i < transforms.Length; i++)
		{
			Transform val = transforms[i];
			string text = names[i];
			uint num = StringPool.Get(text);
			if (!nameDict.ContainsKey(text))
			{
				nameDict.Add(text, val);
			}
			if (!hashDict.ContainsKey(num))
			{
				hashDict.Add(num, val);
			}
			if ((Object)(object)val != (Object)null && !transformDict.ContainsKey(val))
			{
				transformDict.Add(val, num);
			}
		}
	}

	public Transform FindBone(string name, bool defaultToRoot = true)
	{
		Transform value = null;
		if (nameDict.TryGetValue(name, out value))
		{
			return value;
		}
		if (!defaultToRoot)
		{
			return null;
		}
		return transform;
	}

	public Transform FindBone(uint hash, bool defaultToRoot = true)
	{
		Transform value = null;
		if (hashDict.TryGetValue(hash, out value))
		{
			return value;
		}
		if (!defaultToRoot)
		{
			return null;
		}
		return transform;
	}

	public uint FindBoneID(Transform transform)
	{
		if (!transformDict.TryGetValue(transform, out var value))
		{
			return StringPool.closest;
		}
		return value;
	}
}


using UnityEngine;

public class BoneRetarget : MonoBehaviour
{
	public bool preserveInFirstPerson;

	public bool restoreBeforePooling;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class AttackHeliCamOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class CCTVOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ClimateOverlay : MonoBehaviour
{
	[Range(0f, 1f)]
	public float blendingSpeed = 1f;

	public PostProcessVolume[] biomeVolumes;

	public const int biomeCount = 5;

	public const int volumeCount = 6;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ColdOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float smoothTime = 1f;

	public bool preventInstantiation;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ExplosionsOverlay : MonoBehaviour, IClientComponent
{
	public static ExplosionsOverlay Instance;

	public PostProcessVolume postProcessVolume;

	public AnimationCurve radialBlurStartCurve;

	public AnimationCurve radialBlurAmountCurve;

	public AnimationCurve lensDirtinessCurve;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class FlashbangOverlay : MonoBehaviour, IClientComponent
{
	public static FlashbangOverlay Instance;

	public PostProcessVolume postProcessVolume;

	public AnimationCurve burnIntensityCurve;

	public AnimationCurve whiteoutIntensityCurve;

	public SoundDefinition deafLoopDef;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HomingLauncherCamOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public NVGCamera nvgCameraOverlay;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HotOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float smoothTime = 1f;

	public bool preventInstantiation;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HurtOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float smoothTime = 1f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HurtPunch : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public static float punchHurtDuration = 0.334f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class NightLightOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float VisionCareExtraDistance = 20f;

	public float VisionCareExtraBrightness = 0.01f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class OxygenOverlay : MonoBehaviour
{
	[SerializeField]
	private PostProcessVolume postProcessVolume;

	[SerializeField]
	private float smoothTime = 1f;

	[Tooltip("If true, only show this effect when the player is mounted in a submarine.")]
	[SerializeField]
	private bool submarinesOnly;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class RadiationOverlay : MonoBehaviour
{
	public SoundDefinition[] geigerSounds;

	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class SharpenAndVignetteOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class SubmarineOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityStandardAssets.CinematicEffects;

public class TonemappingOverlay : ImageEffectLayer
{
	public TonemappingColorGrading tonemapping;
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class WaterOverlay : MonoBehaviour, IClientComponent
{
	[Serializable]
	public struct EffectParams
	{
		public float scatterCoefficient;

		public float scatterStrength;

		public bool blur;

		public float blurDistance;

		public float blurSize;

		public bool wiggle;

		public float wiggleSpeed;

		public bool chromaticAberration;

		public bool godRays;

		public static EffectParams Default = new EffectParams
		{
			scatterCoefficient = 1f,
			scatterStrength = 1f,
			blur = true,
			blurDistance = 6.5f,
			blurSize = 4f,
			wiggle = true,
			wiggleSpeed = 0.7f,
			chromaticAberration = false,
			godRays = false
		};

		public static EffectParams DefaultAdmin = new EffectParams
		{
			scatterCoefficient = 0.025f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = true,
			godRays = false
		};

		public static EffectParams DefaultGoggles = new EffectParams
		{
			scatterCoefficient = 0.05f,
			scatterStrength = 1f,
			blur = true,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = true,
			wiggleSpeed = 2f,
			chromaticAberration = true,
			godRays = true
		};

		public static EffectParams DefaultSubmarine = new EffectParams
		{
			scatterCoefficient = 0.025f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = false,
			godRays = false
		};

		public static EffectParams DefaultUnderwaterLab = new EffectParams
		{
			scatterCoefficient = 0.005f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = true,
			godRays = false
		};

		public static EffectParams DefaultCinematic = new EffectParams
		{
			scatterCoefficient = 0.025f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = true,
			godRays = false
		};
	}

	public PostProcessVolume postProcessVolume;

	public PostProcessVolume blurPostProcessVolume;

	public EffectParams defaultParams = EffectParams.Default;

	public EffectParams adminParams = EffectParams.DefaultAdmin;

	public EffectParams gogglesParams = EffectParams.DefaultGoggles;

	public EffectParams submarineParams = EffectParams.DefaultSubmarine;

	public EffectParams underwaterLabParams = EffectParams.DefaultUnderwaterLab;

	public EffectParams cinematicParams = EffectParams.DefaultCinematic;

	public Material[] UnderwaterFogMaterials;
}


using System;

[Serializable]
public struct EffectParams
{
	public float scatterCoefficient;

	public float scatterStrength;

	public bool blur;

	public float blurDistance;

	public float blurSize;

	public bool wiggle;

	public float wiggleSpeed;

	public bool chromaticAberration;

	public bool godRays;

	public static EffectParams Default = new EffectParams
	{
		scatterCoefficient = 1f,
		scatterStrength = 1f,
		blur = true,
		blurDistance = 6.5f,
		blurSize = 4f,
		wiggle = true,
		wiggleSpeed = 0.7f,
		chromaticAberration = false,
		godRays = false
	};

	public static EffectParams DefaultAdmin = new EffectParams
	{
		scatterCoefficient = 0.025f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = true,
		godRays = false
	};

	public static EffectParams DefaultGoggles = new EffectParams
	{
		scatterCoefficient = 0.05f,
		scatterStrength = 1f,
		blur = true,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = true,
		wiggleSpeed = 2f,
		chromaticAberration = true,
		godRays = true
	};

	public static EffectParams DefaultSubmarine = new EffectParams
	{
		scatterCoefficient = 0.025f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = false,
		godRays = false
	};

	public static EffectParams DefaultUnderwaterLab = new EffectParams
	{
		scatterCoefficient = 0.005f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = true,
		godRays = false
	};

	public static EffectParams DefaultCinematic = new EffectParams
	{
		scatterCoefficient = 0.025f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = true,
		godRays = false
	};
}


using UnityEngine;
using UnityEngine.UI;

public class CameraMan : SingletonComponent<CameraMan>
{
	public static string DefaultSaveName = string.Empty;

	public const string SavePositionExtension = ".cam";

	public const string SavePositionDirectory = "camsaves";

	public bool OnlyControlWhenCursorHidden = true;

	public bool NeedBothMouseButtonsToZoom;

	public float LookSensitivity = 1f;

	public float MoveSpeed = 1f;

	public static float GuideAspect = 4f;

	public static float GuideRatio = 3f;

	public Canvas canvas;

	public Graphic[] guides;
}


using ConVar;
using UnityEngine;

public class CameraSettings : MonoBehaviour, IClientComponent
{
	private Camera cam;

	private void OnEnable()
	{
		cam = ((Component)this).GetComponent<Camera>();
	}

	private void Update()
	{
		cam.farClipPlane = Mathf.Clamp(Graphics.drawdistance, 500f, 2500f);
	}
}


public class Client : SingletonComponent<Client>
{
	public static Phrase loading_loading = new Phrase("loading.loading", "Loading");

	public static Phrase loading_connecting = new Phrase("loading.connecting", "Connecting");

	public static Phrase loading_connectionaccepted = new Phrase("loading.connectionaccepted", "Connection Accepted");

	public static Phrase loading_connecting_negotiate = new Phrase("loading.connecting.negotiate", "Negotiating Connection");

	public static Phrase loading_level = new Phrase("loading.loadinglevel", "Loading Level");

	public static Phrase loading_skinnablewarmup = new Phrase("loading.skinnablewarmup", "Skinnable Warmup");

	public static Phrase loading_preloadcomplete = new Phrase("loading.preloadcomplete", "Preload Complete");

	public static Phrase loading_openingscene = new Phrase("loading.openingscene", "Opening Scene");

	public static Phrase loading_clientready = new Phrase("loading.clientready", "Client Ready");

	public static Phrase loading_prefabwarmup = new Phrase("loading.prefabwarmup", "Warming Prefabs [{0}/{1}]");

	public static Phrase loading_queue = new Phrase("loading.queue", "Queue");

	public static Phrase loading_queue_status = new Phrase("loading.queue.status", "{0:N0} PLAYERS AHEAD OF YOU, {1:N0} PLAYERS BEHIND");

	public static Phrase loading_queue_next = new Phrase("loading.queue.next", "YOU'RE NEXT - {1:N0} PLAYERS BEHIND YOU");

	public static Phrase party_too_large_phrase = new Phrase("loading.party_too_large", "Party too large to join server: max team size {0}");
}


public abstract class ComponentInfo<T> : ComponentInfo
{
	public T component;

	public void Initialize(T source)
	{
		component = source;
		Setup();
	}
}


using UnityEngine;

public abstract class ComponentInfo : MonoBehaviour
{
	public abstract void Setup();

	public abstract void Reset();
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class MeshCache
{
	[Serializable]
	public class Data
	{
		public Mesh mesh;

		public Vector3[] vertices;

		public Vector3[] normals;

		public Vector4[] tangents;

		public Color32[] colors32;

		public int[] triangles;

		public Vector2[] uv;

		public Vector2[] uv2;

		public Vector2[] uv3;

		public Vector2[] uv4;

		public Bounds bounds;
	}

	public static Dictionary<Mesh, Data> dictionary = new Dictionary<Mesh, Data>();

	public static Data Get(Mesh mesh)
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (!dictionary.TryGetValue(mesh, out var value))
		{
			value = new Data();
			value.mesh = mesh;
			value.vertices = mesh.vertices;
			value.normals = mesh.normals;
			value.tangents = mesh.tangents;
			value.colors32 = mesh.colors32;
			value.triangles = mesh.triangles;
			value.uv = mesh.uv;
			value.uv2 = mesh.uv2;
			value.uv3 = mesh.uv3;
			value.uv4 = mesh.uv4;
			value.bounds = mesh.bounds;
			dictionary.Add(mesh, value);
		}
		return value;
	}
}


using System;
using UnityEngine;

[Serializable]
public class Data
{
	public Mesh mesh;

	public Vector3[] vertices;

	public Vector3[] normals;

	public Vector4[] tangents;

	public Color32[] colors32;

	public int[] triangles;

	public Vector2[] uv;

	public Vector2[] uv2;

	public Vector2[] uv3;

	public Vector2[] uv4;

	public Bounds bounds;
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class MeshColliderData
{
	public List<int> triangles;

	public List<Vector3> vertices;

	public List<Vector3> normals;

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref vertices);
		}
		if (normals != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref normals);
		}
	}

	public void Clear()
	{
		if (triangles != null)
		{
			triangles.Clear();
		}
		if (vertices != null)
		{
			vertices.Clear();
		}
		if (normals != null)
		{
			normals.Clear();
		}
	}

	public void Apply(Mesh mesh)
	{
		mesh.Clear();
		if (vertices != null)
		{
			mesh.SetVertices(vertices);
		}
		if (triangles != null)
		{
			mesh.SetTriangles(triangles, 0);
		}
		if (normals != null)
		{
			if (normals.Count == vertices.Count)
			{
				mesh.SetNormals(normals);
			}
			else if (normals.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping collider normals because some meshes were missing them.");
			}
		}
	}

	public void Combine(MeshColliderGroup meshGroup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < ((List<MeshColliderInstance>)(object)meshGroup).Count; i++)
		{
			MeshColliderInstance meshColliderInstance = ((List<MeshColliderInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshColliderInstance.position, meshColliderInstance.rotation, meshColliderInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshColliderInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshColliderInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshColliderInstance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(meshColliderInstance.data.vertices[k]));
			}
			for (int l = 0; l < meshColliderInstance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(meshColliderInstance.data.normals[l]));
			}
		}
	}

	public void Combine(MeshColliderGroup meshGroup, MeshColliderLookup colliderLookup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < ((List<MeshColliderInstance>)(object)meshGroup).Count; i++)
		{
			MeshColliderInstance instance = ((List<MeshColliderInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(instance.position, instance.rotation, instance.scale);
			int count = vertices.Count;
			for (int j = 0; j < instance.data.triangles.Length; j++)
			{
				triangles.Add(count + instance.data.triangles[j]);
			}
			for (int k = 0; k < instance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(instance.data.vertices[k]));
			}
			for (int l = 0; l < instance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(instance.data.normals[l]));
			}
			colliderLookup.Add(instance);
		}
	}
}


public sealed class MeshColliderGroup : BasePooledList<MeshColliderInstance, MeshColliderGroup>
{
}


using UnityEngine;

public struct MeshColliderInstance
{
	public Transform transform;

	public Rigidbody rigidbody;

	public Collider collider;

	public OBB bounds;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public MeshCache.Data data;

	public Mesh mesh
	{
		get
		{
			return data.mesh;
		}
		set
		{
			data = MeshCache.Get(value);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class MeshColliderLookup
{
	public class LookupGroup
	{
		public List<LookupEntry> data = new List<LookupEntry>();

		public List<int> indices = new List<int>();

		public void Clear()
		{
			data.Clear();
			indices.Clear();
		}

		public void Add(MeshColliderInstance instance)
		{
			data.Add(new LookupEntry(instance));
			int item = data.Count - 1;
			int num = instance.data.triangles.Length / 3;
			for (int i = 0; i < num; i++)
			{
				indices.Add(item);
			}
		}

		public LookupEntry Get(int index)
		{
			return data[indices[index]];
		}
	}

	public struct LookupEntry
	{
		public Transform transform;

		public Rigidbody rigidbody;

		public Collider collider;

		public OBB bounds;

		public LookupEntry(MeshColliderInstance instance)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			transform = instance.transform;
			rigidbody = instance.rigidbody;
			collider = instance.collider;
			bounds = instance.bounds;
		}
	}

	public LookupGroup src = new LookupGroup();

	public LookupGroup dst = new LookupGroup();

	public void Apply()
	{
		LookupGroup lookupGroup = src;
		src = dst;
		dst = lookupGroup;
		dst.Clear();
	}

	public void Add(MeshColliderInstance instance)
	{
		dst.Add(instance);
	}

	public LookupEntry Get(int index)
	{
		return src.Get(index);
	}
}


using System.Collections.Generic;

public class LookupGroup
{
	public List<LookupEntry> data = new List<LookupEntry>();

	public List<int> indices = new List<int>();

	public void Clear()
	{
		data.Clear();
		indices.Clear();
	}

	public void Add(MeshColliderInstance instance)
	{
		data.Add(new LookupEntry(instance));
		int item = data.Count - 1;
		int num = instance.data.triangles.Length / 3;
		for (int i = 0; i < num; i++)
		{
			indices.Add(item);
		}
	}

	public LookupEntry Get(int index)
	{
		return data[indices[index]];
	}
}


using UnityEngine;

public struct LookupEntry
{
	public Transform transform;

	public Rigidbody rigidbody;

	public Collider collider;

	public OBB bounds;

	public LookupEntry(MeshColliderInstance instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		transform = instance.transform;
		rigidbody = instance.rigidbody;
		collider = instance.collider;
		bounds = instance.bounds;
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class MeshData
{
	public List<int> triangles;

	public List<Vector3> vertices;

	public List<Vector3> normals;

	public List<Vector4> tangents;

	public List<Color32> colors32;

	public List<Vector2> uv;

	public List<Vector2> uv2;

	public List<Vector4> positions;

	public void AllocMinimal()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
		if (tangents == null)
		{
			tangents = Pool.Get<List<Vector4>>();
		}
		if (uv == null)
		{
			uv = Pool.Get<List<Vector2>>();
		}
	}

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
		if (tangents == null)
		{
			tangents = Pool.Get<List<Vector4>>();
		}
		if (colors32 == null)
		{
			colors32 = Pool.Get<List<Color32>>();
		}
		if (uv == null)
		{
			uv = Pool.Get<List<Vector2>>();
		}
		if (uv2 == null)
		{
			uv2 = Pool.Get<List<Vector2>>();
		}
		if (positions == null)
		{
			positions = Pool.Get<List<Vector4>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref vertices);
		}
		if (normals != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref normals);
		}
		if (tangents != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref tangents);
		}
		if (colors32 != null)
		{
			Pool.FreeUnmanaged<Color32>(ref colors32);
		}
		if (uv != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv);
		}
		if (uv2 != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv2);
		}
		if (positions != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref positions);
		}
	}

	public void Clear()
	{
		if (triangles != null)
		{
			triangles.Clear();
		}
		if (vertices != null)
		{
			vertices.Clear();
		}
		if (normals != null)
		{
			normals.Clear();
		}
		if (tangents != null)
		{
			tangents.Clear();
		}
		if (colors32 != null)
		{
			colors32.Clear();
		}
		if (uv != null)
		{
			uv.Clear();
		}
		if (uv2 != null)
		{
			uv2.Clear();
		}
		if (positions != null)
		{
			positions.Clear();
		}
	}

	public void Apply(Mesh mesh)
	{
		mesh.Clear();
		if (vertices != null)
		{
			mesh.SetVertices(vertices);
		}
		if (triangles != null)
		{
			mesh.SetTriangles(triangles, 0);
		}
		if (normals != null)
		{
			if (normals.Count == vertices.Count)
			{
				mesh.SetNormals(normals);
			}
			else if (normals.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh normals because some meshes were missing them.");
			}
		}
		if (tangents != null)
		{
			if (tangents.Count == vertices.Count)
			{
				mesh.SetTangents(tangents);
			}
			else if (tangents.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh tangents because some meshes were missing them.");
			}
		}
		if (colors32 != null)
		{
			if (colors32.Count == vertices.Count)
			{
				mesh.SetColors(colors32);
			}
			else if (colors32.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh colors because some meshes were missing them.");
			}
		}
		if (uv != null)
		{
			if (uv.Count == vertices.Count)
			{
				mesh.SetUVs(0, uv);
			}
			else if (uv.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh uvs because some meshes were missing them.");
			}
		}
		if (uv2 != null)
		{
			if (uv2.Count == vertices.Count)
			{
				mesh.SetUVs(1, uv2);
			}
			else if (uv2.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh uv2s because some meshes were missing them.");
			}
		}
		if (positions != null)
		{
			mesh.SetUVs(2, positions);
		}
	}

	public void Combine(MeshGroup meshGroup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshInstance>)(object)meshGroup).Count; i++)
		{
			MeshInstance meshInstance = ((List<MeshInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshInstance.position, meshInstance.rotation, meshInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshInstance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(meshInstance.data.vertices[k]));
				positions.Add(Vector4.op_Implicit(meshInstance.position));
			}
			for (int l = 0; l < meshInstance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(meshInstance.data.normals[l]));
			}
			for (int m = 0; m < meshInstance.data.tangents.Length; m++)
			{
				Vector4 val2 = meshInstance.data.tangents[m];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				tangents.Add(new Vector4(val4.x, val4.y, val4.z, val2.w));
			}
			for (int n = 0; n < meshInstance.data.colors32.Length; n++)
			{
				colors32.Add(meshInstance.data.colors32[n]);
			}
			for (int num = 0; num < meshInstance.data.uv.Length; num++)
			{
				uv.Add(meshInstance.data.uv[num]);
			}
			for (int num2 = 0; num2 < meshInstance.data.uv2.Length; num2++)
			{
				uv2.Add(meshInstance.data.uv2[num2]);
			}
		}
	}
}


public sealed class MeshGroup : BasePooledList<MeshInstance, MeshGroup>
{
}


using UnityEngine;

public struct MeshInstance
{
	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public MeshCache.Data data;

	public Mesh mesh
	{
		get
		{
			return data.mesh;
		}
		set
		{
			data = MeshCache.Get(value);
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class MeshRendererData
{
	public List<int> triangles;

	public List<Vector3> vertices;

	public List<Vector3> normals;

	public List<Vector4> tangents;

	public List<Color32> colors32;

	public List<Vector2> uv;

	public List<Vector2> uv2;

	public List<Vector4> positions;

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
		if (tangents == null)
		{
			tangents = Pool.Get<List<Vector4>>();
		}
		if (colors32 == null)
		{
			colors32 = Pool.Get<List<Color32>>();
		}
		if (uv == null)
		{
			uv = Pool.Get<List<Vector2>>();
		}
		if (uv2 == null)
		{
			uv2 = Pool.Get<List<Vector2>>();
		}
		if (positions == null)
		{
			positions = Pool.Get<List<Vector4>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref vertices);
		}
		if (normals != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref normals);
		}
		if (tangents != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref tangents);
		}
		if (colors32 != null)
		{
			Pool.FreeUnmanaged<Color32>(ref colors32);
		}
		if (uv != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv);
		}
		if (uv2 != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv2);
		}
		if (positions != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref positions);
		}
	}

	public void Clear()
	{
		if (triangles != null)
		{
			triangles.Clear();
		}
		if (vertices != null)
		{
			vertices.Clear();
		}
		if (normals != null)
		{
			normals.Clear();
		}
		if (tangents != null)
		{
			tangents.Clear();
		}
		if (colors32 != null)
		{
			colors32.Clear();
		}
		if (uv != null)
		{
			uv.Clear();
		}
		if (uv2 != null)
		{
			uv2.Clear();
		}
		if (positions != null)
		{
			positions.Clear();
		}
	}

	public void Apply(Mesh mesh)
	{
		mesh.Clear();
		if (vertices != null)
		{
			mesh.SetVertices(vertices);
		}
		if (triangles != null)
		{
			mesh.SetTriangles(triangles, 0);
		}
		if (normals != null)
		{
			if (normals.Count == vertices.Count)
			{
				mesh.SetNormals(normals);
			}
			else if (normals.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer normals because some meshes were missing them.");
			}
		}
		if (tangents != null)
		{
			if (tangents.Count == vertices.Count)
			{
				mesh.SetTangents(tangents);
			}
			else if (tangents.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer tangents because some meshes were missing them.");
			}
		}
		if (colors32 != null)
		{
			if (colors32.Count == vertices.Count)
			{
				mesh.SetColors(colors32);
			}
			else if (colors32.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer colors because some meshes were missing them.");
			}
		}
		if (uv != null)
		{
			if (uv.Count == vertices.Count)
			{
				mesh.SetUVs(0, uv);
			}
			else if (uv.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer uvs because some meshes were missing them.");
			}
		}
		if (uv2 != null)
		{
			if (uv2.Count == vertices.Count)
			{
				mesh.SetUVs(1, uv2);
			}
			else if (uv2.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer uv2s because some meshes were missing them.");
			}
		}
		if (positions != null)
		{
			mesh.SetUVs(2, positions);
		}
	}

	public void Combine(MeshRendererGroup meshGroup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshRendererInstance>)(object)meshGroup).Count; i++)
		{
			MeshRendererInstance meshRendererInstance = ((List<MeshRendererInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshRendererInstance.position, meshRendererInstance.rotation, meshRendererInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshRendererInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshRendererInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshRendererInstance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(meshRendererInstance.data.vertices[k]));
				positions.Add(Vector4.op_Implicit(meshRendererInstance.position));
			}
			for (int l = 0; l < meshRendererInstance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(meshRendererInstance.data.normals[l]));
			}
			for (int m = 0; m < meshRendererInstance.data.tangents.Length; m++)
			{
				Vector4 val2 = meshRendererInstance.data.tangents[m];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				tangents.Add(new Vector4(val4.x, val4.y, val4.z, val2.w));
			}
			for (int n = 0; n < meshRendererInstance.data.colors32.Length; n++)
			{
				colors32.Add(meshRendererInstance.data.colors32[n]);
			}
			for (int num = 0; num < meshRendererInstance.data.uv.Length; num++)
			{
				uv.Add(meshRendererInstance.data.uv[num]);
			}
			for (int num2 = 0; num2 < meshRendererInstance.data.uv2.Length; num2++)
			{
				uv2.Add(meshRendererInstance.data.uv2[num2]);
			}
		}
	}

	public void Combine(MeshRendererGroup meshGroup, MeshRendererLookup rendererLookup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshRendererInstance>)(object)meshGroup).Count; i++)
		{
			MeshRendererInstance instance = ((List<MeshRendererInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(instance.position, instance.rotation, instance.scale);
			int count = vertices.Count;
			for (int j = 0; j < instance.data.triangles.Length; j++)
			{
				triangles.Add(count + instance.data.triangles[j]);
			}
			for (int k = 0; k < instance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(instance.data.vertices[k]));
				positions.Add(Vector4.op_Implicit(instance.position));
			}
			for (int l = 0; l < instance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(instance.data.normals[l]));
			}
			for (int m = 0; m < instance.data.tangents.Length; m++)
			{
				Vector4 val2 = instance.data.tangents[m];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				tangents.Add(new Vector4(val4.x, val4.y, val4.z, val2.w));
			}
			for (int n = 0; n < instance.data.colors32.Length; n++)
			{
				colors32.Add(instance.data.colors32[n]);
			}
			for (int num = 0; num < instance.data.uv.Length; num++)
			{
				uv.Add(instance.data.uv[num]);
			}
			for (int num2 = 0; num2 < instance.data.uv2.Length; num2++)
			{
				uv2.Add(instance.data.uv2[num2]);
			}
			rendererLookup.Add(instance);
		}
	}
}


public sealed class MeshRendererGroup : BasePooledList<MeshRendererInstance, MeshRendererGroup>
{
}


using UnityEngine;

public struct MeshRendererInstance
{
	public Renderer renderer;

	public OBB bounds;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public MeshCache.Data data;

	public Mesh mesh
	{
		get
		{
			return data.mesh;
		}
		set
		{
			data = MeshCache.Get(value);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class MeshRendererLookup
{
	public class LookupGroup
	{
		public List<LookupEntry> data = new List<LookupEntry>();

		public void Clear()
		{
			data.Clear();
		}

		public void Add(MeshRendererInstance instance)
		{
			data.Add(new LookupEntry(instance));
		}

		public LookupEntry Get(int index)
		{
			return data[index];
		}
	}

	public struct LookupEntry
	{
		public Renderer renderer;

		public LookupEntry(MeshRendererInstance instance)
		{
			renderer = instance.renderer;
		}
	}

	public LookupGroup src = new LookupGroup();

	public LookupGroup dst = new LookupGroup();

	public void Apply()
	{
		LookupGroup lookupGroup = src;
		src = dst;
		dst = lookupGroup;
		dst.Clear();
	}

	public void Clear()
	{
		dst.Clear();
	}

	public void Add(MeshRendererInstance instance)
	{
		dst.Add(instance);
	}

	public LookupEntry Get(int index)
	{
		return src.Get(index);
	}
}


using System.Collections.Generic;

public class LookupGroup
{
	public List<LookupEntry> data = new List<LookupEntry>();

	public void Clear()
	{
		data.Clear();
	}

	public void Add(MeshRendererInstance instance)
	{
		data.Add(new LookupEntry(instance));
	}

	public LookupEntry Get(int index)
	{
		return data[index];
	}
}


using UnityEngine;

public struct LookupEntry
{
	public Renderer renderer;

	public LookupEntry(MeshRendererInstance instance)
	{
		renderer = instance.renderer;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

public class RendererInfo : ComponentInfo<Renderer>
{
	public ShadowCastingMode shadows;

	public Material material;

	public Mesh mesh;

	public MeshFilter meshFilter;

	public override void Reset()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		component.shadowCastingMode = shadows;
		if (Object.op_Implicit((Object)(object)material))
		{
			component.sharedMaterial = material;
		}
		Renderer obj = component;
		SkinnedMeshRenderer val = (SkinnedMeshRenderer)(object)((obj is SkinnedMeshRenderer) ? obj : null);
		if (val != null)
		{
			val.sharedMesh = mesh;
		}
		else if (component is MeshRenderer)
		{
			meshFilter.sharedMesh = mesh;
		}
	}

	public override void Setup()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		shadows = component.shadowCastingMode;
		material = component.sharedMaterial;
		Renderer obj = component;
		SkinnedMeshRenderer val = (SkinnedMeshRenderer)(object)((obj is SkinnedMeshRenderer) ? obj : null);
		if (val != null)
		{
			mesh = val.sharedMesh;
		}
		else if (component is MeshRenderer)
		{
			meshFilter = ((Component)this).GetComponent<MeshFilter>();
			mesh = meshFilter.sharedMesh;
		}
	}
}


using UnityEngine;

public class CullWhenInside : MonoBehaviour
{
}


public class DecalBlood : DecalRecycle
{
}


using System;

public abstract class DecalComponent : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(DecalComponent);
	}
}


using UnityEngine;

public class DecalRecycle : BasePrefab, IClientComponent, IEffectRecycle
{
	public float LifeTime = 60f;

	[Range(1f, 50f)]
	public int WarmedUpAmount = 1;
}


public static class DecalRecycleEx
{
}


public class DecalRotate : DecalComponent
{
	[MinMax(0f, 360f)]
	public MinMax range = new MinMax(0f, 360f);
}


public class DecalScale : DecalComponent
{
	[MinMax(0f, 2f)]
	public MinMax range = new MinMax(0.9f, 1.1f);

	public bool uniform = true;
}


using UnityEngine;

public class DemoShotPlayback : MonoBehaviour
{
}


public class DemoShotRecorder : SingletonComponent<DemoShotRecorder>
{
}


public static class DemoShotHelpers
{
}


using System;
using UnityEngine;

[Obsolete]
public class DontBecomeSolidWithPlayerInside : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
public class DrawCameraFrustum : MonoBehaviour
{
	[SerializeField]
	private Material lineMaterial;
}


using UnityEngine;

public class DynamicZNear : MonoBehaviour
{
	public float minimum = 0.05f;

	public float maximum = 1f;
}


public static class EAC
{
}


using System.Runtime.CompilerServices;

public struct EncryptedValue<TInner> where TInner : unmanaged
{
	private TInner _value;

	private int _padding;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public TInner Get()
	{
		return _value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Set(TInner value)
	{
		_value = value;
	}

	public override string ToString()
	{
		return Get().ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator EncryptedValue<TInner>(TInner value)
	{
		EncryptedValue<TInner> result = default(EncryptedValue<TInner>);
		result.Set(value);
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator TInner(EncryptedValue<TInner> encrypted)
	{
		return encrypted.Get();
	}
}


using UnityEngine;

public class FollowCamera : MonoBehaviour, IClientComponent
{
	private void LateUpdate()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)MainCamera.mainCamera == (Object)null))
		{
			((Component)this).transform.position = MainCamera.position;
		}
	}
}


using UnityEngine;

public class Gib : ListComponent<Gib>
{
	public static int gibCount;

	public MeshFilter _meshFilter;

	public MeshRenderer _meshRenderer;

	public MeshCollider _meshCollider;

	public BoxCollider _boxCollider;

	public SphereCollider _sphereCollider;

	public CapsuleCollider _capsuleCollider;

	public Rigidbody _rigidbody;

	public static string GetEffect(PhysicMaterial physicMaterial)
	{
		return physicMaterial.GetNameLower() switch
		{
			"wood" => "assets/bundled/prefabs/fx/building/wood_gib.prefab", 
			"concrete" => "assets/bundled/prefabs/fx/building/stone_gib.prefab", 
			"metal" => "assets/bundled/prefabs/fx/building/metal_sheet_gib.prefab", 
			"rock" => "assets/bundled/prefabs/fx/building/stone_gib.prefab", 
			"flesh" => "assets/bundled/prefabs/fx/building/wood_gib.prefab", 
			_ => "assets/bundled/prefabs/fx/building/wood_gib.prefab", 
		};
	}
}


using System;
using System.Runtime.CompilerServices;
using Facepunch;

public sealed class HiddenValue<T> : IDisposable where T : class
{
	private T _value;

	public HiddenValue()
		: this((T)null)
	{
	}

	public HiddenValue(T value)
	{
		_value = value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public T Get()
	{
		return _value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public HiddenValue<T> Set(T value)
	{
		_value = value;
		return this;
	}

	public void Dispose()
	{
		_value = null;
		HiddenValue<T> hiddenValue = this;
		Pool.FreeUnsafe<HiddenValue<T>>(ref hiddenValue);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class IconSkin : MonoBehaviour, IItemIconChanged, IClientComponent
{
	public Image icon;

	public Text text;
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class IconSkinPicker : MonoBehaviour
{
	public GameObjectRef pickerIcon;

	public GameObject container;

	public Action skinChangedEvent;

	public ScrollRect scroller;

	public SearchFilterInput searchFilter;
}


using System.Collections.Generic;
using UnityEngine;

[DefaultExecutionOrder(-1)]
public class LightEx : UpdateBehaviour, IClientComponent
{
	public bool alterColor;

	public float colorTimeScale = 1f;

	public Color colorA = Color.red;

	public Color colorB = Color.yellow;

	public AnimationCurve blendCurve = new AnimationCurve();

	public bool loopColor = true;

	public bool alterIntensity;

	public float intensityTimeScale = 1f;

	public AnimationCurve intenseCurve = new AnimationCurve();

	public float intensityCurveScale = 3f;

	public bool loopIntensity = true;

	public bool randomOffset;

	public float randomIntensityStartScale = -1f;

	public List<Light> syncLights = new List<Light>(0);

	protected void OnValidate()
	{
		CheckConflict(((Component)this).gameObject);
	}

	public static bool CheckConflict(GameObject go)
	{
		return false;
	}
}


using UnityEngine;

public class LightGroupAtTime : FacepunchBehaviour
{
	public float IntensityOverride = 1f;

	public AnimationCurve IntensityScaleOverTime;

	public Transform SearchRoot;

	[Header("Power Settings")]
	public bool requiresPower;

	[Tooltip("Can NOT be entity, use new blank gameobject!")]
	public Transform powerOverrideTransform;

	public LayerMask checkLayers;

	public GameObject enableWhenLightsOn;

	public float timeBetweenPowerLookup;

	public LightGroupAtTime()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Expected O, but got Unknown
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		AnimationCurve val = new AnimationCurve();
		val.keys = (Keyframe[])(object)new Keyframe[5]
		{
			new Keyframe(0f, 1f),
			new Keyframe(8f, 0f),
			new Keyframe(12f, 0f),
			new Keyframe(19f, 1f),
			new Keyframe(24f, 1f)
		};
		IntensityScaleOverTime = val;
		checkLayers = LayerMask.op_Implicit(1235288065);
		timeBetweenPowerLookup = 10f;
		((FacepunchBehaviour)this)..ctor();
	}
}


using UnityEngine;

public class LocalPositionAnimation : MonoBehaviour, IClientComponent
{
	public Vector3 centerPosition;

	public bool worldSpace;

	public float scaleX = 1f;

	public float timeScaleX = 1f;

	public AnimationCurve movementX = new AnimationCurve();

	public float scaleY = 1f;

	public float timeScaleY = 1f;

	public AnimationCurve movementY = new AnimationCurve();

	public float scaleZ = 1f;

	public float timeScaleZ = 1f;

	public AnimationCurve movementZ = new AnimationCurve();
}


using UnityEngine;

[ExecuteInEditMode]
public class LookAt : MonoBehaviour, IClientComponent
{
	public Transform target;

	private void Update()
	{
		if (!((Object)(object)target == (Object)null))
		{
			((Component)this).transform.LookAt(target);
		}
	}
}


using System;
using UnityEngine;

[ExecuteInEditMode]
public class MainCamera : RustCamera<MainCamera>
{
	public static Camera mainCamera;

	public static Transform mainCameraTransform;

	public static Action PreCullCallback;

	public static bool isValid
	{
		get
		{
			if ((Object)(object)mainCamera != (Object)null && (Object)(object)mainCameraTransform != (Object)null)
			{
				return ((Behaviour)mainCamera).enabled;
			}
			return false;
		}
	}

	public static Vector3 velocity { get; private set; }

	public static Vector3 position
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.position;
		}
		set
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			mainCameraTransform.position = value;
		}
	}

	public static Vector3 forward
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.forward;
		}
		set
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			if (((Vector3)(ref value)).sqrMagnitude > 0f)
			{
				mainCameraTransform.forward = value;
			}
		}
	}

	public static Vector3 right
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.right;
		}
		set
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			if (((Vector3)(ref value)).sqrMagnitude > 0f)
			{
				mainCameraTransform.right = value;
			}
		}
	}

	public static Vector3 up
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.up;
		}
		set
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (((Vector3)(ref value)).sqrMagnitude > 0f)
			{
				((Component)mainCamera).transform.up = value;
			}
		}
	}

	public static Quaternion rotation
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.rotation;
		}
		set
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			mainCameraTransform.rotation = value;
		}
	}

	public static Ray Ray => new Ray(position, forward);
}


using System;
using UnityEngine;

public class MaterialParameterToggle : MonoBehaviour
{
	[Flags]
	public enum ToggleMode
	{
		Detail = 0,
		Emission = 1
	}

	[InspectorFlags]
	public ToggleMode Toggle;

	public Renderer[] TargetRenderers = (Renderer[])(object)new Renderer[0];

	[ColorUsage(true, true)]
	public Color EmissionColor;
}


using System;

[Flags]
public enum ToggleMode
{
	Detail = 0,
	Emission = 1
}


using UnityEngine;

public abstract class BaseMeshPaintable : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class MeshPaintable : BaseMeshPaintable
{
	public string replacementTextureName = "_MainTex";

	public int textureWidth = 256;

	public int textureHeight = 256;

	public Color clearColor = Color.clear;

	public Texture2D targetTexture;

	public bool hasChanges;
}


using UnityEngine;

public class MeshPaintable3D : BaseMeshPaintable
{
	[ClientVar]
	public static float brushScale = 2f;

	[ClientVar]
	public static float uvBufferScale = 2f;

	public string replacementTextureName = "_MainTex";

	public int textureWidth = 256;

	public int textureHeight = 256;

	public Camera cameraPreview;

	public Camera camera3D;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class MeshPaintableSource : MonoBehaviour, IClientComponent
{
	public Vector4 uvRange = new Vector4(0f, 0f, 1f, 1f);

	public int texWidth = 256;

	public int texHeight = 128;

	public string replacementTextureName = "_DecalTexture";

	public float cameraFOV = 60f;

	public float cameraDistance = 2f;

	[NonSerialized]
	public Texture2D texture;

	public GameObject sourceObject;

	public Mesh collisionMesh;

	public Vector3 localPosition;

	public Vector3 localRotation;

	public bool applyToAllRenderers = true;

	public Renderer[] extraRenderers;

	public bool paint3D;

	public bool applyToSkinRenderers = true;

	public bool applyToFirstPersonLegs = true;

	[NonSerialized]
	public bool isSelected;

	[NonSerialized]
	public Renderer legRenderer;

	private static MaterialPropertyBlock block;

	public void Init()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Expected O, but got Unknown
		if ((Object)(object)texture == (Object)null)
		{
			texture = new Texture2D(texWidth, texHeight, (TextureFormat)5, false);
			((Object)texture).name = "MeshPaintableSource_" + ((Object)((Component)this).gameObject).name;
			((Texture)texture).wrapMode = (TextureWrapMode)1;
			TextureEx.Clear(texture, Color32.op_Implicit(Color.clear));
		}
		if (block == null)
		{
			block = new MaterialPropertyBlock();
		}
		else
		{
			block.Clear();
		}
		UpdateMaterials(block, null, forEditing: false, isSelected);
		List<Renderer> list = Pool.Get<List<Renderer>>();
		Transform val = (applyToAllRenderers ? ((Component)this).transform.root : ((Component)this).transform);
		if (applyToSkinRenderers)
		{
			BaseEntity componentInParent = ((Component)this).GetComponentInParent<BaseEntity>();
			if ((Object)(object)componentInParent != (Object)null)
			{
				val = ((Component)componentInParent).transform;
			}
		}
		((Component)val).GetComponentsInChildren<Renderer>(true, list);
		PlayerModelSkin playerModelSkin = default(PlayerModelSkin);
		foreach (Renderer item in list)
		{
			if (applyToSkinRenderers || !((Component)item).TryGetComponent<PlayerModelSkin>(ref playerModelSkin))
			{
				item.SetPropertyBlock(block);
			}
		}
		if (extraRenderers != null)
		{
			Renderer[] array = extraRenderers;
			foreach (Renderer val2 in array)
			{
				if ((Object)(object)val2 != (Object)null)
				{
					val2.SetPropertyBlock(block);
				}
			}
		}
		if (applyToFirstPersonLegs && (Object)(object)legRenderer != (Object)null)
		{
			legRenderer.SetPropertyBlock(block);
		}
		Pool.FreeUnmanaged<Renderer>(ref list);
	}

	public void Free()
	{
		if (Object.op_Implicit((Object)(object)texture))
		{
			Object.Destroy((Object)(object)texture);
			texture = null;
		}
	}

	public void OnDestroy()
	{
		Free();
	}

	public virtual void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride = null, bool forEditing = false, bool isSelected = false)
	{
		block.SetTexture(replacementTextureName, (Texture)(object)(textureOverride ?? texture));
	}

	public virtual Color32[] UpdateFrom(Texture2D input)
	{
		Init();
		Color32[] pixels = input.GetPixels32();
		texture.SetPixels32(pixels);
		texture.Apply(true, false);
		return pixels;
	}

	public void Load(byte[] data)
	{
		Init();
		if (data != null)
		{
			ImageConversion.LoadImage(texture, data);
			texture.Apply(true, false);
		}
	}

	public void Clear()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)texture == (Object)null))
		{
			TextureEx.Clear(texture, Color32.op_Implicit(new Color(0f, 0f, 0f, 0f)));
			texture.Apply(true, false);
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class MeshPaintController : MonoBehaviour, IClientComponent
{
	public enum Tool
	{
		Brush,
		Eraser,
		ColorPicker
	}

	public enum RotateMode
	{
		None,
		Movement,
		Random
	}

	public Camera pickerCamera;

	public Tool currentTool;

	public Texture2D brushTexture;

	public Vector2 brushScale = new Vector2(8f, 8f);

	public Color brushColor = Color.white;

	public float brushSpacing = 2f;

	public float brushSpacingFactor = 0.25f;

	public RawImage brushImage;

	public float brushPreviewScaleMultiplier = 1f;

	public Texture2D stampTexture;

	public RotateMode brushRotation;

	public bool applyDefaults;

	public Texture2D defaltBrushTexture;

	public float defaultBrushSize = 16f;

	public Color defaultBrushColor = Color.black;

	public float defaultBrushAlpha = 0.5f;

	public float maxBrushScale = 32f;

	[Tooltip("When auto-saving is enabled, this is the interval in seconds between saves.")]
	public float autoSaveInterval = 30f;

	public RustButton UndoButton;

	public RustButton RedoButton;

	public GameObject BackgroundBlocker;

	private Vector3 lastPosition;
}


public enum Tool
{
	Brush,
	Eraser,
	ColorPicker
}


public enum RotateMode
{
	None,
	Movement,
	Random
}


using System;
using UnityEngine;

public class OverlayMeshPaintableSource : MeshPaintableSource
{
	private static readonly Memoized<string, string> STPrefixed = new Memoized<string, string>((Func<string, string>)((string s) => s + "_ST"));

	public string baseTextureName = "_Decal1Texture";

	[NonSerialized]
	public Texture2D baseTexture;

	public override void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride = null, bool forEditing = false, bool isSelected = false)
	{
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		base.UpdateMaterials(block, textureOverride, forEditing, isSelected);
		if ((Object)(object)baseTexture != (Object)null)
		{
			float num = (float)((Texture)baseTexture).width / (float)((Texture)baseTexture).height;
			int num2 = texWidth / texHeight;
			float num3 = 1f;
			float num4 = 0f;
			float num5 = 1f;
			float num6 = 0f;
			if ((float)num2 <= num)
			{
				float num7 = (float)texHeight * num;
				num3 = (float)texWidth / num7;
				num4 = (1f - num3) / 2f;
			}
			else
			{
				float num8 = (float)texWidth / num;
				num5 = (float)texHeight / num8;
				num6 = (1f - num5) / 2f;
			}
			block.SetTexture(baseTextureName, (Texture)(object)baseTexture);
			block.SetVector(STPrefixed.Get(baseTextureName), new Vector4(num3, num5, num4, num6));
		}
		else
		{
			block.SetTexture(baseTextureName, (Texture)(object)Texture2D.blackTexture);
		}
	}
}


using Facepunch;
using UnityEngine;

public class Model : MonoBehaviour, IPrefabPreProcess
{
	public SphereCollider collision;

	public Transform rootBone;

	public Transform headBone;

	public Transform eyeBone;

	public Animator animator;

	public Skeleton skeleton;

	[HideInInspector]
	public Transform[] boneTransforms;

	[HideInInspector]
	public string[] boneNames;

	internal BoneDictionary boneDict;

	internal int skin;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	protected void OnEnable()
	{
		skin = -1;
	}

	public void BuildBoneDictionary()
	{
		if (boneDict == null)
		{
			boneDict = new BoneDictionary(((Component)this).transform, boneTransforms, boneNames);
		}
	}

	public int GetSkin()
	{
		return skin;
	}

	private Transform FindBoneInternal(string name)
	{
		BuildBoneDictionary();
		return boneDict.FindBone(name, defaultToRoot: false);
	}

	public Transform FindBone(string name)
	{
		BuildBoneDictionary();
		Transform result = rootBone;
		if (string.IsNullOrEmpty(name))
		{
			return result;
		}
		return boneDict.FindBone(name);
	}

	public Transform FindBone(uint hash)
	{
		BuildBoneDictionary();
		Transform result = rootBone;
		if (hash == 0)
		{
			return result;
		}
		return boneDict.FindBone(hash);
	}

	public uint FindBoneID(Transform transform)
	{
		BuildBoneDictionary();
		return boneDict.FindBoneID(transform);
	}

	public Transform[] GetBones()
	{
		BuildBoneDictionary();
		return boneDict.transforms;
	}

	public Transform FindClosestBone(Vector3 worldPos)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Transform result = rootBone;
		float num = float.MaxValue;
		for (int i = 0; i < boneTransforms.Length; i++)
		{
			Transform val = boneTransforms[i];
			if (!((Object)(object)val == (Object)null))
			{
				float num2 = Vector3.Distance(val.position, worldPos);
				if (!(num2 >= num))
				{
					result = val;
					num = num2;
				}
			}
		}
		return result;
	}

	public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!((Object)(object)this == (Object)null))
		{
			if ((Object)(object)animator == (Object)null)
			{
				animator = ((Component)this).GetComponent<Animator>();
			}
			if ((Object)(object)rootBone == (Object)null)
			{
				rootBone = ((Component)this).transform;
			}
			boneTransforms = ((Component)rootBone).GetComponentsInChildren<Transform>(true);
			boneNames = new string[boneTransforms.Length];
			for (int i = 0; i < boneTransforms.Length; i++)
			{
				boneNames[i] = ((Object)boneTransforms[i]).name;
			}
		}
	}
}


public class NexusClient : SingletonComponent<NexusClient>
{
}


public static class NexusClientUtil
{
}


using UnityEngine;

public class ParticleDisableOnParentDestroy : MonoBehaviour, IOnParentDestroying
{
	public float destroyAfterSeconds;

	public void OnParentDestroying()
	{
		((Component)this).transform.parent = null;
		ParticleSystem component = ((Component)this).GetComponent<ParticleSystem>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.enableEmission = false;
		}
		if (destroyAfterSeconds > 0f)
		{
			GameManager.Destroy(((Component)this).gameObject, destroyAfterSeconds);
		}
	}
}


using UnityEngine;

public class ParticleRandomLifetime : MonoBehaviour
{
	public ParticleSystem mySystem;

	public float minScale = 0.5f;

	public float maxScale = 1f;

	public void Awake()
	{
		if (Object.op_Implicit((Object)(object)mySystem))
		{
			float startLifetime = Random.Range(minScale, maxScale);
			mySystem.startLifetime = startLifetime;
		}
	}
}


using UnityEngine;

public class PlayAudioEx : MonoBehaviour
{
	public float delay;

	private void Start()
	{
	}

	private void OnEnable()
	{
		AudioSource component = ((Component)this).GetComponent<AudioSource>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.PlayDelayed(delay);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PlayerModelHair : MonoBehaviour
{
	public struct RendererMaterials
	{
		public string[] names;

		public Material[] original;

		public Material[] replacement;

		public RendererMaterials(Renderer r)
		{
			original = r.sharedMaterials;
			replacement = original.Clone() as Material[];
			names = new string[original.Length];
			for (int i = 0; i < original.Length; i++)
			{
				names[i] = ((Object)original[i]).name;
			}
		}
	}

	public HairType type;

	private Dictionary<Renderer, RendererMaterials> materials;

	public Dictionary<Renderer, RendererMaterials> Materials => materials;

	private void CacheOriginalMaterials()
	{
		if (materials != null)
		{
			return;
		}
		List<SkinnedMeshRenderer> list = Pool.Get<List<SkinnedMeshRenderer>>();
		((Component)this).gameObject.GetComponentsInChildren<SkinnedMeshRenderer>(true, list);
		materials = new Dictionary<Renderer, RendererMaterials>();
		materials.Clear();
		foreach (SkinnedMeshRenderer item in list)
		{
			materials.Add((Renderer)(object)item, new RendererMaterials((Renderer)(object)item));
		}
		Pool.FreeUnmanaged<SkinnedMeshRenderer>(ref list);
	}

	private void Setup(HairType type, HairSetCollection hair, int meshIndex, float typeNum, float dyeNum, MaterialPropertyBlock block)
	{
		CacheOriginalMaterials();
		HairSetCollection.HairSetEntry hairSetEntry = hair.Get(type, typeNum);
		if ((Object)(object)hairSetEntry.HairSet == (Object)null)
		{
			Debug.LogWarning((object)"Hair.Get returned a NULL hair");
			return;
		}
		int blendShapeIndex = -1;
		if (type == HairType.Facial || type == HairType.Eyebrow)
		{
			blendShapeIndex = meshIndex;
		}
		HairDye dye = null;
		HairDyeCollection hairDyeCollection = hairSetEntry.HairDyeCollection;
		if ((Object)(object)hairDyeCollection != (Object)null)
		{
			dye = hairDyeCollection.Get(dyeNum);
		}
		hairSetEntry.HairSet.Process(this, hairDyeCollection, dye, block);
		hairSetEntry.HairSet.ProcessMorphs(((Component)this).gameObject, blendShapeIndex);
	}

	public void Setup(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
	{
		int index = skin.GetIndex(meshNum);
		SkinSet skinSet = skin.Skins[index];
		if ((Object)(object)skinSet == (Object)null)
		{
			Debug.LogError((object)"Skin.Get returned a NULL skin");
			return;
		}
		int typeIndex = (int)type;
		GetRandomVariation(hairNum, typeIndex, index, out var typeNum, out var dyeNum);
		Setup(type, skinSet.HairCollection, index, typeNum, dyeNum, block);
	}

	public static void GetRandomVariation(float hairNum, int typeIndex, int meshIndex, out float typeNum, out float dyeNum)
	{
		int num = Mathf.FloorToInt(hairNum * 100000f);
		typeNum = GetRandomHairType(hairNum, typeIndex);
		Random.InitState(num + meshIndex);
		dyeNum = Random.Range(0f, 1f);
	}

	public static float GetRandomHairType(float hairNum, int typeIndex)
	{
		Random.InitState(Mathf.FloorToInt(hairNum * 100000f) + typeIndex);
		return Random.Range(0f, 1f);
	}
}


using UnityEngine;

public struct RendererMaterials
{
	public string[] names;

	public Material[] original;

	public Material[] replacement;

	public RendererMaterials(Renderer r)
	{
		original = r.sharedMaterials;
		replacement = original.Clone() as Material[];
		names = new string[original.Length];
		for (int i = 0; i < original.Length; i++)
		{
			names[i] = ((Object)original[i]).name;
		}
	}
}


using System;

[Flags]
public enum HairCapMask
{
	Head = 1,
	Eyebrow = 2,
	Facial = 4,
	Armpit = 8,
	Pubic = 0x10
}


using UnityEngine;

public class PlayerModelHairCap : MonoBehaviour
{
	[InspectorFlags]
	public HairCapMask hairCapMask;

	public void SetupHairCap(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
	{
		int index = skin.GetIndex(meshNum);
		SkinSet skinSet = skin.Skins[index];
		if ((Object)(object)skinSet == (Object)null)
		{
			return;
		}
		for (int i = 0; i < 5; i++)
		{
			if (((uint)hairCapMask & (uint)(1 << i)) == 0)
			{
				continue;
			}
			PlayerModelHair.GetRandomVariation(hairNum, i, index, out var typeNum, out var dyeNum);
			HairType hairType = (HairType)i;
			HairSetCollection.HairSetEntry hairSetEntry = skinSet.HairCollection.Get(hairType, typeNum);
			if (!((Object)(object)hairSetEntry.HairSet == (Object)null))
			{
				HairDyeCollection hairDyeCollection = hairSetEntry.HairDyeCollection;
				if (!((Object)(object)hairDyeCollection == (Object)null))
				{
					hairDyeCollection.Get(dyeNum)?.ApplyCap(hairDyeCollection, hairType, block);
				}
			}
		}
	}
}


using UnityEngine;

public class PlayerModelSkin : MonoBehaviour, IPrefabPreProcess
{
	public enum SkinMaterialType
	{
		HEAD,
		EYE,
		BODY
	}

	public SkinMaterialType MaterialType;

	public Renderer SkinRenderer;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public void Setup(SkinSetCollection skin, float hairNum, float meshNum)
	{
		if (Object.op_Implicit((Object)(object)SkinRenderer) && Object.op_Implicit((Object)(object)skin))
		{
			switch (MaterialType)
			{
			case SkinMaterialType.HEAD:
				SkinRenderer.sharedMaterial = skin.Get(meshNum).HeadMaterial;
				break;
			case SkinMaterialType.BODY:
				SkinRenderer.sharedMaterial = skin.Get(meshNum).BodyMaterial;
				break;
			case SkinMaterialType.EYE:
				SkinRenderer.sharedMaterial = skin.Get(meshNum).EyeMaterial;
				break;
			default:
				SkinRenderer.sharedMaterial = skin.Get(meshNum).BodyMaterial;
				break;
			}
		}
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (clientside)
		{
			SkinRenderer = ((Component)this).GetComponent<Renderer>();
		}
	}
}


public enum SkinMaterialType
{
	HEAD,
	EYE,
	BODY
}


public interface ILerpInfo
{
	public enum LerpType
	{
		Generic,
		Position
	}

	float GetExtrapolationTime();

	float GetInterpolationDelay(LerpType lerpType);

	float GetInterpolationSmoothing();
}


public enum LerpType
{
	Generic,
	Position
}


using System.Collections.Generic;
using Rust.Interpolation;
using UnityEngine;

public interface IPosLerpTarget : ILerpInfo
{
	float GetInterpolationInertia();

	Vector3 GetNetworkPosition();

	Quaternion GetNetworkRotation();

	void SetNetworkPosition(Vector3 pos);

	void SetNetworkRotation(Quaternion rot);

	void DrawInterpolationState(Interpolator<TransformSnapshot>.Segment segment, List<TransformSnapshot> entries);

	void LerpIdleDisable();
}


using System;
using Development.Attributes;
using Facepunch;
using Rust.Interpolation;
using UnityEngine;

[ResetStaticFields]
public class PositionLerp : IPooled
{
	private static ListHashSet<PositionLerp> InstanceList = new ListHashSet<PositionLerp>();

	public static bool DebugLog = false;

	public static bool DebugDraw = false;

	public static int TimeOffsetInterval = 16;

	public static float TimeOffset = 0f;

	public const int TimeOffsetIntervalMin = 4;

	public const int TimeOffsetIntervalMax = 64;

	private bool enabled = true;

	private Action idleDisable;

	private readonly Interpolator<TransformSnapshot> interpolator = new Interpolator<TransformSnapshot>(32);

	private IPosLerpTarget target;

	private static TransformSnapshot snapshotPrototype = default(TransformSnapshot);

	private float timeOffset0 = float.MaxValue;

	private float timeOffset1 = float.MaxValue;

	private float timeOffset2 = float.MaxValue;

	private float timeOffset3 = float.MaxValue;

	private int timeOffsetCount;

	private float lastClientTime;

	private float lastServerTime;

	private float extrapolatedTime;

	private float enabledTime;

	public bool Enabled
	{
		get
		{
			return enabled;
		}
		set
		{
			enabled = value;
			if (enabled)
			{
				OnEnable();
			}
			else
			{
				OnDisable();
			}
		}
	}

	public static float LerpTime => Time.time;

	private void OnEnable()
	{
		InstanceList.Add(this);
		enabledTime = LerpTime;
	}

	private void OnDisable()
	{
		InstanceList.Remove(this);
	}

	public void Initialize(IPosLerpTarget target)
	{
		this.target = target;
		Enabled = true;
	}

	public void Snapshot(Vector3 position, Quaternion rotation, float serverTime)
	{
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		float num = interpolationDelay + interpolationSmoothing + 1f;
		float lerpTime = LerpTime;
		timeOffset0 = Mathf.Min(timeOffset0, lerpTime - serverTime);
		timeOffsetCount++;
		if (timeOffsetCount >= TimeOffsetInterval / 4)
		{
			timeOffset3 = timeOffset2;
			timeOffset2 = timeOffset1;
			timeOffset1 = timeOffset0;
			timeOffset0 = float.MaxValue;
			timeOffsetCount = 0;
		}
		TimeOffset = Mathx.Min(timeOffset0, timeOffset1, timeOffset2, timeOffset3);
		lerpTime = serverTime + TimeOffset;
		if (DebugLog && interpolator.list.Count > 0 && serverTime < lastServerTime)
		{
			Debug.LogWarning((object)(target.ToString() + " adding tick from the past: server time " + serverTime + " < " + lastServerTime));
		}
		else if (DebugLog && interpolator.list.Count > 0 && lerpTime < lastClientTime)
		{
			Debug.LogWarning((object)(target.ToString() + " adding tick from the past: client time " + lerpTime + " < " + lastClientTime));
		}
		else
		{
			lastClientTime = lerpTime;
			lastServerTime = serverTime;
			interpolator.Add(new TransformSnapshot(lerpTime, position, rotation));
		}
		interpolator.Cull(lerpTime - num);
	}

	public void Snapshot(Vector3 position, Quaternion rotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Snapshot(position, rotation, LerpTime - TimeOffset);
	}

	public void SnapTo(Vector3 position, Quaternion rotation, float serverTime)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		interpolator.Clear();
		Snapshot(position, rotation, serverTime);
		target.SetNetworkPosition(position);
		target.SetNetworkRotation(rotation);
	}

	public void SnapTo(Vector3 position, Quaternion rotation)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		interpolator.last = new TransformSnapshot(LerpTime, position, rotation);
		Wipe();
	}

	public void SnapToEnd()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, 0f, 0f, ref snapshotPrototype);
		target.SetNetworkPosition(segment.tick.pos);
		target.SetNetworkRotation(segment.tick.rot);
		Wipe();
	}

	public void Wipe()
	{
		interpolator.Clear();
		timeOffsetCount = 0;
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
	}

	public static void WipeAll()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<PositionLerp> enumerator = InstanceList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Wipe();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	protected void DoCycle()
	{
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		if (target == null)
		{
			return;
		}
		float interpolationInertia = target.GetInterpolationInertia();
		float num = ((interpolationInertia > 0f) ? Mathf.InverseLerp(0f, interpolationInertia, LerpTime - enabledTime) : 1f);
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolation = target.GetInterpolationDelay(ILerpInfo.LerpType.Position) * num;
		float num2 = target.GetInterpolationSmoothing() * num;
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolation, extrapolationTime, num2, ref snapshotPrototype);
		if (segment.next.Time >= interpolator.last.Time)
		{
			extrapolatedTime = Mathf.Min(extrapolatedTime + Time.deltaTime, extrapolationTime);
		}
		else
		{
			extrapolatedTime = Mathf.Max(extrapolatedTime - Time.deltaTime, 0f);
		}
		if (extrapolatedTime > 0f && extrapolationTime > 0f && num2 > 0f)
		{
			float num3 = Time.deltaTime / (extrapolatedTime / extrapolationTime * num2);
			segment.tick.pos = Vector3.Lerp(target.GetNetworkPosition(), segment.tick.pos, num3);
			segment.tick.rot = Quaternion.Slerp(target.GetNetworkRotation(), segment.tick.rot, num3);
		}
		target.SetNetworkPosition(segment.tick.pos);
		target.SetNetworkRotation(segment.tick.rot);
		if (DebugDraw)
		{
			target.DrawInterpolationState(segment, interpolator.list);
		}
		if (LerpTime - lastClientTime > 10f)
		{
			if (idleDisable == null)
			{
				idleDisable = target.LerpIdleDisable;
			}
			IPosLerpTarget posLerpTarget = target;
			InvokeHandler.Invoke((Behaviour)((posLerpTarget is Behaviour) ? posLerpTarget : null), idleDisable, 0f);
		}
	}

	public void TransformEntries(Matrix4x4 matrix)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		Quaternion rotation = ((Matrix4x4)(ref matrix)).rotation;
		for (int i = 0; i < interpolator.list.Count; i++)
		{
			TransformSnapshot value = interpolator.list[i];
			value.pos = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(value.pos);
			value.rot = rotation * value.rot;
			interpolator.list[i] = value;
		}
		interpolator.last.pos = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(interpolator.last.pos);
		interpolator.last.rot = rotation * interpolator.last.rot;
	}

	public Quaternion GetEstimatedAngularVelocity()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (target == null)
		{
			return Quaternion.identity;
		}
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, extrapolationTime, interpolationSmoothing, ref snapshotPrototype);
		TransformSnapshot next = segment.next;
		TransformSnapshot prev = segment.prev;
		if (next.Time == prev.Time)
		{
			return Quaternion.identity;
		}
		return Quaternion.Euler((((Quaternion)(ref prev.rot)).eulerAngles - ((Quaternion)(ref next.rot)).eulerAngles) / (prev.Time - next.Time));
	}

	public Vector3 GetEstimatedVelocity()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (target == null)
		{
			return Vector3.zero;
		}
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, extrapolationTime, interpolationSmoothing, ref snapshotPrototype);
		TransformSnapshot next = segment.next;
		TransformSnapshot prev = segment.prev;
		if (next.Time == prev.Time)
		{
			return Vector3.zero;
		}
		return (prev.pos - next.pos) / (prev.Time - next.Time);
	}

	void IPooled.EnterPool()
	{
		target = null;
		idleDisable = null;
		interpolator.Clear();
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
		lastClientTime = 0f;
		lastServerTime = 0f;
		extrapolatedTime = 0f;
		timeOffsetCount = 0;
		Enabled = false;
	}

	void IPooled.LeavePool()
	{
	}

	public static void Clear()
	{
		InstanceList.Clear();
	}

	public static void Cycle()
	{
		PositionLerp[] buffer = InstanceList.Values.Buffer;
		int count = InstanceList.Count;
		for (int i = 0; i < count; i++)
		{
			buffer[i].DoCycle();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

public class Projectile : ListComponent<Projectile>
{
	public enum EffectMatchMode
	{
		None,
		Velocity,
		InverseVelocity
	}

	[Serializable]
	public class CustomEffectData
	{
		public bool UseCustomEffect;

		public EffectMatchMode MatchMode;
	}

	public struct Modifier
	{
		public float damageScale;

		public float damageOffset;

		public float distanceScale;

		public float distanceOffset;

		public static Modifier Default = new Modifier
		{
			damageScale = 1f,
			damageOffset = 0f,
			distanceScale = 1f,
			distanceOffset = 0f
		};
	}

	public const float moveDeltaTime = 1f / 32f;

	public const float lifeTime = 8f;

	[Header("Attributes")]
	public Vector3 initialVelocity;

	public float drag;

	public float gravityModifier = 1f;

	public float thickness;

	[Header("Orientation")]
	[Tooltip("Tick this box to be able to change the initial orientation of the projectile")]
	public bool changeInitialOrientation;

	[Tooltip("This projectile will raycast for this many units, and then become a projectile. This is typically done for bullets.")]
	public float initialDistance;

	public Vector3 initialOrientation;

	[Header("Impact Rules")]
	public bool remainInWorld;

	[Range(0f, 1f)]
	public float stickProbability = 1f;

	[Range(0f, 1f)]
	public float breakProbability;

	[Range(0f, 1f)]
	public float conditionLoss;

	[Range(0f, 1f)]
	public float ricochetChance;

	public float penetrationPower = 1f;

	public bool canRefract = true;

	public bool penetratesVehicles;

	[Range(0f, 1f)]
	public float waterIntegrityLoss = 0.1f;

	[Header("Damage")]
	public DamageProperties damageProperties;

	[Horizontal(2, -1)]
	public MinMax damageDistances = new MinMax(10f, 100f);

	[Horizontal(2, -1)]
	public MinMax damageMultipliers = new MinMax(1f, 0.8f);

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	[Header("Rendering")]
	public ScaleRenderer rendererToScale;

	public ScaleRenderer firstPersonRenderer;

	public bool createDecals = true;

	[Header("Effects")]
	public bool doDefaultHitEffects = true;

	[Header("Audio")]
	public SoundDefinition flybySound;

	public float flybySoundDistance = 7f;

	public SoundDefinition closeFlybySound;

	public float closeFlybyDistance = 3f;

	[Header("Tumble")]
	public float tumbleSpeed;

	public Vector3 tumbleAxis = Vector3.right;

	[Header("Clientside Custom Impact Effects")]
	public bool playDefaultHitEffects = true;

	public CustomEffectData clientEffectData;

	public GameObjectRef clientEffectPrefab;

	[Header("Swim")]
	public Vector3 swimScale;

	public Vector3 swimSpeed;

	[NonSerialized]
	public BasePlayer owner;

	[NonSerialized]
	public AttackEntity sourceWeaponPrefab;

	[NonSerialized]
	public Projectile sourceProjectilePrefab;

	[NonSerialized]
	public ItemModProjectile mod;

	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public int seed;

	[NonSerialized]
	public bool clientsideEffect;

	[NonSerialized]
	public bool clientsideAttack;

	[NonSerialized]
	public float integrity = 1f;

	[NonSerialized]
	public float maxDistance = float.PositiveInfinity;

	[NonSerialized]
	public Modifier modifier = Modifier.Default;

	[NonSerialized]
	public bool invisible;

	[NonSerialized]
	public bool noHeadshots;

	[NonSerialized]
	public bool noGravity;

	[NonSerialized]
	public float currentThickness;

	[ClientVar(Help = "Should the projectile model attempt to prevent itself being clipped by the camera?", Saved = true)]
	public static bool preventCameraClip = true;

	[ClientVar(Help = "Buffer seconds before turning back on the projectile model.")]
	public static float preventCameraClipBufferSeconds = 0.01f;

	[ClientVar(Help = "Distance before turning back on the server spawned projectiles model.")]
	public static float serverProjectileCameraClipDistance = 0.3f;

	private static uint _fleshMaterialID = 0u;

	private static uint _waterMaterialID = 0u;

	private static uint cachedWaterString = 0u;

	private Vector3? GetCustomEffectNormal()
	{
		return null;
	}

	public void CalculateDamage(HitInfo info, Modifier mod, float scale)
	{
		float num = damageMultipliers.Lerp(mod.distanceOffset + mod.distanceScale * damageDistances.x, mod.distanceOffset + mod.distanceScale * damageDistances.y, info.ProjectileDistance);
		float num2 = scale * (mod.damageOffset + mod.damageScale * num);
		foreach (DamageTypeEntry damageType in damageTypes)
		{
			info.damageTypes.Add(damageType.type, damageType.amount * num2);
		}
		if (Global.developer > 0)
		{
			Debug.Log((object)(" Projectile damage: " + info.damageTypes.Total() + " (scalar=" + num2 + ")"));
		}
	}

	public static uint FleshMaterialID()
	{
		if (_fleshMaterialID == 0)
		{
			_fleshMaterialID = StringPool.Get("flesh");
		}
		return _fleshMaterialID;
	}

	public static uint WaterMaterialID()
	{
		if (_waterMaterialID == 0)
		{
			_waterMaterialID = StringPool.Get("Water");
		}
		return _waterMaterialID;
	}

	public static bool IsWaterMaterial(string hitMaterial)
	{
		if (cachedWaterString == 0)
		{
			cachedWaterString = StringPool.Get("Water");
		}
		if (StringPool.Get(hitMaterial) == cachedWaterString)
		{
			return true;
		}
		return false;
	}

	public static bool ShouldStopProjectile(RaycastHit hit)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity entity = hit.GetEntity();
		if ((Object)(object)entity != (Object)null && !entity.ShouldBlockProjectiles())
		{
			return false;
		}
		return true;
	}
}


public enum EffectMatchMode
{
	None,
	Velocity,
	InverseVelocity
}


using System;

[Serializable]
public class CustomEffectData
{
	public bool UseCustomEffect;

	public EffectMatchMode MatchMode;
}


public struct Modifier
{
	public float damageScale;

	public float damageOffset;

	public float distanceScale;

	public float distanceOffset;

	public static Modifier Default = new Modifier
	{
		damageScale = 1f,
		damageOffset = 0f,
		distanceScale = 1f,
		distanceOffset = 0f
	};
}


using UnityEngine;

public class QueryVis : BaseMonoBehaviour, IClientComponent
{
	public Collider checkCollider;

	private CoverageQueries.Query query;

	public CoverageQueries.RadiusSpace coverageRadiusSpace = CoverageQueries.RadiusSpace.World;

	public float coverageRadius = 0.2f;
}


public class QueryVisJobRunner : BaseMonoBehaviour, IClientComponent
{
}


internal interface IRagdollInhert
{
}


using UnityEngine;

public class RotateToCamera : MonoBehaviour, IClientComponent
{
	public float maxDistance = 30f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public abstract class RustCamera<T> : SingletonComponent<T> where T : RustCamera<T>
{
	[SerializeField]
	private AmplifyOcclusionEffect ssao;

	[SerializeField]
	private SEScreenSpaceShadows contactShadows;

	[SerializeField]
	private VisualizeTexelDensity visualizeTexelDensity;

	[SerializeField]
	private EnvironmentVolumePropertiesCollection environmentVolumeProperties;

	[SerializeField]
	private PostProcessLayer post;

	[SerializeField]
	private PostProcessVolume baseEffectVolume;
}


using UnityEngine;

public class ScaleByIntensity : MonoBehaviour
{
	public Vector3 initialScale = Vector3.zero;

	public Light intensitySource;

	public float maxIntensity = 1f;

	private void Start()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		initialScale = ((Component)this).transform.localScale;
	}

	private void Update()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = (((Behaviour)intensitySource).enabled ? (initialScale * intensitySource.intensity / maxIntensity) : Vector3.zero);
	}
}


using UnityEngine;

public class ScaleBySpeed : MonoBehaviour, IClientComponent
{
	public float minScale = 0.001f;

	public float maxScale = 1f;

	public float minSpeed;

	public float maxSpeed = 1f;

	public MonoBehaviour component;

	public bool toggleComponent = true;

	public bool onlyWhenSubmerged;

	public float submergedThickness = 0.33f;

	private Vector3 prevPosition = Vector3.zero;
}


using System.Collections.Generic;

public class ScreenshotCamera : RustCamera<ScreenshotCamera>
{
	public static List<ScreenshotCamera> activeScreenshotCameras = new List<ScreenshotCamera>();
}


using Rust.UI;
using UnityEngine;

public class SearchFilterInput : MonoBehaviour
{
	public GameObject OpenRoot;

	public GameObject ClosedRoot;

	public RustInput InputField;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SkinnedMultiMesh : MonoBehaviour
{
	public struct Part
	{
		public Wearable wearable;

		public GameObject gameObject;

		public string name;

		public Item item;
	}

	public bool shadowOnly;

	internal bool IsVisible = true;

	public bool eyesView;

	public Skeleton skeleton;

	public SkeletonSkinLod skeletonSkinLod;

	public List<Part> parts = new List<Part>();

	[NonSerialized]
	public List<Part> createdParts = new List<Part>();

	[NonSerialized]
	public long lastBuildHash;

	[NonSerialized]
	public MaterialPropertyBlock sharedPropertyBlock;

	[NonSerialized]
	public MaterialPropertyBlock hairPropertyBlock;

	public float skinNumber;

	public float meshNumber;

	public float hairNumber;

	public int skinType;

	public SkinSetCollection SkinCollection;

	public List<Renderer> Renderers { get; } = new List<Renderer>(32);
}


using UnityEngine;

public struct Part
{
	public Wearable wearable;

	public GameObject gameObject;

	public string name;

	public Item item;
}


using UnityEngine;

public class StatusLightRenderer : MonoBehaviour, IClientComponent
{
	public Material offMaterial;

	public Material onMaterial;

	private MaterialPropertyBlock propertyBlock;

	private Renderer targetRenderer;

	private Color lightColor;

	private Light targetLight;

	private int colorID;

	private int emissionID;

	protected void Awake()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		propertyBlock = new MaterialPropertyBlock();
		targetRenderer = ((Component)this).GetComponent<Renderer>();
		targetLight = ((Component)this).GetComponent<Light>();
		colorID = Shader.PropertyToID("_Color");
		emissionID = Shader.PropertyToID("_EmissionColor");
	}

	public void SetOff()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)targetRenderer))
		{
			targetRenderer.sharedMaterial = offMaterial;
			targetRenderer.SetPropertyBlock((MaterialPropertyBlock)null);
		}
		if (Object.op_Implicit((Object)(object)targetLight))
		{
			targetLight.color = Color.clear;
		}
	}

	public void SetOn()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)targetRenderer))
		{
			targetRenderer.sharedMaterial = onMaterial;
			targetRenderer.SetPropertyBlock(propertyBlock);
		}
		if (Object.op_Implicit((Object)(object)targetLight))
		{
			targetLight.color = lightColor;
		}
	}

	public void SetRed()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		propertyBlock.Clear();
		propertyBlock.SetColor(colorID, GetColor(197, 46, 0, byte.MaxValue));
		propertyBlock.SetColor(emissionID, GetColor(191, 0, 2, byte.MaxValue, 2.916925f));
		lightColor = GetColor(byte.MaxValue, 111, 102, byte.MaxValue);
		SetOn();
	}

	public void SetGreen()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		propertyBlock.Clear();
		propertyBlock.SetColor(colorID, GetColor(19, 191, 13, byte.MaxValue));
		propertyBlock.SetColor(emissionID, GetColor(19, 191, 13, byte.MaxValue, 2.5f));
		lightColor = GetColor(156, byte.MaxValue, 102, byte.MaxValue);
		SetOn();
	}

	private Color GetColor(byte r, byte g, byte b, byte a)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return Color32.op_Implicit(new Color32(r, g, b, a));
	}

	private Color GetColor(byte r, byte g, byte b, byte a, float intensity)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return Color32.op_Implicit(new Color32(r, g, b, a)) * intensity;
	}
}


using ConVar;
using UnityEngine;

public class SunSettings : MonoBehaviour, IClientComponent
{
	private Light light;

	private void OnEnable()
	{
		light = ((Component)this).GetComponent<Light>();
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		LightShadows val = (LightShadows)Mathf.Clamp(Graphics.shadowmode, 1, 2);
		if (light.shadows != val)
		{
			light.shadows = val;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class TextureColorPicker : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IDragHandler
{
	[Serializable]
	public class onColorSelectedEvent : UnityEvent<Color>
	{
	}

	public Texture2D texture;

	public onColorSelectedEvent onColorSelected = new onColorSelectedEvent();

	public virtual void OnPointerDown(PointerEventData eventData)
	{
		OnDrag(eventData);
	}

	public virtual void OnDrag(PointerEventData eventData)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		Vector2 val2 = default(Vector2);
		if (RectTransformUtility.ScreenPointToLocalPointInRectangle(val, eventData.position, eventData.pressEventCamera, ref val2))
		{
			ref float x = ref val2.x;
			float num = x;
			Rect rect = val.rect;
			x = num + ((Rect)(ref rect)).width * val.pivot.x;
			ref float y = ref val2.y;
			float num2 = y;
			rect = val.rect;
			y = num2 + ((Rect)(ref rect)).height * val.pivot.y;
			ref float x2 = ref val2.x;
			float num3 = x2;
			rect = val.rect;
			x2 = num3 / ((Rect)(ref rect)).width;
			ref float y2 = ref val2.y;
			float num4 = y2;
			rect = val.rect;
			y2 = num4 / ((Rect)(ref rect)).height;
			Color pixel = texture.GetPixel((int)(val2.x * (float)((Texture)texture).width), (int)(val2.y * (float)((Texture)texture).height));
			((UnityEvent<Color>)onColorSelected).Invoke(pixel);
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Events;

[Serializable]
public class onColorSelectedEvent : UnityEvent<Color>
{
}


using UnityEngine;

public class TimedRemoval : MonoBehaviour
{
	public Object objectToDestroy;

	public float removeDelay = 1f;

	private void OnEnable()
	{
		Object.Destroy(objectToDestroy, removeDelay);
	}
}


using System;
using Facepunch;
using UnityEngine;

[Serializable]
public class TokenisedPhrase : Phrase
{
	public static readonly Phrase LeftMouse = new Phrase("button.mouse.left", "Left Mouse");

	public static readonly Phrase RightMouse = new Phrase("button.mouse.right", "Right Mouse");

	public static readonly Phrase MiddleMouse = new Phrase("button.mouse.middle", "Middle Mouse");

	public override string translated => ReplaceTokens(((Phrase)this).translated);

	public static string ReplaceTokens(string str)
	{
		if (!str.Contains("["))
		{
			return str;
		}
		str = str.Replace("[inventory.toggle]", string.Format("[{0}]", Input.GetButtonWithBind("inventory.toggle", false).ToUpper()));
		str = str.Replace("[inventory.togglecrafting]", string.Format("[{0}]", Input.GetButtonWithBind("inventory.togglecrafting", false).ToUpper()));
		str = str.Replace("[+map]", string.Format("[{0}]", Input.GetButtonWithBind("+map", false).ToUpper()));
		str = str.Replace("[inventory.examineheld]", string.Format("[{0}]", Input.GetButtonWithBind("inventory.examineheld", false).ToUpper()));
		str = str.Replace("[slot2]", string.Format("[{0}]", Input.GetButtonWithBind("+slot2", false).ToUpper()));
		str = str.Replace("[attack]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+attack", true)).ToUpper()));
		str = str.Replace("[attack2]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+attack2", false)).ToUpper()));
		str = str.Replace("[attack3]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+attack3", false)).ToUpper()));
		str = str.Replace("[+use]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+use", false)).ToUpper()));
		str = str.Replace("[+altlook]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+altlook", false)).ToUpper()));
		str = str.Replace("[+reload]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+reload", false)).ToUpper()));
		str = str.Replace("[+voice]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+voice", false)).ToUpper()));
		str = str.Replace("[+lockBreakHealthPercent]", $"{0.2f:0%}");
		str = str.Replace("[+gestures]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+gestures", false)).ToUpper()));
		str = str.Replace("[+left]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+left", false)).ToUpper()));
		str = str.Replace("[+right]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+right", false)).ToUpper()));
		str = str.Replace("[+backward]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+backward", false)).ToUpper()));
		str = str.Replace("[+forward]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+forward", false)).ToUpper()));
		str = str.Replace("[+sprint]", string.Format("[{0}]", Input.GetButtonWithBind("+sprint", false)).ToUpper());
		str = str.Replace("[+duck]", string.Format("[{0}]", Input.GetButtonWithBind("+duck", false)).ToUpper());
		str = str.Replace("[+pets]", string.Format("[{0}]", Input.GetButtonWithBind("+pets", false)).ToUpper());
		str = str.Replace("[lighttoggle]", string.Format("[{0}]", Input.GetButtonWithBind("lighttoggle", false)).ToUpper());
		str = str.Replace("[+ping]", string.Format("[{0}]", Input.GetButtonWithBind("+ping", false)).ToUpper());
		str = str.Replace("[clan.toggleclan]", string.Format("[{0}]", Input.GetButtonWithBind("clan.toggleclan", false)).ToUpper());
		str = str.Replace("[+jump]", string.Format("[{0}]", Input.GetButtonWithBind("+jump", false)).ToUpper());
		str = str.Replace("[movement]", ("[" + TranslateMouseButton(Input.GetButtonWithBind("+forward", false)) + TranslateMouseButton(Input.GetButtonWithBind("+left", false)) + TranslateMouseButton(Input.GetButtonWithBind("+backward", false)) + TranslateMouseButton(Input.GetButtonWithBind("+right", false)) + "]").ToUpper());
		str = str.Replace("[+help]", string.Format("[{0}]", Input.GetButtonWithBind("+opentutorialhelp", false)).ToUpper());
		str = str.Replace("[chat.open]", string.Format("[{0}]", Input.GetButtonWithBind("chat.open", false)).ToUpper());
		return str;
	}

	public TokenisedPhrase(string t = "", string eng = "")
		: base(t, eng)
	{
	}

	public static string TranslateMouseButton(string mouseButton)
	{
		return mouseButton switch
		{
			"mouse0" => LeftMouse.translated, 
			"mouse1" => RightMouse.translated, 
			"mouse2" => MiddleMouse.translated, 
			_ => mouseButton, 
		};
	}

	private static string GetButtonWithBind(string s)
	{
		if (!Application.isPlaying)
		{
			switch (s)
			{
			case "inventory.toggle":
				return "tab";
			case "inventory.togglecrafting":
				return "q";
			case "+map":
				return "g";
			case "inventory.examineheld":
				return "n";
			case "+slot2":
				return "2";
			case "+attack":
				return "mouse0";
			case "+attack2":
				return "mouse1";
			case "+use":
				return "e";
			case "+altlook":
				return "leftalt";
			case "+reload":
				return "r";
			case "+voice":
				return "v";
			}
		}
		return Input.GetButtonWithBind(s, false);
	}
}


using UnityEngine;

public class TriggerMovement : TriggerBase, IClientComponent
{
	[Tooltip("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
	public Transform losEyes;

	public BaseEntity.MovementModify movementModify;
}


using UnityEngine;

public class TriggerVehicleDrag : TriggerBase, IServerComponent
{
	[Tooltip("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
	public Transform losEyes;

	public float vehicleDrag;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if ((Object)(object)losEyes != (Object)null)
		{
			if (entityContents != null && entityContents.Contains(baseEntity))
			{
				return ((Component)baseEntity).gameObject;
			}
			if (!baseEntity.IsVisible(((Component)losEyes).transform.position, baseEntity.CenterPoint()))
			{
				return null;
			}
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UnderwearIcon : MonoBehaviour, IClientComponent
{
	public Image icon;
}


using System;
using UnityEngine;

public class UnderwearSkinPicker : MonoBehaviour
{
	public GameObjectRef pickerIcon;

	public GameObject container;

	public Action skinChangedEvent;

	public Sprite defaultNudeIcon;

	public Sprite defaultIconMale;

	public Sprite defaultIconFemale;
}


using UnityEngine;

public class UnparentOnDestroy : MonoBehaviour, IOnParentDestroying
{
	public float destroyAfterSeconds = 1f;

	public void OnParentDestroying()
	{
		((Component)this).transform.parent = null;
		GameManager.Destroy(((Component)this).gameObject, (destroyAfterSeconds <= 0f) ? 1f : destroyAfterSeconds);
	}

	protected void OnValidate()
	{
		if (destroyAfterSeconds <= 0f)
		{
			destroyAfterSeconds = 1f;
		}
	}
}


using UnityEngine;

public class ViewModel : MonoBehaviour, IClientComponent
{
	public GameObjectRef viewModelPrefab;
}


using UnityEngine;

public class ViewmodelItem : MonoBehaviour
{
}


using System.Collections.Generic;
using UnityEngine;

public class ViewShake
{
	protected class ShakeParameters
	{
		public float endTime;

		public float duration;

		public float amplitude;

		public float frequency;

		public float nextShake;

		public float angle;

		public Vector3 offset;

		public bool infinite;
	}

	protected List<ShakeParameters> Entries = new List<ShakeParameters>();

	public Vector3 PositionOffset { get; protected set; }

	public Vector3 AnglesOffset { get; protected set; }

	public void AddShake(float amplitude, float frequency, float duration)
	{
		Entries.Add(new ShakeParameters
		{
			amplitude = amplitude,
			frequency = Mathf.Max(frequency, 0.01f),
			duration = duration,
			endTime = Time.time + duration,
			nextShake = 0f,
			angle = 0f,
			infinite = (duration <= 0f)
		});
	}

	public void Update()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		Vector3 zero = Vector3.zero;
		Entries.RemoveAll((ShakeParameters i) => !i.infinite && Time.time > i.endTime);
		foreach (ShakeParameters entry in Entries)
		{
			if (Time.time > entry.nextShake)
			{
				entry.nextShake = Time.time + 1f / entry.frequency;
				entry.offset = new Vector3(Random.Range(0f - entry.amplitude, entry.amplitude), Random.Range(0f - entry.amplitude, entry.amplitude), Random.Range(0f - entry.amplitude, entry.amplitude));
				entry.angle = Random.Range((0f - entry.amplitude) * 0.25f, entry.amplitude * 0.25f);
			}
			float num = 0f;
			float num2 = (entry.infinite ? 1f : ((entry.endTime - Time.time) / entry.duration));
			if (num2 != 0f)
			{
				num = entry.frequency / num2;
			}
			num2 *= num2;
			float num3 = Time.time * num;
			num2 *= Mathf.Sin(num3);
			val += entry.offset * num2;
			zero.z += entry.angle * num2;
			if (!entry.infinite)
			{
				entry.amplitude -= entry.amplitude * Time.deltaTime / (entry.duration * entry.frequency);
			}
		}
		PositionOffset = val * 0.01f;
		AnglesOffset = zero;
	}

	public void Stop()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Entries.Clear();
		PositionOffset = Vector3.zero;
		AnglesOffset = Vector3.zero;
	}
}


using UnityEngine;

protected class ShakeParameters
{
	public float endTime;

	public float duration;

	public float amplitude;

	public float frequency;

	public float nextShake;

	public float angle;

	public Vector3 offset;

	public bool infinite;
}


using UnityEngine;

[RequireComponent(typeof(Wearable))]
public class WearableHairCap : MonoBehaviour
{
	public HairType Type;

	[ColorUsage(false, true)]
	public Color BaseColor = Color.black;

	public Texture Mask;

	private static MaterialPropertyBlock block;

	private static int _HairBaseColorUV1 = Shader.PropertyToID("_HairBaseColorUV1");

	private static int _HairBaseColorUV2 = Shader.PropertyToID("_HairBaseColorUV2");

	private static int _HairPackedMapUV1 = Shader.PropertyToID("_HairPackedMapUV1");

	private static int _HairPackedMapUV2 = Shader.PropertyToID("_HairPackedMapUV2");

	public void ApplyHairCap(MaterialPropertyBlock block)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		if (Type == HairType.Head || Type == HairType.Armpit || Type == HairType.Pubic)
		{
			Texture texture = block.GetTexture(_HairPackedMapUV1);
			block.SetColor(_HairBaseColorUV1, ((Color)(ref BaseColor)).gamma);
			block.SetTexture(_HairPackedMapUV1, ((Object)(object)Mask != (Object)null) ? Mask : texture);
		}
		else if (Type == HairType.Facial)
		{
			Texture texture2 = block.GetTexture(_HairPackedMapUV2);
			block.SetColor(_HairBaseColorUV2, ((Color)(ref BaseColor)).gamma);
			block.SetTexture(_HairPackedMapUV2, ((Object)(object)Mask != (Object)null) ? Mask : texture2);
		}
	}
}


using UnityEngine;

public class BaseCollision : MonoBehaviour, IClientComponent
{
	public BaseEntity Owner;

	public Model model;
}


using System;
using UnityEngine;

[Obsolete]
public class ColliderBatch : MonoBehaviour, IEditorComponent
{
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using GamePhysicsJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using UnityEngine;
using UtilityJobs;

public static class GamePhysics
{
	public enum Realm
	{
		Client,
		Server
	}

	[Flags]
	public enum MasksToValidate : byte
	{
		None = 0,
		Terrain = 1,
		Water = 2,
		All = 3
	}

	public const int BufferLength = 32768;

	private static RaycastHit[] hitBuffer = (RaycastHit[])(object)new RaycastHit[32768];

	private static RaycastHit[] hitBufferB = (RaycastHit[])(object)new RaycastHit[32768];

	private static Collider[] colBuffer = (Collider[])(object)new Collider[32768];

	public const int DefaultMaxResultsPerQuery = 16;

	public static bool CheckSphere(Vector3 position, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position, layerMask);
		return Physics.CheckSphere(position, radius, layerMask, triggerInteraction);
	}

	public static void CheckSpheres(ReadOnly<Vector3> pos, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<bool> results, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckSpheres", 0);
		try
		{
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(pos.Length, (Allocator)3, (NativeArrayOptions)0);
			OverlapSpheres(pos, radii, layerMasks, hits, 1, triggerInteraction, validate);
			CheckHitsJob checkHitsJob = default(CheckHitsJob);
			checkHitsJob.Results = results;
			checkHitsJob.Hits = hits.AsReadOnly();
			CheckHitsJob checkHitsJob2 = checkHitsJob;
			IJobExtensions.RunByRef<CheckHitsJob>(ref checkHitsJob2);
			hits.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision((start + end) * 0.5f, layerMask);
		return Physics.CheckCapsule(start, end, radius, layerMask, triggerInteraction);
	}

	public static void CheckCapsules(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<bool> results, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All, bool mitigateSpheres = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckCapsules", 0);
		try
		{
			ReadOnly<int> layerMasks2 = layerMasks;
			NativeArray<int> array = default(NativeArray<int>);
			if (validate != 0)
			{
				array = new NativeArray<int>(layerMasks.Length, (Allocator)3, (NativeArrayOptions)0);
				layerMasks.CopyTo(array);
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(starts.Length, (Allocator)3, (NativeArrayOptions)0);
				CalcMidpoingJob calcMidpoingJob = default(CalcMidpoingJob);
				calcMidpoingJob.Results = results2;
				calcMidpoingJob.From = starts;
				calcMidpoingJob.To = ends;
				CalcMidpoingJob calcMidpoingJob2 = calcMidpoingJob;
				IJobExtensions.RunByRef<CalcMidpoingJob>(ref calcMidpoingJob2);
				HandleIgnoreCollision(results2.AsReadOnly(), array, validate);
				results2.Dispose();
				layerMasks2 = array.AsReadOnly();
			}
			NativeArray<OverlapCapsuleCommand> val2 = new NativeArray<OverlapCapsuleCommand>(starts.Length, (Allocator)3, (NativeArrayOptions)0);
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob = default(GenerateOverlapCapsuleCommandsJob);
			generateOverlapCapsuleCommandsJob.CapsuleCommands = val2;
			generateOverlapCapsuleCommandsJob.From = starts;
			generateOverlapCapsuleCommandsJob.To = ends;
			generateOverlapCapsuleCommandsJob.Radiii = radii;
			generateOverlapCapsuleCommandsJob.LayerMasks = layerMasks2;
			generateOverlapCapsuleCommandsJob.TriggerInteraction = triggerInteraction;
			generateOverlapCapsuleCommandsJob.HitBackfaces = false;
			generateOverlapCapsuleCommandsJob.HitMultipleFaces = false;
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob2 = generateOverlapCapsuleCommandsJob;
			IJobExtensions.RunByRef<GenerateOverlapCapsuleCommandsJob>(ref generateOverlapCapsuleCommandsJob2);
			NativeArrayEx.SafeDispose(ref array);
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(starts.Length, (Allocator)3, (NativeArrayOptions)0);
			if (mitigateSpheres)
			{
				MitigateSphereCapsuleCommands(val2, hits, 1);
			}
			else
			{
				ExecuteOverlapCapsuleCommands(val2, hits, 1);
			}
			val2.Dispose();
			CheckHitsJob checkHitsJob = default(CheckHitsJob);
			checkHitsJob.Results = results;
			checkHitsJob.Hits = hits.AsReadOnly();
			CheckHitsJob checkHitsJob2 = checkHitsJob;
			IJobExtensions.RunByRef<CheckHitsJob>(ref checkHitsJob2);
			hits.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool CheckOBB(OBB obb, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		return Physics.CheckBox(obb.position, obb.extents, obb.rotation, layerMask, triggerInteraction);
	}

	public static bool CheckOBBAndEntity(OBB obb, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		int num = Physics.OverlapBoxNonAlloc(obb.position, obb.extents, colBuffer, obb.rotation, layerMask, triggerInteraction);
		for (int i = 0; i < num; i++)
		{
			BaseEntity baseEntity = colBuffer[i].ToBaseEntity();
			if (!((Object)(object)baseEntity != (Object)null) || !((Object)(object)ignoreEntity != (Object)null) || (baseEntity.isServer == ignoreEntity.isServer && !((Object)(object)baseEntity == (Object)(object)ignoreEntity)))
			{
				return true;
			}
		}
		return false;
	}

	public static bool CheckBounds(Bounds bounds, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(((Bounds)(ref bounds)).center, layerMask);
		return Physics.CheckBox(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).extents, Quaternion.identity, layerMask, triggerInteraction);
	}

	public static bool CheckInsideNonConvexMesh(Vector3 point, int layerMask = -5)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		bool queriesHitBackfaces = Physics.queriesHitBackfaces;
		Physics.queriesHitBackfaces = true;
		int num = Physics.RaycastNonAlloc(point, Vector3.up, hitBuffer, 100f, layerMask);
		int num2 = Physics.RaycastNonAlloc(point, -Vector3.up, hitBufferB, 100f, layerMask);
		if (num >= hitBuffer.Length)
		{
			Debug.LogWarning((object)"CheckInsideNonConvexMesh query is exceeding hitBuffer length.");
			return false;
		}
		if (num2 > hitBufferB.Length)
		{
			Debug.LogWarning((object)"CheckInsideNonConvexMesh query is exceeding hitBufferB length.");
			return false;
		}
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num2; j++)
			{
				if ((Object)(object)((RaycastHit)(ref hitBuffer[i])).collider == (Object)(object)((RaycastHit)(ref hitBufferB[j])).collider)
				{
					Physics.queriesHitBackfaces = queriesHitBackfaces;
					return true;
				}
			}
		}
		Physics.queriesHitBackfaces = queriesHitBackfaces;
		return false;
	}

	public static bool CheckInsideAnyCollider(Vector3 point, int layerMask = -5)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (Physics.CheckSphere(point, 0f, layerMask))
		{
			return true;
		}
		if (CheckInsideNonConvexMesh(point, layerMask))
		{
			return true;
		}
		if ((Object)(object)TerrainMeta.HeightMap != (Object)null && TerrainMeta.HeightMap.GetHeight(point) > point.y)
		{
			return true;
		}
		return false;
	}

	public static void OverlapSphere(Vector3 position, float radius, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position, layerMask);
		int count = Physics.OverlapSphereNonAlloc(position, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapSpheres(ReadOnly<Vector3> positions, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<ColliderHit> hits, int maxResPerCast, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.OverlapSpheres", 0);
		try
		{
			ReadOnly<int> layerMasks2 = layerMasks;
			NativeArray<int> array = default(NativeArray<int>);
			if (validate != 0)
			{
				array = new NativeArray<int>(layerMasks.Length, (Allocator)3, (NativeArrayOptions)0);
				layerMasks.CopyTo(array);
				HandleIgnoreCollision(positions, array, validate);
				layerMasks2 = array.AsReadOnly();
			}
			NativeArray<OverlapSphereCommand> val2 = new NativeArray<OverlapSphereCommand>(positions.Length, (Allocator)3, (NativeArrayOptions)0);
			GenerateOverlapSphereCommandsJob generateOverlapSphereCommandsJob = default(GenerateOverlapSphereCommandsJob);
			generateOverlapSphereCommandsJob.SphereCommands = val2;
			generateOverlapSphereCommandsJob.Pos = positions;
			generateOverlapSphereCommandsJob.Radiii = radii;
			generateOverlapSphereCommandsJob.LayerMasks = layerMasks2;
			generateOverlapSphereCommandsJob.TriggerInteraction = triggerInteraction;
			generateOverlapSphereCommandsJob.HitBackfaces = false;
			generateOverlapSphereCommandsJob.HitMultipleFaces = false;
			GenerateOverlapSphereCommandsJob generateOverlapSphereCommandsJob2 = generateOverlapSphereCommandsJob;
			IJobExtensions.RunByRef<GenerateOverlapSphereCommandsJob>(ref generateOverlapSphereCommandsJob2);
			NativeArrayEx.SafeDispose(ref array);
			ExecuteOverlapSphereCommands(val2, hits, maxResPerCast);
			val2.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void ExecuteOverlapSphereCommands(NativeArray<OverlapSphereCommand> commands, NativeArray<ColliderHit> hits, int maxResPerCast)
	{
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		if (Debug.isDebugBuild)
		{
			NativeList<int> invalidIndices = default(NativeList<int>);
			invalidIndices..ctor(commands.Length, AllocatorHandle.op_Implicit((Allocator)3));
			ValidateOverlapSphereCommandsJob validateOverlapSphereCommandsJob = default(ValidateOverlapSphereCommandsJob);
			validateOverlapSphereCommandsJob.InvalidIndices = invalidIndices;
			validateOverlapSphereCommandsJob.Commands = commands.AsReadOnly();
			ValidateOverlapSphereCommandsJob validateOverlapSphereCommandsJob2 = validateOverlapSphereCommandsJob;
			IJobExtensions.RunByRef<ValidateOverlapSphereCommandsJob>(ref validateOverlapSphereCommandsJob2);
			if (!invalidIndices.IsEmpty)
			{
				int num = invalidIndices[0];
				OverlapSphereCommand val = commands[num];
				Debug.LogError((object)string.Concat(string.Concat(string.Concat($"OverlapSpheres has {invalidIndices.Length} invalid sphere commands!" + $"\nFirst one was at index {num}:", $"\n\tPos: {((OverlapSphereCommand)(ref val)).point}"), $"\n\tRadius: {((OverlapSphereCommand)(ref val)).radius}"), "\nThese queries will be skipped!"));
			}
			invalidIndices.Dispose();
		}
		int batchSize = GetBatchSize(commands.Length);
		JobHandle val2 = OverlapSphereCommand.ScheduleBatch(commands, hits, batchSize, maxResPerCast, default(JobHandle));
		((JobHandle)(ref val2)).Complete();
	}

	public static void CapsuleSweep(Vector3 position0, Vector3 position1, float radius, Vector3 direction, float distance, List<RaycastHit> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position0, layerMask);
		layerMask = HandleIgnoreCollision(position1, layerMask);
		HitBufferToList(Physics.CapsuleCastNonAlloc(position0, position1, radius, direction, hitBuffer, distance, layerMask, triggerInteraction), list);
	}

	public static void OverlapCapsule(Vector3 point0, Vector3 point1, float radius, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(point0, layerMask);
		layerMask = HandleIgnoreCollision(point1, layerMask);
		int count = Physics.OverlapCapsuleNonAlloc(point0, point1, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapCapsules(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<ColliderHit> hits, int maxResPerCast, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All, bool mitigateSpheres = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.OverlapCapsules", 0);
		try
		{
			ReadOnly<int> layerMasks2 = layerMasks;
			NativeArray<int> array = default(NativeArray<int>);
			if (validate != 0)
			{
				array = new NativeArray<int>(layerMasks.Length, (Allocator)3, (NativeArrayOptions)0);
				layerMasks.CopyTo(array);
				HandleIgnoreCollision(starts, array, validate);
				HandleIgnoreCollision(ends, array, validate);
				layerMasks2 = array.AsReadOnly();
			}
			NativeArray<OverlapCapsuleCommand> val2 = new NativeArray<OverlapCapsuleCommand>(starts.Length, (Allocator)3, (NativeArrayOptions)0);
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob = default(GenerateOverlapCapsuleCommandsJob);
			generateOverlapCapsuleCommandsJob.CapsuleCommands = val2;
			generateOverlapCapsuleCommandsJob.From = starts;
			generateOverlapCapsuleCommandsJob.To = ends;
			generateOverlapCapsuleCommandsJob.Radiii = radii;
			generateOverlapCapsuleCommandsJob.LayerMasks = layerMasks2;
			generateOverlapCapsuleCommandsJob.TriggerInteraction = triggerInteraction;
			generateOverlapCapsuleCommandsJob.HitBackfaces = false;
			generateOverlapCapsuleCommandsJob.HitMultipleFaces = false;
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob2 = generateOverlapCapsuleCommandsJob;
			IJobExtensions.RunByRef<GenerateOverlapCapsuleCommandsJob>(ref generateOverlapCapsuleCommandsJob2);
			NativeArrayEx.SafeDispose(ref array);
			if (mitigateSpheres)
			{
				MitigateSphereCapsuleCommands(val2, hits, maxResPerCast);
			}
			else
			{
				ExecuteOverlapCapsuleCommands(val2, hits, maxResPerCast);
			}
			val2.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void MitigateSphereCapsuleCommands(NativeArray<OverlapCapsuleCommand> commands, NativeArray<ColliderHit> hits, int maxResPerCast)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		NativeList<int> val = default(NativeList<int>);
		val..ctor(commands.Length, AllocatorHandle.op_Implicit((Allocator)3));
		FindSphereCmdsInCapsuleCmdsJob findSphereCmdsInCapsuleCmdsJob = default(FindSphereCmdsInCapsuleCmdsJob);
		findSphereCmdsInCapsuleCmdsJob.SphereIndices = val;
		findSphereCmdsInCapsuleCmdsJob.Commands = commands.AsReadOnly();
		FindSphereCmdsInCapsuleCmdsJob findSphereCmdsInCapsuleCmdsJob2 = findSphereCmdsInCapsuleCmdsJob;
		IJobExtensions.RunByRef<FindSphereCmdsInCapsuleCmdsJob>(ref findSphereCmdsInCapsuleCmdsJob2);
		if (val.IsEmpty)
		{
			val.Dispose();
			ExecuteOverlapCapsuleCommands(commands, hits, maxResPerCast);
			return;
		}
		int num = Math.Max(val.Length, commands.Length - val.Length);
		NativeArray<ColliderHit> hits2 = default(NativeArray<ColliderHit>);
		hits2..ctor(num * maxResPerCast, (Allocator)3, (NativeArrayOptions)0);
		NativeList<OverlapSphereCommand> sphereCommands = default(NativeList<OverlapSphereCommand>);
		sphereCommands..ctor(val.Length, AllocatorHandle.op_Implicit((Allocator)3));
		GenerateSphereCmdsFromCapsuleCmdsJob generateSphereCmdsFromCapsuleCmdsJob = default(GenerateSphereCmdsFromCapsuleCmdsJob);
		generateSphereCmdsFromCapsuleCmdsJob.SphereCommands = sphereCommands;
		generateSphereCmdsFromCapsuleCmdsJob.Commands = commands.AsReadOnly();
		generateSphereCmdsFromCapsuleCmdsJob.Indices = val.AsReadOnly();
		GenerateSphereCmdsFromCapsuleCmdsJob generateSphereCmdsFromCapsuleCmdsJob2 = generateSphereCmdsFromCapsuleCmdsJob;
		IJobExtensions.RunByRef<GenerateSphereCmdsFromCapsuleCmdsJob>(ref generateSphereCmdsFromCapsuleCmdsJob2);
		ExecuteOverlapSphereCommands(sphereCommands.AsArray(), hits2, maxResPerCast);
		ScatterColliderHitsJob scatterColliderHitsJob = default(ScatterColliderHitsJob);
		scatterColliderHitsJob.To = hits;
		scatterColliderHitsJob.From = hits2.AsReadOnly();
		scatterColliderHitsJob.Indices = val.AsReadOnly();
		scatterColliderHitsJob.MaxHitsPerRay = maxResPerCast;
		ScatterColliderHitsJob scatterColliderHitsJob2 = scatterColliderHitsJob;
		IJobExtensions.RunByRef<ScatterColliderHitsJob>(ref scatterColliderHitsJob2);
		sphereCommands.Dispose();
		if (val.Length != commands.Length)
		{
			NativeArray<bool> workBuffer = default(NativeArray<bool>);
			workBuffer..ctor(commands.Length, (Allocator)3, (NativeArrayOptions)0);
			InvertIndexListJob invertIndexListJob = default(InvertIndexListJob);
			invertIndexListJob.Indices = val;
			invertIndexListJob.WorkBuffer = workBuffer;
			InvertIndexListJob invertIndexListJob2 = invertIndexListJob;
			IJobExtensions.RunByRef<InvertIndexListJob>(ref invertIndexListJob2);
			workBuffer.Dispose();
			NativeArray<OverlapCapsuleCommand> val2 = default(NativeArray<OverlapCapsuleCommand>);
			val2..ctor(val.Length, (Allocator)3, (NativeArrayOptions)0);
			GatherJob<OverlapCapsuleCommand> gatherJob = default(GatherJob<OverlapCapsuleCommand>);
			gatherJob.Results = val2;
			gatherJob.Source = commands.AsReadOnly();
			gatherJob.Indices = val.AsReadOnly();
			GatherJob<OverlapCapsuleCommand> gatherJob2 = gatherJob;
			IJobExtensions.RunByRef<GatherJob<OverlapCapsuleCommand>>(ref gatherJob2);
			ExecuteOverlapCapsuleCommands(val2, hits2, maxResPerCast);
			scatterColliderHitsJob = default(ScatterColliderHitsJob);
			scatterColliderHitsJob.To = hits;
			scatterColliderHitsJob.From = hits2.AsReadOnly();
			scatterColliderHitsJob.Indices = val.AsReadOnly();
			scatterColliderHitsJob.MaxHitsPerRay = maxResPerCast;
			ScatterColliderHitsJob scatterColliderHitsJob3 = scatterColliderHitsJob;
			IJobExtensions.RunByRef<ScatterColliderHitsJob>(ref scatterColliderHitsJob3);
			val2.Dispose();
		}
		hits2.Dispose();
		val.Dispose();
	}

	private static void ExecuteOverlapCapsuleCommands(NativeArray<OverlapCapsuleCommand> commands, NativeArray<ColliderHit> hits, int maxResPerCast)
	{
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (Debug.isDebugBuild)
		{
			NativeList<int> invalidIndices = default(NativeList<int>);
			invalidIndices..ctor(commands.Length, AllocatorHandle.op_Implicit((Allocator)3));
			ValidateOverlapCapsuleCommandsJob validateOverlapCapsuleCommandsJob = default(ValidateOverlapCapsuleCommandsJob);
			validateOverlapCapsuleCommandsJob.InvalidIndices = invalidIndices;
			validateOverlapCapsuleCommandsJob.Commands = commands.AsReadOnly();
			ValidateOverlapCapsuleCommandsJob validateOverlapCapsuleCommandsJob2 = validateOverlapCapsuleCommandsJob;
			IJobExtensions.RunByRef<ValidateOverlapCapsuleCommandsJob>(ref validateOverlapCapsuleCommandsJob2);
			if (!invalidIndices.IsEmpty)
			{
				int num = invalidIndices[0];
				OverlapCapsuleCommand val = commands[num];
				Debug.LogError((object)string.Concat(string.Concat(string.Concat(string.Concat($"OverlapCapsules has {invalidIndices.Length} invalid sphere commands!" + $"\nFirst one was at index {num}:", $"\n\tPoint0: {((OverlapCapsuleCommand)(ref val)).point0}"), $"\n\tPoint1: {((OverlapCapsuleCommand)(ref val)).point1}"), $"\n\tRadius: {((OverlapCapsuleCommand)(ref val)).radius}"), "\nThese queries will be skipped!"));
			}
			invalidIndices.Dispose();
		}
		int batchSize = GetBatchSize(commands.Length);
		JobHandle val2 = OverlapCapsuleCommand.ScheduleBatch(commands, hits, batchSize, maxResPerCast, default(JobHandle));
		((JobHandle)(ref val2)).Complete();
	}

	public static void OverlapOBB(OBB obb, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		int count = Physics.OverlapBoxNonAlloc(obb.position, obb.extents, colBuffer, obb.rotation, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapBounds(Bounds bounds, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(((Bounds)(ref bounds)).center, layerMask);
		int count = Physics.OverlapBoxNonAlloc(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).extents, colBuffer, Quaternion.identity, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	private static void BufferToList(Collider[] buffer, int count, List<Collider> list)
	{
		for (int i = 0; i < count; i++)
		{
			list.Add(buffer[i]);
			buffer[i] = null;
		}
	}

	public static bool CheckSphere<T>(Vector3 pos, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapSphere(pos, radius, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static void CheckSpheres<T>(ReadOnly<Vector3> positions, ReadOnly<float> radii, ReadOnly<int> layerMasks, Span<bool> results, QueryTriggerInteraction triggerInteraction = 1, int maxResPerCast = 16, MasksToValidate validate = MasksToValidate.All) where T : Component
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckSpheres<T>", 0);
		try
		{
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(positions.Length * maxResPerCast, (Allocator)3, (NativeArrayOptions)0);
			OverlapSpheres(positions, radii, layerMasks, hits, maxResPerCast, triggerInteraction, validate);
			TimeWarning val2 = TimeWarning.New("FindComponent", 0);
			try
			{
				T val4 = default(T);
				for (int i = 0; i < positions.Length; i++)
				{
					bool flag = false;
					int num = i * maxResPerCast;
					for (int j = 0; j < maxResPerCast; j++)
					{
						ColliderHit val3 = hits[num + j];
						if (((ColliderHit)(ref val3)).instanceID == 0)
						{
							break;
						}
						if (((Component)((ColliderHit)(ref val3)).collider).TryGetComponent<T>(ref val4))
						{
							flag = true;
							break;
						}
					}
					results[i] = flag;
				}
				hits.Dispose();
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool CheckCapsule<T>(Vector3 start, Vector3 end, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapCapsule(start, end, radius, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckOBB<T>(OBB obb, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapOBB(obb, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckBounds<T>(Bounds bounds, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapBounds(bounds, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private static bool CheckComponent<T>(List<Collider> list)
	{
		T val = default(T);
		for (int i = 0; i < list.Count; i++)
		{
			if (((Component)list[i]).gameObject.TryGetComponent<T>(ref val))
			{
				return true;
			}
		}
		return false;
	}

	public static void OverlapSphere<T>(Vector3 position, float radius, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position, layerMask);
		int count = Physics.OverlapSphereNonAlloc(position, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void CheckCapsules<T>(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> layerMasks, Span<bool> results, QueryTriggerInteraction triggerInteraction = 1, int maxResPerCast = 16, MasksToValidate validate = MasksToValidate.All, bool mitigateSpheres = true) where T : Component
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckCapsules<T>", 0);
		try
		{
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(starts.Length * maxResPerCast, (Allocator)3, (NativeArrayOptions)0);
			OverlapCapsules(starts, ends, radii, layerMasks, hits, maxResPerCast, triggerInteraction, validate, mitigateSpheres);
			TimeWarning val2 = TimeWarning.New("FindComponent", 0);
			try
			{
				T val4 = default(T);
				for (int i = 0; i < starts.Length; i++)
				{
					bool flag = false;
					int num = i * maxResPerCast;
					for (int j = 0; j < maxResPerCast; j++)
					{
						ColliderHit val3 = hits[num + j];
						if (((ColliderHit)(ref val3)).instanceID == 0)
						{
							break;
						}
						if (((Component)((ColliderHit)(ref val3)).collider).TryGetComponent<T>(ref val4))
						{
							flag = true;
							break;
						}
					}
					results[i] = flag;
				}
				hits.Dispose();
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void OverlapCapsule<T>(Vector3 point0, Vector3 point1, float radius, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(point0, layerMask);
		layerMask = HandleIgnoreCollision(point1, layerMask);
		int count = Physics.OverlapCapsuleNonAlloc(point0, point1, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapOBB<T>(OBB obb, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		int count = Physics.OverlapBoxNonAlloc(obb.position, obb.extents, colBuffer, obb.rotation, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapBounds<T>(Bounds bounds, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(((Bounds)(ref bounds)).center, layerMask);
		int count = Physics.OverlapBoxNonAlloc(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).extents, colBuffer, Quaternion.identity, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	private static void BufferToList<T>(Collider[] buffer, int count, List<T> list) where T : Component
	{
		T item = default(T);
		for (int i = 0; i < count; i++)
		{
			if (((Component)buffer[i]).TryGetComponent<T>(ref item))
			{
				list.Add(item);
			}
			buffer[i] = null;
		}
	}

	private static void HitBufferToList(int count, List<RaycastHit> list)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (count >= hitBuffer.Length)
		{
			Debug.LogWarning((object)"Physics query is exceeding collider buffer length.");
		}
		for (int i = 0; i < count; i++)
		{
			list.Add(hitBuffer[i]);
		}
	}

	public static bool TraceRealm(Realm realm, Ray ray, float radius, out RaycastHit hitInfo, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (Trace(ray, radius, out var hitInfo2, maxDistance, layerMask, triggerInteraction, ignoreEntity))
		{
			hitInfo = hitInfo2;
			return true;
		}
		hitInfo = default(RaycastHit);
		return false;
	}

	public static BaseNetworkable TraceRealmEntity(Realm realm, Ray ray, float radius = 0f, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!Trace(ray, radius, out var hitInfo, maxDistance, layerMask, triggerInteraction, ignoreEntity))
		{
			return null;
		}
		return hitInfo.GetEntity();
	}

	public static bool Trace(Ray ray, float radius, out RaycastHit hitInfo, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		TraceAllUnordered(ray, radius, list, maxDistance, layerMask, triggerInteraction, ignoreEntity);
		if (list.Count == 0)
		{
			hitInfo = default(RaycastHit);
			Pool.FreeUnmanaged<RaycastHit>(ref list);
			return false;
		}
		Sort(list);
		hitInfo = list[0];
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return true;
	}

	public static void TraceAll(Ray ray, float radius, List<RaycastHit> hits, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		TraceAllUnordered(ray, radius, hits, maxDistance, layerMask, triggerInteraction, ignoreEntity);
		Sort(hits);
	}

	public static void TraceAllUnordered(Ray ray, float radius, List<RaycastHit> hits, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		int num = ((radius != 0f) ? Physics.SphereCastNonAlloc(ray, radius, hitBuffer, maxDistance, layerMask, triggerInteraction) : Physics.RaycastNonAlloc(ray, hitBuffer, maxDistance, layerMask, triggerInteraction));
		if (num < hitBuffer.Length && (layerMask & 0x10) != 0 && WaterSystem.Trace(ray, out var position, out var normal, maxDistance))
		{
			RaycastHit val = default(RaycastHit);
			((RaycastHit)(ref val)).point = position;
			((RaycastHit)(ref val)).normal = normal;
			Vector3 val2 = position - ((Ray)(ref ray)).origin;
			((RaycastHit)(ref val)).distance = ((Vector3)(ref val2)).magnitude;
			RaycastHit val3 = val;
			hitBuffer[num++] = val3;
		}
		if (num == 0)
		{
			return;
		}
		if (num >= hitBuffer.Length)
		{
			Debug.LogWarning((object)"Physics query is exceeding hit buffer length.");
		}
		for (int i = 0; i < num; i++)
		{
			RaycastHit val4 = hitBuffer[i];
			if (Verify(val4, ((Ray)(ref ray)).origin, ignoreEntity))
			{
				hits.Add(val4);
			}
		}
	}

	public static void TraceRaysUnordered(NativeArray<RaycastCommand> rays, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.TraceRaysUnordered", 0);
		try
		{
			int batchSize = GetBatchSize(rays.Length);
			JobHandle inputDeps = RaycastCommand.ScheduleBatch(rays, hits, batchSize, maxHitsPerTrace, default(JobHandle));
			if (traceWater)
			{
				inputDeps = TraceWaterRaysDeferred(hits, rays, maxHitsPerTrace, inputDeps);
			}
			((JobHandle)(ref inputDeps)).Complete();
			VerifyRays(hits, rays, maxHitsPerTrace);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static JobHandle TraceWaterRaysDeferred(NativeArray<RaycastHit> hits, NativeArray<RaycastCommand> rays, int maxHitsPerTrace, JobHandle inputDeps)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ScheduleTraceWaterRaysDeferred", 0);
		try
		{
			if (!rays.IsCreated || rays.Length == 0)
			{
				return inputDeps;
			}
			NativeList<Vector2i> waterIndices = new NativeList<Vector2i>(rays.Length, AllocatorHandle.op_Implicit((Allocator)3));
			NativeList<Ray> val2 = new NativeList<Ray>(rays.Length, AllocatorHandle.op_Implicit((Allocator)3));
			NativeArray<bool> val3 = new NativeArray<bool>(rays.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<float> val4 = new NativeArray<float>(rays.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<Vector3> val5 = new NativeArray<Vector3>(rays.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<Vector3> val6 = new NativeArray<Vector3>(rays.Length, (Allocator)3, (NativeArrayOptions)0);
			PreProcessWaterRaysJob preProcessWaterRaysJob = default(PreProcessWaterRaysJob);
			preProcessWaterRaysJob.hits = hits;
			preProcessWaterRaysJob.rays = rays;
			preProcessWaterRaysJob.maxHitsPerTrace = maxHitsPerTrace;
			preProcessWaterRaysJob.WaterIndices = waterIndices;
			preProcessWaterRaysJob.WaterRays = val2;
			preProcessWaterRaysJob.WaterMaxDists = val4;
			PreProcessWaterRaysJob preProcessWaterRaysJob2 = preProcessWaterRaysJob;
			inputDeps = IJobExtensions.ScheduleByRef<PreProcessWaterRaysJob>(ref preProcessWaterRaysJob2, inputDeps);
			inputDeps = WaterSystem.ScheduleTraceBatchDefer(val2, val4, val3, val5, val6, inputDeps);
			PostProcessWaterRaysJob postProcessWaterRaysJob = default(PostProcessWaterRaysJob);
			postProcessWaterRaysJob.hits = hits;
			postProcessWaterRaysJob.rays = val2.AsDeferredJobArray();
			postProcessWaterRaysJob.WaterIndices = waterIndices;
			postProcessWaterRaysJob.hitsSub = val3;
			postProcessWaterRaysJob.positionsSub = val5;
			postProcessWaterRaysJob.normalsSub = val6;
			PostProcessWaterRaysJob postProcessWaterRaysJob2 = postProcessWaterRaysJob;
			inputDeps = IJobExtensions.ScheduleByRef<PostProcessWaterRaysJob>(ref postProcessWaterRaysJob2, inputDeps);
			waterIndices.Dispose(inputDeps);
			val2.Dispose(inputDeps);
			val3.Dispose(inputDeps);
			val4.Dispose(inputDeps);
			val5.Dispose(inputDeps);
			val6.Dispose(inputDeps);
			return inputDeps;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void VerifyRays(NativeArray<RaycastHit> hits, NativeArray<RaycastCommand> rays, int maxHitsPerCast)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("VerifyRays", 0);
		try
		{
			for (int i = 0; i < rays.Length; i++)
			{
				RaycastCommand val2 = rays[i];
				int num = i * maxHitsPerCast;
				int num2 = 0;
				RaycastHit val4;
				for (int j = 0; j < maxHitsPerCast; j++)
				{
					int num3 = i * maxHitsPerCast + j;
					RaycastHit val3 = hits[num3];
					val4 = hits[num3];
					if (((RaycastHit)(ref val4)).normal == Vector3.zero)
					{
						break;
					}
					if (Verify(val3, ((RaycastCommand)(ref val2)).from))
					{
						hits[num + num2++] = val3;
					}
				}
				if (num2 < maxHitsPerCast)
				{
					val4 = (hits[num + num2] = default(RaycastHit));
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void TraceRays(NativeArray<RaycastCommand> rays, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		TraceRaysUnordered(rays, hits, maxHitsPerTrace, traceWater);
		Sort(hits, rays.Length, maxHitsPerTrace);
	}

	public static void TraceSpheresUnordered(NativeArray<SpherecastCommand> spheres, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.TraceSpheresUnordered", 0);
		try
		{
			int batchSize = GetBatchSize(spheres.Length);
			JobHandle inputDeps = SpherecastCommand.ScheduleBatch(spheres, hits, batchSize, maxHitsPerTrace, default(JobHandle));
			if (traceWater)
			{
				inputDeps = TraceWaterSpheresDeferred(hits, spheres, maxHitsPerTrace, inputDeps);
			}
			((JobHandle)(ref inputDeps)).Complete();
			VerifySpheres(hits, spheres, maxHitsPerTrace);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static JobHandle TraceWaterSpheresDeferred(NativeArray<RaycastHit> hits, NativeArray<SpherecastCommand> spheres, int maxHitsPerTrace, JobHandle inputDeps)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ScheduleTraceWaterSpheresDeferred", 0);
		try
		{
			if (!spheres.IsCreated || spheres.Length == 0)
			{
				return inputDeps;
			}
			NativeList<Vector2i> waterIndices = new NativeList<Vector2i>(spheres.Length, AllocatorHandle.op_Implicit((Allocator)3));
			NativeList<Ray> val2 = new NativeList<Ray>(spheres.Length, AllocatorHandle.op_Implicit((Allocator)3));
			NativeArray<bool> val3 = new NativeArray<bool>(spheres.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<float> val4 = new NativeArray<float>(spheres.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<Vector3> val5 = new NativeArray<Vector3>(spheres.Length, (Allocator)3, (NativeArrayOptions)0);
			NativeArray<Vector3> val6 = new NativeArray<Vector3>(spheres.Length, (Allocator)3, (NativeArrayOptions)0);
			PreProcessWaterSpheresJob preProcessWaterSpheresJob = default(PreProcessWaterSpheresJob);
			preProcessWaterSpheresJob.hits = hits;
			preProcessWaterSpheresJob.rays = spheres;
			preProcessWaterSpheresJob.maxHitsPerTrace = maxHitsPerTrace;
			preProcessWaterSpheresJob.WaterIndices = waterIndices;
			preProcessWaterSpheresJob.WaterRays = val2;
			preProcessWaterSpheresJob.WaterMaxDists = val4;
			PreProcessWaterSpheresJob preProcessWaterSpheresJob2 = preProcessWaterSpheresJob;
			inputDeps = IJobExtensions.ScheduleByRef<PreProcessWaterSpheresJob>(ref preProcessWaterSpheresJob2, inputDeps);
			inputDeps = WaterSystem.ScheduleTraceBatchDefer(val2, val4, val3, val5, val6, inputDeps);
			PostProcessWaterRaysJob postProcessWaterRaysJob = default(PostProcessWaterRaysJob);
			postProcessWaterRaysJob.hits = hits;
			postProcessWaterRaysJob.rays = val2.AsDeferredJobArray();
			postProcessWaterRaysJob.WaterIndices = waterIndices;
			postProcessWaterRaysJob.hitsSub = val3;
			postProcessWaterRaysJob.positionsSub = val5;
			postProcessWaterRaysJob.normalsSub = val6;
			PostProcessWaterRaysJob postProcessWaterRaysJob2 = postProcessWaterRaysJob;
			inputDeps = IJobExtensions.ScheduleByRef<PostProcessWaterRaysJob>(ref postProcessWaterRaysJob2, inputDeps);
			waterIndices.Dispose(inputDeps);
			val2.Dispose(inputDeps);
			val3.Dispose(inputDeps);
			val4.Dispose(inputDeps);
			val5.Dispose(inputDeps);
			val6.Dispose(inputDeps);
			return inputDeps;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void VerifySpheres(NativeArray<RaycastHit> hits, NativeArray<SpherecastCommand> spheres, int maxHitsPerCast)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("VerifySpheres", 0);
		try
		{
			for (int i = 0; i < spheres.Length; i++)
			{
				SpherecastCommand val2 = spheres[i];
				int num = i * maxHitsPerCast;
				int num2 = 0;
				RaycastHit val4;
				for (int j = 0; j < maxHitsPerCast; j++)
				{
					int num3 = i * maxHitsPerCast + j;
					RaycastHit val3 = hits[num3];
					val4 = hits[num3];
					if (((RaycastHit)(ref val4)).normal == Vector3.zero)
					{
						break;
					}
					if (Verify(val3, ((SpherecastCommand)(ref val2)).origin))
					{
						hits[num + num2++] = val3;
					}
				}
				if (num2 < maxHitsPerCast)
				{
					val4 = (hits[num + num2] = default(RaycastHit));
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void TraceSpheres(NativeArray<SpherecastCommand> spheres, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		TraceSpheresUnordered(spheres, hits, maxHitsPerTrace, traceWater);
		Sort(hits, spheres.Length, maxHitsPerTrace);
	}

	public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding0, float padding1, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightInternal(p0, p1, layerMask, radius, padding0, padding1, ignoreEntity);
	}

	public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightInternal(p0, p1, layerMask, radius, padding, padding, ignoreEntity);
	}

	public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightInternal(p0, p1, layerMask, radius, 0f, 0f, ignoreEntity);
	}

	public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding0, float padding1, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightRadius(p0, p1, layerMask, 0f, padding0, padding1, ignoreEntity);
	}

	public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightRadius(p0, p1, layerMask, 0f, padding, padding, ignoreEntity);
	}

	public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightRadius(p0, p1, layerMask, 0f, 0f, 0f, ignoreEntity);
	}

	private static bool LineOfSightInternal(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding0, float padding1, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		if (!ValidBounds.TestOuterBounds(p0))
		{
			return false;
		}
		if (!ValidBounds.TestOuterBounds(p1))
		{
			return false;
		}
		Vector3 val = p1 - p0;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (magnitude <= padding0 + padding1)
		{
			return true;
		}
		Vector3 val2 = val / magnitude;
		Ray val3 = default(Ray);
		((Ray)(ref val3))..ctor(p0 + val2 * padding0, val2);
		float num = magnitude - padding0 - padding1;
		bool flag;
		RaycastHit hitInfo = default(RaycastHit);
		if (!ignoreEntity.IsRealNull() || (layerMask & 0x800000) != 0)
		{
			flag = Trace(val3, 0f, out hitInfo, num, layerMask, (QueryTriggerInteraction)1, ignoreEntity);
			if (radius > 0f && !flag)
			{
				flag = Trace(val3, radius, out hitInfo, num, layerMask, (QueryTriggerInteraction)1, ignoreEntity);
			}
		}
		else
		{
			flag = Physics.Raycast(val3, ref hitInfo, num, layerMask, (QueryTriggerInteraction)1);
			if (radius > 0f && !flag)
			{
				flag = Physics.SphereCast(val3, radius, ref hitInfo, num, layerMask, (QueryTriggerInteraction)1);
			}
		}
		if (!flag)
		{
			if (ConVar.Vis.lineofsight)
			{
				ConsoleNetwork.BroadcastToAllClients("ddraw.line", 60f, Color.green, p0, p1);
			}
			return true;
		}
		if (ConVar.Vis.lineofsight)
		{
			ConsoleNetwork.BroadcastToAllClients("ddraw.line", 60f, Color.red, p0, p1);
			ConsoleNetwork.BroadcastToAllClients("ddraw.text", 60f, Color.white, ((RaycastHit)(ref hitInfo)).point, ((Object)((RaycastHit)(ref hitInfo)).collider).name);
		}
		return false;
	}

	public static bool Verify(RaycastHit hitInfo, Vector3 rayOrigin, BaseEntity ignoreEntity = null)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((RaycastHit)(ref hitInfo)).point;
		if (((RaycastHit)(ref hitInfo)).collider is TerrainCollider && val == Vector3.zero && ((RaycastHit)(ref hitInfo)).distance == 0f)
		{
			val = rayOrigin;
		}
		return Verify(((RaycastHit)(ref hitInfo)).collider, val, ignoreEntity);
	}

	public static bool Verify(Collider collider, Vector3 point, BaseEntity ignoreEntity = null)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)collider == (Object)null)
		{
			if (Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(point))
			{
				return false;
			}
			return true;
		}
		if (collider is TerrainCollider)
		{
			if (Object.op_Implicit((Object)(object)TerrainMeta.Collision) && TerrainMeta.Collision.GetIgnore(point))
			{
				return false;
			}
			return true;
		}
		if (!ignoreEntity.IsRealNull() && CompareEntity(collider.ToBaseEntity(), ignoreEntity))
		{
			return false;
		}
		return collider.enabled;
	}

	public static bool CompareEntity(BaseEntity a, BaseEntity b)
	{
		if (a.IsRealNull() || b.IsRealNull())
		{
			return false;
		}
		if ((Object)(object)a == (Object)(object)b)
		{
			return true;
		}
		return false;
	}

	public static int HandleIgnoreCollision(Vector3 position, int layerMask)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		int num = 8388608;
		if ((layerMask & num) != 0 && Object.op_Implicit((Object)(object)TerrainMeta.Collision) && TerrainMeta.Collision.GetIgnore(position))
		{
			layerMask &= ~num;
		}
		int num2 = 16;
		if ((layerMask & num2) != 0 && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(position))
		{
			layerMask &= ~num2;
		}
		return layerMask;
	}

	public static void HandleIgnoreTerrain(ReadOnly<Vector3> positions, NativeArray<bool> hitIgnoreVolumes)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<float> values = default(NativeArray<float>);
		values..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
		FillJob<float> fillJob = default(FillJob<float>);
		fillJob.Values = values;
		fillJob.Value = 0.01f;
		FillJob<float> fillJob2 = fillJob;
		IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
		TerrainMeta.Collision.GetIgnore(positions, values.AsReadOnly(), hitIgnoreVolumes);
		values.Dispose();
	}

	public static void HandleIgnoreWater(ReadOnly<Vector3> positions, NativeArray<bool> hitIgnoreVolumes)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<float> values = default(NativeArray<float>);
		values..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
		FillJob<float> fillJob = default(FillJob<float>);
		fillJob.Values = values;
		fillJob.Value = 0.01f;
		FillJob<float> fillJob2 = fillJob;
		IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
		WaterSystem.Collision.GetIgnore(positions, values.AsReadOnly(), hitIgnoreVolumes);
		values.Dispose();
	}

	public static void HandleIgnoreCollision(ReadOnly<Vector3> positions, NativeArray<int> layerMasks, MasksToValidate validate = MasksToValidate.All)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (validate.HasFlag(MasksToValidate.Terrain))
		{
			NativeArray<bool> hitIgnoreVolumes = default(NativeArray<bool>);
			hitIgnoreVolumes..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
			HandleIgnoreTerrain(positions, hitIgnoreVolumes);
			RemoveLayerMaskJob removeLayerMaskJob = default(RemoveLayerMaskJob);
			removeLayerMaskJob.LayerMasks = layerMasks;
			removeLayerMaskJob.ShouldIgnore = hitIgnoreVolumes.AsReadOnly();
			removeLayerMaskJob.MaskToRemove = 8388608;
			RemoveLayerMaskJob removeLayerMaskJob2 = removeLayerMaskJob;
			IJobExtensions.RunByRef<RemoveLayerMaskJob>(ref removeLayerMaskJob2);
			hitIgnoreVolumes.Dispose();
		}
		if (validate.HasFlag(MasksToValidate.Water))
		{
			NativeArray<bool> hitIgnoreVolumes2 = default(NativeArray<bool>);
			hitIgnoreVolumes2..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
			HandleIgnoreWater(positions, hitIgnoreVolumes2);
			RemoveLayerMaskJob removeLayerMaskJob = default(RemoveLayerMaskJob);
			removeLayerMaskJob.LayerMasks = layerMasks;
			removeLayerMaskJob.ShouldIgnore = hitIgnoreVolumes2.AsReadOnly();
			removeLayerMaskJob.MaskToRemove = 16;
			RemoveLayerMaskJob removeLayerMaskJob3 = removeLayerMaskJob;
			IJobExtensions.RunByRef<RemoveLayerMaskJob>(ref removeLayerMaskJob3);
			hitIgnoreVolumes2.Dispose();
		}
	}

	public static void Sort(List<RaycastHit> hits)
	{
		hits.Sort((RaycastHit a, RaycastHit b) => ((RaycastHit)(ref a)).distance.CompareTo(((RaycastHit)(ref b)).distance));
	}

	public static void Sort(RaycastHit[] hits)
	{
		Array.Sort(hits, (RaycastHit a, RaycastHit b) => ((RaycastHit)(ref a)).distance.CompareTo(((RaycastHit)(ref b)).distance));
	}

	public static void Sort(NativeArray<RaycastHit> hits, int queryCount, int maxHitsPerQuery)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.Sort", 0);
		try
		{
			NativeArray<int> counts = new NativeArray<int>(queryCount, (Allocator)3, (NativeArrayOptions)0);
			CountRaycastHitsJobs countRaycastHitsJobs = default(CountRaycastHitsJobs);
			countRaycastHitsJobs.Counts = counts;
			countRaycastHitsJobs.Hits = hits.AsReadOnly();
			countRaycastHitsJobs.MaxHitsPerRay = maxHitsPerQuery;
			CountRaycastHitsJobs countRaycastHitsJobs2 = countRaycastHitsJobs;
			IJobExtensions.RunByRef<CountRaycastHitsJobs>(ref countRaycastHitsJobs2);
			for (int i = 0; i < counts.Length; i++)
			{
				int num = counts[i];
				if (num > 1)
				{
					SortJob<RaycastHit, RaycastHitComparer> val2 = NativeSortExtension.SortJob<RaycastHit, RaycastHitComparer>(hits.GetSubArray(i * maxHitsPerQuery, num), default(RaycastHitComparer));
					JobHandle val3 = default(JobHandle);
					val3 = val2.Schedule(val3);
					((JobHandle)(ref val3)).Complete();
				}
			}
			counts.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static int GetBatchSize(int count, int subdivideFactor = 4, int minBatchSize = 64)
	{
		return Math.Max(count / JobsUtility.JobWorkerCount / subdivideFactor, minBatchSize);
	}
}


public enum Realm
{
	Client,
	Server
}


using System;

[Flags]
public enum MasksToValidate : byte
{
	None = 0,
	Terrain = 1,
	Water = 2,
	All = 3
}


using EZhex1991.EZSoftBone;
using UnityEngine;

[RequireComponent(typeof(HitboxSystem))]
public class EZSoftBoneHitboxSystemCollider : EZSoftBoneColliderBase, IClientComponent
{
	public float radius = 2f;

	public override void Collide(ref Vector3 position, float spacing)
	{
	}
}


public class HitboxCollision : BaseCollision
{
}


using UnityEngine;

public class HitboxDefinition : MonoBehaviour
{
	public enum Type
	{
		BOX,
		CAPSULE
	}

	public Vector3 center;

	public Vector3 rotation;

	public Type type;

	public int priority;

	public PhysicMaterial physicMaterial;

	[SerializeField]
	private Vector3 scale = Vector3.one;

	public Vector3 Scale
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return scale;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			scale = new Vector3(Mathf.Abs(value.x), Mathf.Abs(value.y), Mathf.Abs(value.z));
		}
	}

	public Matrix4x4 LocalMatrix => Matrix4x4.TRS(center, Quaternion.Euler(rotation), scale);

	private void OnValidate()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Scale = Scale;
	}

	protected virtual void OnDrawGizmosSelected()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		switch (type)
		{
		case Type.BOX:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), scale);
			Gizmos.color = new Color(0f, 1f, 0f, 0.2f);
			Gizmos.DrawCube(Vector3.zero, Vector3.one);
			Gizmos.color = Color.green;
			Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		case Type.CAPSULE:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), Vector3.one);
			Gizmos.color = Color.green;
			GizmosUtil.DrawWireCapsuleY(Vector3.zero, scale.x, scale.y);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		}
	}

	protected virtual void OnDrawGizmos()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		switch (type)
		{
		case Type.BOX:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), scale);
			Gizmos.color = Color.black;
			Gizmos.DrawSphere(Vector3.zero, 0.005f);
			Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
			Gizmos.color = new Color(1f, 0f, 0f, 0.2f);
			Gizmos.DrawCube(Vector3.zero, Vector3.one);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		case Type.CAPSULE:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), Vector3.one);
			Gizmos.color = Color.black;
			Gizmos.DrawSphere(Vector3.zero, 0.005f);
			GizmosUtil.DrawWireCapsuleY(Vector3.zero, scale.x, scale.y);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		}
	}
}


public enum Type
{
	BOX,
	CAPSULE
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public class HitboxSystem : MonoBehaviour, IPrefabPreProcess
{
	[Serializable]
	public class HitboxShape
	{
		public struct JobStruct
		{
			public Matrix4x4 transform;

			public Matrix4x4 inverseTransform;

			public Vector3 size;

			public HitboxDefinition.Type type;
		}

		public Transform bone;

		public HitboxDefinition.Type type;

		public Matrix4x4 localTransform;

		public PhysicMaterial colliderMaterial;

		private Matrix4x4 transform;

		private Matrix4x4 inverseTransform;

		public Matrix4x4 Transform => transform;

		public Vector3 Position => ((Matrix4x4)(ref transform)).MultiplyPoint(Vector3.zero);

		public Quaternion Rotation => ((Matrix4x4)(ref transform)).rotation;

		public Vector3 Size { get; private set; }

		public void UpdateTransform()
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("HitboxSystem.UpdateTransform", 0);
			try
			{
				transform = bone.localToWorldMatrix * localTransform;
				Size = ((Matrix4x4)(ref transform)).lossyScale;
				transform = Matrix4x4.TRS(Position, Rotation, Vector3.one);
				inverseTransform = ((Matrix4x4)(ref transform)).inverse;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public Vector3 TransformPoint(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref transform)).MultiplyPoint(pt);
		}

		public Vector3 InverseTransformPoint(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref inverseTransform)).MultiplyPoint(pt);
		}

		public Vector3 TransformDirection(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref transform)).MultiplyVector(pt);
		}

		public Vector3 InverseTransformDirection(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref inverseTransform)).MultiplyVector(pt);
		}

		public JobStruct GetJobStruct()
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			JobStruct result = default(JobStruct);
			result.transform = transform;
			result.inverseTransform = inverseTransform;
			result.size = Size;
			result.type = type;
			return result;
		}

		public bool Trace(Ray ray, out RaycastHit hit, float forgivness = 0f, float maxDistance = float.PositiveInfinity)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("Hitbox.Trace", 0);
			try
			{
				((Ray)(ref ray)).origin = InverseTransformPoint(((Ray)(ref ray)).origin);
				((Ray)(ref ray)).direction = InverseTransformDirection(((Ray)(ref ray)).direction);
				if (type == HitboxDefinition.Type.BOX)
				{
					AABB val2 = default(AABB);
					((AABB)(ref val2))..ctor(Vector3.zero, Size);
					if (!((AABB)(ref val2)).Trace(ray, ref hit, forgivness, maxDistance))
					{
						return false;
					}
				}
				else
				{
					Capsule val3 = default(Capsule);
					((Capsule)(ref val3))..ctor(Vector3.zero, Size.x, Size.y * 0.5f);
					if (!((Capsule)(ref val3)).Trace(ray, ref hit, forgivness, maxDistance))
					{
						return false;
					}
				}
				((RaycastHit)(ref hit)).point = TransformPoint(((RaycastHit)(ref hit)).point);
				((RaycastHit)(ref hit)).normal = TransformDirection(((RaycastHit)(ref hit)).normal);
				return true;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public Bounds GetBounds()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			Matrix4x4 val = Transform;
			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					((Matrix4x4)(ref val))[i, j] = Mathf.Abs(((Matrix4x4)(ref val))[i, j]);
				}
			}
			Bounds result = default(Bounds);
			Matrix4x4 val2 = Transform;
			((Bounds)(ref result)).center = ((Matrix4x4)(ref val2)).MultiplyPoint(Vector3.zero);
			((Bounds)(ref result)).extents = ((Matrix4x4)(ref val)).MultiplyVector(Size);
			return result;
		}
	}

	public List<HitboxShape> hitboxes = new List<HitboxShape>();

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		List<HitboxDefinition> list = Pool.Get<List<HitboxDefinition>>();
		((Component)this).GetComponentsInChildren<HitboxDefinition>(list);
		if (serverside)
		{
			foreach (HitboxDefinition item2 in list)
			{
				if (preProcess != null)
				{
					preProcess.RemoveComponent((Component)(object)item2);
				}
			}
			if (preProcess != null)
			{
				preProcess.RemoveComponent((Component)(object)this);
			}
		}
		if (clientside)
		{
			hitboxes.Clear();
			foreach (HitboxDefinition item3 in list.OrderBy((HitboxDefinition x) => x.priority))
			{
				HitboxShape item = new HitboxShape
				{
					bone = ((Component)item3).transform,
					localTransform = item3.LocalMatrix,
					colliderMaterial = item3.physicMaterial,
					type = item3.type
				};
				hitboxes.Add(item);
				if (preProcess != null)
				{
					preProcess.RemoveComponent((Component)(object)item3);
				}
			}
		}
		Pool.FreeUnmanaged<HitboxDefinition>(ref list);
	}
}


using System;
using UnityEngine;

[Serializable]
public class HitboxShape
{
	public struct JobStruct
	{
		public Matrix4x4 transform;

		public Matrix4x4 inverseTransform;

		public Vector3 size;

		public HitboxDefinition.Type type;
	}

	public Transform bone;

	public HitboxDefinition.Type type;

	public Matrix4x4 localTransform;

	public PhysicMaterial colliderMaterial;

	private Matrix4x4 transform;

	private Matrix4x4 inverseTransform;

	public Matrix4x4 Transform => transform;

	public Vector3 Position => ((Matrix4x4)(ref transform)).MultiplyPoint(Vector3.zero);

	public Quaternion Rotation => ((Matrix4x4)(ref transform)).rotation;

	public Vector3 Size { get; private set; }

	public void UpdateTransform()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("HitboxSystem.UpdateTransform", 0);
		try
		{
			transform = bone.localToWorldMatrix * localTransform;
			Size = ((Matrix4x4)(ref transform)).lossyScale;
			transform = Matrix4x4.TRS(Position, Rotation, Vector3.one);
			inverseTransform = ((Matrix4x4)(ref transform)).inverse;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Vector3 TransformPoint(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref transform)).MultiplyPoint(pt);
	}

	public Vector3 InverseTransformPoint(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref inverseTransform)).MultiplyPoint(pt);
	}

	public Vector3 TransformDirection(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref transform)).MultiplyVector(pt);
	}

	public Vector3 InverseTransformDirection(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref inverseTransform)).MultiplyVector(pt);
	}

	public JobStruct GetJobStruct()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		JobStruct result = default(JobStruct);
		result.transform = transform;
		result.inverseTransform = inverseTransform;
		result.size = Size;
		result.type = type;
		return result;
	}

	public bool Trace(Ray ray, out RaycastHit hit, float forgivness = 0f, float maxDistance = float.PositiveInfinity)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Hitbox.Trace", 0);
		try
		{
			((Ray)(ref ray)).origin = InverseTransformPoint(((Ray)(ref ray)).origin);
			((Ray)(ref ray)).direction = InverseTransformDirection(((Ray)(ref ray)).direction);
			if (type == HitboxDefinition.Type.BOX)
			{
				AABB val2 = default(AABB);
				((AABB)(ref val2))..ctor(Vector3.zero, Size);
				if (!((AABB)(ref val2)).Trace(ray, ref hit, forgivness, maxDistance))
				{
					return false;
				}
			}
			else
			{
				Capsule val3 = default(Capsule);
				((Capsule)(ref val3))..ctor(Vector3.zero, Size.x, Size.y * 0.5f);
				if (!((Capsule)(ref val3)).Trace(ray, ref hit, forgivness, maxDistance))
				{
					return false;
				}
			}
			((RaycastHit)(ref hit)).point = TransformPoint(((RaycastHit)(ref hit)).point);
			((RaycastHit)(ref hit)).normal = TransformDirection(((RaycastHit)(ref hit)).normal);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Bounds GetBounds()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 val = Transform;
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				((Matrix4x4)(ref val))[i, j] = Mathf.Abs(((Matrix4x4)(ref val))[i, j]);
			}
		}
		Bounds result = default(Bounds);
		Matrix4x4 val2 = Transform;
		((Bounds)(ref result)).center = ((Matrix4x4)(ref val2)).MultiplyPoint(Vector3.zero);
		((Bounds)(ref result)).extents = ((Matrix4x4)(ref val)).MultiplyVector(Size);
		return result;
	}
}


using UnityEngine;

public struct JobStruct
{
	public Matrix4x4 transform;

	public Matrix4x4 inverseTransform;

	public Vector3 size;

	public HitboxDefinition.Type type;
}


using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public class Buttons
{
	public class ConButton : IConsoleButton
	{
		private int frame;

		private TimeSince _timePressed;

		public bool IsDown { get; set; }

		public TimeSince TimePressed
		{
			get
			{
				//IL_0014: Unknown result type (might be due to invalid IL or missing references)
				//IL_000d: Unknown result type (might be due to invalid IL or missing references)
				if (!IsDown)
				{
					return TimeSince.op_Implicit(0f);
				}
				return _timePressed;
			}
		}

		public bool JustPressed
		{
			get
			{
				if (IsDown)
				{
					return frame == Time.frameCount;
				}
				return false;
			}
		}

		public bool JustReleased
		{
			get
			{
				if (!IsDown)
				{
					return frame == Time.frameCount;
				}
				return false;
			}
		}

		public bool IsPressed
		{
			get
			{
				return IsDown;
			}
			set
			{
				//IL_0022: Unknown result type (might be due to invalid IL or missing references)
				//IL_0027: Unknown result type (might be due to invalid IL or missing references)
				if (value != IsDown)
				{
					IsDown = value;
					frame = Time.frameCount;
					_timePressed = TimeSince.op_Implicit(0f);
				}
			}
		}

		public void Reset()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			_timePressed = default(TimeSince);
			IsDown = false;
			frame = 0;
		}

		public void Call(Arg arg)
		{
		}
	}
}


using UnityEngine;

public class ConButton : IConsoleButton
{
	private int frame;

	private TimeSince _timePressed;

	public bool IsDown { get; set; }

	public TimeSince TimePressed
	{
		get
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			if (!IsDown)
			{
				return TimeSince.op_Implicit(0f);
			}
			return _timePressed;
		}
	}

	public bool JustPressed
	{
		get
		{
			if (IsDown)
			{
				return frame == Time.frameCount;
			}
			return false;
		}
	}

	public bool JustReleased
	{
		get
		{
			if (!IsDown)
			{
				return frame == Time.frameCount;
			}
			return false;
		}
	}

	public bool IsPressed
	{
		get
		{
			return IsDown;
		}
		set
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			if (value != IsDown)
			{
				IsDown = value;
				frame = Time.frameCount;
				_timePressed = TimeSince.op_Implicit(0f);
			}
		}
	}

	public void Reset()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		_timePressed = default(TimeSince);
		IsDown = false;
		frame = 0;
	}

	public void Call(Arg arg)
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[Factory("meta")]
public class Meta : ConsoleSystem
{
	[ServerVar(Clientside = true, Help = "add <convar> <amount> - adds amount to convar")]
	public static void add(Arg args)
	{
		string @string = args.GetString(0, "");
		float @float = args.GetFloat(1, 0.1f);
		Command val = Find(@string);
		float result;
		if (val == null)
		{
			args.ReplyWith("Convar not found: " + (@string ?? "<null>"));
		}
		else if (args.IsClientside && val.Replicated)
		{
			args.ReplyWith("Cannot set replicated convars from the client (use sv to do this)");
		}
		else if (args.IsServerside && val.ServerAdmin && !args.IsAdmin)
		{
			args.ReplyWith("Permission denied");
		}
		else if (!float.TryParse(val.String, out result))
		{
			args.ReplyWith("Convar value cannot be parsed as a number");
		}
		else
		{
			val.Set(result + @float);
		}
	}

	[ClientVar(Help = "if_true <command> <condition> - runs a command if the condition is true")]
	public static void if_true(Arg args)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		bool @bool = args.GetBool(1, false);
		if (@bool)
		{
			ConsoleSystem.Run(Option.Client, @string, new object[1] { @bool });
		}
	}

	[ClientVar(Help = "if_false <command> <condition> - runs a command if the condition is false")]
	public static void if_false(Arg args)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		bool @bool = args.GetBool(1, true);
		if (!@bool)
		{
			ConsoleSystem.Run(Option.Client, @string, new object[1] { @bool });
		}
	}

	[ClientVar(Help = "reset_cycle <key> - resets a cycled bind to the beginning")]
	public static void reset_cycle(Arg args)
	{
		string @string = args.GetString(0, "");
		List<KeyCode> list = default(List<KeyCode>);
		KeyCombos.TryParse(ref @string, ref list);
		Button button = Input.GetButton(@string);
		if (button == null)
		{
			args.ReplyWith("Button not found");
		}
		else if (!button.Cycle)
		{
			args.ReplyWith("Button does not have a cycled bind");
		}
		else
		{
			button.CycleIndex = 0;
		}
	}

	[ClientVar(Help = "exec [command_1] ... - runs all of the commands passed as arguments (also, if the last argument is true/false then that will flow into each command's arguments)")]
	public static void exec(Arg args)
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		List<string> list = Pool.Get<List<string>>();
		for (int i = 0; i < 32; i++)
		{
			string @string = args.GetString(i, "");
			if (string.IsNullOrWhiteSpace(@string))
			{
				break;
			}
			list.Add(@string);
		}
		if (list.Count > 0)
		{
			string text = null;
			string text2 = list[list.Count - 1];
			if (bool.TryParse(text2, out var _))
			{
				text = text2;
				list.RemoveAt(list.Count - 1);
			}
			foreach (string item in list)
			{
				if (text != null)
				{
					ConsoleSystem.Run(Option.Client, item, new object[1] { text });
				}
				else
				{
					ConsoleSystem.Run(Option.Client, item, Array.Empty<object>());
				}
			}
		}
		Pool.FreeUnmanaged<string>(ref list);
	}

	private static Command Find(string name)
	{
		Command val = Server.Find(name);
		if (val != null)
		{
			return val;
		}
		return null;
	}
}


using System;
using System.Runtime.InteropServices;

public static class WindowsAffinityShim
{
	[DllImport("kernel32.dll")]
	public static extern bool SetProcessAffinityMask(IntPtr process, IntPtr mask);

	[DllImport("kernel32.dll")]
	public static extern bool SetPriorityClass(IntPtr process, uint mask);
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public class ArticulatedOccludee : BaseMonoBehaviour
{
	private const float UpdateBoundsFadeStart = 20f;

	private const float UpdateBoundsFadeLength = 1000f;

	private const float UpdateBoundsMaxFrequency = 15f;

	private const float UpdateBoundsMinFrequency = 0.5f;

	private LODGroup lodGroup;

	public List<Collider> colliders = new List<Collider>();

	private OccludeeSphere localOccludee = new OccludeeSphere(-1);

	private List<Renderer> renderers = new List<Renderer>();

	private bool isVisible = true;

	private Action TriggerUpdateVisibilityBoundsDelegate;

	public bool IsVisible => isVisible;

	protected virtual void OnDisable()
	{
		if (!Application.isQuitting)
		{
			UnregisterFromCulling();
			ClearVisibility();
		}
	}

	private void ClearVisibility()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)lodGroup != (Object)null)
		{
			lodGroup.localReferencePoint = Vector3.zero;
			lodGroup.RecalculateBounds();
			lodGroup = null;
		}
		if (renderers != null)
		{
			renderers.Clear();
		}
		localOccludee = new OccludeeSphere(-1);
	}

	public void ProcessVisibility(LODGroup lod)
	{
		lodGroup = lod;
		if ((Object)(object)lod != (Object)null)
		{
			renderers = new List<Renderer>(16);
			LOD[] lODs = lod.GetLODs();
			for (int i = 0; i < lODs.Length; i++)
			{
				Renderer[] array = lODs[i].renderers;
				foreach (Renderer val in array)
				{
					if ((Object)(object)val != (Object)null)
					{
						renderers.Add(val);
					}
				}
			}
		}
		UpdateCullingBounds();
	}

	private void RegisterForCulling(OcclusionCulling.Sphere sphere, bool visible)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (localOccludee.IsRegistered)
		{
			UnregisterFromCulling();
		}
		int num = OcclusionCulling.RegisterOccludee(sphere.position, sphere.radius, visible, 0.25f, isStatic: false, ((Component)this).gameObject.layer, OnVisibilityChanged);
		if (num >= 0)
		{
			localOccludee = new OccludeeSphere(num, localOccludee.sphere);
			return;
		}
		localOccludee.Invalidate();
		Debug.LogWarning((object)("[OcclusionCulling] Occludee registration failed for " + ((Object)this).name + ". Too many registered."));
	}

	private void UnregisterFromCulling()
	{
		if (localOccludee.IsRegistered)
		{
			OcclusionCulling.UnregisterOccludee(localOccludee.id);
			localOccludee.Invalidate();
		}
	}

	public void UpdateCullingBounds()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0315: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		Vector3 val2 = Vector3.zero;
		bool flag = false;
		int num = ((renderers != null) ? renderers.Count : 0);
		int num2 = ((colliders != null) ? colliders.Count : 0);
		if (num > 0 && (num2 == 0 || num < num2))
		{
			for (int i = 0; i < renderers.Count; i++)
			{
				if (renderers[i].isVisible)
				{
					Bounds bounds = renderers[i].bounds;
					Vector3 min = ((Bounds)(ref bounds)).min;
					Vector3 max = ((Bounds)(ref bounds)).max;
					if (!flag)
					{
						val = min;
						val2 = max;
						flag = true;
						continue;
					}
					val.x = ((val.x < min.x) ? val.x : min.x);
					val.y = ((val.y < min.y) ? val.y : min.y);
					val.z = ((val.z < min.z) ? val.z : min.z);
					val2.x = ((val2.x > max.x) ? val2.x : max.x);
					val2.y = ((val2.y > max.y) ? val2.y : max.y);
					val2.z = ((val2.z > max.z) ? val2.z : max.z);
				}
			}
		}
		if (!flag && num2 > 0)
		{
			flag = true;
			Bounds bounds2 = colliders[0].bounds;
			val = ((Bounds)(ref bounds2)).min;
			bounds2 = colliders[0].bounds;
			val2 = ((Bounds)(ref bounds2)).max;
			for (int j = 1; j < colliders.Count; j++)
			{
				Bounds bounds3 = colliders[j].bounds;
				Vector3 min2 = ((Bounds)(ref bounds3)).min;
				Vector3 max2 = ((Bounds)(ref bounds3)).max;
				val.x = ((val.x < min2.x) ? val.x : min2.x);
				val.y = ((val.y < min2.y) ? val.y : min2.y);
				val.z = ((val.z < min2.z) ? val.z : min2.z);
				val2.x = ((val2.x > max2.x) ? val2.x : max2.x);
				val2.y = ((val2.y > max2.y) ? val2.y : max2.y);
				val2.z = ((val2.z > max2.z) ? val2.z : max2.z);
			}
		}
		if (!flag)
		{
			return;
		}
		Vector3 val3 = val2 - val;
		Vector3 position = val + val3 * 0.5f;
		float radius = Mathf.Max(Mathf.Max(val3.x, val3.y), val3.z) * 0.5f;
		OcclusionCulling.Sphere sphere = new OcclusionCulling.Sphere(position, radius);
		if (localOccludee.IsRegistered)
		{
			OcclusionCulling.UpdateDynamicOccludee(localOccludee.id, sphere.position, sphere.radius);
			localOccludee.sphere = sphere;
			return;
		}
		bool visible = true;
		if ((Object)(object)lodGroup != (Object)null)
		{
			visible = lodGroup.enabled;
		}
		RegisterForCulling(sphere, visible);
	}

	protected virtual bool CheckVisibility()
	{
		if (localOccludee.state != null)
		{
			return localOccludee.state.isVisible;
		}
		return true;
	}

	private void ApplyVisibility(bool vis)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)lodGroup != (Object)null)
		{
			float num = ((!vis) ? 100000 : 0);
			if (num != lodGroup.localReferencePoint.x)
			{
				lodGroup.localReferencePoint = new Vector3(num, num, num);
			}
		}
	}

	protected virtual void OnVisibilityChanged(bool visible)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)MainCamera.mainCamera != (Object)null && localOccludee.IsRegistered)
		{
			float dist = Vector3.Distance(MainCamera.position, ((Component)this).transform.position);
			VisUpdateUsingCulling(dist, visible);
			ApplyVisibility(isVisible);
		}
	}

	private void UpdateVisibility(float delay)
	{
	}

	private void VisUpdateUsingCulling(float dist, bool visibility)
	{
	}

	public virtual void TriggerUpdateVisibilityBounds()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (((Behaviour)this).enabled)
		{
			Vector3 val = ((Component)this).transform.position - MainCamera.position;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			float num = 400f;
			float num2;
			if (sqrMagnitude < num)
			{
				num2 = 1f / Random.Range(5f, 25f);
			}
			else
			{
				float num3 = Mathf.Clamp01((Mathf.Sqrt(sqrMagnitude) - 20f) * 0.001f);
				float num4 = Mathf.Lerp(1f / 15f, 2f, num3);
				num2 = Random.Range(num4, num4 + 1f / 15f);
			}
			UpdateVisibility(num2);
			ApplyVisibility(isVisible);
			if (TriggerUpdateVisibilityBoundsDelegate == null)
			{
				TriggerUpdateVisibilityBoundsDelegate = TriggerUpdateVisibilityBounds;
			}
			((FacepunchBehaviour)this).Invoke(TriggerUpdateVisibilityBoundsDelegate, num2);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public static class DamageUtil
{
	public static void RadiusDamage(BaseEntity attackingPlayer, BaseEntity weaponPrefab, Vector3 pos, float minradius, float radius, List<DamageTypeEntry> damage, int layers, bool useLineOfSight, bool ignoreAI = false, bool ignoreAttackingPlayer = false, bool extendedLineOfSight = false, List<DamageTypeEntry> playerDamage = null, bool removeWallpaper = false)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("DamageUtil.RadiusDamage", 0);
		try
		{
			List<HitInfo> list = Pool.Get<List<HitInfo>>();
			List<BaseEntity> list2 = Pool.Get<List<BaseEntity>>();
			List<BaseEntity> list3 = Pool.Get<List<BaseEntity>>();
			Vis.Entities(pos, radius, list3, layers, (QueryTriggerInteraction)2);
			for (int i = 0; i < list3.Count; i++)
			{
				BaseEntity baseEntity = list3[i];
				if (!baseEntity.isServer || list2.Contains(baseEntity) || (ignoreAI && IsIgnoredAI(baseEntity)))
				{
					continue;
				}
				Vector3 val2 = baseEntity.ClosestPoint(pos);
				float num = Mathf.Clamp01((Vector3.Distance(val2, pos) - minradius) / (radius - minradius));
				if (num > 1f)
				{
					continue;
				}
				float amount = 1f - num;
				if (removeWallpaper && baseEntity is BuildingBlock buildingBlock)
				{
					buildingBlock.RemoveWallpaper(0);
					buildingBlock.RemoveWallpaper(1);
				}
				if ((!extendedLineOfSight || GamePhysics.LineOfSight(baseEntity.CenterPoint(), pos, 1218519041, baseEntity)) && (!useLineOfSight || baseEntity.IsVisible(pos)))
				{
					HitInfo hitInfo = new HitInfo();
					hitInfo.Initiator = attackingPlayer;
					hitInfo.WeaponPrefab = weaponPrefab;
					if (playerDamage != null && playerDamage.Count > 0 && baseEntity is BasePlayer)
					{
						hitInfo.damageTypes.Add(playerDamage);
					}
					else
					{
						hitInfo.damageTypes.Add(damage);
					}
					hitInfo.damageTypes.ScaleAll(amount);
					hitInfo.HitPositionWorld = val2;
					Vector3 val3 = pos - val2;
					hitInfo.HitNormalWorld = ((Vector3)(ref val3)).normalized;
					hitInfo.PointStart = pos;
					hitInfo.PointEnd = hitInfo.HitPositionWorld;
					list.Add(hitInfo);
					list2.Add(baseEntity);
				}
			}
			for (int j = 0; j < list2.Count; j++)
			{
				BaseEntity baseEntity2 = list2[j];
				HitInfo info = list[j];
				if (!ignoreAttackingPlayer || !((Object)(object)attackingPlayer != (Object)null) || !baseEntity2.EqualNetID((BaseNetworkable)attackingPlayer))
				{
					baseEntity2.OnAttacked(info);
				}
			}
			Pool.FreeUnmanaged<HitInfo>(ref list);
			Pool.FreeUnmanaged<BaseEntity>(ref list2);
			Pool.FreeUnmanaged<BaseEntity>(ref list3);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static bool IsIgnoredAI(BaseEntity ent)
	{
		return ent is ScientistNPC;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class CinematicEntity : BaseEntity
{
	[Serializable]
	public struct DisableGroup
	{
		public GameObject[] gameObjects;
	}

	private const Flags HideMesh = Flags.Reserved1;

	private const Flags HideMesh2 = Flags.Reserved2;

	private const Flags HideMesh3 = Flags.Reserved3;

	private const Flags HideMesh4 = Flags.Reserved4;

	public List<DisableGroup> DisableObjects;

	private static List<CinematicEntity> serverList = new List<CinematicEntity>();

	public override void ServerInit()
	{
		base.ServerInit();
		if (!serverList.Contains(this))
		{
			serverList.Add(this);
		}
	}

	[ServerVar(Help = "Hides cinematic entities by group (0= none, 1= lights, 2= BGs, 3= props, 4= misc)")]
	public static void HideObjects(Arg args)
	{
		HideObjectShared(args, serverList);
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer && serverList.Contains(this))
		{
			serverList.Remove(this);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool state = !HasFlag(Flags.Reserved1) && !HasFlag(Flags.Reserved2) && !HasFlag(Flags.Reserved3) && !HasFlag(Flags.Reserved4);
		ToggleObjects(state);
	}

	private void ToggleObjects(bool state)
	{
		for (int i = 0; i < DisableObjects.Count; i++)
		{
			DisableGroup disableGroup = DisableObjects[i];
			bool active = state;
			if (!state)
			{
				int f = 1 << 7 + i;
				active = !HasFlag((Flags)f);
			}
			GameObject[] gameObjects = disableGroup.gameObjects;
			for (int j = 0; j < gameObjects.Length; j++)
			{
				gameObjects[j].SetActive(active);
			}
		}
	}

	public static void HideObjectShared(Arg args, List<CinematicEntity> entList)
	{
		if (args.GetString(0, "") == "")
		{
			return;
		}
		List<int> list = new List<int>();
		if (args.GetInt(0, 0) != 0)
		{
			for (int i = 0; i < 4 && !(args.GetString(i, "") == ""); i++)
			{
				int @int = args.GetInt(i, 0);
				if (@int == 0)
				{
					break;
				}
				list.Add(@int - 1);
			}
		}
		foreach (CinematicEntity ent in entList)
		{
			for (int j = 0; j < 4; j++)
			{
				int f = 1 << 7 + j;
				ent.SetFlag((Flags)f, list.Contains(j));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct DisableGroup
{
	public GameObject[] gameObjects;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch.Rust;
using Network;
using UnityEngine;
using UnityEngine.SceneManagement;

[Factory("global")]
public class DiagnosticsConSys : ConsoleSystem
{
	private static void DumpAnimators(string targetFolder)
	{
		Animator[] array = Object.FindObjectsOfType<Animator>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All animators");
		stringBuilder.AppendLine();
		Animator[] array2 = array;
		foreach (Animator val in array2)
		{
			stringBuilder.AppendFormat("{1}\t{0}", ((Component)val).transform.GetRecursiveName(), ((Behaviour)val).enabled);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Animators.List.txt", stringBuilder.ToString());
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("All animators - grouped by object name");
		stringBuilder2.AppendLine();
		foreach (IGrouping<string, Animator> item in from x in array
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder2.AppendFormat("{1:N0}\t{0}", ((Component)item.First()).transform.GetRecursiveName(), item.Count());
			stringBuilder2.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Animators.Counts.txt", stringBuilder2.ToString());
		StringBuilder stringBuilder3 = new StringBuilder();
		stringBuilder3.AppendLine("All animators - grouped by enabled/disabled");
		stringBuilder3.AppendLine();
		foreach (IGrouping<string, Animator> item2 in from x in array
			group x by ((Component)x).transform.GetRecursiveName(((Behaviour)x).enabled ? "" : " (DISABLED)") into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder3.AppendFormat("{1:N0}\t{0}", ((Component)item2.First()).transform.GetRecursiveName(((Behaviour)item2.First()).enabled ? "" : " (DISABLED)"), item2.Count());
			stringBuilder3.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Animators.Counts.Enabled.txt", stringBuilder3.ToString());
	}

	[ClientVar]
	[ServerVar]
	public static void dump(Arg args)
	{
		if (Directory.Exists("diagnostics"))
		{
			Directory.CreateDirectory("diagnostics");
		}
		int num = 1;
		while (Directory.Exists("diagnostics/" + num))
		{
			num++;
		}
		Directory.CreateDirectory("diagnostics/" + num);
		string targetFolder = "diagnostics/" + num + "/";
		DumpLODGroups(targetFolder);
		DumpSystemInformation(targetFolder);
		for (int i = 0; i < SceneManager.sceneCount; i++)
		{
			DumpSceneGameObjects(targetFolder, i);
		}
		DumpAllGameObjects(targetFolder);
		DumpObjects(targetFolder);
		DumpEntities(targetFolder);
		DumpNetwork(targetFolder);
		DumpPhysics(targetFolder);
		DumpAnimators(targetFolder);
		DumpWarmup(targetFolder);
	}

	private static void DumpSystemInformation(string targetFolder)
	{
		WriteTextToFile(targetFolder + "System.Info.txt", SystemInfoGeneralText.currentInfo);
	}

	private static void WriteTextToFile(string file, string text)
	{
		File.WriteAllText(file, text);
	}

	private static void DumpEntities(string targetFolder)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All entities");
		stringBuilder.AppendLine();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				stringBuilder.AppendFormat("{1}\t{0}", current.PrefabName, ((NetworkableId)(((??)current.net?.ID) ?? default(NetworkableId))).Value);
				stringBuilder.AppendLine();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Entity.SV.List.txt", stringBuilder.ToString());
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("All entities");
		stringBuilder2.AppendLine();
		foreach (IGrouping<uint, BaseNetworkable> item in from x in BaseNetworkable.serverEntities
			group x by x.prefabID into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder2.AppendFormat("{1:N0}\t{0}", item.First().PrefabName, item.Count());
			stringBuilder2.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Entity.SV.Counts.txt", stringBuilder2.ToString());
		StringBuilder stringBuilder3 = new StringBuilder();
		stringBuilder3.AppendLine("Saved entities");
		stringBuilder3.AppendLine();
		foreach (IGrouping<uint, BaseEntity> item2 in from x in BaseEntity.saveList
			group x by x.prefabID into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder3.AppendFormat("{1:N0}\t{0}", item2.First().PrefabName, item2.Count());
			stringBuilder3.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Entity.SV.Savelist.Counts.txt", stringBuilder3.ToString());
	}

	private static void DumpLODGroups(string targetFolder)
	{
		DumpLODGroupTotals(targetFolder);
	}

	private static void DumpLODGroupTotals(string targetFolder)
	{
		LODGroup[] source = Object.FindObjectsOfType<LODGroup>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("LODGroups");
		stringBuilder.AppendLine();
		foreach (IGrouping<string, LODGroup> item in from x in source
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", item.Key, item.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "LODGroups.Objects.txt", stringBuilder.ToString());
	}

	private static void DumpNetwork(string targetFolder)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (!((BaseNetwork)Net.sv).IsConnected())
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Server Network Statistics");
		stringBuilder.AppendLine();
		stringBuilder.Append(((BaseNetwork)Net.sv).GetDebug((Connection)null).Replace("\n", "\r\n"));
		stringBuilder.AppendLine();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				stringBuilder.AppendLine("Name: " + current.displayName);
				stringBuilder.AppendLine("SteamID: " + current.userID.Get());
				stringBuilder.Append((current.net == null) ? "INVALID - NET IS NULL" : ((BaseNetwork)Net.sv).GetDebug(current.net.connection).Replace("\n", "\r\n"));
				stringBuilder.AppendLine();
				stringBuilder.AppendLine();
				stringBuilder.AppendLine();
				stringBuilder.AppendLine();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		WriteTextToFile(targetFolder + "Network.Server.txt", stringBuilder.ToString());
	}

	private static void DumpObjects(string targetFolder)
	{
		Object[] array = Object.FindObjectsOfType<Object>();
		Object[] array2 = Object.FindObjectsOfType<Object>(true);
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All active UnityEngine.Object, ordered by count");
		stringBuilder.AppendLine($"Total: {array.Length}");
		stringBuilder.AppendLine();
		foreach (IGrouping<Type, Object> item in from x in array
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((object)item.First()).GetType().Name, item.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object.Count.txt", stringBuilder.ToString());
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("All active + inactive UnityEngine.Object, ordered by count");
		stringBuilder2.AppendLine($"Total: {array2.Length}");
		stringBuilder2.AppendLine();
		foreach (IGrouping<Type, Object> item2 in from x in array2
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder2.AppendFormat("{1:N0}\t{0}", ((object)item2.First()).GetType().Name, item2.Count());
			stringBuilder2.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object_All.Count.txt", stringBuilder2.ToString());
		StringBuilder stringBuilder3 = new StringBuilder();
		stringBuilder3.AppendLine("All active + inactive UnityEngine.Object, ordered by count");
		stringBuilder3.AppendLine($"Total: {array.Length}");
		stringBuilder3.AppendLine();
		foreach (IGrouping<Type, Object> item3 in from x in array
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder3.AppendFormat("{1:N0}\t{0}", ((object)item3.First()).GetType().Name, item3.Count());
			stringBuilder3.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object.Count.txt", stringBuilder3.ToString());
		StringBuilder stringBuilder4 = new StringBuilder();
		stringBuilder4.AppendLine("All active UnityEngine.ScriptableObject, ordered by count");
		stringBuilder4.AppendLine();
		foreach (IGrouping<Type, Object> item4 in from x in array
			where x is ScriptableObject
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder4.AppendFormat("{1:N0}\t{0}", ((object)item4.First()).GetType().Name, item4.Count());
			stringBuilder4.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.ScriptableObject.Count.txt", stringBuilder4.ToString());
	}

	private static void DumpPhysics(string targetFolder)
	{
		DumpTotals(targetFolder);
		DumpColliders(targetFolder);
		DumpRigidBodies(targetFolder);
	}

	private static void DumpTotals(string targetFolder)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Physics Information");
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Total Colliders:\t{0:N0}", Object.FindObjectsOfType<Collider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Active Colliders:\t{0:N0}", (from x in Object.FindObjectsOfType<Collider>()
			where x.enabled
			select x).Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Total RigidBodys:\t{0:N0}", Object.FindObjectsOfType<Rigidbody>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Mesh Colliders:\t{0:N0}", Object.FindObjectsOfType<MeshCollider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Box Colliders:\t{0:N0}", Object.FindObjectsOfType<BoxCollider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Sphere Colliders:\t{0:N0}", Object.FindObjectsOfType<SphereCollider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Capsule Colliders:\t{0:N0}", Object.FindObjectsOfType<CapsuleCollider>().Count());
		stringBuilder.AppendLine();
		WriteTextToFile(targetFolder + "Physics.txt", stringBuilder.ToString());
	}

	private static void DumpColliders(string targetFolder)
	{
		Collider[] source = Object.FindObjectsOfType<Collider>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Physics Colliders");
		stringBuilder.AppendLine();
		foreach (IGrouping<string, Collider> item in from x in source
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0} ({2:N0} triggers) ({3:N0} enabled)", item.Key, item.Count(), item.Count((Collider x) => x.isTrigger), item.Count((Collider x) => x.enabled));
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "Physics.Colliders.Objects.txt", stringBuilder.ToString());
	}

	private static void DumpRigidBodies(string targetFolder)
	{
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody[] source = Object.FindObjectsOfType<Rigidbody>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("RigidBody");
		stringBuilder.AppendLine();
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("RigidBody");
		stringBuilder2.AppendLine();
		foreach (IGrouping<string, Rigidbody> item in from x in source
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0} ({2:N0} awake) ({3:N0} kinematic) ({4:N0} non-discrete)", item.Key, item.Count(), item.Count((Rigidbody x) => !x.IsSleeping()), item.Count((Rigidbody x) => x.isKinematic), item.Count((Rigidbody x) => (int)x.collisionDetectionMode > 0));
			stringBuilder.AppendLine();
			foreach (Rigidbody item2 in item)
			{
				stringBuilder2.AppendFormat("{0} -{1}{2}{3}", item.Key, item2.isKinematic ? " KIN" : "", item2.IsSleeping() ? " SLEEP" : "", item2.useGravity ? " GRAVITY" : "");
				stringBuilder2.AppendLine();
				stringBuilder2.AppendFormat("Mass: {0}\tVelocity: {1}\tsleepThreshold: {2}", item2.mass, item2.velocity, item2.sleepThreshold);
				stringBuilder2.AppendLine();
				stringBuilder2.AppendLine();
			}
		}
		WriteTextToFile(targetFolder + "Physics.RigidBody.Objects.txt", stringBuilder.ToString());
		WriteTextToFile(targetFolder + "Physics.RigidBody.All.txt", stringBuilder2.ToString());
	}

	private static string GetOutputDirectoryForScene(string targetFolder, int sceneIndex, Scene scene)
	{
		string arg = ((Scene)(ref scene)).name.Replace("\\", "_").Replace("/", "_").Replace(" ", "_");
		targetFolder = Path.Combine(targetFolder, "Scenes", $"{sceneIndex}_{arg}/");
		Directory.CreateDirectory(targetFolder);
		return targetFolder;
	}

	private static void DumpSceneGameObjects(string targetFolder, int sceneIndex)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Scene sceneAt = SceneManager.GetSceneAt(sceneIndex);
		Transform[] rootObjects = (from x in ((Scene)(ref sceneAt)).GetRootGameObjects()
			select x.transform).ToArray();
		targetFolder = GetOutputDirectoryForScene(targetFolder, sceneIndex, sceneAt);
		DumpGameObjects(targetFolder, rootObjects);
	}

	private static void DumpAllGameObjects(string targetFolder)
	{
		Transform[] rootObjects = TransformUtil.GetRootObjects();
		DumpGameObjects(targetFolder, rootObjects);
	}

	private static void DumpGameObjects(string targetFolder, Transform[] rootObjects)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All active game objects");
		stringBuilder.AppendLine();
		Transform[] array = rootObjects;
		foreach (Transform tx in array)
		{
			DumpGameObjectRecursive(stringBuilder, tx, 0);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Hierarchy.txt", stringBuilder.ToString());
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All active game objects including components");
		stringBuilder.AppendLine();
		array = rootObjects;
		foreach (Transform tx2 in array)
		{
			DumpGameObjectRecursive(stringBuilder, tx2, 0, includeComponents: true);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Hierarchy.Components.txt", stringBuilder.ToString());
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Root gameobjects, grouped by name, ordered by the total number of objects excluding children");
		stringBuilder.AppendLine();
		foreach (IGrouping<string, Transform> item in from x in rootObjects
			group x by ((Object)x).name into x
			orderby x.Count() descending
			select x)
		{
			Transform val = item.First();
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((Object)val).name, item.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Count.txt", stringBuilder.ToString());
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Root gameobjects, grouped by name, ordered by the total number of objects including children");
		stringBuilder.AppendLine();
		foreach (KeyValuePair<Transform, int> item2 in from x in rootObjects
			group x by ((Object)x).name into x
			select new KeyValuePair<Transform, int>(x.First(), x.Sum((Transform y) => y.GetAllChildren().Count)) into x
			orderby x.Value descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((Object)item2.Key).name, item2.Value);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Count.Children.txt", stringBuilder.ToString());
		Component[] source = (from x in rootObjects.SelectMany((Transform x) => ((Component)x).GetComponentsInChildren<Component>(true))
			where (Object)(object)x != (Object)null
			select x).ToArray();
		Object[] array2 = source.Select((Component x) => x.gameObject).Distinct().ToArray()
			.OfType<Object>()
			.Concat(source.OfType<Object>())
			.ToArray();
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All UnityEngine.Object active + inactive, ordered by count");
		stringBuilder.AppendLine($"Total: {array2.Length}");
		foreach (IGrouping<Type, Object> item3 in from x in array2
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((object)item3.First()).GetType().Name, item3.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object.Count.txt", stringBuilder.ToString());
	}

	private static void DumpGameObjectRecursive(StringBuilder str, Transform tx, int indent, bool includeComponents = false)
	{
		if ((Object)(object)tx == (Object)null)
		{
			return;
		}
		str.Append(' ', indent);
		str.Append(((Component)tx).gameObject.activeSelf ? "+ " : "- ");
		str.Append(((Object)tx).name);
		str.Append(" [").Append(((Component)tx).GetComponents<Component>().Length - 1).Append(']');
		str.AppendLine();
		if (includeComponents)
		{
			Component[] components = ((Component)tx).GetComponents<Component>();
			foreach (Component val in components)
			{
				if (!(val is Transform))
				{
					str.Append(' ', indent + 3);
					bool? flag = val.IsEnabled();
					if (!flag.HasValue)
					{
						str.Append("[~] ");
					}
					else if (flag == true)
					{
						str.Append("[] ");
					}
					else
					{
						str.Append("[ ] ");
					}
					str.Append(((Object)(object)val == (Object)null) ? "NULL" : ((object)val).GetType().ToString());
					str.AppendLine();
				}
			}
		}
		for (int j = 0; j < tx.childCount; j++)
		{
			DumpGameObjectRecursive(str, tx.GetChild(j), indent + 4, includeComponents);
		}
	}

	private static void DumpWarmup(string targetFolder)
	{
		DumpWarmupTimings(targetFolder);
		DumpWorldSpawnTimings(targetFolder);
	}

	private static void DumpWarmupTimings(string targetFolder)
	{
		if (!FileSystem_Warmup.GetWarmupTimes().Any())
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("index,prefab,time");
		int num = 0;
		foreach (var warmupTime in FileSystem_Warmup.GetWarmupTimes())
		{
			object arg = num;
			var (arg2, timeSpan) = warmupTime;
			stringBuilder.AppendLine($"{arg},{arg2},{timeSpan.Ticks * EventRecord.TicksToNS}");
			num++;
		}
		WriteTextToFile(targetFolder + "Asset.Warmup.csv", stringBuilder.ToString());
	}

	private static void DumpWorldSpawnTimings(string targetFolder)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (!World.GetSpawnTimings().Any())
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("index,prefab,time,category,position,rotation");
		int num = 0;
		foreach (World.SpawnTiming spawnTiming in World.GetSpawnTimings())
		{
			object[] obj = new object[6]
			{
				num,
				spawnTiming.prefab.Name,
				null,
				null,
				null,
				null
			};
			TimeSpan time = spawnTiming.time;
			obj[2] = time.Ticks * EventRecord.TicksToNS;
			obj[3] = spawnTiming.category;
			obj[4] = spawnTiming.position;
			obj[5] = spawnTiming.rotation;
			stringBuilder.AppendLine(string.Format("{0},{1},{2},{3},{4},{5}", obj));
			num++;
		}
		WriteTextToFile(targetFolder + "World.Spawn.csv", stringBuilder.ToString());
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;

public class DirectionalDamageTrigger : TriggerBase
{
	public float repeatRate = 1f;

	public List<DamageTypeEntry> damageType;

	public GameObjectRef attackEffect;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (!(baseEntity is BaseCombatEntity))
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)OnTick, repeatRate, repeatRate);
	}

	public override void OnEmpty()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
	}

	private void OnTick()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		if (attackEffect.isValid)
		{
			Effect.server.Run(attackEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		}
		if (entityContents == null)
		{
			return;
		}
		BaseEntity[] array = entityContents.ToArray();
		foreach (BaseEntity baseEntity in array)
		{
			if (baseEntity.IsValid())
			{
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				if (!((Object)(object)baseCombatEntity == (Object)null))
				{
					HitInfo hitInfo = new HitInfo();
					hitInfo.damageTypes.Add(damageType);
					hitInfo.DoHitEffects = true;
					hitInfo.DidHit = true;
					hitInfo.PointStart = ((Component)this).transform.position;
					hitInfo.PointEnd = ((Component)baseCombatEntity).transform.position;
					baseCombatEntity.Hurt(hitInfo);
				}
			}
		}
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[ExecuteInEditMode]
public class DofExposer : ListComponent<DofExposer>
{
	public PostProcessVolume PostVolume;

	public bool DofEnabled;

	public float FocalLength = 15.24f;

	public float Blur = 2f;

	public float FocalAperture = 13.16f;

	public float AnamorphicSqueeze;

	public float AnamorphicBarrel;

	public bool debug;
}


using UnityEngine;

public class DrawArrow : MonoBehaviour
{
	public Color color = new Color(1f, 1f, 1f, 1f);

	public float length = 0.2f;

	public float arrowLength = 0.02f;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 up = ((Component)Camera.current).transform.up;
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = ((Component)this).transform.position + forward * length;
		Gizmos.color = color;
		Gizmos.DrawLine(position, val);
		Gizmos.DrawLine(val, val + up * arrowLength - forward * arrowLength);
		Gizmos.DrawLine(val, val - up * arrowLength - forward * arrowLength);
		Gizmos.DrawLine(val + up * arrowLength - forward * arrowLength, val - up * arrowLength - forward * arrowLength);
	}
}


using UnityEngine;

public class DrawSkeleton : MonoBehaviour
{
	private void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.white;
		DrawTransform(((Component)this).transform);
	}

	private static void DrawTransform(Transform t)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < t.childCount; i++)
		{
			Gizmos.DrawLine(t.position, t.GetChild(i).position);
			DrawTransform(t.GetChild(i));
		}
	}
}


using System;
using System.Collections.Generic;
using Rust.UI.MainMenu;
using UnityEngine;

public class FakeSteamItemStub : IPlayerItemDefinition, IEquatable<IPlayerItemDefinition>
{
	private readonly SteamInventoryItem _steamItemSource;

	private readonly IPlayerItemDefinition _itemSource;

	public readonly ItemStoreTakeover TakeoverSource;

	private string tags;

	public IPlayerItemDefinition Source => _itemSource;

	public int DefinitionId => _steamItemSource.id;

	public string Name
	{
		get
		{
			if (!TakeoverSource.IsValid())
			{
				return _steamItemSource.displayName.translated;
			}
			return TakeoverSource.NameOverride.english;
		}
	}

	public string Description => string.Empty;

	public string Type
	{
		get
		{
			IPlayerItemDefinition itemSource = _itemSource;
			if (itemSource == null)
			{
				return null;
			}
			return itemSource.Type;
		}
	}

	public string IconUrl => string.Empty;

	public int LocalPrice => 0;

	public string LocalPriceFormatted
	{
		get
		{
			IPlayerItemDefinition itemSource = _itemSource;
			if (itemSource == null)
			{
				return null;
			}
			return itemSource.LocalPriceFormatted;
		}
	}

	public string PriceCategory
	{
		get
		{
			IPlayerItemDefinition itemSource = _itemSource;
			if (itemSource == null)
			{
				return null;
			}
			return itemSource.PriceCategory;
		}
	}

	public bool IsGenerator => false;

	public bool IsTradable => false;

	public bool IsMarketable => false;

	public string StoreTags => tags;

	public DateTime Created { get; }

	public DateTime Modified { get; }

	public string ItemShortName => _steamItemSource.itemname;

	public ulong WorkshopId
	{
		get
		{
			if (!(_steamItemSource is ItemSkin itemSkin))
			{
				return 0uL;
			}
			return itemSkin.workshopID;
		}
	}

	public ulong WorkshopDownload { get; }

	public FakeSteamItemStub(ItemStoreTakeover backing, IPlayerItemDefinition itemDef)
	{
		if ((Object)(object)backing.Item != (Object)null)
		{
			TakeoverSource = backing;
			_steamItemSource = backing.Item;
			_itemSource = itemDef;
		}
	}

	public FakeSteamItemStub(SteamInventoryItem steamInventoryItemSource)
	{
		_steamItemSource = steamInventoryItemSource;
	}

	public FakeSteamItemStub(SteamDLCItem dlcItemBacking)
	{
		SteamInventoryItem steamInventoryItem = ScriptableObject.CreateInstance<SteamInventoryItem>();
		steamInventoryItem.id = dlcItemBacking.dlcAppID;
		steamInventoryItem.displayName = dlcItemBacking.dlcName;
		tags = "DLC";
		_steamItemSource = steamInventoryItem;
	}

	public bool Equals(IPlayerItemDefinition other)
	{
		return other.DefinitionId == DefinitionId;
	}

	public IEnumerable<PlayerItemRecipe> GetRecipesContainingThis()
	{
		return null;
	}
}


using System;
using System.Threading;
using UnityEngine;

public class InvokeSpammer : MonoBehaviour
{
	public int InvokeMilliseconds = 1;

	public float RepeatTime = 0.6f;

	private void Start()
	{
		((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).InvokeRepeating((Action)TestInvoke, RepeatTime, RepeatTime);
	}

	private void TestInvoke()
	{
		Thread.Sleep(InvokeMilliseconds);
	}
}


using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class ItemButtonTools : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler, IScrollHandler
{
	public ScrollRect MainScroll;

	public Image image;

	public Image backgroundImage;

	public ItemDefinition itemDef;

	public void GiveSelf(int amount)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		DebugLog();
		ConsoleSystem.Run(Option.Client, "inventory.giveid", new object[2] { itemDef.itemid, amount });
	}

	public void GiveArmed()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		DebugLog();
		ConsoleSystem.Run(Option.Client, "inventory.givearm", new object[1] { itemDef.itemid });
	}

	public void GiveStack()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		DebugLog();
		ConsoleSystem.Run(Option.Client, "inventory.giveid", new object[2] { itemDef.itemid, itemDef.stackable });
	}

	public void GiveBlueprint()
	{
	}

	private void DebugLog()
	{
		if (Input.GetKey((KeyCode)308))
		{
			Debug.Log((object)((Object)((Component)itemDef).gameObject).name, (Object)(object)((Component)itemDef).gameObject);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		MainScroll.OnBeginDrag(eventData);
	}

	public void OnDrag(PointerEventData eventData)
	{
		MainScroll.OnDrag(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		MainScroll.OnEndDrag(eventData);
	}

	public void OnScroll(PointerEventData data)
	{
		MainScroll.OnScroll(data);
	}
}


using System.Linq;
using Facepunch.Extend;
using Rust;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ItemListTools : MonoBehaviour
{
	public GameObject categoryButton;

	public GameObject itemButtonPrefab;

	public Transform itemButtonParent;

	public RustInput searchInputText;

	internal Button lastCategory;

	public ScrollRect MainScrollRect;

	private IOrderedEnumerable<ItemDefinition> currentItems;

	private IOrderedEnumerable<ItemDefinition> allItems;

	public void OnPanelOpened()
	{
		CacheAllItems();
		Refresh();
		searchInputText.InputField.ActivateInputField();
	}

	private void OnOpenDevTools()
	{
		searchInputText.InputField.ActivateInputField();
	}

	private void CacheAllItems()
	{
		if (allItems == null)
		{
			allItems = from x in ItemManager.GetItemDefinitions()
				orderby x.displayName.translated
				select x;
		}
	}

	public void Refresh()
	{
		RebuildCategories();
	}

	private void RebuildCategories()
	{
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Expected O, but got Unknown
		for (int i = 0; i < categoryButton.transform.parent.childCount; i++)
		{
			Transform child = categoryButton.transform.parent.GetChild(i);
			if (!((Object)(object)child == (Object)(object)categoryButton.transform))
			{
				GameManager.Destroy(((Component)child).gameObject);
			}
		}
		categoryButton.SetActive(true);
		foreach (IGrouping<ItemCategory, ItemDefinition> item in from x in ItemManager.GetItemDefinitions()
			group x by x.category into x
			orderby x.First().category
			select x)
		{
			GameObject val = Object.Instantiate<GameObject>(categoryButton);
			val.transform.SetParent(categoryButton.transform.parent, false);
			((TMP_Text)val.GetComponentInChildren<TextMeshProUGUI>()).text = item.First().category.ToString();
			Button btn = val.GetComponentInChildren<Button>();
			ItemDefinition[] itemArray = item.ToArray();
			((UnityEvent)btn.onClick).AddListener((UnityAction)delegate
			{
				if (Object.op_Implicit((Object)(object)lastCategory))
				{
					((Selectable)lastCategory).interactable = true;
				}
				lastCategory = btn;
				((Selectable)lastCategory).interactable = false;
				SwitchItemCategory(itemArray);
			});
			if ((Object)(object)lastCategory == (Object)null)
			{
				lastCategory = btn;
				((Selectable)lastCategory).interactable = false;
				SwitchItemCategory(itemArray);
			}
		}
		categoryButton.SetActive(false);
	}

	private void SwitchItemCategory(ItemDefinition[] defs)
	{
		currentItems = defs.OrderBy((ItemDefinition x) => x.displayName.translated);
		searchInputText.Text = "";
		FilterItems(null);
		MainScrollRect.verticalNormalizedPosition = 1f;
	}

	public void FilterItems(string searchText)
	{
		if ((Object)(object)itemButtonPrefab == (Object)null)
		{
			return;
		}
		TransformEx.DestroyAllChildren(itemButtonParent, false);
		bool flag = !string.IsNullOrEmpty(searchText);
		string search = (flag ? searchText.ToLower() : null);
		IOrderedEnumerable<ItemDefinition> obj = (flag ? allItems : currentItems);
		int num = 0;
		foreach (ItemDefinition item in obj)
		{
			if (!item.Hidden() && (!flag || ItemSearchUtils.IsValidSearchResult(search, item, checkItemIsValid: false)))
			{
				GameObject obj2 = Object.Instantiate<GameObject>(itemButtonPrefab, itemButtonParent);
				((TMP_Text)obj2.GetComponentInChildren<TextMeshProUGUI>()).text = item.displayName.translated;
				obj2.GetComponentInChildren<ItemButtonTools>().itemDef = item;
				obj2.GetComponentInChildren<ItemButtonTools>().MainScroll = MainScrollRect;
				obj2.GetComponentInChildren<ItemButtonTools>().image.sprite = item.iconSprite;
				((Behaviour)obj2.GetComponentInChildren<ItemButtonTools>().backgroundImage).enabled = (Object)(object)item != (Object)null && !item.IsAllowed((EraRestriction)0);
				num++;
				if (num >= 160)
				{
					break;
				}
			}
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class MeshTrimTester : MonoBehaviour
{
	public MeshTrimSettings Settings = MeshTrimSettings.Default;

	public Mesh SourceMesh;

	public MeshFilter TargetMeshFilter;

	public int SubtractIndex;
}


using UnityEngine;

public class MoveObjectOverTime : MonoBehaviour
{
	public Transform Mover;

	public Vector3 OffsetAmount;

	public float Speed = 1f;
}


using Network;
using TMPro;
using UnityEngine;

public class NetworkInfoGeneralText : MonoBehaviour
{
	public TextMeshProUGUI text;

	private void Update()
	{
		UpdateText();
	}

	private void UpdateText()
	{
		string text = "";
		if (Net.sv != null)
		{
			text += "Server\n";
			text += ((BaseNetwork)Net.sv).GetDebug((Connection)null);
			text += "\n";
		}
		((TMP_Text)this.text).text = text;
	}

	private static string ChannelStat(int window, int left)
	{
		return $"{left}/{window}";
	}
}


using UnityEngine;

public class ObjectSpam : MonoBehaviour
{
	public GameObject source;

	public int amount = 1000;

	public float radius;

	private void Start()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < amount; i++)
		{
			GameObject obj = Object.Instantiate<GameObject>(source);
			obj.transform.position = ((Component)this).transform.position + Vector3Ex.Range(0f - radius, radius);
			((Object)obj).hideFlags = (HideFlags)3;
		}
	}
}


using UnityEngine;

public class PingPongRotate : MonoBehaviour
{
	public Vector3 rotationSpeed = Vector3.zero;

	public Vector3 offset = Vector3.zero;

	public Vector3 rotationAmount = Vector3.zero;

	private void Update()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.identity;
		for (int i = 0; i < 3; i++)
		{
			val *= GetRotation(i);
		}
		((Component)this).transform.rotation = val;
	}

	public Quaternion GetRotation(int index)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		switch (index)
		{
		case 0:
			val = Vector3.right;
			break;
		case 1:
			val = Vector3.up;
			break;
		case 2:
			val = Vector3.forward;
			break;
		}
		return Quaternion.AngleAxis(Mathf.Sin((((Vector3)(ref offset))[index] + Time.time) * ((Vector3)(ref rotationSpeed))[index]) * ((Vector3)(ref rotationAmount))[index], val);
	}
}


using UnityEngine;

public class RotateObject : MonoBehaviour
{
	public float rotateSpeed_X = 1f;

	public float rotateSpeed_Y = 1f;

	public float rotateSpeed_Z = 1f;

	public bool localSpace;

	public bool randomizeRotation;

	public Vector3 randomVariationRange = new Vector3(0.5f, 0.5f, 0.5f);

	private void Start()
	{
		if (randomizeRotation)
		{
			rotateSpeed_Y = Random.Range(0f - Mathf.Abs(rotateSpeed_X), Mathf.Abs(rotateSpeed_X));
			rotateSpeed_Z = Random.Range(0f - Mathf.Abs(rotateSpeed_X), Mathf.Abs(rotateSpeed_X));
		}
		rotateSpeed_X *= 1f + Random.Range(0f - randomVariationRange.x, randomVariationRange.x);
		rotateSpeed_Y *= 1f + Random.Range(0f - randomVariationRange.y, randomVariationRange.y);
		rotateSpeed_Z *= 1f + Random.Range(0f - randomVariationRange.z, randomVariationRange.z);
	}

	protected void Update()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		if (localSpace)
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(rotateSpeed_X, rotateSpeed_Y, rotateSpeed_Z);
			((Component)this).transform.Rotate(val * Time.deltaTime, (Space)1);
			return;
		}
		if (rotateSpeed_X != 0f)
		{
			((Component)this).transform.Rotate(Vector3.up, Time.deltaTime * rotateSpeed_X);
		}
		if (rotateSpeed_Y != 0f)
		{
			((Component)this).transform.Rotate(((Component)this).transform.forward, Time.deltaTime * rotateSpeed_Y);
		}
		if (rotateSpeed_Z != 0f)
		{
			((Component)this).transform.Rotate(((Component)this).transform.right, Time.deltaTime * rotateSpeed_Z);
		}
	}
}


public static class SafeMode
{
}


using UnityEngine;
using UnityEngine.UI;

public class SeedPosInfo : MonoBehaviour
{
	public CanvasGroup Canvas;

	public Text WorldPos;

	public Text LevelName;

	public Text WorldSize;

	public Text Seed;
}


using System;
using ConVar;
using Facepunch;
using UnityEngine;

public class ServerConsole : SingletonComponent<ServerConsole>
{
	private static bool consoleEnabled => !CommandLine.HasSwitch("-noconsole");

	private DateTime currentGameTime
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)TOD_Sky.Instance))
			{
				return DateTime.Now;
			}
			return TOD_Sky.Instance.Cycle.DateTime;
		}
	}

	private int currentPlayerCount => BasePlayer.activePlayerList.Count;

	private int maxPlayerCount => Server.maxplayers;

	private int currentEntityCount => BaseNetworkable.serverEntities.Count;

	private int currentSleeperCount => BasePlayer.sleepingPlayerList.Count;

	public void OnEnable()
	{
	}

	private void OnDisable()
	{
		Output.OnMessage -= HandleLog;
	}

	private void OnInputText(string obj)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		ConsoleSystem.Run(Option.Server, obj, Array.Empty<object>());
	}

	public static void PrintColoured(params object[] objects)
	{
	}

	private void HandleLog(string message, string stackTrace, LogType type)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Invalid comparison between Unknown and I4
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Invalid comparison between Unknown and I4
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Invalid comparison between Unknown and I4
		if (message.StartsWith("[CHAT]") || message.StartsWith("[TEAM CHAT]") || message.StartsWith("[CARDS CHAT]"))
		{
			return;
		}
		if ((int)type == 2)
		{
			if (!message.StartsWith("HDR RenderTexture format is not") && !message.StartsWith("The image effect") && !message.StartsWith("Image Effects are not supported on this platform") && !message.StartsWith("[AmplifyColor]") && !message.StartsWith("Skipping profile frame.") && !message.StartsWith("Kinematic body only supports Speculative Continuous collision detection"))
			{
				System.Console.ForegroundColor = ConsoleColor.Yellow;
			}
		}
		else if ((int)type == 0)
		{
			System.Console.ForegroundColor = ConsoleColor.Red;
		}
		else if ((int)type == 4)
		{
			System.Console.ForegroundColor = ConsoleColor.Red;
		}
		else if ((int)type == 1)
		{
			System.Console.ForegroundColor = ConsoleColor.Red;
		}
		else
		{
			System.Console.ForegroundColor = ConsoleColor.Gray;
		}
	}
}


using System;
using System.Runtime.InteropServices;
using UnityEngine;

public static class SystemInfoEx
{
	private static bool[] supportedRenderTextureFormats;

	public static int systemMemoryUsed => (int)(System_GetMemoryUsage() / 1024 / 1024);

	[DllImport("RustNative")]
	private static extern ulong System_GetMemoryUsage();

	public static bool SupportsRenderTextureFormat(RenderTextureFormat format)
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if (supportedRenderTextureFormats == null)
		{
			Array values = Enum.GetValues(typeof(RenderTextureFormat));
			int num = (int)values.GetValue(values.Length - 1);
			supportedRenderTextureFormats = new bool[num + 1];
			for (int i = 0; i <= num; i++)
			{
				bool flag = Enum.IsDefined(typeof(RenderTextureFormat), i);
				supportedRenderTextureFormats[i] = flag && SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)i);
			}
		}
		return supportedRenderTextureFormats[format];
	}
}


using System.Text;
using Rust;
using TMPro;
using UnityEngine;

public class SystemInfoGeneralText : MonoBehaviour
{
	public TextMeshProUGUI text;

	public static string currentInfo
	{
		get
		{
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: false);
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("System");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tName: ");
			stringBuilder.Append(SystemInfo.deviceName);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tOS:   ");
			stringBuilder.Append(SystemInfo.operatingSystem);
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("CPU");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tModel:  ");
			stringBuilder.Append(SystemInfo.processorType);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tCores:  ");
			stringBuilder.Append(SystemInfo.processorCount);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory: ");
			stringBuilder.Append(SystemInfo.systemMemorySize);
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("GPU");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tModel:  ");
			stringBuilder.Append(SystemInfo.graphicsDeviceName);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tAPI:    ");
			stringBuilder.Append(SystemInfo.graphicsDeviceVersion);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory: ");
			stringBuilder.Append(SystemInfo.graphicsMemorySize);
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tSM:     ");
			stringBuilder.Append(SystemInfo.graphicsShaderLevel);
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("Process");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory:   ");
			stringBuilder.Append(SystemInfoEx.systemMemoryUsed);
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("Mono");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tCollects: ");
			stringBuilder.Append(GC.CollectionCount());
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory:   ");
			stringBuilder.Append(GC.GetTotalMemory());
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			if (World.Seed != 0 && World.Size != 0)
			{
				stringBuilder.Append("World");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tSeed:        ");
				if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.ingameMap)
				{
					stringBuilder.Append("?");
				}
				else
				{
					stringBuilder.Append(World.Seed);
				}
				stringBuilder.AppendLine();
				stringBuilder.Append("\tSize:        ");
				stringBuilder.Append(KM2(World.Size));
				stringBuilder.Append(" km");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tHeightmap:   ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) ? TerrainMeta.HeightMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tWatermap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) ? TerrainMeta.WaterMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tSplatmap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.SplatMap) ? TerrainMeta.SplatMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tBiomemap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tTopologymap: ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) ? TerrainMeta.TopologyMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tAlphamap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.AlphaMap) ? TerrainMeta.AlphaMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
			}
			stringBuilder.AppendLine();
			if (!string.IsNullOrEmpty(World.Checksum))
			{
				stringBuilder.AppendLine("Checksum");
				stringBuilder.Append('\t');
				stringBuilder.AppendLine(World.Checksum);
			}
			return stringBuilder.ToString();
		}
	}

	protected void Update()
	{
		((TMP_Text)text).text = currentInfo;
	}

	private static long MB(long bytes)
	{
		return bytes / 1048576;
	}

	private static long MB(ulong bytes)
	{
		return MB((long)bytes);
	}

	private static int KM2(float meters)
	{
		return Mathf.RoundToInt(meters * meters * 1E-06f);
	}
}


using UnityEngine;

public class TriangleIdentifier : MonoBehaviour
{
	public int TriangleID;

	public int SubmeshID;

	public float LineLength = 1.5f;

	private void OnDrawGizmosSelected()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		MeshFilter component = ((Component)this).GetComponent<MeshFilter>();
		if (!((Object)(object)component == (Object)null) && !((Object)(object)component.sharedMesh == (Object)null))
		{
			int[] triangles = component.sharedMesh.GetTriangles(SubmeshID);
			if (TriangleID >= 0 && TriangleID * 3 <= triangles.Length)
			{
				Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
				Vector3 val = component.sharedMesh.vertices[TriangleID * 3];
				Vector3 val2 = component.sharedMesh.vertices[TriangleID * 3 + 1];
				Vector3 val3 = component.sharedMesh.vertices[TriangleID * 3 + 2];
				Vector3 val4 = component.sharedMesh.normals[TriangleID * 3];
				Vector3 val5 = component.sharedMesh.normals[TriangleID * 3 + 1];
				Vector3 val6 = component.sharedMesh.normals[TriangleID * 3 + 2];
				Vector3 val7 = (val + val2 + val3) / 3f;
				Vector3 val8 = (val4 + val5 + val6) / 3f;
				Gizmos.DrawLine(val7, val7 + val8 * LineLength);
			}
		}
	}
}


[JsonModel]
public struct ClientPerformanceReport
{
	public int request_id;

	public string user_id;

	public float fps_average;

	public int fps;

	public int frame_id;

	public float frame_time;

	public float frame_time_average;

	public long memory_system;

	public long memory_collections;

	public long memory_managed_heap;

	public float realtime_since_startup;

	public bool streamer_mode;

	public int ping;

	public int tasks_invokes;

	public int tasks_load_balancer;

	public int workshop_skins_queued;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DevBotSpawner : FacepunchBehaviour
{
	public GameObjectRef bot;

	public Transform waypointParent;

	public bool autoSelectLatestSpawnedGameObject = true;

	public float spawnRate = 1f;

	public int maxPopulation = 1;

	private Transform[] waypoints;

	private List<BaseEntity> _spawned = new List<BaseEntity>();

	public bool HasFreePopulation()
	{
		for (int num = _spawned.Count - 1; num >= 0; num--)
		{
			BaseEntity baseEntity = _spawned[num];
			if ((Object)(object)baseEntity == (Object)null || baseEntity.Health() <= 0f)
			{
				_spawned.Remove(baseEntity);
			}
		}
		if (_spawned.Count < maxPopulation)
		{
			return true;
		}
		return false;
	}

	public void SpawnBot()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		while (HasFreePopulation())
		{
			Vector3 position = waypoints[0].position;
			BaseEntity baseEntity = GameManager.server.CreateEntity(bot.resourcePath, position);
			if ((Object)(object)baseEntity == (Object)null)
			{
				break;
			}
			_spawned.Add(baseEntity);
			((Component)baseEntity).SendMessage("SetWaypoints", (object)waypoints, (SendMessageOptions)1);
			baseEntity.Spawn();
		}
	}

	public void Start()
	{
		waypoints = ((Component)waypointParent).GetComponentsInChildren<Transform>();
		((FacepunchBehaviour)this).InvokeRepeating((Action)SpawnBot, 5f, spawnRate);
	}
}


using UnityEngine;

public class DevCamera : MonoBehaviour
{
	public float movementScale = 1f;
}


using UnityEngine;

[ExecuteInEditMode]
public class DevControls : MonoBehaviour
{
	public GUISkin skin;
}


public class DevControlsTab : BaseMonoBehaviour
{
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class DevDressPlayer : MonoBehaviour
{
	public bool DressRandomly;

	public List<ItemAmount> clothesToWear;

	private void ServerInitComponent()
	{
		BasePlayer component = ((Component)this).GetComponent<BasePlayer>();
		if (DressRandomly)
		{
			DoRandomClothes(component);
		}
		foreach (ItemAmount item in clothesToWear)
		{
			if (!((Object)(object)item.itemDef == (Object)null))
			{
				ItemManager.Create(item.itemDef, 1, 0uL).MoveToContainer(component.inventory.containerWear);
			}
		}
	}

	private void DoRandomClothes(BasePlayer player)
	{
		string text = "";
		foreach (ItemDefinition item in (from x in ItemManager.GetItemDefinitions()
			where Object.op_Implicit((Object)(object)((Component)x).GetComponent<ItemModWearable>())
			orderby Guid.NewGuid()
			select x).Take(Random.Range(0, 4)))
		{
			ItemManager.Create(item, 1, 0uL).MoveToContainer(player.inventory.containerWear);
			text = text + item.shortname + " ";
		}
		text = text.Trim();
		if (text == "")
		{
			text = "naked";
		}
		player.displayName = text;
	}
}


using System.Linq;
using Facepunch;
using Facepunch.Models;
using UnityEngine;

public static class DeveloperList
{
	public static bool Contains(string steamid)
	{
		if (Application.Manifest == null)
		{
			return false;
		}
		if (Application.Manifest.Administrators == null)
		{
			return false;
		}
		return Application.Manifest.Administrators.Any((Administrator x) => x.UserId == steamid);
	}

	public static bool Contains(ulong steamid)
	{
		return Contains(steamid.ToString());
	}

	public static bool IsDeveloper(BasePlayer ply)
	{
		if ((Object)(object)ply != (Object)null)
		{
			return Contains(ply.UserIDString);
		}
		return false;
	}
}


using UnityEngine;

public class DevEnableDisable : DevControlsTab
{
	public GameObject[] Objects;

	public string CookieName = "Cookie";

	public string TabName = "Scene";
}


public class DevEnvironment : DevControlsTab
{
	public TOD_Sky sky;
}


using UnityEngine;

public class DevImpactEffectTest : MonoBehaviour
{
}


using System;
using UnityEngine;

public class DevMovePlayer : BaseMonoBehaviour
{
	public BasePlayer player;

	public Transform[] Waypoints;

	public bool moveRandomly;

	public Vector3 destination = Vector3.zero;

	public Vector3 lookPoint = Vector3.zero;

	private int waypointIndex;

	private float randRun;

	public void Awake()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		randRun = Random.Range(5f, 10f);
		player = ((Component)this).GetComponent<BasePlayer>();
		if (Waypoints.Length != 0)
		{
			destination = Waypoints[0].position;
		}
		else
		{
			destination = ((Component)this).transform.position;
		}
		if (!player.isClient)
		{
			if ((Object)(object)player.eyes == (Object)null)
			{
				player.eyes = ((Component)player).GetComponent<PlayerEyes>();
			}
			((FacepunchBehaviour)this).Invoke((Action)LateSpawn, 1f);
		}
	}

	public void LateSpawn()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		Item item = ItemManager.CreateByName("rifle.semiauto", 1, 0uL);
		player.inventory.GiveItem(item, player.inventory.containerBelt);
		player.UpdateActiveItem(item.uid);
		player.health = 100f;
	}

	public void SetWaypoints(Transform[] wps)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Waypoints = wps;
		destination = wps[0].position;
	}

	public void Update()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		if (player.isClient || !player.IsAlive() || player.IsWounded())
		{
			return;
		}
		if (Vector3.Distance(destination, ((Component)this).transform.position) < 0.25f)
		{
			if (moveRandomly)
			{
				waypointIndex = Random.Range(0, Waypoints.Length);
			}
			else
			{
				waypointIndex++;
			}
			if (waypointIndex >= Waypoints.Length)
			{
				waypointIndex = 0;
			}
		}
		if (Waypoints.Length > waypointIndex)
		{
			destination = Waypoints[waypointIndex].position;
			Vector3 val = destination - ((Component)this).transform.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float running = Mathf.Sin(Time.time + randRun);
			float speed = player.GetSpeed(running, 0f, 0f);
			Vector3 position = ((Component)this).transform.position;
			float range = 1f;
			LayerMask mask = LayerMask.op_Implicit(1537286401);
			if (TransformUtil.GetGroundInfo(((Component)this).transform.position + normalized * speed * Time.deltaTime, out var hitOut, range, mask, ((Component)player).transform))
			{
				position = ((RaycastHit)(ref hitOut)).point;
			}
			((Component)this).transform.position = position;
			val = new Vector3(destination.x, 0f, destination.z) - new Vector3(((Component)player).transform.position.x, 0f, ((Component)player).transform.position.z);
			_ = ((Vector3)(ref val)).normalized;
			player.SendNetworkUpdate();
		}
	}
}


using UnityEngine;

public class DevTimeAdjust : MonoBehaviour
{
	private void Start()
	{
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			TOD_Sky.Instance.Cycle.Hour = PlayerPrefs.GetFloat("DevTime");
		}
	}

	private void OnGUI()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			float num = (float)Screen.width * 0.2f;
			Rect val = default(Rect);
			((Rect)(ref val))..ctor((float)Screen.width - (num + 20f), (float)Screen.height - 30f, num, 20f);
			float hour = TOD_Sky.Instance.Cycle.Hour;
			hour = GUI.HorizontalSlider(val, hour, 0f, 24f);
			((Rect)(ref val)).y = ((Rect)(ref val)).y - 20f;
			GUI.Label(val, "Time Of Day");
			if (hour != TOD_Sky.Instance.Cycle.Hour)
			{
				TOD_Sky.Instance.Cycle.Hour = hour;
				PlayerPrefs.SetFloat("DevTime", hour);
			}
		}
	}
}


using System;
using UnityEngine;

public class DevWeatherAdjust : MonoBehaviour
{
	protected void Awake()
	{
		SingletonComponent<Climate>.Instance.Overrides.Clouds = 0f;
		SingletonComponent<Climate>.Instance.Overrides.Fog = 0f;
		SingletonComponent<Climate>.Instance.Overrides.Wind = 0f;
		SingletonComponent<Climate>.Instance.Overrides.Rain = 0f;
	}

	protected void OnGUI()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)Screen.width * 0.2f;
		GUILayout.BeginArea(new Rect((float)Screen.width - num - 20f, 20f, num, 400f), "", GUIStyle.op_Implicit("box"));
		GUILayout.Box("Weather", Array.Empty<GUILayoutOption>());
		GUILayout.FlexibleSpace();
		GUILayout.Label("Clouds", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Clouds = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Clouds, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.Label("Fog", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Fog = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Fog, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.Label("Wind", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Wind = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Wind, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.Label("Rain", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Rain = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Rain, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.FlexibleSpace();
		GUILayout.EndArea();
	}
}


using System.Collections.Generic;

[JsonModel]
public class ClientFrametimeReport
{
	public int request_id;

	public int start_frame;

	public List<int> frame_times;
}


[JsonModel]
public class ClientFrametimeRequest
{
	public int request_id;

	public int start_frame;

	public int max_frames;
}


using System.Collections.Generic;
using UnityEngine;

public class GameContentList : MonoBehaviour
{
	public enum ResourceType
	{
		Audio,
		Textures,
		Models
	}

	public ResourceType resourceType;

	public List<Object> foundObjects;
}


public enum ResourceType
{
	Audio,
	Textures,
	Models
}


public static class ItemIconUpload
{
}


using UnityEngine;

public class ItemTools : MonoBehaviour
{
}


using UnityEngine;

public class LodLevelDisplay : MonoBehaviour, IEditorComponent
{
	public Color TextColor = Color.green;

	[Range(1f, 6f)]
	public float TextScaleMultiplier = 1f;
}


using UnityEngine;

public class MidiConvar : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using Rust.Workshop;
using UnityEngine;

public class Performance : SingletonComponent<Performance>
{
	public struct Tick
	{
		public int frameID;

		public int frameRate;

		public float frameTime;

		public float frameRateAverage;

		public float frameTimeAverage;

		public long memoryUsageSystem;

		public long memoryAllocations;

		public long memoryCollections;

		public long loadBalancerTasks;

		public long invokeHandlerTasks;

		public long workshopSkinsQueued;

		public int ping;

		public bool gcTriggered;

		public PerformanceSamplePoint performanceSample;
	}

	private struct LagSpike
	{
		public int Index;

		public int Time;
	}

	public static Tick current;

	public static Tick report;

	public const int FrameHistoryCount = 1000;

	private const int HistoryLength = 60;

	private static long cycles = 0L;

	private static int[] frameRateHistory = new int[60];

	private static float[] frameTimeHistory = new float[60];

	private static int[] frameTimes = new int[1000];

	private int frames;

	private float time;

	private void Update()
	{
		frameTimes[Time.frameCount % 1000] = (int)(1000f * Time.deltaTime);
		TimeWarning val = TimeWarning.New("FPSTimer", 0);
		try
		{
			FPSTimer();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public List<int> GetFrameTimes(int requestedStart, int maxCount, out int startIndex)
	{
		startIndex = Math.Max(requestedStart, Math.Max(Time.frameCount - 1000 - 1, 0));
		int num = Math.Min(Math.Min(1000, maxCount), Time.frameCount);
		List<int> list = Pool.Get<List<int>>();
		for (int i = 0; i < num; i++)
		{
			int num2 = (startIndex + i) % 1000;
			list.Add(frameTimes[num2]);
		}
		return list;
	}

	private void FPSTimer()
	{
		frames++;
		time += Time.unscaledDeltaTime;
		if (!(time < 1f))
		{
			long memoryCollections = current.memoryCollections;
			current.frameID = Time.frameCount;
			current.frameRate = frames;
			current.frameTime = time / (float)frames * 1000f;
			frameRateHistory[cycles % frameRateHistory.Length] = current.frameRate;
			frameTimeHistory[cycles % frameTimeHistory.Length] = current.frameTime;
			current.frameRateAverage = AverageFrameRate();
			current.frameTimeAverage = AverageFrameTime();
			current.memoryUsageSystem = SystemInfoEx.systemMemoryUsed;
			current.memoryAllocations = Rust.GC.GetTotalMemory();
			current.memoryCollections = Rust.GC.CollectionCount();
			current.loadBalancerTasks = LoadBalancer.Count();
			current.invokeHandlerTasks = InvokeHandler.Count();
			current.workshopSkinsQueued = WorkshopSkin.QueuedCount;
			current.performanceSample = PerformanceMetrics.PerformancePerSecond;
			PerformanceMetrics.PerformancePerSecond = default(PerformanceSamplePoint);
			current.gcTriggered = memoryCollections != current.memoryCollections;
			frames = 0;
			time = 0f;
			cycles++;
			report = current;
		}
	}

	private float AverageFrameRate()
	{
		float num = 0f;
		int num2 = Math.Min(frameRateHistory.Length, (int)cycles);
		for (int i = 0; i < num2; i++)
		{
			num += (float)frameRateHistory[i];
		}
		return num / (float)num2;
	}

	private float AverageFrameTime()
	{
		float num = 0f;
		int num2 = Math.Min(frameTimeHistory.Length, (int)cycles);
		for (int i = 0; i < frameTimeHistory.Length; i++)
		{
			num += frameTimeHistory[i];
		}
		return num / (float)num2;
	}
}


public struct Tick
{
	public int frameID;

	public int frameRate;

	public float frameTime;

	public float frameRateAverage;

	public float frameTimeAverage;

	public long memoryUsageSystem;

	public long memoryAllocations;

	public long memoryCollections;

	public long loadBalancerTasks;

	public long invokeHandlerTasks;

	public long workshopSkinsQueued;

	public int ping;

	public bool gcTriggered;

	public PerformanceSamplePoint performanceSample;
}


private struct LagSpike
{
	public int Index;

	public int Time;
}


using UnityEngine;

public class PrefabPrepare : MonoBehaviour
{
}


using UnityEngine;

public class PrefabValidate : MonoBehaviour
{
}


using UnityEngine;

public class ProjectileTestSpawner : MonoBehaviour
{
	public Projectile TargetProjectile;

	public float RepeatTime = 1f;

	public float VelocityScale = 1f;
}


using UnityEngine;

public class SteamInventoryGen : MonoBehaviour
{
}


using Rust;
using UnityEngine;

public class DoorAnimEvents : MonoBehaviour, IClientComponent
{
	public GameObjectRef openStart;

	public GameObjectRef openEnd;

	public GameObjectRef closeStart;

	public GameObjectRef closeEnd;

	public GameObject soundTarget;

	public bool checkAnimSpeed;

	public Animator animator => ((Component)this).GetComponent<Animator>();

	public void DoorOpenStart()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !openStart.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime > 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed < 0f)
			{
				return;
			}
		}
		Effect.client.Run(openStart.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}

	public void DoorOpenEnd()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !openEnd.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime < 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed < 0f)
			{
				return;
			}
		}
		Effect.client.Run(openEnd.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}

	public void DoorCloseStart()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !closeStart.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime > 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed > 0f)
			{
				return;
			}
		}
		Effect.client.Run(closeStart.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}

	public void DoorCloseEnd()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !closeEnd.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime < 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed > 0f)
			{
				return;
			}
		}
		Effect.client.Run(closeEnd.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}
}


using UnityEngine;

public class AnimationEvents : BaseMonoBehaviour
{
	public Transform rootObject;

	public HeldEntity targetEntity;

	[Tooltip("Path to the effect folder for these animations. Relative to this object.")]
	public string effectFolder;

	public bool enforceClipWeights;

	public string localFolder;

	[Tooltip("If true the localFolder field won't update with manifest updates, use for custom paths")]
	public bool customLocalFolder;

	public HeldEntity worldModelEntity;

	public bool IsBusy;

	protected void OnEnable()
	{
		if ((Object)(object)rootObject == (Object)null)
		{
			rootObject = ((Component)this).transform;
		}
	}
}


using UnityEngine;

public class AnimationEventsStub : MonoBehaviour
{
}


using UnityEngine;

public abstract class BaseFootstepEffect : MonoBehaviour, IClientComponent
{
	public LayerMask validImpactLayers = LayerMask.op_Implicit(-1);
}


using UnityEngine;

public class BucketVMFluidSim : MonoBehaviour, IClientComponent
{
	public Animator waterbucketAnim;

	public ParticleSystem waterPour;

	public ParticleSystem waterTurbulence;

	public ParticleSystem waterFill;

	public float waterLevel;

	public float targetWaterLevel;

	public AudioSource waterSpill;
}


using UnityEngine;

public class ColdBreath : BaseMonoBehaviour
{
	public GameObjectRef effect;

	private BasePlayer player;

	private Transform jawBone;
}


using System.Collections.Generic;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;

public class Effect : EffectData
{
	public enum Type : uint
	{
		Generic,
		Projectile,
		GenericGlobal
	}

	public static class client
	{
		public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
		{
		}

		public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
		{
			string.IsNullOrEmpty(strName);
		}

		public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3))
		{
		}

		public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3), Type overrideType = Type.Generic)
		{
			string.IsNullOrEmpty(strName);
		}

		public static void Run(string strName, GameObject obj)
		{
			string.IsNullOrEmpty(strName);
		}

		public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			if (info.HitEntity.IsValid())
			{
				Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal + info.HitNormalLocal * 0.1f, info.HitNormalLocal);
			}
			else
			{
				Run(effectName, info.HitPositionWorld + info.HitNormalWorld * 0.1f, info.HitNormalWorld);
			}
		}

		private static bool CanPlayImpactEffect(HitInfo info)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
			{
				return false;
			}
			return true;
		}

		private static Type GetOverrideType(HitInfo info)
		{
			return Type.Generic;
		}

		private static void HandleAdditiveEffects(HitInfo info)
		{
			if (info.damageTypes.Has(DamageType.Explosion))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
			}
			if (info.damageTypes.Has(DamageType.Heat))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
			}
		}

		public static void ImpactEffect(HitInfo info, string customEffect = null)
		{
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0156: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			if (!info.DoHitEffects)
			{
				return;
			}
			string materialName = StringPool.Get(info.HitMaterial);
			string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
			string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
			if (!CanPlayImpactEffect(info))
			{
				return;
			}
			if (info.HitEntity.IsValid())
			{
				if (customEffect == null)
				{
					GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
					if (impactEffect.isValid)
					{
						strName = impactEffect.resourcePath;
					}
				}
				Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
				if (info.DoDecals)
				{
					Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
				}
			}
			else
			{
				Type overrideType = GetOverrideType(info);
				Run(strName, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
				Run(decal, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
			}
			if (info.WeaponPrefab is BaseMelee baseMelee)
			{
				string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
				if (info.HitEntity.IsValid())
				{
					Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
				}
				else
				{
					Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld);
				}
			}
			HandleAdditiveEffects(info);
		}
	}

	public static class server
	{
		public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			reusableInstace.Init(fxtype, ent, boneID, posLocal, normLocal, sourceConnection);
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}

		public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			if (!string.IsNullOrEmpty(strName))
			{
				reusableInstace.Init(Type.Generic, ent, boneID, posLocal, normLocal, sourceConnection);
				reusableInstace.pooledString = strName;
				reusableInstace.broadcast = broadcast;
				reusableInstace.targets = targets;
				EffectNetwork.Send(reusableInstace);
			}
		}

		public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			reusableInstace.Init(fxtype, posWorld, normWorld, sourceConnection);
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}

		public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			if (!string.IsNullOrEmpty(strName))
			{
				reusableInstace.Init(Type.Generic, posWorld, normWorld, sourceConnection);
				reusableInstace.pooledString = strName;
				reusableInstace.broadcast = broadcast;
				reusableInstace.targets = targets;
				EffectNetwork.Send(reusableInstace);
			}
		}

		public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			if (info.HitEntity.IsValid())
			{
				Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			}
			else
			{
				Run(effectName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			}
		}

		private static bool CanPlayImpactEffect(HitInfo info)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
			{
				return false;
			}
			return true;
		}

		private static void HandleAdditiveEffects(HitInfo info)
		{
			if (info.damageTypes.Has(DamageType.Explosion))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
			}
			if (info.damageTypes.Has(DamageType.Heat))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
			}
		}

		private static void HandleWeaponEffects(HitInfo info, string materialName)
		{
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)info.WeaponPrefab))
			{
				return;
			}
			BaseMelee baseMelee = info.WeaponPrefab as BaseMelee;
			if ((Object)(object)baseMelee != (Object)null)
			{
				string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
				if (info.HitEntity.IsValid())
				{
					Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
				}
				else
				{
					Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
				}
			}
		}

		private static bool IsLegalPlacement(HitInfo info)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			Bounds bounds = info.HitEntity.bounds;
			float num = info.HitEntity.BoundsPadding();
			((Bounds)(ref bounds)).extents = ((Bounds)(ref bounds)).extents + new Vector3(num, num, num);
			if (!((Bounds)(ref bounds)).Contains(info.HitPositionLocal))
			{
				BasePlayer initiatorPlayer = info.InitiatorPlayer;
				if ((Object)(object)initiatorPlayer != (Object)null && ((object)initiatorPlayer).GetType() == typeof(BasePlayer))
				{
					float num2 = Mathf.Sqrt(((Bounds)(ref bounds)).SqrDistance(info.HitPositionLocal));
					if (num2 > ConVar.AntiHack.impact_effect_distance_forgiveness)
					{
						AntiHack.Log(initiatorPlayer, AntiHackType.EffectHack, $"Tried to run an impact effect outside of entity '{info.HitEntity.ShortPrefabName}' bounds by {num2}m");
					}
				}
				return false;
			}
			return true;
		}

		public static void ImpactEffect(HitInfo info, string customEffect = null)
		{
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0117: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			if (Interface.CallHook("OnImpactEffectCreate", (object)info, (object)customEffect) != null || (Object.op_Implicit((Object)(object)info.InitiatorPlayer) && info.InitiatorPlayer.limitNetworking) || !info.DoHitEffects)
			{
				return;
			}
			string materialName = StringPool.Get(info.HitMaterial);
			if (!CanPlayImpactEffect(info))
			{
				return;
			}
			string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
			string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
			if (info.HitEntity.IsValid())
			{
				if (customEffect == null)
				{
					GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
					if (impactEffect.isValid)
					{
						strName = impactEffect.resourcePath;
					}
				}
				if (!IsLegalPlacement(info))
				{
					return;
				}
				Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
				Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			}
			else
			{
				Run(strName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
				Run(decal, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			}
			HandleWeaponEffects(info, materialName);
			HandleAdditiveEffects(info);
		}
	}

	public Vector3 upDir;

	public Vector3 worldPos;

	public Vector3 worldNrm;

	public bool attached;

	public Transform transform;

	public GameObject gameObject;

	public string pooledString;

	public bool broadcast;

	public List<Connection> targets;

	private static Effect reusableInstace = new Effect();

	public Effect()
	{
	}

	public Effect(string effectName, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		Init(Type.Generic, posWorld, normWorld, sourceConnection);
		pooledString = effectName;
	}

	public Effect(string effectName, BaseEntity ent, uint boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection = null)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		Init(Type.Generic, ent, boneID, posLocal, normLocal, sourceConnection);
		pooledString = effectName;
	}

	public void Init(Type fxtype, BaseEntity ent, uint boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection = null)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		Clear();
		base.type = (uint)fxtype;
		attached = true;
		base.origin = posLocal;
		base.normal = normLocal;
		if ((Object)(object)ent != (Object)null && !ent.IsValid())
		{
			Debug.LogWarning((object)"Effect.Init - invalid entity");
		}
		base.entity = (NetworkableId)(ent.IsValid() ? ent.net.ID : default(NetworkableId));
		base.source = sourceConnection?.userid ?? 0;
		base.bone = boneID;
	}

	public void Init(Type fxtype, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		Clear();
		base.type = (uint)fxtype;
		attached = false;
		base.origin = (worldPos = posWorld);
		base.normal = (worldNrm = normWorld);
		base.source = sourceConnection?.userid ?? 0;
	}

	public void Clear()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		base.type = 0u;
		base.pooledstringid = 0u;
		base.number = 0;
		base.origin = default(Vector3);
		base.normal = default(Vector3);
		base.scale = 0f;
		base.entity = default(NetworkableId);
		base.bone = 0u;
		base.source = 0uL;
		base.distanceOverride = 0f;
		upDir = Vector3.zero;
		worldPos = Vector3.zero;
		worldNrm = Vector3.zero;
		attached = false;
		transform = null;
		gameObject = null;
		pooledString = null;
		broadcast = false;
		targets = null;
	}
}


public enum Type : uint
{
	Generic,
	Projectile,
	GenericGlobal
}


using Rust;
using UnityEngine;

public static class client
{
	public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
	{
	}

	public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
	{
		string.IsNullOrEmpty(strName);
	}

	public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3))
	{
	}

	public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3), Type overrideType = Type.Generic)
	{
		string.IsNullOrEmpty(strName);
	}

	public static void Run(string strName, GameObject obj)
	{
		string.IsNullOrEmpty(strName);
	}

	public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (info.HitEntity.IsValid())
		{
			Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal + info.HitNormalLocal * 0.1f, info.HitNormalLocal);
		}
		else
		{
			Run(effectName, info.HitPositionWorld + info.HitNormalWorld * 0.1f, info.HitNormalWorld);
		}
	}

	private static bool CanPlayImpactEffect(HitInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
		{
			return false;
		}
		return true;
	}

	private static Type GetOverrideType(HitInfo info)
	{
		return Type.Generic;
	}

	private static void HandleAdditiveEffects(HitInfo info)
	{
		if (info.damageTypes.Has(DamageType.Explosion))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
		}
		if (info.damageTypes.Has(DamageType.Heat))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
		}
	}

	public static void ImpactEffect(HitInfo info, string customEffect = null)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		if (!info.DoHitEffects)
		{
			return;
		}
		string materialName = StringPool.Get(info.HitMaterial);
		string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
		string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
		if (!CanPlayImpactEffect(info))
		{
			return;
		}
		if (info.HitEntity.IsValid())
		{
			if (customEffect == null)
			{
				GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
				if (impactEffect.isValid)
				{
					strName = impactEffect.resourcePath;
				}
			}
			Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
			if (info.DoDecals)
			{
				Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
			}
		}
		else
		{
			Type overrideType = GetOverrideType(info);
			Run(strName, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
			Run(decal, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
		}
		if (info.WeaponPrefab is BaseMelee baseMelee)
		{
			string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
			if (info.HitEntity.IsValid())
			{
				Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
			}
			else
			{
				Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld);
			}
		}
		HandleAdditiveEffects(info);
	}
}


using System.Collections.Generic;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;

public static class server
{
	public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		reusableInstace.Init(fxtype, ent, boneID, posLocal, normLocal, sourceConnection);
		reusableInstace.broadcast = broadcast;
		reusableInstace.targets = targets;
		EffectNetwork.Send(reusableInstace);
	}

	public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (!string.IsNullOrEmpty(strName))
		{
			reusableInstace.Init(Type.Generic, ent, boneID, posLocal, normLocal, sourceConnection);
			reusableInstace.pooledString = strName;
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}
	}

	public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		reusableInstace.Init(fxtype, posWorld, normWorld, sourceConnection);
		reusableInstace.broadcast = broadcast;
		reusableInstace.targets = targets;
		EffectNetwork.Send(reusableInstace);
	}

	public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!string.IsNullOrEmpty(strName))
		{
			reusableInstace.Init(Type.Generic, posWorld, normWorld, sourceConnection);
			reusableInstace.pooledString = strName;
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}
	}

	public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (info.HitEntity.IsValid())
		{
			Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
		}
		else
		{
			Run(effectName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
		}
	}

	private static bool CanPlayImpactEffect(HitInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
		{
			return false;
		}
		return true;
	}

	private static void HandleAdditiveEffects(HitInfo info)
	{
		if (info.damageTypes.Has(DamageType.Explosion))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
		}
		if (info.damageTypes.Has(DamageType.Heat))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
		}
	}

	private static void HandleWeaponEffects(HitInfo info, string materialName)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)info.WeaponPrefab))
		{
			return;
		}
		BaseMelee baseMelee = info.WeaponPrefab as BaseMelee;
		if ((Object)(object)baseMelee != (Object)null)
		{
			string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
			if (info.HitEntity.IsValid())
			{
				Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			}
			else
			{
				Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			}
		}
	}

	private static bool IsLegalPlacement(HitInfo info)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = info.HitEntity.bounds;
		float num = info.HitEntity.BoundsPadding();
		((Bounds)(ref bounds)).extents = ((Bounds)(ref bounds)).extents + new Vector3(num, num, num);
		if (!((Bounds)(ref bounds)).Contains(info.HitPositionLocal))
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((Object)(object)initiatorPlayer != (Object)null && ((object)initiatorPlayer).GetType() == typeof(BasePlayer))
			{
				float num2 = Mathf.Sqrt(((Bounds)(ref bounds)).SqrDistance(info.HitPositionLocal));
				if (num2 > ConVar.AntiHack.impact_effect_distance_forgiveness)
				{
					AntiHack.Log(initiatorPlayer, AntiHackType.EffectHack, $"Tried to run an impact effect outside of entity '{info.HitEntity.ShortPrefabName}' bounds by {num2}m");
				}
			}
			return false;
		}
		return true;
	}

	public static void ImpactEffect(HitInfo info, string customEffect = null)
	{
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnImpactEffectCreate", (object)info, (object)customEffect) != null || (Object.op_Implicit((Object)(object)info.InitiatorPlayer) && info.InitiatorPlayer.limitNetworking) || !info.DoHitEffects)
		{
			return;
		}
		string materialName = StringPool.Get(info.HitMaterial);
		if (!CanPlayImpactEffect(info))
		{
			return;
		}
		string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
		string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
		if (info.HitEntity.IsValid())
		{
			if (customEffect == null)
			{
				GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
				if (impactEffect.isValid)
				{
					strName = impactEffect.resourcePath;
				}
			}
			if (!IsLegalPlacement(info))
			{
				return;
			}
			Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
		}
		else
		{
			Run(strName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			Run(decal, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
		}
		HandleWeaponEffects(info, materialName);
		HandleAdditiveEffects(info);
	}
}


using UnityEngine;

public class EffectAudioPerspectiveSwitcher : MonoBehaviour, IEffect
{
	[HideInInspector]
	public EffectParentToWeaponBone parentToWeaponComponent;
}


public interface IEffectRecycle
{
}


public interface IEffect
{
}


public static class EffectLibrary
{
}


using UnityEngine;

public class EffectMuzzleFlash : MonoBehaviour, IEffect
{
}


using System;
using System.IO;
using Network;
using Network.Visibility;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public static class EffectNetwork
{
	public static void Send(Effect effect)
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null || !((BaseNetwork)Net.sv).IsConnected())
		{
			return;
		}
		TimeWarning val = TimeWarning.New("EffectNetwork.Send", 0);
		try
		{
			Group val2 = null;
			if (!string.IsNullOrEmpty(effect.pooledString))
			{
				((EffectData)effect).pooledstringid = StringPool.Get(effect.pooledString);
			}
			if (((EffectData)effect).pooledstringid == 0)
			{
				Debug.Log((object)("String ID is 0 - unknown effect " + effect.pooledString));
				return;
			}
			if (effect.broadcast)
			{
				NetWrite val3 = ((BaseNetwork)Net.sv).StartWrite();
				val3.PacketID((Type)13);
				ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val3, false, 2097152);
				val3.Send(new SendInfo(BaseNetworkable.GlobalNetworkGroup.subscribers));
				return;
			}
			if (effect.targets != null)
			{
				NetWrite val4 = ((BaseNetwork)Net.sv).StartWrite();
				val4.PacketID((Type)13);
				ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val4, false, 2097152);
				val4.Send(new SendInfo(effect.targets));
				return;
			}
			if (((NetworkableId)(ref ((EffectData)effect).entity)).IsValid)
			{
				BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(((EffectData)effect).entity) as BaseEntity;
				if (!baseEntity.IsValid())
				{
					return;
				}
				val2 = baseEntity.net.group;
			}
			else
			{
				val2 = Net.sv.visibility.GetGroup(effect.worldPos);
			}
			if (val2 != null)
			{
				NetWrite val5 = ((BaseNetwork)Net.sv).StartWrite();
				val5.PacketID((Type)13);
				ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val5, false, 2097152);
				val5.Send(new SendInfo(val2.subscribers));
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void Send(Effect effect, Connection target)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		((EffectData)effect).pooledstringid = StringPool.Get(effect.pooledString);
		if (((EffectData)effect).pooledstringid == 0)
		{
			Debug.LogWarning((object)("EffectNetwork.Send - unpooled effect name: " + effect.pooledString));
			return;
		}
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		val.PacketID((Type)13);
		ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val, false, 2097152);
		val.Send(new SendInfo(target));
	}
}


public class EffectParentToWeaponBone : BaseMonoBehaviour, IEffect
{
	public string boneName;

	public bool singleFrame;
}


using UnityEngine;

public class EffectScaleWithCameraDistance : MonoBehaviour, IEffect
{
	public float minScale = 1f;

	public float maxScale = 2.5f;

	public float scaleStartDistance = 50f;

	public float scaleEndDistance = 150f;
}


using UnityEngine;

public class EmissionBlink : FacepunchBehaviour, IClientComponent, INotifyLOD
{
	public EmissionToggle emissionToggle;

	public float blinkDuration = 1f;

	public float blinkInterval = 3f;

	public Light light;

	public float onIntensity = 3f;

	public float offIntensity = 1f;

	[Header("Optional Secondary Light")]
	public bool useSecondaryLight;

	public Light secondaryLight;

	public float secondaryOnIntensity = 2f;

	public float secondaryOffIntensity = 0.5f;
}


using UnityEngine;

public class EmissionScaledByLight : MonoBehaviour, IClientComponent
{
	private Color emissionColor;

	public Renderer[] targetRenderers;

	public int materialIndex = -1;

	private static MaterialPropertyBlock block;

	public Light lightToFollow;

	public float maxEmissionValue = 3f;
}


using UnityEngine;

public class EmissionToggle : MonoBehaviour, IClientComponent
{
	private Color emissionColor;

	public Renderer[] targetRenderers;

	public int materialIndex = -1;
}


using UnityEngine;

public class EyeBlink : MonoBehaviour
{
	public Transform LeftEye;

	public Transform LeftEyelid;

	public Vector3 LeftEyeOffset = new Vector3(0.01f, -0.002f, 0f);

	public Transform RightEye;

	public Transform RightEyelid;

	public Vector3 RightEyeOffset = new Vector3(0.01f, -0.002f, 0f);

	public Vector3 ClosedEyelidPosition;

	public Vector3 ClosedEyelidRotation;

	public Vector2 TimeWithoutBlinking = new Vector2(1f, 10f);

	public float BlinkSpeed = 0.2f;

	public Vector3 LeftEyeInitial;

	public Vector3 RightEyeInitial;
}


using UnityEngine;

public class EyeController : MonoBehaviour
{
	public const float MaxLookDot = 0.8f;

	public bool debug;

	public Transform LeftEye;

	public Transform RightEye;

	public Transform EyeTransform;

	public Vector3 Fudge = new Vector3(0f, 90f, 0f);

	public Vector3 FlickerRange;

	private Transform Focus;

	private float FocusUpdateTime;
}


using UnityEngine;

public class FireBomb : MonoBehaviour, IClientComponent
{
	public GameObject fireParticle;

	public float bombRadius;

	public float particleDuration;

	public float emitDuration;
}


using UnityEngine;

public class FirstPersonEffect : MonoBehaviour, IEffect
{
	public bool isGunShot;

	[HideInInspector]
	public EffectParentToWeaponBone parentToWeaponComponent;
}


using UnityEngine;

public class FootstepEffects : BaseFootstepEffect
{
	public Transform leftFoot;

	public Transform rightFoot;

	public string footstepEffectName = "footstep/barefoot";

	public string jumpStartEffectName = "jump-start/barefoot";

	public string jumpLandEffectName = "jump-land/barefoot";

	public SoundDefinition accentSound;
}


public interface IAnimationEventReceiver
{
}


using UnityEngine;

public class LightPulse : MonoBehaviour, IClientComponent
{
	public Light TargetLight;

	public float PulseSpeed = 1f;

	public float Lifetime = 3f;

	public float MaxIntensity = 3f;

	public float FadeOutSpeed = 2f;
}


using UnityEngine;

public class MaterialSwap : MonoBehaviour, IClientComponent
{
	public int materialIndex;

	public Renderer myRenderer;

	public Material OverrideMaterial;
}


using UnityEngine;

public class Muzzleflash_AlphaRandom : MonoBehaviour
{
	public ParticleSystem[] muzzleflashParticles;

	private Gradient grad = new Gradient();

	private GradientColorKey[] gck = (GradientColorKey[])(object)new GradientColorKey[3];

	private GradientAlphaKey[] gak = (GradientAlphaKey[])(object)new GradientAlphaKey[3];

	private void Start()
	{
	}

	private void OnEnable()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		gck[0].color = Color.white;
		gck[0].time = 0f;
		gck[1].color = Color.white;
		gck[1].time = 0.6f;
		gck[2].color = Color.black;
		gck[2].time = 0.75f;
		float alpha = Random.Range(0.2f, 0.85f);
		gak[0].alpha = alpha;
		gak[0].time = 0f;
		gak[1].alpha = alpha;
		gak[1].time = 0.45f;
		gak[2].alpha = 0f;
		gak[2].time = 0.5f;
		grad.SetKeys(gck, gak);
		ParticleSystem[] array = muzzleflashParticles;
		foreach (ParticleSystem val in array)
		{
			if ((Object)(object)val == (Object)null)
			{
				Debug.LogWarning((object)("Muzzleflash_AlphaRandom : null particle system in " + ((Object)((Component)this).gameObject).name));
				continue;
			}
			ColorOverLifetimeModule colorOverLifetime = val.colorOverLifetime;
			((ColorOverLifetimeModule)(ref colorOverLifetime)).color = MinMaxGradient.op_Implicit(grad);
		}
	}
}


using UnityEngine;

public class MuzzleFlash_Flamelet : MonoBehaviour
{
	public ParticleSystem flameletParticle;

	private void OnEnable()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		ShapeModule shape = flameletParticle.shape;
		((ShapeModule)(ref shape)).angle = Random.Range(6, 13);
		float num = Random.Range(7f, 9f);
		flameletParticle.startSpeed = Random.Range(2.5f, num);
		flameletParticle.startSize = Random.Range(0.05f, num * 0.015f);
	}
}


using UnityEngine;

public class NPCFootstepEffects : BaseFootstepEffect
{
	public string impactEffectDirectory = "footstep/stag";

	public Transform frontLeftFoot;

	public Transform frontRightFoot;

	public Transform backLeftFoot;

	public Transform backRightFoot;
}


using UnityEngine;

public class ParticleEmissionSound : FacepunchBehaviour, IClientComponent, ILOD
{
	public ParticleSystem particleSystem;

	public SoundDefinition soundDefinition;

	public float soundCooldown;
}


using UnityEngine;

public class ParticleEmitFromParentObject : MonoBehaviour
{
	public string bonename;

	private Bounds bounds;

	private Transform bone;

	private BaseEntity entity;

	private float lastBoundsUpdate;
}


using ConVar;
using UnityEngine;

public class PhysicsEffects : MonoBehaviour
{
	public BaseEntity entity;

	public SoundDefinition physImpactSoundDef;

	public float minTimeBetweenEffects = 0.25f;

	public float minDistBetweenEffects = 0.1f;

	public float hardnessScale = 1f;

	public float lowMedThreshold = 0.4f;

	public float medHardThreshold = 0.7f;

	public float enableDelay = 0.1f;

	public LayerMask ignoreLayers;

	public bool useCollisionPositionInsteadOfTransform;

	public float minimumRigidbodyImpactWeight;

	private float lastEffectPlayed;

	private float enabledAt = float.PositiveInfinity;

	private float ignoreImpactThreshold = 0.02f;

	private Vector3 lastCollisionPos;

	public void OnEnable()
	{
		enabledAt = Time.time;
	}

	public void OnCollisionEnter(Collision collision)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if (!Physics.sendeffects || Time.time < enabledAt + enableDelay || Time.time < lastEffectPlayed + minTimeBetweenEffects || ((1 << collision.gameObject.layer) & LayerMask.op_Implicit(ignoreLayers)) != 0)
		{
			return;
		}
		Vector3 relativeVelocity = collision.relativeVelocity;
		float magnitude = ((Vector3)(ref relativeVelocity)).magnitude;
		magnitude = magnitude * 0.055f * hardnessScale;
		Rigidbody val = default(Rigidbody);
		if (!(magnitude <= ignoreImpactThreshold) && (!((useCollisionPositionInsteadOfTransform ? Vector3.Distance(((ContactPoint)(ref collision.contacts[0])).point, lastCollisionPos) : Vector3.Distance(((Component)this).transform.position, lastCollisionPos)) < minDistBetweenEffects) || lastEffectPlayed == 0f) && (!(minimumRigidbodyImpactWeight > 0f) || !collision.gameObject.TryGetComponent<Rigidbody>(ref val) || !(val.mass < minimumRigidbodyImpactWeight)))
		{
			if ((Object)(object)entity != (Object)null)
			{
				entity.SignalBroadcast(BaseEntity.Signal.PhysImpact, magnitude.ToString());
			}
			lastEffectPlayed = Time.time;
			if (useCollisionPositionInsteadOfTransform)
			{
				lastCollisionPos = ((Component)this).transform.InverseTransformPoint(((ContactPoint)(ref collision.contacts[0])).point);
			}
			else
			{
				lastCollisionPos = ((Component)this).transform.position;
			}
		}
	}
}


using UnityEngine;

public class RottingFlies : MonoBehaviour, IClientComponent
{
	public GameObjectRef effect;

	public SoundDefinition soundDef;

	public Transform rootBone;
}


using UnityEngine;

public class Sandstorm : MonoBehaviour
{
	public ParticleSystem m_psSandStorm;

	public float m_flSpeed;

	public float m_flSwirl;

	public float m_flEmissionRate;

	private void Start()
	{
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.RotateAround(((Component)this).transform.position, Vector3.up, Time.deltaTime * m_flSwirl);
		Vector3 eulerAngles = ((Component)this).transform.eulerAngles;
		eulerAngles.x = -7f + Mathf.Sin(Time.time * 2.5f) * 7f;
		((Component)this).transform.eulerAngles = eulerAngles;
		if ((Object)(object)m_psSandStorm != (Object)null)
		{
			m_psSandStorm.startSpeed = m_flSpeed;
			ParticleSystem psSandStorm = m_psSandStorm;
			psSandStorm.startSpeed += Mathf.Sin(Time.time * 0.4f) * (m_flSpeed * 0.75f);
			m_psSandStorm.emissionRate = m_flEmissionRate + Mathf.Sin(Time.time * 1f) * (m_flEmissionRate * 0.3f);
		}
	}
}


using System;
using UnityEngine;

public class ScaleParticleSystem : ScaleRenderer
{
	public ParticleSystem pSystem;

	public bool scaleGravity;

	[NonSerialized]
	private float startSize;

	[NonSerialized]
	private float startLifeTime;

	[NonSerialized]
	private float startSpeed;

	[NonSerialized]
	private float startGravity;

	public override void GatherInitialValues()
	{
		base.GatherInitialValues();
		startGravity = pSystem.gravityModifier;
		startSpeed = pSystem.startSpeed;
		startSize = pSystem.startSize;
		startLifeTime = pSystem.startLifetime;
	}

	public override void SetScale_Internal(float scale)
	{
		base.SetScale_Internal(scale);
		pSystem.startSize = startSize * scale;
		pSystem.startLifetime = startLifeTime * scale;
		pSystem.startSpeed = startSpeed * scale;
		pSystem.gravityModifier = startGravity * scale;
	}
}


using UnityEngine;

public class ScaleRenderer : MonoBehaviour
{
	public bool useRandomScale;

	public float scaleMin = 1f;

	public float scaleMax = 1f;

	private float lastScale = -1f;

	protected bool hasInitialValues;

	public Renderer myRenderer;

	private bool ScaleDifferent(float newScale)
	{
		return newScale != lastScale;
	}

	public void Start()
	{
		if (useRandomScale)
		{
			SetScale(Random.Range(scaleMin, scaleMax));
		}
	}

	public void SetScale(float scale)
	{
		if (!hasInitialValues)
		{
			GatherInitialValues();
		}
		if (ScaleDifferent(scale) || (scale > 0f && !myRenderer.enabled))
		{
			SetRendererEnabled(scale != 0f);
			SetScale_Internal(scale);
		}
	}

	public virtual void SetScale_Internal(float scale)
	{
		lastScale = scale;
	}

	public virtual void SetRendererEnabled(bool isEnabled)
	{
		if (Object.op_Implicit((Object)(object)myRenderer) && myRenderer.enabled != isEnabled)
		{
			myRenderer.enabled = isEnabled;
		}
	}

	public virtual void GatherInitialValues()
	{
		hasInitialValues = true;
	}
}


using System;
using UnityEngine;

public class ScaleTrailRenderer : ScaleRenderer
{
	private TrailRenderer trailRenderer;

	[NonSerialized]
	private float startWidth;

	[NonSerialized]
	private float endWidth;

	[NonSerialized]
	private float duration;

	[NonSerialized]
	private float startMultiplier;

	public override void GatherInitialValues()
	{
		base.GatherInitialValues();
		if (Object.op_Implicit((Object)(object)myRenderer))
		{
			trailRenderer = ((Component)myRenderer).GetComponent<TrailRenderer>();
		}
		else
		{
			trailRenderer = ((Component)this).GetComponentInChildren<TrailRenderer>();
		}
		startWidth = trailRenderer.startWidth;
		endWidth = trailRenderer.endWidth;
		duration = trailRenderer.time;
		startMultiplier = trailRenderer.widthMultiplier;
	}

	public override void SetScale_Internal(float scale)
	{
		if (scale == 0f)
		{
			trailRenderer.emitting = false;
			((Renderer)trailRenderer).enabled = false;
			trailRenderer.time = 0f;
			trailRenderer.Clear();
			return;
		}
		if (!trailRenderer.emitting)
		{
			trailRenderer.Clear();
		}
		trailRenderer.emitting = true;
		((Renderer)trailRenderer).enabled = true;
		base.SetScale_Internal(scale);
		trailRenderer.widthMultiplier = startMultiplier * scale;
		trailRenderer.time = duration * scale;
	}
}


using UnityEngine;

public class ScaleTransform : ScaleRenderer
{
	private Vector3 initialScale;

	public override void SetScale_Internal(float scale)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.SetScale_Internal(scale);
		((Component)myRenderer).transform.localScale = initialScale * scale;
	}

	public override void GatherInitialValues()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		initialScale = ((Component)myRenderer).transform.localScale;
		base.GatherInitialValues();
	}
}


using UnityEngine;

public class AnimatedScreenShake : BaseScreenShake
{
	public AnimationClip TargetClip;

	[ReadOnly]
	public AnimationCurve rotX;

	[ReadOnly]
	public AnimationCurve rotY;

	[ReadOnly]
	public AnimationCurve rotZ;

	[ReadOnly]
	public AnimationCurve posX;

	[ReadOnly]
	public AnimationCurve posY;

	[ReadOnly]
	public AnimationCurve posZ;

	private const float VALID_RANGE = 0.1f;

	private bool canPlay;

	public override void Setup()
	{
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		if (canPlay)
		{
			float num = rotX.Evaluate(delta);
			float num2 = rotY.Evaluate(delta);
			float num3 = rotZ.Evaluate(delta);
			float num4 = posX.Evaluate(delta);
			float num5 = posY.Evaluate(delta);
			float num6 = posZ.Evaluate(delta);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(num, num2, num3);
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(num4, num5, num6);
			if ((bool)cam)
			{
				cam.rotation = Quaternion.Euler(((Quaternion)(ref cam.rotation)).eulerAngles + val);
				ref Vector3 position = ref cam.position;
				position += val2;
			}
			if ((bool)vm)
			{
				vm.rotation = Quaternion.Euler(((Quaternion)(ref vm.rotation)).eulerAngles + val);
				ref Vector3 position2 = ref vm.position;
				position2 += val2;
			}
		}
	}
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public abstract class BaseScreenShake : MonoBehaviour
{
	public static List<BaseScreenShake> list = new List<BaseScreenShake>();

	internal static float punchFadeScale = 0f;

	internal static float bobScale = 0f;

	internal static float animPunchMagnitude = 10f;

	internal static AnimationCurve InverseCurve = AnimationCurve.Linear(0f, 1f, 1f, 0.05f);

	public float length = 2f;

	internal float timeTaken;

	private int currentFrame = -1;

	public static void Apply(Camera cam, BaseViewModel vm)
	{
		CachedTransform<Camera> cam2 = new CachedTransform<Camera>(cam);
		CachedTransform<BaseViewModel> vm2 = new CachedTransform<BaseViewModel>(vm);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].Run(ref cam2, ref vm2);
		}
		cam2.Apply();
		vm2.Apply();
	}

	protected void OnEnable()
	{
		list.Add(this);
		timeTaken = 0f;
		Setup();
	}

	protected void OnDisable()
	{
		if (!Application.isQuitting)
		{
			list.Remove(this);
		}
	}

	public void Run(ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		if (!(timeTaken > length))
		{
			if (Time.frameCount != currentFrame)
			{
				timeTaken += Time.deltaTime;
				currentFrame = Time.frameCount;
			}
			float delta = Mathf.InverseLerp(0f, length, timeTaken);
			Run(delta, ref cam, ref vm);
		}
	}

	public abstract void Setup();

	public abstract void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm);
}


using UnityEngine;
using UnityEngine.Serialization;

public class ExplosionScreenBounceFade : ScreenBounceFade
{
	[FormerlySerializedAs("explosionVolumeWeight")]
	public AnimationCurve volumeWeight;
}


using UnityEngine;

public class ScreenBounce : BaseScreenShake
{
	public AnimationCurve bounceScale;

	public AnimationCurve bounceSpeed;

	public AnimationCurve bounceViewmodel;

	private float bounceTime;

	private Vector3 bounceVelocity = Vector3.zero;

	public override void Setup()
	{
		bounceTime = Random.Range(0f, 1000f);
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		bounceTime += Time.deltaTime * bounceSpeed.Evaluate(delta);
		float num = bounceScale.Evaluate(delta) * 0.1f;
		bounceVelocity.x = Mathf.Sin(bounceTime * 20f) * num;
		bounceVelocity.y = Mathf.Cos(bounceTime * 25f) * num;
		bounceVelocity.z = 0f;
		Vector3 zero = Vector3.zero;
		zero += bounceVelocity.x * cam.right;
		zero += bounceVelocity.y * cam.up;
		if ((bool)cam)
		{
			ref Vector3 position = ref cam.position;
			position += zero;
		}
		if ((bool)vm)
		{
			ref Vector3 position2 = ref vm.position;
			position2 += zero * -1f * bounceViewmodel.Evaluate(delta);
		}
	}
}


using UnityEngine;

public class ScreenBounceFade : BaseScreenShake
{
	public AnimationCurve bounceScale;

	public AnimationCurve bounceSpeed;

	public AnimationCurve bounceViewmodel;

	public AnimationCurve distanceFalloff;

	public AnimationCurve timeFalloff;

	private float bounceTime;

	private Vector3 bounceVelocity = Vector3.zero;

	public float maxDistance = 10f;

	public float scale = 1f;

	public override void Setup()
	{
		bounceTime = Random.Range(0f, 1000f);
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(cam.position, ((Component)this).transform.position);
		float num2 = 1f - Mathf.InverseLerp(0f, maxDistance, num);
		bounceTime += Time.deltaTime * bounceSpeed.Evaluate(delta);
		float num3 = distanceFalloff.Evaluate(num2);
		float num4 = bounceScale.Evaluate(delta) * 0.1f * num3 * scale * timeFalloff.Evaluate(delta);
		bounceVelocity.x = Mathf.Sin(bounceTime * 20f) * num4;
		bounceVelocity.y = Mathf.Cos(bounceTime * 25f) * num4;
		bounceVelocity.z = 0f;
		Vector3 zero = Vector3.zero;
		zero += bounceVelocity.x * cam.right;
		zero += bounceVelocity.y * cam.up;
		zero *= num2;
		if ((bool)cam)
		{
			ref Vector3 position = ref cam.position;
			position += zero;
		}
		if ((bool)vm)
		{
			ref Vector3 position2 = ref vm.position;
			position2 += zero * -1f * bounceViewmodel.Evaluate(delta);
		}
	}
}


using UnityEngine;

public class ScreenFov : BaseScreenShake
{
	public AnimationCurve FovAdjustment;

	public override void Setup()
	{
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		if ((bool)cam)
		{
			Camera component = cam.component;
			component.fieldOfView += FovAdjustment.Evaluate(delta);
		}
	}
}


using UnityEngine;

public class ScreenRotate : BaseScreenShake
{
	public AnimationCurve Pitch;

	public AnimationCurve Yaw;

	public AnimationCurve Roll;

	public AnimationCurve ViewmodelEffect;

	public float scale = 1f;

	public bool useViewModelEffect = true;

	public override void Setup()
	{
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		zero.x = Pitch.Evaluate(delta);
		zero.y = Yaw.Evaluate(delta);
		zero.z = Roll.Evaluate(delta);
		if ((bool)cam)
		{
			ref Quaternion rotation = ref cam.rotation;
			rotation *= Quaternion.Euler(zero * scale);
		}
		if ((bool)vm && useViewModelEffect)
		{
			ref Quaternion rotation2 = ref vm.rotation;
			rotation2 *= Quaternion.Euler(zero * scale * -1f * (1f - ViewmodelEffect.Evaluate(delta)));
		}
	}
}


using UnityEngine;

public class Shaker : MonoBehaviour
{
	public float Frequency = 0.1f;

	public Vector3 PositionMagnitude;

	public Vector3 RotationMagnitude;

	public float GlobalMultiplier = 1f;
}


using System;
using UnityEngine;

public class SwapAmmoParticle : MonoBehaviour, IClientComponent, IEffect
{
	[Serializable]
	public struct Override
	{
		public ItemDefinition TargetAmmo;

		public Material TargetMaterial;
	}

	public ParticleSystem Target;

	public Override[] Overrides;
}


using System;
using UnityEngine;

[Serializable]
public struct Override
{
	public ItemDefinition TargetAmmo;

	public Material TargetMaterial;
}


using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

public class TransformLineRenderer : MonoBehaviour, IClientComponent
{
	internal struct LineRendererUpdateJob : IJobParallelForTransform
	{
		[NativeMatchesParallelForLength]
		[WriteOnly]
		public NativeArray<Vector3> ResultWorldPositions;

		public void Execute(int index, [ReadOnly] TransformAccess transform)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			ResultWorldPositions[index] = ((TransformAccess)(ref transform)).position;
		}
	}

	public Transform[] TransformSequence;

	public LineRenderer TargetRenderer;

	public bool IsEnabled = true;
}


using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

internal struct LineRendererUpdateJob : IJobParallelForTransform
{
	[NativeMatchesParallelForLength]
	[WriteOnly]
	public NativeArray<Vector3> ResultWorldPositions;

	public void Execute(int index, [ReadOnly] TransformAccess transform)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		ResultWorldPositions[index] = ((TransformAccess)(ref transform)).position;
	}
}


using UnityEngine;

public class EmissionOffsetStepped : MonoBehaviour, IClientComponent
{
	public Material material;

	public float offsetAmount = 0.1f;

	public float minInterval = 0.5f;

	public float maxInterval = 2f;
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch.Rust.Profiling;
using Network;
using Oxide.Core;
using UnityEngine;

public static class ConsoleNetwork
{
	private static Stopwatch timer = new Stopwatch();

	internal static void Init()
	{
	}

	internal static void OnClientCommand(Message packet)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		if (packet.read.Unread > Server.maxpacketsize_command)
		{
			Debug.LogWarning((object)"Dropping client command due to size");
			return;
		}
		timer.Restart();
		string text = packet.read.StringRaw(8388608, false);
		if (packet.connection == null || !packet.connection.connected)
		{
			Debug.LogWarning((object)("Client without connection tried to run command: " + text));
		}
		else if (Interface.CallHook("OnClientCommand", (object)packet.connection, (object)text) == null)
		{
			Option val = Option.Server;
			val = ((Option)(ref val)).FromConnection(packet.connection);
			string text2 = ConsoleSystem.Run(((Option)(ref val)).Quiet(), text, Array.Empty<object>());
			if (!string.IsNullOrEmpty(text2))
			{
				SendClientReply(packet.connection, text2);
			}
			if (timer.Elapsed > RuntimeProfiler.ConsoleCommandWarningThreshold)
			{
				LagSpikeProfiler.ConsoleCommand(timer.Elapsed, packet, text);
			}
		}
	}

	internal static void SendClientReply(Connection cn, string strCommand)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)11);
			obj.String(strCommand, false);
			obj.Send(new SendInfo(cn));
		}
	}

	public static void SendClientCommand(Connection cn, string strCommand, params object[] args)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && Interface.CallHook("OnSendCommand", (object)cn, (object)strCommand, (object)args) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			string text = ConsoleSystem.BuildCommand(strCommand, args);
			obj.String(text, false);
			obj.Send(new SendInfo(cn));
		}
	}

	public static void SendClientCommandImmediate(Connection cn, string strCommand, params object[] args)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			string text = ConsoleSystem.BuildCommand(strCommand, args);
			obj.String(text, false);
			SendInfo val = default(SendInfo);
			((SendInfo)(ref val))..ctor(cn);
			val.priority = (Priority)0;
			obj.SendImmediate(val);
		}
	}

	public static void SendClientCommand(List<Connection> cn, string strCommand, params object[] args)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && Interface.CallHook("OnSendCommand", (object)cn, (object)strCommand, (object)args) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			obj.String(ConsoleSystem.BuildCommand(strCommand, args), false);
			obj.Send(new SendInfo(cn));
		}
	}

	public static void BroadcastToAllClients(string strCommand, params object[] args)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && Interface.CallHook("OnBroadcastCommand", (object)strCommand, (object)args) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			obj.String(ConsoleSystem.BuildCommand(strCommand, args), false);
			obj.Send(new SendInfo(Net.sv.connections));
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch.Models;
using Newtonsoft.Json.Linq;
using UnityEngine;

public class CpuAffinity
{
	private static bool _appliedAutoCpuAffinity;

	public static void Apply()
	{
	}

	private static void ApplyImpl(Manifest manifest)
	{
		try
		{
			string cpuModel = SystemInfo.processorType;
			(string, int, int) tuple = ReadManifestCoreRanges(manifest).FirstOrDefault(((string Cpu, int Min, int Max) r) => cpuModel.Contains(r.Cpu, StringComparison.OrdinalIgnoreCase));
			if (tuple.Item2 >= 0 && tuple.Item3 > tuple.Item2)
			{
				ulong num = 0uL;
				for (int i = tuple.Item2; i <= tuple.Item3; i++)
				{
					num |= (ulong)(1L << i);
				}
				if (SystemCommands.SetCpuAffinity(num))
				{
					Debug.Log((object)$"Automatically set CPU affinity to cores {tuple.Item2}-{tuple.Item3} ({tuple.Item1})");
				}
			}
		}
		catch (Exception arg)
		{
			Debug.LogWarning((object)$"Failed to auto set CPU affinity: {arg}");
		}
	}

	private static List<(string Cpu, int Min, int Max)> ReadManifestCoreRanges(Manifest manifest)
	{
		List<(string, int, int)> list = new List<(string, int, int)>();
		JObject obj = manifest?.Metadata;
		JToken obj2 = ((obj != null) ? obj["PreferredCoreRanges"] : null);
		JArray val = (JArray)(object)((obj2 is JArray) ? obj2 : null);
		if (val == null || ((JContainer)val).Count <= 0)
		{
			return list;
		}
		foreach (JToken item in val)
		{
			JObject val2 = (JObject)(object)((item is JObject) ? item : null);
			if (val2 != null)
			{
				JToken obj3 = val2["Cpu"];
				string text = ((obj3 != null) ? Extensions.Value<string>((IEnumerable<JToken>)obj3) : null);
				JToken obj4 = val2["Min"];
				int? num = ((obj4 != null) ? new int?(Extensions.Value<int>((IEnumerable<JToken>)obj4)) : ((int?)null));
				JToken obj5 = val2["Max"];
				int? num2 = ((obj5 != null) ? new int?(Extensions.Value<int>((IEnumerable<JToken>)obj5)) : ((int?)null));
				if (text != null && num.HasValue && num2.HasValue)
				{
					list.Add((text, num.Value, num2.Value));
				}
			}
		}
		return list;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Facepunch;
using Facepunch.Utility;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class VDDraw : SingletonComponent<VDDraw>, IServerComponent
{
	private const int maxLogFiles = 10;

	private const string prefix = "VDDraw";

	private const string extension = "vddraw";

	private const string compressionExtension = "gz";

	private const float defaultEntryDuration = 0.2f;

	private const float saveIntervalSeconds = 60f;

	private ConcurrentQueue<VDDrawEntry> logEntries = new ConcurrentQueue<VDDrawEntry>();

	private bool _isRecording;

	private string currentLogPath;

	public static bool isRecording => SingletonComponent<VDDraw>.Instance._isRecording;

	private static string logDirectoryPath => Path.Combine(Application.persistentDataPath, "Logs");

	[ServerVar]
	public static void SetIsRecording(Arg arg)
	{
		bool flag = (arg.HasArgs(1) ? arg.GetBool(0, false) : (!SingletonComponent<VDDraw>.Instance._isRecording));
		if (SingletonComponent<VDDraw>.Instance._isRecording == flag)
		{
			if (SingletonComponent<VDDraw>.Instance._isRecording)
			{
				arg.ReplyWith("Already recording");
			}
			else
			{
				arg.ReplyWith("Not recording");
			}
		}
		else if (flag)
		{
			SingletonComponent<VDDraw>.Instance.StartRecording();
			arg.ReplyWith("Recording started");
		}
		else
		{
			SingletonComponent<VDDraw>.Instance.StopRecording();
			arg.ReplyWith("Recording stopped");
		}
	}

	private void StartRecording()
	{
		if (!_isRecording)
		{
			_isRecording = true;
			if (!Directory.Exists(logDirectoryPath))
			{
				Directory.CreateDirectory(logDirectoryPath);
			}
			ManageLogFiles();
			currentLogPath = GetNewLogFilePath();
			((FacepunchBehaviour)this).InvokeRepeating((Action)SaveLogs, 0f, 60f);
			Application.quitting += StopRecording;
		}
	}

	private void StopRecording()
	{
		if (_isRecording)
		{
			_isRecording = false;
			((FacepunchBehaviour)this).CancelInvoke((Action)SaveLogs);
			SaveLogs();
			CompressCurrentLog();
			currentLogPath = null;
			Application.quitting -= StopRecording;
		}
	}

	public static void Log(BaseEntity entity, bool display, string label, string message)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)1;
			val.message = message;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	public static void Line(BaseEntity entity, bool display, string label, Vector3 start, Vector3 end, Color color, float duration = 0f)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)0;
			val.start = start;
			val.end = end;
			val.color = color;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	public static void Text(BaseEntity entity, bool display, string label, string message, Vector3 position, Color color, float duration = 0f, float scaleMulti = 1f, bool alsoLog = false)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid())
		{
			if (SingletonComponent<VDDraw>.Instance._isRecording)
			{
				VDDrawEntry val = Pool.Get<VDDrawEntry>();
				val.entityName = GetEntityReadableName(entity);
				val.label = label;
				val.frame = Time.frameCount;
				val.category = (Category)2;
				val.start = position;
				val.message = message;
				val.color = color;
				SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
			}
			if (alsoLog)
			{
				Log(entity, display, label, message);
			}
		}
	}

	public static void Sphere(BaseEntity entity, bool display, string label, Vector3 position, float size, Color color, float duration = 0f)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)3;
			val.start = position;
			val.sizeX = size;
			val.color = color;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	public static void Box(BaseEntity entity, bool display, string label, Vector3 center, Quaternion rotation, Vector3 size, Color color, float duration = 0f)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)4;
			val.start = center;
			val.end = rotation * Vector3.forward;
			val.sizeX = size.x;
			val.sizeY = size.y;
			val.sizeZ = size.z;
			val.color = color;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	private static string GetNewLogFilePath()
	{
		string text = DateTime.Now.ToString("yyyyMMdd_HHmmss");
		return Path.Combine(logDirectoryPath, "VDDraw_" + text + ".vddraw");
	}

	public static string GetLastLogFilePath()
	{
		List<FileInfo> list = (from f in new DirectoryInfo(logDirectoryPath).GetFiles("VDDraw_*")
			orderby f.CreationTime
			select f).ToList();
		if (list.Count == 0)
		{
			return null;
		}
		return list.Last().FullName;
	}

	private void CompressCurrentLog()
	{
		TimeWarning val = TimeWarning.New("VDDraw:CompressCurrentLog", 0);
		try
		{
			string lastLogFilePath = GetLastLogFilePath();
			byte[] data = File.ReadAllBytes(lastLogFilePath);
			File.WriteAllBytes(bytes: Compression.Compress(data), path: lastLogFilePath + ".gz");
			File.Delete(lastLogFilePath);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SaveLogs()
	{
		TimeWarning val = TimeWarning.New("VDDraw:SaveLogs", 0);
		try
		{
			using FileStream fileStream = new FileStream(currentLogPath, FileMode.Append, FileAccess.Write, FileShare.None, 4096, useAsync: true);
			VDDrawEntry result;
			while (logEntries.TryDequeue(out result))
			{
				ProtoStreamExtensions.WriteToStream((IProto)(object)result, (Stream)fileStream, true, 2097152);
				Pool.Free<VDDrawEntry>(ref result);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void ManageLogFiles()
	{
		List<FileInfo> list = (from f in new DirectoryInfo(logDirectoryPath).GetFiles("VDDraw_*")
			orderby f.CreationTime
			select f).ToList();
		if (list.Count > 10)
		{
			int num = list.Count - 10;
			for (int i = 0; i < num; i++)
			{
				Debug.Log((object)("Deleting log file: " + list[i].FullName));
				list[i].Delete();
			}
		}
	}

	public static string GetEntityReadableName(BaseEntity entity)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		string name = ((object)entity).GetType().Name;
		NetworkableId iD = entity.net.ID;
		return name + "_" + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Threading;
using UnityEngine;

public class FileSystem_Warmup : MonoBehaviour
{
	private static List<(string, TimeSpan)> warmupTimes = new List<(string, TimeSpan)>();

	private static bool run = true;

	private static string[] ExcludeFilter = new string[13]
	{
		"/bundled/prefabs/autospawn/monument", "/bundled/prefabs/autospawn/mountain", "/bundled/prefabs/autospawn/canyon", "/bundled/prefabs/autospawn/decor", "/bundled/prefabs/autospawn/tunnel", "/bundled/prefabs/remapped", "/bundled/prefabs/navmesh", "/content/ui/", "/prefabs/ui/", "/prefabs/world/",
		"/prefabs/system/", "/standard assets/", "/third party/"
	};

	private static Stopwatch warmupTimer = new Stopwatch();

	public static IEnumerable<(string, TimeSpan)> GetWarmupTimes()
	{
		return warmupTimes;
	}

	public static void Run()
	{
		if (!run)
		{
			return;
		}
		FileSystemBackend backend = FileSystem.Backend;
		AssetBundleBackend val = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
		if (val != null && val.GetAssetSceneProgress() < 1f)
		{
			Debug.LogError((object)"Cannot run synchronous asset warmup until all asset scenes are finished loading");
			return;
		}
		List<string> assetList = GetAssetList();
		for (int i = 0; i < assetList.Count; i++)
		{
			PrefabWarmup(assetList[i]);
		}
		run = false;
	}

	public static IEnumerator Run(Action<string> statusFunction, string format = null, CancellationToken ct = default(CancellationToken))
	{
		if (!run)
		{
			yield break;
		}
		FileSystemBackend backend = FileSystem.Backend;
		AssetBundleBackend assetBundleBackend = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
		if (assetBundleBackend != null)
		{
			float lastProgress = 0f;
			while (!ct.IsCancellationRequested)
			{
				float assetSceneProgress = assetBundleBackend.GetAssetSceneProgress();
				if (assetSceneProgress >= 1f)
				{
					break;
				}
				if (!Mathf.Approximately(assetSceneProgress, lastProgress))
				{
					lastProgress = assetSceneProgress;
					statusFunction?.Invoke($"Loading Game Prefabs {assetSceneProgress * 100f:0.0}%");
				}
				yield return null;
			}
		}
		Timing timer = new Timing("asset_warmup");
		List<string> assetList = GetAssetList();
		yield return RunForAssets(assetList, statusFunction, format, ct);
		timer.End();
		run = false;
	}

	public static IEnumerator RunForAssets(List<string> assetList, Action<string> statusFunction, string format = null, CancellationToken ct = default(CancellationToken))
	{
		if (assetList.Count == 0)
		{
			yield break;
		}
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < assetList.Count; i++)
		{
			if (ct.IsCancellationRequested)
			{
				break;
			}
			if (sw.Elapsed.TotalSeconds > (double)CalculateFrameBudget() || i == 0 || i == assetList.Count - 1)
			{
				statusFunction?.Invoke(string.Format((format != null) ? format : "{0}/{1}", i + 1, assetList.Count));
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Restart();
			}
			PrefabWarmup(assetList[i]);
		}
	}

	private static float CalculateFrameBudget()
	{
		return 2f;
	}

	private static bool ShouldIgnore(string path)
	{
		for (int i = 0; i < ExcludeFilter.Length; i++)
		{
			if (StringEx.Contains(path, ExcludeFilter[i], CompareOptions.OrdinalIgnoreCase))
			{
				return true;
			}
		}
		return false;
	}

	private static List<string> GetAssetList()
	{
		FileSystemBackend backend = FileSystem.Backend;
		AssetBundleBackend val = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
		if (val == null)
		{
			return new List<string>();
		}
		return (from t in val.GetAssetScenePrefabs(AssetSceneManifest.Current.AutoLoadScenes)
			where !ShouldIgnore(t.Path)
			select t.Path).ToList();
	}

	private static void PrefabWarmup(string path)
	{
		warmupTimer.Restart();
		GameManager.server.FindPrefab(path);
		warmupTimer.Stop();
		warmupTimes.Add(ValueTuple.Create(path, warmupTimer.Elapsed));
	}
}


