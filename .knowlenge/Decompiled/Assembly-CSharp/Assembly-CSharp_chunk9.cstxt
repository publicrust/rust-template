using System;
using System.Collections;
using System.IO;
using ConVar;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class HumanNPC : NPCPlayer, IAISenses, IAIAttack, IThinker
{
	[Header("LOS")]
	public int AdditionalLosBlockingLayer;

	[Header("Loot")]
	public LootContainer.LootSpawnSlot[] LootSpawnSlots;

	[Header("Damage")]
	public float aimConeScale = 2f;

	public float lastDismountTime;

	[NonSerialized]
	public bool lightsOn;

	public float nextZoneSearchTime;

	public AIInformationZone cachedInfoZone;

	public float targetAimedDuration;

	private float lastAimSetTime;

	public Vector3 aimOverridePosition = Vector3.zero;

	public ScientistBrain Brain { get; set; }

	public override float StartHealth()
	{
		return startHealth;
	}

	public override float StartMaxHealth()
	{
		return startHealth;
	}

	public override float MaxHealth()
	{
		return startHealth;
	}

	public override bool IsLoadBalanced()
	{
		return true;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Brain = ((Component)this).GetComponent<ScientistBrain>();
		if (!base.isClient)
		{
			AIThinkManager.Add(this);
		}
	}

	internal override void DoServerDestroy()
	{
		AIThinkManager.Remove(this);
		base.DoServerDestroy();
	}

	public void LightCheck()
	{
		if ((TOD_Sky.Instance.IsNight && !lightsOn) || (TOD_Sky.Instance.IsDay && lightsOn))
		{
			LightToggle();
			lightsOn = !lightsOn;
		}
	}

	public override float GetAimConeScale()
	{
		return aimConeScale;
	}

	public override void EquipWeapon(bool skipDeployDelay = false)
	{
		base.EquipWeapon(skipDeployDelay);
	}

	public override void DismountObject()
	{
		base.DismountObject();
		lastDismountTime = Time.time;
	}

	public bool RecentlyDismounted()
	{
		return Time.time < lastDismountTime + 10f;
	}

	public virtual float GetIdealDistanceFromTarget()
	{
		return Mathf.Max(5f, EngagementRange() * 0.75f);
	}

	public AIInformationZone GetInformationZone(Vector3 pos)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)VirtualInfoZone != (Object)null)
		{
			return VirtualInfoZone;
		}
		if ((Object)(object)cachedInfoZone == (Object)null || Time.time > nextZoneSearchTime)
		{
			cachedInfoZone = AIInformationZone.GetForPoint(pos);
			nextZoneSearchTime = Time.time + 5f;
		}
		return cachedInfoZone;
	}

	public float EngagementRange()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (Object.op_Implicit((Object)(object)attackEntity))
		{
			return attackEntity.effectiveRange * (attackEntity.aiOnlyInRange ? 1f : 2f) * Brain.AttackRangeMultiplier;
		}
		return Brain.SenseRange;
	}

	public void SetDucked(bool flag)
	{
		if (Interface.CallHook("OnNpcDuck", (object)this) == null)
		{
			modelState.ducked = flag;
			SendNetworkUpdate();
		}
	}

	public virtual void TryThink()
	{
		ServerThink_Internal();
	}

	public override void ServerThink(float delta)
	{
		base.ServerThink(delta);
		if (Brain.ShouldServerThink())
		{
			Brain.DoThink();
		}
	}

	public void TickAttack(float delta, BaseCombatEntity target, bool targetIsLOS)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)target == (Object)null)
		{
			return;
		}
		Vector3 val = base.eyes.BodyForward();
		Vector3 val2 = target.CenterPoint() - base.eyes.position;
		float num = Vector3.Dot(val, ((Vector3)(ref val2)).normalized);
		if (targetIsLOS)
		{
			if (num > 0.2f)
			{
				targetAimedDuration += delta;
			}
		}
		else
		{
			if (num < 0.5f)
			{
				targetAimedDuration = 0f;
			}
			CancelBurst();
		}
		if (targetAimedDuration >= 0.2f && targetIsLOS)
		{
			bool flag = false;
			float dist = 0f;
			if (this != null)
			{
				flag = ((IAIAttack)this).IsTargetInRange((BaseEntity)target, out dist);
			}
			else
			{
				AttackEntity attackEntity = GetAttackEntity();
				if (Object.op_Implicit((Object)(object)attackEntity))
				{
					dist = (((Object)(object)target != (Object)null) ? Vector3.Distance(((Component)this).transform.position, ((Component)target).transform.position) : (-1f));
					flag = dist < attackEntity.effectiveRange * (attackEntity.aiOnlyInRange ? 1f : 2f);
				}
			}
			if (flag)
			{
				ShotTest(dist);
			}
		}
		else
		{
			CancelBurst();
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (base.isMounted)
		{
			info.damageTypes.ScaleAll(0.1f);
		}
		base.Hurt(info);
		BaseEntity initiator = info.Initiator;
		if ((Object)(object)initiator != (Object)null && !initiator.EqualNetID((BaseNetworkable)this))
		{
			Brain.Senses.Memory.SetKnown(initiator, this, null);
		}
	}

	public float GetAimSwayScalar()
	{
		return 1f - Mathf.InverseLerp(1f, 3f, Time.time - lastGunShotTime);
	}

	public override Vector3 GetAimDirection()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Brain != (Object)null && (Object)(object)Brain.Navigator != (Object)null && Brain.Navigator.IsOverridingFacingDirection)
		{
			return Brain.Navigator.FacingDirectionOverride;
		}
		return base.GetAimDirection();
	}

	public override void SetAimDirection(Vector3 newAim)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		if (newAim == Vector3.zero || base.eyes.IsUnityNull() || ((Component)this).transform.IsUnityNull<Transform>())
		{
			return;
		}
		float num = Time.time - lastAimSetTime;
		lastAimSetTime = Time.time;
		AttackEntity attackEntity = GetAttackEntity();
		if (Object.op_Implicit((Object)(object)attackEntity))
		{
			newAim = attackEntity.ModifyAIAim(newAim, GetAimSwayScalar());
		}
		Quaternion val;
		if (base.isMounted)
		{
			BaseMountable baseMountable = GetMounted();
			Vector3 eulerAngles = ((Component)baseMountable).transform.eulerAngles;
			val = Quaternion.LookRotation(newAim, ((Component)baseMountable).transform.up);
			Quaternion val2 = Quaternion.Euler(((Quaternion)(ref val)).eulerAngles);
			Quaternion val3 = Quaternion.LookRotation(((Component)this).transform.InverseTransformDirection(val2 * Vector3.forward), ((Component)this).transform.up);
			Vector3 eulerAngles2 = ((Quaternion)(ref val3)).eulerAngles;
			eulerAngles2 = BaseMountable.ConvertVector(eulerAngles2);
			Quaternion val4 = Quaternion.Euler(Mathf.Clamp(eulerAngles2.x, baseMountable.pitchClamp.x, baseMountable.pitchClamp.y), Mathf.Clamp(eulerAngles2.y, baseMountable.yawClamp.x, baseMountable.yawClamp.y), eulerAngles.z);
			Quaternion val5 = Quaternion.LookRotation(((Component)this).transform.TransformDirection(val4 * Vector3.forward), ((Component)this).transform.up);
			newAim = BaseMountable.ConvertVector(((Quaternion)(ref val5)).eulerAngles);
		}
		else
		{
			BaseEntity baseEntity = GetParentEntity();
			if (!baseEntity.IsUnityNull())
			{
				Vector3 val6 = ((Component)baseEntity).transform.InverseTransformDirection(newAim);
				Vector3 val7 = default(Vector3);
				((Vector3)(ref val7))..ctor(newAim.x, val6.y, newAim.z);
				base.eyes.rotation = Quaternion.Lerp(base.eyes.rotation, Quaternion.LookRotation(val7, ((Component)baseEntity).transform.up), num * 25f);
				val = base.eyes.bodyRotation;
				viewAngles = ((Quaternion)(ref val)).eulerAngles;
				ServerRotation = base.eyes.bodyRotation;
				return;
			}
		}
		base.eyes.rotation = (base.isMounted ? Quaternion.Slerp(base.eyes.rotation, Quaternion.Euler(newAim), num * 70f) : Quaternion.Lerp(base.eyes.rotation, Quaternion.LookRotation(newAim, ((Component)this).transform.up), num * 25f));
		val = base.eyes.rotation;
		viewAngles = ((Quaternion)(ref val)).eulerAngles;
		ServerRotation = base.eyes.rotation;
	}

	public void SetStationaryAimPoint(Vector3 aimAt)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		aimOverridePosition = aimAt;
	}

	public void ClearStationaryAimPoint()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		aimOverridePosition = Vector3.zero;
	}

	public override bool ShouldDropActiveItem()
	{
		return false;
	}

	public override void AttackerInfo(DeathInfo info)
	{
		base.AttackerInfo(info);
		info.inflictorName = base.inventory.containerBelt.GetSlot(0).info.shortname;
		if (DeathIconOverride != null && DeathIconOverride.isValid)
		{
			info.attackerName = Path.GetFileNameWithoutExtension(DeathIconOverride.resourcePath);
		}
		else
		{
			info.attackerName = base.ShortPrefabName;
		}
	}

	public bool IsThreat(BaseEntity entity)
	{
		return IsTarget(entity);
	}

	public bool IsTarget(BaseEntity entity)
	{
		if (entity is BasePlayer && !entity.IsNpc)
		{
			return true;
		}
		if (entity is BasePet)
		{
			return true;
		}
		if (entity is ScarecrowNPC)
		{
			return true;
		}
		return false;
	}

	public bool IsFriendly(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.prefabID == prefabID;
	}

	public bool CanAttack(BaseEntity entity)
	{
		return true;
	}

	public bool IsTargetInRange(BaseEntity entity, out float dist)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		dist = Vector3.Distance(((Component)entity).transform.position, ((Component)this).transform.position);
		return dist <= EngagementRange();
	}

	public bool CanSeeTarget(BaseEntity entity)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return CanSeeTarget(entity, Vector3.zero);
	}

	public bool CanSeeTarget(BaseEntity entity, Vector3 fromOffset)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return true;
		}
		if (AdditionalLosBlockingLayer == 0)
		{
			return IsPlayerVisibleToUs(basePlayer, fromOffset, 1218519041);
		}
		return IsPlayerVisibleToUs(basePlayer, fromOffset, 0x48A12001 | (1 << AdditionalLosBlockingLayer));
	}

	public bool NeedsToReload()
	{
		return false;
	}

	public bool Reload()
	{
		return true;
	}

	public float CooldownDuration()
	{
		return 5f;
	}

	public bool IsOnCooldown()
	{
		return false;
	}

	public bool StartAttacking(BaseEntity entity)
	{
		return true;
	}

	public void StopAttacking()
	{
	}

	public float GetAmmoFraction()
	{
		return AmmoFractionRemaining();
	}

	public BaseEntity GetBestTarget()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity result = null;
		float num = -1f;
		foreach (BaseEntity player in Brain.Senses.Players)
		{
			if (!((Object)(object)player == (Object)null) && !(player.Health() <= 0f) && Interface.CallHook("OnNpcTarget", (object)this, (object)player) == null)
			{
				float num2 = Vector3.Distance(((Component)player).transform.position, ((Component)this).transform.position);
				float num3 = 1f - Mathf.InverseLerp(1f, Brain.SenseRange, num2);
				Vector3 val = ((Component)player).transform.position - base.eyes.position;
				float num4 = Vector3.Dot(((Vector3)(ref val)).normalized, base.eyes.BodyForward());
				num3 += Mathf.InverseLerp(Brain.VisionCone, 1f, num4) / 2f;
				num3 += (Brain.Senses.Memory.IsLOS(player) ? 2f : 0f);
				if (num3 > num)
				{
					result = player;
					num = num3;
				}
			}
		}
		return result;
	}

	public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
	{
		BaseCombatEntity target2 = target as BaseCombatEntity;
		TickAttack(delta, target2, targetIsLOS);
	}

	public void UseHealingItem(Item item)
	{
		((MonoBehaviour)this).StartCoroutine(Heal(item));
	}

	private IEnumerator Heal(Item item)
	{
		UpdateActiveItem(item.uid);
		Item activeItem = GetActiveItem();
		MedicalTool heldItem = activeItem.GetHeldEntity() as MedicalTool;
		if (!((Object)(object)heldItem == (Object)null))
		{
			yield return (object)new WaitForSeconds(1f);
			heldItem.ServerUse(1f, 1f, null);
			Heal(MaxHealth());
			yield return (object)new WaitForSeconds(2f);
			EquipWeapon();
		}
	}

	public Item FindHealingItem()
	{
		if ((Object)(object)Brain == (Object)null)
		{
			return null;
		}
		if (!Brain.CanUseHealingItems)
		{
			return null;
		}
		if ((Object)(object)base.inventory == (Object)null || base.inventory.containerBelt == null)
		{
			return null;
		}
		for (int i = 0; i < base.inventory.containerBelt.capacity; i++)
		{
			Item slot = base.inventory.containerBelt.GetSlot(i);
			if (slot != null && slot.amount > 1 && (Object)(object)(slot.GetHeldEntity() as MedicalTool) != (Object)null)
			{
				return slot;
			}
		}
		return null;
	}

	protected override void ApplyLoot(NPCPlayerCorpse corpse)
	{
		base.ApplyLoot(corpse);
		if (LootSpawnSlots.Length != 0)
		{
			LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
			for (int i = 0; i < lootSpawnSlots.Length; i++)
			{
				LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
				for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
				{
					if ((string.IsNullOrEmpty(lootSpawnSlot.onlyWithLoadoutNamed) || lootSpawnSlot.onlyWithLoadoutNamed == GetLoadoutName()) && Random.Range(0f, 1f) <= lootSpawnSlot.probability)
					{
						lootSpawnSlot.definition.SpawnIntoContainer(corpse.containers[0]);
					}
				}
			}
		}
		if (Server.npcAmmoLootMultiplier == 1f)
		{
			return;
		}
		foreach (Item item in corpse.containers[0].itemList)
		{
			if ((item.info.lootDistributionType & ItemDefinition.LootDistributionModifierType.FirearmAmmunition) == ItemDefinition.LootDistributionModifierType.FirearmAmmunition)
			{
				item.amount = Mathf.Max(1, Mathf.RoundToInt((float)item.amount * Server.npcAmmoLootMultiplier));
			}
		}
	}

	public override bool IsOnGround()
	{
		return true;
	}
}


using UnityEngine;

public class HumanPathFinder : BasePathFinder
{
	private BaseEntity npc;

	public void Init(BaseEntity npc)
	{
		this.npc = npc;
	}

	public override AIMovePoint GetBestRoamPoint(Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float anchorClampDistance, float lookupMaxRange = 20f)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		AIInformationZone aIInformationZone = null;
		if (npc is HumanNPC humanNPC)
		{
			aIInformationZone = ((!((Object)(object)humanNPC.VirtualInfoZone != (Object)null)) ? humanNPC.GetInformationZone(currentPos) : humanNPC.VirtualInfoZone);
		}
		if ((Object)(object)aIInformationZone == (Object)null)
		{
			return null;
		}
		return GetBestRoamPoint(aIInformationZone, anchorPos, currentPos, currentDirection, anchorClampDistance, lookupMaxRange);
	}

	private AIMovePoint GetBestRoamPoint(AIInformationZone aiZone, Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float clampDistance, float lookupMaxRange)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)aiZone == (Object)null)
		{
			return null;
		}
		bool flag = clampDistance > -1f;
		float num = float.NegativeInfinity;
		AIPoint aIPoint = null;
		int pointCount;
		AIPoint[] movePointsInRange = aiZone.GetMovePointsInRange(anchorPos, lookupMaxRange, out pointCount);
		if (movePointsInRange == null || pointCount <= 0)
		{
			return null;
		}
		for (int i = 0; i < pointCount; i++)
		{
			AIPoint aIPoint2 = movePointsInRange[i];
			if (!((Component)((Component)aIPoint2).transform.parent).gameObject.activeSelf)
			{
				continue;
			}
			float num2 = Mathf.Abs(currentPos.y - ((Component)aIPoint2).transform.position.y);
			bool flag2 = currentPos.y < WaterSystem.OceanLevel;
			if (!flag2 && ((!flag2 && ((Component)aIPoint2).transform.position.y < WaterSystem.OceanLevel) || (currentPos.y >= WaterSystem.OceanLevel && num2 > 5f)))
			{
				continue;
			}
			float num3 = 0f;
			float num4 = Vector3.Dot(currentDirection, Vector3Ex.Direction2D(((Component)aIPoint2).transform.position, currentPos));
			num3 += Mathf.InverseLerp(-1f, 1f, num4) * 100f;
			if (!aIPoint2.InUse())
			{
				num3 += 1000f;
			}
			num3 += (1f - Mathf.InverseLerp(1f, 10f, num2)) * 100f;
			float num5 = Vector3.Distance(currentPos, ((Component)aIPoint2).transform.position);
			if (num5 <= 1f)
			{
				num3 -= 3000f;
			}
			if (flag)
			{
				float num6 = Vector3.Distance(anchorPos, ((Component)aIPoint2).transform.position);
				if (num6 <= clampDistance)
				{
					num3 += 1000f;
					num3 += (1f - Mathf.InverseLerp(0f, clampDistance, num6)) * 200f * Random.Range(0.8f, 1f);
				}
			}
			else if (num5 > 3f)
			{
				num3 += Mathf.InverseLerp(3f, lookupMaxRange, num5) * 50f;
			}
			if (num3 > num)
			{
				aIPoint = aIPoint2;
				num = num3;
			}
		}
		return aIPoint as AIMovePoint;
	}
}


public interface IThinker
{
	void TryThink();
}


using UnityEngine;

public class ScientistBrain : BaseAIBrain
{
	public class BlindedState : BaseBlindedState
	{
		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			HumanNPC obj = entity as HumanNPC;
			obj.SetDucked(flag: false);
			obj.Server_StartGesture(235662700u);
			brain.Navigator.SetDestination(brain.PathFinder.GetRandomPositionAround(((Component)entity).transform.position, 1f, 2.5f), BaseNavigator.NavigationSpeed.Slowest);
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
			if ((Object)(object)entity.ToPlayer() != (Object)null)
			{
				entity.ToPlayer().Server_CancelGesture();
			}
		}
	}

	public class ChaseState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		private float nextPositionUpdateTime;

		public ChaseState()
			: base(AIState.Chase)
		{
			base.AgrresiveState = true;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder != null)
			{
				status = StateStatus.Running;
				nextPositionUpdateTime = 0f;
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
			brain.Navigator.ClearFacingDirectionOverride();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0393: Unknown result type (might be due to invalid IL or missing references)
			//IL_0379: Unknown result type (might be due to invalid IL or missing references)
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0348: Unknown result type (might be due to invalid IL or missing references)
			//IL_035f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0364: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_025d: Unknown result type (might be due to invalid IL or missing references)
			//IL_025f: Unknown result type (might be due to invalid IL or missing references)
			//IL_021c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0221: Unknown result type (might be due to invalid IL or missing references)
			//IL_0226: Unknown result type (might be due to invalid IL or missing references)
			//IL_022b: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				return StateStatus.Error;
			}
			float num = Vector3.Distance(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
			if (brain.Senses.Memory.IsLOS(baseEntity) || num <= brain.Navigator.FaceTargetChaseDistance || base.TimeInState <= 5f)
			{
				brain.Navigator.SetFacingDirectionEntity(baseEntity);
			}
			else
			{
				brain.Navigator.ClearFacingDirectionOverride();
			}
			if (num <= 10f)
			{
				brain.Navigator.SetCurrentSpeed(BaseNavigator.NavigationSpeed.Normal);
			}
			else
			{
				brain.Navigator.SetCurrentSpeed(BaseNavigator.NavigationSpeed.Fast);
			}
			if (Time.time > nextPositionUpdateTime)
			{
				nextPositionUpdateTime = Time.time + Random.Range(0.5f, 1f);
				Vector3 pos = ((Component)entity).transform.position;
				AIInformationZone informationZone = (entity as HumanNPC).GetInformationZone(((Component)baseEntity).transform.position);
				bool flag = false;
				if ((Object)(object)informationZone != (Object)null)
				{
					AIMovePoint aIMovePoint = informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity);
					flag = (Object)(object)aIMovePoint != (Object)null;
					if (!flag && brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint)
					{
						float num2 = brain.Navigator.BestMovementPointMaxDistance * brain.Navigator.PathFindChaseLOSDistanceMultiplier;
						if (num <= num2 && Vector3.Distance(((Component)baseEntity).transform.position, brain.Events.Memory.Position.Get(4)) <= num2)
						{
							Vector3 val = ((Component)brain).transform.position;
							bool flag2 = false;
							for (int i = 0; i < brain.Navigator.PathFindChaseLOSAttemptCount; i++)
							{
								val = brain.PathFinder.GetRandomPositionAround(((Component)baseEntity).transform.position, 1.5f, 7f) + Vector3.up;
								BasePlayer obj = baseEntity as BasePlayer;
								HumanNPC humanNPC = entity as HumanNPC;
								if ((Object)(object)obj != (Object)null && (Object)(object)humanNPC != (Object)null)
								{
									flag2 = !Physics.Linecast(((Component)baseEntity).transform.position + Vector3.up, val, 1218519297, (QueryTriggerInteraction)1);
								}
								if (flag2)
								{
									break;
								}
							}
							if (flag2)
							{
								pos = val;
							}
							flag = flag2;
							nextPositionUpdateTime = Time.time + Random.Range(5f, 8f);
						}
					}
					if (!flag && brain.Navigator.CanUseRandomMovePointIfNonFound)
					{
						aIMovePoint = informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: false, returnRandom: true);
						if ((Object)(object)aIMovePoint != (Object)null)
						{
							nextPositionUpdateTime = Time.time + 15f;
						}
						flag = true;
					}
					if (!flag)
					{
						aIMovePoint = ((!brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint) ? informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: true) : informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: true, returnRandom: true));
						flag = (Object)(object)aIMovePoint != (Object)null;
					}
					if (Object.op_Implicit((Object)(object)aIMovePoint))
					{
						aIMovePoint.SetUsedBy(entity, 5f);
						pos = brain.PathFinder.GetRandomPositionAround(((Component)aIMovePoint).transform.position, 0f, aIMovePoint.radius - 0.3f);
					}
				}
				if (!flag)
				{
					return StateStatus.Error;
				}
				if (num < 10f)
				{
					brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Normal);
				}
				else
				{
					brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast);
				}
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public class CombatState : BasicAIState
	{
		private float nextActionTime;

		private Vector3 combatStartPosition;

		public CombatState()
			: base(AIState.Combat)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			combatStartPosition = ((Component)entity).transform.position;
			FaceTarget();
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			(entity as HumanNPC).SetDucked(flag: false);
			brain.Navigator.ClearFacingDirectionOverride();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			HumanNPC humanNPC = entity as HumanNPC;
			FaceTarget();
			if (Time.time > nextActionTime)
			{
				if (Random.Range(0, 3) == 1)
				{
					nextActionTime = Time.time + Random.Range(1f, 2f);
					humanNPC.SetDucked(flag: true);
					brain.Navigator.Stop();
				}
				else
				{
					nextActionTime = Time.time + Random.Range(2f, 3f);
					humanNPC.SetDucked(flag: false);
					brain.Navigator.SetDestination(brain.PathFinder.GetRandomPositionAround(combatStartPosition, 1f), BaseNavigator.NavigationSpeed.Normal);
				}
			}
			return StateStatus.Running;
		}

		private void FaceTarget()
		{
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				brain.Navigator.ClearFacingDirectionOverride();
			}
			else
			{
				brain.Navigator.SetFacingDirectionEntity(baseEntity);
			}
		}
	}

	public class CombatStationaryState : BasicAIState
	{
		public CombatStationaryState()
			: base(AIState.CombatStationary)
		{
			base.AgrresiveState = true;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				brain.Navigator.SetFacingDirectionEntity(baseEntity);
			}
			else
			{
				brain.Navigator.ClearFacingDirectionOverride();
			}
			return StateStatus.Running;
		}
	}

	public class CoverState : BasicAIState
	{
		public CoverState()
			: base(AIState.Cover)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			HumanNPC humanNPC = entity as HumanNPC;
			humanNPC.SetDucked(flag: true);
			AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
			if ((Object)(object)aIPoint != (Object)null)
			{
				aIPoint.SetUsedBy(entity);
			}
			if (!(humanNPC.healthFraction <= brain.HealBelowHealthFraction) || !(Random.Range(0f, 1f) <= brain.HealChance))
			{
				return;
			}
			Item item = humanNPC.FindHealingItem();
			if (item != null)
			{
				BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
				if ((Object)(object)baseEntity == (Object)null || (!brain.Senses.Memory.IsLOS(baseEntity) && Vector3.Distance(((Component)entity).transform.position, ((Component)baseEntity).transform.position) >= 5f))
				{
					humanNPC.UseHealingItem(item);
				}
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			(entity as HumanNPC).SetDucked(flag: false);
			brain.Navigator.ClearFacingDirectionOverride();
			AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
			if ((Object)(object)aIPoint != (Object)null)
			{
				aIPoint.ClearIfUsedBy(entity);
			}
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			HumanNPC humanNPC = entity as HumanNPC;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			float num = humanNPC.AmmoFractionRemaining();
			if (num == 0f || ((Object)(object)baseEntity != (Object)null && !brain.Senses.Memory.IsLOS(baseEntity) && num < 0.25f))
			{
				humanNPC.AttemptReload();
			}
			if ((Object)(object)baseEntity != (Object)null)
			{
				brain.Navigator.SetFacingDirectionEntity(baseEntity);
			}
			return StateStatus.Running;
		}
	}

	public class DismountedState : BaseDismountedState
	{
		private StateStatus status = StateStatus.Error;

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder == null)
			{
				return;
			}
			AIInformationZone informationZone = (entity as HumanNPC).GetInformationZone(((Component)entity).transform.position);
			if (!((Object)(object)informationZone == (Object)null))
			{
				AICoverPoint bestCoverPoint = informationZone.GetBestCoverPoint(((Component)entity).transform.position, ((Component)entity).transform.position, 25f, 50f, entity);
				if (Object.op_Implicit((Object)(object)bestCoverPoint))
				{
					bestCoverPoint.SetUsedBy(entity, 10f);
				}
				Vector3 pos = (((Object)(object)bestCoverPoint == (Object)null) ? ((Component)entity).transform.position : ((Component)bestCoverPoint).transform.position);
				if (brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast))
				{
					status = StateStatus.Running;
				}
			}
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public class IdleState : BaseIdleState
	{
	}

	public class KillSelfState : BasicAIState
	{
		public KillSelfState()
			: base(AIState.KillSelf)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			entity.Kill();
		}
	}

	public class MountAPC : BasicAIState
	{
		public MountAPC()
			: base(AIState.MountAPC)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			BradleyAPC bradleyAPC = brain.Events.Memory.Entity.Get(7) as BradleyAPC;
			if ((Object)(object)bradleyAPC != (Object)null)
			{
				bradleyAPC.OnScientistMounted(entity as ScientistNPC);
			}
			entity.Kill();
		}
	}

	public class MountedState : BaseMountedState
	{
	}

	public class MoveToVector3State : BasicAIState
	{
		public MoveToVector3State()
			: base(AIState.MoveToVector3)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
			brain.Navigator.ClearFacingDirectionOverride();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			Vector3 pos = brain.Events.Memory.Position.Get(7);
			if (!brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast, 0.5f))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	public class RoamState : BaseRoamState
	{
		private StateStatus status = StateStatus.Error;

		private AIMovePoint roamPoint;

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
			ClearRoamPointUsage(entity);
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			ClearRoamPointUsage(entity);
			if (brain.PathFinder == null)
			{
				return;
			}
			status = StateStatus.Error;
			roamPoint = brain.PathFinder.GetBestRoamPoint(GetRoamAnchorPosition(), ((Component)entity).transform.position, (entity as HumanNPC).eyes.BodyForward(), brain.Navigator.MaxRoamDistanceFromHome, brain.Navigator.BestRoamPointMaxDistance);
			if ((Object)(object)roamPoint != (Object)null)
			{
				if (brain.Navigator.SetDestination(((Component)roamPoint).transform.position, BaseNavigator.NavigationSpeed.Slow))
				{
					roamPoint.SetUsedBy(entity);
					status = StateStatus.Running;
				}
				else
				{
					roamPoint.SetUsedBy(entity, 600f);
				}
			}
		}

		private void ClearRoamPointUsage(BaseEntity entity)
		{
			if ((Object)(object)roamPoint != (Object)null)
			{
				roamPoint.ClearIfUsedBy(entity);
				roamPoint = null;
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			PickGoodLookDirection();
			return StateStatus.Finished;
		}

		private void PickGoodLookDirection()
		{
		}
	}

	public class TakeCoverState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		private BaseEntity coverFromEntity;

		public TakeCoverState()
			: base(AIState.TakeCover)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			status = StateStatus.Running;
			if (!StartMovingToCover(entity as HumanNPC))
			{
				status = StateStatus.Error;
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
			ClearCoverPointUsage(entity);
		}

		private void ClearCoverPointUsage(BaseEntity entity)
		{
			AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
			if ((Object)(object)aIPoint != (Object)null)
			{
				aIPoint.ClearIfUsedBy(entity);
			}
		}

		private bool StartMovingToCover(HumanNPC entity)
		{
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			coverFromEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			Vector3 hideFromPosition = (Object.op_Implicit((Object)(object)coverFromEntity) ? ((Component)coverFromEntity).transform.position : (((Component)entity).transform.position + entity.LastAttackedDir * 30f));
			AIInformationZone informationZone = entity.GetInformationZone(((Component)entity).transform.position);
			if ((Object)(object)informationZone == (Object)null)
			{
				return false;
			}
			float minRange = ((entity.SecondsSinceAttacked < 2f) ? 2f : 0f);
			float bestCoverPointMaxDistance = brain.Navigator.BestCoverPointMaxDistance;
			AICoverPoint bestCoverPoint = informationZone.GetBestCoverPoint(((Component)entity).transform.position, hideFromPosition, minRange, bestCoverPointMaxDistance, entity);
			if ((Object)(object)bestCoverPoint == (Object)null)
			{
				return false;
			}
			Vector3 position = ((Component)bestCoverPoint).transform.position;
			if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Normal))
			{
				return false;
			}
			FaceCoverFromEntity();
			brain.Events.Memory.AIPoint.Set(bestCoverPoint, 4);
			bestCoverPoint.SetUsedBy(entity);
			return true;
		}

		public override void DrawGizmos()
		{
			base.DrawGizmos();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			FaceCoverFromEntity();
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}

		private void FaceCoverFromEntity()
		{
			coverFromEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if (!((Object)(object)coverFromEntity == (Object)null))
			{
				brain.Navigator.SetFacingDirectionEntity(coverFromEntity);
			}
		}
	}

	public static int Count;

	public override void AddStates()
	{
		base.AddStates();
		AddState(new IdleState());
		AddState(new RoamState());
		AddState(new ChaseState());
		AddState(new CombatState());
		AddState(new TakeCoverState());
		AddState(new CoverState());
		AddState(new MountedState());
		AddState(new DismountedState());
		AddState(new BaseFollowPathState());
		AddState(new BaseNavigateHomeState());
		AddState(new CombatStationaryState());
		AddState(new BaseMoveTorwardsState());
		AddState(new MoveToVector3State());
		AddState(new BlindedState());
		AddState(new KillSelfState());
		AddState(new MountAPC());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new HumanPathFinder();
		((HumanPathFinder)base.PathFinder).Init(GetBaseEntity());
		Count++;
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		Count--;
	}

	public HumanNPC GetEntity()
	{
		return GetBaseEntity() as HumanNPC;
	}

	protected override void OnStateChanged()
	{
		base.OnStateChanged();
		if (base.CurrentState != null)
		{
			switch (base.CurrentState.StateType)
			{
			case AIState.Idle:
			case AIState.Roam:
			case AIState.Patrol:
			case AIState.FollowPath:
			case AIState.Cooldown:
				GetEntity().SetPlayerFlag(BasePlayer.PlayerFlags.Relaxed, b: true);
				break;
			default:
				GetEntity().SetPlayerFlag(BasePlayer.PlayerFlags.Relaxed, b: false);
				break;
			}
		}
	}
}


using UnityEngine;

public class BlindedState : BaseBlindedState
{
	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		HumanNPC obj = entity as HumanNPC;
		obj.SetDucked(flag: false);
		obj.Server_StartGesture(235662700u);
		brain.Navigator.SetDestination(brain.PathFinder.GetRandomPositionAround(((Component)entity).transform.position, 1f, 2.5f), BaseNavigator.NavigationSpeed.Slowest);
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
		if ((Object)(object)entity.ToPlayer() != (Object)null)
		{
			entity.ToPlayer().Server_CancelGesture();
		}
	}
}


using UnityEngine;

public class ChaseState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	private float nextPositionUpdateTime;

	public ChaseState()
		: base(AIState.Chase)
	{
		base.AgrresiveState = true;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder != null)
		{
			status = StateStatus.Running;
			nextPositionUpdateTime = 0f;
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
		brain.Navigator.ClearFacingDirectionOverride();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return StateStatus.Error;
		}
		float num = Vector3.Distance(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
		if (brain.Senses.Memory.IsLOS(baseEntity) || num <= brain.Navigator.FaceTargetChaseDistance || base.TimeInState <= 5f)
		{
			brain.Navigator.SetFacingDirectionEntity(baseEntity);
		}
		else
		{
			brain.Navigator.ClearFacingDirectionOverride();
		}
		if (num <= 10f)
		{
			brain.Navigator.SetCurrentSpeed(BaseNavigator.NavigationSpeed.Normal);
		}
		else
		{
			brain.Navigator.SetCurrentSpeed(BaseNavigator.NavigationSpeed.Fast);
		}
		if (Time.time > nextPositionUpdateTime)
		{
			nextPositionUpdateTime = Time.time + Random.Range(0.5f, 1f);
			Vector3 pos = ((Component)entity).transform.position;
			AIInformationZone informationZone = (entity as HumanNPC).GetInformationZone(((Component)baseEntity).transform.position);
			bool flag = false;
			if ((Object)(object)informationZone != (Object)null)
			{
				AIMovePoint aIMovePoint = informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity);
				flag = (Object)(object)aIMovePoint != (Object)null;
				if (!flag && brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint)
				{
					float num2 = brain.Navigator.BestMovementPointMaxDistance * brain.Navigator.PathFindChaseLOSDistanceMultiplier;
					if (num <= num2 && Vector3.Distance(((Component)baseEntity).transform.position, brain.Events.Memory.Position.Get(4)) <= num2)
					{
						Vector3 val = ((Component)brain).transform.position;
						bool flag2 = false;
						for (int i = 0; i < brain.Navigator.PathFindChaseLOSAttemptCount; i++)
						{
							val = brain.PathFinder.GetRandomPositionAround(((Component)baseEntity).transform.position, 1.5f, 7f) + Vector3.up;
							BasePlayer obj = baseEntity as BasePlayer;
							HumanNPC humanNPC = entity as HumanNPC;
							if ((Object)(object)obj != (Object)null && (Object)(object)humanNPC != (Object)null)
							{
								flag2 = !Physics.Linecast(((Component)baseEntity).transform.position + Vector3.up, val, 1218519297, (QueryTriggerInteraction)1);
							}
							if (flag2)
							{
								break;
							}
						}
						if (flag2)
						{
							pos = val;
						}
						flag = flag2;
						nextPositionUpdateTime = Time.time + Random.Range(5f, 8f);
					}
				}
				if (!flag && brain.Navigator.CanUseRandomMovePointIfNonFound)
				{
					aIMovePoint = informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: false, returnRandom: true);
					if ((Object)(object)aIMovePoint != (Object)null)
					{
						nextPositionUpdateTime = Time.time + 15f;
					}
					flag = true;
				}
				if (!flag)
				{
					aIMovePoint = ((!brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint) ? informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: true) : informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: true, returnRandom: true));
					flag = (Object)(object)aIMovePoint != (Object)null;
				}
				if (Object.op_Implicit((Object)(object)aIMovePoint))
				{
					aIMovePoint.SetUsedBy(entity, 5f);
					pos = brain.PathFinder.GetRandomPositionAround(((Component)aIMovePoint).transform.position, 0f, aIMovePoint.radius - 0.3f);
				}
			}
			if (!flag)
			{
				return StateStatus.Error;
			}
			if (num < 10f)
			{
				brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Normal);
			}
			else
			{
				brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast);
			}
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


using UnityEngine;

public class CombatState : BasicAIState
{
	private float nextActionTime;

	private Vector3 combatStartPosition;

	public CombatState()
		: base(AIState.Combat)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		combatStartPosition = ((Component)entity).transform.position;
		FaceTarget();
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		(entity as HumanNPC).SetDucked(flag: false);
		brain.Navigator.ClearFacingDirectionOverride();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		HumanNPC humanNPC = entity as HumanNPC;
		FaceTarget();
		if (Time.time > nextActionTime)
		{
			if (Random.Range(0, 3) == 1)
			{
				nextActionTime = Time.time + Random.Range(1f, 2f);
				humanNPC.SetDucked(flag: true);
				brain.Navigator.Stop();
			}
			else
			{
				nextActionTime = Time.time + Random.Range(2f, 3f);
				humanNPC.SetDucked(flag: false);
				brain.Navigator.SetDestination(brain.PathFinder.GetRandomPositionAround(combatStartPosition, 1f), BaseNavigator.NavigationSpeed.Normal);
			}
		}
		return StateStatus.Running;
	}

	private void FaceTarget()
	{
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			brain.Navigator.ClearFacingDirectionOverride();
		}
		else
		{
			brain.Navigator.SetFacingDirectionEntity(baseEntity);
		}
	}
}


using UnityEngine;

public class CombatStationaryState : BasicAIState
{
	public CombatStationaryState()
		: base(AIState.CombatStationary)
	{
		base.AgrresiveState = true;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			brain.Navigator.SetFacingDirectionEntity(baseEntity);
		}
		else
		{
			brain.Navigator.ClearFacingDirectionOverride();
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class CoverState : BasicAIState
{
	public CoverState()
		: base(AIState.Cover)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		HumanNPC humanNPC = entity as HumanNPC;
		humanNPC.SetDucked(flag: true);
		AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
		if ((Object)(object)aIPoint != (Object)null)
		{
			aIPoint.SetUsedBy(entity);
		}
		if (!(humanNPC.healthFraction <= brain.HealBelowHealthFraction) || !(Random.Range(0f, 1f) <= brain.HealChance))
		{
			return;
		}
		Item item = humanNPC.FindHealingItem();
		if (item != null)
		{
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null || (!brain.Senses.Memory.IsLOS(baseEntity) && Vector3.Distance(((Component)entity).transform.position, ((Component)baseEntity).transform.position) >= 5f))
			{
				humanNPC.UseHealingItem(item);
			}
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		(entity as HumanNPC).SetDucked(flag: false);
		brain.Navigator.ClearFacingDirectionOverride();
		AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
		if ((Object)(object)aIPoint != (Object)null)
		{
			aIPoint.ClearIfUsedBy(entity);
		}
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		HumanNPC humanNPC = entity as HumanNPC;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		float num = humanNPC.AmmoFractionRemaining();
		if (num == 0f || ((Object)(object)baseEntity != (Object)null && !brain.Senses.Memory.IsLOS(baseEntity) && num < 0.25f))
		{
			humanNPC.AttemptReload();
		}
		if ((Object)(object)baseEntity != (Object)null)
		{
			brain.Navigator.SetFacingDirectionEntity(baseEntity);
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class DismountedState : BaseDismountedState
{
	private StateStatus status = StateStatus.Error;

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder == null)
		{
			return;
		}
		AIInformationZone informationZone = (entity as HumanNPC).GetInformationZone(((Component)entity).transform.position);
		if (!((Object)(object)informationZone == (Object)null))
		{
			AICoverPoint bestCoverPoint = informationZone.GetBestCoverPoint(((Component)entity).transform.position, ((Component)entity).transform.position, 25f, 50f, entity);
			if (Object.op_Implicit((Object)(object)bestCoverPoint))
			{
				bestCoverPoint.SetUsedBy(entity, 10f);
			}
			Vector3 pos = (((Object)(object)bestCoverPoint == (Object)null) ? ((Component)entity).transform.position : ((Component)bestCoverPoint).transform.position);
			if (brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast))
			{
				status = StateStatus.Running;
			}
		}
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


public class IdleState : BaseIdleState
{
}


public class KillSelfState : BasicAIState
{
	public KillSelfState()
		: base(AIState.KillSelf)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		entity.Kill();
	}
}


using UnityEngine;

public class MountAPC : BasicAIState
{
	public MountAPC()
		: base(AIState.MountAPC)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		BradleyAPC bradleyAPC = brain.Events.Memory.Entity.Get(7) as BradleyAPC;
		if ((Object)(object)bradleyAPC != (Object)null)
		{
			bradleyAPC.OnScientistMounted(entity as ScientistNPC);
		}
		entity.Kill();
	}
}


public class MountedState : BaseMountedState
{
}


using UnityEngine;

public class MoveToVector3State : BasicAIState
{
	public MoveToVector3State()
		: base(AIState.MoveToVector3)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
		brain.Navigator.ClearFacingDirectionOverride();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		Vector3 pos = brain.Events.Memory.Position.Get(7);
		if (!brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast, 0.5f))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class RoamState : BaseRoamState
{
	private StateStatus status = StateStatus.Error;

	private AIMovePoint roamPoint;

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
		ClearRoamPointUsage(entity);
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		ClearRoamPointUsage(entity);
		if (brain.PathFinder == null)
		{
			return;
		}
		status = StateStatus.Error;
		roamPoint = brain.PathFinder.GetBestRoamPoint(GetRoamAnchorPosition(), ((Component)entity).transform.position, (entity as HumanNPC).eyes.BodyForward(), brain.Navigator.MaxRoamDistanceFromHome, brain.Navigator.BestRoamPointMaxDistance);
		if ((Object)(object)roamPoint != (Object)null)
		{
			if (brain.Navigator.SetDestination(((Component)roamPoint).transform.position, BaseNavigator.NavigationSpeed.Slow))
			{
				roamPoint.SetUsedBy(entity);
				status = StateStatus.Running;
			}
			else
			{
				roamPoint.SetUsedBy(entity, 600f);
			}
		}
	}

	private void ClearRoamPointUsage(BaseEntity entity)
	{
		if ((Object)(object)roamPoint != (Object)null)
		{
			roamPoint.ClearIfUsedBy(entity);
			roamPoint = null;
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		PickGoodLookDirection();
		return StateStatus.Finished;
	}

	private void PickGoodLookDirection()
	{
	}
}


using UnityEngine;

public class TakeCoverState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	private BaseEntity coverFromEntity;

	public TakeCoverState()
		: base(AIState.TakeCover)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		status = StateStatus.Running;
		if (!StartMovingToCover(entity as HumanNPC))
		{
			status = StateStatus.Error;
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
		ClearCoverPointUsage(entity);
	}

	private void ClearCoverPointUsage(BaseEntity entity)
	{
		AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
		if ((Object)(object)aIPoint != (Object)null)
		{
			aIPoint.ClearIfUsedBy(entity);
		}
	}

	private bool StartMovingToCover(HumanNPC entity)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		coverFromEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		Vector3 hideFromPosition = (Object.op_Implicit((Object)(object)coverFromEntity) ? ((Component)coverFromEntity).transform.position : (((Component)entity).transform.position + entity.LastAttackedDir * 30f));
		AIInformationZone informationZone = entity.GetInformationZone(((Component)entity).transform.position);
		if ((Object)(object)informationZone == (Object)null)
		{
			return false;
		}
		float minRange = ((entity.SecondsSinceAttacked < 2f) ? 2f : 0f);
		float bestCoverPointMaxDistance = brain.Navigator.BestCoverPointMaxDistance;
		AICoverPoint bestCoverPoint = informationZone.GetBestCoverPoint(((Component)entity).transform.position, hideFromPosition, minRange, bestCoverPointMaxDistance, entity);
		if ((Object)(object)bestCoverPoint == (Object)null)
		{
			return false;
		}
		Vector3 position = ((Component)bestCoverPoint).transform.position;
		if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Normal))
		{
			return false;
		}
		FaceCoverFromEntity();
		brain.Events.Memory.AIPoint.Set(bestCoverPoint, 4);
		bestCoverPoint.SetUsedBy(entity);
		return true;
	}

	public override void DrawGizmos()
	{
		base.DrawGizmos();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		FaceCoverFromEntity();
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}

	private void FaceCoverFromEntity()
	{
		coverFromEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if (!((Object)(object)coverFromEntity == (Object)null))
		{
			brain.Navigator.SetFacingDirectionEntity(coverFromEntity);
		}
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class ScientistNPC : HumanNPC, IAIMounted
{
	public enum RadioChatterType
	{
		NONE,
		Idle,
		Alert
	}

	public GameObjectRef[] RadioChatterEffects;

	public GameObjectRef[] DeathEffects;

	public string deathStatName = "kill_scientist";

	public static readonly Phrase ScientistName = new Phrase("npc_scientist", "Scientist");

	public Vector2 IdleChatterRepeatRange = new Vector2(10f, 15f);

	public RadioChatterType radioChatterType;

	public float lastAlertedTime = -100f;

	public override string displayName => ScientistName.translated;

	public void SetChatterType(RadioChatterType newType)
	{
		if (newType != radioChatterType)
		{
			if (newType == RadioChatterType.Idle)
			{
				QueueRadioChatter();
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)PlayRadioChatter);
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetChatterType(RadioChatterType.Idle);
		((FacepunchBehaviour)this).InvokeRandomized((Action)IdleCheck, 0f, 20f, 1f);
	}

	public void IdleCheck()
	{
		if (Time.time > lastAlertedTime + 20f)
		{
			SetChatterType(RadioChatterType.Idle);
		}
	}

	public void QueueRadioChatter()
	{
		if (IsAlive() && !base.IsDestroyed)
		{
			((FacepunchBehaviour)this).Invoke((Action)PlayRadioChatter, Random.Range(IdleChatterRepeatRange.x, IdleChatterRepeatRange.y));
		}
	}

	public override bool ShotTest(float targetDist)
	{
		bool result = base.ShotTest(targetDist);
		if (Time.time - lastGunShotTime < 5f)
		{
			Alert();
		}
		return result;
	}

	public void Alert()
	{
		if (Interface.CallHook("OnNpcAlert", (object)this) == null)
		{
			lastAlertedTime = Time.time;
			SetChatterType(RadioChatterType.Alert);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		Alert();
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		base.OnDied(info);
		SetChatterType(RadioChatterType.NONE);
		if (DeathEffects.Length != 0)
		{
			Effect.server.Run(DeathEffects[Random.Range(0, DeathEffects.Length)].resourcePath, ServerPosition, Vector3.up);
		}
		if (info != null && (Object)(object)info.InitiatorPlayer != (Object)null && !info.InitiatorPlayer.IsNpc)
		{
			info.InitiatorPlayer.stats.Add(deathStatName, 1, (Stats)5);
		}
	}

	public void PlayRadioChatter()
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (RadioChatterEffects.Length != 0)
		{
			if (base.IsDestroyed || (Object)(object)((Component)this).transform == (Object)null)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)PlayRadioChatter);
			}
			else if (Interface.CallHook("OnNpcRadioChatter", (object)this) == null)
			{
				Effect.server.Run(RadioChatterEffects[Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
				QueueRadioChatter();
			}
		}
	}

	public override void EquipWeapon(bool skipDeployDelay = false)
	{
		base.EquipWeapon(skipDeployDelay);
		HeldEntity heldEntity = GetHeldEntity();
		if (!((Object)(object)heldEntity != (Object)null))
		{
			return;
		}
		Item item = heldEntity.GetItem();
		if (item == null || item.contents == null || Interface.CallHook("OnNpcEquipWeapon", (object)this, (object)item) != null)
		{
			return;
		}
		if (Random.Range(0, 3) == 0)
		{
			Item item2 = ItemManager.CreateByName("weapon.mod.flashlight", 1, 0uL);
			if (!item2.MoveToContainer(item.contents))
			{
				item2.Remove();
				return;
			}
			lightsOn = false;
			((FacepunchBehaviour)this).InvokeRandomized((Action)base.LightCheck, 0f, 30f, 5f);
			LightCheck();
		}
		else
		{
			Item item3 = ItemManager.CreateByName("weapon.mod.lasersight", 1, 0uL);
			if (!item3.MoveToContainer(item.contents))
			{
				item3.Remove();
			}
			LightToggle();
			lightsOn = true;
		}
	}

	public bool IsMounted()
	{
		return base.isMounted;
	}
}


public enum RadioChatterType
{
	NONE,
	Idle,
	Alert
}


using Rust;
using UnityEngine;

public class TunnelDweller : HumanNPC
{
	public static readonly Phrase TunnelDwellerName = new Phrase("npc_tunneldweller", "Tunnel Dweller");

	private const string DWELLER_KILL_STAT = "dweller_kills_while_moving";

	public override string displayName => TunnelDwellerName.translated;

	protected override void OnKilledByPlayer(BasePlayer p)
	{
		base.OnKilledByPlayer(p);
		if (GameInfo.HasAchievements && (Object)(object)p.GetParentEntity() != (Object)null && p.GetParentEntity() is TrainEngine { CurThrottleSetting: not TrainEngine.EngineSpeeds.Zero, IsMovingOrOn: not false })
		{
			p.stats.Add("dweller_kills_while_moving", 1, Stats.All);
			p.stats.Save(forceSteamSave: true);
		}
	}
}


public class UnderwaterDweller : HumanNPC
{
	public static readonly Phrase UnderwaterDwellerName = new Phrase("npc_underwaterdweller", "Underwater Dweller");

	public override string displayName => UnderwaterDwellerName.translated;
}


using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using UnityEngine;
using UnityEngine.AI;

public class NPCPlayer : BasePlayer
{
	public float MovementTickStartDelay = 1f;

	public AIInformationZone VirtualInfoZone;

	public Vector3 finalDestination;

	[NonSerialized]
	private float randomOffset;

	[NonSerialized]
	public Vector3 spawnPos;

	public PlayerInventoryProperties[] loadouts;

	public LayerMask movementMask = LayerMask.op_Implicit(1503731969);

	public bool LegacyNavigation = true;

	public NavMeshAgent NavAgent;

	public float damageScale = 1f;

	public float shortRange = 10f;

	public float attackLengthMaxShortRangeScale = 1f;

	private bool _isDormant;

	private string loadoutname;

	public float lastGunShotTime;

	public float triggerEndTime;

	public float nextTriggerTime;

	private float lastThinkTime;

	private float lastPositionUpdateTime;

	private float lastMovementTickTime;

	public Vector3 lastPos;

	private float lastThrowTime;

	public override bool IsNpc => true;

	public virtual bool IsDormant
	{
		get
		{
			return _isDormant;
		}
		set
		{
			_isDormant = value;
			_ = _isDormant;
		}
	}

	public override float PositionTickRate
	{
		protected get
		{
			return 0.1f;
		}
	}

	public virtual bool IsOnNavMeshLink
	{
		get
		{
			if (IsNavRunning())
			{
				return NavAgent.isOnOffMeshLink;
			}
			return false;
		}
	}

	public virtual bool HasPath
	{
		get
		{
			if (IsNavRunning())
			{
				return NavAgent.hasPath;
			}
			return false;
		}
	}

	protected virtual string CorpsePath => "assets/prefabs/npc/scientist/scientist_corpse.prefab";

	protected virtual bool ShouldCorpseTakeChildren => true;

	protected virtual bool KeepCorpseClothingIntact => true;

	protected virtual string OverrideCorpseName => displayName;

	protected virtual bool CopyInventoryToCorpse => true;

	public virtual bool IsLoadBalanced()
	{
		return false;
	}

	public override void ServerInit()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		spawnPos = GetPosition();
		randomOffset = Random.Range(0f, 1f);
		base.ServerInit();
		UpdateNetworkGroup();
		EquipLoadout(loadouts);
		if (!IsLoadBalanced())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ServerThink_Internal, 0f, 0.1f);
			lastThinkTime = Time.time;
		}
		((FacepunchBehaviour)this).Invoke((Action)EquipTest, 0.25f);
		finalDestination = ((Component)this).transform.position;
		if ((Object)(object)NavAgent == (Object)null)
		{
			NavAgent = ((Component)this).GetComponent<NavMeshAgent>();
		}
		if (Object.op_Implicit((Object)(object)NavAgent))
		{
			NavAgent.updateRotation = false;
			NavAgent.updatePosition = false;
			if (!LegacyNavigation)
			{
				((Component)((Component)this).transform).gameObject.GetComponent<BaseNavigator>().Init(this, NavAgent);
			}
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)TickMovement, MovementTickStartDelay, PositionTickRate, PositionTickRate * 0.1f);
	}

	public string GetLoadoutName()
	{
		return loadoutname;
	}

	public void EquipLoadout(PlayerInventoryProperties[] loads)
	{
		if (loads != null && loads.Length != 0)
		{
			int num = Random.Range(0, loads.Length);
			loadoutname = loads[num].niceName;
			loads[num].GiveToPlayer(this);
		}
	}

	public override void ApplyInheritedVelocity(Vector3 velocity)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		ServerPosition = BaseNpc.GetNewNavPosWithVelocity(this, velocity);
	}

	public void RandomMove()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		float num = 8f;
		Vector2 val = Random.insideUnitCircle * num;
		SetDestination(spawnPos + new Vector3(val.x, 0f, val.y));
	}

	public virtual void SetDestination(Vector3 newDestination)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		finalDestination = newDestination;
	}

	public AttackEntity GetAttackEntity()
	{
		return GetHeldEntity() as AttackEntity;
	}

	public BaseProjectile GetGun()
	{
		AttackEntity attackEntity = GetHeldEntity() as AttackEntity;
		if ((Object)(object)attackEntity == (Object)null)
		{
			return null;
		}
		BaseProjectile baseProjectile = attackEntity as BaseProjectile;
		if (Object.op_Implicit((Object)(object)baseProjectile))
		{
			return baseProjectile;
		}
		return null;
	}

	public virtual float AmmoFractionRemaining()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (Object.op_Implicit((Object)(object)attackEntity))
		{
			return attackEntity.AmmoFraction();
		}
		return 0f;
	}

	public virtual bool IsReloading()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (!Object.op_Implicit((Object)(object)attackEntity))
		{
			return false;
		}
		return attackEntity.ServerIsReloading();
	}

	public virtual void AttemptReload()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (!((Object)(object)attackEntity == (Object)null) && attackEntity.CanReload())
		{
			attackEntity.ServerReload();
		}
	}

	public virtual bool ShotTest(float targetDist)
	{
		AttackEntity attackEntity = GetHeldEntity() as AttackEntity;
		if ((Object)(object)attackEntity == (Object)null)
		{
			return false;
		}
		BaseProjectile baseProjectile = attackEntity as BaseProjectile;
		if (Object.op_Implicit((Object)(object)baseProjectile))
		{
			if (baseProjectile.primaryMagazine.contents <= 0)
			{
				baseProjectile.ServerReload();
				return false;
			}
			if (baseProjectile.NextAttackTime > Time.time)
			{
				return false;
			}
		}
		else
		{
			FlameThrower flameThrower = attackEntity as FlameThrower;
			if ((Object)(object)flameThrower != (Object)null && flameThrower.ammo <= 0)
			{
				flameThrower.ServerReload();
				return false;
			}
		}
		if (!Mathf.Approximately(attackEntity.attackLengthMin, -1f))
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)TriggerDown))
			{
				return true;
			}
			if (Time.time < nextTriggerTime)
			{
				return true;
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)TriggerDown, 0f, 0.01f);
			if (targetDist <= shortRange)
			{
				triggerEndTime = Time.time + Random.Range(attackEntity.attackLengthMin, attackEntity.attackLengthMax * attackLengthMaxShortRangeScale);
			}
			else
			{
				triggerEndTime = Time.time + Random.Range(attackEntity.attackLengthMin, attackEntity.attackLengthMax);
			}
			TriggerDown();
			return true;
		}
		attackEntity.ServerUse(damageScale, 1f, null);
		lastGunShotTime = Time.time;
		return true;
	}

	public virtual float GetAimConeScale()
	{
		return 1f;
	}

	public void CancelBurst(float delay = 0.2f)
	{
		if (triggerEndTime > Time.time + delay)
		{
			triggerEndTime = Time.time + delay;
		}
	}

	public bool MeleeAttack()
	{
		AttackEntity attackEntity = GetHeldEntity() as AttackEntity;
		if ((Object)(object)attackEntity == (Object)null)
		{
			return false;
		}
		BaseMelee baseMelee = attackEntity as BaseMelee;
		if ((Object)(object)baseMelee == (Object)null)
		{
			return false;
		}
		baseMelee.ServerUse(damageScale, 1f, null);
		return true;
	}

	public virtual void TriggerDown()
	{
		AttackEntity attackEntity = GetHeldEntity() as AttackEntity;
		if ((Object)(object)attackEntity != (Object)null)
		{
			attackEntity.ServerUse(damageScale, 1f, null);
		}
		lastGunShotTime = Time.time;
		if (Time.time > triggerEndTime)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TriggerDown);
			nextTriggerTime = Time.time + (((Object)(object)attackEntity != (Object)null) ? attackEntity.attackSpacing : 1f);
		}
	}

	public virtual void EquipWeapon(bool skipDeployDelay = false)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)base.inventory == (Object)null || base.inventory.containerBelt == null)
		{
			return;
		}
		Item slot = base.inventory.containerBelt.GetSlot(0);
		if (Interface.CallHook("OnNpcEquipWeapon", (object)this, (object)slot) != null || slot == null)
		{
			return;
		}
		UpdateActiveItem(base.inventory.containerBelt.GetSlot(0).uid);
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!((Object)(object)heldEntity != (Object)null))
		{
			return;
		}
		AttackEntity component = ((Component)heldEntity).GetComponent<AttackEntity>();
		if ((Object)(object)component != (Object)null)
		{
			if (skipDeployDelay)
			{
				component.ResetAttackCooldown();
			}
			component.TopUpAmmo();
		}
	}

	public void EquipTest()
	{
		EquipWeapon(skipDeployDelay: true);
	}

	internal void ServerThink_Internal()
	{
		float delta = Time.time - lastThinkTime;
		ServerThink(delta);
		lastThinkTime = Time.time;
	}

	public virtual void ServerThink(float delta)
	{
		TickAi(delta);
	}

	public virtual void Resume()
	{
	}

	public virtual bool IsNavRunning()
	{
		return false;
	}

	public virtual void TickAi(float delta)
	{
	}

	public void TickMovement()
	{
		float delta = Time.realtimeSinceStartup - lastMovementTickTime;
		lastMovementTickTime = Time.realtimeSinceStartup;
		MovementUpdate(delta);
	}

	public override float GetNetworkTime()
	{
		if (Time.realtimeSinceStartup - lastPositionUpdateTime > PositionTickRate * 2f)
		{
			return Time.time;
		}
		return lastPositionUpdateTime;
	}

	public virtual void MovementUpdate(float delta)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if (!LegacyNavigation || base.isClient || !IsAlive() || IsWounded() || (!base.isMounted && !IsNavRunning()))
		{
			return;
		}
		if (IsDormant || !syncPosition)
		{
			if (IsNavRunning())
			{
				NavAgent.destination = ServerPosition;
			}
			return;
		}
		Vector3 moveToPosition = ((Component)this).transform.position;
		if (HasPath)
		{
			moveToPosition = NavAgent.nextPosition;
		}
		if (ValidateNextPosition(ref moveToPosition))
		{
			UpdateSpeed(delta);
			UpdatePositionAndRotation(moveToPosition);
		}
	}

	private bool ValidateNextPosition(ref Vector3 moveToPosition)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		if (!ValidBounds.Test(this, moveToPosition) && (Object)(object)((Component)this).transform != (Object)null && !base.IsDestroyed)
		{
			Debug.Log((object)("Invalid NavAgent Position: " + ((object)this)?.ToString() + " " + ((object)(Vector3)(ref moveToPosition)/*cast due to .constrained prefix*/).ToString() + " (destroying)"));
			Kill();
			return false;
		}
		return true;
	}

	private void UpdateSpeed(float delta)
	{
		float num = DesiredMoveSpeed();
		NavAgent.speed = Mathf.Lerp(NavAgent.speed, num, delta * 8f);
	}

	protected virtual void UpdatePositionAndRotation(Vector3 moveToPosition)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		lastPositionUpdateTime = Time.time;
		ServerPosition = moveToPosition;
		SetAimDirection(GetAimDirection());
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public virtual float DesiredMoveSpeed()
	{
		float running = Mathf.Sin(Time.time + randomOffset);
		return GetSpeed(running, 0f, 0f);
	}

	public override bool EligibleForWounding(HitInfo info)
	{
		return false;
	}

	public virtual Vector3 GetAimDirection()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.Distance2D(finalDestination, GetPosition()) >= 1f)
		{
			Vector3 val = finalDestination - GetPosition();
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			return new Vector3(normalized.x, 0f, normalized.z);
		}
		return base.eyes.BodyForward();
	}

	public virtual void SetAimDirection(Vector3 newAim)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!(newAim == Vector3.zero))
		{
			AttackEntity attackEntity = GetAttackEntity();
			if (Object.op_Implicit((Object)(object)attackEntity))
			{
				newAim = attackEntity.ModifyAIAim(newAim);
			}
			base.eyes.rotation = Quaternion.LookRotation(newAim, Vector3.up);
			Quaternion rotation = base.eyes.rotation;
			viewAngles = ((Quaternion)(ref rotation)).eulerAngles;
			ServerRotation = base.eyes.rotation;
			lastPositionUpdateTime = Time.time;
		}
	}

	public bool TryUseThrownWeapon(BaseEntity target, float attackRate)
	{
		if (HasThrownItemCooldown())
		{
			return false;
		}
		Item item = FindThrownWeapon();
		if (item == null)
		{
			lastThrowTime = Time.time;
			return false;
		}
		return TryUseThrownWeapon(item, target, attackRate);
	}

	public bool TryUseThrownWeapon(Item item, BaseEntity target, float attackRate)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (HasThrownItemCooldown())
		{
			return false;
		}
		float num = Vector3.Distance(((Component)target).transform.position, ((Component)this).transform.position);
		if (num <= 2f || num >= 20f)
		{
			return false;
		}
		Vector3 position = ((Component)target).transform.position;
		if (!IsVisible(CenterPoint(), position))
		{
			return false;
		}
		if (UseThrownWeapon(item, target))
		{
			if (this is ScarecrowNPC)
			{
				ScarecrowNPC.NextBeanCanAllowedTime = Time.time + Halloween.scarecrow_throw_beancan_global_delay;
			}
			lastThrowTime = Time.time;
			return true;
		}
		return false;
	}

	public bool HasThrownItemCooldown()
	{
		return Time.time - lastThrowTime < 10f;
	}

	protected bool UseThrownWeapon(Item item, BaseEntity target)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		UpdateActiveItem(item.uid);
		ThrownWeapon thrownWeapon = GetActiveItem().GetHeldEntity() as ThrownWeapon;
		if ((Object)(object)thrownWeapon == (Object)null)
		{
			return false;
		}
		((MonoBehaviour)this).StartCoroutine(DoThrow(thrownWeapon, target));
		return true;
	}

	private IEnumerator DoThrow(ThrownWeapon thrownWeapon, BaseEntity target)
	{
		modelState.aiming = true;
		yield return (object)new WaitForSeconds(1.5f);
		SetAimDirection(Vector3Ex.Direction(((Component)target).transform.position, ((Component)this).transform.position));
		thrownWeapon.ResetAttackCooldown();
		thrownWeapon.ServerThrow(((Component)target).transform.position);
		modelState.aiming = false;
		((FacepunchBehaviour)this).Invoke((Action)EquipTest, 0.5f);
	}

	public Item FindThrownWeapon()
	{
		if ((Object)(object)base.inventory == (Object)null || base.inventory.containerBelt == null)
		{
			return null;
		}
		for (int i = 0; i < base.inventory.containerBelt.capacity; i++)
		{
			Item slot = base.inventory.containerBelt.GetSlot(i);
			if (slot != null && (Object)(object)(slot.GetHeldEntity() as ThrownWeapon) != (Object)null)
			{
				return slot;
			}
		}
		return null;
	}

	public override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Create corpse", 0);
		try
		{
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse(CorpsePath, flagsOnDeath, modelState) as NPCPlayerCorpse;
			if (Object.op_Implicit((Object)(object)nPCPlayerCorpse))
			{
				if ((Object)(object)NavAgent != (Object)null)
				{
					Transform transform = ((Component)nPCPlayerCorpse).transform;
					transform.position += Vector3.down * NavAgent.baseOffset;
				}
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				if (CopyInventoryToCorpse)
				{
					nPCPlayerCorpse.TakeFrom(this, base.inventory.containerMain, base.inventory.containerWear, base.inventory.containerBelt);
				}
				else
				{
					nPCPlayerCorpse.CreateEmptyContainer(base.inventory.containerMain.capacity);
				}
				nPCPlayerCorpse.playerName = OverrideCorpseName;
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				if (ShouldCorpseTakeChildren)
				{
					nPCPlayerCorpse.TakeChildren(this);
				}
				for (int i = 0; i < nPCPlayerCorpse.containers.Length; i++)
				{
					ItemContainer itemContainer = nPCPlayerCorpse.containers[i];
					if (!KeepCorpseClothingIntact || i != 1)
					{
						itemContainer.Clear();
					}
				}
				object obj = Interface.CallHook("OnCorpsePopulate", (object)this, (object)nPCPlayerCorpse);
				if (obj is BaseCorpse)
				{
					return (BaseCorpse)obj;
				}
				ApplyLoot(nPCPlayerCorpse);
			}
			return nPCPlayerCorpse;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected virtual void ApplyLoot(NPCPlayerCorpse corpse)
	{
	}
}


using UnityEngine;

public class FrankensteinBrain : PetBrain
{
	public class MoveToPointState : BasicAIState
	{
		private float originalStopDistance;

		public MoveToPointState()
			: base(AIState.MoveToPoint)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			BaseNavigator navigator = brain.Navigator;
			originalStopDistance = navigator.StoppingDistance;
			navigator.StoppingDistance = 0.5f;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.StoppingDistance = originalStopDistance;
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			Vector3 pos = brain.Events.Memory.Position.Get(6);
			if (!brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Normal, MoveTowardsRate))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				brain.LoadDefaultAIDesign();
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	public class MoveTorwardsState : BasicAIState
	{
		public MoveTorwardsState()
			: base(AIState.MoveTowards)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Stop();
				return StateStatus.Error;
			}
			if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Normal, MoveTowardsRate))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	[ServerVar]
	public static float MoveTowardsRate = 1f;

	public override void AddStates()
	{
		base.AddStates();
		AddState(new BaseIdleState());
		AddState(new MoveTorwardsState());
		AddState(new BaseChaseState());
		AddState(new BaseAttackState());
		AddState(new MoveToPointState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new HumanPathFinder();
		((HumanPathFinder)base.PathFinder).Init(GetBaseEntity());
	}

	public FrankensteinPet GetEntity()
	{
		return GetBaseEntity() as FrankensteinPet;
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
	}
}


using UnityEngine;

public class MoveToPointState : BasicAIState
{
	private float originalStopDistance;

	public MoveToPointState()
		: base(AIState.MoveToPoint)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		BaseNavigator navigator = brain.Navigator;
		originalStopDistance = navigator.StoppingDistance;
		navigator.StoppingDistance = 0.5f;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.StoppingDistance = originalStopDistance;
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		Vector3 pos = brain.Events.Memory.Position.Get(6);
		if (!brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Normal, MoveTowardsRate))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			brain.LoadDefaultAIDesign();
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class MoveTorwardsState : BasicAIState
{
	public MoveTorwardsState()
		: base(AIState.MoveTowards)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Stop();
			return StateStatus.Error;
		}
		if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Normal, MoveTowardsRate))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


public class MapMarkerPet : MapMarker
{
	public override void ServerInit()
	{
		base.ServerInit();
		base.limitNetworking = true;
	}

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		return (ulong)player.userID == base.OwnerID;
	}
}


using ConVar;
using UnityEngine;

public class ScarecrowBrain : BaseAIBrain
{
	public class AttackState : BasicAIState
	{
		private IAIAttack attack;

		private float originalStoppingDistance;

		public AttackState()
			: base(AIState.Attack)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
			originalStoppingDistance = brain.Navigator.StoppingDistance;
			brain.Navigator.Agent.stoppingDistance = 1f;
			brain.Navigator.StoppingDistance = 1f;
			base.StateEnter(brain, entity);
			attack = entity as IAIAttack;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
				brain.Navigator.SetFacingDirectionOverride(aimDirection);
				if (attack.CanAttack(baseEntity))
				{
					StartAttacking(baseEntity);
				}
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
			brain.Navigator.Agent.stoppingDistance = originalStoppingDistance;
			brain.Navigator.StoppingDistance = originalStoppingDistance;
			brain.Navigator.ClearFacingDirectionOverride();
			brain.Navigator.Stop();
			StopAttacking();
		}

		private void StopAttacking()
		{
			attack.StopAttacking();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if (attack == null)
			{
				return StateStatus.Error;
			}
			if ((Object)(object)baseEntity == (Object)null)
			{
				brain.Navigator.ClearFacingDirectionOverride();
				StopAttacking();
				return StateStatus.Finished;
			}
			if (brain.Senses.ignoreSafeZonePlayers)
			{
				BasePlayer basePlayer = baseEntity as BasePlayer;
				if ((Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
				{
					return StateStatus.Error;
				}
			}
			Vector3Ex.Direction2D(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
			Vector3 position = ((Component)baseEntity).transform.position;
			if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Fast, 0.2f))
			{
				return StateStatus.Error;
			}
			Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			else
			{
				StopAttacking();
			}
			return StateStatus.Running;
		}

		private static Vector3 GetAimDirection(Vector3 from, Vector3 target)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			return Vector3Ex.Direction2D(target, from);
		}

		private void StartAttacking(BaseEntity entity)
		{
			attack.StartAttacking(entity);
		}
	}

	public class ChaseState : BasicAIState
	{
		private float throwDelayTime;

		private bool useBeanCan;

		public ChaseState()
			: base(AIState.Chase)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
			throwDelayTime = Time.time + Random.Range(0.2f, 0.5f);
			useBeanCan = (float)Random.Range(0, 100) <= 20f;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Stop();
				return StateStatus.Error;
			}
			if (useBeanCan && Time.time >= throwDelayTime && AI.npc_use_thrown_weapons && Halloween.scarecrows_throw_beancans && Time.time >= ScarecrowNPC.NextBeanCanAllowedTime && (brain.GetBrainBaseEntity() as ScarecrowNPC).TryUseThrownWeapon(baseEntity, 10f))
			{
				brain.Navigator.Stop();
				return StateStatus.Running;
			}
			if (!(brain.GetBrainBaseEntity() as BasePlayer).modelState.aiming)
			{
				if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f))
				{
					return StateStatus.Error;
				}
				if (!brain.Navigator.Moving)
				{
					return StateStatus.Finished;
				}
				return StateStatus.Running;
			}
			return StateStatus.Running;
		}
	}

	public class RoamState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		public RoamState()
			: base(AIState.Roam)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder == null)
			{
				return;
			}
			ScarecrowNPC scarecrowNPC = entity as ScarecrowNPC;
			if (!((Object)(object)scarecrowNPC == (Object)null))
			{
				Vector3 val = brain.Events.Memory.Position.Get(4);
				Vector3 val2 = val;
				val2 = ((!scarecrowNPC.RoamAroundHomePoint) ? brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, brain.Events.Memory.Position.Get(4), 10f, brain.Navigator.BestRoamPointMaxDistance) : brain.PathFinder.GetBestRoamPositionFromAnchor(brain.Navigator, val, val, 1f, brain.Navigator.BestRoamPointMaxDistance));
				if (brain.Navigator.SetDestination(val2, BaseNavigator.NavigationSpeed.Slow))
				{
					status = StateStatus.Running;
				}
				else
				{
					status = StateStatus.Error;
				}
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public override void AddStates()
	{
		base.AddStates();
		AddState(new BaseIdleState());
		AddState(new ChaseState());
		AddState(new AttackState());
		AddState(new RoamState());
		AddState(new BaseFleeState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new HumanPathFinder();
		((HumanPathFinder)base.PathFinder).Init(GetBaseEntity());
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
	}
}


using UnityEngine;

public class AttackState : BasicAIState
{
	private IAIAttack attack;

	private float originalStoppingDistance;

	public AttackState()
		: base(AIState.Attack)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		originalStoppingDistance = brain.Navigator.StoppingDistance;
		brain.Navigator.Agent.stoppingDistance = 1f;
		brain.Navigator.StoppingDistance = 1f;
		base.StateEnter(brain, entity);
		attack = entity as IAIAttack;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		brain.Navigator.Agent.stoppingDistance = originalStoppingDistance;
		brain.Navigator.StoppingDistance = originalStoppingDistance;
		brain.Navigator.ClearFacingDirectionOverride();
		brain.Navigator.Stop();
		StopAttacking();
	}

	private void StopAttacking()
	{
		attack.StopAttacking();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if (attack == null)
		{
			return StateStatus.Error;
		}
		if ((Object)(object)baseEntity == (Object)null)
		{
			brain.Navigator.ClearFacingDirectionOverride();
			StopAttacking();
			return StateStatus.Finished;
		}
		if (brain.Senses.ignoreSafeZonePlayers)
		{
			BasePlayer basePlayer = baseEntity as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
			{
				return StateStatus.Error;
			}
		}
		Vector3Ex.Direction2D(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
		Vector3 position = ((Component)baseEntity).transform.position;
		if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Fast, 0.2f))
		{
			return StateStatus.Error;
		}
		Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
		brain.Navigator.SetFacingDirectionOverride(aimDirection);
		if (attack.CanAttack(baseEntity))
		{
			StartAttacking(baseEntity);
		}
		else
		{
			StopAttacking();
		}
		return StateStatus.Running;
	}

	private static Vector3 GetAimDirection(Vector3 from, Vector3 target)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Direction2D(target, from);
	}

	private void StartAttacking(BaseEntity entity)
	{
		attack.StartAttacking(entity);
	}
}


using ConVar;
using UnityEngine;

public class ChaseState : BasicAIState
{
	private float throwDelayTime;

	private bool useBeanCan;

	public ChaseState()
		: base(AIState.Chase)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		throwDelayTime = Time.time + Random.Range(0.2f, 0.5f);
		useBeanCan = (float)Random.Range(0, 100) <= 20f;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Stop();
			return StateStatus.Error;
		}
		if (useBeanCan && Time.time >= throwDelayTime && AI.npc_use_thrown_weapons && Halloween.scarecrows_throw_beancans && Time.time >= ScarecrowNPC.NextBeanCanAllowedTime && (brain.GetBrainBaseEntity() as ScarecrowNPC).TryUseThrownWeapon(baseEntity, 10f))
		{
			brain.Navigator.Stop();
			return StateStatus.Running;
		}
		if (!(brain.GetBrainBaseEntity() as BasePlayer).modelState.aiming)
		{
			if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class RoamState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	public RoamState()
		: base(AIState.Roam)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder == null)
		{
			return;
		}
		ScarecrowNPC scarecrowNPC = entity as ScarecrowNPC;
		if (!((Object)(object)scarecrowNPC == (Object)null))
		{
			Vector3 val = brain.Events.Memory.Position.Get(4);
			Vector3 val2 = val;
			val2 = ((!scarecrowNPC.RoamAroundHomePoint) ? brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, brain.Events.Memory.Position.Get(4), 10f, brain.Navigator.BestRoamPointMaxDistance) : brain.PathFinder.GetBestRoamPositionFromAnchor(brain.Navigator, val, val, 1f, brain.Navigator.BestRoamPointMaxDistance));
			if (brain.Navigator.SetDestination(val2, BaseNavigator.NavigationSpeed.Slow))
			{
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


using ConVar;
using ProtoBuf;
using Rust;
using UnityEngine;

public class ScarecrowNPC : NPCPlayer, IAISenses, IAIAttack, IThinker
{
	public float BaseAttackRate = 2f;

	[Header("Loot")]
	public LootContainer.LootSpawnSlot[] LootSpawnSlots;

	public LootContainer.LootSpawnSlot[] bonusLootSlots;

	public static float NextBeanCanAllowedTime;

	public bool BlockClothingOnCorpse;

	public bool RoamAroundHomePoint;

	public GameObjectRef soulReleaseEffect;

	public bool wasSoulReleased;

	public ScarecrowBrain Brain { get; set; }

	public override BaseNpc.AiStatistics.FamilyEnum Family => BaseNpc.AiStatistics.FamilyEnum.Murderer;

	protected override string CorpsePath => "assets/prefabs/npc/murderer/murderer_corpse.prefab";

	protected override bool ShouldCorpseTakeChildren => false;

	protected override string OverrideCorpseName => "Scarecrow";

	public override float StartHealth()
	{
		return startHealth;
	}

	public override float StartMaxHealth()
	{
		return startHealth;
	}

	public override float MaxHealth()
	{
		return startHealth;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Brain = ((Component)this).GetComponent<ScarecrowBrain>();
		if (!base.isClient)
		{
			AIThinkManager.Add(this);
			wasSoulReleased = false;
		}
	}

	internal override void DoServerDestroy()
	{
		AIThinkManager.Remove(this);
		base.DoServerDestroy();
	}

	public virtual void TryThink()
	{
		ServerThink_Internal();
	}

	public override void ServerThink(float delta)
	{
		base.ServerThink(delta);
		if (Brain.ShouldServerThink())
		{
			Brain.DoThink();
		}
	}

	public override string Categorize()
	{
		return "Scarecrow";
	}

	public override void EquipWeapon(bool skipDeployDelay = false)
	{
		base.EquipWeapon(skipDeployDelay);
		HeldEntity heldEntity = GetHeldEntity();
		if ((Object)(object)heldEntity != (Object)null && heldEntity is Chainsaw chainsaw)
		{
			chainsaw.ServerNPCStart();
		}
	}

	public float EngagementRange()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (Object.op_Implicit((Object)(object)attackEntity))
		{
			return attackEntity.effectiveRange * (attackEntity.aiOnlyInRange ? 1f : 2f) * Brain.AttackRangeMultiplier;
		}
		return Brain.SenseRange;
	}

	public bool IsThreat(BaseEntity entity)
	{
		return IsTarget(entity);
	}

	public bool IsTarget(BaseEntity entity)
	{
		if (entity is BasePlayer)
		{
			return !entity.IsNpc;
		}
		return false;
	}

	public bool IsFriendly(BaseEntity entity)
	{
		return false;
	}

	public bool CanAttack(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (NeedsToReload())
		{
			return false;
		}
		if (IsOnCooldown())
		{
			return false;
		}
		if (!IsTargetInRange(entity, out var _))
		{
			return false;
		}
		if (InSafeZone() || (entity is BasePlayer basePlayer && basePlayer.InSafeZone()))
		{
			return false;
		}
		if (!CanSeeTarget(entity))
		{
			return false;
		}
		return true;
	}

	public bool IsTargetInRange(BaseEntity entity, out float dist)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		dist = Vector3.Distance(((Component)entity).transform.position, ((Component)this).transform.position);
		return dist <= EngagementRange();
	}

	public bool CanSeeTarget(BaseEntity entity)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.IsVisible(GetEntity().CenterPoint(), entity.CenterPoint());
	}

	public bool NeedsToReload()
	{
		return false;
	}

	public bool Reload()
	{
		return true;
	}

	public float CooldownDuration()
	{
		return BaseAttackRate;
	}

	public bool IsOnCooldown()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (Object.op_Implicit((Object)(object)attackEntity))
		{
			return attackEntity.HasAttackCooldown();
		}
		return true;
	}

	public bool StartAttacking(BaseEntity target)
	{
		BaseCombatEntity baseCombatEntity = target as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity == (Object)null)
		{
			return false;
		}
		Attack(baseCombatEntity);
		return true;
	}

	private void Attack(BaseCombatEntity target)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)target == (Object)null))
		{
			Vector3 val = target.ServerPosition - ServerPosition;
			if (((Vector3)(ref val)).magnitude > 0.001f)
			{
				ServerRotation = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
			}
			AttackEntity attackEntity = GetAttackEntity();
			if (Object.op_Implicit((Object)(object)attackEntity))
			{
				attackEntity.ServerUse(1f, 1f, null);
			}
		}
	}

	public void StopAttacking()
	{
	}

	public float GetAmmoFraction()
	{
		return AmmoFractionRemaining();
	}

	public BaseEntity GetBestTarget()
	{
		return null;
	}

	public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
	{
	}

	public override bool ShouldDropActiveItem()
	{
		return false;
	}

	protected override void ApplyLoot(NPCPlayerCorpse corpse)
	{
		base.ApplyLoot(corpse);
		LootContainer.LootSpawnSlot[] lootSpawnSlots;
		if (LootSpawnSlots.Length != 0)
		{
			lootSpawnSlots = LootSpawnSlots;
			for (int i = 0; i < lootSpawnSlots.Length; i++)
			{
				LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
				for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
				{
					if (Random.Range(0f, 1f) <= lootSpawnSlot.probability)
					{
						lootSpawnSlot.definition.SpawnIntoContainer(corpse.containers[0]);
					}
				}
			}
		}
		if (!wasSoulReleased)
		{
			return;
		}
		lootSpawnSlots = bonusLootSlots;
		for (int i = 0; i < lootSpawnSlots.Length; i++)
		{
			LootContainer.LootSpawnSlot lootSpawnSlot2 = lootSpawnSlots[i];
			for (int k = 0; k < lootSpawnSlot2.numberToSpawn; k++)
			{
				if (Random.Range(0f, 1f) <= lootSpawnSlot2.probability)
				{
					lootSpawnSlot2.definition.SpawnIntoContainer(corpse.containers[0]);
				}
			}
		}
	}

	public override void Hurt(HitInfo info)
	{
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		bool flag = info.damageTypes.Has(DamageType.Slash) && info.damageTypes.Has(DamageType.Stab) && info.damageTypes.Has(DamageType.Generic) && info.damageTypes.Get(DamageType.Generic) <= 0.1f;
		if (flag)
		{
			if ((Object)(object)info.ProjectilePrefab != (Object)null && !((Object)info.ProjectilePrefab).name.Contains("vamp"))
			{
				flag = false;
			}
			if ((Object)(object)info.WeaponPrefab != (Object)null && !((Object)info.WeaponPrefab).name.Contains("vamp"))
			{
				flag = false;
			}
		}
		if (flag)
		{
			wasSoulReleased = true;
			info.damageTypes.ScaleAll(1000f);
			Effect.server.Run(soulReleaseEffect.resourcePath, this, StringPool.Get("spine3"), Vector3.zero, Vector3.forward);
		}
		else if (!info.isHeadshot)
		{
			if (((Object)(object)info.InitiatorPlayer != (Object)null && !info.InitiatorPlayer.IsNpc) || ((Object)(object)info.InitiatorPlayer == (Object)null && (Object)(object)info.Initiator != (Object)null && info.Initiator.IsNpc))
			{
				info.damageTypes.ScaleAll(Halloween.scarecrow_body_dmg_modifier);
			}
			else
			{
				info.damageTypes.ScaleAll(2f);
			}
		}
		base.Hurt(info);
	}

	public override void AttackerInfo(DeathInfo info)
	{
		base.AttackerInfo(info);
		info.inflictorName = base.inventory.containerBelt.GetSlot(0).info.shortname;
		info.attackerName = base.ShortPrefabName;
	}
}


using UnityEngine;

public class Stag : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 3f;

	public override float RealisticMass => 200f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Meat))
		{
			return false;
		}
		CollectibleEntity collectibleEntity = best as CollectibleEntity;
		if ((Object)(object)collectibleEntity != (Object)null)
		{
			ItemAmount[] itemList = collectibleEntity.itemList;
			for (int i = 0; i < itemList.Length; i++)
			{
				if (itemList[i].itemDef.category == ItemCategory.Food)
				{
					return true;
				}
			}
		}
		return base.WantsToEat(best);
	}

	public override string Categorize()
	{
		return "Stag";
	}
}


using UnityEngine;

public class ClawMark : BaseEntity
{
	public Material[] materials;

	public DeferredDecal decalComponent;
}


using System;
using UnityEngine;

public class NightEyeComponent : FacepunchBehaviour, IClientComponent
{
	[SerializeField]
	private Renderer[] nightEyes;

	private bool wasDayLastCheck;

	private void OnEnable()
	{
		wasDayLastCheck = TOD_Sky.Instance.IsDay;
		Renderer[] array = nightEyes;
		for (int i = 0; i < array.Length; i++)
		{
			((Component)array[i]).gameObject.SetActive(TOD_Sky.Instance.IsNight);
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)Tick, 5f, 5f, 2.5f);
	}

	private void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Tick);
	}

	private void Tick()
	{
		TimeWarning val = TimeWarning.New("NightEyeComponent:Tick", 0);
		try
		{
			if (wasDayLastCheck && TOD_Sky.Instance.IsNight)
			{
				Renderer[] array = nightEyes;
				for (int i = 0; i < array.Length; i++)
				{
					((Component)array[i]).gameObject.SetActive(true);
				}
			}
			else if (!wasDayLastCheck && TOD_Sky.Instance.IsDay)
			{
				Renderer[] array = nightEyes;
				for (int i = 0; i < array.Length; i++)
				{
					((Component)array[i]).gameObject.SetActive(false);
				}
			}
			wasDayLastCheck = TOD_Sky.Instance.IsDay;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public class Wolf : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 2f;

	public override float RealisticMass => 45f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Meat))
		{
			return true;
		}
		return base.WantsToEat(best);
	}

	public override string Categorize()
	{
		return "Wolf";
	}
}


public class Zombie : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return base.WantsToEat(best);
	}

	protected override void TickSleep()
	{
		Sleep = 100f;
	}

	public override string Categorize()
	{
		return "Zombie";
	}
}


using UnityEngine;

public class AIArena : MonoBehaviour
{
}


using UnityEngine;

public class AIArenaNameTag : MonoBehaviour
{
	public BasePlayer Entity;

	public bool ShowHealth = true;

	public bool ShowName = true;

	private string trimmedName;
}


using UnityEngine;

public class AICoverPoint : AIPoint
{
	public float coverDot = 0.5f;

	public void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + Vector3.up * 1f;
		Gizmos.color = Color.white;
		Gizmos.DrawLine(val, val + ((Component)this).transform.forward * 0.5f);
		Gizmos.color = Color.yellow;
		Gizmos.DrawCube(((Component)this).transform.position + Vector3.up * 0.125f, new Vector3(0.5f, 0.25f, 0.5f));
		Gizmos.DrawLine(((Component)this).transform.position, val);
		Vector3 val2 = ((Component)this).transform.forward + ((Component)this).transform.right * coverDot * 1f;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		val2 = ((Component)this).transform.forward + -((Component)this).transform.right * coverDot * 1f;
		Vector3 normalized2 = ((Vector3)(ref val2)).normalized;
		Gizmos.DrawLine(val, val + normalized * 1f);
		Gizmos.DrawLine(val, val + normalized2 * 1f);
	}
}


using UnityEngine;

public class AICoverPointTool : MonoBehaviour
{
	private struct TestResult
	{
		public Vector3 Position;

		public bool Valid;

		public bool Forward;

		public bool Right;

		public bool Backward;

		public bool Left;
	}

	[ContextMenu("Place Cover Points")]
	public void PlaceCoverPoints()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		foreach (Transform item in ((Component)this).transform)
		{
			Object.DestroyImmediate((Object)(object)((Component)item).gameObject);
		}
		Vector3 pos = default(Vector3);
		((Vector3)(ref pos))..ctor(((Component)this).transform.position.x - 50f, ((Component)this).transform.position.y, ((Component)this).transform.position.z - 50f);
		for (int i = 0; i < 50; i++)
		{
			for (int j = 0; j < 50; j++)
			{
				TestResult result = TestPoint(pos);
				if (result.Valid)
				{
					PlacePoint(result);
				}
				pos.x += 2f;
			}
			pos.x -= 100f;
			pos.z += 2f;
		}
	}

	private TestResult TestPoint(Vector3 pos)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		pos.y += 0.5f;
		TestResult result = default(TestResult);
		result.Position = pos;
		if (HitsCover(new Ray(pos, Vector3.forward), 1218519041, 1f))
		{
			result.Forward = true;
			result.Valid = true;
		}
		if (HitsCover(new Ray(pos, Vector3.right), 1218519041, 1f))
		{
			result.Right = true;
			result.Valid = true;
		}
		if (HitsCover(new Ray(pos, Vector3.back), 1218519041, 1f))
		{
			result.Backward = true;
			result.Valid = true;
		}
		if (HitsCover(new Ray(pos, Vector3.left), 1218519041, 1f))
		{
			result.Left = true;
			result.Valid = true;
		}
		return result;
	}

	private void PlacePoint(TestResult result)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (result.Forward)
		{
			PlacePoint(result.Position, Vector3.forward);
		}
		if (result.Right)
		{
			PlacePoint(result.Position, Vector3.right);
		}
		if (result.Backward)
		{
			PlacePoint(result.Position, Vector3.back);
		}
		if (result.Left)
		{
			PlacePoint(result.Position, Vector3.left);
		}
	}

	private void PlacePoint(Vector3 pos, Vector3 dir)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		AICoverPoint aICoverPoint = new GameObject("CP").AddComponent<AICoverPoint>();
		((Component)aICoverPoint).transform.position = pos;
		((Component)aICoverPoint).transform.forward = dir;
		((Component)aICoverPoint).transform.SetParent(((Component)this).transform);
	}

	public bool HitsCover(Ray ray, int layerMask, float maxDistance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).origin))
		{
			return false;
		}
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).direction))
		{
			return false;
		}
		if (((Ray)(ref ray)).direction == Vector3.zero)
		{
			return false;
		}
		if (GamePhysics.Trace(ray, 0f, out var _, maxDistance, layerMask, (QueryTriggerInteraction)0))
		{
			return true;
		}
		return false;
	}
}


using UnityEngine;

private struct TestResult
{
	public Vector3 Position;

	public bool Valid;

	public bool Forward;

	public bool Right;

	public bool Backward;

	public bool Left;
}


using System.Collections.Generic;
using UnityEngine;

public class AIInformationCell
{
	public Bounds BoundingBox;

	public List<AIInformationCell> NeighbourCells = new List<AIInformationCell>();

	public AIInformationCellContents<AIMovePoint> MovePoints = new AIInformationCellContents<AIMovePoint>();

	public AIInformationCellContents<AICoverPoint> CoverPoints = new AIInformationCellContents<AICoverPoint>();

	public int X { get; }

	public int Z { get; }

	public AIInformationCell(Bounds bounds, GameObject root, int x, int z)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		BoundingBox = bounds;
		X = x;
		Z = z;
		MovePoints.Init(bounds, root);
		CoverPoints.Init(bounds, root);
	}

	public void DebugDraw(Color color, bool points, float scale = 1f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		Gizmos.DrawWireCube(((Bounds)(ref BoundingBox)).center, ((Bounds)(ref BoundingBox)).size * scale);
		Gizmos.color = color2;
		if (!points)
		{
			return;
		}
		foreach (AIMovePoint item in MovePoints.Items)
		{
			Gizmos.DrawLine(((Bounds)(ref BoundingBox)).center, ((Component)item).transform.position);
		}
		foreach (AICoverPoint item2 in CoverPoints.Items)
		{
			Gizmos.DrawLine(((Bounds)(ref BoundingBox)).center, ((Component)item2).transform.position);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class AIInformationCellContents<T> where T : AIPoint
{
	public HashSet<T> Items = new HashSet<T>();

	public int Count => Items.Count;

	public bool Empty => Items.Count == 0;

	public void Init(Bounds cellBounds, GameObject root)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Clear();
		T[] componentsInChildren = root.GetComponentsInChildren<T>(true);
		foreach (T val in componentsInChildren)
		{
			if (((Bounds)(ref cellBounds)).Contains(((Component)val).gameObject.transform.position))
			{
				Add(val);
			}
		}
	}

	public void Clear()
	{
		Items.Clear();
	}

	public void Add(T item)
	{
		Items.Add(item);
	}

	public void Remove(T item)
	{
		Items.Remove(item);
	}
}


using UnityEngine;

public class AIInformationGrid : MonoBehaviour
{
	public int CellSize = 10;

	public Bounds BoundingBox;

	public AIInformationCell[] Cells;

	private Vector3 origin;

	private int xCellCount;

	private int zCellCount;

	private const int maxPointResults = 2048;

	private AIMovePoint[] movePointResults = new AIMovePoint[2048];

	private AICoverPoint[] coverPointResults = new AICoverPoint[2048];

	private const int maxCellResults = 512;

	private AIInformationCell[] resultCells = new AIInformationCell[512];

	[ContextMenu("Init")]
	public void Init()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		AIInformationZone component = ((Component)this).GetComponent<AIInformationZone>();
		if ((Object)(object)component == (Object)null)
		{
			Debug.LogWarning((object)"Unable to Init AIInformationGrid, no AIInformationZone found!");
			return;
		}
		BoundingBox = component.bounds;
		((Bounds)(ref BoundingBox)).center = ((Component)this).transform.position + ((Bounds)(ref component.bounds)).center + new Vector3(0f, ((Bounds)(ref BoundingBox)).extents.y, 0f);
		float num = ((Bounds)(ref BoundingBox)).extents.x * 2f;
		float num2 = ((Bounds)(ref BoundingBox)).extents.z * 2f;
		xCellCount = (int)Mathf.Ceil(num / (float)CellSize);
		zCellCount = (int)Mathf.Ceil(num2 / (float)CellSize);
		Cells = new AIInformationCell[xCellCount * zCellCount];
		Vector3 val = (origin = ((Bounds)(ref BoundingBox)).min);
		val.x = ((Bounds)(ref BoundingBox)).min.x + (float)CellSize / 2f;
		val.z = ((Bounds)(ref BoundingBox)).min.z + (float)CellSize / 2f;
		Bounds bounds = default(Bounds);
		for (int i = 0; i < zCellCount; i++)
		{
			for (int j = 0; j < xCellCount; j++)
			{
				Vector3 val2 = val;
				((Bounds)(ref bounds))..ctor(val2, new Vector3((float)CellSize, ((Bounds)(ref BoundingBox)).extents.y * 2f, (float)CellSize));
				Cells[GetIndex(j, i)] = new AIInformationCell(bounds, ((Component)this).gameObject, j, i);
				val.x += CellSize;
			}
			val.x = ((Bounds)(ref BoundingBox)).min.x + (float)CellSize / 2f;
			val.z += CellSize;
		}
	}

	private int GetIndex(int x, int z)
	{
		return z * xCellCount + x;
	}

	public AIInformationCell CellAt(int x, int z)
	{
		return Cells[GetIndex(x, z)];
	}

	public AIMovePoint[] GetMovePointsInRange(Vector3 position, float maxRange, out int pointCount)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		pointCount = 0;
		int cellCount;
		AIInformationCell[] cellsInRange = GetCellsInRange(position, maxRange, out cellCount);
		if (cellCount > 0)
		{
			for (int i = 0; i < cellCount; i++)
			{
				if (cellsInRange[i] == null)
				{
					continue;
				}
				foreach (AIMovePoint item in cellsInRange[i].MovePoints.Items)
				{
					movePointResults[pointCount] = item;
					pointCount++;
				}
			}
		}
		return movePointResults;
	}

	public AICoverPoint[] GetCoverPointsInRange(Vector3 position, float maxRange, out int pointCount)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		pointCount = 0;
		int cellCount;
		AIInformationCell[] cellsInRange = GetCellsInRange(position, maxRange, out cellCount);
		if (cellCount > 0)
		{
			for (int i = 0; i < cellCount; i++)
			{
				if (cellsInRange[i] == null)
				{
					continue;
				}
				foreach (AICoverPoint item in cellsInRange[i].CoverPoints.Items)
				{
					coverPointResults[pointCount] = item;
					pointCount++;
				}
			}
		}
		return coverPointResults;
	}

	public AIInformationCell[] GetCellsInRange(Vector3 position, float maxRange, out int cellCount)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		cellCount = 0;
		int num = (int)(maxRange / (float)CellSize);
		AIInformationCell cell = GetCell(position);
		if (cell == null)
		{
			return resultCells;
		}
		int num2 = Mathf.Max(cell.X - num, 0);
		int num3 = Mathf.Min(cell.X + num, xCellCount - 1);
		int num4 = Mathf.Max(cell.Z - num, 0);
		int num5 = Mathf.Min(cell.Z + num, zCellCount - 1);
		for (int i = num4; i <= num5; i++)
		{
			for (int j = num2; j <= num3; j++)
			{
				resultCells[cellCount] = CellAt(j, i);
				cellCount++;
				if (cellCount >= 512)
				{
					return resultCells;
				}
			}
		}
		return resultCells;
	}

	public AIInformationCell GetCell(Vector3 position)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (Cells == null)
		{
			return null;
		}
		Vector3 val = position - origin;
		if (val.x < 0f || val.z < 0f)
		{
			return null;
		}
		int num = (int)(val.x / (float)CellSize);
		int num2 = (int)(val.z / (float)CellSize);
		if (num < 0 || num >= xCellCount)
		{
			return null;
		}
		if (num2 < 0 || num2 >= zCellCount)
		{
			return null;
		}
		return CellAt(num, num2);
	}

	public void OnDrawGizmos()
	{
		DebugDraw();
	}

	public void DebugDraw()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (Cells != null)
		{
			AIInformationCell[] cells = Cells;
			for (int i = 0; i < cells.Length; i++)
			{
				cells[i]?.DebugDraw(Color.white, points: false);
			}
		}
	}
}


using UnityEngine;

public class AIInformationGridTester : MonoBehaviour
{
	public AIInformationGrid Grid;

	public float Range = 10f;
}


using System;
using System.Collections.Generic;
using ConVar;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class AIInformationZone : BaseMonoBehaviour, IServerComponent
{
	public bool RenderBounds;

	public bool ShouldSleepAI;

	public bool Virtual;

	public bool UseCalculatedCoverDistances = true;

	public static List<AIInformationZone> zones = new List<AIInformationZone>();

	public List<AICoverPoint> coverPoints = new List<AICoverPoint>();

	public List<AIMovePoint> movePoints = new List<AIMovePoint>();

	private AICoverPoint[] coverPointArray;

	private AIMovePoint[] movePointArray;

	public List<NavMeshLink> navMeshLinks = new List<NavMeshLink>();

	public List<AIMovePointPath> paths = new List<AIMovePointPath>();

	public Bounds bounds;

	public bool SetMovePointTerrainYOnEnable;

	private AIInformationGrid grid;

	[ServerVar]
	public static bool UseSimpleLOSCheck = false;

	private List<IAISleepable> sleepables = new List<IAISleepable>();

	private OBB areaBox;

	private bool isDirty = true;

	private int processIndex;

	private int halfPaths;

	private int pathSuccesses;

	private int pathFails;

	private bool initd;

	private static bool lastFrameAnyDirty = false;

	private static float rebuildStartTime = 0f;

	public static float buildTimeTest = 0f;

	private static float lastNavmeshBuildTime = 0f;

	public bool Sleeping { get; private set; }

	public int SleepingCount
	{
		get
		{
			if (!Sleeping)
			{
				return 0;
			}
			return sleepables.Count;
		}
	}

	public static AIInformationZone Merge(List<AIInformationZone> zones, GameObject newRoot)
	{
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		if (zones == null)
		{
			return null;
		}
		AIInformationZone aIInformationZone = newRoot.AddComponent<AIInformationZone>();
		aIInformationZone.UseCalculatedCoverDistances = false;
		foreach (AIInformationZone zone in zones)
		{
			if ((Object)(object)zone == (Object)null)
			{
				continue;
			}
			foreach (AIMovePoint movePoint in zone.movePoints)
			{
				aIInformationZone.AddMovePoint(movePoint);
				((Component)movePoint).transform.SetParent(newRoot.transform);
			}
			foreach (AICoverPoint coverPoint in zone.coverPoints)
			{
				aIInformationZone.AddCoverPoint(coverPoint);
				((Component)coverPoint).transform.SetParent(newRoot.transform);
			}
		}
		aIInformationZone.bounds = EncapsulateBounds(zones);
		ref Bounds reference = ref aIInformationZone.bounds;
		((Bounds)(ref reference)).extents = ((Bounds)(ref reference)).extents + new Vector3(5f, 0f, 5f);
		ref Bounds reference2 = ref aIInformationZone.bounds;
		((Bounds)(ref reference2)).center = ((Bounds)(ref reference2)).center - ((Component)aIInformationZone).transform.position;
		for (int num = zones.Count - 1; num >= 0; num--)
		{
			AIInformationZone aIInformationZone2 = zones[num];
			if (!((Object)(object)aIInformationZone2 == (Object)null))
			{
				Object.Destroy((Object)(object)aIInformationZone2);
			}
		}
		return aIInformationZone;
	}

	public static Bounds EncapsulateBounds(List<AIInformationZone> zones)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		Bounds result = default(Bounds);
		((Bounds)(ref result)).center = ((Component)zones[0]).transform.position;
		foreach (AIInformationZone zone in zones)
		{
			if (!((Object)(object)zone == (Object)null))
			{
				Vector3 center = ((Bounds)(ref zone.bounds)).center + ((Component)zone).transform.position;
				Bounds val = zone.bounds;
				((Bounds)(ref val)).center = center;
				((Bounds)(ref result)).Encapsulate(val);
			}
		}
		return result;
	}

	public void Start()
	{
		Init();
	}

	private void OnEnable()
	{
		Init();
		if (SetMovePointTerrainYOnEnable)
		{
			SetMovePointsY(8454144, 4f, 8f, 0f);
		}
	}

	private void OnDisable()
	{
		if (zones != null)
		{
			zones.Remove(this);
		}
	}

	public void Init()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		areaBox = new OBB(((Component)this).transform.position, ((Component)this).transform.lossyScale, ((Component)this).transform.rotation, bounds);
		if (!zones.Contains(this))
		{
			zones.Add(this);
		}
		if (!initd)
		{
			initd = true;
			AddInitialPoints();
			grid = ((Component)this).GetComponent<AIInformationGrid>();
			if ((Object)(object)grid != (Object)null)
			{
				grid.Init();
			}
		}
	}

	private void SetMovePointsY(int layerMask, float yStartOffset, float yDistance, float localYDefault)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		foreach (AIMovePoint movePoint in movePoints)
		{
			if (!((Object)(object)movePoint == (Object)null))
			{
				if (Physics.Raycast(((Component)movePoint).transform.position + Vector3.up * yStartOffset, Vector3.down, ref val, yDistance, layerMask))
				{
					((Component)movePoint).transform.position = ((RaycastHit)(ref val)).point + Vector3.up * 0.1f;
				}
				else
				{
					((Component)movePoint).transform.localPosition = new Vector3(((Component)movePoint).transform.localPosition.x, localYDefault, ((Component)movePoint).transform.localPosition.z);
				}
			}
		}
	}

	public void RegisterSleepableEntity(IAISleepable sleepable)
	{
		if (sleepable != null && sleepable.AllowedToSleep() && !sleepables.Contains(sleepable))
		{
			sleepables.Add(sleepable);
			if (Sleeping && sleepable.AllowedToSleep())
			{
				sleepable.SleepAI();
			}
		}
	}

	public void UnregisterSleepableEntity(IAISleepable sleepable)
	{
		if (sleepable != null)
		{
			sleepables.Remove(sleepable);
		}
	}

	public void SleepAI()
	{
		if (!AI.sleepwake || !ShouldSleepAI)
		{
			return;
		}
		foreach (IAISleepable sleepable in sleepables)
		{
			sleepable?.SleepAI();
		}
		Sleeping = true;
	}

	public void WakeAI()
	{
		foreach (IAISleepable sleepable in sleepables)
		{
			sleepable?.WakeAI();
		}
		Sleeping = false;
	}

	private void AddCoverPoint(AICoverPoint point)
	{
		if (!coverPoints.Contains(point))
		{
			coverPoints.Add(point);
			MarkDirty();
		}
	}

	private void RemoveCoverPoint(AICoverPoint point, bool markDirty = true)
	{
		coverPoints.Remove(point);
		if (markDirty)
		{
			MarkDirty();
		}
	}

	private void AddMovePoint(AIMovePoint point)
	{
		if (!movePoints.Contains(point))
		{
			movePoints.Add(point);
			MarkDirty();
		}
	}

	private void RemoveMovePoint(AIMovePoint point, bool markDirty = true)
	{
		movePoints.Remove(point);
		if (markDirty)
		{
			MarkDirty();
		}
	}

	public void MarkDirty(bool completeRefresh = false)
	{
		isDirty = true;
		processIndex = 0;
		halfPaths = 0;
		pathSuccesses = 0;
		pathFails = 0;
		if (!completeRefresh)
		{
			return;
		}
		foreach (AIMovePoint movePoint in movePoints)
		{
			movePoint.distances.Clear();
			movePoint.distancesToCover.Clear();
		}
	}

	private bool PassesBudget(float startTime, float budgetSeconds)
	{
		if (Time.realtimeSinceStartup - startTime > budgetSeconds)
		{
			return false;
		}
		return true;
	}

	public bool ProcessDistancesAttempt()
	{
		return true;
	}

	private bool ProcessDistances()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Expected O, but got Unknown
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Invalid comparison between Unknown and I4
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		if (!UseCalculatedCoverDistances)
		{
			return true;
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		float budgetSeconds = AIThinkManager.framebudgetms / 1000f * 0.25f;
		if (realtimeSinceStartup < lastNavmeshBuildTime + 60f)
		{
			budgetSeconds = 0.1f;
		}
		int num = 1 << NavMesh.GetAreaFromName("HumanNPC");
		NavMeshPath val = new NavMeshPath();
		while (PassesBudget(realtimeSinceStartup, budgetSeconds))
		{
			AIMovePoint aIMovePoint = movePoints[processIndex];
			bool flag = true;
			int num2 = 0;
			for (int num3 = aIMovePoint.distances.Keys.Count - 1; num3 >= 0; num3--)
			{
				AIMovePoint aIMovePoint2 = aIMovePoint.distances.Keys[num3];
				if (!movePoints.Contains(aIMovePoint2))
				{
					aIMovePoint.distances.Remove(aIMovePoint2);
				}
			}
			for (int num4 = aIMovePoint.distancesToCover.Keys.Count - 1; num4 >= 0; num4--)
			{
				AICoverPoint aICoverPoint = aIMovePoint.distancesToCover.Keys[num4];
				if (!coverPoints.Contains(aICoverPoint))
				{
					num2++;
					aIMovePoint.distancesToCover.Remove(aICoverPoint);
				}
			}
			foreach (AICoverPoint coverPoint in coverPoints)
			{
				if ((Object)(object)coverPoint == (Object)null || aIMovePoint.distancesToCover.Contains(coverPoint))
				{
					continue;
				}
				float num5 = -1f;
				if (Vector3.Distance(((Component)aIMovePoint).transform.position, ((Component)coverPoint).transform.position) > 40f)
				{
					num5 = -2f;
				}
				else if (NavMesh.CalculatePath(((Component)aIMovePoint).transform.position, ((Component)coverPoint).transform.position, num, val) && (int)val.status == 0)
				{
					int num6 = val.corners.Length;
					if (num6 > 1)
					{
						Vector3 val2 = val.corners[0];
						float num7 = 0f;
						for (int i = 0; i < num6; i++)
						{
							Vector3 val3 = val.corners[i];
							num7 += Vector3.Distance(val2, val3);
							val2 = val3;
						}
						num5 = num7;
						pathSuccesses++;
					}
					else
					{
						num5 = Vector3.Distance(((Component)aIMovePoint).transform.position, ((Component)coverPoint).transform.position);
						halfPaths++;
					}
				}
				else
				{
					pathFails++;
					num5 = -2f;
				}
				aIMovePoint.distancesToCover.Add(coverPoint, num5);
				if (!PassesBudget(realtimeSinceStartup, budgetSeconds))
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				processIndex++;
			}
			if (processIndex >= movePoints.Count - 1)
			{
				break;
			}
		}
		return processIndex >= movePoints.Count - 1;
	}

	public static void BudgetedTick()
	{
		if (!AI.move || Time.realtimeSinceStartup < buildTimeTest)
		{
			return;
		}
		bool flag = false;
		foreach (AIInformationZone zone in zones)
		{
			if (zone.isDirty)
			{
				flag = true;
				_ = zone.isDirty;
				zone.isDirty = !zone.ProcessDistancesAttempt();
				break;
			}
		}
		if (Global.developer > 0)
		{
			if (flag && !lastFrameAnyDirty)
			{
				Debug.Log((object)"AIInformationZones rebuilding...");
				rebuildStartTime = Time.realtimeSinceStartup;
			}
			if (lastFrameAnyDirty && !flag)
			{
				Debug.Log((object)("AIInformationZone rebuild complete! Duration : " + (Time.realtimeSinceStartup - rebuildStartTime) + " seconds."));
			}
		}
		lastFrameAnyDirty = flag;
	}

	public void NavmeshBuildingComplete()
	{
		lastNavmeshBuildTime = Time.realtimeSinceStartup;
		buildTimeTest = Time.realtimeSinceStartup + 15f;
		MarkDirty(completeRefresh: true);
	}

	public Vector3 ClosestPointTo(Vector3 target)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref areaBox)).ClosestPoint(target);
	}

	public void AddInitialPoints()
	{
		AICoverPoint[] componentsInChildren = ((Component)((Component)this).transform).GetComponentsInChildren<AICoverPoint>();
		foreach (AICoverPoint point in componentsInChildren)
		{
			AddCoverPoint(point);
		}
		AIMovePoint[] componentsInChildren2 = ((Component)((Component)this).transform).GetComponentsInChildren<AIMovePoint>(true);
		foreach (AIMovePoint point2 in componentsInChildren2)
		{
			AddMovePoint(point2);
		}
		RefreshPointArrays();
		NavMeshLink[] componentsInChildren3 = ((Component)((Component)this).transform).GetComponentsInChildren<NavMeshLink>(true);
		navMeshLinks.AddRange(componentsInChildren3);
		AIMovePointPath[] componentsInChildren4 = ((Component)((Component)this).transform).GetComponentsInChildren<AIMovePointPath>();
		paths.AddRange(componentsInChildren4);
	}

	private void RefreshPointArrays()
	{
		movePointArray = movePoints?.ToArray();
		coverPointArray = coverPoints?.ToArray();
	}

	public void AddDynamicAIPoints(AIMovePoint[] movePoints, AICoverPoint[] coverPoints, Func<Vector3, bool> validatePoint = null)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (movePoints != null)
		{
			foreach (AIMovePoint aIMovePoint in movePoints)
			{
				if (!((Object)(object)aIMovePoint == (Object)null) && (validatePoint == null || (validatePoint != null && validatePoint(((Component)aIMovePoint).transform.position))))
				{
					AddMovePoint(aIMovePoint);
				}
			}
		}
		if (coverPoints != null)
		{
			foreach (AICoverPoint aICoverPoint in coverPoints)
			{
				if (!((Object)(object)aICoverPoint == (Object)null) && (validatePoint == null || (validatePoint != null && validatePoint(((Component)aICoverPoint).transform.position))))
				{
					AddCoverPoint(aICoverPoint);
				}
			}
		}
		RefreshPointArrays();
	}

	public void RemoveDynamicAIPoints(AIMovePoint[] movePoints, AICoverPoint[] coverPoints)
	{
		if (movePoints != null)
		{
			foreach (AIMovePoint aIMovePoint in movePoints)
			{
				if (!((Object)(object)aIMovePoint == (Object)null))
				{
					RemoveMovePoint(aIMovePoint, markDirty: false);
				}
			}
		}
		if (coverPoints != null)
		{
			foreach (AICoverPoint aICoverPoint in coverPoints)
			{
				if (!((Object)(object)aICoverPoint == (Object)null))
				{
					RemoveCoverPoint(aICoverPoint, markDirty: false);
				}
			}
		}
		MarkDirty();
		RefreshPointArrays();
	}

	public AIMovePointPath GetNearestPath(Vector3 position)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (paths == null || paths.Count == 0)
		{
			return null;
		}
		float num = float.MaxValue;
		AIMovePointPath result = null;
		foreach (AIMovePointPath path in paths)
		{
			foreach (AIMovePoint point in path.Points)
			{
				float num2 = Vector3.SqrMagnitude(((Component)point).transform.position - position);
				if (num2 < num)
				{
					num = num2;
					result = path;
				}
			}
		}
		return result;
	}

	public static AIInformationZone GetForPoint(Vector3 point, bool fallBackToNearest = true)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		if (zones == null || zones.Count == 0)
		{
			return null;
		}
		foreach (AIInformationZone zone in zones)
		{
			if (!((Object)(object)zone == (Object)null) && !zone.Virtual && ((OBB)(ref zone.areaBox)).Contains(point))
			{
				return zone;
			}
		}
		if (!fallBackToNearest)
		{
			return null;
		}
		float num = float.PositiveInfinity;
		AIInformationZone aIInformationZone = zones[0];
		foreach (AIInformationZone zone2 in zones)
		{
			if (!((Object)(object)zone2 == (Object)null) && !((Object)(object)((Component)zone2).transform == (Object)null) && !zone2.Virtual)
			{
				float num2 = Vector3.Distance(((Component)zone2).transform.position, point);
				if (num2 < num)
				{
					num = num2;
					aIInformationZone = zone2;
				}
			}
		}
		if (aIInformationZone.Virtual)
		{
			aIInformationZone = null;
		}
		return aIInformationZone;
	}

	public bool PointInside(Vector3 point)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref areaBox)).Contains(point);
	}

	public AIMovePoint GetBestMovePointNear(BaseEntity targetEntity, BaseEntity fromEntity, float minRange, float maxRange, bool checkLOS = false, BaseEntity forObject = null, bool returnClosest = false, bool returnRandom = false)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetEntity == (Object)null || (Object)(object)fromEntity == (Object)null)
		{
			return null;
		}
		AIPoint aIPoint = null;
		AIPoint aIPoint2 = null;
		float num = -1f;
		float num2 = float.PositiveInfinity;
		int pointCount;
		AIPoint[] movePointsInRange = GetMovePointsInRange(((Component)targetEntity).transform.position, maxRange, out pointCount);
		if (movePointsInRange == null || pointCount <= 0)
		{
			return null;
		}
		for (int i = 0; i < pointCount; i++)
		{
			AIPoint aIPoint3 = movePointsInRange[i];
			if (!((Component)((Component)aIPoint3).transform.parent).gameObject.activeSelf || (!(((Component)fromEntity).transform.position.y < WaterSystem.OceanLevel) && ((Component)aIPoint3).transform.position.y < WaterSystem.OceanLevel))
			{
				continue;
			}
			float num3 = 0f;
			Vector3 position = ((Component)aIPoint3).transform.position;
			float num4 = Vector3.Distance(((Component)targetEntity).transform.position, position);
			if (num4 < num2)
			{
				aIPoint2 = aIPoint3;
				num2 = num4;
			}
			if (num4 > maxRange)
			{
				continue;
			}
			num3 += (aIPoint3.CanBeUsedBy(forObject) ? 100f : 0f);
			num3 += (1f - Mathf.InverseLerp(minRange, maxRange, num4)) * 100f;
			if (num3 < num)
			{
				continue;
			}
			if (checkLOS)
			{
				BasePlayer basePlayer = targetEntity as BasePlayer;
				HumanNPC humanNPC = fromEntity as HumanNPC;
				bool flag;
				if (!UseSimpleLOSCheck && (Object)(object)basePlayer != (Object)null && (Object)(object)humanNPC != (Object)null)
				{
					Vector3 fromOffset = position - ((Component)humanNPC).transform.position;
					flag = humanNPC.CanSeeTarget(basePlayer, fromOffset);
				}
				else
				{
					flag = !Physics.Linecast(((Component)targetEntity).transform.position + Vector3.up, position + Vector3.up, 1218519297, (QueryTriggerInteraction)1);
				}
				if (!flag)
				{
					continue;
				}
			}
			if (num3 > num)
			{
				aIPoint = aIPoint3;
				num = num3;
			}
		}
		if ((Object)(object)aIPoint == (Object)null && returnRandom)
		{
			return movePointsInRange[Random.Range(0, movePointsInRange.Length)] as AIMovePoint;
		}
		if ((Object)(object)aIPoint == (Object)null && returnClosest)
		{
			return aIPoint2 as AIMovePoint;
		}
		return aIPoint as AIMovePoint;
	}

	public AIPoint[] GetMovePointsInRange(Vector3 currentPos, float maxRange, out int pointCount)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		pointCount = 0;
		AIMovePoint[] movePointsInRange;
		if ((Object)(object)grid != (Object)null && AI.usegrid)
		{
			movePointsInRange = grid.GetMovePointsInRange(currentPos, maxRange, out pointCount);
		}
		else
		{
			movePointsInRange = movePointArray;
			if (movePointsInRange != null)
			{
				pointCount = movePointsInRange.Length;
			}
		}
		return movePointsInRange;
	}

	private AIMovePoint GetClosestRaw(Vector3 pos, bool onlyIncludeWithCover = false)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		AIMovePoint result = null;
		float num = float.PositiveInfinity;
		foreach (AIMovePoint movePoint in movePoints)
		{
			if (!onlyIncludeWithCover || movePoint.distancesToCover.Count != 0)
			{
				float num2 = Vector3.Distance(((Component)movePoint).transform.position, pos);
				if (num2 < num)
				{
					num = num2;
					result = movePoint;
				}
			}
		}
		return result;
	}

	public AICoverPoint GetBestCoverPoint(Vector3 currentPosition, Vector3 hideFromPosition, float minRange = 0f, float maxRange = 20f, BaseEntity forObject = null, bool allowObjectToReuse = true)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		AICoverPoint aICoverPoint = null;
		float num = 0f;
		AIMovePoint closestRaw = GetClosestRaw(currentPosition, onlyIncludeWithCover: true);
		int pointCount;
		AICoverPoint[] coverPointsInRange = GetCoverPointsInRange(currentPosition, maxRange, out pointCount);
		if (coverPointsInRange == null || pointCount <= 0)
		{
			return null;
		}
		for (int i = 0; i < pointCount; i++)
		{
			AICoverPoint aICoverPoint2 = coverPointsInRange[i];
			Vector3 position = ((Component)aICoverPoint2).transform.position;
			Vector3 val = hideFromPosition - position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float num2 = Vector3.Dot(((Component)aICoverPoint2).transform.forward, normalized);
			if (num2 < 1f - aICoverPoint2.coverDot)
			{
				continue;
			}
			float num3 = -1f;
			if (UseCalculatedCoverDistances && (Object)(object)closestRaw != (Object)null && closestRaw.distancesToCover.Contains(aICoverPoint2) && !isDirty)
			{
				num3 = closestRaw.distancesToCover[aICoverPoint2];
				if (num3 == -2f)
				{
					continue;
				}
			}
			else
			{
				num3 = Vector3.Distance(currentPosition, position);
			}
			float num4 = 0f;
			if (aICoverPoint2.InUse())
			{
				bool flag = aICoverPoint2.IsUsedBy(forObject);
				if (!(allowObjectToReuse && flag))
				{
					num4 -= 1000f;
				}
			}
			if (minRange > 0f)
			{
				num4 -= (1f - Mathf.InverseLerp(0f, minRange, num3)) * 100f;
			}
			float num5 = Mathf.Abs(position.y - currentPosition.y);
			num4 += (1f - Mathf.InverseLerp(1f, 5f, num5)) * 500f;
			num4 += Mathf.InverseLerp(1f - aICoverPoint2.coverDot, 1f, num2) * 50f;
			num4 += (1f - Mathf.InverseLerp(2f, maxRange, num3)) * 100f;
			float num6 = 1f - Mathf.InverseLerp(4f, 10f, Vector3.Distance(currentPosition, hideFromPosition));
			val = ((Component)aICoverPoint2).transform.position - currentPosition;
			float num7 = Vector3.Dot(((Vector3)(ref val)).normalized, normalized);
			num4 -= Mathf.InverseLerp(-1f, 0.25f, num7) * 50f * num6;
			if (num4 > num)
			{
				aICoverPoint = aICoverPoint2;
				num = num4;
			}
		}
		if (Object.op_Implicit((Object)(object)aICoverPoint))
		{
			return aICoverPoint;
		}
		return null;
	}

	private AICoverPoint[] GetCoverPointsInRange(Vector3 position, float maxRange, out int pointCount)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		pointCount = 0;
		AICoverPoint[] coverPointsInRange;
		if ((Object)(object)grid != (Object)null && AI.usegrid)
		{
			coverPointsInRange = grid.GetCoverPointsInRange(position, maxRange, out pointCount);
		}
		else
		{
			coverPointsInRange = coverPointArray;
			if (coverPointsInRange != null)
			{
				pointCount = coverPointsInRange.Length;
			}
		}
		return coverPointsInRange;
	}

	public NavMeshLink GetClosestNavMeshLink(Vector3 pos)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		NavMeshLink result = null;
		float num = float.PositiveInfinity;
		foreach (NavMeshLink navMeshLink in navMeshLinks)
		{
			float num2 = Vector3.Distance(((Component)navMeshLink).gameObject.transform.position, pos);
			if (num2 < num)
			{
				result = navMeshLink;
				num = num2;
				if (num2 < 0.25f)
				{
					break;
				}
			}
		}
		return result;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class AIMovePoint : AIPoint
{
	public class DistTo
	{
		public float distance;

		public AIMovePoint target;
	}

	public ListDictionary<AIMovePoint, float> distances = new ListDictionary<AIMovePoint, float>();

	public ListDictionary<AICoverPoint, float> distancesToCover = new ListDictionary<AICoverPoint, float>();

	public float radius = 1f;

	public float WaitTime;

	public List<Transform> LookAtPoints;

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		Color color = Gizmos.color;
		Gizmos.color = Color.green;
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, radius);
		Gizmos.color = color;
	}

	public void DrawLookAtPoints()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Color color = Gizmos.color;
		Gizmos.color = Color.gray;
		if (LookAtPoints != null)
		{
			foreach (Transform lookAtPoint in LookAtPoints)
			{
				if (!((Object)(object)lookAtPoint == (Object)null))
				{
					Gizmos.DrawSphere(lookAtPoint.position, 0.2f);
					Gizmos.DrawLine(((Component)this).transform.position, lookAtPoint.position);
				}
			}
		}
		Gizmos.color = color;
	}

	public void Clear()
	{
		LookAtPoints = null;
	}

	public void AddLookAtPoint(Transform transform)
	{
		if (LookAtPoints == null)
		{
			LookAtPoints = new List<Transform>();
		}
		LookAtPoints.Add(transform);
	}

	public bool HasLookAtPoints()
	{
		if (LookAtPoints != null)
		{
			return LookAtPoints.Count > 0;
		}
		return false;
	}

	public Transform GetRandomLookAtPoint()
	{
		if (LookAtPoints == null || LookAtPoints.Count == 0)
		{
			return null;
		}
		return LookAtPoints[Random.Range(0, LookAtPoints.Count)];
	}
}


public class DistTo
{
	public float distance;

	public AIMovePoint target;
}


using System.Collections.Generic;
using UnityEngine;

public class AIMovePointPath : MonoBehaviour
{
	public enum Mode
	{
		Loop,
		Reverse
	}

	public enum PathDirection
	{
		Forwards,
		Backwards
	}

	public Color DebugPathColor = Color.green;

	public Mode LoopMode;

	public List<AIMovePoint> Points = new List<AIMovePoint>();

	public void Clear()
	{
		Points.Clear();
	}

	public void AddPoint(AIMovePoint point)
	{
		Points.Add(point);
	}

	public AIMovePoint FindNearestPoint(Vector3 position)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Points[FindNearestPointIndex(position)];
	}

	public int FindNearestPointIndex(Vector3 position)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		int result = 0;
		int num2 = 0;
		foreach (AIMovePoint point in Points)
		{
			float num3 = Vector3.SqrMagnitude(position - ((Component)point).transform.position);
			if (num3 < num)
			{
				num = num3;
				result = num2;
			}
			num2++;
		}
		return result;
	}

	public AIMovePoint GetPointAtIndex(int index)
	{
		if (index < 0 || index >= Points.Count)
		{
			return null;
		}
		return Points[index];
	}

	public int GetNextPointIndex(int currentPointIndex, ref PathDirection pathDirection)
	{
		int num = currentPointIndex + ((pathDirection == PathDirection.Forwards) ? 1 : (-1));
		if (num < 0)
		{
			if (LoopMode == Mode.Loop)
			{
				num = Points.Count - 1;
			}
			else
			{
				num = 1;
				pathDirection = PathDirection.Forwards;
			}
		}
		else if (num >= Points.Count)
		{
			if (LoopMode == Mode.Loop)
			{
				num = 0;
			}
			else
			{
				num = Points.Count - 2;
				pathDirection = PathDirection.Backwards;
			}
		}
		return num;
	}

	private void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		Color color = Gizmos.color;
		Gizmos.color = DebugPathColor;
		int num = -1;
		foreach (AIMovePoint point in Points)
		{
			num++;
			if (!((Object)(object)point == (Object)null))
			{
				if (num + 1 < Points.Count)
				{
					Gizmos.DrawLine(((Component)point).transform.position, ((Component)Points[num + 1]).transform.position);
				}
				else if (LoopMode == Mode.Loop)
				{
					Gizmos.DrawLine(((Component)point).transform.position, ((Component)Points[0]).transform.position);
				}
			}
		}
		Gizmos.color = color;
	}

	private void OnDrawGizmosSelected()
	{
		if (Points == null)
		{
			return;
		}
		foreach (AIMovePoint point in Points)
		{
			point.DrawLookAtPoints();
		}
	}

	[ContextMenu("Add Child Points")]
	public void AddChildPoints()
	{
		Points = new List<AIMovePoint>();
		Points.AddRange(((Component)this).GetComponentsInChildren<AIMovePoint>());
	}
}


public enum Mode
{
	Loop,
	Reverse
}


public enum PathDirection
{
	Forwards,
	Backwards
}


using System;
using UnityEngine;

public class AIPoint : BaseMonoBehaviour
{
	private BaseEntity currentUser;

	public bool InUse()
	{
		return (Object)(object)currentUser != (Object)null;
	}

	public bool IsUsedBy(BaseEntity user)
	{
		if (!InUse())
		{
			return false;
		}
		if ((Object)(object)user == (Object)null)
		{
			return false;
		}
		return (Object)(object)user == (Object)(object)currentUser;
	}

	public bool CanBeUsedBy(BaseEntity user)
	{
		if ((Object)(object)user != (Object)null && (Object)(object)currentUser == (Object)(object)user)
		{
			return true;
		}
		return !InUse();
	}

	public void SetUsedBy(BaseEntity user, float duration = 5f)
	{
		currentUser = user;
		((FacepunchBehaviour)this).CancelInvoke((Action)ClearUsed);
		((FacepunchBehaviour)this).Invoke((Action)ClearUsed, duration);
	}

	public void SetUsedBy(BaseEntity user)
	{
		currentUser = user;
	}

	public void ClearUsed()
	{
		currentUser = null;
	}

	public void ClearIfUsedBy(BaseEntity user)
	{
		if ((Object)(object)currentUser == (Object)(object)user)
		{
			ClearUsed();
		}
	}
}


using UnityEngine;

public class AITraversalArea : TriggerBase
{
	public Transform entryPoint1;

	public Transform entryPoint2;

	public AITraversalWaitPoint[] waitPoints;

	public Bounds movementArea;

	public Transform activeEntryPoint;

	public float nextFreeTime;

	public void OnValidate()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		((Bounds)(ref movementArea)).center = ((Component)this).transform.position;
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!baseEntity.IsNpc)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public bool CanTraverse(BaseEntity ent)
	{
		return Time.time > nextFreeTime;
	}

	public Transform GetClosestEntry(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(position, entryPoint1.position);
		float num2 = Vector3.Distance(position, entryPoint2.position);
		if (num < num2)
		{
			return entryPoint1;
		}
		return entryPoint2;
	}

	public Transform GetFarthestEntry(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(position, entryPoint1.position);
		float num2 = Vector3.Distance(position, entryPoint2.position);
		if (num > num2)
		{
			return entryPoint1;
		}
		return entryPoint2;
	}

	public void SetBusyFor(float dur = 1f)
	{
		nextFreeTime = Time.time + dur;
	}

	public bool CanUse(Vector3 dirFrom)
	{
		return Time.time > nextFreeTime;
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
	}

	public AITraversalWaitPoint GetEntryPointNear(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = GetClosestEntry(pos).position;
		Vector3 position2 = GetFarthestEntry(pos).position;
		_ = new BaseEntity[1];
		AITraversalWaitPoint result = null;
		float num = 0f;
		AITraversalWaitPoint[] array = waitPoints;
		foreach (AITraversalWaitPoint aITraversalWaitPoint in array)
		{
			if (aITraversalWaitPoint.Occupied())
			{
				continue;
			}
			Vector3 position3 = ((Component)aITraversalWaitPoint).transform.position;
			float num2 = Vector3.Distance(position, position3);
			if (!(Vector3.Distance(position2, position3) < num2))
			{
				float num3 = Vector3.Distance(position3, pos);
				float num4 = (1f - Mathf.InverseLerp(0f, 20f, num3)) * 100f;
				if (num4 > num)
				{
					num = num4;
					result = aITraversalWaitPoint;
				}
			}
		}
		return result;
	}

	public bool EntityFilter(BaseEntity ent)
	{
		if (ent.IsNpc)
		{
			return ent.isServer;
		}
		return false;
	}

	public override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.magenta;
		Gizmos.DrawCube(entryPoint1.position + Vector3.up * 0.125f, new Vector3(0.5f, 0.25f, 0.5f));
		Gizmos.DrawCube(entryPoint2.position + Vector3.up * 0.125f, new Vector3(0.5f, 0.25f, 0.5f));
		Gizmos.color = new Color(0.2f, 1f, 0.2f, 0.5f);
		Gizmos.DrawCube(((Bounds)(ref movementArea)).center, ((Bounds)(ref movementArea)).size);
		Gizmos.color = Color.magenta;
		AITraversalWaitPoint[] array = waitPoints;
		for (int i = 0; i < array.Length; i++)
		{
			GizmosUtil.DrawCircleY(((Component)array[i]).transform.position, 0.5f);
		}
	}
}


using UnityEngine;

public class AITraversalWaitPoint : MonoBehaviour
{
	public float nextFreeTime;

	public bool Occupied()
	{
		return Time.time > nextFreeTime;
	}

	public void Occupy(float dur = 1f)
	{
		nextFreeTime = Time.time + dur;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class BaseNavigator : BaseMonoBehaviour
{
	public enum NavigationType
	{
		None,
		NavMesh,
		AStar,
		Custom,
		Base
	}

	public enum NavigationSpeed
	{
		Slowest,
		Slow,
		Normal,
		Fast
	}

	protected enum OverrideFacingDirectionMode
	{
		None,
		Direction,
		Entity
	}

	[ServerVar(Help = "The max step-up height difference for pet base navigation")]
	public static float maxStepUpDistance = 1.7f;

	[ServerVar(Help = "How many frames between base navigation movement updates")]
	public static int baseNavMovementFrameInterval = 2;

	[ServerVar(Help = "How long we are not moving for before trigger the stuck event")]
	public static float stuckTriggerDuration = 10f;

	[ServerVar]
	public static float navTypeHeightOffset = 0.5f;

	[ServerVar]
	public static float navTypeDistance = 1f;

	[Header("General")]
	public bool CanNavigateMounted;

	public bool CanUseNavMesh = true;

	public bool CanUseAStar = true;

	public bool CanUseBaseNav;

	public bool CanUseCustomNav;

	public float StoppingDistance = 0.5f;

	public string DefaultArea = "Walkable";

	public bool CanPathFindToChaseTargetIfNoMovePoint;

	public int PathFindChaseLOSAttemptCount = 5;

	public float PathFindChaseLOSDistanceMultiplier = 1.5f;

	[Header("Stuck Detection")]
	public bool TriggerStuckEvent;

	public float StuckDistance = 1f;

	[Header("Speed")]
	public float Speed = 5f;

	public float Acceleration = 5f;

	public float TurnSpeed = 10f;

	public NavigationSpeed MoveTowardsSpeed = NavigationSpeed.Normal;

	public bool FaceMoveTowardsTarget;

	[Header("Speed Fractions")]
	public float SlowestSpeedFraction = 0.16f;

	public float SlowSpeedFraction = 0.3f;

	public float NormalSpeedFraction = 0.5f;

	public float FastSpeedFraction = 1f;

	public float LowHealthSpeedReductionTriggerFraction;

	public float LowHealthMaxSpeedFraction = 0.5f;

	public float SwimmingSpeedMultiplier = 0.25f;

	[Header("AIPoint Usage")]
	public float BestMovementPointMaxDistance = 10f;

	public float BestCoverPointMaxDistance = 20f;

	public float BestRoamPointMaxDistance = 20f;

	public float MaxRoamDistanceFromHome = -1f;

	[Header("Misc")]
	public float FaceTargetChaseDistance = 10f;

	public bool CanUseRandomMovePointIfNonFound;

	public float MaxWaterDepth = 0.75f;

	public bool SpeedBasedAvoidancePriority;

	private NavMeshPath path;

	private NavMeshQueryFilter navMeshQueryFilter;

	private int defaultAreaMask;

	[InspectorFlags]
	public Enum biomePreference = (Enum)12;

	public bool UseBiomePreference;

	[InspectorFlags]
	public Enum topologyPreference = (Enum)96;

	[InspectorFlags]
	public Enum topologyPrevent;

	[InspectorFlags]
	public Enum biomeRequirement;

	public float stuckTimer;

	public Vector3 stuckCheckPosition;

	protected bool traversingNavMeshLink;

	protected string currentNavMeshLinkName;

	protected Vector3 currentNavMeshLinkEndPos;

	protected Stack<IAIPathNode> currentAStarPath;

	protected IAIPathNode targetNode;

	protected float currentSpeedFraction = 1f;

	private float lastSetDestinationTime;

	protected OverrideFacingDirectionMode overrideFacingDirectionMode;

	protected BaseEntity facingDirectionEntity;

	protected bool overrideFacingDirection;

	protected Vector3 facingDirectionOverride;

	protected bool paused;

	private int frameCount;

	private float accumDelta;

	public AIMovePointPath Path { get; set; }

	public BasePath AStarGraph { get; set; }

	public NavMeshAgent Agent { get; private set; }

	public BaseCombatEntity BaseEntity { get; private set; }

	public Vector3 Destination { get; set; }

	public virtual bool IsOnNavMeshLink
	{
		get
		{
			if (((Behaviour)Agent).enabled)
			{
				return Agent.isOnOffMeshLink;
			}
			return false;
		}
	}

	public bool Moving => CurrentNavigationType != NavigationType.None;

	public NavigationType CurrentNavigationType { get; private set; }

	public NavigationType LastUsedNavigationType { get; private set; }

	[HideInInspector]
	public bool StuckOffNavmesh { get; private set; }

	public virtual bool HasPath
	{
		get
		{
			if ((Object)(object)Agent == (Object)null)
			{
				return false;
			}
			if (((Behaviour)Agent).enabled && Agent.hasPath)
			{
				return true;
			}
			if (currentAStarPath != null)
			{
				return true;
			}
			return false;
		}
	}

	public bool IsOverridingFacingDirection => overrideFacingDirectionMode != OverrideFacingDirectionMode.None;

	public Vector3 FacingDirectionOverride => facingDirectionOverride;

	public int TopologyPreference()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected I4, but got Unknown
		return (int)topologyPreference;
	}

	public int TopologyPrevent()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected I4, but got Unknown
		return (int)topologyPrevent;
	}

	public int BiomeRequirement()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected I4, but got Unknown
		return (int)biomeRequirement;
	}

	public virtual void Init(BaseCombatEntity entity, NavMeshAgent agent)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Expected O, but got Unknown
		defaultAreaMask = 1 << NavMesh.GetAreaFromName(DefaultArea);
		BaseEntity = entity;
		Agent = agent;
		if ((Object)(object)Agent != (Object)null)
		{
			Agent.acceleration = Acceleration;
			Agent.angularSpeed = TurnSpeed;
		}
		navMeshQueryFilter = default(NavMeshQueryFilter);
		((NavMeshQueryFilter)(ref navMeshQueryFilter)).agentTypeID = Agent.agentTypeID;
		((NavMeshQueryFilter)(ref navMeshQueryFilter)).areaMask = defaultAreaMask;
		path = new NavMeshPath();
		SetCurrentNavigationType(NavigationType.None);
	}

	public void SetNavMeshEnabled(bool flag)
	{
		if ((Object)(object)Agent == (Object)null || ((Behaviour)Agent).enabled == flag)
		{
			return;
		}
		if (AiManager.nav_disable)
		{
			((Behaviour)Agent).enabled = false;
			return;
		}
		if (((Behaviour)Agent).enabled)
		{
			if (flag)
			{
				if (Agent.isOnNavMesh)
				{
					Agent.isStopped = false;
				}
			}
			else if (Agent.isOnNavMesh)
			{
				Agent.isStopped = true;
			}
		}
		((Behaviour)Agent).enabled = flag;
		if (flag && CanEnableNavMeshNavigation())
		{
			PlaceOnNavMesh(2f);
		}
	}

	protected virtual bool CanEnableNavMeshNavigation()
	{
		if (!CanUseNavMesh)
		{
			return false;
		}
		return true;
	}

	protected virtual bool CanUpdateMovement()
	{
		if ((Object)(object)BaseEntity != (Object)null && !BaseEntity.IsAlive())
		{
			return false;
		}
		return true;
	}

	public void ForceToGround()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)DelayedForceToGround);
		((FacepunchBehaviour)this).Invoke((Action)DelayedForceToGround, 0.5f);
	}

	private void DelayedForceToGround()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		int num = 10551296;
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(((Component)this).transform.position + Vector3.up * 0.5f, Vector3.down, ref val, 1000f, num))
		{
			BaseEntity.ServerPosition = ((RaycastHit)(ref val)).point;
		}
	}

	public bool PlaceOnNavMesh(float yOffset)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (Agent.isOnNavMesh)
		{
			return true;
		}
		bool flag = false;
		float maxRange = (IsSwimming() ? 30f : 6f);
		if (GetNearestNavmeshPosition(((Component)this).transform.position + Vector3.one * yOffset, out var position, maxRange))
		{
			flag = Warp(position);
			if (flag)
			{
				OnPlacedOnNavmesh();
			}
		}
		if (!flag)
		{
			StuckOffNavmesh = true;
			OnFailedToPlaceOnNavmesh();
		}
		return flag;
	}

	public virtual void OnPlacedOnNavmesh()
	{
	}

	public virtual void OnFailedToPlaceOnNavmesh()
	{
	}

	public bool Warp(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Agent.Warp(position);
		((Behaviour)Agent).enabled = true;
		((Component)this).transform.position = position;
		if (!Agent.isOnNavMesh)
		{
			Debug.LogWarning((object)("Agent still not on navmesh after a warp. No navmesh areas matching agent type? Agent type: " + Agent.agentTypeID), (Object)(object)((Component)this).gameObject);
			StuckOffNavmesh = true;
			return false;
		}
		StuckOffNavmesh = false;
		return true;
	}

	public bool GetNearestNavmeshPosition(Vector3 target, out Vector3 position, float maxRange)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		position = ((Component)this).transform.position;
		bool result = true;
		NavMeshHit val = default(NavMeshHit);
		if (NavMesh.SamplePosition(target, ref val, maxRange, defaultAreaMask))
		{
			position = ((NavMeshHit)(ref val)).position;
		}
		else
		{
			result = false;
		}
		return result;
	}

	public bool SetBaseDestination(Vector3 pos, float speedFraction)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.move)
		{
			return false;
		}
		if (!AI.navthink)
		{
			return false;
		}
		paused = false;
		currentSpeedFraction = speedFraction;
		if (ReachedPosition(pos))
		{
			return true;
		}
		Destination = pos;
		SetCurrentNavigationType(NavigationType.Base);
		return true;
	}

	public bool SetDestination(BasePath path, IAIPathNode newTargetNode, float speedFraction)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.move)
		{
			return false;
		}
		if (!AI.navthink)
		{
			return false;
		}
		paused = false;
		if (!CanUseAStar)
		{
			return false;
		}
		if (newTargetNode == targetNode && HasPath)
		{
			return true;
		}
		if (ReachedPosition(newTargetNode.Position))
		{
			return true;
		}
		IAIPathNode closestToPoint = path.GetClosestToPoint(((Component)this).transform.position);
		if (closestToPoint == null || !closestToPoint.IsValid())
		{
			return false;
		}
		if (AStarPath.FindPath(closestToPoint, newTargetNode, out currentAStarPath, out var _))
		{
			currentSpeedFraction = speedFraction;
			targetNode = newTargetNode;
			SetCurrentNavigationType(NavigationType.AStar);
			Destination = newTargetNode.Position;
			return true;
		}
		return false;
	}

	public bool SetDestination(Vector3 pos, NavigationSpeed speed, float updateInterval = 0f, float navmeshSampleDistance = 0f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return SetDestination(pos, GetSpeedFraction(speed), updateInterval, navmeshSampleDistance);
	}

	public virtual bool SetCustomDestination(Vector3 pos, float speedFraction = 1f, float updateInterval = 0f)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.move)
		{
			return false;
		}
		if (!AI.navthink)
		{
			return false;
		}
		if (!CanUseCustomNav)
		{
			return false;
		}
		paused = false;
		if (ReachedPosition(pos))
		{
			return true;
		}
		currentSpeedFraction = speedFraction;
		SetCurrentNavigationType(NavigationType.Custom);
		return true;
	}

	public bool SetDestination(Vector3 pos, float speedFraction = 1f, float updateInterval = 0f, float navmeshSampleDistance = 0f)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.move)
		{
			return false;
		}
		if (!AI.navthink)
		{
			return false;
		}
		if (updateInterval > 0f && !UpdateIntervalElapsed(updateInterval))
		{
			return true;
		}
		lastSetDestinationTime = Time.time;
		paused = false;
		currentSpeedFraction = speedFraction;
		if (ReachedPosition(pos))
		{
			return true;
		}
		NavigationType navigationType = NavigationType.NavMesh;
		bool num = CanUseBaseNav && CanUseNavMesh;
		NavigationType navigationType2 = NavigationType.None;
		if (num)
		{
			Vector3 navMeshPos;
			NavigationType navigationType3 = DetermineNavigationType(((Component)this).transform.position, out navMeshPos);
			navigationType2 = DetermineNavigationType(pos, out var _);
			if (navigationType2 == NavigationType.NavMesh && navigationType3 == NavigationType.NavMesh && (CurrentNavigationType == NavigationType.None || CurrentNavigationType == NavigationType.Base))
			{
				Warp(navMeshPos);
			}
			if (navigationType2 == NavigationType.Base && navigationType3 != NavigationType.Base)
			{
				BasePet basePet = BaseEntity as BasePet;
				if ((Object)(object)basePet != (Object)null)
				{
					BasePlayer basePlayer = basePet.Brain.Events.Memory.Entity.Get(5) as BasePlayer;
					if ((Object)(object)basePlayer != (Object)null)
					{
						BuildingPrivlidge buildingPrivilege = basePlayer.GetBuildingPrivilege(new OBB(pos, ((Component)this).transform.rotation, BaseEntity.bounds));
						if ((Object)(object)buildingPrivilege != (Object)null && !buildingPrivilege.IsAuthed(basePlayer) && buildingPrivilege.AnyAuthed())
						{
							return false;
						}
					}
				}
			}
			switch (navigationType2)
			{
			case NavigationType.Base:
				navigationType = ((navigationType3 == NavigationType.Base) ? NavigationType.Base : ((!(Vector3.Distance(BaseEntity.ServerPosition, pos) <= 10f) || !(Mathf.Abs(BaseEntity.ServerPosition.y - pos.y) <= 3f)) ? NavigationType.NavMesh : NavigationType.Base));
				break;
			case NavigationType.NavMesh:
				navigationType = ((navigationType3 == NavigationType.NavMesh) ? NavigationType.NavMesh : NavigationType.Base);
				break;
			}
		}
		else
		{
			navigationType = (CanUseNavMesh ? NavigationType.NavMesh : NavigationType.AStar);
		}
		switch (navigationType)
		{
		case NavigationType.Base:
			return SetBaseDestination(pos, speedFraction);
		case NavigationType.AStar:
			if ((Object)(object)AStarGraph != (Object)null)
			{
				return SetDestination(AStarGraph, AStarGraph.GetClosestToPoint(pos), speedFraction);
			}
			if (CanUseCustomNav)
			{
				return SetCustomDestination(pos, speedFraction, updateInterval);
			}
			return false;
		default:
		{
			if (AiManager.nav_disable)
			{
				return false;
			}
			if (navmeshSampleDistance > 0f && AI.setdestinationsamplenavmesh)
			{
				NavMeshHit val = default(NavMeshHit);
				if (!NavMesh.SamplePosition(pos, ref val, navmeshSampleDistance, defaultAreaMask))
				{
					return false;
				}
				pos = ((NavMeshHit)(ref val)).position;
			}
			SetCurrentNavigationType(NavigationType.NavMesh);
			if (!Agent.isOnNavMesh)
			{
				return false;
			}
			if (!((Behaviour)Agent).isActiveAndEnabled)
			{
				return false;
			}
			Destination = pos;
			bool flag;
			if (AI.usecalculatepath)
			{
				flag = NavMesh.CalculatePath(((Component)this).transform.position, Destination, navMeshQueryFilter, path);
				if (flag)
				{
					Agent.SetPath(path);
				}
				else if (AI.usesetdestinationfallback)
				{
					flag = Agent.SetDestination(Destination);
				}
			}
			else
			{
				flag = Agent.SetDestination(Destination);
			}
			if (flag && SpeedBasedAvoidancePriority)
			{
				Agent.avoidancePriority = Random.Range(0, 21) + Mathf.FloorToInt(speedFraction * 80f);
			}
			return flag;
		}
		}
	}

	private NavigationType DetermineNavigationType(Vector3 location, out Vector3 navMeshPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		navMeshPos = location;
		int num = 2097152;
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(location + Vector3.up * navTypeHeightOffset, Vector3.down, ref val, navTypeDistance, num))
		{
			return NavigationType.Base;
		}
		Vector3 position;
		int result = (GetNearestNavmeshPosition(location + Vector3.up * navTypeHeightOffset, out position, navTypeDistance) ? 1 : 4);
		navMeshPos = position;
		return (NavigationType)result;
	}

	public void SetCurrentSpeed(NavigationSpeed speed)
	{
		currentSpeedFraction = GetSpeedFraction(speed);
	}

	public bool UpdateIntervalElapsed(float updateInterval)
	{
		if (updateInterval <= 0f)
		{
			return true;
		}
		return Time.time - lastSetDestinationTime >= updateInterval;
	}

	public float GetSpeedFraction(NavigationSpeed speed)
	{
		return speed switch
		{
			NavigationSpeed.Fast => FastSpeedFraction, 
			NavigationSpeed.Normal => NormalSpeedFraction, 
			NavigationSpeed.Slow => SlowSpeedFraction, 
			NavigationSpeed.Slowest => SlowestSpeedFraction, 
			_ => 1f, 
		};
	}

	public void SetCurrentNavigationType(NavigationType navType)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (CurrentNavigationType == NavigationType.None)
		{
			stuckCheckPosition = ((Component)this).transform.position;
			stuckTimer = 0f;
		}
		CurrentNavigationType = navType;
		if (CurrentNavigationType != 0)
		{
			LastUsedNavigationType = CurrentNavigationType;
		}
		switch (navType)
		{
		case NavigationType.None:
			stuckTimer = 0f;
			break;
		case NavigationType.NavMesh:
			SetNavMeshEnabled(flag: true);
			break;
		}
	}

	public void Pause()
	{
		if (CurrentNavigationType != 0)
		{
			Stop();
			paused = true;
		}
	}

	public void Resume()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (paused)
		{
			SetDestination(Destination, currentSpeedFraction);
			paused = false;
		}
	}

	public void Stop()
	{
		switch (CurrentNavigationType)
		{
		case NavigationType.AStar:
			StopAStar();
			break;
		case NavigationType.NavMesh:
			StopNavMesh();
			break;
		case NavigationType.Custom:
			StopCustom();
			break;
		}
		SetCurrentNavigationType(NavigationType.None);
		paused = false;
	}

	private void StopNavMesh()
	{
		SetNavMeshEnabled(flag: false);
	}

	private void StopAStar()
	{
		currentAStarPath = null;
		targetNode = null;
	}

	protected virtual void StopCustom()
	{
	}

	public void Think(float delta)
	{
		if (AI.move && AI.navthink && !((Object)(object)BaseEntity == (Object)null))
		{
			UpdateNavigation(delta);
		}
	}

	public void UpdateNavigation(float delta)
	{
		UpdateMovement(delta);
	}

	private void UpdateMovement(float delta)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.move || !CanUpdateMovement())
		{
			return;
		}
		Vector3 moveToPosition = ((Component)this).transform.position;
		if (TriggerStuckEvent)
		{
			stuckTimer += delta;
			if (CurrentNavigationType != 0 && stuckTimer >= stuckTriggerDuration)
			{
				if (Vector3.Distance(((Component)this).transform.position, stuckCheckPosition) <= StuckDistance)
				{
					OnStuck();
				}
				stuckTimer = 0f;
				stuckCheckPosition = ((Component)this).transform.position;
			}
		}
		if (CurrentNavigationType == NavigationType.Base)
		{
			moveToPosition = Destination;
		}
		else if (IsOnNavMeshLink)
		{
			HandleNavMeshLinkTraversal(delta, ref moveToPosition);
		}
		else if (HasPath)
		{
			moveToPosition = GetNextPathPosition();
		}
		else if (CurrentNavigationType == NavigationType.Custom)
		{
			moveToPosition = Destination;
		}
		if (ValidateNextPosition(ref moveToPosition))
		{
			bool swimming = IsSwimming();
			UpdateSpeed(delta, swimming);
			UpdatePositionAndRotation(moveToPosition, delta);
		}
	}

	public virtual void OnStuck()
	{
		BasePet basePet = BaseEntity as BasePet;
		if ((Object)(object)basePet != (Object)null && (Object)(object)basePet.Brain != (Object)null)
		{
			basePet.Brain.LoadDefaultAIDesign();
		}
	}

	public virtual bool IsSwimming()
	{
		return false;
	}

	private Vector3 GetNextPathPosition()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (currentAStarPath != null && currentAStarPath.Count > 0)
		{
			IAIPathNode iAIPathNode = currentAStarPath.Peek();
			if (iAIPathNode == null || !iAIPathNode.IsValid())
			{
				return ((Component)this).transform.position;
			}
			return iAIPathNode.Position;
		}
		return Agent.nextPosition;
	}

	private bool ValidateNextPosition(ref Vector3 moveToPosition)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		bool flag = ValidBounds.Test(BaseEntity, moveToPosition);
		if ((Object)(object)BaseEntity != (Object)null && !flag && (Object)(object)((Component)this).transform != (Object)null && !BaseEntity.IsDestroyed)
		{
			Debug.Log((object)("Invalid NavAgent Position: " + ((object)this)?.ToString() + " " + ((object)(Vector3)(ref moveToPosition)/*cast due to .constrained prefix*/).ToString() + " (destroying)"));
			BaseEntity.Kill();
			return false;
		}
		return true;
	}

	private void UpdateSpeed(float delta, bool swimming)
	{
		float num = GetTargetSpeed();
		if (LowHealthSpeedReductionTriggerFraction > 0f && BaseEntity.healthFraction <= LowHealthSpeedReductionTriggerFraction)
		{
			num = Mathf.Min(num, Speed * LowHealthMaxSpeedFraction);
		}
		Agent.speed = num * (swimming ? SwimmingSpeedMultiplier : 1f);
	}

	protected virtual float GetTargetSpeed()
	{
		return Speed * currentSpeedFraction;
	}

	protected virtual void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
	{
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		if (CurrentNavigationType == NavigationType.AStar && currentAStarPath != null && currentAStarPath.Count > 0)
		{
			((Component)this).transform.position = Vector3.MoveTowards(((Component)this).transform.position, moveToPosition, Agent.speed * delta);
			BaseEntity.ServerPosition = ((Component)this).transform.localPosition;
			if (ReachedPosition(moveToPosition))
			{
				currentAStarPath.Pop();
				if (currentAStarPath.Count == 0)
				{
					Stop();
					return;
				}
				moveToPosition = currentAStarPath.Peek().Position;
			}
		}
		if (CurrentNavigationType == NavigationType.NavMesh)
		{
			if (ReachedPosition(Agent.destination))
			{
				Stop();
			}
			if ((Object)(object)BaseEntity != (Object)null)
			{
				BaseEntity.ServerPosition = moveToPosition;
			}
		}
		if (CurrentNavigationType == NavigationType.Base)
		{
			frameCount++;
			accumDelta += delta;
			if (frameCount < baseNavMovementFrameInterval)
			{
				return;
			}
			frameCount = 0;
			delta = accumDelta;
			accumDelta = 0f;
			int num = 10551552;
			Vector3 val = Vector3Ex.Direction2D(Destination, BaseEntity.ServerPosition);
			Vector3 val2 = BaseEntity.ServerPosition + val * delta * Agent.speed;
			Vector3 val3 = BaseEntity.ServerPosition + Vector3.up * maxStepUpDistance;
			Vector3 val4 = Vector3Ex.Direction(val2 + Vector3.up * maxStepUpDistance, BaseEntity.ServerPosition + Vector3.up * maxStepUpDistance);
			float num2 = Vector3.Distance(val3, val2 + Vector3.up * maxStepUpDistance) + 0.25f;
			RaycastHit val5 = default(RaycastHit);
			if (Physics.Raycast(val3, val4, ref val5, num2, num))
			{
				return;
			}
			Vector3 val6 = val2 + Vector3.up * (maxStepUpDistance + 0.3f);
			Vector3 val7 = val2;
			if (!Physics.SphereCast(val6, 0.25f, Vector3.down, ref val5, 10f, num))
			{
				return;
			}
			val7 = ((RaycastHit)(ref val5)).point;
			if (val7.y - BaseEntity.ServerPosition.y > maxStepUpDistance)
			{
				return;
			}
			BaseEntity.ServerPosition = val7;
			if (ReachedPosition(moveToPosition))
			{
				Stop();
			}
		}
		if (overrideFacingDirectionMode != 0)
		{
			ApplyFacingDirectionOverride();
		}
	}

	public virtual void ApplyFacingDirectionOverride()
	{
	}

	public void SetFacingDirectionEntity(BaseEntity entity)
	{
		overrideFacingDirectionMode = OverrideFacingDirectionMode.Entity;
		facingDirectionEntity = entity;
	}

	public void SetFacingDirectionOverride(Vector3 direction)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		overrideFacingDirectionMode = OverrideFacingDirectionMode.Direction;
		overrideFacingDirection = true;
		facingDirectionOverride = direction;
	}

	public void ClearFacingDirectionOverride()
	{
		overrideFacingDirectionMode = OverrideFacingDirectionMode.None;
		overrideFacingDirection = false;
		facingDirectionEntity = null;
	}

	protected bool ReachedPosition(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Distance(position, ((Component)this).transform.position) <= StoppingDistance;
	}

	private void HandleNavMeshLinkTraversal(float delta, ref Vector3 moveToPosition)
	{
		if (!traversingNavMeshLink)
		{
			HandleNavMeshLinkTraversalStart(delta);
		}
		HandleNavMeshLinkTraversalTick(delta, ref moveToPosition);
		if (IsNavMeshLinkTraversalComplete(delta, ref moveToPosition))
		{
			CompleteNavMeshLink();
		}
	}

	private bool HandleNavMeshLinkTraversalStart(float delta)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		OffMeshLinkData currentOffMeshLinkData = Agent.currentOffMeshLinkData;
		if (!((OffMeshLinkData)(ref currentOffMeshLinkData)).valid || !((OffMeshLinkData)(ref currentOffMeshLinkData)).activated)
		{
			return false;
		}
		Vector3 val = ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos - ((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		normalized.y = 0f;
		Vector3 desiredVelocity = Agent.desiredVelocity;
		desiredVelocity.y = 0f;
		if (Vector3.Dot(desiredVelocity, normalized) < 0.1f)
		{
			CompleteNavMeshLink();
			return false;
		}
		OffMeshLinkType linkType = ((OffMeshLinkData)(ref currentOffMeshLinkData)).linkType;
		currentNavMeshLinkName = ((object)(OffMeshLinkType)(ref linkType)/*cast due to .constrained prefix*/).ToString();
		Vector3 val2 = (((Object)(object)BaseEntity != (Object)null) ? BaseEntity.ServerPosition : ((Component)this).transform.position);
		val = val2 - ((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos;
		float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
		val = val2 - ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos;
		if (sqrMagnitude > ((Vector3)(ref val)).sqrMagnitude)
		{
			currentNavMeshLinkEndPos = ((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos;
		}
		else
		{
			currentNavMeshLinkEndPos = ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos;
		}
		traversingNavMeshLink = true;
		Agent.ActivateCurrentOffMeshLink(false);
		Agent.obstacleAvoidanceType = (ObstacleAvoidanceType)0;
		if (!(currentNavMeshLinkName == "OpenDoorLink") && !(currentNavMeshLinkName == "JumpRockLink"))
		{
			_ = currentNavMeshLinkName == "JumpFoundationLink";
		}
		return true;
	}

	private void HandleNavMeshLinkTraversalTick(float delta, ref Vector3 moveToPosition)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (currentNavMeshLinkName == "OpenDoorLink")
		{
			moveToPosition = Vector3.MoveTowards(moveToPosition, currentNavMeshLinkEndPos, Agent.speed * delta);
		}
		else if (currentNavMeshLinkName == "JumpRockLink")
		{
			moveToPosition = Vector3.MoveTowards(moveToPosition, currentNavMeshLinkEndPos, Agent.speed * delta);
		}
		else if (currentNavMeshLinkName == "JumpFoundationLink")
		{
			moveToPosition = Vector3.MoveTowards(moveToPosition, currentNavMeshLinkEndPos, Agent.speed * delta);
		}
		else
		{
			moveToPosition = Vector3.MoveTowards(moveToPosition, currentNavMeshLinkEndPos, Agent.speed * delta);
		}
	}

	private bool IsNavMeshLinkTraversalComplete(float delta, ref Vector3 moveToPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = moveToPosition - currentNavMeshLinkEndPos;
		if (((Vector3)(ref val)).sqrMagnitude < 0.01f)
		{
			moveToPosition = currentNavMeshLinkEndPos;
			traversingNavMeshLink = false;
			currentNavMeshLinkName = string.Empty;
			CompleteNavMeshLink();
			return true;
		}
		return false;
	}

	private void CompleteNavMeshLink()
	{
		Agent.ActivateCurrentOffMeshLink(true);
		Agent.CompleteOffMeshLink();
		Agent.isStopped = false;
		Agent.obstacleAvoidanceType = (ObstacleAvoidanceType)4;
	}

	public bool IsPositionATopologyPreference(Vector3 position)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.TopologyMap != (Object)null)
		{
			int topology = TerrainMeta.TopologyMap.GetTopology(position);
			if ((TopologyPreference() & topology) != 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsPositionPreventTopology(Vector3 position)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.TopologyMap != (Object)null)
		{
			int topology = TerrainMeta.TopologyMap.GetTopology(position);
			if ((TopologyPrevent() & topology) != 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsPositionABiomePreference(Vector3 position)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Expected I4, but got Unknown
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (!UseBiomePreference)
		{
			return true;
		}
		if ((Object)(object)TerrainMeta.BiomeMap != (Object)null)
		{
			int num = (int)biomePreference;
			if ((TerrainMeta.BiomeMap.GetBiomeMaxType(position) & num) != 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsPositionABiomeRequirement(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if ((int)biomeRequirement == 0)
		{
			return true;
		}
		if ((Object)(object)TerrainMeta.BiomeMap != (Object)null)
		{
			int biomeMaxType = TerrainMeta.BiomeMap.GetBiomeMaxType(position);
			if ((BiomeRequirement() & biomeMaxType) != 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsAcceptableWaterDepth(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return WaterLevel.GetOverallWaterDepth(pos, waves: true, volumes: false) <= MaxWaterDepth;
	}

	public void SetBrakingEnabled(bool flag)
	{
		Agent.autoBraking = flag;
	}

	public static int GetNavMeshAgentID(string name)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < NavMesh.GetSettingsCount(); i++)
		{
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(i);
			if (name == NavMesh.GetSettingsNameFromID(((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID))
			{
				return ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
			}
		}
		return -1;
	}
}


public enum NavigationType
{
	None,
	NavMesh,
	AStar,
	Custom,
	Base
}


public enum NavigationSpeed
{
	Slowest,
	Slow,
	Normal,
	Fast
}


protected enum OverrideFacingDirectionMode
{
	None,
	Direction,
	Entity
}


using System.Collections;
using Unity.Mathematics;
using UnityEngine;

public class FishSwarm : MonoBehaviour
{
	public FishShoal.FishType[] fishTypes;

	public FishShoal[] fishShoals;

	private void Awake()
	{
		fishShoals = new FishShoal[fishTypes.Length];
		for (int i = 0; i < fishTypes.Length; i++)
		{
			fishShoals[i] = new FishShoal(fishTypes[i]);
		}
		((MonoBehaviour)this).StartCoroutine(SpawnFish());
	}

	private IEnumerator SpawnFish()
	{
		while (true)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			if (Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) && Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
			{
				FishShoal[] array = fishShoals;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].TrySpawn(float3.op_Implicit(((Component)this).transform.position));
					yield return CoroutineEx.waitForEndOfFrame;
				}
			}
		}
	}

	private void Update()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		FishShoal[] array = fishShoals;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnUpdate(float3.op_Implicit(((Component)this).transform.position));
		}
	}

	private void LateUpdate()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		FishShoal[] array = fishShoals;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnLateUpdate(float3.op_Implicit(((Component)this).transform.position));
		}
	}

	private void OnDestroy()
	{
		FishShoal[] array = fishShoals;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Dispose();
		}
	}

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.DrawWireSphere(((Component)this).transform.position, 15f);
		Gizmos.DrawWireSphere(((Component)this).transform.position, 40f);
		if (Application.isPlaying)
		{
			FishShoal[] array = fishShoals;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnDrawGizmosSelected();
			}
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Rendering;

public class FishShoal : IDisposable
{
	[Serializable]
	public struct FishType
	{
		public Mesh mesh;

		public Material material;

		public int castsPerFrame;

		public int maxCount;

		public float minSpeed;

		public float maxSpeed;

		public float idealDepth;

		public float minTurnSpeed;

		public float maxTurnSpeed;

		public float minScale;

		public float maxScale;
	}

	public struct FishData
	{
		public bool isAlive;

		public float updateTime;

		public float startleTime;

		public float spawnX;

		public float spawnZ;

		public float destinationX;

		public float destinationZ;

		public float directionX;

		public float directionZ;

		public float speed;

		public float scale;
	}

	public struct FishRenderData
	{
		public float3 position;

		public float rotation;

		public float scale;

		public float distance;

		public float seed;
	}

	public struct FishCollisionGatherJob : IJob
	{
		public int layerMask;

		public uint seed;

		public int castCount;

		public int fishCount;

		public NativeArray<RaycastCommand> castCommands;

		public NativeArray<FishData> fishDataArray;

		public NativeArray<FishRenderData> fishRenderDataArray;

		public NativeArray<int> fishCastIndices;

		public void Execute()
		{
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			Random val = default(Random);
			((Random)(ref val))..ctor(seed);
			int length = castCommands.Length;
			for (int i = 0; i < length; i++)
			{
				RaycastCommand val3;
				if (i >= castCount)
				{
					val3 = (castCommands[i] = default(RaycastCommand));
					continue;
				}
				int num = ((Random)(ref val)).NextInt(0, fishCount);
				FishData fishData = fishDataArray[num];
				FishRenderData fishRenderData = fishRenderDataArray[num];
				ref NativeArray<RaycastCommand> reference = ref castCommands;
				int num2 = i;
				val3 = default(RaycastCommand);
				((RaycastCommand)(ref val3)).from = float3.op_Implicit(fishRenderData.position);
				((RaycastCommand)(ref val3)).direction = float3.op_Implicit(new float3(fishData.directionX, 0f, fishData.directionZ));
				((RaycastCommand)(ref val3)).distance = 4f;
				((RaycastCommand)(ref val3)).layerMask = layerMask;
				((RaycastCommand)(ref val3)).maxHits = 1;
				reference[num2] = val3;
				fishCastIndices[i] = num;
			}
		}
	}

	public struct FishCollisionProcessJob : IJob
	{
		public int castCount;

		public NativeArray<FishData> fishDataArray;

		[ReadOnly]
		public NativeArray<RaycastHit> castResults;

		[ReadOnly]
		public NativeArray<int> fishCastIndices;

		[ReadOnly]
		public NativeArray<FishRenderData> fishRenderDataArray;

		public void Execute()
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < castCount; i++)
			{
				RaycastHit val = castResults[i];
				if (((RaycastHit)(ref val)).normal != default(Vector3))
				{
					int num = fishCastIndices[i];
					FishData fishData = fishDataArray[num];
					if (fishData.startleTime <= 0f)
					{
						FishRenderData fishRenderData = fishRenderDataArray[num];
						float2 xz = ((float3)(ref fishRenderData.position)).xz;
						val = castResults[i];
						float x = ((RaycastHit)(ref val)).point.x;
						val = castResults[i];
						float2 val2 = math.normalize(new float2(x, ((RaycastHit)(ref val)).point.z) - xz);
						float2 val3 = xz - val2 * 8f;
						fishData.destinationX = val3.x;
						fishData.destinationZ = val3.y;
						fishData.startleTime = 2f;
						fishData.updateTime = 6f;
						fishDataArray[num] = fishData;
					}
				}
			}
		}
	}

	public struct FishUpdateJob : IJobParallelFor
	{
		[ReadOnly]
		public float3 cameraPosition;

		[ReadOnly]
		public uint seed;

		[ReadOnly]
		public float dt;

		[ReadOnly]
		public float minSpeed;

		[ReadOnly]
		public float maxSpeed;

		[ReadOnly]
		public float minTurnSpeed;

		[ReadOnly]
		public float maxTurnSpeed;

		[ReadOnly]
		public float minDepth;

		[NativeDisableUnsafePtrRestriction]
		public unsafe FishData* fishDataArray;

		[NativeDisableUnsafePtrRestriction]
		public unsafe FishRenderData* fishRenderDataArray;

		public unsafe void Execute(int i)
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_011b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_017c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0181: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_018d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0194: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_0206: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0226: Unknown result type (might be due to invalid IL or missing references)
			//IL_022b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0233: Unknown result type (might be due to invalid IL or missing references)
			//IL_023e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0243: Unknown result type (might be due to invalid IL or missing references)
			//IL_0248: Unknown result type (might be due to invalid IL or missing references)
			FishData* ptr = fishDataArray + i;
			FishRenderData* ptr2 = fishRenderDataArray + i;
			Random random = default(Random);
			((Random)(ref random))..ctor((uint)(i * 3245 + seed));
			float num = math.distancesq(cameraPosition, ptr2->position);
			bool flag = ptr->startleTime > 0f;
			if (num > math.pow(40f, 2f) || ((float3)(&ptr2->position)).y > minDepth)
			{
				ptr->isAlive = false;
				return;
			}
			if (!flag && num < 100f)
			{
				ptr->startleTime = 2f;
				flag = true;
			}
			float3 val = default(float3);
			((float3)(ref val))..ctor(ptr->destinationX, ((float3)(&ptr2->position)).y, ptr->destinationZ);
			if (ptr->updateTime >= 8f || math.distancesq(val, ptr2->position) < 1f)
			{
				float3 target = GetTarget(new float3(ptr->spawnX, 0f, ptr->spawnZ), ref random);
				ptr->updateTime = 0f;
				ptr->destinationX = target.x;
				ptr->destinationZ = target.z;
			}
			ptr2->scale = math.lerp(ptr2->scale, ptr->scale, dt * 5f);
			ptr->speed = math.lerp(ptr->speed, flag ? maxSpeed : minSpeed, dt * 4f);
			float3 val2 = math.normalize(val - ptr2->position);
			float a = math.atan2(val2.z, val2.x);
			ptr2->rotation = 0f - ptr2->rotation + MathF.PI / 2f;
			float num2 = (flag ? maxTurnSpeed : minTurnSpeed);
			ptr2->rotation = LerpAngle(ptr2->rotation, a, dt * num2);
			float3 zero = float3.zero;
			math.sincos(ptr2->rotation, ref zero.z, ref zero.x);
			ptr->directionX = zero.x;
			ptr->directionZ = zero.z;
			float3* position = &ptr2->position;
			Unsafe.Write(position, *position + zero * ptr->speed * dt);
			ptr2->rotation = 0f - ptr2->rotation + MathF.PI / 2f;
			ptr2->distance += ptr->speed * dt;
			ptr->updateTime += dt;
			ptr->startleTime -= dt;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static float LerpAngle(float a0, float a1, float t)
		{
			float num = a1 - a0;
			num = math.clamp(num - math.floor(num / (MathF.PI * 2f)) * (MathF.PI * 2f), 0f, MathF.PI * 2f);
			return math.lerp(a0, a0 + ((num > MathF.PI) ? (num - MathF.PI * 2f) : num), t);
		}
	}

	public struct KillFish : IJob
	{
		public NativeArray<FishData> fishDataArray;

		public NativeArray<FishRenderData> fishRenderDataArray;

		public NativeArray<int> fishCount;

		public void Execute()
		{
			int num = fishCount[0];
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				if (!fishDataArray[num2].isAlive)
				{
					if (num2 < num - 1)
					{
						fishDataArray[num2] = fishDataArray[num - 1];
						fishRenderDataArray[num2] = fishRenderDataArray[num - 1];
					}
					num--;
				}
			}
			fishCount[0] = num;
		}
	}

	private const float maxFishDistance = 40f;

	private FishType fishType;

	private JobHandle jobHandle;

	private NativeArray<RaycastCommand> castCommands;

	private NativeArray<RaycastHit> castResults;

	private NativeArray<int> fishCastIndices;

	private NativeArray<FishData> fishData;

	private NativeArray<FishRenderData> fishRenderData;

	private NativeArray<int> fishCount;

	private MaterialPropertyBlock materialPropertyBlock;

	private ComputeBuffer fishBuffer;

	public FishShoal(FishType fishType)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Expected O, but got Unknown
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Expected O, but got Unknown
		this.fishType = fishType;
		castCommands = new NativeArray<RaycastCommand>(fishType.castsPerFrame, (Allocator)4, (NativeArrayOptions)1);
		castResults = new NativeArray<RaycastHit>(fishType.castsPerFrame, (Allocator)4, (NativeArrayOptions)1);
		fishCastIndices = new NativeArray<int>(fishType.castsPerFrame, (Allocator)4, (NativeArrayOptions)1);
		fishData = new NativeArray<FishData>(fishType.maxCount, (Allocator)4, (NativeArrayOptions)1);
		fishRenderData = new NativeArray<FishRenderData>(fishType.maxCount, (Allocator)4, (NativeArrayOptions)1);
		fishCount = new NativeArray<int>(1, (Allocator)4, (NativeArrayOptions)1);
		fishBuffer = new ComputeBuffer(fishType.maxCount, UnsafeUtility.SizeOf<FishRenderData>());
		materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.SetBuffer("_FishData", fishBuffer);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static float3 GetTarget(float3 spawnPos, ref Random random)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		float2 val = ((Random)(ref random)).NextFloat2Direction();
		return spawnPos + new float3(val.x, 0f, val.y) * ((Random)(ref random)).NextFloat(10f, 15f);
	}

	private int GetPopulationScaleForPoint(float3 cameraPosition)
	{
		return 1;
	}

	public void TrySpawn(float3 cameraPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(float3.op_Implicit(cameraPosition), waves: false, volumes: false);
		float item = waterAndTerrainSurface.Item1;
		float item2 = waterAndTerrainSurface.Item2;
		item -= 3f;
		if (math.abs(item - item2) < 4f || item < item2)
		{
			return;
		}
		int num = fishCount[0];
		int num2 = Mathf.Min(Mathf.CeilToInt((float)(fishType.maxCount * GetPopulationScaleForPoint(cameraPosition))) - num, 5);
		if (num2 <= 0)
		{
			return;
		}
		uint num3 = (uint)(Time.frameCount + fishType.mesh.vertexCount);
		int num4 = fishCount[0];
		int num5 = math.min(num4 + num2, fishType.maxCount);
		Random random = default(Random);
		for (int i = num4; i < num5; i++)
		{
			((Random)(ref random))..ctor((uint)(i * 3245 + num3));
			float3 val = cameraPosition + ((Random)(ref random)).NextFloat3Direction() * ((Random)(ref random)).NextFloat(40f);
			val.y = ((Random)(ref random)).NextFloat(math.max(item2 + 1f, cameraPosition.y - 30f), math.min(item, cameraPosition.y + 30f));
			if (!((Object)(object)WaterSystem.Instance == (Object)null) && WaterLevel.Test(float3.op_Implicit(val), waves: false, volumes: false) && !(TerrainMeta.HeightMap.GetHeight(float3.op_Implicit(val)) > val.y) && !EnvironmentManager.Check(float3.op_Implicit(val), EnvironmentType.UnderwaterLab, 30f))
			{
				float3 target = GetTarget(val, ref random);
				float3 val2 = math.normalize(target - val);
				fishData[num] = new FishData
				{
					isAlive = true,
					spawnX = val.x,
					spawnZ = val.z,
					destinationX = target.x,
					destinationZ = target.z,
					scale = ((Random)(ref random)).NextFloat(fishType.minScale, fishType.maxScale)
				};
				fishRenderData[num] = new FishRenderData
				{
					position = val,
					rotation = math.atan2(val2.z, val2.x),
					scale = 0f,
					seed = ((Random)(ref random)).NextFloat(0f, 2f)
				};
				num++;
			}
		}
		fishCount[0] = num;
	}

	public void OnUpdate(float3 cameraPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		UpdateJobs(cameraPosition);
	}

	private unsafe void UpdateJobs(float3 cameraPosition)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		((JobHandle)(ref jobHandle)).Complete();
		int num = fishCount[0];
		if (num != 0)
		{
			float item = WaterLevel.GetWaterAndTerrainSurface(float3.op_Implicit(cameraPosition), waves: false, volumes: false).Item1;
			item -= 3f;
			int castCount = math.min(fishType.castsPerFrame, num);
			uint seed = (uint)(Time.frameCount + fishType.mesh.vertexCount);
			FishCollisionGatherJob fishCollisionGatherJob = default(FishCollisionGatherJob);
			fishCollisionGatherJob.layerMask = -1;
			fishCollisionGatherJob.seed = seed;
			fishCollisionGatherJob.castCount = castCount;
			fishCollisionGatherJob.fishCount = num;
			fishCollisionGatherJob.castCommands = castCommands;
			fishCollisionGatherJob.fishCastIndices = fishCastIndices;
			fishCollisionGatherJob.fishDataArray = fishData;
			fishCollisionGatherJob.fishRenderDataArray = fishRenderData;
			FishCollisionGatherJob fishCollisionGatherJob2 = fishCollisionGatherJob;
			FishCollisionProcessJob fishCollisionProcessJob = default(FishCollisionProcessJob);
			fishCollisionProcessJob.castCount = castCount;
			fishCollisionProcessJob.castResults = castResults;
			fishCollisionProcessJob.fishCastIndices = fishCastIndices;
			fishCollisionProcessJob.fishDataArray = fishData;
			fishCollisionProcessJob.fishRenderDataArray = fishRenderData;
			FishCollisionProcessJob fishCollisionProcessJob2 = fishCollisionProcessJob;
			FishUpdateJob fishUpdateJob = default(FishUpdateJob);
			fishUpdateJob.cameraPosition = cameraPosition;
			fishUpdateJob.seed = seed;
			fishUpdateJob.dt = Time.deltaTime;
			fishUpdateJob.minSpeed = fishType.minSpeed;
			fishUpdateJob.maxSpeed = fishType.maxSpeed;
			fishUpdateJob.minTurnSpeed = fishType.minTurnSpeed;
			fishUpdateJob.maxTurnSpeed = fishType.maxTurnSpeed;
			fishUpdateJob.fishDataArray = (FishData*)NativeArrayUnsafeUtility.GetUnsafePtr<FishData>(fishData);
			fishUpdateJob.fishRenderDataArray = (FishRenderData*)NativeArrayUnsafeUtility.GetUnsafePtr<FishRenderData>(fishRenderData);
			fishUpdateJob.minDepth = item - 3f;
			FishUpdateJob fishUpdateJob2 = fishUpdateJob;
			KillFish killFish = default(KillFish);
			killFish.fishCount = fishCount;
			killFish.fishDataArray = fishData;
			killFish.fishRenderDataArray = fishRenderData;
			KillFish killFish2 = killFish;
			jobHandle = IJobExtensions.Schedule<FishCollisionGatherJob>(fishCollisionGatherJob2, default(JobHandle));
			jobHandle = RaycastCommand.ScheduleBatch(castCommands, castResults, 5, jobHandle);
			jobHandle = IJobExtensions.Schedule<FishCollisionProcessJob>(fishCollisionProcessJob2, jobHandle);
			jobHandle = IJobParallelForExtensions.Schedule<FishUpdateJob>(fishUpdateJob2, num, 10, jobHandle);
			jobHandle = IJobExtensions.Schedule<KillFish>(killFish2, jobHandle);
		}
	}

	public void OnLateUpdate(float3 cameraPosition)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		((JobHandle)(ref jobHandle)).Complete();
		if (fishCount[0] != 0)
		{
			Bounds val = default(Bounds);
			((Bounds)(ref val))..ctor(float3.op_Implicit(cameraPosition), Vector3.one * 40f);
			fishBuffer.SetData<FishRenderData>(fishRenderData);
			Graphics.DrawMeshInstancedProcedural(fishType.mesh, 0, fishType.material, val, fishCount[0], materialPropertyBlock, (ShadowCastingMode)1, true, 0, (Camera)null, (LightProbeUsage)1, (LightProbeProxyVolume)null);
		}
	}

	public void Dispose()
	{
		((JobHandle)(ref jobHandle)).Complete();
		castCommands.Dispose();
		castResults.Dispose();
		fishCastIndices.Dispose();
		fishData.Dispose();
		fishRenderData.Dispose();
		fishCount.Dispose();
		fishBuffer.Dispose();
	}

	public void OnDrawGizmosSelected()
	{
		((JobHandle)(ref jobHandle)).Complete();
		_ = fishCount[0];
	}
}


using System;
using UnityEngine;

[Serializable]
public struct FishType
{
	public Mesh mesh;

	public Material material;

	public int castsPerFrame;

	public int maxCount;

	public float minSpeed;

	public float maxSpeed;

	public float idealDepth;

	public float minTurnSpeed;

	public float maxTurnSpeed;

	public float minScale;

	public float maxScale;
}


public struct FishData
{
	public bool isAlive;

	public float updateTime;

	public float startleTime;

	public float spawnX;

	public float spawnZ;

	public float destinationX;

	public float destinationZ;

	public float directionX;

	public float directionZ;

	public float speed;

	public float scale;
}


using Unity.Mathematics;

public struct FishRenderData
{
	public float3 position;

	public float rotation;

	public float scale;

	public float distance;

	public float seed;
}


using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public struct FishCollisionGatherJob : IJob
{
	public int layerMask;

	public uint seed;

	public int castCount;

	public int fishCount;

	public NativeArray<RaycastCommand> castCommands;

	public NativeArray<FishData> fishDataArray;

	public NativeArray<FishRenderData> fishRenderDataArray;

	public NativeArray<int> fishCastIndices;

	public void Execute()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Random val = default(Random);
		((Random)(ref val))..ctor(seed);
		int length = castCommands.Length;
		for (int i = 0; i < length; i++)
		{
			RaycastCommand val3;
			if (i >= castCount)
			{
				val3 = (castCommands[i] = default(RaycastCommand));
				continue;
			}
			int num = ((Random)(ref val)).NextInt(0, fishCount);
			FishData fishData = fishDataArray[num];
			FishRenderData fishRenderData = fishRenderDataArray[num];
			ref NativeArray<RaycastCommand> reference = ref castCommands;
			int num2 = i;
			val3 = default(RaycastCommand);
			((RaycastCommand)(ref val3)).from = float3.op_Implicit(fishRenderData.position);
			((RaycastCommand)(ref val3)).direction = float3.op_Implicit(new float3(fishData.directionX, 0f, fishData.directionZ));
			((RaycastCommand)(ref val3)).distance = 4f;
			((RaycastCommand)(ref val3)).layerMask = layerMask;
			((RaycastCommand)(ref val3)).maxHits = 1;
			reference[num2] = val3;
			fishCastIndices[i] = num;
		}
	}
}


using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public struct FishCollisionProcessJob : IJob
{
	public int castCount;

	public NativeArray<FishData> fishDataArray;

	[ReadOnly]
	public NativeArray<RaycastHit> castResults;

	[ReadOnly]
	public NativeArray<int> fishCastIndices;

	[ReadOnly]
	public NativeArray<FishRenderData> fishRenderDataArray;

	public void Execute()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < castCount; i++)
		{
			RaycastHit val = castResults[i];
			if (((RaycastHit)(ref val)).normal != default(Vector3))
			{
				int num = fishCastIndices[i];
				FishData fishData = fishDataArray[num];
				if (fishData.startleTime <= 0f)
				{
					FishRenderData fishRenderData = fishRenderDataArray[num];
					float2 xz = ((float3)(ref fishRenderData.position)).xz;
					val = castResults[i];
					float x = ((RaycastHit)(ref val)).point.x;
					val = castResults[i];
					float2 val2 = math.normalize(new float2(x, ((RaycastHit)(ref val)).point.z) - xz);
					float2 val3 = xz - val2 * 8f;
					fishData.destinationX = val3.x;
					fishData.destinationZ = val3.y;
					fishData.startleTime = 2f;
					fishData.updateTime = 6f;
					fishDataArray[num] = fishData;
				}
			}
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;

public struct FishUpdateJob : IJobParallelFor
{
	[ReadOnly]
	public float3 cameraPosition;

	[ReadOnly]
	public uint seed;

	[ReadOnly]
	public float dt;

	[ReadOnly]
	public float minSpeed;

	[ReadOnly]
	public float maxSpeed;

	[ReadOnly]
	public float minTurnSpeed;

	[ReadOnly]
	public float maxTurnSpeed;

	[ReadOnly]
	public float minDepth;

	[NativeDisableUnsafePtrRestriction]
	public unsafe FishData* fishDataArray;

	[NativeDisableUnsafePtrRestriction]
	public unsafe FishRenderData* fishRenderDataArray;

	public unsafe void Execute(int i)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		FishData* ptr = fishDataArray + i;
		FishRenderData* ptr2 = fishRenderDataArray + i;
		Random random = default(Random);
		((Random)(ref random))..ctor((uint)(i * 3245 + seed));
		float num = math.distancesq(cameraPosition, ptr2->position);
		bool flag = ptr->startleTime > 0f;
		if (num > math.pow(40f, 2f) || ((float3)(&ptr2->position)).y > minDepth)
		{
			ptr->isAlive = false;
			return;
		}
		if (!flag && num < 100f)
		{
			ptr->startleTime = 2f;
			flag = true;
		}
		float3 val = default(float3);
		((float3)(ref val))..ctor(ptr->destinationX, ((float3)(&ptr2->position)).y, ptr->destinationZ);
		if (ptr->updateTime >= 8f || math.distancesq(val, ptr2->position) < 1f)
		{
			float3 target = GetTarget(new float3(ptr->spawnX, 0f, ptr->spawnZ), ref random);
			ptr->updateTime = 0f;
			ptr->destinationX = target.x;
			ptr->destinationZ = target.z;
		}
		ptr2->scale = math.lerp(ptr2->scale, ptr->scale, dt * 5f);
		ptr->speed = math.lerp(ptr->speed, flag ? maxSpeed : minSpeed, dt * 4f);
		float3 val2 = math.normalize(val - ptr2->position);
		float a = math.atan2(val2.z, val2.x);
		ptr2->rotation = 0f - ptr2->rotation + MathF.PI / 2f;
		float num2 = (flag ? maxTurnSpeed : minTurnSpeed);
		ptr2->rotation = LerpAngle(ptr2->rotation, a, dt * num2);
		float3 zero = float3.zero;
		math.sincos(ptr2->rotation, ref zero.z, ref zero.x);
		ptr->directionX = zero.x;
		ptr->directionZ = zero.z;
		float3* position = &ptr2->position;
		Unsafe.Write(position, *position + zero * ptr->speed * dt);
		ptr2->rotation = 0f - ptr2->rotation + MathF.PI / 2f;
		ptr2->distance += ptr->speed * dt;
		ptr->updateTime += dt;
		ptr->startleTime -= dt;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static float LerpAngle(float a0, float a1, float t)
	{
		float num = a1 - a0;
		num = math.clamp(num - math.floor(num / (MathF.PI * 2f)) * (MathF.PI * 2f), 0f, MathF.PI * 2f);
		return math.lerp(a0, a0 + ((num > MathF.PI) ? (num - MathF.PI * 2f) : num), t);
	}
}


using Unity.Collections;
using Unity.Jobs;

public struct KillFish : IJob
{
	public NativeArray<FishData> fishDataArray;

	public NativeArray<FishRenderData> fishRenderDataArray;

	public NativeArray<int> fishCount;

	public void Execute()
	{
		int num = fishCount[0];
		for (int num2 = num - 1; num2 >= 0; num2--)
		{
			if (!fishDataArray[num2].isAlive)
			{
				if (num2 < num - 1)
				{
					fishDataArray[num2] = fishDataArray[num - 1];
					fishRenderDataArray[num2] = fishRenderDataArray[num - 1];
				}
				num--;
			}
		}
		fishCount[0] = num;
	}
}


using UnityEngine;
using UnityEngine.AI;

public class FishNavigator : BaseNavigator
{
	public BaseNpc NPC { get; private set; }

	public override void Init(BaseCombatEntity entity, NavMeshAgent agent)
	{
		base.Init(entity, agent);
		NPC = entity as BaseNpc;
	}

	protected override bool SetCustomDestination(Vector3 pos, float speedFraction = 1f, float updateInterval = 0f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!base.SetCustomDestination(pos, speedFraction, updateInterval))
		{
			return false;
		}
		base.Destination = pos;
		return true;
	}

	protected override void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.position = Vector3.MoveTowards(((Component)this).transform.position, moveToPosition, GetTargetSpeed() * delta);
		base.BaseEntity.ServerPosition = ((Component)this).transform.localPosition;
		if (ReachedPosition(moveToPosition))
		{
			Stop();
		}
		else
		{
			UpdateRotation(moveToPosition, delta);
		}
	}

	private void UpdateRotation(Vector3 moveToPosition, float delta)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		base.BaseEntity.ServerRotation = Quaternion.LookRotation(Vector3Ex.Direction(moveToPosition, ((Component)this).transform.position));
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Spatial;
using UnityEngine;

public class NpcFireManager : SingletonComponent<NpcFireManager>, IServerComponent
{
	private const float maxFireMeleeAge = 1f;

	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private Grid<BaseEntity> fireGrid = new Grid<BaseEntity>(32, 8096f);

	private Dictionary<BaseEntity, double> recentFireMeleeEvents = new Dictionary<BaseEntity, double>();

	private double nextTickTime;

	public void Add(BaseEntity entity)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		fireGrid.Add(entity, ((Component)entity).transform.position.x, ((Component)entity).transform.position.z);
	}

	public void Move(BaseEntity entity)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFireManager.Move", 0);
		try
		{
			if (IsOnFire(entity))
			{
				Vector3 position = ((Component)entity).transform.position;
				fireGrid.Move(entity, position.x, position.z);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Remove(BaseEntity entity)
	{
		fireGrid.Remove(entity);
	}

	public void GetFiresAround(Vector3 position, float range, List<BaseEntity> results)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFireManager.GetFiresAround", 0);
		try
		{
			if (fireGrid == null)
			{
				return;
			}
			fireGrid.Query<BaseEntity>(position.x, position.z, range, results);
			for (int num = results.Count - 1; num >= 0; num--)
			{
				if (!results[num].IsValid())
				{
					if (AI.logIssues)
					{
						Debug.LogWarning((object)$"Removed null fire from results list near {position}, this is unusual as fires should be removed from the grid when destroyed.");
					}
					results.RemoveAt(num);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnReceivedSignalServer(BaseEntity entity, BaseEntity.Signal signal, string arg)
	{
		if (signal != 0)
		{
			return;
		}
		if (entity is HeldEntity heldEntity && IsOnFire(heldEntity))
		{
			BasePlayer ownerPlayer = heldEntity.GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				recentFireMeleeEvents[ownerPlayer] = Time.timeAsDouble;
			}
		}
		if (entity is BasePlayer basePlayer && IsOnFire(basePlayer.GetHeldEntity()) && (Object)(object)entity != (Object)null)
		{
			recentFireMeleeEvents[entity] = Time.timeAsDouble;
		}
	}

	public bool DidMeleeWithFireRecently(BaseEntity querier, BaseEntity target, out double meleeTime, float maxDistance = 10f)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFireManager.DidMeleeWithFireRecently", 0);
		try
		{
			if (recentFireMeleeEvents.TryGetValue(target, out var value) && Vector3.Distance(((Component)querier).transform.position, ((Component)target).transform.position) <= maxDistance)
			{
				meleeTime = value;
				return true;
			}
			meleeTime = 0.0;
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsOnFire(BaseEntity entity)
	{
		if (!entity.IsValid())
		{
			return false;
		}
		if (entity.IsOnFire())
		{
			return true;
		}
		if (entity is BaseOven baseOven && baseOven.IsOn() && baseOven.hasOpenFlame)
		{
			return true;
		}
		return false;
	}

	public void Tick()
	{
		if (Time.timeAsDouble < nextTickTime)
		{
			return;
		}
		nextTickTime = Time.timeAsDouble + (double)Random.Range(4f, 6f);
		TimeWarning val = TimeWarning.New("NpcFireManager.RemoveStaleEntries", 0);
		try
		{
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				foreach (var (baseEntity2, num2) in recentFireMeleeEvents)
				{
					if (!baseEntity2.IsValid() || Time.timeAsDouble - num2 > 1.0)
					{
						((List<BaseEntity>)(object)val2).Add(baseEntity2);
					}
				}
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					recentFireMeleeEvents.Remove(item);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Spatial;
using UnityEngine;

public class NpcFoodManager : SingletonComponent<NpcFoodManager>, IServerComponent
{
	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private Grid<BaseEntity> foodGrid = new Grid<BaseEntity>(32, 8096f);

	public bool Add(BaseEntity food)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (!IsFood(food))
		{
			return false;
		}
		if (!foodGrid.AddUnique(food, ((Component)food).transform.position.x, ((Component)food).transform.position.z))
		{
			if (AI.logIssues)
			{
				Debug.LogWarning((object)$"Failed to add food to grid: {food.ShortPrefabName}_{food.net.ID}");
			}
			return false;
		}
		return true;
	}

	public void Move(BaseEntity food)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFoodManager.Move", 0);
		try
		{
			if (IsFood(food))
			{
				Vector3 position = ((Component)food).transform.position;
				foodGrid.Move(food, position.x, position.z);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool Contains(BaseEntity food)
	{
		if (!IsFood(food))
		{
			return false;
		}
		return foodGrid.Contains(food);
	}

	public bool Remove(BaseEntity food)
	{
		if (!IsFood(food))
		{
			return false;
		}
		if (!foodGrid.Remove(food))
		{
			return false;
		}
		return true;
	}

	public void GetFoodAround(Vector3 position, float range, List<BaseEntity> results)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFoodManager.GetFoodAround", 0);
		try
		{
			if (foodGrid != null)
			{
				foodGrid.Query<BaseEntity>(position.x, position.z, range, results);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsFood(BaseEntity entity)
	{
		if (entity is DroppedItem droppedItem)
		{
			if (droppedItem.item == null)
			{
				return false;
			}
			return droppedItem.item.info.Traits.HasFlag(BaseEntity.TraitFlag.Meat);
		}
		return entity is BaseCorpse;
	}

	public static bool IsFoodImmobile(BaseEntity entity)
	{
		if (entity is DroppedItem { IsSleeping: not false })
		{
			return true;
		}
		if (entity is BaseCorpse { IsSleeping: not false })
		{
			return true;
		}
		return false;
	}
}


public enum NpcNoiseIntensity
{
	None,
	Low,
	Medium,
	High
}


using Facepunch;
using UnityEngine;

public class NpcNoiseEvent : IPooled
{
	public BaseEntity Initiator;

	public Vector3 Position;

	public NpcNoiseIntensity Intensity;

	public double EventTime;

	public void EnterPool()
	{
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using Facepunch;
using Spatial;
using UnityEngine;

public class NpcNoiseManager : SingletonComponent<NpcNoiseManager>, IServerComponent
{
	private const float voiceChatEventMaxAge = 1f;

	private const float noiseMaxAge = 10f;

	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private ConcurrentDictionary<BasePlayer, double> recentVoiceChatEvents = new ConcurrentDictionary<BasePlayer, double>();

	private Grid<NpcNoiseEvent> noiseGrid = new Grid<NpcNoiseEvent>(32, 8096f);

	private Queue<NpcNoiseEvent> noises = new Queue<NpcNoiseEvent>();

	private double nextTickTime;

	public void AddNoise(BaseEntity initiator, Vector3 position, NpcNoiseIntensity intensity)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (!((FacepunchBehaviour)this).IsInvoking((Action)RemoveOldNoises))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)RemoveOldNoises, 0f, 0f);
		}
		NpcNoiseEvent npcNoiseEvent = Pool.Get<NpcNoiseEvent>();
		npcNoiseEvent.Initiator = initiator;
		npcNoiseEvent.Position = position;
		npcNoiseEvent.Intensity = intensity;
		npcNoiseEvent.EventTime = Time.timeAsDouble;
		noiseGrid.Add(npcNoiseEvent, npcNoiseEvent.Position.x, npcNoiseEvent.Position.z);
		noises.Enqueue(npcNoiseEvent);
	}

	private void RemoveOldNoises()
	{
		TimeWarning val = TimeWarning.New("RemoveOldNoises", 0);
		try
		{
			while (noises.Count > 0)
			{
				NpcNoiseEvent npcNoiseEvent = noises.Peek();
				if (Time.timeAsDouble - npcNoiseEvent.EventTime <= 10.0)
				{
					break;
				}
				noises.Dequeue();
				noiseGrid.Remove(npcNoiseEvent);
				Pool.Free<NpcNoiseEvent>(ref npcNoiseEvent);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetNoisesAround(Vector3 position, float range, List<NpcNoiseEvent> results)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (noiseGrid != null)
		{
			noiseGrid.Query<NpcNoiseEvent>(position.x, position.z, range, results);
		}
	}

	public void OnServerProjectileHit(BaseEntity entity, ServerProjectile projectile, RaycastHit hit)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		AddNoise(entity, ((Component)projectile).transform.position, NpcNoiseIntensity.High);
	}

	public void OnProjectileHit(BaseEntity entity, HitInfo hit)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		AddNoise(entity, hit.HitPositionWorld, (hit.Weapon is BowWeapon || hit.Weapon is BaseMelee) ? NpcNoiseIntensity.Medium : NpcNoiseIntensity.High);
	}

	public void OnWeaponShot(BasePlayer player, BaseProjectile weapon)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		AddNoise(player, ((Component)player).transform.position, (weapon is BowWeapon) ? NpcNoiseIntensity.Low : NpcNoiseIntensity.High);
	}

	public void OnWeaponThrown(BasePlayer player, BaseMelee weapon, bool canAiHearIt)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (canAiHearIt)
		{
			AddNoise(player, ((Component)player).transform.position, NpcNoiseIntensity.Low);
		}
	}

	public void OnVoiceChat(BasePlayer player)
	{
		recentVoiceChatEvents[player] = Time.timeAsDouble;
	}

	public void OnMeleeHit(BaseMelee weapon, HitInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = weapon.GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			AddNoise(ownerPlayer, ((Component)ownerPlayer).transform.position, NpcNoiseIntensity.Medium);
		}
	}

	public bool HasPlayerSpokenNear(BaseEntity querier, BasePlayer targetPlayer, float maxDistance = 16f)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcNoiseManager.HasPlayerSpokenNear", 0);
		try
		{
			double value;
			return recentVoiceChatEvents.TryGetValue(targetPlayer, out value) && Vector3.Distance(((Component)querier).transform.position, ((Component)targetPlayer).transform.position) <= maxDistance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Tick()
	{
		if (Time.timeAsDouble < nextTickTime)
		{
			return;
		}
		nextTickTime = Time.timeAsDouble + (double)Random.Range(4f, 6f);
		TimeWarning val = TimeWarning.New("NpcNoiseManager.RemoveStaleEntries", 0);
		try
		{
			PooledList<BasePlayer> val2 = Pool.Get<PooledList<BasePlayer>>();
			try
			{
				double value;
				foreach (KeyValuePair<BasePlayer, double> recentVoiceChatEvent in recentVoiceChatEvents)
				{
					recentVoiceChatEvent.Deconstruct(out var key, out value);
					BasePlayer basePlayer = key;
					double num = value;
					if (!basePlayer.IsValid() || Time.timeAsDouble - num > 1.0)
					{
						((List<BasePlayer>)(object)val2).Add(basePlayer);
					}
				}
				foreach (BasePlayer item in (List<BasePlayer>)(object)val2)
				{
					recentVoiceChatEvents.Remove(item, out value);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Rust;
using Rust.Ai;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class DungeonNavmesh : FacepunchBehaviour, IServerComponent
{
	public int NavMeshAgentTypeIndex;

	[Tooltip("The default area associated with the NavMeshAgent index.")]
	public string DefaultAreaName = "HumanNPC";

	public float NavmeshResolutionModifier = 1.25f;

	[Tooltip("Bounds which are auto calculated from CellSize * CellCount")]
	public Bounds Bounds;

	public NavMeshData NavMeshData;

	public NavMeshDataInstance NavMeshDataInstance;

	public LayerMask LayerMask;

	public NavMeshCollectGeometry NavMeshCollectGeometry;

	public static List<DungeonNavmesh> Instances = new List<DungeonNavmesh>();

	[ServerVar]
	public static bool use_baked_terrain_mesh = true;

	private List<NavMeshBuildSource> sources;

	private AsyncOperation BuildingOperation;

	private bool HasBuildOperationStarted;

	private Stopwatch BuildTimer = new Stopwatch();

	private int defaultArea;

	private int agentTypeId;

	public bool IsBuilding
	{
		get
		{
			if (!HasBuildOperationStarted || BuildingOperation != null)
			{
				return true;
			}
			return false;
		}
	}

	public static bool NavReady()
	{
		if (Instances == null || Instances.Count == 0)
		{
			return true;
		}
		foreach (DungeonNavmesh instance in Instances)
		{
			if (instance.IsBuilding)
			{
				return false;
			}
		}
		return true;
	}

	private void OnEnable()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
		agentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		NavMeshData = new NavMeshData(agentTypeId);
		sources = new List<NavMeshBuildSource>();
		defaultArea = NavMesh.GetAreaFromName(DefaultAreaName);
		((FacepunchBehaviour)this).InvokeRepeating((Action)FinishBuildingNavmesh, 0f, 1f);
		Instances.Add(this);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FinishBuildingNavmesh);
			((NavMeshDataInstance)(ref NavMeshDataInstance)).Remove();
			Instances.Remove(this);
		}
	}

	[ContextMenu("Update Monument Nav Mesh")]
	public void UpdateNavMeshAsync()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (!HasBuildOperationStarted && !AiManager.nav_disable && AI.npc_enable)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			Debug.Log((object)("Starting Dungeon Navmesh Build with " + sources.Count + " sources"));
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
			((NavMeshBuildSettings)(ref settingsByIndex)).overrideVoxelSize = true;
			((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize = ((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize * NavmeshResolutionModifier;
			BuildingOperation = NavMeshBuilder.UpdateNavMeshDataAsync(NavMeshData, settingsByIndex, sources, Bounds);
			BuildTimer.Reset();
			BuildTimer.Start();
			HasBuildOperationStarted = true;
			float num = Time.realtimeSinceStartup - realtimeSinceStartup;
			if (num > 0.1f)
			{
				Debug.LogWarning((object)("Calling UpdateNavMesh took " + num));
			}
			NotifyInformationZonesOfCompletion();
		}
	}

	public void NotifyInformationZonesOfCompletion()
	{
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			zone.NavmeshBuildingComplete();
		}
	}

	public void SourcesCollected()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		int count = sources.Count;
		Debug.Log((object)("Source count Pre cull : " + sources.Count));
		Vector3 val = default(Vector3);
		for (int num = sources.Count - 1; num >= 0; num--)
		{
			NavMeshBuildSource item = sources[num];
			Matrix4x4 transform = ((NavMeshBuildSource)(ref item)).transform;
			((Vector3)(ref val))..ctor(((Matrix4x4)(ref transform))[0, 3], ((Matrix4x4)(ref transform))[1, 3], ((Matrix4x4)(ref transform))[2, 3]);
			bool flag = false;
			foreach (AIInformationZone zone in AIInformationZone.zones)
			{
				if (Vector3Ex.Distance2D(zone.ClosestPointTo(val), val) <= 50f)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				sources.Remove(item);
			}
		}
		Debug.Log((object)("Source count post cull : " + sources.Count + " total removed : " + (count - sources.Count)));
	}

	public IEnumerator UpdateNavMeshAndWait(IEnumerable<GameObject> roots)
	{
		if (HasBuildOperationStarted || AiManager.nav_disable || !AI.npc_enable)
		{
			yield break;
		}
		HasBuildOperationStarted = false;
		((Bounds)(ref Bounds)).center = ((Component)this).transform.position;
		((Bounds)(ref Bounds)).size = new Vector3(1000000f, 100000f, 100000f);
		IEnumerator enumerator = NavMeshTools.CollectSourcesAsync(roots, ((LayerMask)(ref LayerMask)).value, NavMeshCollectGeometry, defaultArea, sources, AppendModifierVolumes, UpdateNavMeshAsync);
		if (AiManager.nav_wait)
		{
			yield return enumerator;
			int lastPct = 0;
			while (!HasBuildOperationStarted)
			{
				yield return CoroutineEx.waitForSecondsRealtime(0.25f);
			}
			while (BuildingOperation != null)
			{
				int num = (int)(BuildingOperation.progress * 100f);
				if (lastPct != num)
				{
					Debug.LogFormat("{0}%", new object[1] { num });
					lastPct = num;
				}
				yield return CoroutineEx.waitForSecondsRealtime(0.25f);
				FinishBuildingNavmesh();
			}
		}
		else
		{
			((MonoBehaviour)this).StartCoroutine(enumerator);
			Debug.Log((object)"nav_wait is false, so we're not waiting for the navmesh to finish generating. This might cause your server to sputter while it's generating.");
		}
	}

	private void AppendModifierVolumes(List<NavMeshBuildSource> sources)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		Vector3 size = default(Vector3);
		foreach (NavMeshModifierVolume activeModifier in NavMeshModifierVolume.activeModifiers)
		{
			if ((LayerMask.op_Implicit(LayerMask) & (1 << ((Component)activeModifier).gameObject.layer)) != 0 && activeModifier.AffectsAgentType(agentTypeId))
			{
				Vector3 val = ((Component)activeModifier).transform.TransformPoint(activeModifier.center);
				if (((Bounds)(ref Bounds)).Contains(val))
				{
					Vector3 lossyScale = ((Component)activeModifier).transform.lossyScale;
					((Vector3)(ref size))..ctor(activeModifier.size.x * Mathf.Abs(lossyScale.x), activeModifier.size.y * Mathf.Abs(lossyScale.y), activeModifier.size.z * Mathf.Abs(lossyScale.z));
					NavMeshBuildSource item = default(NavMeshBuildSource);
					((NavMeshBuildSource)(ref item)).shape = (NavMeshBuildSourceShape)5;
					((NavMeshBuildSource)(ref item)).transform = Matrix4x4.TRS(val, ((Component)activeModifier).transform.rotation, Vector3.one);
					((NavMeshBuildSource)(ref item)).size = size;
					((NavMeshBuildSource)(ref item)).area = activeModifier.area;
					sources.Add(item);
				}
			}
		}
	}

	public void FinishBuildingNavmesh()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (BuildingOperation != null && BuildingOperation.isDone)
		{
			if (!((NavMeshDataInstance)(ref NavMeshDataInstance)).valid)
			{
				NavMeshDataInstance = NavMesh.AddNavMeshData(NavMeshData);
			}
			Debug.Log((object)$"Monument Navmesh Build took {BuildTimer.Elapsed.TotalSeconds:0.00} seconds");
			BuildingOperation = null;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using Rust;
using Rust.Ai;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class DynamicNavMesh : SingletonComponent<DynamicNavMesh>, IServerComponent
{
	public int NavMeshAgentTypeIndex;

	[Tooltip("The default area associated with the NavMeshAgent index.")]
	public string DefaultAreaName = "Walkable";

	public int AsyncTerrainNavMeshBakeCellSize = 80;

	public int AsyncTerrainNavMeshBakeCellHeight = 100;

	public Bounds Bounds;

	public NavMeshData NavMeshData;

	public NavMeshDataInstance NavMeshDataInstance;

	public LayerMask LayerMask;

	public NavMeshCollectGeometry NavMeshCollectGeometry;

	[ServerVar]
	public static bool use_baked_terrain_mesh;

	private List<NavMeshBuildSource> sources;

	private AsyncOperation BuildingOperation;

	private bool HasBuildOperationStarted;

	private Stopwatch BuildTimer = new Stopwatch();

	private int defaultArea;

	private int agentTypeId;

	public bool IsBuilding
	{
		get
		{
			if (!HasBuildOperationStarted || BuildingOperation != null)
			{
				return true;
			}
			return false;
		}
	}

	private void OnEnable()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
		agentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		NavMeshData = new NavMeshData(agentTypeId);
		sources = new List<NavMeshBuildSource>();
		defaultArea = NavMesh.GetAreaFromName(DefaultAreaName);
		((FacepunchBehaviour)this).InvokeRepeating((Action)FinishBuildingNavmesh, 0f, 1f);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FinishBuildingNavmesh);
			((NavMeshDataInstance)(ref NavMeshDataInstance)).Remove();
		}
	}

	[ContextMenu("Update Nav Mesh")]
	public void UpdateNavMeshAsync()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		if (!HasBuildOperationStarted && !AiManager.nav_disable)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			Debug.Log((object)("Starting Navmesh Build with " + sources.Count + " sources"));
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
			((NavMeshBuildSettings)(ref settingsByIndex)).overrideVoxelSize = true;
			((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize = ((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize * 2f;
			BuildingOperation = NavMeshBuilder.UpdateNavMeshDataAsync(NavMeshData, settingsByIndex, sources, Bounds);
			BuildTimer.Reset();
			BuildTimer.Start();
			HasBuildOperationStarted = true;
			float num = Time.realtimeSinceStartup - realtimeSinceStartup;
			if (num > 0.1f)
			{
				Debug.LogWarning((object)("Calling UpdateNavMesh took " + num));
			}
		}
	}

	public IEnumerator UpdateNavMeshAndWait()
	{
		if (HasBuildOperationStarted || AiManager.nav_disable)
		{
			yield break;
		}
		HasBuildOperationStarted = false;
		((Bounds)(ref Bounds)).size = TerrainMeta.Size;
		NavMesh.pathfindingIterationsPerFrame = AiManager.pathfindingIterationsPerFrame;
		IEnumerator enumerator = NavMeshTools.CollectSourcesAsync(Bounds, LayerMask.op_Implicit(LayerMask), NavMeshCollectGeometry, defaultArea, use_baked_terrain_mesh, AsyncTerrainNavMeshBakeCellSize, sources, AppendModifierVolumes, UpdateNavMeshAsync, null);
		if (AiManager.nav_wait)
		{
			yield return enumerator;
		}
		else
		{
			((MonoBehaviour)this).StartCoroutine(enumerator);
		}
		if (!AiManager.nav_wait)
		{
			Debug.Log((object)"nav_wait is false, so we're not waiting for the navmesh to finish generating. This might cause your server to sputter while it's generating.");
			yield break;
		}
		int lastPct = 0;
		while (!HasBuildOperationStarted)
		{
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
		}
		while (BuildingOperation != null)
		{
			int num = (int)(BuildingOperation.progress * 100f);
			if (lastPct != num)
			{
				Debug.LogFormat("{0}%", new object[1] { num });
				lastPct = num;
			}
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
			FinishBuildingNavmesh();
		}
	}

	private void AppendModifierVolumes(List<NavMeshBuildSource> sources)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 size = default(Vector3);
		foreach (NavMeshModifierVolume activeModifier in NavMeshModifierVolume.activeModifiers)
		{
			if ((LayerMask.op_Implicit(LayerMask) & (1 << ((Component)activeModifier).gameObject.layer)) != 0 && activeModifier.AffectsAgentType(agentTypeId))
			{
				Vector3 val = ((Component)activeModifier).transform.TransformPoint(activeModifier.center);
				Vector3 lossyScale = ((Component)activeModifier).transform.lossyScale;
				((Vector3)(ref size))..ctor(activeModifier.size.x * Mathf.Abs(lossyScale.x), activeModifier.size.y * Mathf.Abs(lossyScale.y), activeModifier.size.z * Mathf.Abs(lossyScale.z));
				NavMeshBuildSource item = default(NavMeshBuildSource);
				((NavMeshBuildSource)(ref item)).shape = (NavMeshBuildSourceShape)5;
				((NavMeshBuildSource)(ref item)).transform = Matrix4x4.TRS(val, ((Component)activeModifier).transform.rotation, Vector3.one);
				((NavMeshBuildSource)(ref item)).size = size;
				((NavMeshBuildSource)(ref item)).area = activeModifier.area;
				sources.Add(item);
			}
		}
	}

	public void FinishBuildingNavmesh()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (BuildingOperation != null && BuildingOperation.isDone)
		{
			if (!((NavMeshDataInstance)(ref NavMeshDataInstance)).valid)
			{
				NavMeshDataInstance = NavMesh.AddNavMeshData(NavMeshData);
			}
			Debug.Log((object)$"Navmesh Build took {BuildTimer.Elapsed.TotalSeconds:0.00} seconds");
			BuildingOperation = null;
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class Eqs
{
	public sealed class PooledScoreList : BasePooledList<(Vector3 pos, float score), PooledScoreList>
	{
		public void SortByScoreDesc(BaseEntity baseEntity = null)
		{
			TimeWarning val = TimeWarning.New("SortByScoreDesc", 0);
			try
			{
				((List<(Vector3, float)>)(object)this).Sort((Comparison<(Vector3, float)>)(((Vector3 pos, float score) a, (Vector3 pos, float score) b) => b.score.CompareTo(a.score)));
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public void Reorder(List<Vector3> positions)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("Reorder", 0);
			try
			{
				for (int i = 0; i < positions.Count; i++)
				{
					positions[i] = ((List<(Vector3, float)>)(object)this)[i].Item1;
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static void SamplePositionsInDonutShape(Vector3 center, List<Vector3> sampledPositions, float radius = 10f, int numRings = 1, int itemsPerRing = 8)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePositionsInDonutShape", 0);
		try
		{
			for (int i = 0; i < itemsPerRing; i++)
			{
				float num = MathF.PI * 2f * (float)i / (float)itemsPerRing;
				Vector3 item = center + new Vector3(Mathf.Cos(num), 0f, Mathf.Sin(num)) * radius;
				sampledPositions.Add(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void SamplePositionsInMultiDonutShape(Vector3 center, List<Vector3> sampledPositions, float outerRadius = 10f, float innerRadius = 10f, int numRings = 1, int itemsPerRing = 8)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePositionsInMultiDonutShape", 0);
		try
		{
			for (int i = 0; i < numRings; i++)
			{
				float num = ((numRings != 1) ? Mathf.Lerp(innerRadius, outerRadius, (float)i / (float)(numRings - 1)) : outerRadius);
				for (int j = 0; j < itemsPerRing; j++)
				{
					float num2 = (float)i * MathF.PI / (float)numRings;
					float num3 = MathF.PI * 2f * (float)j / (float)itemsPerRing + num2;
					Vector3 item = center + new Vector3(Mathf.Cos(num3), 0f, Mathf.Sin(num3)) * num;
					sampledPositions.Add(item);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public sealed class PooledScoreList : BasePooledList<(Vector3 pos, float score), PooledScoreList>
{
	public void SortByScoreDesc(BaseEntity baseEntity = null)
	{
		TimeWarning val = TimeWarning.New("SortByScoreDesc", 0);
		try
		{
			((List<(Vector3, float)>)(object)this).Sort((Comparison<(Vector3, float)>)(((Vector3 pos, float score) a, (Vector3 pos, float score) b) => b.score.CompareTo(a.score)));
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Reorder(List<Vector3> positions)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Reorder", 0);
		try
		{
			for (int i = 0; i < positions.Count; i++)
			{
				positions[i] = ((List<(Vector3, float)>)(object)this)[i].Item1;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Rust;
using Rust.Ai;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class MonumentNavMesh : FacepunchBehaviour, IServerComponent
{
	public int NavMeshAgentTypeIndex;

	[Tooltip("The default area associated with the NavMeshAgent index.")]
	public string DefaultAreaName = "HumanNPC";

	[Tooltip("How many cells to use squared")]
	public int CellCount = 1;

	[Tooltip("The size of each cell for async object gathering")]
	public int CellSize = 80;

	public int Height = 100;

	public float NavmeshResolutionModifier = 0.5f;

	[Tooltip("Use the bounds specified in editor instead of generating it from cellsize * cellcount")]
	public bool overrideAutoBounds;

	[Tooltip("Bounds which are auto calculated from CellSize * CellCount")]
	public Bounds Bounds;

	public NavMeshData NavMeshData;

	public NavMeshDataInstance NavMeshDataInstance;

	public LayerMask LayerMask;

	public NavMeshCollectGeometry NavMeshCollectGeometry;

	public bool forceCollectTerrain;

	public bool shouldNotifyAIZones = true;

	public Transform CustomNavMeshRoot;

	public bool IgnoreTerrain;

	[ServerVar]
	public static bool use_baked_terrain_mesh = true;

	private List<NavMeshBuildSource> sources;

	private AsyncOperation BuildingOperation;

	private bool HasBuildOperationStarted;

	private Stopwatch BuildTimer = new Stopwatch();

	private int defaultArea;

	private int agentTypeId;

	public bool IsBuilding
	{
		get
		{
			if (!HasBuildOperationStarted || BuildingOperation != null)
			{
				return true;
			}
			return false;
		}
	}

	private void OnEnable()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
		agentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		NavMeshData = new NavMeshData(agentTypeId);
		sources = new List<NavMeshBuildSource>();
		defaultArea = NavMesh.GetAreaFromName(DefaultAreaName);
		((FacepunchBehaviour)this).InvokeRepeating((Action)FinishBuildingNavmesh, 0f, 1f);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FinishBuildingNavmesh);
			((NavMeshDataInstance)(ref NavMeshDataInstance)).Remove();
		}
	}

	[ContextMenu("Update Monument Nav Mesh")]
	public void UpdateNavMeshAsync()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (!HasBuildOperationStarted && !AiManager.nav_disable && AI.npc_enable)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			Debug.Log((object)("Starting Monument Navmesh Build with " + sources.Count + " sources"));
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
			((NavMeshBuildSettings)(ref settingsByIndex)).overrideVoxelSize = true;
			((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize = ((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize * NavmeshResolutionModifier;
			BuildingOperation = NavMeshBuilder.UpdateNavMeshDataAsync(NavMeshData, settingsByIndex, sources, Bounds);
			BuildTimer.Reset();
			BuildTimer.Start();
			HasBuildOperationStarted = true;
			float num = Time.realtimeSinceStartup - realtimeSinceStartup;
			if (num > 0.1f)
			{
				Debug.LogWarning((object)("Calling UpdateNavMesh took " + num));
			}
			if (shouldNotifyAIZones)
			{
				NotifyInformationZonesOfCompletion();
			}
		}
	}

	public IEnumerator UpdateNavMeshAndWait()
	{
		if (HasBuildOperationStarted || AiManager.nav_disable || !AI.npc_enable)
		{
			yield break;
		}
		HasBuildOperationStarted = false;
		((Bounds)(ref Bounds)).center = ((Component)this).transform.position;
		if (!overrideAutoBounds)
		{
			((Bounds)(ref Bounds)).size = new Vector3((float)(CellSize * CellCount), (float)Height, (float)(CellSize * CellCount));
		}
		IEnumerator enumerator = NavMeshTools.CollectSourcesAsync(Bounds, LayerMask.op_Implicit(LayerMask), NavMeshCollectGeometry, defaultArea, use_baked_terrain_mesh && !forceCollectTerrain && !IgnoreTerrain, CellSize, sources, AppendModifierVolumes, UpdateNavMeshAsync, CustomNavMeshRoot);
		if (AiManager.nav_wait)
		{
			yield return enumerator;
		}
		else
		{
			((MonoBehaviour)this).StartCoroutine(enumerator);
		}
		if (!AiManager.nav_wait)
		{
			Debug.Log((object)"nav_wait is false, so we're not waiting for the navmesh to finish generating. This might cause your server to sputter while it's generating.");
			yield break;
		}
		int lastPct = 0;
		while (!HasBuildOperationStarted)
		{
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
		}
		while (BuildingOperation != null)
		{
			int num = (int)(BuildingOperation.progress * 100f);
			if (lastPct != num)
			{
				Debug.LogFormat("{0}%", new object[1] { num });
				lastPct = num;
			}
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
			FinishBuildingNavmesh();
		}
	}

	public void NotifyInformationZonesOfCompletion()
	{
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			zone.NavmeshBuildingComplete();
		}
	}

	private void AppendModifierVolumes(List<NavMeshBuildSource> sources)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		Vector3 size = default(Vector3);
		foreach (NavMeshModifierVolume activeModifier in NavMeshModifierVolume.activeModifiers)
		{
			if ((LayerMask.op_Implicit(LayerMask) & (1 << ((Component)activeModifier).gameObject.layer)) != 0 && activeModifier.AffectsAgentType(agentTypeId))
			{
				Vector3 val = ((Component)activeModifier).transform.TransformPoint(activeModifier.center);
				if (((Bounds)(ref Bounds)).Contains(val))
				{
					Vector3 lossyScale = ((Component)activeModifier).transform.lossyScale;
					((Vector3)(ref size))..ctor(activeModifier.size.x * Mathf.Abs(lossyScale.x), activeModifier.size.y * Mathf.Abs(lossyScale.y), activeModifier.size.z * Mathf.Abs(lossyScale.z));
					NavMeshBuildSource item = default(NavMeshBuildSource);
					((NavMeshBuildSource)(ref item)).shape = (NavMeshBuildSourceShape)5;
					((NavMeshBuildSource)(ref item)).transform = Matrix4x4.TRS(val, ((Component)activeModifier).transform.rotation, Vector3.one);
					((NavMeshBuildSource)(ref item)).size = size;
					((NavMeshBuildSource)(ref item)).area = activeModifier.area;
					sources.Add(item);
				}
			}
		}
	}

	public void FinishBuildingNavmesh()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (BuildingOperation != null && BuildingOperation.isDone)
		{
			if (!((NavMeshDataInstance)(ref NavMeshDataInstance)).valid)
			{
				NavMeshDataInstance = NavMesh.AddNavMeshData(NavMeshData);
			}
			Debug.Log((object)$"Monument Navmesh Build took {BuildTimer.Elapsed.TotalSeconds:0.00} seconds");
			BuildingOperation = null;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public static class NavMeshTools
{
	public static IEnumerator CollectSourcesAsync(Bounds bounds, int mask, NavMeshCollectGeometry geometry, int area, bool useBakedTerrainMesh, int cellSize, List<NavMeshBuildSource> sources, Action<List<NavMeshBuildSource>> append, Action callback, Transform customNavMeshDataRoot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		while (!AI.move && !AiManager.nav_wait)
		{
			yield return CoroutineEx.waitForSeconds(1f);
		}
		if ((Object)(object)customNavMeshDataRoot != (Object)null)
		{
			((Component)customNavMeshDataRoot).gameObject.SetActive(true);
			yield return (object)new WaitForEndOfFrame();
		}
		float time = Time.realtimeSinceStartup;
		Debug.Log((object)"Starting Navmesh Source Collecting");
		mask = ((!useBakedTerrainMesh) ? (mask | 0x800000) : (mask & -8388609));
		List<NavMeshBuildMarkup> list = new List<NavMeshBuildMarkup>();
		NavMeshBuilder.CollectSources(bounds, mask, geometry, area, list, sources);
		if (useBakedTerrainMesh && (Object)(object)TerrainMeta.HeightMap != (Object)null)
		{
			for (float x = 0f - ((Bounds)(ref bounds)).extents.x; x < ((Bounds)(ref bounds)).extents.x - (float)(cellSize / 2); x += (float)cellSize)
			{
				for (float z = 0f - ((Bounds)(ref bounds)).extents.z; z < ((Bounds)(ref bounds)).extents.z - (float)(cellSize / 2); z += (float)cellSize)
				{
					AsyncTerrainNavMeshBake terrainSource = new AsyncTerrainNavMeshBake(new Vector3(x, 0f, z), cellSize, cellSize, normal: false, alpha: true);
					yield return terrainSource;
					sources.Add(terrainSource.CreateNavMeshBuildSource(area));
				}
			}
		}
		append?.Invoke(sources);
		Debug.Log((object)$"Navmesh Source Collecting took {Time.realtimeSinceStartup - time:0.00} seconds");
		if ((Object)(object)customNavMeshDataRoot != (Object)null)
		{
			((Component)customNavMeshDataRoot).gameObject.SetActive(false);
		}
		callback?.Invoke();
	}

	public static IEnumerator CollectSourcesAsync(IEnumerable<GameObject> roots, int mask, NavMeshCollectGeometry geometry, int area, List<NavMeshBuildSource> sources, Action<List<NavMeshBuildSource>> append, Action callback)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		while (!AI.move && !AiManager.nav_wait)
		{
			yield return CoroutineEx.waitForSeconds(1f);
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log((object)"Starting Navmesh Source Collecting");
		List<NavMeshBuildMarkup> list = new List<NavMeshBuildMarkup>();
		List<NavMeshBuildSource> list2 = new List<NavMeshBuildSource>();
		foreach (GameObject root in roots)
		{
			if ((Object)(object)root == (Object)null)
			{
				continue;
			}
			NavMeshBuilder.CollectSources(root.transform, mask, geometry, area, list, list2);
			foreach (NavMeshBuildSource item in list2)
			{
				sources.Add(item);
			}
		}
		append?.Invoke(sources);
		Debug.Log((object)$"Navmesh Source Collecting took {Time.realtimeSinceStartup - realtimeSinceStartup:0.00} seconds");
		callback?.Invoke();
	}
}


using ConVar;
using UnityEngine;

public class NPCBarricadeTriggerBox : MonoBehaviour
{
	private Barricade target;

	private static int playerServerLayer = -1;

	public void Setup(Barricade t)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		target = t;
		((Component)this).transform.SetParent(((Component)target).transform, false);
		((Component)this).gameObject.layer = 18;
		BoxCollider obj = ((Component)this).gameObject.AddComponent<BoxCollider>();
		((Collider)obj).isTrigger = true;
		obj.center = Vector3.zero;
		obj.size = Vector3.one * AI.npc_door_trigger_size + Vector3.right * ((Bounds)(ref target.bounds)).size.x;
	}

	private void OnTriggerEnter(Collider other)
	{
		if ((Object)(object)target == (Object)null || target.isClient)
		{
			return;
		}
		if (playerServerLayer < 0)
		{
			playerServerLayer = LayerMask.NameToLayer("Player (Server)");
		}
		if ((((Component)other).gameObject.layer & playerServerLayer) > 0)
		{
			BasePlayer component = ((Component)other).gameObject.GetComponent<BasePlayer>();
			if ((Object)(object)component != (Object)null && component.IsNpc && !(component is BasePet))
			{
				target.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}
}


using ConVar;
using UnityEngine;

public class NPCDoorTriggerBox : MonoBehaviour
{
	private Door door;

	private static int playerServerLayer = -1;

	public void Setup(Door d)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		door = d;
		((Component)this).transform.SetParent(((Component)door).transform, false);
		((Component)this).gameObject.layer = 18;
		BoxCollider obj = ((Component)this).gameObject.AddComponent<BoxCollider>();
		((Collider)obj).isTrigger = true;
		obj.center = Vector3.zero;
		obj.size = Vector3.one * AI.npc_door_trigger_size;
	}

	private void OnTriggerEnter(Collider other)
	{
		if ((Object)(object)door == (Object)null || door.isClient || door.IsLocked() || (!door.isSecurityDoor && door.IsOpen()) || (door.isSecurityDoor && !door.IsOpen()))
		{
			return;
		}
		if (playerServerLayer < 0)
		{
			playerServerLayer = LayerMask.NameToLayer("Player (Server)");
		}
		if ((((Component)other).gameObject.layer & playerServerLayer) > 0)
		{
			BasePlayer component = ((Component)other).gameObject.GetComponent<BasePlayer>();
			if ((Object)(object)component != (Object)null && component.IsNpc && !door.isSecurityDoor)
			{
				door.SetOpen(open: true);
			}
		}
	}
}


using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class RealmedNavMeshObstacle : BasePrefab
{
	public NavMeshObstacle Obstacle;

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (bundling)
		{
			return;
		}
		base.PreProcess(process, rootObj, name, serverside, clientside, bundling: false);
		if (base.isServer && Object.op_Implicit((Object)(object)Obstacle))
		{
			if (AiManager.nav_disable)
			{
				process.RemoveComponent((Component)(object)Obstacle);
				Obstacle = null;
			}
			else if (AiManager.nav_obstacles_carve_state >= 2)
			{
				Obstacle.carving = true;
			}
			else if (AiManager.nav_obstacles_carve_state == 1)
			{
				Obstacle.carving = ((Component)Obstacle).gameObject.layer == 21;
			}
			else
			{
				Obstacle.carving = false;
			}
		}
		process.RemoveComponent((Component)(object)this);
	}
}


using System;
using UnityEngine;

public class BaseAnimalNPC : BaseNpc, IAIAttack, IAITirednessAbove, IAISleep, IAIHungerAbove, IAISenses, IThinker
{
	public string deathStatName = "";

	public AnimalBrain brain;

	private TimeSince lastBrainError;

	public override void ServerInit()
	{
		base.ServerInit();
		brain = ((Component)this).GetComponent<AnimalBrain>();
		if (!base.isClient)
		{
			AIThinkManager.AddAnimal(this);
		}
	}

	internal override void DoServerDestroy()
	{
		if (!base.isClient)
		{
			AIThinkManager.RemoveAnimal(this);
			base.DoServerDestroy();
		}
	}

	public virtual void TryThink()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)brain != (Object)null && HasBrain && brain.ShouldServerThink())
		{
			brain.DoThink();
		}
		else if ((Object)(object)brain == (Object)null && TimeSince.op_Implicit(lastBrainError) > 10f)
		{
			lastBrainError = TimeSince.op_Implicit(0f);
			Debug.LogWarning((object)(((Object)((Component)this).gameObject).name + " is missing a brain"));
		}
	}

	public override void OnDied(HitInfo hitInfo = null)
	{
		if (hitInfo != null)
		{
			BasePlayer initiatorPlayer = hitInfo.InitiatorPlayer;
			if ((Object)(object)initiatorPlayer != (Object)null)
			{
				initiatorPlayer.GiveAchievement("KILL_ANIMAL");
				if (!string.IsNullOrEmpty(deathStatName))
				{
					initiatorPlayer.stats.Add(deathStatName, 1, (Stats)5);
					initiatorPlayer.stats.Save();
				}
				initiatorPlayer.LifeStoryKill(this);
			}
		}
		base.OnDied((HitInfo)null);
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer && Object.op_Implicit((Object)(object)info.InitiatorPlayer) && !info.damageTypes.IsMeleeType())
		{
			info.InitiatorPlayer.LifeStoryShotHit(info.Weapon);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Kill();
	}

	public bool CanAttack(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (NeedsToReload())
		{
			return false;
		}
		if (IsOnCooldown())
		{
			return false;
		}
		if (!IsTargetInRange(entity, out var _))
		{
			return false;
		}
		if (!CanSeeTarget(entity))
		{
			return false;
		}
		BasePlayer basePlayer = entity as BasePlayer;
		BaseVehicle baseVehicle = (((Object)(object)basePlayer != (Object)null) ? basePlayer.GetMountedVehicle() : null);
		if ((Object)(object)baseVehicle != (Object)null && baseVehicle is BaseModularVehicle)
		{
			return false;
		}
		return true;
	}

	public bool NeedsToReload()
	{
		return false;
	}

	public float EngagementRange()
	{
		return AttackRange * brain.AttackRangeMultiplier;
	}

	public bool IsTargetInRange(BaseEntity entity, out float dist)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		dist = Vector3.Distance(((Component)entity).transform.position, base.AttackPosition);
		return dist <= EngagementRange();
	}

	public bool CanSeeTarget(BaseEntity entity)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.IsVisible(GetEntity().CenterPoint(), entity.CenterPoint());
	}

	public bool Reload()
	{
		throw new NotImplementedException();
	}

	public bool StartAttacking(BaseEntity target)
	{
		BaseCombatEntity baseCombatEntity = target as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity == (Object)null)
		{
			return false;
		}
		Attack(baseCombatEntity);
		return true;
	}

	public void StopAttacking()
	{
	}

	public float CooldownDuration()
	{
		return AttackRate;
	}

	public bool IsOnCooldown()
	{
		return !AttackReady();
	}

	public bool IsTirednessAbove(float value)
	{
		return 1f - Sleep > value;
	}

	public void StartSleeping()
	{
		SetFact(Facts.IsSleeping, 1);
	}

	public void StopSleeping()
	{
		SetFact(Facts.IsSleeping, 0);
	}

	public bool IsHungerAbove(float value)
	{
		return 1f - Energy.Level > value;
	}

	public bool IsThreat(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null)
		{
			if (baseNpc.Stats.Family == Stats.Family)
			{
				return false;
			}
			return IsAfraidOf(baseNpc.Stats.Family);
		}
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			return IsAfraidOf(basePlayer.Family);
		}
		return false;
	}

	public bool IsTarget(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null && baseNpc.Stats.Family == Stats.Family)
		{
			return false;
		}
		return !IsThreat(entity);
	}

	public bool IsFriendly(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.prefabID == prefabID;
	}

	public float GetAmmoFraction()
	{
		return 1f;
	}

	public BaseEntity GetBestTarget()
	{
		return null;
	}

	public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
	{
	}
}


using UnityEngine;

public class BaseFishNPC : BaseNpc, IAIAttack, IAISenses, IThinker
{
	protected FishBrain brain;

	public override void ServerInit()
	{
		base.ServerInit();
		brain = ((Component)this).GetComponent<FishBrain>();
		if (!base.isClient)
		{
			AIThinkManager.AddAnimal(this);
		}
	}

	internal override void DoServerDestroy()
	{
		if (!base.isClient)
		{
			AIThinkManager.RemoveAnimal(this);
			base.DoServerDestroy();
		}
	}

	public virtual void TryThink()
	{
		if (brain.ShouldServerThink())
		{
			brain.DoThink();
		}
	}

	public bool CanAttack(BaseEntity entity)
	{
		if (IsOnCooldown())
		{
			return false;
		}
		if (!IsTargetInRange(entity, out var _))
		{
			return false;
		}
		if (!CanSeeTarget(entity))
		{
			return false;
		}
		return true;
	}

	public bool NeedsToReload()
	{
		return false;
	}

	public float EngagementRange()
	{
		return AttackRange * brain.AttackRangeMultiplier;
	}

	public bool IsTargetInRange(BaseEntity entity, out float dist)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		dist = Vector3.Distance(((Component)entity).transform.position, base.AttackPosition);
		return dist <= EngagementRange();
	}

	public bool CanSeeTarget(BaseEntity entity)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.IsVisible(GetEntity().CenterPoint(), entity.CenterPoint());
	}

	public bool Reload()
	{
		return true;
	}

	public bool StartAttacking(BaseEntity target)
	{
		BaseCombatEntity baseCombatEntity = target as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity == (Object)null)
		{
			return false;
		}
		Attack(baseCombatEntity);
		return true;
	}

	public void StopAttacking()
	{
	}

	public float CooldownDuration()
	{
		return AttackRate;
	}

	public bool IsOnCooldown()
	{
		return !AttackReady();
	}

	public bool IsThreat(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null)
		{
			if (baseNpc.Stats.Family == Stats.Family)
			{
				return false;
			}
			return IsAfraidOf(baseNpc.Stats.Family);
		}
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			return IsAfraidOf(basePlayer.Family);
		}
		return false;
	}

	public bool IsTarget(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null && baseNpc.Stats.Family == Stats.Family)
		{
			return false;
		}
		return !IsThreat(entity);
	}

	public bool IsFriendly(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.prefabID == prefabID;
	}

	public float GetAmmoFraction()
	{
		return 1f;
	}

	public BaseEntity GetBestTarget()
	{
		return null;
	}

	public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
	{
	}
}


using System;
using UnityEngine;

[Serializable]
public struct StateTimer
{
	public float ReleaseTime;

	public Action OnFinished;

	public bool IsActive
	{
		get
		{
			bool num = ReleaseTime > Time.time;
			if (!num && OnFinished != null)
			{
				OnFinished();
				OnFinished = null;
			}
			return num;
		}
	}

	public void Activate(float seconds, Action onFinished = null)
	{
		ReleaseTime = Time.time + seconds;
		OnFinished = onFinished;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct VitalLevel
{
	public float Level;

	private float lastUsedTime;

	public float TimeSinceUsed => Time.time - lastUsedTime;

	internal void Add(float f)
	{
		Level += f;
		if (Level > 1f)
		{
			Level = 1f;
		}
		if (Level < 0f)
		{
			Level = 0f;
		}
	}

	internal void Use(float f)
	{
		if (!Mathf.Approximately(f, 0f))
		{
			Level -= Mathf.Abs(f);
			if (Level < 0f)
			{
				Level = 0f;
			}
			lastUsedTime = Time.time;
		}
	}
}


using ConVar;
using UnityEngine;
using UnityEngine.AI;

public class NPCNavigator : BaseNavigator
{
	public int DestroyOnFailedSampleCount = 5;

	private int sampleFailCount;

	public BaseNpc NPC { get; private set; }

	public override void Init(BaseCombatEntity entity, NavMeshAgent agent)
	{
		base.Init(entity, agent);
		NPC = entity as BaseNpc;
		sampleFailCount = 0;
	}

	public override void OnFailedToPlaceOnNavmesh()
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		base.OnFailedToPlaceOnNavmesh();
		if ((Object)(object)SingletonComponent<DynamicNavMesh>.Instance == (Object)null || SingletonComponent<DynamicNavMesh>.Instance.IsBuilding)
		{
			return;
		}
		sampleFailCount++;
		if (DestroyOnFailedSampleCount > 0 && sampleFailCount >= DestroyOnFailedSampleCount)
		{
			string[] obj = new string[6]
			{
				"Failed to sample navmesh ",
				sampleFailCount.ToString(),
				" times in a row at: ",
				null,
				null,
				null
			};
			Vector3 position = ((Component)this).transform.position;
			obj[3] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
			obj[4] = ". Destroying: ";
			obj[5] = ((Object)((Component)this).gameObject).name;
			Debug.LogWarning((object)string.Concat(obj));
			if ((Object)(object)NPC != (Object)null && !NPC.IsDestroyed)
			{
				NPC.Kill();
			}
		}
	}

	public override void OnPlacedOnNavmesh()
	{
		base.OnPlacedOnNavmesh();
		sampleFailCount = 0;
	}

	protected override bool CanEnableNavMeshNavigation()
	{
		if (!base.CanEnableNavMeshNavigation())
		{
			return false;
		}
		return true;
	}

	protected override bool CanUpdateMovement()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanUpdateMovement())
		{
			return false;
		}
		if ((Object)(object)NPC != (Object)null && (NPC.IsDormant || !NPC.syncPosition) && ((Behaviour)base.Agent).enabled)
		{
			SetDestination(NPC.ServerPosition);
			return false;
		}
		return true;
	}

	protected override void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		base.UpdatePositionAndRotation(moveToPosition, delta);
		UpdateRotation(moveToPosition, delta);
	}

	private void UpdateRotation(Vector3 moveToPosition, float delta)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		if (overrideFacingDirectionMode != 0)
		{
			return;
		}
		if (traversingNavMeshLink)
		{
			Vector3 val = base.Agent.destination - base.BaseEntity.ServerPosition;
			if (((Vector3)(ref val)).sqrMagnitude > 1f)
			{
				val = currentNavMeshLinkEndPos - base.BaseEntity.ServerPosition;
			}
			_ = ((Vector3)(ref val)).sqrMagnitude;
			_ = 0.001f;
			return;
		}
		Vector3 val2 = base.Agent.destination - base.BaseEntity.ServerPosition;
		if (((Vector3)(ref val2)).sqrMagnitude > 1f)
		{
			val2 = base.Agent.desiredVelocity;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			if (((Vector3)(ref normalized)).sqrMagnitude > 0.001f)
			{
				base.BaseEntity.ServerRotation = Quaternion.LookRotation(normalized);
			}
		}
	}

	public override void ApplyFacingDirectionOverride()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyFacingDirectionOverride();
		base.BaseEntity.ServerRotation = Quaternion.LookRotation(base.FacingDirectionOverride);
	}

	public override bool IsSwimming()
	{
		if (!AI.npcswimming)
		{
			return false;
		}
		if ((Object)(object)NPC != (Object)null)
		{
			return NPC.swimming;
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.AI;

public class NPCPlayerNavigator : BaseNavigator
{
	public NPCPlayer NPCPlayerEntity { get; private set; }

	public override void Init(BaseCombatEntity entity, NavMeshAgent agent)
	{
		base.Init(entity, agent);
		NPCPlayerEntity = entity as NPCPlayer;
	}

	protected override bool CanEnableNavMeshNavigation()
	{
		if (!base.CanEnableNavMeshNavigation())
		{
			return false;
		}
		if (NPCPlayerEntity.isMounted && !CanNavigateMounted)
		{
			return false;
		}
		return true;
	}

	protected override bool CanUpdateMovement()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanUpdateMovement())
		{
			return false;
		}
		if (NPCPlayerEntity.IsWounded())
		{
			return false;
		}
		if (base.CurrentNavigationType == NavigationType.NavMesh && (NPCPlayerEntity.IsDormant || !NPCPlayerEntity.syncPosition) && ((Behaviour)base.Agent).enabled)
		{
			SetDestination(NPCPlayerEntity.ServerPosition);
			return false;
		}
		return true;
	}

	protected override void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		base.UpdatePositionAndRotation(moveToPosition, delta);
		if (overrideFacingDirectionMode == OverrideFacingDirectionMode.None)
		{
			if (base.CurrentNavigationType == NavigationType.NavMesh)
			{
				NPCPlayer nPCPlayerEntity = NPCPlayerEntity;
				Vector3 desiredVelocity = base.Agent.desiredVelocity;
				nPCPlayerEntity.SetAimDirection(((Vector3)(ref desiredVelocity)).normalized);
			}
			else if (base.CurrentNavigationType == NavigationType.AStar || base.CurrentNavigationType == NavigationType.Base)
			{
				NPCPlayerEntity.SetAimDirection(Vector3Ex.Direction2D(moveToPosition, ((Component)this).transform.position));
			}
		}
	}

	public override void ApplyFacingDirectionOverride()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyFacingDirectionOverride();
		if (overrideFacingDirectionMode != 0 && !NPCPlayerEntity.IsUnityNull())
		{
			if (overrideFacingDirectionMode == OverrideFacingDirectionMode.Direction)
			{
				NPCPlayerEntity.SetAimDirection(facingDirectionOverride);
			}
			else if ((Object)(object)facingDirectionEntity != (Object)null)
			{
				Vector3 aimDirection = GetAimDirection(NPCPlayerEntity, facingDirectionEntity);
				facingDirectionOverride = aimDirection;
				NPCPlayerEntity.SetAimDirection(facingDirectionOverride);
			}
		}
	}

	private static Vector3 GetAimDirection(BasePlayer aimingPlayer, BaseEntity target)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		if (target.IsUnityNull())
		{
			return Vector3Ex.Direction2D(((Component)aimingPlayer).transform.position + (((Object)(object)aimingPlayer.eyes != (Object)null) ? aimingPlayer.eyes.BodyForward() : ((Component)aimingPlayer).transform.forward) * 1000f, ((Component)aimingPlayer).transform.position);
		}
		if (Vector3Ex.Distance2D(((Component)aimingPlayer).transform.position, ((Component)target).transform.position) <= 0.75f)
		{
			return Vector3Ex.Direction2D(((Component)target).transform.position, ((Component)aimingPlayer).transform.position);
		}
		Vector3 val = TargetAimPositionOffset(target) - (((Object)(object)aimingPlayer.eyes != (Object)null) ? aimingPlayer.eyes.position : ((Component)aimingPlayer).transform.position);
		return ((Vector3)(ref val)).normalized;
	}

	private static Vector3 TargetAimPositionOffset(BaseEntity target)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = target as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsSleeping() || basePlayer.IsWounded())
			{
				return ((Component)basePlayer).transform.position + Vector3.up * 0.1f;
			}
			if ((Object)(object)basePlayer.eyes != (Object)null)
			{
				return basePlayer.eyes.position - Vector3.up * 0.15f;
			}
		}
		return target.CenterPoint();
	}
}


using UnityEngine;

public class NPCPlayerNavigatorTester : BaseMonoBehaviour
{
	public BasePathNode TargetNode;

	private BasePathNode currentNode;

	private void Update()
	{
		if ((Object)(object)TargetNode != (Object)(object)currentNode)
		{
			((Component)this).GetComponent<BaseNavigator>().SetDestination(TargetNode.Path, TargetNode, 0.5f);
			currentNode = TargetNode;
		}
	}
}


using UnityEngine;

public class NavPathTester : MonoBehaviour
{
	[SerializeField]
	private Transform target;

	private void OnDrawGizmosSelected()
	{
		if (!((Object)(object)target == (Object)null) && ((Object)(object)((Component)target).GetComponent<NavPathTester>()).Is<NavPathTester>(out NavPathTester entAsT) && (Object)(object)entAsT.target == (Object)null)
		{
			entAsT.target = ((Component)this).transform;
		}
	}

	public static void GizmosDrawPath(Vector3[] corners, Color color)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		for (int i = 0; i < corners.Length - 1; i++)
		{
			Gizmos.DrawSphere(corners[i], 0.01f);
			Gizmos.DrawLine(corners[i], corners[i + 1]);
		}
		Gizmos.color = color2;
	}
}


using UnityEngine;
using UnityEngine.AI;

public static class NPCOverwatchSpot
{
	public static (Vector3 loc, Vector3 dir)? Find(Vector3[] corners)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		if (corners.Length < 3)
		{
			return null;
		}
		NavMeshHit val9 = default(NavMeshHit);
		RaycastHit val14 = default(RaycastHit);
		RaycastHit val15 = default(RaycastHit);
		for (int num = corners.Length - 1; num >= 2; num--)
		{
			Vector3 val = corners[num];
			Vector3 val2 = corners[num - 1];
			Vector3 val3 = corners[num - 2];
			Gizmos.color = Color.red;
			Vector3 val4 = Vector3Ex.NormalizeXZ(val - val2);
			Vector3 val5 = Vector3Ex.NormalizeXZ(val3 - val2);
			Vector3 val6 = -Vector3Ex.NormalizeXZ(val4 + val5);
			Gizmos.DrawLine(val2, val2 + val6);
			Gizmos.color = Color.blue;
			Vector3 val7 = val6 * 0.01f;
			val += val7;
			val2 += val7;
			Vector3 val8 = Vector3Ex.NormalizeXZ(val2 - val) * 100f;
			if (NavMesh.Raycast(val, val + val8, ref val9, -1))
			{
				Vector3 val10 = val;
				Vector3 val11 = val;
				Vector3 val12 = ((NavMeshHit)(ref val9)).position - val;
				Gizmos.DrawLine(val10, val11 + ((Vector3)(ref val12)).normalized * 100f);
				if (((NavMeshHit)(ref val9)).distance >= 7f)
				{
					Vector3 val13 = corners[^1];
					Vector3 position = ((NavMeshHit)(ref val9)).position;
					bool flag = Physics.Linecast(val13 + 1.7f * Vector3.up, position + 1.7f * Vector3.up, ref val14, 1218652417);
					Gizmos.color = Color.red;
					Gizmos.DrawLine(val13 + 1.7f * Vector3.up, position + 1.7f * Vector3.up);
					if (flag)
					{
						bool flag2 = Physics.Linecast(val13 + 0.2f * Vector3.up, position + 0.2f * Vector3.up, ref val15, 1218652417);
						Gizmos.DrawLine(val13 + 0.2f * Vector3.up, position + 0.2f * Vector3.up);
						if (flag2)
						{
							Gizmos.color = Color.blue;
							Gizmos.DrawWireSphere(((NavMeshHit)(ref val9)).position, 0.1f);
							Vector3 position2 = ((NavMeshHit)(ref val9)).position;
							val12 = val - ((NavMeshHit)(ref val9)).position;
							return (position2, ((Vector3)(ref val12)).normalized);
						}
					}
				}
			}
		}
		return null;
	}
}


using UnityEngine;
using UnityEngine.AI;

public static class NPCFlankSpot
{
	public readonly struct FlankRoute
	{
		public readonly Vector3 FlankPoint;

		public readonly NavMeshPath ToFlankPoint;

		public readonly NavMeshPath FromFlankPointToEnemy;

		public FlankRoute(Vector3 flankPoint, NavMeshPath toFlankPoint, NavMeshPath fromFlankPointToEnemy)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			FlankPoint = flankPoint;
			ToFlankPoint = toFlankPoint;
			FromFlankPointToEnemy = fromFlankPointToEnemy;
		}
	}

	public static bool Find(Vector3[] pathToEnemy, float pathDistance, out FlankRoute flank)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		flank = default(FlankRoute);
		if (!FindMiddlePoint(pathToEnemy, pathDistance, out var middlePoint, out var dir))
		{
			return false;
		}
		Gizmos.color = Color.white;
		Gizmos.DrawSphere(middlePoint, 0.1f);
		Vector3 val = dir * pathDistance * 0.5f;
		val.y = 0f;
		if (TryBuildFlankPath(pathToEnemy, middlePoint, middlePoint + Quaternion.AngleAxis(90f, Vector3.up) * val, out flank))
		{
			return true;
		}
		if (TryBuildFlankPath(pathToEnemy, middlePoint, middlePoint + Quaternion.AngleAxis(-90f, Vector3.up) * val, out flank))
		{
			return true;
		}
		return false;
	}

	private static bool TryBuildFlankPath(Vector3[] pathToEnemy, Vector3 pathMiddle, Vector3 approximateFlankPoint, out FlankRoute flank)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected O, but got Unknown
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Expected O, but got Unknown
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Expected O, but got Unknown
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.white;
		Gizmos.DrawLine(pathMiddle, approximateFlankPoint);
		flank = default(FlankRoute);
		NavMeshHit val = default(NavMeshHit);
		if (!NavMesh.SamplePosition(approximateFlankPoint, ref val, 10f, -1))
		{
			return false;
		}
		Gizmos.DrawLine(approximateFlankPoint, ((NavMeshHit)(ref val)).position);
		NavMeshPath val2 = new NavMeshPath();
		if (!NavMesh.CalculatePath(pathMiddle, ((NavMeshHit)(ref val)).position, -1, val2))
		{
			return false;
		}
		Vector3 val3 = val2.corners[^1];
		NavMeshPath val4 = new NavMeshPath();
		if (!NavMesh.CalculatePath(pathToEnemy[0], val3, -1, val4))
		{
			return false;
		}
		Vector3[] corners = val4.corners;
		NavMeshPath val5 = new NavMeshPath();
		if (!NavMesh.CalculatePath(val3, pathToEnemy[^1], -1, val5))
		{
			return false;
		}
		Vector3[] corners2 = val5.corners;
		if (!ArePathsDifferent(pathToEnemy, corners2))
		{
			NavPathTester.GizmosDrawPath(corners, Color.grey);
			NavPathTester.GizmosDrawPath(corners2, Color.yellow);
			return false;
		}
		if (!ArePathsDifferent(pathToEnemy, corners))
		{
			NavPathTester.GizmosDrawPath(corners, Color.yellow);
			NavPathTester.GizmosDrawPath(corners2, Color.grey);
			return false;
		}
		if (!ArePathsDifferent(corners, corners2))
		{
			NavPathTester.GizmosDrawPath(corners, Color.yellow);
			NavPathTester.GizmosDrawPath(corners2, Color.grey);
			return false;
		}
		if (Vector3.Angle(pathToEnemy[^1] - pathToEnemy[^2], corners2[^1] - corners2[^2]) < 30f)
		{
			NavPathTester.GizmosDrawPath(corners, Color.grey);
			NavPathTester.GizmosDrawPath(corners2, Color.red);
			return false;
		}
		flank = new FlankRoute(val3, val4, val5);
		return true;
	}

	private static bool ArePathsDifferent(Vector3[] path1, Vector3[] path2, float minRatio = 0.25f)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (path1.Length < 3 || path2.Length < 3)
		{
			if (!(path1[0] != path2[0]))
			{
				return path1[^1] != path2[^1];
			}
			return true;
		}
		int num = 0;
		for (int i = 1; i < path1.Length - 1; i++)
		{
			for (int j = 1; j < path2.Length - 1; j++)
			{
				if (path1[i] == path2[j])
				{
					num++;
					break;
				}
			}
		}
		int num2 = Mathf.Min(path1.Length - 2, path2.Length - 2);
		return (float)num / (float)num2 <= minRatio;
	}

	private static bool FindMiddlePoint(Vector3[] corners, float pathLength, out Vector3 middlePoint, out Vector3 dir)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		float num = pathLength * 0.5f;
		float num2 = 0f;
		for (int i = 0; i < corners.Length - 1; i++)
		{
			Vector3 val = corners[i];
			Vector3 val2 = corners[i + 1];
			float num3 = Vector3.Distance(val, val2);
			if (num2 + num3 >= num)
			{
				float num4 = (num - num2) / num3;
				middlePoint = Vector3.Lerp(val, val2, num4);
				Vector3 val3 = val2 - val;
				dir = ((Vector3)(ref val3)).normalized;
				return true;
			}
			num2 += num3;
		}
		middlePoint = default(Vector3);
		dir = default(Vector3);
		return false;
	}
}


using UnityEngine;
using UnityEngine.AI;

public readonly struct FlankRoute
{
	public readonly Vector3 FlankPoint;

	public readonly NavMeshPath ToFlankPoint;

	public readonly NavMeshPath FromFlankPointToEnemy;

	public FlankRoute(Vector3 flankPoint, NavMeshPath toFlankPoint, NavMeshPath fromFlankPointToEnemy)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		FlankPoint = flankPoint;
		ToFlankPoint = toFlankPoint;
		FromFlankPointToEnemy = fromFlankPointToEnemy;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

public static class NPCDynamicCover
{
	public static bool Find(Vector3 pos, Vector3 enemyPos, out NavMeshPath path, out Vector3 coverDir, float radius = 10f, int itemsPerRing = 8, float offset = 0f)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Expected O, but got Unknown
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		path = null;
		coverDir = default(Vector3);
		float num = Vector3.SignedAngle(enemyPos - pos, Vector3.forward, Vector3.up) * (MathF.PI / 180f) + offset;
		NavMeshHit val2 = default(NavMeshHit);
		for (int i = 0; i < itemsPerRing; i++)
		{
			float num2 = MathF.PI * -2f * (float)i / (float)itemsPerRing + num;
			Vector3 val = pos + new Vector3(Mathf.Cos(num2), 0f, Mathf.Sin(num2)) * radius;
			Gizmos.color = Color.white;
			Gizmos.DrawLine(pos, val);
			if (!NavMesh.SamplePosition(val, ref val2, 3f, -1))
			{
				continue;
			}
			Gizmos.DrawLine(val, ((NavMeshHit)(ref val2)).position);
			val = ((NavMeshHit)(ref val2)).position;
			Vector3 val3 = enemyPos - val;
			Vector3 val4 = Vector3.Cross(((Vector3)(ref val3)).normalized, Vector3.up) * 0.5f;
			if (IsPositionVisibleFrom(val + val4, enemyPos) || IsPositionVisibleFrom(val - val4, enemyPos))
			{
				continue;
			}
			if (path == null)
			{
				path = new NavMeshPath();
			}
			if (NavMesh.CalculatePath(pos, val, -1, path) && (int)path.status == 0)
			{
				Gizmos.color = Color.black;
				NavPathTester.GizmosDrawPath(path.corners, Color.black);
				if (!(path.GetPathLength() > radius * 2f))
				{
					Gizmos.color = Color.yellow;
					Gizmos.DrawSphere(val, 0.5f);
					val3 = enemyPos - val;
					coverDir = ((Vector3)(ref val3)).normalized;
					return true;
				}
			}
		}
		path = null;
		return false;
	}

	private static bool IsPositionVisibleFrom(Vector3 pos, Vector3 enemyPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.up * 1.7f;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Linecast(pos + val, enemyPos + val, ref val2, 1218652417))
		{
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(pos + val, ((RaycastHit)(ref val2)).point);
			Gizmos.DrawSphere(((RaycastHit)(ref val2)).point, 0.1f);
			Gizmos.color = Color.red;
			Gizmos.DrawLine(((RaycastHit)(ref val2)).point, enemyPos + val);
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class RootMotionData : BaseScriptableObject
{
	public AnimationCurve xMotionCurve;

	public AnimationCurve yMotionCurve;

	public AnimationCurve zMotionCurve;

	public AnimationCurve yRotationCurve;

	public AnimationClip inPlaceAnimation;
}


using UnityEngine;

public class TraceTester : MonoBehaviour
{
}


using UnityEngine;

public class WaterDepthTester : MonoBehaviour
{
	private void Update()
	{
	}
}


using UnityEngine;

public class WorkshopRenderSettings : MonoBehaviour
{
	public ItemDefinition ItemDefinition;

	public bool ToggleLightingRig;

	public Transform LightingRig;
}


using UnityEngine;

public class AccessbilityMaterialPropertyBlock : AccessibilityComponent
{
	public Renderer TargetRenderer;

	public string TagName;

	public AccessibilityColourCollection ForData;
}


public abstract class AccessibilityComponent : ListComponent<AccessibilityComponent>, IClientComponent
{
}


using UnityEngine;

public class AccessibilityDecalMaterial : AccessibilityComponent
{
	public DeferredDecal DecalRenderer;

	public AccessibilityMaterialCollection TargetData;

	public Material NightVisionTeaMaterial;
}


using UnityEngine.UI;

public class AccessibilityMaterialSprite : AccessibilityComponent
{
	public Image TargetImage;

	public AccessibilityMaterialCollection TargetData;
}


using UnityEngine;

public class AccessibilityMaterialSwap : AccessibilityComponent
{
	public AccessibilityMaterialCollection ForData;

	public Renderer ForRenderer;
}


public class AccessibilityMaterialSwap_NVG : AccessibilityMaterialSwap
{
}


using UnityEngine.UI;

public class AccessibilitySpriteColour : AccessibilityComponent
{
	public AccessibilityColourCollection TargetData;

	public Image SpriteA;

	public Image SpriteB;
}


public class AccessibilityCollection<T> : BaseScriptableObject
{
	public string convarName;

	public T[] AllOptions;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Accessibility/Colour Collection")]
public class AccessibilityColourCollection : AccessibilityCollection<AccessibilityColourCollection.ColourPair>
{
	[Serializable]
	public struct ColourPair
	{
		public Color A;

		public Color B;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ColourPair
{
	public Color A;

	public Color B;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Accessibility/Material Collection")]
public class AccessibilityMaterialCollection : AccessibilityCollection<AccessibilityMaterialCollection.MaterialOption>
{
	[Serializable]
	public struct MaterialOption
	{
		public Material TargetMaterial;

		public Color HudColour;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct MaterialOption
{
	public Material TargetMaterial;

	public Color HudColour;
}


public enum AIState
{
	None,
	Idle,
	Roam,
	Chase,
	Cover,
	Combat,
	Mounted,
	Exfil,
	Patrol,
	Orbit,
	Egress,
	Land,
	DropCrate,
	MoveTowards,
	Flee,
	Attack,
	Sleep,
	Reload,
	TakeCover,
	Dismounted,
	FollowPath,
	NavigateHome,
	CombatStationary,
	Cooldown,
	MoveToPoint,
	MoveToVector3,
	Blinded,
	KillSelf,
	MountAPC
}


public enum AIThinkMode
{
	FixedUpdate,
	Interval
}


using System;
using UnityEngine;

public class BasePathFinder
{
	private static Vector3[] preferedTopologySamples = (Vector3[])(object)new Vector3[4];

	private static Vector3[] topologySamples = (Vector3[])(object)new Vector3[4];

	private Vector3 chosenPosition;

	private const float halfPI = MathF.PI / 180f;

	public virtual Vector3 GetRandomPatrolPoint()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.zero;
	}

	public virtual AIMovePoint GetBestRoamPoint(Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float anchorClampDistance, float lookupMaxRange = 20f)
	{
		return null;
	}

	public void DebugDraw()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Color color = Gizmos.color;
		Gizmos.color = Color.green;
		Gizmos.DrawSphere(chosenPosition, 5f);
		Gizmos.color = Color.blue;
		Vector3[] array = topologySamples;
		for (int i = 0; i < array.Length; i++)
		{
			Gizmos.DrawSphere(array[i], 2.5f);
		}
		Gizmos.color = color;
	}

	public virtual Vector3 GetRandomPositionAround(Vector3 position, float minDistFrom = 0f, float maxDistFrom = 2f)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		if (maxDistFrom < 0f)
		{
			maxDistFrom = 0f;
		}
		Vector2 val = Random.insideUnitCircle * maxDistFrom;
		float num = Mathf.Clamp(Mathf.Max(Mathf.Abs(val.x), minDistFrom), minDistFrom, maxDistFrom) * Mathf.Sign(val.x);
		float num2 = Mathf.Clamp(Mathf.Max(Mathf.Abs(val.y), minDistFrom), minDistFrom, maxDistFrom) * Mathf.Sign(val.y);
		return position + new Vector3(num, 0f, num2);
	}

	public virtual Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		float radius = Random.Range(minRange, maxRange);
		int num = 0;
		int num2 = 0;
		float num3 = Random.Range(0f, 90f);
		for (float num4 = 0f; num4 < 360f; num4 += 90f)
		{
			Vector3 pointOnCircle = GetPointOnCircle(anchorPos, radius, num4 + num3);
			if (navigator.GetNearestNavmeshPosition(pointOnCircle, out var position, 10f) && navigator.IsPositionABiomeRequirement(position) && navigator.IsAcceptableWaterDepth(position) && !navigator.IsPositionPreventTopology(position))
			{
				topologySamples[num] = position;
				num++;
				if (navigator.IsPositionABiomePreference(position) && navigator.IsPositionATopologyPreference(position))
				{
					preferedTopologySamples[num2] = position;
					num2++;
				}
			}
		}
		if (num2 > 0)
		{
			chosenPosition = preferedTopologySamples[Random.Range(0, num2)];
		}
		else if (num > 0)
		{
			chosenPosition = topologySamples[Random.Range(0, num)];
		}
		else
		{
			chosenPosition = fallbackPos;
		}
		return chosenPosition;
	}

	public virtual Vector3 GetBestRoamPositionFromAnchor(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		float radius = Random.Range(minRange, maxRange);
		int num = 0;
		int num2 = 0;
		float num3 = Random.Range(0f, 90f);
		for (float num4 = 0f; num4 < 360f; num4 += 90f)
		{
			Vector3 pointOnCircle = GetPointOnCircle(anchorPos, radius, num4 + num3);
			if (navigator.GetNearestNavmeshPosition(pointOnCircle, out var position, 10f) && navigator.IsAcceptableWaterDepth(position))
			{
				topologySamples[num] = position;
				num++;
				if (navigator.IsPositionABiomePreference(position) && navigator.IsPositionATopologyPreference(position))
				{
					preferedTopologySamples[num2] = position;
					num2++;
				}
			}
		}
		if (Random.Range(0f, 1f) <= 0.9f && num2 > 0)
		{
			chosenPosition = preferedTopologySamples[Random.Range(0, num2)];
		}
		else if (num > 0)
		{
			chosenPosition = topologySamples[Random.Range(0, num)];
		}
		else
		{
			chosenPosition = fallbackPos;
		}
		return chosenPosition;
	}

	public virtual bool GetBestFleePosition(BaseNavigator navigator, AIBrainSenses senses, BaseEntity fleeFrom, Vector3 fallbackPos, float minRange, float maxRange, out Vector3 result)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)fleeFrom == (Object)null)
		{
			result = ((Component)navigator).transform.position;
			return false;
		}
		Vector3 dirFromThreat = Vector3Ex.Direction2D(((Component)navigator).transform.position, ((Component)fleeFrom).transform.position);
		if (TestFleeDirection(navigator, dirFromThreat, 0f, minRange, maxRange, out result))
		{
			return true;
		}
		bool flag = Random.Range(0, 2) == 1;
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 45f : 315f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 315f : 45f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 90f : 270f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 270f : 90f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, 135f + Random.Range(0f, 90f), minRange, maxRange, out result))
		{
			return true;
		}
		return false;
	}

	private bool TestFleeDirection(BaseNavigator navigator, Vector3 dirFromThreat, float offsetDegrees, float minRange, float maxRange, out Vector3 result)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		result = ((Component)navigator).transform.position;
		Vector3 val = Quaternion.Euler(0f, offsetDegrees, 0f) * dirFromThreat;
		Vector3 target = ((Component)navigator).transform.position + val * Random.Range(minRange, maxRange);
		if (!navigator.GetNearestNavmeshPosition(target, out var position, 20f))
		{
			return false;
		}
		if (!navigator.IsAcceptableWaterDepth(position))
		{
			return false;
		}
		result = position;
		return true;
	}

	public static Vector3 GetPointOnCircle(Vector3 center, float radius, float degrees)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		float num = center.x + radius * Mathf.Cos(degrees * (MathF.PI / 180f));
		float num2 = center.z + radius * Mathf.Sin(degrees * (MathF.PI / 180f));
		return new Vector3(num, center.y, num2);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class UnderwaterPathFinder : BasePathFinder
{
	private BaseEntity npc;

	public void Init(BaseEntity npc)
	{
		this.npc = npc;
	}

	public override Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		List<Vector3> list = Pool.Get<List<Vector3>>();
		(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(((Component)navigator).transform.position, waves: false, volumes: false);
		float item = waterAndTerrainSurface.Item1;
		float item2 = waterAndTerrainSurface.Item2;
		for (int i = 0; i < 8; i++)
		{
			Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(fallbackPos, Random.Range(1f, navigator.MaxRoamDistanceFromHome), Random.Range(0f, 359f));
			pointOnCircle.y += Random.Range(-2f, 2f);
			pointOnCircle.y = Mathf.Clamp(pointOnCircle.y, item2, item);
			list.Add(pointOnCircle);
		}
		float num = -1f;
		int num2 = -1;
		for (int j = 0; j < list.Count; j++)
		{
			Vector3 val = list[j];
			if (npc.IsVisible(val))
			{
				float num3 = 0f;
				Vector3 val2 = Vector3Ex.Direction2D(val, ((Component)navigator).transform.position);
				float num4 = Vector3.Dot(((Component)navigator).transform.forward, val2);
				num3 += Mathf.InverseLerp(0.25f, 0.8f, num4) * 5f;
				float num5 = Mathf.Abs(val.y - ((Component)navigator).transform.position.y);
				num3 += 1f - Mathf.InverseLerp(1f, 3f, num5) * 5f;
				if (num3 > num || num2 == -1)
				{
					num = num3;
					num2 = j;
				}
			}
		}
		Vector3 result = list[num2];
		Pool.FreeUnmanaged<Vector3>(ref list);
		return result;
	}

	public override bool GetBestFleePosition(BaseNavigator navigator, AIBrainSenses senses, BaseEntity fleeFrom, Vector3 fallbackPos, float minRange, float maxRange, out Vector3 result)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)fleeFrom == (Object)null)
		{
			result = ((Component)navigator).transform.position;
			return false;
		}
		Vector3 val = Vector3Ex.Direction2D(((Component)navigator).transform.position, ((Component)fleeFrom).transform.position);
		result = ((Component)navigator).transform.position + val * Random.Range(minRange, maxRange);
		return true;
	}
}


using UnityEngine;

public class AimConeUtil
{
	public static Vector3 GetModifiedAimConeDirection(float aimCone, Vector3 inputVec, bool anywhereInside = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.LookRotation(inputVec);
		aimCone = Mathf.Max(aimCone, 0f);
		Vector2 val2;
		if (!anywhereInside)
		{
			Vector2 insideUnitCircle = Random.insideUnitCircle;
			val2 = ((Vector2)(ref insideUnitCircle)).normalized;
		}
		else
		{
			val2 = Random.insideUnitCircle;
		}
		Vector2 val3 = val2;
		return val * Quaternion.Euler(val3.x * aimCone * 0.5f, val3.y * aimCone * 0.5f, 0f) * Vector3.forward;
	}

	public static Quaternion GetAimConeQuat(float aimCone)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 insideUnitSphere = Random.insideUnitSphere;
		return Quaternion.Euler(insideUnitSphere.x * aimCone * 0.5f, insideUnitSphere.y * aimCone * 0.5f, 0f);
	}
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch.Network.Raknet;
using Facepunch.Rust;
using Network;

public static class PlayerNetworkingProfiler
{
	public static int level = 0;

	public static TimeSpan MinFlushInterval = TimeSpan.FromSeconds(1.0);

	public static int ConnectionsPerFrame = 30;

	private static int currentIndex;

	private static DateTime flushCooldown;

	public static void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp)
	{
		if (level == 0)
		{
			return;
		}
		if (currentIndex >= Net.sv.connections.Count)
		{
			if (flushCooldown > DateTime.UtcNow)
			{
				return;
			}
			flushCooldown = DateTime.UtcNow + MinFlushInterval;
			currentIndex = 0;
		}
		Server sv = Net.sv;
		Server val = (Server)(object)((sv is Server) ? sv : null);
		if (val != null)
		{
			SerializeRaknet(uploader, frameIndex, timestamp, val);
		}
	}

	private static void SerializeRaknet(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp, Server server)
	{
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		int num = Math.Min(((Server)server).connections.Count, currentIndex + ConnectionsPerFrame);
		RaknetStats val2 = default(RaknetStats);
		while (currentIndex < num)
		{
			Connection val = ((Server)server).connections[currentIndex];
			if (server.TryGetConnectionStats(val, ref val2))
			{
				string ipaddress = val.ipaddress;
				string value = ipaddress.Split(':')[0];
				string value2 = ipaddress.Split(':')[1];
				int latestPing = server.GetLatestPing(val);
				EventRecord eventRecord = EventRecord.CSV().AddField("", timestamp).AddField("", frameIndex)
					.AddField("", Server.server_id)
					.AddField("", val.guid)
					.AddField("", val.userid)
					.AddField("", value)
					.AddField("", value2)
					.AddField("", latestPing)
					.AddField("", val2.connectionStartTime)
					.AddField("", val2.isLimitedByCongestionControl)
					.AddField("", val2.isLimitedByOutgoingBandwidthLimit)
					.AddField("", val2.BPSLimitByCongestionControl)
					.AddField("", val2.BPSLimitByOutgoingBandwidthLimit)
					.AddField("", val2.messagesInResendBuffer)
					.AddField("", val2.bytesInResendBuffer)
					.AddField("", val2.packetlossLastSecond)
					.AddField("", val2.packetlossTotal);
				for (int i = 0; i < 4; i++)
				{
					eventRecord.AddField("", (ulong)Unsafe.Add(ref val2.bytesInSendBuffer.FixedElementField, i));
				}
				for (int j = 0; j < 4; j++)
				{
					eventRecord.AddField("", (ulong)Unsafe.Add(ref val2.messageInSendBuffer.FixedElementField, j));
				}
				eventRecord.AddField("", val2.runningTotal.FixedElementField);
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 1));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 2));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 3));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 4));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 5));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 6));
				uploader.Append(eventRecord);
			}
			currentIndex++;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

public static class TypeNameCache
{
	private static Dictionary<Type, string> cache = new Dictionary<Type, string>();

	private static Regex genericPrefixRegex = new Regex("`\\d+\\[");

	public static string GetName(Type type)
	{
		if (!cache.TryGetValue(type, out var value))
		{
			value = CalculateName(type);
			cache[type] = value;
		}
		return value;
	}

	private static string CalculateName(Type type)
	{
		string input = type.ToString();
		input = genericPrefixRegex.Replace(input, "<");
		return input.Replace("]", ">");
	}

	public static void ClearCache()
	{
		cache.Clear();
	}
}


using System;
using UnityEngine;

public class HorseIdleMultiConditionCrossfade : StateMachineBehaviour
{
	[Serializable]
	public struct Condition
	{
		public enum CondtionOperator
		{
			GreaterThan,
			LessThan
		}

		public int FloatParameter;

		public CondtionOperator Operator;

		public float Value;
	}

	public string TargetState = "breathe";

	public float NormalizedTransitionDuration = 0.1f;
}


using System;

[Serializable]
public struct Condition
{
	public enum CondtionOperator
	{
		GreaterThan,
		LessThan
	}

	public int FloatParameter;

	public CondtionOperator Operator;

	public float Value;
}


public enum CondtionOperator
{
	GreaterThan,
	LessThan
}


using UnityEngine;

public class TriggerResetter : StateMachineBehaviour
{
	public string triggerName;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Invalid comparison between Unknown and I4
		AnimatorControllerParameter[] parameters = animator.parameters;
		foreach (AnimatorControllerParameter val in parameters)
		{
			if ((int)val.type == 9 && val.name == triggerName)
			{
				animator.ResetTrigger(val.name);
			}
		}
	}
}


using System;
using UnityEngine;

public class WeightedAnimationRandomiser : StateMachineBehaviour
{
	[Serializable]
	public struct IdleChance
	{
		public string StateName;

		[Range(0f, 100f)]
		public int Chance;
	}

	public int LoopRangeMin = 3;

	public int LoopRangeMax = 5;

	public float NormalizedTransitionDuration;

	public IdleChance[] IdleTransitions = new IdleChance[0];

	public bool AllowRepeats;
}


using System;
using UnityEngine;

[Serializable]
public struct IdleChance
{
	public string StateName;

	[Range(0f, 100f)]
	public int Chance;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Ambience Definition")]
public class AmbienceDefinition : ScriptableObject
{
	[Serializable]
	public class ValueRange
	{
		public float min;

		public float max;

		public ValueRange(float min, float max)
		{
			this.min = min;
			this.max = max;
		}
	}

	[Header("Sound")]
	public List<SoundDefinition> sounds;

	[Horizontal(2, -1)]
	public ValueRange stingFrequency = new ValueRange(15f, 30f);

	[InspectorFlags]
	[Header("Environment")]
	public Enum biomes = (Enum)(-1);

	[InspectorFlags]
	public Enum topologies = (Enum)(-1);

	public EnvironmentType environmentType = EnvironmentType.Underground;

	public bool useEnvironmentType;

	public AnimationCurve time = AnimationCurve.Linear(0f, 0f, 24f, 0f);

	[Horizontal(2, -1)]
	public ValueRange rain = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange wind = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange snow = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange waves = new ValueRange(0f, 10f);
}


using System;

[Serializable]
public class ValueRange
{
	public float min;

	public float max;

	public ValueRange(float min, float max)
	{
		this.min = min;
		this.max = max;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Ambience Definition List")]
public class AmbienceDefinitionList : ScriptableObject
{
	public List<AmbienceDefinition> defs;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class AmbienceEmitter : MonoBehaviour, IClientComponent, IComparable<AmbienceEmitter>
{
	public AmbienceDefinitionList baseAmbience;

	public AmbienceDefinitionList stings;

	public bool isStatic = true;

	public bool followCamera;

	public bool isBaseEmitter;

	public bool active;

	public float cameraDistanceSq = float.PositiveInfinity;

	public BoundingSphere boundingSphere;

	public float crossfadeTime = 2f;

	public Dictionary<AmbienceDefinition, float> nextStingTime = new Dictionary<AmbienceDefinition, float>();

	public float deactivateTime = float.PositiveInfinity;

	public bool playUnderwater = true;

	public bool playAbovewater = true;

	public Enum currentTopology { get; private set; }

	public Enum currentBiome { get; private set; }

	public int CompareTo(AmbienceEmitter other)
	{
		return cameraDistanceSq.CompareTo(other.cameraDistanceSq);
	}
}


using UnityEngine;

public class AmbienceLocalStings : MonoBehaviour
{
	public float maxDistance = 100f;

	public float stingRadius = 10f;

	public float stingFrequency = 30f;

	public float stingFrequencyVariance = 15f;

	public SoundDefinition[] stingSounds;
}


using System;
using System.Collections.Generic;

public class AmbienceManager : SingletonComponent<AmbienceManager>, IClientComponent
{
	[Serializable]
	public class EmitterTypeLimit
	{
		public List<AmbienceDefinitionList> ambience;

		public int limit = 1;

		public int active;
	}

	public List<EmitterTypeLimit> localEmitterLimits = new List<EmitterTypeLimit>();

	public EmitterTypeLimit catchallEmitterLimit = new EmitterTypeLimit();

	public int maxActiveLocalEmitters = 5;

	public int activeLocalEmitters;

	public List<AmbienceEmitter> cameraEmitters = new List<AmbienceEmitter>();

	public List<AmbienceEmitter> emittersInRange = new List<AmbienceEmitter>();

	public List<AmbienceEmitter> activeEmitters = new List<AmbienceEmitter>();

	public float localEmitterRange = 30f;

	public List<AmbienceZone> currentAmbienceZones = new List<AmbienceZone>();

	public bool isUnderwater;

	public float ambienceZoneGain { get; private set; } = 1f;
}


using System;
using System.Collections.Generic;

[Serializable]
public class EmitterTypeLimit
{
	public List<AmbienceDefinitionList> ambience;

	public int limit = 1;

	public int active;
}


using UnityEngine;

public class AmbienceSpawnEmitters : MonoBehaviour, IClientComponent
{
	public int baseEmitterCount = 5;

	public int baseEmitterDistance = 10;

	public GameObjectRef emitterPrefab;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class AmbienceWaveSounds : SingletonComponent<AmbienceWaveSounds>, IClientComponent
{
	[Serializable]
	public class WaveLayer
	{
		public SoundDefinition soundDefinition;

		public AnimationCurve oceanScaleGainCurve;
	}

	public int emitterCount = 3;

	public float emitterDistance = 10f;

	public List<WaveLayer> waveLayers = new List<WaveLayer>();
}


using System;
using UnityEngine;

[Serializable]
public class WaveLayer
{
	public SoundDefinition soundDefinition;

	public AnimationCurve oceanScaleGainCurve;
}


using UnityEngine;

public class AmbienceWaveSoundZone : TriggerBase, IClientComponentEx
{
	public float priority;

	public float gain = 1f;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}
}


using UnityEngine;

public class AmbienceZone : TriggerBase, IClientComponentEx
{
	public AmbienceDefinitionList baseAmbience;

	public AmbienceDefinitionList stings;

	public float priority;

	public bool overrideCrossfadeTime;

	public float crossfadeTime = 1f;

	public float ambienceGain = 1f;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class RainSurfaceAmbience : SingletonComponent<RainSurfaceAmbience>, IClientComponent
{
	[Serializable]
	public class SurfaceSound
	{
		public AmbienceDefinitionList baseAmbience;

		public List<PhysicMaterial> materials = new List<PhysicMaterial>();
	}

	public List<SurfaceSound> surfaces = new List<SurfaceSound>();

	public GameObjectRef emitterPrefab;

	public Dictionary<ParticlePatch, AmbienceEmitter> spawnedEmitters = new Dictionary<ParticlePatch, AmbienceEmitter>();
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class SurfaceSound
{
	public AmbienceDefinitionList baseAmbience;

	public List<PhysicMaterial> materials = new List<PhysicMaterial>();
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Blended Engine Loop Definition")]
public class BlendedEngineLoopDefinition : ScriptableObject
{
	[Serializable]
	public class EngineLoopDefinition
	{
		public SoundDefinition soundDefinition;

		public float RPM;

		public float startRPM;

		public float startFullRPM;

		public float stopFullRPM;

		public float stopRPM;

		public float GetPitchForRPM(float targetRPM)
		{
			return targetRPM / RPM;
		}
	}

	public EngineLoopDefinition[] engineLoops;

	public float minRPM;

	public float maxRPM;

	public float RPMChangeRateUp = 0.5f;

	public float RPMChangeRateDown = 0.2f;
}


using System;

[Serializable]
public class EngineLoopDefinition
{
	public SoundDefinition soundDefinition;

	public float RPM;

	public float startRPM;

	public float startFullRPM;

	public float stopFullRPM;

	public float stopRPM;

	public float GetPitchForRPM(float targetRPM)
	{
		return targetRPM / RPM;
	}
}


using UnityEngine;

public class BlendedLoopEngineSound : MonoBehaviour, IClientComponent
{
	public class EngineLoop
	{
		public BlendedEngineLoopDefinition.EngineLoopDefinition definition;

		public BlendedLoopEngineSound parent;

		public Sound sound;

		public SoundModulation.Modulator gainMod;

		public SoundModulation.Modulator pitchMod;
	}

	public BlendedEngineLoopDefinition loopDefinition;

	public bool engineOn;

	[Range(0f, 1f)]
	public float RPMControl;

	public float smoothedRPMControl;

	private EngineLoop[] engineLoops;

	public bool debugPlayImmediately;

	public float maxDistance => loopDefinition.engineLoops[0].soundDefinition.maxDistance;

	public EngineLoop[] GetEngineLoops()
	{
		return engineLoops;
	}

	public float GetLoopGain(int idx)
	{
		if (engineLoops != null && engineLoops[idx] != null && engineLoops[idx].gainMod != null)
		{
			return engineLoops[idx].gainMod.value;
		}
		return 0f;
	}

	public float GetLoopPitch(int idx)
	{
		if (engineLoops != null && engineLoops[idx] != null && engineLoops[idx].pitchMod != null)
		{
			return engineLoops[idx].pitchMod.value;
		}
		return 0f;
	}
}


public class EngineLoop
{
	public BlendedEngineLoopDefinition.EngineLoopDefinition definition;

	public BlendedLoopEngineSound parent;

	public Sound sound;

	public SoundModulation.Modulator gainMod;

	public SoundModulation.Modulator pitchMod;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class BlendedSoundLoops : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class Loop
	{
		public SoundDefinition soundDef;

		public AnimationCurve gainCurve;

		public AnimationCurve pitchCurve;

		[HideInInspector]
		public Sound sound;

		[HideInInspector]
		public SoundModulation.Modulator gainMod;

		[HideInInspector]
		public SoundModulation.Modulator pitchMod;
	}

	[Range(0f, 1f)]
	public float blend;

	public float blendSmoothing = 1f;

	public float loopFadeOutTime = 0.5f;

	public float loopFadeInTime = 0.5f;

	public float gainModSmoothing = 1f;

	public float pitchModSmoothing = 1f;

	public bool shouldPlay = true;

	public float gain = 1f;

	public List<Loop> loops = new List<Loop>();

	public float maxDistance;
}


using System;
using UnityEngine;

[Serializable]
public class Loop
{
	public SoundDefinition soundDef;

	public AnimationCurve gainCurve;

	public AnimationCurve pitchCurve;

	[HideInInspector]
	public Sound sound;

	[HideInInspector]
	public SoundModulation.Modulator gainMod;

	[HideInInspector]
	public SoundModulation.Modulator pitchMod;
}


using UnityEngine;

public class BlendedSoundLoopSpeedControl : MonoBehaviour, IClientComponent
{
	public BlendedSoundLoops loops;

	public float speed;

	public float speedMax = 10f;
}


using System;
using System.Collections.Generic;
using Facepunch;
using JSON;
using UnityEngine;

public class EngineAudioClip : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class EngineCycle
	{
		public int RPM;

		public int startSample;

		public int endSample;

		public float period;

		public int id;

		public EngineCycle(int RPM, int startSample, int endSample, float period, int id)
		{
			this.RPM = RPM;
			this.startSample = startSample;
			this.endSample = endSample;
			this.period = period;
			this.id = id;
		}
	}

	public class EngineCycleBucket
	{
		public int RPM;

		public List<EngineCycle> cycles = new List<EngineCycle>();

		public List<int> remainingCycles = new List<int>();

		public EngineCycleBucket(int RPM)
		{
			this.RPM = RPM;
		}

		public EngineCycle GetCycle(Random random, int lastCycleId)
		{
			if (remainingCycles.Count == 0)
			{
				ResetRemainingCycles(random);
			}
			int index = Extensions.Pop<int>(remainingCycles);
			if (cycles[index].id == lastCycleId)
			{
				if (remainingCycles.Count == 0)
				{
					ResetRemainingCycles(random);
				}
				index = Extensions.Pop<int>(remainingCycles);
			}
			return cycles[index];
		}

		private void ResetRemainingCycles(Random random)
		{
			for (int i = 0; i < cycles.Count; i++)
			{
				remainingCycles.Add(i);
			}
			ListEx.Shuffle<int>(remainingCycles, (uint)random.Next());
		}

		public void Add(EngineCycle cycle)
		{
			if (!cycles.Contains(cycle))
			{
				cycles.Add(cycle);
			}
		}
	}

	public class Grain : IPooled
	{
		private float[] sourceData;

		private int startSample;

		private int currentSample;

		private int attackTimeSamples;

		private int sustainTimeSamples;

		private int releaseTimeSamples;

		private float gain;

		private float gainPerSampleAttack;

		private float gainPerSampleRelease;

		private int attackEndSample;

		private int releaseStartSample;

		private int endSample;

		public bool finished => currentSample >= endSample;

		public void Init(float[] source, EngineCycle cycle, int cyclePadding)
		{
			sourceData = source;
			startSample = cycle.startSample - cyclePadding;
			currentSample = startSample;
			attackTimeSamples = cyclePadding;
			sustainTimeSamples = cycle.endSample - cycle.startSample;
			releaseTimeSamples = cyclePadding;
			gainPerSampleAttack = 1f / (float)attackTimeSamples;
			gainPerSampleRelease = -1f / (float)releaseTimeSamples;
			attackEndSample = startSample + attackTimeSamples;
			releaseStartSample = attackEndSample + sustainTimeSamples;
			endSample = releaseStartSample + releaseTimeSamples;
			gain = 0f;
		}

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			sourceData = null;
			startSample = 0;
			currentSample = 0;
			attackTimeSamples = 0;
			sustainTimeSamples = 0;
			releaseTimeSamples = 0;
			gain = 0f;
			gainPerSampleAttack = 0f;
			gainPerSampleRelease = 0f;
			attackEndSample = 0;
			releaseStartSample = 0;
			endSample = 0;
		}

		public float GetSample()
		{
			if (currentSample >= sourceData.Length)
			{
				return 0f;
			}
			float num = sourceData[currentSample];
			if (currentSample <= attackEndSample)
			{
				gain += gainPerSampleAttack;
				if (gain > 0.8f)
				{
					gain = 0.8f;
				}
			}
			else if (currentSample >= releaseStartSample)
			{
				gain += gainPerSampleRelease;
				if (gain < 0f)
				{
					gain = 0f;
				}
			}
			currentSample++;
			return num * gain;
		}
	}

	public AudioClip granularClip;

	public AudioClip accelerationClip;

	public TextAsset accelerationCyclesJson;

	public List<EngineCycle> accelerationCycles = new List<EngineCycle>();

	public List<EngineCycleBucket> cycleBuckets = new List<EngineCycleBucket>();

	public Dictionary<int, EngineCycleBucket> accelerationCyclesByRPM = new Dictionary<int, EngineCycleBucket>();

	public Dictionary<int, int> rpmBucketLookup = new Dictionary<int, int>();

	public int sampleRate = 44100;

	public int samplesUntilNextGrain;

	public int lastCycleId;

	public List<Grain> grains = new List<Grain>();

	public int currentRPM;

	public int targetRPM = 1500;

	public int minRPM;

	public int maxRPM;

	public int cyclePadding;

	[Range(0f, 1f)]
	public float RPMControl;

	public AudioSource source;

	public float rpmLerpSpeed = 0.025f;

	public float rpmLerpSpeedDown = 0.01f;

	private int GetBucketRPM(int RPM)
	{
		return Mathf.RoundToInt((float)(RPM / 25)) * 25;
	}
}


using System;

[Serializable]
public class EngineCycle
{
	public int RPM;

	public int startSample;

	public int endSample;

	public float period;

	public int id;

	public EngineCycle(int RPM, int startSample, int endSample, float period, int id)
	{
		this.RPM = RPM;
		this.startSample = startSample;
		this.endSample = endSample;
		this.period = period;
		this.id = id;
	}
}


using System;
using System.Collections.Generic;
using JSON;

public class EngineCycleBucket
{
	public int RPM;

	public List<EngineCycle> cycles = new List<EngineCycle>();

	public List<int> remainingCycles = new List<int>();

	public EngineCycleBucket(int RPM)
	{
		this.RPM = RPM;
	}

	public EngineCycle GetCycle(Random random, int lastCycleId)
	{
		if (remainingCycles.Count == 0)
		{
			ResetRemainingCycles(random);
		}
		int index = Extensions.Pop<int>(remainingCycles);
		if (cycles[index].id == lastCycleId)
		{
			if (remainingCycles.Count == 0)
			{
				ResetRemainingCycles(random);
			}
			index = Extensions.Pop<int>(remainingCycles);
		}
		return cycles[index];
	}

	private void ResetRemainingCycles(Random random)
	{
		for (int i = 0; i < cycles.Count; i++)
		{
			remainingCycles.Add(i);
		}
		ListEx.Shuffle<int>(remainingCycles, (uint)random.Next());
	}

	public void Add(EngineCycle cycle)
	{
		if (!cycles.Contains(cycle))
		{
			cycles.Add(cycle);
		}
	}
}


using Facepunch;

public class Grain : IPooled
{
	private float[] sourceData;

	private int startSample;

	private int currentSample;

	private int attackTimeSamples;

	private int sustainTimeSamples;

	private int releaseTimeSamples;

	private float gain;

	private float gainPerSampleAttack;

	private float gainPerSampleRelease;

	private int attackEndSample;

	private int releaseStartSample;

	private int endSample;

	public bool finished => currentSample >= endSample;

	public void Init(float[] source, EngineCycle cycle, int cyclePadding)
	{
		sourceData = source;
		startSample = cycle.startSample - cyclePadding;
		currentSample = startSample;
		attackTimeSamples = cyclePadding;
		sustainTimeSamples = cycle.endSample - cycle.startSample;
		releaseTimeSamples = cyclePadding;
		gainPerSampleAttack = 1f / (float)attackTimeSamples;
		gainPerSampleRelease = -1f / (float)releaseTimeSamples;
		attackEndSample = startSample + attackTimeSamples;
		releaseStartSample = attackEndSample + sustainTimeSamples;
		endSample = releaseStartSample + releaseTimeSamples;
		gain = 0f;
	}

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		sourceData = null;
		startSample = 0;
		currentSample = 0;
		attackTimeSamples = 0;
		sustainTimeSamples = 0;
		releaseTimeSamples = 0;
		gain = 0f;
		gainPerSampleAttack = 0f;
		gainPerSampleRelease = 0f;
		attackEndSample = 0;
		releaseStartSample = 0;
		endSample = 0;
	}

	public float GetSample()
	{
		if (currentSample >= sourceData.Length)
		{
			return 0f;
		}
		float num = sourceData[currentSample];
		if (currentSample <= attackEndSample)
		{
			gain += gainPerSampleAttack;
			if (gain > 0.8f)
			{
				gain = 0.8f;
			}
		}
		else if (currentSample >= releaseStartSample)
		{
			gain += gainPerSampleRelease;
			if (gain < 0f)
			{
				gain = 0f;
			}
		}
		currentSample++;
		return num * gain;
	}
}


using UnityEngine;

public class FlybySound : MonoBehaviour, IClientComponent
{
	public SoundDefinition flybySound;

	public float flybySoundDistance = 7f;

	public SoundDefinition closeFlybySound;

	public float closeFlybyDistance = 3f;
}


using UnityEngine;

public class FootstepSound : MonoBehaviour, IClientComponent
{
	public enum Hardness
	{
		Light = 1,
		Medium,
		Hard
	}

	public SoundDefinition lightSound;

	public SoundDefinition medSound;

	public SoundDefinition hardSound;

	private const float panAmount = 0.05f;
}


public enum Hardness
{
	Light = 1,
	Medium,
	Hard
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class GranularAudioClip : MonoBehaviour
{
	public class Grain : IPooled
	{
		private float[] sourceData;

		private int sourceDataLength;

		private int startSample;

		private int currentSample;

		private int attackTimeSamples;

		private int sustainTimeSamples;

		private int releaseTimeSamples;

		private float gain;

		private float gainPerSampleAttack;

		private float gainPerSampleRelease;

		private int attackEndSample;

		private int releaseStartSample;

		private int endSample;

		public bool finished => currentSample >= endSample;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			sourceData = null;
			sourceDataLength = 0;
			startSample = 0;
			currentSample = 0;
			attackTimeSamples = 0;
			sustainTimeSamples = 0;
			releaseTimeSamples = 0;
			gain = 0f;
			gainPerSampleAttack = 0f;
			gainPerSampleRelease = 0f;
			attackEndSample = 0;
			releaseStartSample = 0;
			endSample = 0;
		}

		public void Init(float[] source, int start, int attack, int sustain, int release)
		{
			sourceData = source;
			sourceDataLength = sourceData.Length;
			startSample = start;
			currentSample = start;
			attackTimeSamples = attack;
			sustainTimeSamples = sustain;
			releaseTimeSamples = release;
			gainPerSampleAttack = 1f / (float)attackTimeSamples;
			gainPerSampleRelease = -1f / (float)releaseTimeSamples;
			attackEndSample = startSample + attackTimeSamples;
			releaseStartSample = attackEndSample + sustainTimeSamples;
			endSample = releaseStartSample + releaseTimeSamples;
			gain = 0f;
		}

		public float GetSample()
		{
			int num = currentSample % sourceDataLength;
			if (num < 0)
			{
				num += sourceDataLength;
			}
			float num2 = sourceData[num];
			if (currentSample <= attackEndSample)
			{
				gain += gainPerSampleAttack;
			}
			else if (currentSample >= releaseStartSample)
			{
				gain += gainPerSampleRelease;
			}
			currentSample++;
			return num2 * gain;
		}
	}

	public AudioClip sourceClip;

	private float[] sourceAudioData;

	private int sourceChannels = 1;

	public AudioClip granularClip;

	public int sampleRate = 44100;

	public float sourceTime = 0.5f;

	public float sourceTimeVariation = 0.1f;

	public float grainAttack = 0.1f;

	public float grainSustain = 0.1f;

	public float grainRelease = 0.1f;

	public float grainFrequency = 0.1f;

	public int grainAttackSamples;

	public int grainSustainSamples;

	public int grainReleaseSamples;

	public int grainFrequencySamples;

	public int samplesUntilNextGrain;

	public List<Grain> grains = new List<Grain>();

	private Random random = new Random();

	private bool inited;

	private void Update()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Invalid comparison between Unknown and I4
		if (!inited && (int)sourceClip.loadState == 2)
		{
			sampleRate = sourceClip.frequency;
			sourceAudioData = new float[sourceClip.samples * sourceClip.channels];
			sourceClip.GetData(sourceAudioData, 0);
			InitAudioClip();
			AudioSource component = ((Component)this).GetComponent<AudioSource>();
			component.clip = granularClip;
			component.loop = true;
			component.Play();
			inited = true;
		}
		RefreshCachedData();
	}

	private void RefreshCachedData()
	{
		grainAttackSamples = Mathf.FloorToInt(grainAttack * (float)sampleRate * (float)sourceChannels);
		grainSustainSamples = Mathf.FloorToInt(grainSustain * (float)sampleRate * (float)sourceChannels);
		grainReleaseSamples = Mathf.FloorToInt(grainRelease * (float)sampleRate * (float)sourceChannels);
		grainFrequencySamples = Mathf.FloorToInt(grainFrequency * (float)sampleRate * (float)sourceChannels);
	}

	private void InitAudioClip()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Expected O, but got Unknown
		int num = 1;
		int num2 = 1;
		AudioSettings.GetDSPBufferSize(ref num, ref num2);
		granularClip = AudioClip.Create(((Object)sourceClip).name + " (granular)", num, sourceClip.channels, sampleRate, true, new PCMReaderCallback(OnAudioRead));
		sourceChannels = sourceClip.channels;
	}

	private void OnAudioRead(float[] data)
	{
		for (int i = 0; i < data.Length; i++)
		{
			if (samplesUntilNextGrain <= 0)
			{
				SpawnGrain();
			}
			float num = 0f;
			for (int j = 0; j < grains.Count; j++)
			{
				num += grains[j].GetSample();
			}
			data[i] = num;
			samplesUntilNextGrain--;
		}
		CleanupFinishedGrains();
	}

	private void SpawnGrain()
	{
		if (grainFrequencySamples != 0)
		{
			float num = (float)(random.NextDouble() * (double)sourceTimeVariation * 2.0) - sourceTimeVariation;
			int start = Mathf.FloorToInt((sourceTime + num) * (float)sampleRate / (float)sourceChannels);
			Grain grain = Pool.Get<Grain>();
			grain.Init(sourceAudioData, start, grainAttackSamples, grainSustainSamples, grainReleaseSamples);
			grains.Add(grain);
			samplesUntilNextGrain = grainFrequencySamples;
		}
	}

	private void CleanupFinishedGrains()
	{
		for (int num = grains.Count - 1; num >= 0; num--)
		{
			Grain grain = grains[num];
			if (grain.finished)
			{
				Pool.Free<Grain>(ref grain);
				grains.RemoveAt(num);
			}
		}
	}
}


using Facepunch;

public class Grain : IPooled
{
	private float[] sourceData;

	private int sourceDataLength;

	private int startSample;

	private int currentSample;

	private int attackTimeSamples;

	private int sustainTimeSamples;

	private int releaseTimeSamples;

	private float gain;

	private float gainPerSampleAttack;

	private float gainPerSampleRelease;

	private int attackEndSample;

	private int releaseStartSample;

	private int endSample;

	public bool finished => currentSample >= endSample;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		sourceData = null;
		sourceDataLength = 0;
		startSample = 0;
		currentSample = 0;
		attackTimeSamples = 0;
		sustainTimeSamples = 0;
		releaseTimeSamples = 0;
		gain = 0f;
		gainPerSampleAttack = 0f;
		gainPerSampleRelease = 0f;
		attackEndSample = 0;
		releaseStartSample = 0;
		endSample = 0;
	}

	public void Init(float[] source, int start, int attack, int sustain, int release)
	{
		sourceData = source;
		sourceDataLength = sourceData.Length;
		startSample = start;
		currentSample = start;
		attackTimeSamples = attack;
		sustainTimeSamples = sustain;
		releaseTimeSamples = release;
		gainPerSampleAttack = 1f / (float)attackTimeSamples;
		gainPerSampleRelease = -1f / (float)releaseTimeSamples;
		attackEndSample = startSample + attackTimeSamples;
		releaseStartSample = attackEndSample + sustainTimeSamples;
		endSample = releaseStartSample + releaseTimeSamples;
		gain = 0f;
	}

	public float GetSample()
	{
		int num = currentSample % sourceDataLength;
		if (num < 0)
		{
			num += sourceDataLength;
		}
		float num2 = sourceData[num];
		if (currentSample <= attackEndSample)
		{
			gain += gainPerSampleAttack;
		}
		else if (currentSample >= releaseStartSample)
		{
			gain += gainPerSampleRelease;
		}
		currentSample++;
		return num2 * gain;
	}
}


public interface ISoundBudgetedUpdate
{
	void DoUpdate();

	bool IsSyncedToParent();
}


using UnityEngine.Audio;

public class MixerSnapshotManager : SingletonComponent<MixerSnapshotManager>, IClientComponent
{
	public AudioMixerSnapshot defaultSnapshot;

	public AudioMixerSnapshot underwaterSnapshot;

	public AudioMixerSnapshot loadingSnapshot;

	public AudioMixerSnapshot woundedSnapshot;

	public AudioMixerSnapshot cctvSnapshot;

	public AudioMixerSnapshot fadeToBlackSnapshot;

	public SoundDefinition underwaterInSound;

	public SoundDefinition underwaterOutSound;

	public AudioMixerSnapshot recordingSnapshot;

	public SoundDefinition woundedLoop;

	private Sound woundedLoopSound;

	public SoundDefinition cctvModeLoopDef;

	private Sound cctvModeLoop;

	public SoundDefinition cctvModeStartDef;

	public SoundDefinition cctvModeStopDef;

	public AudioMixerSnapshot predatorNearbySnapshot;

	public float deafness;
}


using UnityEngine;

public class MovementSoundTrigger : TriggerBase, IClientComponentEx, ILOD
{
	public SoundDefinition softSound;

	public SoundDefinition medSound;

	public SoundDefinition hardSound;

	public Collider collider;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)collider);
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class MusicChangeIntensity : MonoBehaviour
{
	[Serializable]
	public class DistanceIntensity
	{
		public float distance = 60f;

		public float raiseTo;

		public bool forceStartMusicInSuppressedMusicZones;
	}

	public float raiseTo;

	public List<DistanceIntensity> distanceIntensities = new List<DistanceIntensity>();

	public float tickInterval = 0.2f;
}


using System;

[Serializable]
public class DistanceIntensity
{
	public float distance = 60f;

	public float raiseTo;

	public bool forceStartMusicInSuppressedMusicZones;
}


using System.Collections.Generic;
using UnityEngine;

public class MusicClip : ScriptableObject
{
	public AudioClip audioClip;

	public int lengthInBars = 1;

	public int lengthInBarsWithTail;

	public List<float> fadeInPoints = new List<float>();

	public float GetNextFadeInPoint(float currentClipTimeBars)
	{
		if (fadeInPoints.Count == 0)
		{
			return currentClipTimeBars + 0.125f;
		}
		float result = -1f;
		float num = float.PositiveInfinity;
		for (int i = 0; i < fadeInPoints.Count; i++)
		{
			float num2 = fadeInPoints[i];
			float num3 = num2 - currentClipTimeBars;
			if (!(num2 <= 0.01f) && num3 > 0f && num3 < num)
			{
				num = num3;
				result = num2;
			}
		}
		return result;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class MusicClipLoader
{
	public class LoadedAudioClip : IPooled
	{
		public AudioClip clip;

		public float unloadTime;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			clip = null;
			unloadTime = 0f;
		}
	}

	public List<LoadedAudioClip> loadedClips = new List<LoadedAudioClip>();

	public Dictionary<AudioClip, LoadedAudioClip> loadedClipDict = new Dictionary<AudioClip, LoadedAudioClip>();

	public List<AudioClip> clipsToLoad = new List<AudioClip>();

	public List<AudioClip> clipsToUnload = new List<AudioClip>();

	public void Update()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Invalid comparison between Unknown and I4
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Invalid comparison between Unknown and I4
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Invalid comparison between Unknown and I4
		for (int num = clipsToLoad.Count - 1; num >= 0; num--)
		{
			AudioClip val = clipsToLoad[num];
			if ((int)val.loadState != 2 && (int)val.loadState != 1)
			{
				val.LoadAudioData();
				clipsToLoad.RemoveAt(num);
				return;
			}
		}
		for (int num2 = clipsToUnload.Count - 1; num2 >= 0; num2--)
		{
			AudioClip val2 = clipsToUnload[num2];
			if ((int)val2.loadState == 2)
			{
				val2.UnloadAudioData();
				clipsToUnload.RemoveAt(num2);
				break;
			}
		}
	}

	public void Refresh()
	{
		for (int i = 0; i < SingletonComponent<MusicManager>.Instance.activeMusicClips.Count; i++)
		{
			MusicTheme.PositionedClip positionedClip = SingletonComponent<MusicManager>.Instance.activeMusicClips[i];
			LoadedAudioClip loadedAudioClip = FindLoadedClip(positionedClip.musicClip.audioClip);
			if (loadedAudioClip == null)
			{
				loadedAudioClip = Pool.Get<LoadedAudioClip>();
				loadedAudioClip.clip = positionedClip.musicClip.audioClip;
				loadedAudioClip.unloadTime = (float)AudioSettings.dspTime + loadedAudioClip.clip.length + 1f;
				loadedClips.Add(loadedAudioClip);
				loadedClipDict.Add(loadedAudioClip.clip, loadedAudioClip);
				clipsToLoad.Add(loadedAudioClip.clip);
			}
			else
			{
				loadedAudioClip.unloadTime = (float)AudioSettings.dspTime + loadedAudioClip.clip.length + 1f;
				clipsToUnload.Remove(loadedAudioClip.clip);
			}
		}
		for (int num = loadedClips.Count - 1; num >= 0; num--)
		{
			LoadedAudioClip loadedAudioClip2 = loadedClips[num];
			if (AudioSettings.dspTime > (double)loadedAudioClip2.unloadTime)
			{
				clipsToUnload.Add(loadedAudioClip2.clip);
				loadedClips.Remove(loadedAudioClip2);
				loadedClipDict.Remove(loadedAudioClip2.clip);
				Pool.Free<LoadedAudioClip>(ref loadedAudioClip2);
			}
		}
	}

	private LoadedAudioClip FindLoadedClip(AudioClip clip)
	{
		if (loadedClipDict.ContainsKey(clip))
		{
			return loadedClipDict[clip];
		}
		return null;
	}
}


using Facepunch;
using UnityEngine;

public class LoadedAudioClip : IPooled
{
	public AudioClip clip;

	public float unloadTime;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		clip = null;
		unloadTime = 0f;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.Audio;

public class MusicManager : SingletonComponent<MusicManager>, IClientComponent
{
	[Serializable]
	public class ClipPlaybackData : IPooled
	{
		public AudioSource source;

		public MusicTheme.PositionedClip positionedClip;

		public bool isActive;

		public bool fadingIn;

		public bool fadingOut;

		public double fadeStarted;

		public bool needsSync;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			source = null;
			positionedClip = null;
			isActive = false;
			fadingIn = false;
			fadingOut = false;
			fadeStarted = 0.0;
			needsSync = false;
		}
	}

	public AudioMixerGroup mixerGroup;

	public List<MusicTheme> themes;

	public MusicTheme currentTheme;

	public List<AudioSource> sources = new List<AudioSource>();

	public double nextMusic;

	public double nextMusicFromIntensityRaise;

	[Range(0f, 1f)]
	public float intensity;

	public Dictionary<MusicTheme.PositionedClip, ClipPlaybackData> clipPlaybackData = new Dictionary<MusicTheme.PositionedClip, ClipPlaybackData>();

	public int holdIntensityUntilBar;

	public bool musicPlaying;

	public bool loadingFirstClips;

	public MusicTheme nextTheme;

	public double lastClipUpdate;

	public float clipUpdateInterval = 0.1f;

	public double themeStartTime;

	public int lastActiveClipRefresh = -10;

	public int activeClipRefreshInterval = 1;

	public bool forceThemeChange;

	public float randomIntensityJumpChance;

	public int clipScheduleBarsEarly = 1;

	public List<MusicTheme.PositionedClip> activeClips = new List<MusicTheme.PositionedClip>();

	public List<MusicTheme.PositionedClip> activeMusicClips = new List<MusicTheme.PositionedClip>();

	public List<MusicTheme.PositionedClip> activeControlClips = new List<MusicTheme.PositionedClip>();

	public List<MusicZone> currentMusicZones = new List<MusicZone>();

	public int currentBar;

	public int barOffset;

	public double currentThemeTime => AudioSettings.dspTime - themeStartTime;

	public int themeBar => currentBar + barOffset;

	public static void RaiseIntensityTo(float amount, int holdLengthBars = 0)
	{
	}

	public void StopMusic()
	{
	}
}


using System;
using Facepunch;
using UnityEngine;

[Serializable]
public class ClipPlaybackData : IPooled
{
	public AudioSource source;

	public MusicTheme.PositionedClip positionedClip;

	public bool isActive;

	public bool fadingIn;

	public bool fadingOut;

	public double fadeStarted;

	public bool needsSync;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		source = null;
		positionedClip = null;
		isActive = false;
		fadingIn = false;
		fadingOut = false;
		fadeStarted = 0.0;
		needsSync = false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MusicTheme")]
public class MusicTheme : ScriptableObject
{
	[Serializable]
	public class Layer
	{
		public string name = "layer";
	}

	[Serializable]
	public class PositionedClip
	{
		public MusicTheme theme;

		public MusicClip musicClip;

		public int startingBar;

		public int layerId;

		public float minIntensity;

		public float maxIntensity = 1f;

		public bool allowFadeIn = true;

		public bool allowFadeOut = true;

		public float fadeInTime = 1f;

		public float fadeOutTime = 0.5f;

		public float intensityReduction;

		public int jumpBarCount;

		public float jumpMinimumIntensity = 0.5f;

		public float jumpMaximumIntensity = 0.5f;

		public int endingBar
		{
			get
			{
				if (!((Object)(object)musicClip == (Object)null))
				{
					return startingBar + musicClip.lengthInBarsWithTail;
				}
				return startingBar;
			}
		}

		public bool isControlClip => (Object)(object)musicClip == (Object)null;

		public bool CanPlay(float intensity)
		{
			if (intensity > minIntensity || (minIntensity == 0f && intensity == 0f))
			{
				return intensity <= maxIntensity;
			}
			return false;
		}

		public void CopySettingsFrom(PositionedClip otherClip)
		{
			if (isControlClip == otherClip.isControlClip && otherClip != this)
			{
				allowFadeIn = otherClip.allowFadeIn;
				fadeInTime = otherClip.fadeInTime;
				allowFadeOut = otherClip.allowFadeOut;
				fadeOutTime = otherClip.fadeOutTime;
				maxIntensity = otherClip.maxIntensity;
				minIntensity = otherClip.minIntensity;
				intensityReduction = otherClip.intensityReduction;
			}
		}
	}

	[Serializable]
	public class ValueRange
	{
		public float min;

		public float max;

		public ValueRange(float min, float max)
		{
			this.min = min;
			this.max = max;
		}
	}

	[Header("Basic info")]
	public float tempo = 80f;

	public int intensityHoldBars = 4;

	public int lengthInBars;

	[Header("Playback restrictions")]
	public bool canPlayInMenus = true;

	[Horizontal(2, -1)]
	public ValueRange rain = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange wind = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange snow = new ValueRange(0f, 1f);

	[InspectorFlags]
	public Enum biomes = (Enum)(-1);

	[InspectorFlags]
	public Enum topologies = (Enum)(-1);

	public AnimationCurve time = AnimationCurve.Linear(0f, 0f, 24f, 0f);

	[Header("Clip data")]
	public List<PositionedClip> clips = new List<PositionedClip>();

	public List<Layer> layers = new List<Layer>();

	private Dictionary<int, List<PositionedClip>> activeClips = new Dictionary<int, List<PositionedClip>>();

	private List<AudioClip> firstAudioClips = new List<AudioClip>();

	private Dictionary<AudioClip, bool> audioClipDict = new Dictionary<AudioClip, bool>();

	public int layerCount => layers.Count;

	public int samplesPerBar => MusicUtil.BarsToSamples(tempo, 1f, 44100);

	private void OnValidate()
	{
		audioClipDict.Clear();
		activeClips.Clear();
		UpdateLengthInBars();
		for (int i = 0; i < clips.Count; i++)
		{
			PositionedClip positionedClip = clips[i];
			int num = ActiveClipCollectionID(positionedClip.startingBar - 8);
			int num2 = ActiveClipCollectionID(positionedClip.endingBar);
			for (int j = num; j <= num2; j++)
			{
				if (!activeClips.ContainsKey(j))
				{
					activeClips.Add(j, new List<PositionedClip>());
				}
				if (!activeClips[j].Contains(positionedClip))
				{
					activeClips[j].Add(positionedClip);
				}
			}
			if ((Object)(object)positionedClip.musicClip != (Object)null)
			{
				AudioClip audioClip = positionedClip.musicClip.audioClip;
				if (!audioClipDict.ContainsKey(audioClip))
				{
					audioClipDict.Add(audioClip, value: true);
				}
				if (positionedClip.startingBar < 8 && !firstAudioClips.Contains(audioClip))
				{
					firstAudioClips.Add(audioClip);
				}
				positionedClip.musicClip.lengthInBarsWithTail = Mathf.CeilToInt(MusicUtil.SecondsToBars(tempo, positionedClip.musicClip.audioClip.length));
			}
		}
	}

	public List<PositionedClip> GetActiveClipsForBar(int bar)
	{
		int key = ActiveClipCollectionID(bar);
		if (!activeClips.ContainsKey(key))
		{
			return null;
		}
		return activeClips[key];
	}

	private int ActiveClipCollectionID(int bar)
	{
		return Mathf.FloorToInt(Mathf.Max((float)(bar / 4), 0f));
	}

	public Layer LayerById(int id)
	{
		if (layers.Count <= id)
		{
			return null;
		}
		return layers[id];
	}

	public void AddLayer()
	{
		Layer layer = new Layer();
		layer.name = "layer " + layers.Count;
		layers.Add(layer);
	}

	private void UpdateLengthInBars()
	{
		int num = 0;
		for (int i = 0; i < clips.Count; i++)
		{
			PositionedClip positionedClip = clips[i];
			if (!((Object)(object)positionedClip.musicClip == (Object)null))
			{
				int num2 = positionedClip.startingBar + positionedClip.musicClip.lengthInBars;
				if (num2 > num)
				{
					num = num2;
				}
			}
		}
		lengthInBars = num;
	}

	public bool CanPlayInEnvironment(int currentBiome, int currentTopology, float currentRain, float currentSnow, float currentWind)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Invalid comparison between Unknown and I4
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Invalid comparison between Unknown and I4
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance) && time.Evaluate(TOD_Sky.Instance.Cycle.Hour) < 0f)
		{
			return false;
		}
		if ((int)biomes != -1 && (biomes & currentBiome) == 0)
		{
			return false;
		}
		if ((int)topologies != -1 && (topologies & currentTopology) != 0)
		{
			return false;
		}
		if (((rain.min > 0f || rain.max < 1f) && currentRain < rain.min) || currentRain > rain.max)
		{
			return false;
		}
		if (((snow.min > 0f || snow.max < 1f) && currentSnow < snow.min) || currentSnow > snow.max)
		{
			return false;
		}
		if (((wind.min > 0f || wind.max < 1f) && currentWind < wind.min) || currentWind > wind.max)
		{
			return false;
		}
		return true;
	}

	public bool FirstClipsLoaded()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		for (int i = 0; i < firstAudioClips.Count; i++)
		{
			if ((int)firstAudioClips[i].loadState != 2)
			{
				return false;
			}
		}
		return true;
	}

	public bool ContainsAudioClip(AudioClip clip)
	{
		return audioClipDict.ContainsKey(clip);
	}
}


using System;

[Serializable]
public class Layer
{
	public string name = "layer";
}


using System;
using UnityEngine;

[Serializable]
public class PositionedClip
{
	public MusicTheme theme;

	public MusicClip musicClip;

	public int startingBar;

	public int layerId;

	public float minIntensity;

	public float maxIntensity = 1f;

	public bool allowFadeIn = true;

	public bool allowFadeOut = true;

	public float fadeInTime = 1f;

	public float fadeOutTime = 0.5f;

	public float intensityReduction;

	public int jumpBarCount;

	public float jumpMinimumIntensity = 0.5f;

	public float jumpMaximumIntensity = 0.5f;

	public int endingBar
	{
		get
		{
			if (!((Object)(object)musicClip == (Object)null))
			{
				return startingBar + musicClip.lengthInBarsWithTail;
			}
			return startingBar;
		}
	}

	public bool isControlClip => (Object)(object)musicClip == (Object)null;

	public bool CanPlay(float intensity)
	{
		if (intensity > minIntensity || (minIntensity == 0f && intensity == 0f))
		{
			return intensity <= maxIntensity;
		}
		return false;
	}

	public void CopySettingsFrom(PositionedClip otherClip)
	{
		if (isControlClip == otherClip.isControlClip && otherClip != this)
		{
			allowFadeIn = otherClip.allowFadeIn;
			fadeInTime = otherClip.fadeInTime;
			allowFadeOut = otherClip.allowFadeOut;
			fadeOutTime = otherClip.fadeOutTime;
			maxIntensity = otherClip.maxIntensity;
			minIntensity = otherClip.minIntensity;
			intensityReduction = otherClip.intensityReduction;
		}
	}
}


using System;

[Serializable]
public class ValueRange
{
	public float min;

	public float max;

	public ValueRange(float min, float max)
	{
		this.min = min;
		this.max = max;
	}
}


using UnityEngine;

public class MusicUtil
{
	public const float OneSixteenth = 0.0625f;

	public static double BeatsToSeconds(float tempo, float beats)
	{
		return 60.0 / (double)tempo * (double)beats;
	}

	public static double BarsToSeconds(float tempo, float bars)
	{
		return BeatsToSeconds(tempo, bars * 4f);
	}

	public static int SecondsToSamples(double seconds)
	{
		return SecondsToSamples(seconds, AudioSettings.outputSampleRate);
	}

	public static int SecondsToSamples(double seconds, int sampleRate)
	{
		return (int)((double)sampleRate * seconds);
	}

	public static int SecondsToSamples(float seconds)
	{
		return SecondsToSamples(seconds, AudioSettings.outputSampleRate);
	}

	public static int SecondsToSamples(float seconds, int sampleRate)
	{
		return (int)((float)sampleRate * seconds);
	}

	public static int BarsToSamples(float tempo, float bars, int sampleRate)
	{
		return SecondsToSamples(BarsToSeconds(tempo, bars), sampleRate);
	}

	public static int BarsToSamples(float tempo, float bars)
	{
		return SecondsToSamples(BarsToSeconds(tempo, bars));
	}

	public static int BeatsToSamples(float tempo, float beats)
	{
		return SecondsToSamples(BeatsToSeconds(tempo, beats));
	}

	public static float SecondsToBeats(float tempo, double seconds)
	{
		return tempo / 60f * (float)seconds;
	}

	public static float SecondsToBars(float tempo, double seconds)
	{
		return SecondsToBeats(tempo, seconds) / 4f;
	}

	public static float Quantize(float position, float gridSize)
	{
		return Mathf.Round(position / gridSize) * gridSize;
	}

	public static float FlooredQuantize(float position, float gridSize)
	{
		return Mathf.Floor(position / gridSize) * gridSize;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class MusicZone : MonoBehaviour, IClientComponent
{
	public List<MusicTheme> themes;

	public float priority;

	public bool suppressAutomaticMusic;

	public bool startOnEnter;
}


using UnityEngine;

public class OnePoleLowpassFilter : MonoBehaviour
{
	[Range(10f, 20000f)]
	public float frequency = 20000f;
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Reverb Settings")]
public class ReverbSettings : ScriptableObject
{
	[Range(-10000f, 0f)]
	public int room;

	[Range(-10000f, 0f)]
	public int roomHF;

	[Range(-10000f, 0f)]
	public int roomLF;

	[Range(0.1f, 20f)]
	public float decayTime;

	[Range(0.1f, 2f)]
	public float decayHFRatio;

	[Range(-10000f, 1000f)]
	public int reflections;

	[Range(0f, 0.3f)]
	public float reflectionsDelay;

	[Range(-10000f, 2000f)]
	public int reverb;

	[Range(0f, 0.1f)]
	public float reverbDelay;

	[Range(1000f, 20000f)]
	public float HFReference;

	[Range(20f, 1000f)]
	public float LFReference;

	[Range(0f, 100f)]
	public float diffusion;

	[Range(0f, 100f)]
	public float density;
}


using UnityEngine;

public class ReverbZoneTrigger : TriggerBase, IClientComponentEx, ILOD
{
	public Collider trigger;

	public AudioReverbZone reverbZone;

	public float lodDistance = 100f;

	public bool inRange;

	public ReverbSettings reverbSettings;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)trigger);
		p.RemoveComponent((Component)(object)reverbZone);
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}

	public bool IsSyncedToParent()
	{
		return false;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ShoutcastStreamer : MonoBehaviour, IClientComponent
{
	public string Host = "http://listen.57fm.com:80/rcxmas";

	public AudioSource Source;

	public static RadioPlaylist[] BuiltinRadios;

	public static Dictionary<string, string> ParsedLocalRadioList;

	public static void CheckBuiltInRadios()
	{
		if (BuiltinRadios == null)
		{
			BuiltinRadios = FileSystem.LoadAll<RadioPlaylist>("assets/prefabs/voiceaudio/boombox/sound/builtinplaylists", "");
			ParsedLocalRadioList = new Dictionary<string, string>();
			RadioPlaylist[] builtinRadios = BuiltinRadios;
			foreach (RadioPlaylist radioPlaylist in builtinRadios)
			{
				ParsedLocalRadioList.Add(radioPlaylist.LocalName, radioPlaylist.Url);
			}
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SlicedGranularAudioClip : MonoBehaviour, IClientComponent
{
	public class Grain : IPooled
	{
		private float[] sourceData;

		private int startSample;

		private int currentSample;

		private int attackTimeSamples;

		private int sustainTimeSamples;

		private int releaseTimeSamples;

		private float gain;

		private float gainPerSampleAttack;

		private float gainPerSampleRelease;

		private int attackEndSample;

		private int releaseStartSample;

		private int endSample;

		public bool finished => currentSample >= endSample;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			sourceData = null;
			startSample = 0;
			currentSample = 0;
			attackTimeSamples = 0;
			sustainTimeSamples = 0;
			releaseTimeSamples = 0;
			gain = 0f;
			gainPerSampleAttack = 0f;
			gainPerSampleRelease = 0f;
			attackEndSample = 0;
			releaseStartSample = 0;
			endSample = 0;
		}

		public void Init(float[] source, int start, int attack, int sustain, int release)
		{
			sourceData = source;
			startSample = start;
			currentSample = start;
			attackTimeSamples = attack;
			sustainTimeSamples = sustain;
			releaseTimeSamples = release;
			gainPerSampleAttack = 0.5f / (float)attackTimeSamples;
			gainPerSampleRelease = -0.5f / (float)releaseTimeSamples;
			attackEndSample = startSample + attackTimeSamples;
			releaseStartSample = attackEndSample + sustainTimeSamples;
			endSample = releaseStartSample + releaseTimeSamples;
			gain = 0f;
		}

		public float GetSample()
		{
			if (currentSample >= sourceData.Length)
			{
				return 0f;
			}
			float num = sourceData[currentSample];
			if (currentSample <= attackEndSample)
			{
				gain += gainPerSampleAttack;
				if (gain > 0.5f)
				{
					gain = 0.5f;
				}
			}
			else if (currentSample >= releaseStartSample)
			{
				gain += gainPerSampleRelease;
				if (gain < 0f)
				{
					gain = 0f;
				}
			}
			currentSample++;
			return num * gain;
		}

		public void FadeOut()
		{
			releaseStartSample = currentSample;
			endSample = releaseStartSample + releaseTimeSamples;
		}
	}

	public AudioSource source;

	public AudioClip sourceClip;

	public AudioClip granularClip;

	public int sampleRate = 44100;

	public float grainAttack = 0.1f;

	public float grainSustain = 0.1f;

	public float grainRelease = 0.1f;

	public float grainFrequency = 0.1f;

	public int grainAttackSamples;

	public int grainSustainSamples;

	public int grainReleaseSamples;

	public int grainFrequencySamples;

	public int samplesUntilNextGrain;

	public List<Grain> grains = new List<Grain>();

	public List<int> startPositions = new List<int>();

	public int lastStartPositionIdx = int.MaxValue;

	public bool playOnAwake = true;
}


using Facepunch;

public class Grain : IPooled
{
	private float[] sourceData;

	private int startSample;

	private int currentSample;

	private int attackTimeSamples;

	private int sustainTimeSamples;

	private int releaseTimeSamples;

	private float gain;

	private float gainPerSampleAttack;

	private float gainPerSampleRelease;

	private int attackEndSample;

	private int releaseStartSample;

	private int endSample;

	public bool finished => currentSample >= endSample;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		sourceData = null;
		startSample = 0;
		currentSample = 0;
		attackTimeSamples = 0;
		sustainTimeSamples = 0;
		releaseTimeSamples = 0;
		gain = 0f;
		gainPerSampleAttack = 0f;
		gainPerSampleRelease = 0f;
		attackEndSample = 0;
		releaseStartSample = 0;
		endSample = 0;
	}

	public void Init(float[] source, int start, int attack, int sustain, int release)
	{
		sourceData = source;
		startSample = start;
		currentSample = start;
		attackTimeSamples = attack;
		sustainTimeSamples = sustain;
		releaseTimeSamples = release;
		gainPerSampleAttack = 0.5f / (float)attackTimeSamples;
		gainPerSampleRelease = -0.5f / (float)releaseTimeSamples;
		attackEndSample = startSample + attackTimeSamples;
		releaseStartSample = attackEndSample + sustainTimeSamples;
		endSample = releaseStartSample + releaseTimeSamples;
		gain = 0f;
	}

	public float GetSample()
	{
		if (currentSample >= sourceData.Length)
		{
			return 0f;
		}
		float num = sourceData[currentSample];
		if (currentSample <= attackEndSample)
		{
			gain += gainPerSampleAttack;
			if (gain > 0.5f)
			{
				gain = 0.5f;
			}
		}
		else if (currentSample >= releaseStartSample)
		{
			gain += gainPerSampleRelease;
			if (gain < 0f)
			{
				gain = 0f;
			}
		}
		currentSample++;
		return num * gain;
	}

	public void FadeOut()
	{
		releaseStartSample = currentSample;
		endSample = releaseStartSample + releaseTimeSamples;
	}
}


using UnityEngine;

public class Sound : MonoBehaviour, IClientComponent
{
	public static float volumeExponent = Mathf.Log(Mathf.Sqrt(10f), 2f);

	public SoundDefinition definition;

	public SoundModifier[] modifiers;

	public SoundSource soundSource;

	public AudioSource[] audioSources = (AudioSource[])(object)new AudioSource[2];

	[SerializeField]
	private SoundFade _fade;

	[SerializeField]
	private SoundModulation _modulation;

	[SerializeField]
	private SoundOcclusion _occlusion;

	public SoundFade fade => _fade;

	public SoundModulation modulation => _modulation;

	public SoundOcclusion occlusion => _occlusion;
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

[CreateAssetMenu(menuName = "Rust/Sound Class")]
public class SoundClass : ScriptableObject
{
	[Header("Mixer Settings")]
	public AudioMixerGroup output;

	public AudioMixerGroup firstPersonOutput;

	[Header("Occlusion Settings")]
	public bool enableOcclusion;

	public bool playIfOccluded = true;

	public float occlusionGain = 1f;

	[Tooltip("Use this mixer group when the sound is occluded to save DSP CPU usage. Only works for non-looping sounds.")]
	public AudioMixerGroup occludedOutput;

	[Header("Voice Limiting")]
	public int globalVoiceMaxCount = 100;

	public int priority = 128;

	public List<SoundDefinition> definitions = new List<SoundDefinition>();
}


using UnityEngine;

public class SoundClassTest : MonoBehaviour
{
	public SoundClass soundClass;

	public float soundInterval = 0.5f;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SoundDefinition : ScriptableObject
{
	[Serializable]
	public class DistanceAudioClipList
	{
		public int distance;

		[Horizontal(2, -1)]
		public List<WeightedAudioClip> audioClips;
	}

	public GameObjectRef template;

	[Horizontal(2, -1)]
	public List<WeightedAudioClip> weightedAudioClips = new List<WeightedAudioClip>
	{
		new WeightedAudioClip()
	};

	public List<DistanceAudioClipList> distanceAudioClips;

	public SoundClass soundClass;

	public bool defaultToFirstPerson;

	public bool loop;

	public bool randomizeStartPosition;

	public bool useHighQualityFades;

	[Range(0f, 1f)]
	public float volume = 1f;

	[Range(0f, 1f)]
	public float volumeVariation;

	[Range(-3f, 3f)]
	public float pitch = 1f;

	[Range(0f, 1f)]
	public float pitchVariation;

	[Header("Voice limiting")]
	public bool dontVoiceLimit;

	public int globalVoiceMaxCount = 100;

	public int localVoiceMaxCount = 100;

	public float localVoiceRange = 10f;

	public float voiceLimitFadeOutTime = 0.05f;

	public float localVoiceDebounceTime = 0.1f;

	[Header("Occlusion Settings")]
	public bool forceOccludedPlayback;

	[Header("Doppler")]
	public bool enableDoppler;

	public float dopplerAmount = 0.18f;

	public float dopplerScale = 1f;

	public float dopplerAdjustmentRate = 1f;

	[Header("Custom curves")]
	public AnimationCurve falloffCurve;

	public bool useCustomFalloffCurve;

	public AnimationCurve spatialBlendCurve;

	public bool useCustomSpatialBlendCurve;

	public AnimationCurve spreadCurve;

	public bool useCustomSpreadCurve;

	public float maxDistance
	{
		get
		{
			if (template == null)
			{
				return 0f;
			}
			AudioSource component = template.Get().GetComponent<AudioSource>();
			if ((Object)(object)component == (Object)null)
			{
				return 0f;
			}
			return component.maxDistance;
		}
	}

	public float GetLength()
	{
		float num = 0f;
		for (int i = 0; i < weightedAudioClips.Count; i++)
		{
			AudioClip audioClip = weightedAudioClips[i].audioClip;
			if (Object.op_Implicit((Object)(object)audioClip))
			{
				num = Mathf.Max(audioClip.length, num);
			}
		}
		for (int j = 0; j < distanceAudioClips.Count; j++)
		{
			List<WeightedAudioClip> audioClips = distanceAudioClips[j].audioClips;
			for (int k = 0; k < audioClips.Count; k++)
			{
				AudioClip audioClip2 = audioClips[k].audioClip;
				if (Object.op_Implicit((Object)(object)audioClip2))
				{
					num = Mathf.Max(audioClip2.length, num);
				}
			}
		}
		float num2 = 1f / (pitch - pitchVariation);
		return num * num2;
	}

	public Sound Play()
	{
		return null;
	}

	public Sound Play(GameObject forGameObject)
	{
		return null;
	}
}


using System;
using System.Collections.Generic;

[Serializable]
public class DistanceAudioClipList
{
	public int distance;

	[Horizontal(2, -1)]
	public List<WeightedAudioClip> audioClips;
}


using UnityEngine;

public class SoundFade : MonoBehaviour, IClientComponent
{
	public enum Direction
	{
		In,
		Out
	}

	public SoundFadeHQAudioFilter hqFadeFilter;

	public float currentGain = 1f;

	public float startingGain;

	public float finalGain = 1f;

	public int sampleRate = 44100;

	public bool highQualityFadeCompleted;

	public float length;

	public Direction currentDirection;
}


public enum Direction
{
	In,
	Out
}


using UnityEngine;

public class SoundFadeHQAudioFilter : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class SoundFollowCollider : MonoBehaviour, IClientComponent
{
	public SoundDefinition soundDefinition;

	public Sound sound;

	public Bounds soundFollowBounds;

	public bool startImmediately;
}


public class SoundManager : SingletonComponent<SoundManager>, IClientComponent
{
	public SoundClass defaultSoundClass;
}


using UnityEngine;

public class SoundModifier : MonoBehaviour
{
	[HideInInspector]
	public Sound sound;
}


using System;
using Facepunch;
using UnityEngine;

public class SoundModulation : MonoBehaviour, IClientComponent
{
	public enum Parameter
	{
		Gain,
		Pitch,
		Spread,
		MaxDistance
	}

	[Serializable]
	public class Modulator : IPooled
	{
		public Parameter param;

		public float value = 1f;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			param = Parameter.Gain;
			value = 1f;
		}
	}

	private const int parameterCount = 4;
}


public enum Parameter
{
	Gain,
	Pitch,
	Spread,
	MaxDistance
}


using System;
using Facepunch;

[Serializable]
public class Modulator : IPooled
{
	public Parameter param;

	public float value = 1f;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		param = Parameter.Gain;
		value = 1f;
	}
}


using UnityEngine;

public class SoundOcclusion : MonoBehaviour
{
	public LayerMask occlusionLayerMask;
}


using UnityEngine;

public class SoundPlayer : BaseMonoBehaviour, IClientComponent
{
	public SoundDefinition soundDefinition;

	public bool playImmediately = true;

	public float minStartDelay;

	public float maxStartDelay;

	public bool debugRepeat;

	public bool pending;

	public Vector3 soundOffset = Vector3.zero;
}


using UnityEngine;

public class SoundPlayerCull : MonoBehaviour, IClientComponent, ILOD
{
	public SoundPlayer soundPlayer;

	public float cullDistance = 100f;
}


using UnityEngine;

public class SoundPlayerCullLODComponent : LODComponent
{
	public float Distance = 100f;

	public SoundPlayer TargetSoundPlayer;

	private void OnValidate()
	{
		if ((Object)(object)TargetSoundPlayer == (Object)null)
		{
			TargetSoundPlayer = ((Component)this).GetComponent<SoundPlayer>();
		}
	}
}


public class SoundRandomizer
{
}


using UnityEngine;

[RequireComponent(typeof(SoundPlayer))]
public class SoundRepeater : MonoBehaviour
{
	public float interval = 5f;

	public SoundPlayer player;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SoundSource : MonoBehaviour, IClientComponentEx, ILOD
{
	[Serializable]
	public class OcclusionPoint
	{
		public Vector3 offset = Vector3.zero;

		public bool isOccluded;
	}

	[Header("Occlusion")]
	public bool handleOcclusionChecks;

	public LayerMask occlusionLayerMask;

	public List<OcclusionPoint> occlusionPoints = new List<OcclusionPoint>();

	public bool isOccluded;

	public float occlusionAmount;

	public float lodDistance = 100f;

	public bool inRange;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)this);
	}

	public bool IsSyncedToParent()
	{
		return false;
	}
}


using System;
using UnityEngine;

[Serializable]
public class OcclusionPoint
{
	public Vector3 offset = Vector3.zero;

	public bool isOccluded;
}


using UnityEngine;

public class SoundVoiceLimiter : MonoBehaviour, IClientComponent
{
	public int maxSimultaneousSounds = 5;
}


using UnityEngine;

public class TimeBasedSoundSpread : SoundModifier
{
	public AnimationCurve spreadCurve;

	public AnimationCurve wanderIntensityCurve;
}


using System;
using UnityEngine;

[Serializable]
public class WeightedAudioClip
{
	public AudioClip audioClip;

	public int weight = 1;
}


using System;

public class AttractionPoint : PrefabAttribute
{
	public string groupName;

	protected override Type GetIndexedType()
	{
		return typeof(AttractionPoint);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BuildingProximity : PrefabAttribute
{
	public struct ProximityInfo
	{
		public bool hit;

		public bool connection;

		public Line line;

		public float sqrDist;
	}

	private const float check_radius = 2f;

	private const float check_forgiveness = 0.01f;

	private const float foundation_width = 3f;

	private const float foundation_extents = 1.5f;

	public static bool Check(BasePlayer player, Construction construction, Vector3 position, Quaternion rotation)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(position, rotation, construction.bounds);
		float radius = ((Vector3)(ref val.extents)).magnitude + 2f;
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(val.position, radius, list, 2097152, (QueryTriggerInteraction)2);
		uint num = 0u;
		for (int i = 0; i < list.Count; i++)
		{
			BuildingBlock buildingBlock = list[i];
			Construction blockDefinition = buildingBlock.blockDefinition;
			Vector3 position2 = ((Component)buildingBlock).transform.position;
			Quaternion rotation2 = ((Component)buildingBlock).transform.rotation;
			ProximityInfo proximity = GetProximity(construction, position, rotation, blockDefinition, position2, rotation2);
			ProximityInfo proximity2 = GetProximity(blockDefinition, position2, rotation2, construction, position, rotation);
			ProximityInfo proximityInfo = default(ProximityInfo);
			proximityInfo.hit = proximity.hit || proximity2.hit;
			proximityInfo.connection = proximity.connection || proximity2.connection;
			if (proximity.sqrDist <= proximity2.sqrDist)
			{
				proximityInfo.line = proximity.line;
				proximityInfo.sqrDist = proximity.sqrDist;
			}
			else
			{
				proximityInfo.line = proximity2.line;
				proximityInfo.sqrDist = proximity2.sqrDist;
			}
			if (proximityInfo.connection)
			{
				BuildingManager.Building building = buildingBlock.GetBuilding();
				if (building != null)
				{
					BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
					if ((Object)(object)dominatingBuildingPrivilege != (Object)null)
					{
						if (!construction.canBypassBuildingPermission && !dominatingBuildingPrivilege.CanBuild(player))
						{
							Construction.lastPlacementError = Phrase.op_Implicit(ConstructionErrors.CannotAttachToUnauthorized.translated);
							Pool.FreeUnmanaged<BuildingBlock>(ref list);
							return true;
						}
						if (num == 0)
						{
							num = building.ID;
						}
						else if (num != building.ID)
						{
							if (!dominatingBuildingPrivilege.CanBuild(player))
							{
								Construction.lastPlacementError = ConstructionErrors.CannotAttachToUnauthorized;
							}
							else
							{
								Construction.lastPlacementError = ConstructionErrors.CannotConnectTwoBuildings;
							}
							Pool.FreeUnmanaged<BuildingBlock>(ref list);
							return true;
						}
					}
				}
			}
			if (proximityInfo.hit)
			{
				Vector3 val2 = proximityInfo.line.point1 - proximityInfo.line.point0;
				if (!(Mathf.Abs(val2.y) > 1.49f) && !(Vector3Ex.Magnitude2D(val2) > 1.49f))
				{
					string translated = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID).info.name.translated;
					Construction.lastPlacementError = Phrase.op_Implicit(string.Format(ConstructionErrors.TooCloseTo.translated, translated));
					Construction.lastPlacementErrorIsDetailed = true;
					Pool.FreeUnmanaged<BuildingBlock>(ref list);
					return true;
				}
			}
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
		return false;
	}

	public static ProximityInfo GetProximity(Construction construction1, Vector3 position1, Quaternion rotation1, Construction construction2, Vector3 position2, Quaternion rotation2)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		ProximityInfo result = default(ProximityInfo);
		result.hit = false;
		result.connection = false;
		result.line = default(Line);
		result.sqrDist = float.MaxValue;
		for (int i = 0; i < construction1.allSockets.Length; i++)
		{
			ConstructionSocket constructionSocket = construction1.allSockets[i] as ConstructionSocket;
			if (constructionSocket == null)
			{
				continue;
			}
			for (int j = 0; j < construction2.allSockets.Length; j++)
			{
				Socket_Base socket = construction2.allSockets[j];
				if (constructionSocket.CanConnect(position1, rotation1, socket, position2, rotation2))
				{
					result.connection = true;
					return result;
				}
			}
		}
		if (construction1.isServer)
		{
			for (int k = 0; k < construction1.allSockets.Length; k++)
			{
				Socket_Base socket_Base = construction1.allSockets[k];
				if (!(socket_Base is NeighbourSocket) && !(socket_Base is StabilitySocket))
				{
					continue;
				}
				for (int l = 0; l < construction2.allSockets.Length; l++)
				{
					Socket_Base socket2 = construction2.allSockets[l];
					if (socket_Base.CanConnect(position1, rotation1, socket2, position2, rotation2))
					{
						result.connection = true;
						return result;
					}
				}
			}
		}
		if (!result.connection && construction1.allProximities.Length != 0)
		{
			Line val = default(Line);
			for (int m = 0; m < construction1.allSockets.Length; m++)
			{
				ConstructionSocket constructionSocket2 = construction1.allSockets[m] as ConstructionSocket;
				if (constructionSocket2 == null || constructionSocket2.socketType != ConstructionSocket.Type.Wall)
				{
					continue;
				}
				Vector3 selectPivot = constructionSocket2.GetSelectPivot(position1, rotation1);
				for (int n = 0; n < construction2.allProximities.Length; n++)
				{
					Vector3 selectPivot2 = construction2.allProximities[n].GetSelectPivot(position2, rotation2);
					((Line)(ref val))..ctor(selectPivot, selectPivot2);
					Vector3 val2 = val.point1 - val.point0;
					float sqrMagnitude = ((Vector3)(ref val2)).sqrMagnitude;
					if (sqrMagnitude < result.sqrDist)
					{
						result.hit = true;
						result.line = val;
						result.sqrDist = sqrMagnitude;
					}
				}
			}
		}
		return result;
	}

	public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return position + rotation * worldPosition;
	}

	protected override Type GetIndexedType()
	{
		return typeof(BuildingProximity);
	}
}


public struct ProximityInfo
{
	public bool hit;

	public bool connection;

	public Line line;

	public float sqrDist;
}


using System;
using UnityEngine;

public class ConditionalModel : PrefabAttribute
{
	public GameObjectRef prefab;

	public bool onClient = true;

	public bool onServer = true;

	public bool IsImportant;

	[NonSerialized]
	public ModelConditionTest[] conditions;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		conditions = ((Component)this).GetComponentsInChildren<ModelConditionTest>(true);
	}

	public bool RunTests(BaseEntity parent)
	{
		for (int i = 0; i < conditions.Length; i++)
		{
			if (!conditions[i].DoTest(parent))
			{
				return false;
			}
		}
		return true;
	}

	public bool RunTestsExceptFoundationSide(BaseEntity parent)
	{
		for (int i = 0; i < conditions.Length; i++)
		{
			if (!(conditions[i] is ModelConditionTest_FoundationSide) && !conditions[i].DoTest(parent))
			{
				return false;
			}
		}
		return true;
	}

	public virtual GameObject InstantiateSkin(BaseEntity parent)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (!onServer && isServer)
		{
			return null;
		}
		GameObject val = gameManager.CreatePrefab(prefab.resourcePath, ((Component)parent).transform, active: false);
		if (Object.op_Implicit((Object)(object)val))
		{
			val.transform.localPosition = worldPosition;
			val.transform.localRotation = worldRotation;
			val.AwakeFromInstantiate();
		}
		return val;
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConditionalModel);
	}
}


using System;
using UnityEngine;

public class ConditionalModelWallpaper : ConditionalModel
{
	public bool softSide;

	public override GameObject InstantiateSkin(BaseEntity parent)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if (!onServer && isServer)
		{
			return null;
		}
		GameObject val = gameManager.CreatePrefab(prefab.resourcePath, ((Component)parent).transform, active: false);
		if ((Object)(object)val != (Object)null)
		{
			val.transform.localPosition = worldPosition;
			val.transform.localRotation = worldRotation;
			BuildingBlock buildingBlock = parent as BuildingBlock;
			if ((Object)(object)buildingBlock != (Object)null)
			{
				ItemDefinition itemDefForCategory = WallpaperSettings.GetItemDefForCategory(WallpaperPlanner.Settings.GetCategory(buildingBlock, (!softSide) ? 1 : 0));
				SkinHelpers.SetSkin(val, itemDefForCategory, softSide ? buildingBlock.wallpaperID : buildingBlock.wallpaperID2);
				float num = (softSide ? buildingBlock.wallpaperRotation : buildingBlock.wallpaperRotation2);
				if (num != 0f)
				{
					Vector3 localEulerAngles = val.transform.localEulerAngles;
					localEulerAngles.y += num;
					val.transform.localRotation = Quaternion.Euler(localEulerAngles);
				}
				val.AwakeFromInstantiate();
			}
		}
		return val;
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConditionalModel);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Serialization;

public class Construction : PrefabAttribute
{
	public class Grade
	{
		public BuildingGrade grade;

		public float maxHealth;

		public List<ItemAmount> costToBuild;

		public PhysicMaterial physicMaterial => grade.physicMaterial;

		public ProtectionProperties damageProtecton => grade.damageProtecton;
	}

	public struct Target
	{
		public bool valid;

		public Ray ray;

		public BaseEntity entity;

		public Socket_Base socket;

		public bool onTerrain;

		public Vector3 position;

		public Vector3 normal;

		public Vector3 rotation;

		public BasePlayer player;

		public bool buildingBlocked;

		public bool isHoldingShift;

		public Quaternion GetWorldRotation(bool female)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			Quaternion val = socket.rotation;
			if (socket.male && socket.female && female)
			{
				val = socket.rotation * Quaternion.Euler(180f, 0f, 180f);
			}
			return ((Component)entity).transform.rotation * val;
		}

		public Vector3 GetWorldPosition()
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			Matrix4x4 localToWorldMatrix = ((Component)entity).transform.localToWorldMatrix;
			return ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(socket.position);
		}
	}

	public struct Placement
	{
		public Vector3 position;

		public Quaternion rotation;

		public bool isPopulated;

		public readonly bool isHoldingShift;

		public Transform transform;

		public Placement(Target target)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			isHoldingShift = target.isHoldingShift;
			position = Vector3.zero;
			rotation = Quaternion.identity;
			isPopulated = true;
			transform = null;
			if ((Object)(object)target.entity != (Object)null)
			{
				transform = ((Component)target.entity).transform;
			}
		}
	}

	public BaseEntity.Menu.Option info;

	public bool canBypassBuildingPermission;

	public bool showBuildingBlockedPreview = true;

	[InspectorName("Can bypass road checks")]
	public bool canPlaceOnRoads;

	[FormerlySerializedAs("canRotate")]
	public bool canRotateBeforePlacement;

	[FormerlySerializedAs("canRotate")]
	public bool canRotateAfterPlacement;

	public bool checkVolumeOnRotate;

	public bool checkVolumeOnUpgrade;

	public bool canPlaceAtMaxDistance;

	public bool placeOnWater;

	public bool overridePlacementLayer;

	public LayerMask overridedPlacementLayer;

	public LayerMask additionalPlacementLayer;

	public Vector3 rotationAmount = new Vector3(0f, 90f, 0f);

	public Vector3 applyStartingRotation = Vector3.zero;

	public Transform deployOffset;

	public bool enforceLineOfSightCheckAgainstParentEntity;

	[Tooltip("Axis Snapping for IO Entities.")]
	public bool canSnap;

	public float holdToPlaceDuration;

	public bool canFloodFillSockets;

	[Space]
	public bool alternativeLOSChecks;

	public Vector3[] alternativeLOSPositions;

	public bool canUseLastValidPosition = true;

	[Range(0f, 10f)]
	public float healthMultiplier = 1f;

	[Range(0f, 10f)]
	public float costMultiplier = 1f;

	[Range(1f, 50f)]
	public float maxplaceDistance = 4f;

	[Range(0f, 10f)]
	public float minPlaceDistance = 1f;

	public Mesh guideMesh;

	[NonSerialized]
	public Socket_Base[] allSockets;

	[NonSerialized]
	public BuildingProximity[] allProximities;

	[NonSerialized]
	public ConstructionGrade defaultGrade;

	[NonSerialized]
	public SocketHandle socketHandle;

	[NonSerialized]
	public Bounds bounds;

	[NonSerialized]
	public bool isBuildingPrivilege;

	[NonSerialized]
	public bool isSleepingBag;

	[NonSerialized]
	public ConstructionGrade[] grades;

	[NonSerialized]
	public Deployable deployable;

	[NonSerialized]
	public ConstructionPlaceholder placeholder;

	[ReplicatedVar]
	public static bool alternativeLOSChecks_enabled = true;

	public static Phrase lastPlacementError = Phrase.op_Implicit(string.Empty);

	public static bool lastPlacementErrorIsDetailed;

	public static string lastPlacementErrorDebug;

	public static BuildingBlock lastBuildingBlockError;

	public BaseEntity CreateConstruction(Target target, bool bNeedsValidPlacement = false)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = GameManager.server.CreatePrefab(fullName, Vector3.zero, Quaternion.identity, active: false);
		bool flag = UpdatePlacement(val.transform, this, ref target);
		BaseEntity baseEntity = val.ToBaseEntity();
		if (bNeedsValidPlacement && !flag)
		{
			if (baseEntity.IsValid())
			{
				baseEntity.Kill();
			}
			else
			{
				GameManager.Destroy(val);
			}
			return null;
		}
		DecayEntity decayEntity = baseEntity as DecayEntity;
		if (Object.op_Implicit((Object)(object)decayEntity))
		{
			decayEntity.AttachToBuilding(target.entity as DecayEntity);
		}
		return baseEntity;
	}

	public bool HasMaleSockets(Target target)
	{
		Socket_Base[] array = allSockets;
		foreach (Socket_Base socket_Base in array)
		{
			if (socket_Base.male && !socket_Base.maleDummy && socket_Base.TestTarget(target))
			{
				return true;
			}
		}
		return false;
	}

	public void FindMaleSockets(Target target, List<Socket_Base> sockets)
	{
		Socket_Base[] array = allSockets;
		foreach (Socket_Base socket_Base in array)
		{
			if (socket_Base.male && !socket_Base.maleDummy && socket_Base.TestTarget(target))
			{
				sockets.Add(socket_Base);
			}
		}
	}

	public ConstructionGrade GetGrade(BuildingGrade.Enum iGrade, ulong iSkin)
	{
		ConstructionGrade[] array = grades;
		foreach (ConstructionGrade constructionGrade in array)
		{
			if (constructionGrade.gradeBase.type == iGrade && constructionGrade.gradeBase.skin == iSkin)
			{
				return constructionGrade;
			}
		}
		return defaultGrade;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		isBuildingPrivilege = Object.op_Implicit((Object)(object)rootObj.GetComponent<BuildingPrivlidge>());
		isSleepingBag = Object.op_Implicit((Object)(object)rootObj.GetComponent<SleepingBag>());
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
		deployable = ((Component)this).GetComponent<Deployable>();
		placeholder = ((Component)this).GetComponentInChildren<ConstructionPlaceholder>();
		allSockets = ((Component)this).GetComponentsInChildren<Socket_Base>(true);
		allProximities = ((Component)this).GetComponentsInChildren<BuildingProximity>(true);
		socketHandle = ((Component)this).GetComponentsInChildren<SocketHandle>(true).FirstOrDefault();
		grades = rootObj.GetComponents<ConstructionGrade>();
		ConstructionGrade[] array = grades;
		foreach (ConstructionGrade constructionGrade in array)
		{
			if (!(constructionGrade == null))
			{
				constructionGrade.construction = this;
				if (!(defaultGrade != null))
				{
					defaultGrade = constructionGrade;
				}
			}
		}
	}

	protected override Type GetIndexedType()
	{
		return typeof(Construction);
	}

	public bool HasAlternativeLOSChecks()
	{
		if (alternativeLOSChecks_enabled && alternativeLOSChecks && alternativeLOSPositions != null)
		{
			return alternativeLOSPositions.Length != 0;
		}
		return false;
	}

	public bool UpdatePlacement(Transform transform, Construction common, ref Target target)
	{
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_045e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0464: Unknown result type (might be due to invalid IL or missing references)
		//IL_046a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_041d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		//IL_0491: Unknown result type (might be due to invalid IL or missing references)
		//IL_0533: Unknown result type (might be due to invalid IL or missing references)
		//IL_053a: Unknown result type (might be due to invalid IL or missing references)
		//IL_054d: Unknown result type (might be due to invalid IL or missing references)
		if (!target.valid)
		{
			if (common.placeOnWater)
			{
				lastPlacementError = ConstructionErrors.WantsWater;
			}
			return false;
		}
		if (!common.canBypassBuildingPermission && !target.player.CanBuild())
		{
			lastPlacementError = ConstructionErrors.NoPermission;
			return false;
		}
		List<Socket_Base> list = Pool.Get<List<Socket_Base>>();
		common.FindMaleSockets(target, list);
		foreach (Socket_Base item in list)
		{
			Placement placement = default(Placement);
			if ((Object)(object)target.entity != (Object)null && target.socket != null && target.entity.IsOccupied(target.socket))
			{
				continue;
			}
			if (!placement.isPopulated)
			{
				placement = item.DoPlacement(target);
			}
			if ((Object)(object)target.player != (Object)null && target.player.IsInTutorial)
			{
				TutorialIsland currentTutorialIsland = target.player.GetCurrentTutorialIsland();
				if ((Object)(object)currentTutorialIsland != (Object)null && !currentTutorialIsland.CheckPlacement(common, target, ref placement))
				{
					placement = default(Placement);
				}
			}
			if (!placement.isPopulated)
			{
				continue;
			}
			if (target.player.IsInCreativeMode && Creative.freePlacement)
			{
				transform.SetPositionAndRotation(placement.position, placement.rotation);
				return true;
			}
			if (!item.CheckSocketMods(ref placement))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				continue;
			}
			if (!TestPlacingThroughRock(ref placement, target))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.ThroughRock;
				continue;
			}
			if (common.HasAlternativeLOSChecks())
			{
				if (target.socket == null && !TestPlacingThroughWall(ref placement, transform, common, target))
				{
					transform.position = placement.position;
					transform.rotation = placement.rotation;
					lastPlacementError = ConstructionErrors.ThroughWalls;
					lastPlacementErrorDebug = "Placing through walls";
					continue;
				}
				if (!Planner.HasLineOfSight(ref placement, common, target))
				{
					transform.position = placement.position;
					transform.rotation = placement.rotation;
					lastPlacementError = ConstructionErrors.LineOfSightBlocked;
					continue;
				}
			}
			else if (!TestPlacingThroughWall(ref placement, transform, common, target))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.ThroughWalls;
				lastPlacementErrorDebug = "Placing through walls";
				continue;
			}
			if (!TestPlacingCloseToRoad(ref placement, target, common))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.TooCloseToRoad;
				continue;
			}
			if (target.entity is Door && target.socket == null)
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.CantDeployOnDoor;
				continue;
			}
			if (Vector3.Distance(placement.position, target.player.eyes.position) > common.maxplaceDistance + 1f)
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.TooFarAway;
				continue;
			}
			DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(prefabID);
			if (DeployVolume.Check(placement.position, placement.rotation, volumes))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				if ((Object)(object)DeployVolume.LastDeployHit != (Object)null)
				{
					lastPlacementErrorDebug = ((Object)DeployVolume.LastDeployHit).name;
					string blockedByErrorFromCollider = ConstructionErrors.GetBlockedByErrorFromCollider(DeployVolume.LastDeployHit, target.player);
					if (!string.IsNullOrEmpty(blockedByErrorFromCollider))
					{
						lastPlacementError = Phrase.op_Implicit(blockedByErrorFromCollider);
						lastPlacementErrorIsDetailed = true;
						continue;
					}
				}
				lastPlacementError = ConstructionErrors.NotEnoughSpace;
				continue;
			}
			if (BuildingProximity.Check(target.player, this, placement.position, placement.rotation))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				continue;
			}
			if (common.isBuildingPrivilege && !target.player.CanPlaceBuildingPrivilege(placement.position, placement.rotation, common.bounds))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.StackPrivilege;
				continue;
			}
			bool flag = target.player.IsBuildingBlocked(placement.position, placement.rotation, common.bounds, cached: false);
			if (!common.canBypassBuildingPermission && flag)
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.NoPermission;
				continue;
			}
			target.buildingBlocked = flag;
			transform.SetPositionAndRotation(placement.position, placement.rotation);
			if ((!((Object)(object)target.player != (Object)null) || !target.player.IsInCreativeMode || !Creative.bypassHoldToPlaceDuration) && common.holdToPlaceDuration > 0f && (Object)(object)target.player != (Object)null && isServer && target.player.GetHeldEntity() is Planner planner && (Vector3.Distance(((Component)target.player).transform.position, planner.serverStartDurationPlacementPosition) > 1f || Mathf.Abs(TimeSince.op_Implicit(planner.serverStartDurationPlacementTime) - common.holdToPlaceDuration) > 0.5f))
			{
				return false;
			}
			Pool.FreeUnmanaged<Socket_Base>(ref list);
			return true;
		}
		Pool.FreeUnmanaged<Socket_Base>(ref list);
		return false;
	}

	private bool TestPlacingThroughRock(ref Placement placement, Target target)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(placement.position, Vector3.one, placement.rotation, bounds);
		Vector3 center = target.player.GetCenter(ducked: true);
		Vector3 origin = ((Ray)(ref target.ray)).origin;
		if (Physics.Linecast(center, origin, 65536, (QueryTriggerInteraction)1))
		{
			return false;
		}
		RaycastHit val2 = default(RaycastHit);
		Vector3 val3 = (((OBB)(ref val)).Trace(target.ray, ref val2, float.PositiveInfinity) ? ((RaycastHit)(ref val2)).point : ((OBB)(ref val)).ClosestPoint(origin));
		if (Physics.Linecast(origin, val3, 65536, (QueryTriggerInteraction)1))
		{
			return false;
		}
		return true;
	}

	private static bool TestPlacingThroughWall(ref Placement placement, Transform transform, Construction common, Target target)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = placement.position;
		if ((Object)(object)common.deployOffset != (Object)null)
		{
			val += placement.rotation * common.deployOffset.localPosition;
		}
		Vector3 val2 = val - ((Ray)(ref target.ray)).origin;
		RaycastHit hit = default(RaycastHit);
		if (!Physics.Raycast(((Ray)(ref target.ray)).origin, ((Vector3)(ref val2)).normalized, ref hit, ((Vector3)(ref val2)).magnitude, 2097152))
		{
			return true;
		}
		StabilityEntity stabilityEntity = hit.GetEntity() as StabilityEntity;
		if (!common.enforceLineOfSightCheckAgainstParentEntity && (Object)(object)stabilityEntity != (Object)null && (Object)(object)target.entity == (Object)(object)stabilityEntity)
		{
			return true;
		}
		if (((Vector3)(ref val2)).magnitude - ((RaycastHit)(ref hit)).distance < 0.2f)
		{
			return true;
		}
		transform.SetPositionAndRotation(((RaycastHit)(ref hit)).point, placement.rotation);
		return false;
	}

	private bool TestPlacingCloseToRoad(ref Placement placement, Target target, Construction construction)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		if (construction.canPlaceOnRoads)
		{
			return true;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		if ((Object)(object)heightMap == (Object)null)
		{
			return true;
		}
		if ((Object)(object)topologyMap == (Object)null)
		{
			return true;
		}
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(placement.position, Vector3.one, placement.rotation, bounds);
		float num = Mathf.Abs(heightMap.GetHeight(val.position) - val.position.y);
		if (num > 9f)
		{
			return true;
		}
		float radius = Mathf.Lerp(3f, 0f, num / 9f);
		Vector3 position = val.position;
		Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
		Vector3 point2 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
		Vector3 point3 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
		Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
		int topology = topologyMap.GetTopology(position, radius);
		int topology2 = topologyMap.GetTopology(point, radius);
		int topology3 = topologyMap.GetTopology(point2, radius);
		int topology4 = topologyMap.GetTopology(point3, radius);
		int topology5 = topologyMap.GetTopology(point4, radius);
		if (((topology | topology2 | topology3 | topology4 | topology5) & 0x80800) == 0)
		{
			return true;
		}
		return false;
	}

	public virtual bool ShowAsNeutral(Target target)
	{
		return target.buildingBlocked;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class Grade
{
	public BuildingGrade grade;

	public float maxHealth;

	public List<ItemAmount> costToBuild;

	public PhysicMaterial physicMaterial => grade.physicMaterial;

	public ProtectionProperties damageProtecton => grade.damageProtecton;
}


using UnityEngine;

public struct Target
{
	public bool valid;

	public Ray ray;

	public BaseEntity entity;

	public Socket_Base socket;

	public bool onTerrain;

	public Vector3 position;

	public Vector3 normal;

	public Vector3 rotation;

	public BasePlayer player;

	public bool buildingBlocked;

	public bool isHoldingShift;

	public Quaternion GetWorldRotation(bool female)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = socket.rotation;
		if (socket.male && socket.female && female)
		{
			val = socket.rotation * Quaternion.Euler(180f, 0f, 180f);
		}
		return ((Component)entity).transform.rotation * val;
	}

	public Vector3 GetWorldPosition()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = ((Component)entity).transform.localToWorldMatrix;
		return ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(socket.position);
	}
}


using UnityEngine;

public struct Placement
{
	public Vector3 position;

	public Quaternion rotation;

	public bool isPopulated;

	public readonly bool isHoldingShift;

	public Transform transform;

	public Placement(Target target)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		isHoldingShift = target.isHoldingShift;
		position = Vector3.zero;
		rotation = Quaternion.identity;
		isPopulated = true;
		transform = null;
		if ((Object)(object)target.entity != (Object)null)
		{
			transform = ((Component)target.entity).transform;
		}
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public static class ConstructionErrors
{
	public static readonly Phrase NoPermission = new Phrase("error_buildpermission", "You don't have permission to build here");

	public static readonly Phrase StackPrivilege = new Phrase("error_stackprivilege", "Cannot stack building privileges");

	public static readonly Phrase CantBuildWhileMoving = new Phrase("error_whilemoving", "You can't build this while moving");

	public static readonly Phrase ThroughRock = new Phrase("error_throughrock", "Placing through rock");

	public static readonly Phrase ThroughWalls = new Phrase("error_throughwalls", "Placing through walls");

	public static readonly Phrase InsideObjects = new Phrase("error_insideobjects", "Can't deploy inside objects");

	public static readonly Phrase TooCloseToRoad = new Phrase("error_tooclosetoroad", "Placing too close to road");

	public static readonly Phrase TooFarAway = new Phrase("error_toofar", "Too far away");

	public static readonly Phrase BlockedBy = new Phrase("error_blockedby", "Blocked by {0}");

	public static readonly Phrase BlockedByPlayer = new Phrase("error_blockedbyplayer", "Blocked by Player {0}");

	public static readonly Phrase BlockedByVehicle = new Phrase("error_blockedbyvehicle", "Blocked by Vehicle");

	public static readonly Phrase TooCloseTo = new Phrase("error_toocloseto", "Too close to {0}");

	public static readonly Phrase TooCloseToMonument = new Phrase("error_tooclosetomonument", "Cannot build this close to {0}");

	public static readonly Phrase BlockedByTree = new Phrase("error_blockedbytree", "Blocked by tree");

	public static readonly Phrase BlockedByTerrain = new Phrase("error_blockedbyterrain", "Blocked by terrain");

	public static readonly Phrase SkinNotOwned = new Phrase("error_skinnotowned", "Skin not owned");

	public static readonly Phrase CannotBuildInThisArea = new Phrase("error_cannotbuildarea", "Cannot build in this area");

	public static readonly Phrase NotEnoughSpace = new Phrase("error_notenoughspace", "Not enough space");

	public static readonly Phrase NotStableEnough = new Phrase("error_notstableenough", "Not stable enough");

	public static readonly Phrase MustPlaceOnConstruction = new Phrase("error_wantsconstruction", "Must be placed on a construction");

	public static readonly Phrase CantPlaceOnConstruction = new Phrase("error_doesnotwantconstruction", "Cannot be placed on constructions");

	public static readonly Phrase CantPlaceOnMonument = new Phrase("error_cantplaceonmonument", "Cannot be placed on monument");

	public static readonly Phrase NotInTerrain = new Phrase("error_notinterrain", "Not in terrain");

	public static readonly Phrase MustPlaceOnRoad = new Phrase("error_placement_needs_road", "Must be placed on road");

	public static readonly Phrase CantPlaceOnRoad = new Phrase("error_placement_no_road", "Cannot be placed on road");

	public static readonly Phrase InvalidAreaVehicleLarge = new Phrase("error_invalidarea_vehiclelarge", "Cannot deploy near a large vehicle");

	public static readonly Phrase InvalidAngle = new Phrase("error_invalidangle", "Invalid angle");

	public static readonly Phrase InvalidEntity = new Phrase("error_invalidentitycheck", "Invalid entity");

	public static readonly Phrase InvalidEntityType = new Phrase("error_invalidentitytype", "Invalid entity type");

	public static readonly Phrase WantsWater = new Phrase("error_inwater_wants", "Must be placed in water");

	public static readonly Phrase WantsWaterBody = new Phrase("error_inwater_wants_body", "Must be placed in a body of water");

	public static readonly Phrase InWater = new Phrase("error_inwater", "Can't be placed in water");

	public static readonly Phrase TooDeep = new Phrase("error_toodeep", "Water is too deep");

	public static readonly Phrase TooShallow = new Phrase("error_shallow", "Water is too shallow");

	public static readonly Phrase CouldntFindConstruction = new Phrase("error_counlndfindconstruction", "Couldn't find construction");

	public static readonly Phrase CouldntFindEntity = new Phrase("error_counlndfindentity", "Couldn't find entity");

	public static readonly Phrase CouldntFindSocket = new Phrase("error_counlndfindsocket", "Couldn't find socket");

	public static readonly Phrase Antihack = new Phrase("error_antihack", "Anti hack!");

	public static readonly Phrase AntihackWithReason = new Phrase("error_antihack_reason", "Anti hack! ({0})");

	public static readonly Phrase CantDeployOnDoor = new Phrase("error_cantdeployondoor", "Can't deploy on door");

	public static readonly Phrase DeployableMismatch = new Phrase("error_deployablemismatch", "Deployable mismatch!");

	public static readonly Phrase LineOfSightBlocked = new Phrase("error_lineofsightblocked", "Line of sight blocked");

	public static readonly Phrase ParentTooFar = new Phrase("error_parenttoofar", "Parent too far away");

	public static readonly Phrase SocketOccupied = new Phrase("error_sockectoccupied", "Target socket is occupied");

	public static readonly Phrase SocketNotFemale = new Phrase("error_socketnotfemale", "Target socket is not female");

	public static readonly Phrase WantsInside = new Phrase("error_wantsinside", "Must be placed inside your base");

	public static readonly Phrase WantsOutside = new Phrase("error_wantsoutside", "Can't be placed inside a base");

	public static readonly Phrase PlayerName = new Phrase("error_name_player", "Player {0}");

	public static readonly Phrase HorseName = new Phrase("error_name_horse", "Horse");

	public static readonly Phrase ModularCarName = new Phrase("error_name_modularcar", "Modular Car");

	public static readonly Phrase TreeName = new Phrase("error_name_tree", "Tree");

	public static readonly Phrase DebrisName = new Phrase("error_name_debris", "Debris");

	public static readonly Phrase OreName = new Phrase("error_name_ore", "Ore");

	public static readonly Phrase DroppedItemName = new Phrase("error_dropped_item", "Dropped item");

	public static readonly Phrase CannotAttachToUnauthorized = new Phrase("error_cannotattachtounauth", "Cannot attach to unauthorized building");

	public static readonly Phrase CannotConnectTwoBuildings = new Phrase("error_connecttwobuildings", "Cannot connect two buildings with cupboards");

	public static readonly Phrase CantUpgradeRecentlyDamaged = new Phrase("error_upgraderecentlydamaged", "Recently damaged, upgradable in {0} seconds");

	public static readonly Phrase CantRotateAnymore = new Phrase("grade_rotationblocked", "Can't rotate this block anymore");

	public static readonly Phrase CantDemolishAnymore = new Phrase("grade_demolishblocked", "Can't demolish this block anymore");

	public static string GetTranslatedNameFromEntity(BaseEntity entity, BasePlayer fromPlayer = null)
	{
		if (entity is ModularCar || entity is BaseVehicleModule)
		{
			return ModularCarName.translated;
		}
		if (entity is BaseVehicleSeat && entity.parentEntity.Get(serverside: false) is RidableHorse)
		{
			return HorseName.translated;
		}
		if (entity is BaseNPC2 baseNPC)
		{
			return baseNPC.displayName;
		}
		if (entity is RidableHorse || entity is HorseSaddle)
		{
			return HorseName.translated;
		}
		if (entity is HumanNPC humanNPC)
		{
			return humanNPC.displayName;
		}
		if (entity is BasePlayer { displayName: var arg } basePlayer)
		{
			if ((Object)(object)fromPlayer != (Object)null)
			{
				arg = NameHelper.GetPlayerNameStreamSafe(fromPlayer, basePlayer);
			}
			return string.Format(PlayerName.translated, arg);
		}
		if (entity is BuildingBlock buildingBlock)
		{
			return PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID).info.name.translated;
		}
		if (entity is DebrisEntity)
		{
			return DebrisName.translated;
		}
		if (entity is TreeEntity)
		{
			return TreeName.translated;
		}
		if (entity is OreResourceEntity)
		{
			return OreName.translated;
		}
		if (entity is DroppedItem)
		{
			return DroppedItemName.translated;
		}
		SprayCan.GetItemDefinitionForEntity(entity, out var def);
		if ((Object)(object)def != (Object)null)
		{
			return def.displayName.translated;
		}
		return string.Empty;
	}

	public static string GetBlockedByErrorFromEntity(BaseEntity entity, BasePlayer fromPlayer = null)
	{
		string translatedNameFromEntity = GetTranslatedNameFromEntity(entity, fromPlayer);
		if (!string.IsNullOrEmpty(translatedNameFromEntity))
		{
			return string.Format(BlockedBy.translated, translatedNameFromEntity);
		}
		return null;
	}

	public static string GetBlockedByErrorFromCollider(Collider col, BasePlayer fromPlayer = null)
	{
		PreventBuildingMonumentTag preventBuildingMonumentTag = GetPreventBuildingMonumentTag(col);
		if ((Object)(object)preventBuildingMonumentTag != (Object)null)
		{
			return string.Format(TooCloseToMonument.translated, preventBuildingMonumentTag.GetAttachedMonument().displayPhrase.translated);
		}
		BaseEntity baseEntity = col.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			return GetBlockedByErrorFromEntity(baseEntity, fromPlayer);
		}
		if (col is TerrainCollider)
		{
			return BlockedByTerrain.translated;
		}
		return null;
	}

	public static PreventBuildingMonumentTag GetPreventBuildingMonumentTag(Collider col)
	{
		PreventBuildingMonumentTag preventBuildingMonumentTag = default(PreventBuildingMonumentTag);
		if ((Object)(object)col != (Object)null && ((Component)col).TryGetComponent<PreventBuildingMonumentTag>(ref preventBuildingMonumentTag) && (Object)(object)preventBuildingMonumentTag.GetAttachedMonument() != (Object)null && !((Component)preventBuildingMonumentTag).gameObject.HasCustomTag(GameObjectTag.BlockPlacement))
		{
			return preventBuildingMonumentTag;
		}
		return null;
	}

	public static void Log(BasePlayer player, string message)
	{
		if (!((Object)(object)player == (Object)null) && !string.IsNullOrEmpty(message) && player.isServer && player.net.connection.info.GetBool("client.errortoasts_debug", false))
		{
			player.ChatMessage(message);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

public class ConstructionGrade : PrefabAttribute
{
	private struct CachedAmount
	{
		public List<ItemAmount> costs;

		public float cachedConVarMultiplier;
	}

	[NonSerialized]
	public Construction construction;

	public BuildingGrade gradeBase;

	public GameObjectRef skinObject;

	private Dictionary<BuildingGrade.Enum, CachedAmount> _costs;

	private float _costBuildPercent;

	public float maxHealth
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)gradeBase) || !construction)
			{
				return 0f;
			}
			return gradeBase.baseHealth * construction.healthMultiplier;
		}
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		_costs = new Dictionary<BuildingGrade.Enum, CachedAmount>();
		foreach (BuildingGrade.Enum value in Enum.GetValues(typeof(BuildingGrade.Enum)))
		{
			UpdateCosts(value);
		}
	}

	private void UpdateCosts(BuildingGrade.Enum grade)
	{
		List<ItemAmount> list = new List<ItemAmount>();
		float num = ((grade == gradeBase.type) ? 0.2f : 1f);
		float costMultiplier = ConVar.Decay.GetCostMultiplier(gradeBase.type);
		foreach (ItemAmount item in gradeBase.baseCost)
		{
			list.Add(new ItemAmount(item.itemDef, Mathf.Ceil(item.amount * construction.costMultiplier * num * costMultiplier)));
		}
		_costs[grade] = new CachedAmount
		{
			cachedConVarMultiplier = costMultiplier,
			costs = list
		};
	}

	public List<ItemAmount> CostToBuild(BuildingGrade.Enum fromGrade = BuildingGrade.Enum.None)
	{
		if (ConVar.Decay.GetCostMultiplier(gradeBase.type) != _costs[fromGrade].cachedConVarMultiplier)
		{
			UpdateCosts(fromGrade);
		}
		return _costs[fromGrade].costs;
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConstructionGrade);
	}
}


using System.Collections.Generic;

private struct CachedAmount
{
	public List<ItemAmount> costs;

	public float cachedConVarMultiplier;
}


using System;
using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode]
public class ConstructionPlaceholder : PrefabAttribute, IPrefabPreProcess
{
	public Mesh mesh;

	public Material material;

	public bool renderer;

	public bool collider;

	[NonSerialized]
	public MeshRenderer MeshRenderer;

	[NonSerialized]
	public MeshFilter MeshFilter;

	[NonSerialized]
	public MeshCollider MeshCollider;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		if (!clientside || !((Behaviour)this).enabled)
		{
			return;
		}
		if (renderer)
		{
			MeshFilter = rootObj.GetComponent<MeshFilter>();
			MeshRenderer = rootObj.GetComponent<MeshRenderer>();
			if (!Object.op_Implicit((Object)(object)MeshFilter))
			{
				MeshFilter = rootObj.AddComponent<MeshFilter>();
				MeshFilter.sharedMesh = mesh;
			}
			if (!Object.op_Implicit((Object)(object)MeshRenderer))
			{
				MeshRenderer = rootObj.AddComponent<MeshRenderer>();
				((Renderer)MeshRenderer).sharedMaterial = material;
				((Renderer)MeshRenderer).shadowCastingMode = (ShadowCastingMode)0;
			}
		}
		if (collider)
		{
			MeshCollider = rootObj.GetComponent<MeshCollider>();
			if (!Object.op_Implicit((Object)(object)MeshCollider))
			{
				MeshCollider = rootObj.AddComponent<MeshCollider>();
				MeshCollider.sharedMesh = mesh;
			}
		}
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConstructionPlaceholder);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ConstructionSkin : BasePrefab
{
	public List<GameObject> conditionals;

	public ulong DetermineConditionalModelState(BuildingBlock parent)
	{
		ConditionalModel[] array = PrefabAttribute.server.FindAll<ConditionalModel>(prefabID);
		if (array.Length > 64)
		{
			Debug.LogError((object)("Too many ConditionalModels on " + ((Object)parent).name + "! Maximum supported is 64"));
		}
		ulong num = 0uL;
		for (int i = 0; i < array.Length && i < 64; i++)
		{
			if (array[i].RunTests(parent))
			{
				num |= (ulong)(1L << i);
			}
		}
		return num;
	}

	private void CreateConditionalModels(BuildingBlock parent)
	{
		ConditionalModel[] array = PrefabAttribute.server.FindAll<ConditionalModel>(prefabID);
		for (int i = 0; i < array.Length; i++)
		{
			if (!parent.GetConditionalModel(i))
			{
				continue;
			}
			GameObject val = array[i].InstantiateSkin(parent);
			if (!((Object)(object)val == (Object)null))
			{
				if (conditionals == null)
				{
					conditionals = new List<GameObject>();
				}
				conditionals.Add(val);
			}
		}
	}

	private void DestroyConditionalModels(BuildingBlock parent)
	{
		if (conditionals != null)
		{
			for (int i = 0; i < conditionals.Count; i++)
			{
				parent.gameManager.Retire(conditionals[i]);
			}
			conditionals.Clear();
		}
	}

	public virtual void Refresh(BuildingBlock parent)
	{
		DestroyConditionalModels(parent);
		CreateConditionalModels(parent);
	}

	public void Destroy(BuildingBlock parent)
	{
		DestroyConditionalModels(parent);
		parent.gameManager.Retire(((Component)this).gameObject);
	}

	public virtual uint GetStartingDetailColour(uint playerColourIndex)
	{
		return 0u;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Construction Colour Lookup")]
public class ConstructionSkin_ColourLookup : ScriptableObject
{
	public Texture2D Sample;

	public Color[] AllColours;
}


using UnityEngine;

public class ConstructionSkin_CustomDetail : ConstructionSkin
{
	public ConstructionSkin_ColourLookup ColourLookup;

	public override uint GetStartingDetailColour(uint playerColourIndex)
	{
		if (playerColourIndex != 0)
		{
			return (uint)Mathf.Clamp((float)playerColourIndex, 1f, (float)(ColourLookup.AllColours.Length + 1));
		}
		return (uint)Random.Range(1, ColourLookup.AllColours.Length + 1);
	}
}


using UnityEngine;

public class ConstructionSocket : Socket_Base
{
	public enum Type
	{
		None,
		Foundation,
		Floor,
		Misc,
		Doorway,
		Wall,
		Block,
		Ramp,
		StairsTriangle,
		Stairs,
		FloorFrameTriangle,
		Window,
		Shutters,
		WallFrame,
		FloorFrame,
		WindowDressing,
		DoorDressing,
		Elevator,
		DoubleDoorDressing
	}

	public Type socketType;

	public int rotationDegrees;

	public int rotationOffset;

	public bool restrictPlacementRotation;

	public bool restrictPlacementAngle;

	public float faceAngle;

	public float angleAllowed = 150f;

	public bool wantsInside;

	[Range(0f, 1f)]
	public float support = 1f;

	private static readonly Vector3[] outsideLookupDirs;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.6f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	private void OnDrawGizmosSelected()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (female)
		{
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.DrawWireCube(selectCenter, selectSize);
		}
	}

	public override bool TestTarget(Construction.Target target)
	{
		if (!base.TestTarget(target))
		{
			return false;
		}
		return IsCompatible(target.socket);
	}

	public override bool IsCompatible(Socket_Base socket)
	{
		if (!base.IsCompatible(socket))
		{
			return false;
		}
		ConstructionSocket constructionSocket = socket as ConstructionSocket;
		if (constructionSocket == null)
		{
			return false;
		}
		if (constructionSocket.socketType == Type.None || socketType == Type.None)
		{
			return false;
		}
		if (constructionSocket.socketType != socketType)
		{
			return false;
		}
		return true;
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		Matrix4x4 val = Matrix4x4.TRS(position, rotation, Vector3.one);
		Matrix4x4 val2 = Matrix4x4.TRS(socketPosition, socketRotation, Vector3.one);
		Vector3 val3 = ((Matrix4x4)(ref val)).MultiplyPoint3x4(worldPosition);
		Vector3 val4 = ((Matrix4x4)(ref val2)).MultiplyPoint3x4(socket.worldPosition);
		if (Vector3.Distance(val3, val4) > 0.02f)
		{
			return false;
		}
		Vector3 val5 = ((Matrix4x4)(ref val)).MultiplyVector(worldRotation * Vector3.forward);
		Vector3 val6 = ((Matrix4x4)(ref val2)).MultiplyVector(socket.worldRotation * Vector3.forward);
		float num = Vector3.Angle(val5, val6);
		if (male && female)
		{
			num = Mathf.Min(num, Vector3.Angle(-val5, val6));
		}
		if (socket.male && socket.female)
		{
			num = Mathf.Min(num, Vector3.Angle(val5, -val6));
		}
		if (num > 2f)
		{
			return false;
		}
		return true;
	}

	public bool TestRestrictedAngles(Vector3 suggestedPos, Quaternion suggestedAng, Construction.Target target)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (restrictPlacementAngle)
		{
			Quaternion val = Quaternion.Euler(0f, faceAngle, 0f) * suggestedAng;
			float num = Vector3Ex.DotDegrees(Vector3Ex.XZ3D(((Ray)(ref target.ray)).direction), val * Vector3.forward);
			if (num > angleAllowed * 0.5f)
			{
				return false;
			}
			if (num < angleAllowed * -0.5f)
			{
				return false;
			}
		}
		return true;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)target.entity) || !Object.op_Implicit((Object)(object)((Component)target.entity).transform))
		{
			return default(Construction.Placement);
		}
		if (!CanConnectToEntity(target))
		{
			return default(Construction.Placement);
		}
		ConstructionSocket constructionSocket = target.socket as ConstructionSocket;
		Vector3 val = target.GetWorldPosition();
		Quaternion val2 = target.GetWorldRotation(female: true);
		if (constructionSocket != null && !IsCompatible(constructionSocket))
		{
			return default(Construction.Placement);
		}
		if (wantsInside)
		{
			Vector3 pos = ((Component)target.entity).transform.position + localPosition + ((Component)target.entity).transform.right * 0.2f;
			if (IsOutside(pos, ((Component)target.entity).transform))
			{
				Construction.lastPlacementError = ConstructionErrors.WantsInside;
				return default(Construction.Placement);
			}
		}
		if (rotationDegrees > 0 && (constructionSocket == null || !constructionSocket.restrictPlacementRotation))
		{
			Construction.Placement placement = new Construction.Placement(target);
			float num = float.MaxValue;
			float num2 = 0f;
			for (int i = 0; i < 360; i += rotationDegrees)
			{
				Quaternion val3 = Quaternion.Euler(0f, (float)(rotationOffset + i), 0f);
				Vector3 direction = ((Ray)(ref target.ray)).direction;
				Vector3 val4 = val3 * val2 * Vector3.up;
				float num3 = Vector3.Angle(direction, val4);
				if (num3 < num)
				{
					num = num3;
					num2 = i;
				}
			}
			for (int j = 0; j < 360; j += rotationDegrees)
			{
				Quaternion val5 = val2 * Quaternion.Inverse(rotation);
				Quaternion val6 = Quaternion.Euler(target.rotation);
				Quaternion val7 = Quaternion.Euler(0f, (float)(rotationOffset + j) + num2, 0f);
				Quaternion val8 = val6 * val7 * val5;
				Vector3 val9 = val8 * position;
				placement.position = val - val9;
				placement.rotation = val8;
				if (CheckSocketMods(ref placement))
				{
					return placement;
				}
			}
		}
		Construction.Placement result = new Construction.Placement(target);
		Quaternion val10 = val2 * Quaternion.Inverse(rotation);
		if (ShouldInheritFemaleSocketRotation(socketType))
		{
			Quaternion val11 = Quaternion.Euler(target.rotation);
			val10 *= val11;
		}
		Vector3 val12 = val10 * position;
		result.position = val - val12;
		result.rotation = val10;
		if (!TestRestrictedAngles(val, val2, target))
		{
			return default(Construction.Placement);
		}
		return result;
	}

	protected virtual bool CanConnectToEntity(Construction.Target target)
	{
		return true;
	}

	private bool ShouldInheritFemaleSocketRotation(Type type)
	{
		if (type != Type.WallFrame && type != Type.Doorway && type != Type.FloorFrameTriangle && type != Type.FloorFrame)
		{
			return type == Type.Shutters;
		}
		return true;
	}

	public bool IsOutside(Vector3 pos, Transform tr)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		float num = 5f;
		for (int i = 0; i < outsideLookupDirs.Length; i++)
		{
			Vector3 val = tr.TransformDirection(outsideLookupDirs[i]);
			Vector3 val2 = pos + val * num;
			if (!Physics.Raycast(new Ray(val2, -val), num - 0.5f, 2097152))
			{
				return true;
			}
		}
		return false;
	}

	static ConstructionSocket()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = new Vector3[4];
		Vector3 val = new Vector3(0f, 1f, 0f);
		array[0] = ((Vector3)(ref val)).normalized;
		val = new Vector3(1f, 0f, 0f);
		array[1] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, 1f);
		array[2] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, -1f);
		array[3] = ((Vector3)(ref val)).normalized;
		outsideLookupDirs = (Vector3[])(object)array;
	}
}


public enum Type
{
	None,
	Foundation,
	Floor,
	Misc,
	Doorway,
	Wall,
	Block,
	Ramp,
	StairsTriangle,
	Stairs,
	FloorFrameTriangle,
	Window,
	Shutters,
	WallFrame,
	FloorFrame,
	WindowDressing,
	DoorDressing,
	Elevator,
	DoubleDoorDressing
}


using UnityEngine;

public class ConstructionSocket_Elevator : ConstructionSocket
{
	public int MaxFloor = 5;

	protected override bool CanConnectToEntity(Construction.Target target)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (target.entity is Elevator elevator && elevator.Floor >= MaxFloor)
		{
			return false;
		}
		Vector3 val = target.GetWorldPosition();
		Quaternion val2 = target.GetWorldRotation(female: true);
		if (GamePhysics.CheckOBB(new OBB(val, new Vector3(2f, 0.5f, 2f), val2), 2097152, (QueryTriggerInteraction)0))
		{
			return false;
		}
		return base.CanConnectToEntity(target);
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		Matrix4x4 val = Matrix4x4.TRS(position, rotation, Vector3.one);
		Vector3 val2 = ((Matrix4x4)(ref val)).MultiplyPoint3x4(worldPosition);
		return !GamePhysics.CheckOBB(new OBB(val2, new Vector3(2f, 0.5f, 2f), rotation), 2097152, (QueryTriggerInteraction)0);
	}
}


public class Construction_SleepingBag : Construction
{
}


using System;
using UnityEngine;

public class DecayPoint : PrefabAttribute
{
	[Tooltip("If this point is occupied this will take this % off the power of the decay")]
	public float protection = 0.25f;

	public Socket_Base socket;

	public bool IsOccupied(BaseEntity entity)
	{
		return entity.IsOccupied(socket);
	}

	protected override Type GetIndexedType()
	{
		return typeof(DecayPoint);
	}
}


using System;
using UnityEngine;

public class DirectionProperties : PrefabAttribute
{
	private const float radius = 200f;

	public Bounds bounds = new Bounds(Vector3.zero, Vector3.zero);

	public ProtectionProperties extraProtection;

	protected override Type GetIndexedType()
	{
		return typeof(DirectionProperties);
	}

	public bool IsWeakspot(Transform tx, HitInfo info)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if (((Bounds)(ref bounds)).size == Vector3.zero)
		{
			return false;
		}
		BasePlayer initiatorPlayer = info.InitiatorPlayer;
		if ((Object)(object)initiatorPlayer == (Object)null)
		{
			return false;
		}
		BaseEntity hitEntity = info.HitEntity;
		if ((Object)(object)hitEntity == (Object)null)
		{
			return false;
		}
		Matrix4x4 worldToLocalMatrix = tx.worldToLocalMatrix;
		Vector3 val = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(info.PointStart) - worldPosition;
		float num = Vector3Ex.DotDegrees(worldForward, val);
		Vector3 val2 = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(info.HitPositionWorld);
		OBB val3 = default(OBB);
		((OBB)(ref val3))..ctor(worldPosition, worldRotation, bounds);
		Vector3 position = initiatorPlayer.eyes.position;
		WeakpointProperties[] array = PrefabAttribute.server.FindAll<WeakpointProperties>(hitEntity.prefabID);
		if (array != null && array.Length != 0)
		{
			bool flag = false;
			WeakpointProperties[] array2 = array;
			foreach (WeakpointProperties weakpointProperties in array2)
			{
				if ((!weakpointProperties.BlockWhenRoofAttached || CheckWeakpointRoof(hitEntity)) && IsWeakspotVisible(hitEntity, position, tx.TransformPoint(weakpointProperties.worldPosition)))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return false;
			}
		}
		else if (!IsWeakspotVisible(hitEntity, position, tx.TransformPoint(val3.position)))
		{
			return false;
		}
		if (num > 100f)
		{
			return ((OBB)(ref val3)).Contains(val2);
		}
		return false;
	}

	private bool CheckWeakpointRoof(BaseEntity hitEntity)
	{
		foreach (EntityLink entityLink in hitEntity.GetEntityLinks())
		{
			if (!(entityLink.socket is NeighbourSocket))
			{
				continue;
			}
			foreach (EntityLink connection in entityLink.connections)
			{
				if (connection.owner is BuildingBlock buildingBlock && (buildingBlock.ShortPrefabName == "roof" || buildingBlock.ShortPrefabName == "roof.triangle"))
				{
					return false;
				}
			}
		}
		return true;
	}

	private bool IsWeakspotVisible(BaseEntity hitEntity, Vector3 playerEyes, Vector3 weakspotPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		if (!hitEntity.IsVisible(playerEyes, weakspotPos))
		{
			return false;
		}
		return true;
	}
}


using System;

public abstract class ModelConditionTest : PrefabAttribute
{
	public abstract bool DoTest(BaseEntity ent);

	protected override Type GetIndexedType()
	{
		return typeof(ModelConditionTest);
	}
}


public class ModelConditionTest_False : ModelConditionTest
{
	public ConditionalModel reference;

	public override bool DoTest(BaseEntity ent)
	{
		return !reference.RunTests(ent);
	}
}


using UnityEngine;

public class ModelConditionTest_FoundationSide : ModelConditionTest
{
	private const string square_south = "foundation/sockets/foundation-top/1";

	private const string square_north = "foundation/sockets/foundation-top/3";

	private const string square_west = "foundation/sockets/foundation-top/2";

	private const string square_east = "foundation/sockets/foundation-top/4";

	private const string triangle_south = "foundation.triangle/sockets/foundation-top/1";

	private const string triangle_northwest = "foundation.triangle/sockets/foundation-top/2";

	private const string triangle_northeast = "foundation.triangle/sockets/foundation-top/3";

	private string socket = string.Empty;

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(1.5f, 1.5f, 0f), new Vector3(3f, 3f, 3f));
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = worldRotation * Vector3.right;
		if (name.Contains("foundation.triangle"))
		{
			if (val.z < -0.9f)
			{
				socket = "foundation.triangle/sockets/foundation-top/1";
			}
			if (val.x < -0.1f)
			{
				socket = "foundation.triangle/sockets/foundation-top/2";
			}
			if (val.x > 0.1f)
			{
				socket = "foundation.triangle/sockets/foundation-top/3";
			}
			return;
		}
		if (val.z < -0.9f)
		{
			socket = "foundation/sockets/foundation-top/1";
		}
		if (val.z > 0.9f)
		{
			socket = "foundation/sockets/foundation-top/3";
		}
		if (val.x < -0.9f)
		{
			socket = "foundation/sockets/foundation-top/2";
		}
		if (val.x > 0.9f)
		{
			socket = "foundation/sockets/foundation-top/4";
		}
	}

	public override bool DoTest(BaseEntity ent)
	{
		EntityLink entityLink = ent.FindLink(socket);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock == (Object)null) && !(buildingBlock.blockDefinition.info.name.token == "foundation_steps"))
			{
				if (buildingBlock.grade == BuildingGrade.Enum.TopTier)
				{
					return false;
				}
				if (buildingBlock.grade == BuildingGrade.Enum.Metal)
				{
					return false;
				}
				if (buildingBlock.grade == BuildingGrade.Enum.Stone)
				{
					return false;
				}
			}
		}
		return true;
	}
}


public class ModelConditionTest_Inside : ModelConditionTest
{
	public override bool DoTest(BaseEntity ent)
	{
		return !ModelConditionTest_Outside.CheckCondition(ent);
	}
}


public class ModelConditionTest_Outside : ModelConditionTest
{
	public override bool DoTest(BaseEntity ent)
	{
		return CheckCondition(ent);
	}

	public static bool CheckCondition(BaseEntity ent)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		OBB val = ent.WorldSpaceBounds();
		return ent.IsOutside(((OBB)(ref val)).GetPoint(0f, 1f, 0f));
	}
}


using UnityEngine;

public class ModelConditionTest_RampHigh : ModelConditionTest
{
	private const string socket = "ramp/sockets/block-male/1";

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, 0.75f, 0f), new Vector3(3f, 1.5f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		return ent.FindLink("ramp/sockets/block-male/1")?.IsEmpty() ?? false;
	}
}


using UnityEngine;

public class ModelConditionTest_RampLow : ModelConditionTest
{
	private const string socket = "ramp/sockets/block-male/1";

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, 0.375f, 0f), new Vector3(3f, 0.75f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		EntityLink entityLink = ent.FindLink("ramp/sockets/block-male/1");
		if (entityLink == null)
		{
			return false;
		}
		return !entityLink.IsEmpty();
	}
}


using UnityEngine;

public class ModelConditionTest_RoofBottom : ModelConditionTest
{
	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_bot_right = "sockets/neighbour/3";

	private const string socket_bot_left = "sockets/neighbour/4";

	private const string socket_top_right = "sockets/neighbour/5";

	private const string socket_top_left = "sockets/neighbour/6";

	private static string[] sockets_bot_right = new string[2] { "roof/sockets/neighbour/3", "roof.triangle/sockets/neighbour/3" };

	private static string[] sockets_bot_left = new string[2] { "roof/sockets/neighbour/4", "roof.triangle/sockets/neighbour/4" };

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, -1.5f, 3f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		bool flag = false;
		bool flag2 = false;
		EntityLink entityLink = ent.FindLink(sockets_bot_right);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			if (entityLink.connections[i].name.EndsWith("sockets/neighbour/5"))
			{
				flag = true;
				break;
			}
		}
		EntityLink entityLink2 = ent.FindLink(sockets_bot_left);
		if (entityLink2 == null)
		{
			return false;
		}
		for (int j = 0; j < entityLink2.connections.Count; j++)
		{
			if (entityLink2.connections[j].name.EndsWith("sockets/neighbour/6"))
			{
				flag2 = true;
				break;
			}
		}
		if (flag && flag2)
		{
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class ModelConditionTest_RoofLeft : ModelConditionTest
{
	public enum AngleType
	{
		None = -1,
		Straight = 0,
		Convex60 = 60,
		Convex90 = 90,
		Convex120 = 120,
		Concave30 = -30,
		Concave60 = -60,
		Concave90 = -90,
		Concave120 = -120
	}

	public enum ShapeType
	{
		Any = -1,
		Square,
		Triangle
	}

	public AngleType angle = AngleType.None;

	public ShapeType shape = ShapeType.Any;

	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_right = "sockets/neighbour/3";

	private const string socket_left = "sockets/neighbour/4";

	private static string[] sockets_left = new string[2] { "roof/sockets/neighbour/4", "roof.triangle/sockets/neighbour/4" };

	private bool IsConvex => angle > (AngleType)10;

	private bool IsConcave => angle < (AngleType)(-10);

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(3f, 1.5f, 0f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink(sockets_left);
		if (entityLink == null)
		{
			return false;
		}
		if (angle == AngleType.None)
		{
			for (int i = 0; i < entityLink.connections.Count; i++)
			{
				if (entityLink.connections[i].name.EndsWith("sockets/neighbour/3"))
				{
					return false;
				}
			}
			return true;
		}
		if (entityLink.IsEmpty())
		{
			return false;
		}
		bool result = false;
		for (int j = 0; j < entityLink.connections.Count; j++)
		{
			EntityLink entityLink2 = entityLink.connections[j];
			if (!entityLink2.name.EndsWith("sockets/neighbour/3") || (shape == ShapeType.Square && !entityLink2.name.StartsWith("roof/")) || (shape == ShapeType.Triangle && !entityLink2.name.StartsWith("roof.triangle/")))
			{
				continue;
			}
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null || buildingBlock2.grade != buildingBlock.grade)
			{
				continue;
			}
			int num = (int)angle;
			float num2 = Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (num2 < (float)(num - 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else if (num2 > (float)(num + 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else
			{
				result = true;
			}
		}
		return result;
	}
}


public enum AngleType
{
	None = -1,
	Straight = 0,
	Convex60 = 60,
	Convex90 = 90,
	Convex120 = 120,
	Concave30 = -30,
	Concave60 = -60,
	Concave90 = -90,
	Concave120 = -120
}


public enum ShapeType
{
	Any = -1,
	Square,
	Triangle
}


using UnityEngine;

public class ModelConditionTest_RoofRight : ModelConditionTest
{
	public enum AngleType
	{
		None = -1,
		Straight = 0,
		Convex60 = 60,
		Convex90 = 90,
		Convex120 = 120,
		Concave30 = -30,
		Concave60 = -60,
		Concave90 = -90,
		Concave120 = -120
	}

	public enum ShapeType
	{
		Any = -1,
		Square,
		Triangle
	}

	public AngleType angle = AngleType.None;

	public ShapeType shape = ShapeType.Any;

	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_right = "sockets/neighbour/3";

	private const string socket_left = "sockets/neighbour/4";

	private static string[] sockets_right = new string[2] { "roof/sockets/neighbour/3", "roof.triangle/sockets/neighbour/3" };

	private bool IsConvex => angle > (AngleType)10;

	private bool IsConcave => angle < (AngleType)(-10);

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(-3f, 1.5f, 0f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink(sockets_right);
		if (entityLink == null)
		{
			return false;
		}
		if (angle == AngleType.None)
		{
			for (int i = 0; i < entityLink.connections.Count; i++)
			{
				if (entityLink.connections[i].name.EndsWith("sockets/neighbour/4"))
				{
					return false;
				}
			}
			return true;
		}
		if (entityLink.IsEmpty())
		{
			return false;
		}
		bool result = false;
		for (int j = 0; j < entityLink.connections.Count; j++)
		{
			EntityLink entityLink2 = entityLink.connections[j];
			if (!entityLink2.name.EndsWith("sockets/neighbour/4") || (shape == ShapeType.Square && !entityLink2.name.StartsWith("roof/")) || (shape == ShapeType.Triangle && !entityLink2.name.StartsWith("roof.triangle/")))
			{
				continue;
			}
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null || buildingBlock2.grade != buildingBlock.grade)
			{
				continue;
			}
			int num = (int)angle;
			float num2 = 0f - Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (num2 < (float)(num - 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else if (num2 > (float)(num + 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else
			{
				result = true;
			}
		}
		return result;
	}
}


public enum AngleType
{
	None = -1,
	Straight = 0,
	Convex60 = 60,
	Convex90 = 90,
	Convex120 = 120,
	Concave30 = -30,
	Concave60 = -60,
	Concave90 = -90,
	Concave120 = -120
}


public enum ShapeType
{
	Any = -1,
	Square,
	Triangle
}


using UnityEngine;

public class ModelConditionTest_RoofTop : ModelConditionTest
{
	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_bot_right = "sockets/neighbour/3";

	private const string socket_bot_left = "sockets/neighbour/4";

	private const string socket_top_right = "sockets/neighbour/5";

	private const string socket_top_left = "sockets/neighbour/6";

	private static string[] sockets_top_right = new string[2] { "roof/sockets/neighbour/5", "roof.triangle/sockets/neighbour/5" };

	private static string[] sockets_top_left = new string[2] { "roof/sockets/neighbour/6", "roof.triangle/sockets/neighbour/6" };

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, -1.5f, 3f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		bool flag = false;
		bool flag2 = false;
		EntityLink entityLink = ent.FindLink(sockets_top_right);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			if (entityLink.connections[i].name.EndsWith("sockets/neighbour/3"))
			{
				flag = true;
				break;
			}
		}
		EntityLink entityLink2 = ent.FindLink(sockets_top_left);
		if (entityLink2 == null)
		{
			return false;
		}
		for (int j = 0; j < entityLink2.connections.Count; j++)
		{
			if (entityLink2.connections[j].name.EndsWith("sockets/neighbour/4"))
			{
				flag2 = true;
				break;
			}
		}
		if (flag && flag2)
		{
			return false;
		}
		return true;
	}
}


public class ModelConditionTest_RoofTriangle : ModelConditionTest
{
	private const string socket = "roof/sockets/wall-female";

	public override bool DoTest(BaseEntity ent)
	{
		EntityLink entityLink = ent.FindLink("roof/sockets/wall-female");
		if (entityLink == null)
		{
			return true;
		}
		if (!entityLink.IsEmpty())
		{
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class ModelConditionTest_SpiralStairs : ModelConditionTest
{
	private const string stairs_socket_female = "sockets/stairs-female/1";

	private static string[] stairs_sockets_female = new string[2] { "block.stair.spiral/sockets/stairs-female/1", "block.stair.spiral.triangle/sockets/stairs-female/1" };

	private const string floor_socket_female = "sockets/floor-female/1";

	private static string[] floor_sockets_female = new string[2] { "block.stair.spiral/sockets/floor-female/1", "block.stair.spiral.triangle/sockets/floor-female/1" };

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, 2.35f, 0f), new Vector3(3f, 1.5f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink(stairs_sockets_female);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock2 = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock2 == (Object)null) && buildingBlock2.grade == buildingBlock.grade)
			{
				return false;
			}
		}
		EntityLink entityLink2 = ent.FindLink(floor_sockets_female);
		if (entityLink2 == null)
		{
			return true;
		}
		if (!entityLink2.IsEmpty())
		{
			return false;
		}
		return true;
	}
}


public class ModelConditionTest_True : ModelConditionTest
{
	public ConditionalModel reference;

	public override bool DoTest(BaseEntity ent)
	{
		return reference.RunTests(ent);
	}
}


public class ModelConditionTest_Variant : ModelConditionTest
{
	public ulong VariantSeed;

	public ulong VariantIndex;

	public ulong VariantCount = 3uL;

	public override bool DoTest(BaseEntity ent)
	{
		ulong num = ent.net.ID.Value + VariantSeed;
		SeedRandom.Wanghash(ref num);
		SeedRandom.Wanghash(ref num);
		SeedRandom.Wanghash(ref num);
		return num % VariantCount == VariantIndex;
	}
}


public class ModelConditionTest_Wall : ModelConditionTest
{
	public override bool DoTest(BaseEntity ent)
	{
		if (!ModelConditionTest_WallTriangleLeft.CheckCondition(ent))
		{
			return !ModelConditionTest_WallTriangleRight.CheckCondition(ent);
		}
		return false;
	}
}


using UnityEngine;

public class ModelConditionTest_WallCornerLeft : ModelConditionTest
{
	private const string socket = "sockets/stability/2";

	private static string[] sockets = new string[5] { "wall/sockets/stability/2", "wall.half/sockets/stability/2", "wall.low/sockets/stability/2", "wall.doorway/sockets/stability/2", "wall.window/sockets/stability/2" };

	public override bool DoTest(BaseEntity ent)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		EntityLink entityLink = ent.FindLink(sockets);
		if (entityLink == null)
		{
			return false;
		}
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		bool result = false;
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			EntityLink entityLink2 = entityLink.connections[i];
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null)
			{
				continue;
			}
			float num = Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (entityLink2.name.EndsWith("sockets/stability/2"))
			{
				if (num > -10f || num < -100f)
				{
					return false;
				}
				continue;
			}
			if (num < 10f && num > -10f)
			{
				return false;
			}
			if (num < -10f)
			{
				return false;
			}
			if (buildingBlock2.grade == buildingBlock.grade)
			{
				result = true;
			}
		}
		return result;
	}
}


using UnityEngine;

public class ModelConditionTest_WallCornerRight : ModelConditionTest
{
	private const string socket = "sockets/stability/1";

	private static string[] sockets = new string[5] { "wall/sockets/stability/1", "wall.half/sockets/stability/1", "wall.low/sockets/stability/1", "wall.doorway/sockets/stability/1", "wall.window/sockets/stability/1" };

	public override bool DoTest(BaseEntity ent)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		EntityLink entityLink = ent.FindLink(sockets);
		if (entityLink == null)
		{
			return false;
		}
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		bool result = false;
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			EntityLink entityLink2 = entityLink.connections[i];
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null)
			{
				continue;
			}
			float num = Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (entityLink2.name.EndsWith("sockets/stability/1"))
			{
				if (num < 10f || num > 100f)
				{
					return false;
				}
				continue;
			}
			if (num < 10f && num > -10f)
			{
				return false;
			}
			if (num > 10f)
			{
				return false;
			}
			if (buildingBlock2.grade == buildingBlock.grade)
			{
				result = true;
			}
		}
		return result;
	}
}


using UnityEngine;

public class ModelConditionTest_Wallpaper : ModelConditionTest
{
	public bool wantsWallpaper = true;

	public bool softSide;

	public override bool DoTest(BaseEntity ent)
	{
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		bool flag = buildingBlock.HasWallpaper((!softSide) ? 1 : 0);
		if (!wantsWallpaper)
		{
			return !flag;
		}
		return flag;
	}
}


using UnityEngine;

public class ModelConditionTest_WallTriangleLeft : ModelConditionTest
{
	private const string socket_1 = "wall/sockets/wall-female";

	private const string socket_2 = "wall/sockets/floor-female/1";

	private const string socket_3 = "wall/sockets/floor-female/2";

	private const string socket_4 = "wall/sockets/floor-female/3";

	private const string socket_5 = "wall/sockets/floor-female/4";

	private const string socket_6 = "wall/sockets/stability/1";

	private const string socket = "wall/sockets/neighbour/1";

	public static bool CheckCondition(BaseEntity ent)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		if (CheckSocketOccupied(ent, "wall/sockets/wall-female"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/1"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/2"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/3"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/4"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/stability/1"))
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink("wall/sockets/neighbour/1");
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock == (Object)null))
			{
				if (buildingBlock.blockDefinition.info.name.token == "roof" && Vector3.Angle(((Component)ent).transform.forward, ((Component)buildingBlock).transform.forward) < 10f)
				{
					return true;
				}
				if (buildingBlock.blockDefinition.info.name.token == "roof_triangle" && Vector3.Angle(((Component)ent).transform.forward, ((Component)buildingBlock).transform.forward) < 40f)
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool CheckSocketOccupied(BaseEntity ent, string socket)
	{
		EntityLink entityLink = ent.FindLink(socket);
		if (entityLink == null)
		{
			return false;
		}
		return !entityLink.IsEmpty();
	}

	public override bool DoTest(BaseEntity ent)
	{
		return CheckCondition(ent);
	}
}


using UnityEngine;

public class ModelConditionTest_WallTriangleRight : ModelConditionTest
{
	private const string socket_1 = "wall/sockets/wall-female";

	private const string socket_2 = "wall/sockets/floor-female/1";

	private const string socket_3 = "wall/sockets/floor-female/2";

	private const string socket_4 = "wall/sockets/floor-female/3";

	private const string socket_5 = "wall/sockets/floor-female/4";

	private const string socket_6 = "wall/sockets/stability/2";

	private const string socket = "wall/sockets/neighbour/1";

	public static bool CheckCondition(BaseEntity ent)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		if (CheckSocketOccupied(ent, "wall/sockets/wall-female"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/1"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/2"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/3"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/4"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/stability/2"))
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink("wall/sockets/neighbour/1");
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock == (Object)null))
			{
				if (buildingBlock.blockDefinition.info.name.token == "roof" && Vector3.Angle(((Component)ent).transform.forward, -((Component)buildingBlock).transform.forward) < 10f)
				{
					return true;
				}
				if (buildingBlock.blockDefinition.info.name.token == "roof_triangle" && Vector3.Angle(((Component)ent).transform.forward, -((Component)buildingBlock).transform.forward) < 40f)
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool CheckSocketOccupied(BaseEntity ent, string socket)
	{
		EntityLink entityLink = ent.FindLink(socket);
		if (entityLink == null)
		{
			return false;
		}
		return !entityLink.IsEmpty();
	}

	public override bool DoTest(BaseEntity ent)
	{
		return CheckCondition(ent);
	}
}


using UnityEngine;

public class NeighbourSocket : Socket_Base
{
	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.DrawWireCube(selectCenter, selectSize);
	}

	public override bool TestTarget(Construction.Target target)
	{
		return false;
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		OBB selectBounds = GetSelectBounds(position, rotation);
		OBB selectBounds2 = socket.GetSelectBounds(socketPosition, socketRotation);
		return ((OBB)(ref selectBounds)).Intersects(selectBounds2);
	}
}


using System;
using UnityEngine;

public class SocketHandle : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(SocketHandle);
	}

	internal void AdjustTarget(ref Construction.Target target, float maxplaceDistance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = worldPosition;
		Vector3 val2 = ((Ray)(ref target.ray)).origin + ((Ray)(ref target.ray)).direction * maxplaceDistance - val;
		ref Ray ray = ref target.ray;
		Vector3 val3 = val2 - ((Ray)(ref target.ray)).origin;
		((Ray)(ref ray)).direction = ((Vector3)(ref val3)).normalized;
	}
}


using System;
using UnityEngine;

public abstract class SocketMod : PrefabAttribute
{
	[NonSerialized]
	public Socket_Base baseSocket;

	public Phrase FailedPhrase;

	public SocketMod_Grouping SocketGrouping { get; private set; }

	protected virtual Phrase ErrorPhrase => Phrase.op_Implicit(string.Empty);

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		Transform parent = ((Component)this).transform.parent;
		SocketGrouping = ((parent != null) ? ((Component)parent).GetComponent<SocketMod_Grouping>() : null);
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
	}

	public virtual Phrase GetTranslatedErrorMessage()
	{
		if (!string.IsNullOrEmpty(FailedPhrase.token))
		{
			return FailedPhrase;
		}
		return ErrorPhrase;
	}

	public virtual string GetDebugErrorMessage()
	{
		return hierachyName ?? "";
	}

	public virtual bool DoCheck(Construction.Placement place)
	{
		return false;
	}

	public virtual void ModifyPlacement(ref Construction.Placement place)
	{
	}

	protected override Type GetIndexedType()
	{
		return typeof(SocketMod);
	}
}


using UnityEngine;

public class SocketMod_AngleCheck : SocketMod
{
	public bool wantsAngle = true;

	public Vector3 worldNormal = Vector3.up;

	public float withinDegrees = 45f;

	public bool usePlacementNormal;

	protected override Phrase ErrorPhrase => ConstructionErrors.InvalidAngle;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = (usePlacementNormal ? Vector3.forward : Vector3.up);
		float num = Vector3Ex.DotDegrees(worldNormal, place.rotation * val);
		if (!usePlacementNormal)
		{
			return num < withinDegrees;
		}
		return num >= withinDegrees;
	}
}


using UnityEngine;

public class SocketMod_AreaCheck : SocketMod
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 0.1f);

	public LayerMask layerMask;

	public bool wantsInside = true;

	private Phrase lastError = new Phrase("", "");

	protected override Phrase ErrorPhrase => lastError;

	public static bool IsInArea(Vector3 position, Quaternion rotation, Bounds bounds, LayerMask layerMask, BaseEntity entity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckOBBAndEntity(new OBB(position, rotation, bounds), ((LayerMask)(ref layerMask)).value, (QueryTriggerInteraction)0, entity);
	}

	public bool DoCheck(Vector3 position, Quaternion rotation, BaseEntity entity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position2 = position + rotation * worldPosition;
		Quaternion rotation2 = rotation * worldRotation;
		return IsInArea(position2, rotation2, bounds, layerMask, entity) == wantsInside;
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		bool flag = DoCheck(place.position, place.rotation);
		if (!flag)
		{
			lastError = ConstructionErrors.NotStableEnough;
			if (LayerMask.op_Implicit(layerMask) == 2097152 || LayerMask.op_Implicit(layerMask) == 136314880)
			{
				lastError = (wantsInside ? ConstructionErrors.MustPlaceOnConstruction : ConstructionErrors.CantPlaceOnConstruction);
			}
		}
		else if (wantsInside && (LayerMask.op_Implicit(layerMask) & 0x8000000) == 0)
		{
			flag = !GamePhysics.CheckSphere(place.position, 5f, 134217728, (QueryTriggerInteraction)0);
			if (!flag)
			{
				lastError = ConstructionErrors.InvalidAreaVehicleLarge;
			}
		}
		if (flag)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_Attraction : SocketMod
{
	public float outerRadius = 1f;

	public float innerRadius = 0.1f;

	public string groupName = "wallbottom";

	public bool lockRotation;

	public bool bypassPlayerRotation;

	public bool ignoreRotationForRadiusCheck;

	public bool shiftDisableSnap = true;

	public bool shiftEnableSnap;

	public bool applyPostRotationSnapping;

	private static float[] PostSnapRotations = new float[4] { 0f, 90f, 180f, 270f };

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
		Gizmos.DrawSphere(Vector3.zero, outerRadius);
		Gizmos.color = new Color(0f, 1f, 0f, 0.6f);
		Gizmos.DrawSphere(Vector3.zero, innerRadius);
	}

	public override bool DoCheck(Construction.Placement place)
	{
		return true;
	}

	public override void ModifyPlacement(ref Construction.Placement place)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		if ((shiftEnableSnap && !place.isHoldingShift) || (shiftDisableSnap && place.isHoldingShift))
		{
			return;
		}
		Vector3 val = place.position + place.rotation * worldPosition;
		Quaternion rotation = place.rotation;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(val, outerRadius * 2f, list, -1, (QueryTriggerInteraction)2);
		Vector3 position = Vector3.zero;
		float num = float.MaxValue;
		Vector3 position2 = place.position;
		Quaternion rotation2 = Quaternion.identity;
		foreach (BaseEntity item in list)
		{
			if (item.isServer != isServer)
			{
				continue;
			}
			AttractionPoint[] array = prefabAttribute.FindAll<AttractionPoint>(item.prefabID);
			if (array == null)
			{
				continue;
			}
			AttractionPoint[] array2 = array;
			foreach (AttractionPoint attractionPoint in array2)
			{
				if (attractionPoint.groupName != groupName)
				{
					continue;
				}
				Vector3 val2 = ((Component)item).transform.position + ((Component)item).transform.rotation * attractionPoint.worldPosition;
				Vector3 val3 = val2 - val;
				float magnitude = ((Vector3)(ref val3)).magnitude;
				if (ignoreRotationForRadiusCheck)
				{
					Vector3 val4 = ((Component)item).transform.TransformPoint(Vector3.LerpUnclamped(Vector3.zero, Vector3Ex.WithY(attractionPoint.worldPosition, 0f), 2f));
					float num2 = Vector3.Distance(val4, position2);
					if (num2 < num)
					{
						num = num2;
						position = val4;
						rotation2 = ((Component)item).transform.rotation;
					}
				}
				if (magnitude > outerRadius)
				{
					continue;
				}
				Quaternion val5 = ((lockRotation && bypassPlayerRotation) ? (((Component)item).transform.rotation * attractionPoint.localRotation) : QuaternionEx.LookRotationWithOffset(worldPosition, val2 - place.position, Vector3.up));
				float num3 = Mathf.InverseLerp(outerRadius, innerRadius, magnitude);
				if (lockRotation)
				{
					num3 = 1f;
				}
				if (lockRotation)
				{
					if (bypassPlayerRotation)
					{
						place.rotation = ((Component)item).transform.rotation * attractionPoint.localRotation;
					}
					else
					{
						Vector3 eulerAngles = ((Quaternion)(ref place.rotation)).eulerAngles;
						eulerAngles -= new Vector3(eulerAngles.x % 90f, eulerAngles.y % 90f, eulerAngles.z % 90f);
						place.rotation = Quaternion.Euler(eulerAngles + ((Component)item).transform.eulerAngles);
					}
				}
				else
				{
					place.rotation = Quaternion.Lerp(place.rotation, val5, num3);
				}
				val = place.position + place.rotation * worldPosition;
				val3 = val2 - val;
				place.position += val3 * num3;
			}
		}
		if (num < float.MaxValue && ignoreRotationForRadiusCheck)
		{
			place.position = position;
			place.rotation = rotation2;
		}
		if (applyPostRotationSnapping)
		{
			Quaternion rotation3 = place.rotation;
			float num4 = float.MaxValue;
			float[] postSnapRotations = PostSnapRotations;
			foreach (float num5 in postSnapRotations)
			{
				Quaternion val6 = place.rotation * Quaternion.Euler(0f, num5, 0f);
				float num6 = Quaternion.Angle(val6, rotation);
				if (num6 < num4)
				{
					num4 = num6;
					rotation3 = val6;
				}
			}
			if (num4 < float.MaxValue)
			{
				place.rotation = rotation3;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_BuildingBlock : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public bool wantsCollide;

	protected override Phrase ErrorPhrase => ConstructionErrors.MustPlaceOnConstruction;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		bool flag = list.Count > 0;
		if (flag && wantsCollide)
		{
			Pool.FreeUnmanaged<BuildingBlock>(ref list);
			return true;
		}
		if (flag && !wantsCollide)
		{
			Pool.FreeUnmanaged<BuildingBlock>(ref list);
			return false;
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
		return !wantsCollide;
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public class SocketMod_EntityCheck : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public BaseEntity[] entityTypes;

	public bool wantsCollide;

	protected override Phrase ErrorPhrase => ConstructionErrors.InvalidEntity;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		bool result = !wantsCollide;
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		foreach (BaseEntity ent in list)
		{
			bool flag = entityTypes.Any((BaseEntity x) => x.prefabID == ent.prefabID);
			if (flag && wantsCollide)
			{
				result = true;
				break;
			}
			if (flag && !wantsCollide)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_EntityType : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public BaseEntity searchType;

	public bool wantsCollide;

	protected override Phrase ErrorPhrase => ConstructionErrors.InvalidEntityType;

	public override string GetDebugErrorMessage()
	{
		return base.GetDebugErrorMessage() + $" {searchType}";
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		bool result = !wantsCollide;
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		foreach (BaseEntity item in list)
		{
			bool flag = ((object)item).GetType().IsAssignableFrom(((object)searchType).GetType());
			if (flag && wantsCollide)
			{
				result = true;
				break;
			}
			if (flag && !wantsCollide)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


public class SocketMod_EnvironmentVolume : SocketMod
{
	[InspectorFlags]
	public EnvironmentType environmentNone;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		EnvironmentType environmentType = EnvironmentManager.Get(place.position + place.rotation * worldPosition);
		if (environmentNone != 0 && (environmentType & environmentNone) != 0)
		{
			EnvironmentType blockedTypes = environmentType & environmentNone;
			Construction.lastPlacementError = Phrase.op_Implicit(GetErrorMessage(blockedTypes));
			return false;
		}
		return true;
	}

	private string GetErrorMessage(EnvironmentType blockedTypes)
	{
		string text = "Can't be placed ";
		if (blockedTypes.HasFlag(EnvironmentType.TrainTunnels))
		{
			return text + "In Train Tunnels";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Underground))
		{
			return text + "Underground";
		}
		if (blockedTypes.HasFlag(EnvironmentType.NoSunlight))
		{
			return text + "In The Dark";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Submarine))
		{
			return text + "In A Submarine";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Outdoor))
		{
			return text + "Outdoors";
		}
		if (blockedTypes.HasFlag(EnvironmentType.PlayerConstruction))
		{
			return text + "Near Player Construction";
		}
		if (blockedTypes.HasFlag(EnvironmentType.UnderwaterLab))
		{
			return text + "In Underwater Labs";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Elevator))
		{
			return text + "Near Elevators";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Building) || blockedTypes.HasFlag(EnvironmentType.BuildingDark) || blockedTypes.HasFlag(EnvironmentType.BuildingVeryDark))
		{
			return text + "In A Building";
		}
		return text + "(Unknown Environment)";
	}
}


using System.Collections.Generic;
using UnityEngine;

public class SocketMod_Grouping : SocketMod
{
	private List<SocketMod> SocketMods;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		SocketMods = new List<SocketMod>();
		foreach (Transform child in ((Component)this).transform.GetChildren())
		{
			SocketMods.AddRange(((Component)child).GetComponents<SocketMod>());
		}
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
	}

	public override bool DoCheck(Construction.Placement place)
	{
		if (SocketMods == null || SocketMods.Count == 0)
		{
			return true;
		}
		foreach (SocketMod socketMod in SocketMods)
		{
			if (socketMod.DoCheck(place))
			{
				return true;
			}
		}
		return false;
	}
}


using UnityEngine;

public class SocketMod_HotSpot : SocketMod
{
	public float spotSize = 0.1f;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = new Color(1f, 1f, 0f, 0.5f);
		Gizmos.DrawSphere(Vector3.zero, spotSize);
	}

	public override void ModifyPlacement(ref Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		place.position = position;
	}
}


using System;
using Rust;
using UnityEngine;

public class SocketMod_Inside : SocketMod
{
	public bool wantsInside = true;

	public bool customDirections;

	public Vector3[] customRayDirections;

	private static readonly Vector3[] outsideLookupDirs;

	protected override Phrase ErrorPhrase
	{
		get
		{
			if (!wantsInside)
			{
				return ConstructionErrors.WantsOutside;
			}
			return ConstructionErrors.WantsInside;
		}
	}

	private Vector3[] directions
	{
		get
		{
			if (!customDirections)
			{
				return outsideLookupDirs;
			}
			return customRayDirections;
		}
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = place.position + place.rotation * baseSocket.localPosition;
		Quaternion val2 = place.rotation * baseSocket.localRotation;
		Vector3 pos = val + val2 * localPosition;
		Quaternion rotation = val2 * localRotation;
		bool flag = IsOutside(pos, rotation, directions);
		return !wantsInside == flag;
	}

	public static bool IsOutside(Vector3 pos, Transform tr, int layerMask = 2162688)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return IsOutside(pos, tr.rotation, outsideLookupDirs, layerMask);
	}

	public static bool IsOutside(Vector3 pos, Transform tr, Vector3[] dirs, int layerMask = 2162688)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return IsOutside(pos, tr.rotation, dirs, layerMask);
	}

	public static bool IsOutside(Vector3 pos, Quaternion rotation, Vector3[] dirs, int layerMask = 2162688)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SocketMod_Inside.IsOutside", 0);
		try
		{
			float num = 20f;
			int num2 = 0;
			bool flag = true;
			RaycastHit val3 = default(RaycastHit);
			for (int i = 0; i < dirs.Length; i++)
			{
				Vector3 val2 = rotation * dirs[i];
				if (Physics.Raycast(new Ray(pos, val2), ref val3, num - 0.5f, layerMask))
				{
					if (((Component)((RaycastHit)(ref val3)).collider).gameObject.IsOnLayer((Layer)21))
					{
						num2++;
					}
				}
				else
				{
					flag = false;
				}
			}
			if (flag)
			{
				return num2 < 2;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	static SocketMod_Inside()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = new Vector3[8];
		Vector3 val = new Vector3(1f, 1f, 0f);
		array[0] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, -1f, 0f);
		array[1] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 1f, 1f);
		array[2] = ((Vector3)(ref val)).normalized;
		val = new Vector3(-1f, 1f, 0f);
		array[3] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, 1f);
		array[4] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 1f, 0f);
		array[5] = ((Vector3)(ref val)).normalized;
		val = new Vector3(1f, 0f, 0.5f);
		array[6] = ((Vector3)(ref val)).normalized;
		val = new Vector3(-1f, 0f, 0.5f);
		array[7] = ((Vector3)(ref val)).normalized;
		outsideLookupDirs = (Vector3[])(object)array;
	}
}


using UnityEngine;

public class SocketMod_InWater : SocketMod
{
	public bool wantsInWater = true;

	public bool excludeArtificialWater;

	protected override Phrase ErrorPhrase
	{
		get
		{
			if (!wantsInWater)
			{
				return ConstructionErrors.InWater;
			}
			if (!excludeArtificialWater)
			{
				return ConstructionErrors.WantsWater;
			}
			return ConstructionErrors.WantsWaterBody;
		}
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(place.position + place.rotation * worldPosition - new Vector3(0f, 0.1f, 0f), waves: true, volumes: true);
		bool isValid = waterInfo.isValid;
		bool artificalWater = waterInfo.artificalWater;
		if (isValid == wantsInWater)
		{
			if (artificalWater)
			{
				return !excludeArtificialWater;
			}
			return true;
		}
		return false;
	}
}


using UnityEngine;

public class SocketMod_PhysicMaterial : SocketMod
{
	public PhysicMaterial[] ValidMaterials;

	private PhysicMaterial foundMaterial;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position;
		Vector3 eulerAngles = ((Quaternion)(ref place.rotation)).eulerAngles;
		Vector3 val = position + ((Vector3)(ref eulerAngles)).normalized * 0.5f;
		eulerAngles = ((Quaternion)(ref place.rotation)).eulerAngles;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val, -((Vector3)(ref eulerAngles)).normalized, ref val2, 1f, 161546240, (QueryTriggerInteraction)1))
		{
			foundMaterial = ((RaycastHit)(ref val2)).collider.GetMaterialAt(((RaycastHit)(ref val2)).point);
			PhysicMaterial[] validMaterials = ValidMaterials;
			for (int i = 0; i < validMaterials.Length; i++)
			{
				if ((Object)(object)validMaterials[i] == (Object)(object)foundMaterial)
				{
					return true;
				}
			}
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_PlantCheck : SocketMod
{
	public bool CanBePotted = true;

	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public bool wantsCollide;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if (!CanBePotted && (Object)(object)place.transform != (Object)null)
		{
			PlanterBox planterBox = place.transform.ToBaseEntity() as PlanterBox;
			if ((Object)(object)planterBox != (Object)null && planterBox.PlantPot)
			{
				return false;
			}
		}
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		bool result = !wantsCollide;
		foreach (BaseEntity item in list)
		{
			GrowableEntity component = ((Component)item).GetComponent<GrowableEntity>();
			if (Object.op_Implicit((Object)(object)component) && wantsCollide)
			{
				result = true;
				break;
			}
			if (Object.op_Implicit((Object)(object)component) && !wantsCollide)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_RoadCheck : SocketMod
{
	public float sphereRadius = 1f;

	public bool wantsCollide;

	public LayerMask layerMask = LayerMask.op_Implicit(65536);

	protected override Phrase ErrorPhrase
	{
		get
		{
			if (!wantsCollide)
			{
				return ConstructionErrors.CantPlaceOnRoad;
			}
			return ConstructionErrors.MustPlaceOnRoad;
		}
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, (QueryTriggerInteraction)2);
		bool flag = false;
		for (int i = 0; i < list.Count; i++)
		{
			Collider val = list[i];
			if ((Object)(object)val != (Object)null && ((Component)val).gameObject.HasCustomTag(GameObjectTag.Road))
			{
				flag = true;
				break;
			}
		}
		bool num = wantsCollide == flag;
		Pool.FreeUnmanaged<Collider>(ref list);
		if (num)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_SphereCheck : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public bool wantsCollide;

	public bool requireMonument;

	[Space]
	public BaseEntity[] entityWhitelist;

	private Phrase lastError = new Phrase("", "");

	protected override Phrase ErrorPhrase => lastError;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, (QueryTriggerInteraction)2);
		if (requireMonument)
		{
			for (int i = 0; i < list.Count; i++)
			{
				Collider val = list[i];
				if (!((Component)val).gameObject.HasCustomTag(GameObjectTag.BlockBarricadePlacement) && ((Object)(object)val.GetMonument() == (Object)null || ((Component)val).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement)))
				{
					list.RemoveAt(i);
					i--;
				}
			}
		}
		bool flag = wantsCollide == list.Count > 0;
		if (entityWhitelist.Length != 0)
		{
			foreach (Collider item in list)
			{
				BaseEntity baseEntity = item.ToBaseEntity();
				if ((Object)(object)baseEntity != (Object)null)
				{
					flag = DeployVolume.CheckEntityList(baseEntity, entityWhitelist, trueIfAnyFound: true);
				}
			}
		}
		if (!flag)
		{
			lastError = ConstructionErrors.NotStableEnough;
			if (LayerMask.op_Implicit(layerMask) == 2097152 || LayerMask.op_Implicit(layerMask) == 136314880)
			{
				lastError = (wantsCollide ? ConstructionErrors.MustPlaceOnConstruction : ConstructionErrors.CantPlaceOnConstruction);
			}
			else if (!wantsCollide && requireMonument)
			{
				lastError = ConstructionErrors.CantPlaceOnMonument;
			}
			else if (!wantsCollide && list.Count > 0)
			{
				using List<Collider>.Enumerator enumerator = list.GetEnumerator();
				while (enumerator.MoveNext())
				{
					string blockedByErrorFromCollider = ConstructionErrors.GetBlockedByErrorFromCollider(DeployVolume.LastDeployHit = enumerator.Current);
					if (!string.IsNullOrEmpty(blockedByErrorFromCollider))
					{
						Construction.lastPlacementErrorIsDetailed = true;
						lastError = Phrase.op_Implicit(blockedByErrorFromCollider);
						break;
					}
				}
			}
		}
		else if (wantsCollide && (LayerMask.op_Implicit(layerMask) & 0x8000000) == 0)
		{
			flag = !GamePhysics.CheckSphere(place.position, 5f, 134217728, (QueryTriggerInteraction)0);
			if (!flag)
			{
				lastError = ConstructionErrors.InvalidAreaVehicleLarge;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		if (flag)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_TerrainCheck : SocketMod
{
	public bool wantsInTerrain = true;

	public bool preventWorldLayerInMonuments;

	private static Phrase lastError = new Phrase("", "");

	protected override Phrase ErrorPhrase => lastError;

	public static bool IsInTerrain(Vector3 vPoint, bool worldLayerInMonuments)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.OutOfBounds(vPoint))
		{
			if (TerrainMeta.IsPointWithinTutorialBounds(vPoint))
			{
				return Physics.Raycast(new Ray(vPoint + Vector3.up * 3f, Vector3.down), 3f, 65536);
			}
			return false;
		}
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAllUnordered(new Ray(vPoint + Vector3.up * 3f, Vector3.down), 0f, list, 3f, 65536, (QueryTriggerInteraction)0);
		using (List<RaycastHit>.Enumerator enumerator = list.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				RaycastHit current = enumerator.Current;
				if (worldLayerInMonuments)
				{
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return true;
				}
				if (((Component)((RaycastHit)(ref current)).collider).gameObject.HasCustomTag(GameObjectTag.BlockBarricadePlacement))
				{
					lastError = ConstructionErrors.CantPlaceOnMonument;
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return false;
				}
				if (((Component)((RaycastHit)(ref current)).collider).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement))
				{
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return true;
				}
				MonumentInfo monument = ((RaycastHit)(ref current)).collider.GetMonument();
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				if ((Object)(object)monument == (Object)null)
				{
					return true;
				}
				lastError = ConstructionErrors.CantPlaceOnMonument;
				return false;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		if (!Object.op_Implicit((Object)(object)TerrainMeta.Collision) || !TerrainMeta.Collision.GetIgnore(vPoint))
		{
			Terrain[] activeTerrains = Terrain.activeTerrains;
			foreach (Terrain val in activeTerrains)
			{
				if (val.SampleHeight(vPoint) + ((Component)val).transform.position.y > vPoint.y)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vPoint = place.position + place.rotation * worldPosition;
		lastError = null;
		if (IsInTerrain(vPoint, !preventWorldLayerInMonuments) == wantsInTerrain)
		{
			return true;
		}
		if (lastError == null)
		{
			lastError = ConstructionErrors.NotInTerrain;
		}
		return false;
	}
}


using UnityEngine;

public class SocketMod_WaterDepth : SocketMod
{
	public float MinimumWaterDepth = 2f;

	public float MaximumWaterDepth = 4f;

	public bool BlockArtificialWaterVolumes;

	private Phrase lastError = new Phrase("", "");

	private float lastDepth;

	protected override Phrase ErrorPhrase => lastError;

	public override string GetDebugErrorMessage()
	{
		return base.GetDebugErrorMessage() + $" {lastDepth}m";
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = place.position + place.rotation * worldPosition;
		pos.y -= 0.2f;
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(pos, waves: false, volumes: true);
		if (BlockArtificialWaterVolumes && waterInfo.artificalWater)
		{
			return false;
		}
		if (waterInfo.overallDepth > MinimumWaterDepth && waterInfo.overallDepth < MaximumWaterDepth)
		{
			return true;
		}
		lastError = ((waterInfo.overallDepth <= MinimumWaterDepth) ? ConstructionErrors.TooShallow : ConstructionErrors.TooDeep);
		return false;
	}
}


using System;
using UnityEngine;

public class Socket_Base : PrefabAttribute
{
	[Serializable]
	public class OccupiedSocketCheck
	{
		public Socket_Base Socket;

		public bool FemaleDummy;
	}

	public bool male = true;

	public bool maleDummy;

	public bool female;

	public bool femaleDummy;

	public bool femaleNoStability;

	public bool monogamous;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Quaternion rotation;

	private Type cachedType;

	public Vector3 selectSize = new Vector3(2f, 0.1f, 2f);

	public Vector3 selectCenter = new Vector3(0f, 0f, 1f);

	[ReadOnly]
	public string socketName;

	[NonSerialized]
	public SocketMod[] socketMods;

	public OccupiedSocketCheck[] checkOccupiedSockets;

	public Socket_Base()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		cachedType = ((object)this).GetType();
	}

	public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return position + rotation * worldPosition;
	}

	public virtual OBB GetSelectBounds(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(position + rotation * worldPosition, Vector3.one, rotation * worldRotation, new Bounds(selectCenter, selectSize));
	}

	protected override Type GetIndexedType()
	{
		return typeof(Socket_Base);
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		position = ((Component)this).transform.position;
		rotation = ((Component)this).transform.rotation;
		socketMods = ((Component)this).GetComponentsInChildren<SocketMod>(true);
		SocketMod[] array = socketMods;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].baseSocket = this;
		}
	}

	public virtual bool TestTarget(Construction.Target target)
	{
		return target.socket != null;
	}

	public virtual bool IsCompatible(Socket_Base socket)
	{
		if (socket == null)
		{
			return false;
		}
		if (!socket.male && !male)
		{
			return false;
		}
		if (!socket.female && !female)
		{
			return false;
		}
		return socket.cachedType == cachedType;
	}

	public virtual bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		return IsCompatible(socket);
	}

	public virtual Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.LookRotation(target.normal, Vector3.up) * Quaternion.Euler(target.rotation);
		Vector3 val2 = target.position;
		val2 -= val * position;
		Construction.Placement result = new Construction.Placement(target);
		result.rotation = val;
		result.position = val2;
		return result;
	}

	public virtual bool CheckSocketMods(ref Construction.Placement placement)
	{
		SocketMod[] array = socketMods;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ModifyPlacement(ref placement);
		}
		array = socketMods;
		foreach (SocketMod socketMod in array)
		{
			if (!(socketMod.SocketGrouping != null) && !socketMod.DoCheck(placement))
			{
				Construction.lastPlacementError = socketMod.GetTranslatedErrorMessage();
				return false;
			}
		}
		return true;
	}
}


using System;

[Serializable]
public class OccupiedSocketCheck
{
	public Socket_Base Socket;

	public bool FemaleDummy;
}


using UnityEngine;

public class Socket_Free : Socket_Base
{
	public Vector3 idealPlacementNormal = Vector3.up;

	public bool useTargetNormal = true;

	public bool blendAimAngle = true;

	public override bool TestTarget(Construction.Target target)
	{
		return target.onTerrain;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		Vector3 val2;
		if (useTargetNormal)
		{
			Vector3 normal = target.normal;
			Vector3 val = idealPlacementNormal;
			if (blendAimAngle || Mathf.Abs(target.normal.y) > 0.98f)
			{
				val2 = target.position - ((Ray)(ref target.ray)).origin;
				Vector3 normalized = ((Vector3)(ref val2)).normalized;
				float num = Mathf.Abs(Vector3.Dot(normalized, normal));
				val = Vector3.Lerp(normalized, idealPlacementNormal, num);
			}
			identity = Quaternion.LookRotation(normal, val) * Quaternion.Inverse(rotation) * Quaternion.Euler(target.rotation);
		}
		else
		{
			val2 = target.position - ((Ray)(ref target.ray)).origin;
			Vector3 normalized2 = ((Vector3)(ref val2)).normalized;
			normalized2.y = 0f;
			identity = Quaternion.LookRotation(normalized2, idealPlacementNormal) * Quaternion.Euler(target.rotation);
		}
		Vector3 val3 = target.position;
		val3 -= identity * position;
		Construction.Placement result = new Construction.Placement(target);
		result.rotation = identity;
		result.position = val3;
		return result;
	}
}


public enum DeployableSnappingMode
{
	Off,
	Simple,
	Advanced
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class Socket_Free_Snappable : Socket_Free
{
	private struct SnapResult
	{
		public bool Valid;

		public float Score;

		public Construction.Placement Placement;

		public string Label;

		public static SnapResult Invalid
		{
			get
			{
				SnapResult result = default(SnapResult);
				result.Valid = false;
				result.Score = float.MaxValue;
				return result;
			}
		}
	}

	private struct BuildingBlockPadding
	{
		public enum PaddingType
		{
			WeaksideOnly,
			StrongsideOnly,
			Both
		}

		public float YPadding;

		public float NormalPadding;

		public PaddingType PaddingMode;
	}

	[ClientVar(Saved = true, Help = "The current snapping mode for deployables.")]
	public static int SnappingMode = 2;

	[ClientVar]
	public static bool DebugSnapping = false;

	[SerializeField]
	[Header("Snapping - General")]
	private float generalPadding;

	[SerializeField]
	[Header("Snapping - Walls")]
	private float snappingPadding;

	[SerializeField]
	[Header("Snapping - Corners")]
	private bool allowSnappingToCorners = true;

	[SerializeField]
	private float cornerPadding = -0.01f;

	[SerializeField]
	[Header("Snapping - Same Deployable")]
	private bool allowSnappingToSameDeployable = true;

	[SerializeField]
	private float sameDeployablePadding;

	private BaseEntity staticEntity;

	private Construction staticConstruction;

	private static List<SnapResult> results = new List<SnapResult>();

	private static readonly Dictionary<string, BuildingBlockPadding> _buildingBlockPaddingDatabase = new Dictionary<string, BuildingBlockPadding>
	{
		{
			"assets/prefabs/building core/foundation/foundation.container.prefab",
			new BuildingBlockPadding
			{
				YPadding = 0.02f,
				NormalPadding = 0f,
				PaddingMode = BuildingBlockPadding.PaddingType.Both
			}
		},
		{
			"assets/prefabs/building core/wall/wall.wood.full.prefab",
			new BuildingBlockPadding
			{
				YPadding = 0f,
				NormalPadding = 0.1f,
				PaddingMode = BuildingBlockPadding.PaddingType.StrongsideOnly
			}
		},
		{
			"assets/prefabs/building core/wall/wall.twig.prefab",
			new BuildingBlockPadding
			{
				YPadding = 0f,
				NormalPadding = 0.1f,
				PaddingMode = BuildingBlockPadding.PaddingType.Both
			}
		}
	};

	private void AddDirections(Construction.Target target, PooledList<Vector3> directions, bool rayAligned)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		((List<Vector3>)(object)directions).Clear();
		Vector3 val;
		Vector3 val2;
		if (rayAligned)
		{
			val = ((Ray)(ref target.ray)).direction;
			val.y = 0f;
			val2 = -Vector3.Cross(val, Vector3.up);
		}
		else
		{
			val = ((Component)target.entity).transform.forward;
			val2 = ((Component)target.entity).transform.right;
		}
		((List<Vector3>)(object)directions).Add(val);
		((List<Vector3>)(object)directions).Add(-val);
		((List<Vector3>)(object)directions).Add(val2);
		((List<Vector3>)(object)directions).Add(-val2);
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		staticEntity = rootObj.GetComponent<BaseEntity>();
		staticConstruction = rootObj.GetComponent<Construction>();
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		if (SnappingMode == 0)
		{
			return base.DoPlacement(target);
		}
		if (!target.isHoldingShift || (Object)(object)target.entity == (Object)null)
		{
			return base.DoPlacement(target);
		}
		if (target.buildingBlocked)
		{
			return base.DoPlacement(target);
		}
		TimeWarning val = TimeWarning.New("Socket_Free_Snappable.DoPlacement", 0);
		try
		{
			Vector3 val2 = target.position + target.normal * 0.05f;
			Ray ray = new Ray(val2, Vector3.down);
			PooledList<RaycastHit> val3 = Pool.Get<PooledList<RaycastHit>>();
			try
			{
				GamePhysics.TraceAll(ray, 0f, (List<RaycastHit>)(object)val3, 2f, 2097152, (QueryTriggerInteraction)0);
				if (((List<RaycastHit>)(object)val3).Count > 0)
				{
					foreach (RaycastHit item in (List<RaycastHit>)(object)val3)
					{
						RaycastHit current = item;
						if (GamePhysics.LineOfSight(((Ray)(ref target.ray)).origin, ((RaycastHit)(ref current)).point + Vector3.up * 0.1f, 2097152) && !(Vector3Ex.Distance2D(((Ray)(ref target.ray)).origin, ((RaycastHit)(ref current)).point) > staticConstruction.maxplaceDistance))
						{
							float num = ((Bounds)(ref staticEntity.bounds)).extents.y - ((Bounds)(ref staticEntity.bounds)).center.y;
							Vector3 val4 = Vector3.up * num;
							target.position = ((RaycastHit)(ref current)).point + val4;
							float buildingBlockPadding = GetBuildingBlockPadding(((Object)((RaycastHit)(ref current)).collider).name, yPadding: true, ((Component)((RaycastHit)(ref current)).collider).transform, ((RaycastHit)(ref current)).normal);
							ref Vector3 reference = ref target.position;
							reference += Vector3.up * buildingBlockPadding;
						}
					}
					results.Clear();
					if (SnappingMode == 2)
					{
						results.Add(TryCornerSnap(target));
						results.Add(TryMatchingDeployableSnap(target));
					}
					results.Add(TryWallSnap(target));
					SnapResult snapResult = SnapResult.Invalid;
					foreach (SnapResult result in results)
					{
						if (DebugSnapping && result.Valid)
						{
							Debug.Log((object)$"[Snapping] Placement:{result.Label} (score: {result.Score:F3} (valid: {result.Valid})");
						}
						if (result.Valid && result.Score < snapResult.Score && ContainerCorpse.IsValidPointForEntity(staticEntity.prefabID, result.Placement.position, result.Placement.rotation))
						{
							if (DebugSnapping)
							{
								Debug.Log((object)$"Selected best: {result.Label}, Score: {result.Score}");
							}
							snapResult = result;
						}
					}
					if (DebugSnapping)
					{
						Debug.Log((object)$"Final Best Valid: {snapResult.Valid}, Score: {snapResult.Score}, Label: {snapResult.Label}");
					}
					if (snapResult.Valid)
					{
						if (DebugSnapping)
						{
							Debug.Log((object)$"[Snapping] Best placement: {snapResult.Label} (score: {snapResult.Score:F3})");
						}
						return snapResult.Placement;
					}
					target.valid = false;
					return base.DoPlacement(target);
				}
				target.valid = false;
				return base.DoPlacement(target);
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private float GetMaxDistance()
	{
		return 2.5f;
	}

	private float GetBuildingBlockPadding(string name, bool yPadding, Transform buildingBlockTransform, Vector3 rayNormal)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (_buildingBlockPaddingDatabase.TryGetValue(name, out var value))
		{
			if (yPadding)
			{
				return value.YPadding;
			}
			if (ShouldAddPadding(buildingBlockTransform, rayNormal, value.PaddingMode))
			{
				return value.NormalPadding;
			}
		}
		return 0f;
	}

	private bool ShouldAddPadding(Transform buildingBlockTransform, Vector3 rayNormal, BuildingBlockPadding.PaddingType type)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (type == BuildingBlockPadding.PaddingType.Both)
		{
			return true;
		}
		Matrix4x4 worldToLocalMatrix = buildingBlockTransform.worldToLocalMatrix;
		Vector3 val = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyVector(-rayNormal);
		float num = Vector3Ex.DotDegrees(worldForward, val);
		return type switch
		{
			BuildingBlockPadding.PaddingType.WeaksideOnly => num > 90f, 
			BuildingBlockPadding.PaddingType.StrongsideOnly => num < 90f, 
			_ => false, 
		};
	}

	private SnapResult TryWallSnap(Construction.Target target)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Socket_Free_Snappable.DoPlacement.TryWallSnap", 0);
		try
		{
			if (TryFindBestSnappingHit(target, out var bestHit))
			{
				Quaternion targetRotation = ComputeSnappedRotation(target, bestHit);
				Vector3 val2 = ComputeSnappedPosition(target, bestHit, targetRotation);
				float score = Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref bestHit)).point);
				SnapResult result = default(SnapResult);
				result.Valid = true;
				result.Score = score;
				result.Placement = new Construction.Placement(target)
				{
					position = val2,
					rotation = targetRotation
				};
				result.Label = "Wall";
				return result;
			}
			return SnapResult.Invalid;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool TryFindBestSnappingHit(Construction.Target target, out RaycastHit bestHit)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		bestHit = default(RaycastHit);
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			AddDirections(target, val, rayAligned: false);
			Vector3 val2 = target.position + Vector3.up * 0.05f;
			PooledList<RaycastHit> val3 = Pool.Get<PooledList<RaycastHit>>();
			try
			{
				Ray ray = default(Ray);
				foreach (Vector3 item in (List<Vector3>)(object)val)
				{
					((Ray)(ref ray))..ctor(val2, item);
					PooledList<RaycastHit> val4 = Pool.Get<PooledList<RaycastHit>>();
					try
					{
						GamePhysics.TraceAll(ray, 0f, (List<RaycastHit>)(object)val4, GetMaxDistance(), 2097152, (QueryTriggerInteraction)0);
						if (((List<RaycastHit>)(object)val4).Count <= 0)
						{
							continue;
						}
						foreach (RaycastHit item2 in (List<RaycastHit>)(object)val4)
						{
							((List<RaycastHit>)(object)val3).Add(item2);
						}
					}
					finally
					{
						((IDisposable)val4)?.Dispose();
					}
				}
				float num = float.MaxValue;
				foreach (RaycastHit item3 in (List<RaycastHit>)(object)val3)
				{
					RaycastHit current3 = item3;
					if (!(Vector3.Distance(((RaycastHit)(ref current3)).point, ((Ray)(ref target.ray)).origin) > staticConstruction.maxplaceDistance))
					{
						float num2 = Vector3Ex.Distance2D(val2, ((RaycastHit)(ref current3)).point);
						if (num2 < num)
						{
							num = num2;
							bestHit = current3;
						}
					}
				}
				return Math.Abs(num - float.MaxValue) > Mathf.Epsilon;
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private Quaternion ComputeSnappedRotation(Construction.Target target, RaycastHit bestHit)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((RaycastHit)(ref bestHit)).normal;
		normal.y = 0f;
		Quaternion val = ((normal == Vector3.zero) ? Quaternion.identity : Quaternion.LookRotation(normal, Vector3.up));
		Vector3 val2 = ((RaycastHit)(ref bestHit)).point - ((Ray)(ref target.ray)).origin;
		Vector3 val3 = -((Vector3)(ref val2)).normalized;
		val3.y = 0f;
		Quaternion val4 = Quaternion.LookRotation(val3, Vector3.up) * Quaternion.Euler(target.rotation);
		Quaternion val5 = val * Quaternion.Euler(target.rotation);
		Vector3 val6 = val5 * ((RaycastHit)(ref bestHit)).normal;
		Vector3 val7 = val4 * ((RaycastHit)(ref bestHit)).normal;
		if (Mathf.Abs(Vector3.Dot(val7, val6)) < 0.5f)
		{
			Quaternion val8 = Quaternion.AngleAxis(Mathf.Round(Vector3.SignedAngle(val6, val7, Vector3.up) / 90f) * 90f, Vector3.up);
			val5 *= val8;
		}
		return val5;
	}

	private Vector3 ComputeSnappedPosition(Construction.Target target, RaycastHit bestHit, Quaternion targetRotation)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((RaycastHit)(ref bestHit)).normal;
		normal.y = 0f;
		Matrix4x4 val = Matrix4x4.TRS(target.position, targetRotation, ((Component)staticEntity).transform.lossyScale);
		Matrix4x4 inverse = ((Matrix4x4)(ref val)).inverse;
		Vector3 val2 = Vector3.Scale(((Matrix4x4)(ref inverse)).MultiplyVector(normal), ((Bounds)(ref staticEntity.bounds)).extents);
		Vector3 val3 = ((Matrix4x4)(ref val)).MultiplyVector(val2);
		Vector3 val4 = targetRotation * ((Bounds)(ref staticEntity.bounds)).center;
		val4.y = 0f;
		float num = Vector3.Dot(val4, normal);
		Vector3 val5 = ((RaycastHit)(ref bestHit)).point + normal * snappingPadding + val3 - normal * num;
		val5 += normal * generalPadding;
		if ((Object)(object)((RaycastHit)(ref bestHit)).collider != (Object)null)
		{
			float buildingBlockPadding = GetBuildingBlockPadding(((Object)((RaycastHit)(ref bestHit)).collider).name, yPadding: false, ((Component)((RaycastHit)(ref bestHit)).collider).transform, ((RaycastHit)(ref bestHit)).normal);
			val5 += normal * buildingBlockPadding;
		}
		val5.y = target.position.y;
		return val5;
	}

	private SnapResult TryCornerSnap(Construction.Target target)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		if (!allowSnappingToCorners)
		{
			return SnapResult.Invalid;
		}
		TimeWarning val = TimeWarning.New("Socket_Free_Snappable.DoPlacement.TryCornerSnap", 0);
		try
		{
			if (TryFindCornerHits(target, out var hitA, out var hitB))
			{
				RaycastHit bestHit = ((Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref hitA)).point) < Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref hitB)).point)) ? hitA : hitB);
				Quaternion targetRotation = ComputeSnappedRotation(target, bestHit);
				Vector3 val2 = ComputeCornerSnappedPosition(target, hitA, hitB, targetRotation);
				float num = Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref hitA)).point);
				float num2 = Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref hitB)).point);
				float num3 = Mathf.Min(num, num2);
				num3 *= 0.7f;
				SnapResult result = default(SnapResult);
				result.Valid = true;
				result.Score = num3;
				result.Placement = new Construction.Placement(target)
				{
					position = val2,
					rotation = targetRotation
				};
				result.Label = "Corner";
				return result;
			}
			return SnapResult.Invalid;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool TryFindCornerHits(Construction.Target target, out RaycastHit hitA, out RaycastHit hitB)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		hitA = default(RaycastHit);
		hitB = default(RaycastHit);
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			AddDirections(target, val, rayAligned: false);
			Vector3 val2 = target.position + Vector3.up * 0.5f;
			float num = float.MaxValue;
			PooledList<RaycastHit> val3 = Pool.Get<PooledList<RaycastHit>>();
			try
			{
				Ray ray = default(Ray);
				foreach (Vector3 item in (List<Vector3>)(object)val)
				{
					((Ray)(ref ray))..ctor(val2, item);
					PooledList<RaycastHit> val4 = Pool.Get<PooledList<RaycastHit>>();
					try
					{
						GamePhysics.TraceAll(ray, 0f, (List<RaycastHit>)(object)val4, GetMaxDistance() / 2.5f, 2097408, (QueryTriggerInteraction)0);
						if (((List<RaycastHit>)(object)val4).Count <= 0)
						{
							continue;
						}
						foreach (RaycastHit item2 in (List<RaycastHit>)(object)val4)
						{
							((List<RaycastHit>)(object)val3).Add(item2);
						}
					}
					finally
					{
						((IDisposable)val4)?.Dispose();
					}
				}
				for (int i = 0; i < ((List<RaycastHit>)(object)val3).Count; i++)
				{
					for (int j = i + 1; j < ((List<RaycastHit>)(object)val3).Count; j++)
					{
						RaycastHit val5 = ((List<RaycastHit>)(object)val3)[i];
						Vector3 normal = ((RaycastHit)(ref val5)).normal;
						val5 = ((List<RaycastHit>)(object)val3)[j];
						Vector3 normal2 = ((RaycastHit)(ref val5)).normal;
						if (!(((List<RaycastHit>)(object)val3)[i].GetEntity().net.ID == ((List<RaycastHit>)(object)val3)[j].GetEntity().net.ID))
						{
							float num2 = Mathf.Abs(Vector3.Dot(((Vector3)(ref normal)).normalized, ((Vector3)(ref normal2)).normalized));
							val5 = ((List<RaycastHit>)(object)val3)[i];
							float num3 = Vector3Ex.Distance2D(val2, ((RaycastHit)(ref val5)).point);
							float num4 = num3;
							val5 = ((List<RaycastHit>)(object)val3)[j];
							num3 = num4 + Vector3Ex.Distance2D(val2, ((RaycastHit)(ref val5)).point);
							if (num2 < 0.3f && num3 < num)
							{
								hitA = ((List<RaycastHit>)(object)val3)[i];
								hitB = ((List<RaycastHit>)(object)val3)[j];
								num = num3;
							}
						}
					}
				}
				return Math.Abs(num - float.MaxValue) > Mathf.Epsilon;
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private Vector3 GetPlaneIntersectionPoint(Vector3 normal1, Vector3 point1, Vector3 normal2, Vector3 point2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(normal1, normal2);
		if (((Vector3)(ref val)).sqrMagnitude < Mathf.Epsilon)
		{
			return Vector3.zero;
		}
		float num = Vector3.Dot(normal1, point1);
		float num2 = Vector3.Dot(normal2, point2);
		Vector3 val2 = Vector3.Cross(normal2, val) * num + Vector3.Cross(val, normal1) * num2;
		float num3 = ((Vector3)(ref val)).magnitude * ((Vector3)(ref val)).magnitude;
		return val2 / num3;
	}

	private Vector3 ComputeCornerSnappedPosition(Construction.Target target, RaycastHit hitA, RaycastHit hitB, Quaternion targetRotation)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((RaycastHit)(ref hitA)).normal;
		Vector3 normal2 = ((RaycastHit)(ref hitB)).normal;
		normal.y = 0f;
		normal2.y = 0f;
		Vector3 planeIntersectionPoint = GetPlaneIntersectionPoint(normal, ((RaycastHit)(ref hitA)).point, normal2, ((RaycastHit)(ref hitB)).point);
		planeIntersectionPoint.y = target.position.y;
		Vector3 val = normal + normal2;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = targetRotation * ((Bounds)(ref staticEntity.bounds)).center;
		Matrix4x4 val3 = Matrix4x4.TRS(planeIntersectionPoint + val2, targetRotation, ((Component)staticEntity).transform.lossyScale);
		Matrix4x4 inverse = ((Matrix4x4)(ref val3)).inverse;
		Vector3 val4 = Vector3.Scale(((Matrix4x4)(ref inverse)).MultiplyVector(normal), ((Bounds)(ref staticEntity.bounds)).extents);
		inverse = ((Matrix4x4)(ref val3)).inverse;
		Vector3 val5 = Vector3.Scale(((Matrix4x4)(ref inverse)).MultiplyVector(normal2), ((Bounds)(ref staticEntity.bounds)).extents);
		Vector3 val6 = ((Matrix4x4)(ref val3)).MultiplyVector(val4 + val5);
		Vector3 val7 = planeIntersectionPoint + val6;
		val7 += normalized * cornerPadding;
		val7 += normalized * generalPadding;
		float num = 0f;
		if ((Object)(object)((RaycastHit)(ref hitA)).collider != (Object)null)
		{
			num = Mathf.Max(num, GetBuildingBlockPadding(((Object)((RaycastHit)(ref hitA)).collider).name, yPadding: false, ((Component)((RaycastHit)(ref hitA)).collider).transform, ((RaycastHit)(ref hitA)).normal));
		}
		if ((Object)(object)((RaycastHit)(ref hitB)).collider != (Object)null)
		{
			num = Mathf.Max(num, GetBuildingBlockPadding(((Object)((RaycastHit)(ref hitB)).collider).name, yPadding: false, ((Component)((RaycastHit)(ref hitB)).collider).transform, ((RaycastHit)(ref hitB)).normal));
		}
		val7 += normalized * num;
		val7.y = target.position.y;
		return val7;
	}

	private SnapResult TryMatchingDeployableSnap(Construction.Target target)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (!allowSnappingToSameDeployable)
		{
			return SnapResult.Invalid;
		}
		TimeWarning val = TimeWarning.New("Socket_Free_Snappable.DoPlacement.TryMatchingDeployableSnap", 0);
		try
		{
			if (TryFindMatchingDeployables(target, out var bestHit))
			{
				Quaternion targetRotation = ((RaycastHit)(ref bestHit)).transform.root.rotation;
				Vector3 val2 = ComputeSnappedMatchingDeployablePosition(target, bestHit, targetRotation);
				float num = Vector3Ex.Distance2D(target.position, ((RaycastHit)(ref bestHit)).point);
				if (target.entity.prefabID == staticEntity.prefabID)
				{
					num *= 0.9f;
				}
				SnapResult result = default(SnapResult);
				result.Valid = true;
				result.Score = num;
				result.Placement = new Construction.Placement(target)
				{
					position = val2,
					rotation = targetRotation
				};
				result.Label = "Deployable";
				return result;
			}
			return SnapResult.Invalid;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private Vector3 ComputeSnappedMatchingDeployablePosition(Construction.Target target, RaycastHit bestHit, Quaternion targetRotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity entity = bestHit.GetEntity();
		if ((Object)(object)entity == (Object)null)
		{
			return target.position;
		}
		OBB val = entity.WorldSpaceBounds();
		Vector3 val2 = ((RaycastHit)(ref bestHit)).point - val.position;
		val2.y = 0f;
		Vector3[] obj = new Vector3[4]
		{
			val.right,
			-val.right,
			val.forward,
			-val.forward
		};
		Vector3 val3 = val.forward;
		float num = -1f;
		Vector3[] array = (Vector3[])(object)obj;
		foreach (Vector3 val4 in array)
		{
			float num2 = Vector3.Dot(val2, val4);
			if (num2 > num)
			{
				num = num2;
				val3 = val4;
			}
		}
		Matrix4x4 val5 = Matrix4x4.TRS(target.position, targetRotation, ((Component)staticEntity).transform.lossyScale);
		Matrix4x4 inverse = ((Matrix4x4)(ref val5)).inverse;
		Vector3 val6 = Vector3.Scale(((Matrix4x4)(ref inverse)).MultiplyVector(((Vector3)(ref val3)).normalized), ((Bounds)(ref staticEntity.bounds)).size);
		Vector3 val7 = ((Matrix4x4)(ref val5)).MultiplyVector(val6);
		Vector3 val8 = targetRotation * ((Bounds)(ref staticEntity.bounds)).center;
		val8.y = 0f;
		float num3 = Vector3.Dot(val8, val3);
		return ((Component)entity).transform.position + val3 * sameDeployablePadding + val7 - val3 * num3 + val3 * generalPadding;
	}

	private bool TryFindMatchingDeployables(Construction.Target target, out RaycastHit bestHit)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		bestHit = default(RaycastHit);
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			AddDirections(target, val, rayAligned: false);
			Vector3 val2 = target.position + Vector3.up * 0.05f;
			PooledList<RaycastHit> val3 = Pool.Get<PooledList<RaycastHit>>();
			try
			{
				Ray ray = default(Ray);
				foreach (Vector3 item in (List<Vector3>)(object)val)
				{
					((Ray)(ref ray))..ctor(val2, item);
					PooledList<RaycastHit> val4 = Pool.Get<PooledList<RaycastHit>>();
					try
					{
						GamePhysics.TraceAll(ray, 0f, (List<RaycastHit>)(object)val4, GetMaxDistance() * 1.5f, 256, (QueryTriggerInteraction)0);
						if (((List<RaycastHit>)(object)val4).Count <= 0)
						{
							continue;
						}
						foreach (RaycastHit item2 in (List<RaycastHit>)(object)val4)
						{
							RaycastHit current2 = item2;
							if (!((Object)(object)((RaycastHit)(ref current2)).collider == (Object)null) && current2.GetEntity().prefabID == staticEntity.prefabID)
							{
								((List<RaycastHit>)(object)val3).Add(current2);
							}
						}
					}
					finally
					{
						((IDisposable)val4)?.Dispose();
					}
				}
				float num = float.MaxValue;
				foreach (RaycastHit item3 in (List<RaycastHit>)(object)val3)
				{
					RaycastHit current3 = item3;
					if (!(Vector3.Distance(((RaycastHit)(ref current3)).point, ((Ray)(ref target.ray)).origin) > staticConstruction.maxplaceDistance))
					{
						float num2 = Vector3Ex.Distance2D(val2, ((RaycastHit)(ref current3)).point);
						if (num2 < num)
						{
							num = num2;
							bestHit = current3;
						}
					}
				}
				return Math.Abs(num - float.MaxValue) > Mathf.Epsilon;
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


private struct SnapResult
{
	public bool Valid;

	public float Score;

	public Construction.Placement Placement;

	public string Label;

	public static SnapResult Invalid
	{
		get
		{
			SnapResult result = default(SnapResult);
			result.Valid = false;
			result.Score = float.MaxValue;
			return result;
		}
	}
}


private struct BuildingBlockPadding
{
	public enum PaddingType
	{
		WeaksideOnly,
		StrongsideOnly,
		Both
	}

	public float YPadding;

	public float NormalPadding;

	public PaddingType PaddingMode;
}


public enum PaddingType
{
	WeaksideOnly,
	StrongsideOnly,
	Both
}


using UnityEngine;

public class Socket_Specific : Socket_Base
{
	public bool useFemaleRotation = true;

	public string targetSocketName;

	public bool blockPlacementOnChildEntities;

	public bool canRotate;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.2f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	public override bool TestTarget(Construction.Target target)
	{
		if (!base.TestTarget(target))
		{
			return false;
		}
		Socket_Specific_Female socket_Specific_Female = target.socket as Socket_Specific_Female;
		if (socket_Specific_Female == null)
		{
			return false;
		}
		if (blockPlacementOnChildEntities && (Object)(object)target.entity != (Object)null && (Object)(object)target.entity.GetParentEntity() != (Object)null)
		{
			return false;
		}
		return socket_Specific_Female.CanAccept(this);
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = target.socket.rotation;
		if (target.socket.male && target.socket.female)
		{
			val = target.socket.rotation * Quaternion.Euler(180f, 0f, 180f);
		}
		Socket_Specific_Female socket_Specific_Female = target.socket as Socket_Specific_Female;
		Transform val2 = (socket_Specific_Female.parentToBone ? target.entity.FindBone(socket_Specific_Female.boneName) : ((Component)target.entity).transform);
		Matrix4x4 localToWorldMatrix = val2.localToWorldMatrix;
		Vector3 val3 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(target.socket.localPosition);
		Quaternion val4;
		if (useFemaleRotation)
		{
			val4 = val2.rotation * val;
		}
		else
		{
			Vector3 val5 = new Vector3(val3.x, 0f, val3.z);
			Vector3 val6 = default(Vector3);
			((Vector3)(ref val6))..ctor(target.player.eyes.position.x, 0f, target.player.eyes.position.z);
			Vector3 val7 = val5 - val6;
			val4 = Quaternion.LookRotation(((Vector3)(ref val7)).normalized) * val;
		}
		Construction.Placement result = new Construction.Placement(target);
		Quaternion val8 = val4 * Quaternion.Inverse(rotation);
		if (canRotate)
		{
			val8 *= Quaternion.Euler(target.rotation);
		}
		Vector3 val9 = val8 * position;
		result.position = val3 - val9;
		result.rotation = val8;
		return result;
	}
}


using UnityEngine;

public class Socket_Specific_Female : Socket_Base
{
	public int rotationDegrees;

	public int rotationOffset;

	public string[] allowedMaleSockets;

	public bool parentToBone;

	public string boneName;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.2f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.DrawWireCube(selectCenter, selectSize);
	}

	public bool CanAccept(Socket_Specific socket)
	{
		string[] array = allowedMaleSockets;
		foreach (string text in array)
		{
			if (socket.targetSocketName == text)
			{
				return true;
			}
		}
		return false;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		return base.DoPlacement(target);
	}
}


using UnityEngine;

public class Socket_Terrain : Socket_Base
{
	public float placementHeight;

	public bool alignToNormal;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.2f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.color = new Color(0f, 1f, 0f, 0.2f);
		Gizmos.DrawCube(Vector3.zero, new Vector3(0.1f, 0.1f, placementHeight));
		Gizmos.color = new Color(0f, 1f, 0f, 0.5f);
		Gizmos.DrawWireCube(Vector3.zero, new Vector3(0.1f, 0.1f, placementHeight));
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	public override bool TestTarget(Construction.Target target)
	{
		return target.onTerrain;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		Vector3 direction = ((Ray)(ref target.ray)).direction;
		direction.y = 0f;
		((Vector3)(ref direction)).Normalize();
		Vector3 val = Vector3.up;
		if (alignToNormal)
		{
			val = target.normal;
		}
		Quaternion val2 = Quaternion.LookRotation(direction, val) * Quaternion.Euler(0f, eulerAngles.y, 0f) * Quaternion.Euler(target.rotation);
		Vector3 val3 = target.position;
		val3 -= val2 * position;
		Construction.Placement result = new Construction.Placement(target);
		result.rotation = val2;
		result.position = val3;
		return result;
	}
}


using UnityEngine;

public class StabilitySocket : Socket_Base
{
	[Range(0f, 1f)]
	public float support = 1f;

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.DrawWireCube(selectCenter, selectSize);
	}

	public override bool TestTarget(Construction.Target target)
	{
		return false;
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		OBB selectBounds = GetSelectBounds(position, rotation);
		OBB selectBounds2 = socket.GetSelectBounds(socketPosition, socketRotation);
		return ((OBB)(ref selectBounds)).Intersects(selectBounds2);
	}
}


using System;

public class WeakpointProperties : PrefabAttribute
{
	public bool BlockWhenRoofAttached;

	protected override Type GetIndexedType()
	{
		return typeof(WeakpointProperties);
	}
}


using UnityEngine;

public class CanvasOrderHack : MonoBehaviour
{
	private void OnEnable()
	{
		Canvas[] componentsInChildren = ((Component)this).GetComponentsInChildren<Canvas>(true);
		foreach (Canvas val in componentsInChildren)
		{
			if (val.overrideSorting)
			{
				int sortingOrder = val.sortingOrder;
				val.sortingOrder = sortingOrder + 1;
			}
		}
		componentsInChildren = ((Component)this).GetComponentsInChildren<Canvas>(true);
		foreach (Canvas val2 in componentsInChildren)
		{
			if (val2.overrideSorting)
			{
				int sortingOrder = val2.sortingOrder;
				val2.sortingOrder = sortingOrder - 1;
			}
		}
	}
}


using UnityEngine;

public class AnimalSkin : MonoBehaviour, IClientComponent
{
	public SkinnedMeshRenderer[] animalMesh;

	public AnimalMultiSkin[] animalSkins;

	private Model model;

	public bool dontRandomizeOnStart;

	private void Start()
	{
		model = ((Component)this).gameObject.GetComponent<Model>();
		if (!dontRandomizeOnStart)
		{
			int iSkin = Mathf.FloorToInt((float)Random.Range(0, animalSkins.Length));
			ChangeSkin(iSkin);
		}
	}

	public void ChangeSkin(int iSkin)
	{
		if (animalSkins.Length == 0)
		{
			return;
		}
		iSkin = Mathf.Clamp(iSkin, 0, animalSkins.Length - 1);
		SkinnedMeshRenderer[] array = animalMesh;
		foreach (SkinnedMeshRenderer val in array)
		{
			Material[] sharedMaterials = ((Renderer)val).sharedMaterials;
			if (sharedMaterials != null)
			{
				for (int j = 0; j < sharedMaterials.Length; j++)
				{
					sharedMaterials[j] = animalSkins[iSkin].multiSkin[j];
				}
				((Renderer)val).sharedMaterials = sharedMaterials;
			}
		}
		if ((Object)(object)model != (Object)null)
		{
			model.skin = iSkin;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class AnimalMultiSkin
{
	public Material[] multiSkin;
}


using UnityEngine;

public class AnimalAnimation : MonoBehaviour, IClientComponent
{
	public BaseEntity Entity;

	public BaseNpc Target;

	public Animator Animator;

	public MaterialEffect FootstepEffects;

	public Transform[] Feet;

	[Tooltip("Ensure there is a float param called idleOffset if this is enabled")]
	public bool hasIdleOffset;

	[Tooltip("Check animation clip weights when playing sounds so we don't play sounds for clips that are blended out")]
	public bool enforceClipWeights;

	[ReadOnly]
	public string BaseFolder;

	public string OverrideBaseFolder;

	public float RequiredCameraDistanceForSfx;
}


using UnityEngine;

public class AnimalFootIK : MonoBehaviour
{
	public Transform[] Feet;

	public Animator animator;

	public float maxWeightDistance = 0.1f;

	public float minWeightDistance = 0.025f;

	public float actualFootOffset = 0.01f;

	public bool GroundSample(Vector3 origin, out RaycastHit hit)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (Physics.Raycast(origin + Vector3.up * 0.5f, Vector3.down, ref hit, 1f, 455155969))
		{
			return true;
		}
		return false;
	}

	public void Start()
	{
	}

	public AvatarIKGoal GoalFromIndex(int index)
	{
		return (AvatarIKGoal)(index switch
		{
			0 => 2, 
			1 => 3, 
			2 => 0, 
			3 => 1, 
			_ => 2, 
		});
	}

	private void OnAnimatorIK(int layerIndex)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"animal ik!");
		for (int i = 0; i < 4; i++)
		{
			Transform val = Feet[i];
			AvatarIKGoal val2 = GoalFromIndex(i);
			_ = Vector3.up;
			Vector3 position = ((Component)val).transform.position;
			float iKPositionWeight = animator.GetIKPositionWeight(val2);
			if (GroundSample(((Component)val).transform.position - Vector3.down * actualFootOffset, out var hit))
			{
				_ = ((RaycastHit)(ref hit)).normal;
				position = ((RaycastHit)(ref hit)).point;
				float num = Vector3.Distance(((Component)val).transform.position - Vector3.down * actualFootOffset, position);
				iKPositionWeight = 1f - Mathf.InverseLerp(minWeightDistance, maxWeightDistance, num);
				animator.SetIKPosition(val2, position + Vector3.up * actualFootOffset);
			}
			else
			{
				iKPositionWeight = 0f;
			}
			animator.SetIKPositionWeight(val2, iKPositionWeight);
		}
	}
}


using UnityEngine;

public class AvatarSwitcher : StateMachineBehaviour
{
	public Avatar ToApply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateEnter(animator, stateInfo, layerIndex);
		if ((Object)(object)ToApply != (Object)null)
		{
			animator.avatar = ToApply;
			animator.Play(((AnimatorStateInfo)(ref stateInfo)).shortNameHash, layerIndex);
		}
	}
}


using System;
using UnityEngine;

public class BlendShapeController : MonoBehaviour
{
	public enum BlendMode
	{
		Idle,
		Happy,
		Angry
	}

	[Serializable]
	public struct BlendState
	{
		[Range(0f, 100f)]
		public float[] States;

		public BlendMode Mode;
	}

	public SkinnedMeshRenderer TargetRenderer;

	public BlendState[] States;

	public float LerpSpeed = 0.25f;

	public BlendMode CurrentMode;
}


public enum BlendMode
{
	Idle,
	Happy,
	Angry
}


using System;
using UnityEngine;

[Serializable]
public struct BlendState
{
	[Range(0f, 100f)]
	public float[] States;

	public BlendMode Mode;
}


using UnityEngine;

public class BlendTreeEventSender : StateMachineBehaviour
{
	[Tooltip("The name of the Blend Parameter to monitor.")]
	public string blendParameter = "BlendParameter";

	[Tooltip("The blend value threshold to trigger the event.")]
	public float triggerThreshold = 0.5f;

	[Tooltip("The event name that will be sent via SendMessage.")]
	public string eventName = "OnAnimationEvent";

	[Tooltip("Custom string parameter to send along with the event.")]
	public string eventParameter = "";

	[Tooltip("Should the event only fire once per entry?")]
	public bool fireOnce = true;

	private bool eventTriggered;

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		float @float = animator.GetFloat(blendParameter);
		if (@float >= triggerThreshold && (!fireOnce || !eventTriggered))
		{
			FireEvent(animator);
			eventTriggered = true;
		}
		if (@float < triggerThreshold)
		{
			eventTriggered = false;
		}
	}

	private void FireEvent(Animator animator)
	{
		((Component)animator).gameObject.SendMessage(eventName, (object)eventParameter, (SendMessageOptions)1);
	}
}


using UnityEngine;
using UnityEngine.Animations;

public class CurveStateSpeed : StateMachineBehaviour
{
	public AnimationCurve SpeedCurve = AnimationCurve.Constant(0f, 1f, 1f);

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex, controller);
		float speed = 1f;
		if (!animator.IsInTransition(layerIndex))
		{
			speed = SpeedCurve.Evaluate(((AnimatorStateInfo)(ref stateInfo)).normalizedTime);
		}
		animator.speed = speed;
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateExit(animator, stateInfo, layerIndex);
		animator.speed = 1f;
	}
}


using UnityEngine;

public class GameObjectToggleState : StateMachineBehaviour
{
	public bool UseCurve;

	[MinMax(0f, 1f)]
	[Tooltip("The normalised range in the animation in which to apply the TargetState")]
	public Vector2 ValidNormalisedRange;

	public AnimationCurve CurveRange = AnimationCurve.Linear(0f, 0f, 1f, 0f);

	[Tooltip("What state to set the target object to, true = enabled, false = disabled")]
	public bool TargetState;

	[Tooltip("What gameObject to toggle (ensure it's a unique name in the hierarchy)")]
	public string GameObjectName;

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex);
		bool flag = (UseCurve ? (CurveRange.Evaluate(((AnimatorStateInfo)(ref stateInfo)).normalizedTime) > 0f) : (((AnimatorStateInfo)(ref stateInfo)).normalizedTime > ValidNormalisedRange.x && ((AnimatorStateInfo)(ref stateInfo)).normalizedTime < ValidNormalisedRange.y));
		Model model = ((Component)animator).gameObject.GetComponent<Model>();
		if ((Object)(object)model == (Object)null)
		{
			model = ((Component)animator).gameObject.GetComponentInParent<Model>();
		}
		if ((Object)(object)model != (Object)null)
		{
			Transform val = model.FindBone(GameObjectName);
			if ((Object)(object)val != (Object)null)
			{
				((Component)val).gameObject.SetActive(flag ? TargetState : (!TargetState));
			}
		}
	}
}


using UnityEngine;

public class AverageVelocity
{
	private Vector3 pos;

	private float time;

	private float lastEntry;

	private float averageSpeed;

	private Vector3 averageVelocity;

	public float Speed => averageSpeed;

	public Vector3 Average => averageVelocity;

	public void Record(Vector3 newPos)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - time;
		if (!(num < 0.1f))
		{
			if (((Vector3)(ref pos)).sqrMagnitude > 0f)
			{
				Vector3 val = newPos - pos;
				averageVelocity = val * (1f / num);
				averageSpeed = ((Vector3)(ref averageVelocity)).magnitude;
			}
			time = Time.time;
			pos = newPos;
		}
	}
}


using UnityEngine;

public class NpcWalkAnimation : MonoBehaviour, IClientComponent
{
	public Vector3 HipFudge = new Vector3(-90f, 0f, 90f);

	public BaseNpc Npc;

	public Animator Animator;

	public Transform HipBone;

	public Transform LookBone;

	public bool UpdateWalkSpeed = true;

	public bool UpdateFacingDirection = true;

	public bool UpdateGroundNormal = true;

	public Transform alignmentRoot;

	public bool LaggyAss = true;

	public bool LookAtTarget;

	public float MaxLaggyAssRotation = 70f;

	public float MaxWalkAnimSpeed = 25f;

	public bool UseDirectionBlending;

	public bool useTurnPosing;

	public float turnPoseScale = 0.5f;

	public float laggyAssLerpScale = 15f;

	public bool skeletonChainInverted;
}


using UnityEngine;

public class ReliableEventSender : StateMachineBehaviour
{
	[Header("State Enter")]
	public string StateEnter;

	[Header("Mid State")]
	public string MidStateEvent;

	[Range(0f, 1f)]
	public float TargetEventTime;
}


using UnityEngine;

public class ShieldBlockStateBehaviour : StateMachineBehaviour
{
}


using UnityEngine;

public class StateLayerController : StateMachineBehaviour
{
	public int TargetLayer = 2;
}


using UnityEngine;

public class SuppressEyeMovement : StateMachineBehaviour
{
}


using UnityEngine;

public class AnimationEventForward : MonoBehaviour
{
	public GameObject targetObject;

	public void Event(string type)
	{
		targetObject.SendMessage(type);
	}
}


using ConVar;
using UnityEngine;
using UnityEngine.Audio;

public class AudioSettings : MonoBehaviour
{
	public static float duckingFactor = 1f;

	public AudioMixer mixer;

	private void Update()
	{
		if (!((Object)(object)mixer == (Object)null))
		{
			mixer.SetFloat("MasterVol", LinearToDecibel(Audio.master * duckingFactor));
			float num = default(float);
			mixer.GetFloat("MusicVol", ref num);
			if (!LevelManager.isLoaded || !MainCamera.isValid)
			{
				mixer.SetFloat("MusicVol", Mathf.Lerp(num, LinearToDecibel(Audio.musicvolumemenu), Time.deltaTime));
			}
			else
			{
				mixer.SetFloat("MusicVol", Mathf.Lerp(num, LinearToDecibel(Audio.musicvolume), Time.deltaTime));
			}
			float num2 = 1f - (((Object)(object)SingletonComponent<MixerSnapshotManager>.Instance == (Object)null) ? 0f : SingletonComponent<MixerSnapshotManager>.Instance.deafness);
			mixer.SetFloat("WorldVol", LinearToDecibel(Audio.game * num2));
			mixer.SetFloat("UIVol", LinearToDecibel(Audio.ui * num2));
			mixer.SetFloat("WorldVolFlashbang", LinearToDecibel(Audio.game));
			mixer.SetFloat("VoiceVol", LinearToDecibel(Audio.voices * num2));
			mixer.SetFloat("InstrumentVol", LinearToDecibel(Audio.instruments * num2));
			float num3 = LinearToDecibel(Audio.voiceProps * num2) - 28.7f;
			mixer.SetFloat("VoicePropsVol", num3 * num2);
			mixer.SetFloat("SeasonalEventsVol", LinearToDecibel(Audio.eventAudio * num2));
		}
	}

	private float LinearToDecibel(float linear)
	{
		if (linear > 0f)
		{
			return 20f * Mathf.Log10(linear);
		}
		return -144f;
	}
}


using System;
using System.Text;
using Facepunch;
using Rust.Workshop;
using TMPro;
using UnityEngine;

public class BenchmarkInfo : SingletonComponent<BenchmarkInfo>
{
	public static string BenchmarkTitle;

	public static string BenchmarkSubtitle;

	public TextMeshProUGUI PerformanceText;

	public TextMeshProUGUI SystemInfoText;

	private StringBuilder sb = new StringBuilder();

	private RealTimeSince timeSinceUpdated;

	private void Start()
	{
		string text = Environment.MachineName + "\n";
		text = text + SystemInfo.operatingSystem + "\n";
		text += $"{(double)SystemInfo.systemMemorySize / 1024.0:0}GB RAM\n";
		text = text + SystemInfo.processorType + "\n";
		text += $"{SystemInfo.graphicsDeviceName} ({(double)SystemInfo.graphicsMemorySize / 1024.0:0}GB)\n";
		text += "\n";
		text = text + BuildInfo.Current.Build.Node + " / " + BuildInfo.Current.Scm.Date + "\n";
		text = text + BuildInfo.Current.Scm.Repo + "/" + BuildInfo.Current.Scm.Branch + "#" + BuildInfo.Current.Scm.ChangeId + "\n";
		text = text + BuildInfo.Current.Scm.Author + " - " + BuildInfo.Current.Scm.Comment + "\n";
		((TMP_Text)SystemInfoText).text = text;
	}

	private void Update()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (!(RealTimeSince.op_Implicit(timeSinceUpdated) < 0.25f))
		{
			timeSinceUpdated = RealTimeSince.op_Implicit(0f);
			sb.Clear();
			sb.AppendLine(BenchmarkTitle);
			sb.AppendLine(BenchmarkSubtitle);
			sb.AppendLine();
			sb.Append(Performance.current.frameRate).Append(" FPS");
			sb.Append(" / ").Append(Performance.current.frameTime.ToString("0.0")).Append("ms");
			sb.AppendLine().Append(Performance.current.memoryAllocations).Append(" MB");
			sb.Append(" / ").Append(Performance.current.memoryCollections).Append(" GC");
			sb.AppendLine().Append(Performance.current.memoryUsageSystem).Append(" RAM");
			sb.AppendLine().Append(Performance.current.loadBalancerTasks).Append(" TASKS");
			sb.Append(" / ").Append(WorkshopSkin.QueuedCount).Append(" SKINS");
			sb.Append(" / ").Append(Performance.current.invokeHandlerTasks).Append(" INVOKES");
			sb.AppendLine();
			sb.AppendLine(DateTime.Now.ToShortDateString() + " " + DateTime.Now.ToLongTimeString());
			((TMP_Text)PerformanceText).text = sb.ToString();
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class BoneDictionary
{
	public Transform transform;

	public Transform[] transforms;

	public string[] names;

	private Dictionary<string, Transform> nameDict = new Dictionary<string, Transform>(StringComparer.OrdinalIgnoreCase);

	private Dictionary<uint, Transform> hashDict = new Dictionary<uint, Transform>();

	private Dictionary<Transform, uint> transformDict = new Dictionary<Transform, uint>();

	public int Count => transforms.Length;

	public BoneDictionary(Transform rootBone)
	{
		transform = rootBone;
		transforms = ((Component)rootBone).GetComponentsInChildren<Transform>(true);
		names = new string[transforms.Length];
		for (int i = 0; i < transforms.Length; i++)
		{
			Transform val = transforms[i];
			if ((Object)(object)val != (Object)null)
			{
				names[i] = ((Object)val).name;
			}
		}
		BuildBoneDictionary();
	}

	public BoneDictionary(Transform rootBone, Transform[] boneTransforms, string[] boneNames)
	{
		transform = rootBone;
		transforms = boneTransforms;
		names = boneNames;
		BuildBoneDictionary();
	}

	private void BuildBoneDictionary()
	{
		for (int i = 0; i < transforms.Length; i++)
		{
			Transform val = transforms[i];
			string text = names[i];
			uint num = StringPool.Get(text);
			if (!nameDict.ContainsKey(text))
			{
				nameDict.Add(text, val);
			}
			if (!hashDict.ContainsKey(num))
			{
				hashDict.Add(num, val);
			}
			if ((Object)(object)val != (Object)null && !transformDict.ContainsKey(val))
			{
				transformDict.Add(val, num);
			}
		}
	}

	public Transform FindBone(string name, bool defaultToRoot = true)
	{
		Transform value = null;
		if (nameDict.TryGetValue(name, out value))
		{
			return value;
		}
		if (!defaultToRoot)
		{
			return null;
		}
		return transform;
	}

	public Transform FindBone(uint hash, bool defaultToRoot = true)
	{
		Transform value = null;
		if (hashDict.TryGetValue(hash, out value))
		{
			return value;
		}
		if (!defaultToRoot)
		{
			return null;
		}
		return transform;
	}

	public uint FindBoneID(Transform transform)
	{
		if (!transformDict.TryGetValue(transform, out var value))
		{
			return StringPool.closest;
		}
		return value;
	}
}


using UnityEngine;

public class BoneRetarget : MonoBehaviour
{
	public bool preserveInFirstPerson;

	public bool restoreBeforePooling;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class AttackHeliCamOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class CCTVOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ClimateOverlay : MonoBehaviour
{
	[Range(0f, 1f)]
	public float blendingSpeed = 1f;

	public PostProcessVolume[] biomeVolumes;

	public const int biomeCount = 5;

	public const int volumeCount = 6;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ColdOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float smoothTime = 1f;

	public bool preventInstantiation;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ExplosionsOverlay : MonoBehaviour, IClientComponent
{
	public static ExplosionsOverlay Instance;

	public PostProcessVolume postProcessVolume;

	public AnimationCurve radialBlurStartCurve;

	public AnimationCurve radialBlurAmountCurve;

	public AnimationCurve lensDirtinessCurve;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class FlashbangOverlay : MonoBehaviour, IClientComponent
{
	public static FlashbangOverlay Instance;

	public PostProcessVolume postProcessVolume;

	public AnimationCurve burnIntensityCurve;

	public AnimationCurve whiteoutIntensityCurve;

	public SoundDefinition deafLoopDef;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HomingLauncherCamOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public NVGCamera nvgCameraOverlay;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HotOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float smoothTime = 1f;

	public bool preventInstantiation;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HurtOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float smoothTime = 1f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HurtPunch : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public static float punchHurtDuration = 0.334f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class NightLightOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float VisionCareExtraDistance = 20f;

	public float VisionCareExtraBrightness = 0.01f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class OxygenOverlay : MonoBehaviour
{
	[SerializeField]
	private PostProcessVolume postProcessVolume;

	[SerializeField]
	private float smoothTime = 1f;

	[Tooltip("If true, only show this effect when the player is mounted in a submarine.")]
	[SerializeField]
	private bool submarinesOnly;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class RadiationOverlay : MonoBehaviour
{
	public SoundDefinition[] geigerSounds;

	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class SharpenAndVignetteOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class SubmarineOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityStandardAssets.CinematicEffects;

public class TonemappingOverlay : ImageEffectLayer
{
	public TonemappingColorGrading tonemapping;
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class WaterOverlay : MonoBehaviour, IClientComponent
{
	[Serializable]
	public struct EffectParams
	{
		public float scatterCoefficient;

		public float scatterStrength;

		public bool blur;

		public float blurDistance;

		public float blurSize;

		public bool wiggle;

		public float wiggleSpeed;

		public bool chromaticAberration;

		public bool godRays;

		public static EffectParams Default = new EffectParams
		{
			scatterCoefficient = 1f,
			scatterStrength = 1f,
			blur = true,
			blurDistance = 6.5f,
			blurSize = 4f,
			wiggle = true,
			wiggleSpeed = 0.7f,
			chromaticAberration = false,
			godRays = false
		};

		public static EffectParams DefaultAdmin = new EffectParams
		{
			scatterCoefficient = 0.025f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = true,
			godRays = false
		};

		public static EffectParams DefaultGoggles = new EffectParams
		{
			scatterCoefficient = 0.05f,
			scatterStrength = 1f,
			blur = true,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = true,
			wiggleSpeed = 2f,
			chromaticAberration = true,
			godRays = true
		};

		public static EffectParams DefaultSubmarine = new EffectParams
		{
			scatterCoefficient = 0.025f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = false,
			godRays = false
		};

		public static EffectParams DefaultUnderwaterLab = new EffectParams
		{
			scatterCoefficient = 0.005f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = true,
			godRays = false
		};

		public static EffectParams DefaultCinematic = new EffectParams
		{
			scatterCoefficient = 0.025f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = true,
			godRays = false
		};
	}

	public PostProcessVolume postProcessVolume;

	public PostProcessVolume blurPostProcessVolume;

	public EffectParams defaultParams = EffectParams.Default;

	public EffectParams adminParams = EffectParams.DefaultAdmin;

	public EffectParams gogglesParams = EffectParams.DefaultGoggles;

	public EffectParams submarineParams = EffectParams.DefaultSubmarine;

	public EffectParams underwaterLabParams = EffectParams.DefaultUnderwaterLab;

	public EffectParams cinematicParams = EffectParams.DefaultCinematic;

	public Material[] UnderwaterFogMaterials;
}


using System;

[Serializable]
public struct EffectParams
{
	public float scatterCoefficient;

	public float scatterStrength;

	public bool blur;

	public float blurDistance;

	public float blurSize;

	public bool wiggle;

	public float wiggleSpeed;

	public bool chromaticAberration;

	public bool godRays;

	public static EffectParams Default = new EffectParams
	{
		scatterCoefficient = 1f,
		scatterStrength = 1f,
		blur = true,
		blurDistance = 6.5f,
		blurSize = 4f,
		wiggle = true,
		wiggleSpeed = 0.7f,
		chromaticAberration = false,
		godRays = false
	};

	public static EffectParams DefaultAdmin = new EffectParams
	{
		scatterCoefficient = 0.025f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = true,
		godRays = false
	};

	public static EffectParams DefaultGoggles = new EffectParams
	{
		scatterCoefficient = 0.05f,
		scatterStrength = 1f,
		blur = true,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = true,
		wiggleSpeed = 2f,
		chromaticAberration = true,
		godRays = true
	};

	public static EffectParams DefaultSubmarine = new EffectParams
	{
		scatterCoefficient = 0.025f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = false,
		godRays = false
	};

	public static EffectParams DefaultUnderwaterLab = new EffectParams
	{
		scatterCoefficient = 0.005f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = true,
		godRays = false
	};

	public static EffectParams DefaultCinematic = new EffectParams
	{
		scatterCoefficient = 0.025f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = true,
		godRays = false
	};
}


using UnityEngine;
using UnityEngine.UI;

public class CameraMan : SingletonComponent<CameraMan>
{
	public static string DefaultSaveName = string.Empty;

	public const string SavePositionExtension = ".cam";

	public const string SavePositionDirectory = "camsaves";

	public bool OnlyControlWhenCursorHidden = true;

	public bool NeedBothMouseButtonsToZoom;

	public float LookSensitivity = 1f;

	public float MoveSpeed = 1f;

	public static float GuideAspect = 4f;

	public static float GuideRatio = 3f;

	public Canvas canvas;

	public Graphic[] guides;
}


using ConVar;
using UnityEngine;

public class CameraSettings : MonoBehaviour, IClientComponent
{
	private Camera cam;

	private void OnEnable()
	{
		cam = ((Component)this).GetComponent<Camera>();
	}

	private void Update()
	{
		cam.farClipPlane = Mathf.Clamp(Graphics.drawdistance, 500f, 2500f);
	}
}


public class Client : SingletonComponent<Client>
{
	public static Phrase loading_loading = new Phrase("loading.loading", "Loading");

	public static Phrase loading_connecting = new Phrase("loading.connecting", "Connecting");

	public static Phrase loading_connectionaccepted = new Phrase("loading.connectionaccepted", "Connection Accepted");

	public static Phrase loading_connecting_negotiate = new Phrase("loading.connecting.negotiate", "Negotiating Connection");

	public static Phrase loading_level = new Phrase("loading.loadinglevel", "Loading Level");

	public static Phrase loading_skinnablewarmup = new Phrase("loading.skinnablewarmup", "Skinnable Warmup");

	public static Phrase loading_preloadcomplete = new Phrase("loading.preloadcomplete", "Preload Complete");

	public static Phrase loading_openingscene = new Phrase("loading.openingscene", "Opening Scene");

	public static Phrase loading_clientready = new Phrase("loading.clientready", "Client Ready");

	public static Phrase loading_prefabwarmup = new Phrase("loading.prefabwarmup", "Warming Prefabs [{0}/{1}]");

	public static Phrase loading_queue = new Phrase("loading.queue", "Queue");

	public static Phrase loading_queue_status = new Phrase("loading.queue.status", "{0:N0} PLAYERS AHEAD OF YOU, {1:N0} PLAYERS BEHIND");

	public static Phrase loading_queue_next = new Phrase("loading.queue.next", "YOU'RE NEXT - {1:N0} PLAYERS BEHIND YOU");

	public static Phrase party_too_large_phrase = new Phrase("loading.party_too_large", "Party too large to join server: max team size {0}");
}


public abstract class ComponentInfo<T> : ComponentInfo
{
	public T component;

	public void Initialize(T source)
	{
		component = source;
		Setup();
	}
}


using UnityEngine;

public abstract class ComponentInfo : MonoBehaviour
{
	public abstract void Setup();

	public abstract void Reset();
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class MeshCache
{
	[Serializable]
	public class Data
	{
		public Mesh mesh;

		public Vector3[] vertices;

		public Vector3[] normals;

		public Vector4[] tangents;

		public Color32[] colors32;

		public int[] triangles;

		public Vector2[] uv;

		public Vector2[] uv2;

		public Vector2[] uv3;

		public Vector2[] uv4;

		public Bounds bounds;
	}

	public static Dictionary<Mesh, Data> dictionary = new Dictionary<Mesh, Data>();

	public static Data Get(Mesh mesh)
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (!dictionary.TryGetValue(mesh, out var value))
		{
			value = new Data();
			value.mesh = mesh;
			value.vertices = mesh.vertices;
			value.normals = mesh.normals;
			value.tangents = mesh.tangents;
			value.colors32 = mesh.colors32;
			value.triangles = mesh.triangles;
			value.uv = mesh.uv;
			value.uv2 = mesh.uv2;
			value.uv3 = mesh.uv3;
			value.uv4 = mesh.uv4;
			value.bounds = mesh.bounds;
			dictionary.Add(mesh, value);
		}
		return value;
	}
}


using System;
using UnityEngine;

[Serializable]
public class Data
{
	public Mesh mesh;

	public Vector3[] vertices;

	public Vector3[] normals;

	public Vector4[] tangents;

	public Color32[] colors32;

	public int[] triangles;

	public Vector2[] uv;

	public Vector2[] uv2;

	public Vector2[] uv3;

	public Vector2[] uv4;

	public Bounds bounds;
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class MeshColliderData
{
	public List<int> triangles;

	public List<Vector3> vertices;

	public List<Vector3> normals;

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref vertices);
		}
		if (normals != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref normals);
		}
	}

	public void Clear()
	{
		if (triangles != null)
		{
			triangles.Clear();
		}
		if (vertices != null)
		{
			vertices.Clear();
		}
		if (normals != null)
		{
			normals.Clear();
		}
	}

	public void Apply(Mesh mesh)
	{
		mesh.Clear();
		if (vertices != null)
		{
			mesh.SetVertices(vertices);
		}
		if (triangles != null)
		{
			mesh.SetTriangles(triangles, 0);
		}
		if (normals != null)
		{
			if (normals.Count == vertices.Count)
			{
				mesh.SetNormals(normals);
			}
			else if (normals.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping collider normals because some meshes were missing them.");
			}
		}
	}

	public void Combine(MeshColliderGroup meshGroup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < ((List<MeshColliderInstance>)(object)meshGroup).Count; i++)
		{
			MeshColliderInstance meshColliderInstance = ((List<MeshColliderInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshColliderInstance.position, meshColliderInstance.rotation, meshColliderInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshColliderInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshColliderInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshColliderInstance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(meshColliderInstance.data.vertices[k]));
			}
			for (int l = 0; l < meshColliderInstance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(meshColliderInstance.data.normals[l]));
			}
		}
	}

	public void Combine(MeshColliderGroup meshGroup, MeshColliderLookup colliderLookup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < ((List<MeshColliderInstance>)(object)meshGroup).Count; i++)
		{
			MeshColliderInstance instance = ((List<MeshColliderInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(instance.position, instance.rotation, instance.scale);
			int count = vertices.Count;
			for (int j = 0; j < instance.data.triangles.Length; j++)
			{
				triangles.Add(count + instance.data.triangles[j]);
			}
			for (int k = 0; k < instance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(instance.data.vertices[k]));
			}
			for (int l = 0; l < instance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(instance.data.normals[l]));
			}
			colliderLookup.Add(instance);
		}
	}
}


public sealed class MeshColliderGroup : BasePooledList<MeshColliderInstance, MeshColliderGroup>
{
}


using UnityEngine;

public struct MeshColliderInstance
{
	public Transform transform;

	public Rigidbody rigidbody;

	public Collider collider;

	public OBB bounds;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public MeshCache.Data data;

	public Mesh mesh
	{
		get
		{
			return data.mesh;
		}
		set
		{
			data = MeshCache.Get(value);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class MeshColliderLookup
{
	public class LookupGroup
	{
		public List<LookupEntry> data = new List<LookupEntry>();

		public List<int> indices = new List<int>();

		public void Clear()
		{
			data.Clear();
			indices.Clear();
		}

		public void Add(MeshColliderInstance instance)
		{
			data.Add(new LookupEntry(instance));
			int item = data.Count - 1;
			int num = instance.data.triangles.Length / 3;
			for (int i = 0; i < num; i++)
			{
				indices.Add(item);
			}
		}

		public LookupEntry Get(int index)
		{
			return data[indices[index]];
		}
	}

	public struct LookupEntry
	{
		public Transform transform;

		public Rigidbody rigidbody;

		public Collider collider;

		public OBB bounds;

		public LookupEntry(MeshColliderInstance instance)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			transform = instance.transform;
			rigidbody = instance.rigidbody;
			collider = instance.collider;
			bounds = instance.bounds;
		}
	}

	public LookupGroup src = new LookupGroup();

	public LookupGroup dst = new LookupGroup();

	public void Apply()
	{
		LookupGroup lookupGroup = src;
		src = dst;
		dst = lookupGroup;
		dst.Clear();
	}

	public void Add(MeshColliderInstance instance)
	{
		dst.Add(instance);
	}

	public LookupEntry Get(int index)
	{
		return src.Get(index);
	}
}


using System.Collections.Generic;

public class LookupGroup
{
	public List<LookupEntry> data = new List<LookupEntry>();

	public List<int> indices = new List<int>();

	public void Clear()
	{
		data.Clear();
		indices.Clear();
	}

	public void Add(MeshColliderInstance instance)
	{
		data.Add(new LookupEntry(instance));
		int item = data.Count - 1;
		int num = instance.data.triangles.Length / 3;
		for (int i = 0; i < num; i++)
		{
			indices.Add(item);
		}
	}

	public LookupEntry Get(int index)
	{
		return data[indices[index]];
	}
}


using UnityEngine;

public struct LookupEntry
{
	public Transform transform;

	public Rigidbody rigidbody;

	public Collider collider;

	public OBB bounds;

	public LookupEntry(MeshColliderInstance instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		transform = instance.transform;
		rigidbody = instance.rigidbody;
		collider = instance.collider;
		bounds = instance.bounds;
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class MeshData
{
	public List<int> triangles;

	public List<Vector3> vertices;

	public List<Vector3> normals;

	public List<Vector4> tangents;

	public List<Color32> colors32;

	public List<Vector2> uv;

	public List<Vector2> uv2;

	public List<Vector4> positions;

	public void AllocMinimal()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
		if (tangents == null)
		{
			tangents = Pool.Get<List<Vector4>>();
		}
		if (uv == null)
		{
			uv = Pool.Get<List<Vector2>>();
		}
	}

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
		if (tangents == null)
		{
			tangents = Pool.Get<List<Vector4>>();
		}
		if (colors32 == null)
		{
			colors32 = Pool.Get<List<Color32>>();
		}
		if (uv == null)
		{
			uv = Pool.Get<List<Vector2>>();
		}
		if (uv2 == null)
		{
			uv2 = Pool.Get<List<Vector2>>();
		}
		if (positions == null)
		{
			positions = Pool.Get<List<Vector4>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref vertices);
		}
		if (normals != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref normals);
		}
		if (tangents != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref tangents);
		}
		if (colors32 != null)
		{
			Pool.FreeUnmanaged<Color32>(ref colors32);
		}
		if (uv != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv);
		}
		if (uv2 != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv2);
		}
		if (positions != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref positions);
		}
	}

	public void Clear()
	{
		if (triangles != null)
		{
			triangles.Clear();
		}
		if (vertices != null)
		{
			vertices.Clear();
		}
		if (normals != null)
		{
			normals.Clear();
		}
		if (tangents != null)
		{
			tangents.Clear();
		}
		if (colors32 != null)
		{
			colors32.Clear();
		}
		if (uv != null)
		{
			uv.Clear();
		}
		if (uv2 != null)
		{
			uv2.Clear();
		}
		if (positions != null)
		{
			positions.Clear();
		}
	}

	public void Apply(Mesh mesh)
	{
		mesh.Clear();
		if (vertices != null)
		{
			mesh.SetVertices(vertices);
		}
		if (triangles != null)
		{
			mesh.SetTriangles(triangles, 0);
		}
		if (normals != null)
		{
			if (normals.Count == vertices.Count)
			{
				mesh.SetNormals(normals);
			}
			else if (normals.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh normals because some meshes were missing them.");
			}
		}
		if (tangents != null)
		{
			if (tangents.Count == vertices.Count)
			{
				mesh.SetTangents(tangents);
			}
			else if (tangents.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh tangents because some meshes were missing them.");
			}
		}
		if (colors32 != null)
		{
			if (colors32.Count == vertices.Count)
			{
				mesh.SetColors(colors32);
			}
			else if (colors32.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh colors because some meshes were missing them.");
			}
		}
		if (uv != null)
		{
			if (uv.Count == vertices.Count)
			{
				mesh.SetUVs(0, uv);
			}
			else if (uv.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh uvs because some meshes were missing them.");
			}
		}
		if (uv2 != null)
		{
			if (uv2.Count == vertices.Count)
			{
				mesh.SetUVs(1, uv2);
			}
			else if (uv2.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh uv2s because some meshes were missing them.");
			}
		}
		if (positions != null)
		{
			mesh.SetUVs(2, positions);
		}
	}

	public void Combine(MeshGroup meshGroup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshInstance>)(object)meshGroup).Count; i++)
		{
			MeshInstance meshInstance = ((List<MeshInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshInstance.position, meshInstance.rotation, meshInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshInstance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(meshInstance.data.vertices[k]));
				positions.Add(Vector4.op_Implicit(meshInstance.position));
			}
			for (int l = 0; l < meshInstance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(meshInstance.data.normals[l]));
			}
			for (int m = 0; m < meshInstance.data.tangents.Length; m++)
			{
				Vector4 val2 = meshInstance.data.tangents[m];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				tangents.Add(new Vector4(val4.x, val4.y, val4.z, val2.w));
			}
			for (int n = 0; n < meshInstance.data.colors32.Length; n++)
			{
				colors32.Add(meshInstance.data.colors32[n]);
			}
			for (int num = 0; num < meshInstance.data.uv.Length; num++)
			{
				uv.Add(meshInstance.data.uv[num]);
			}
			for (int num2 = 0; num2 < meshInstance.data.uv2.Length; num2++)
			{
				uv2.Add(meshInstance.data.uv2[num2]);
			}
		}
	}
}


public sealed class MeshGroup : BasePooledList<MeshInstance, MeshGroup>
{
}


using UnityEngine;

public struct MeshInstance
{
	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public MeshCache.Data data;

	public Mesh mesh
	{
		get
		{
			return data.mesh;
		}
		set
		{
			data = MeshCache.Get(value);
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class MeshRendererData
{
	public List<int> triangles;

	public List<Vector3> vertices;

	public List<Vector3> normals;

	public List<Vector4> tangents;

	public List<Color32> colors32;

	public List<Vector2> uv;

	public List<Vector2> uv2;

	public List<Vector4> positions;

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
		if (tangents == null)
		{
			tangents = Pool.Get<List<Vector4>>();
		}
		if (colors32 == null)
		{
			colors32 = Pool.Get<List<Color32>>();
		}
		if (uv == null)
		{
			uv = Pool.Get<List<Vector2>>();
		}
		if (uv2 == null)
		{
			uv2 = Pool.Get<List<Vector2>>();
		}
		if (positions == null)
		{
			positions = Pool.Get<List<Vector4>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref vertices);
		}
		if (normals != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref normals);
		}
		if (tangents != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref tangents);
		}
		if (colors32 != null)
		{
			Pool.FreeUnmanaged<Color32>(ref colors32);
		}
		if (uv != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv);
		}
		if (uv2 != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv2);
		}
		if (positions != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref positions);
		}
	}

	public void Clear()
	{
		if (triangles != null)
		{
			triangles.Clear();
		}
		if (vertices != null)
		{
			vertices.Clear();
		}
		if (normals != null)
		{
			normals.Clear();
		}
		if (tangents != null)
		{
			tangents.Clear();
		}
		if (colors32 != null)
		{
			colors32.Clear();
		}
		if (uv != null)
		{
			uv.Clear();
		}
		if (uv2 != null)
		{
			uv2.Clear();
		}
		if (positions != null)
		{
			positions.Clear();
		}
	}

	public void Apply(Mesh mesh)
	{
		mesh.Clear();
		if (vertices != null)
		{
			mesh.SetVertices(vertices);
		}
		if (triangles != null)
		{
			mesh.SetTriangles(triangles, 0);
		}
		if (normals != null)
		{
			if (normals.Count == vertices.Count)
			{
				mesh.SetNormals(normals);
			}
			else if (normals.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer normals because some meshes were missing them.");
			}
		}
		if (tangents != null)
		{
			if (tangents.Count == vertices.Count)
			{
				mesh.SetTangents(tangents);
			}
			else if (tangents.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer tangents because some meshes were missing them.");
			}
		}
		if (colors32 != null)
		{
			if (colors32.Count == vertices.Count)
			{
				mesh.SetColors(colors32);
			}
			else if (colors32.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer colors because some meshes were missing them.");
			}
		}
		if (uv != null)
		{
			if (uv.Count == vertices.Count)
			{
				mesh.SetUVs(0, uv);
			}
			else if (uv.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer uvs because some meshes were missing them.");
			}
		}
		if (uv2 != null)
		{
			if (uv2.Count == vertices.Count)
			{
				mesh.SetUVs(1, uv2);
			}
			else if (uv2.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer uv2s because some meshes were missing them.");
			}
		}
		if (positions != null)
		{
			mesh.SetUVs(2, positions);
		}
	}

	public void Combine(MeshRendererGroup meshGroup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshRendererInstance>)(object)meshGroup).Count; i++)
		{
			MeshRendererInstance meshRendererInstance = ((List<MeshRendererInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshRendererInstance.position, meshRendererInstance.rotation, meshRendererInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshRendererInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshRendererInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshRendererInstance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(meshRendererInstance.data.vertices[k]));
				positions.Add(Vector4.op_Implicit(meshRendererInstance.position));
			}
			for (int l = 0; l < meshRendererInstance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(meshRendererInstance.data.normals[l]));
			}
			for (int m = 0; m < meshRendererInstance.data.tangents.Length; m++)
			{
				Vector4 val2 = meshRendererInstance.data.tangents[m];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				tangents.Add(new Vector4(val4.x, val4.y, val4.z, val2.w));
			}
			for (int n = 0; n < meshRendererInstance.data.colors32.Length; n++)
			{
				colors32.Add(meshRendererInstance.data.colors32[n]);
			}
			for (int num = 0; num < meshRendererInstance.data.uv.Length; num++)
			{
				uv.Add(meshRendererInstance.data.uv[num]);
			}
			for (int num2 = 0; num2 < meshRendererInstance.data.uv2.Length; num2++)
			{
				uv2.Add(meshRendererInstance.data.uv2[num2]);
			}
		}
	}

	public void Combine(MeshRendererGroup meshGroup, MeshRendererLookup rendererLookup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshRendererInstance>)(object)meshGroup).Count; i++)
		{
			MeshRendererInstance instance = ((List<MeshRendererInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(instance.position, instance.rotation, instance.scale);
			int count = vertices.Count;
			for (int j = 0; j < instance.data.triangles.Length; j++)
			{
				triangles.Add(count + instance.data.triangles[j]);
			}
			for (int k = 0; k < instance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(instance.data.vertices[k]));
				positions.Add(Vector4.op_Implicit(instance.position));
			}
			for (int l = 0; l < instance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(instance.data.normals[l]));
			}
			for (int m = 0; m < instance.data.tangents.Length; m++)
			{
				Vector4 val2 = instance.data.tangents[m];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				tangents.Add(new Vector4(val4.x, val4.y, val4.z, val2.w));
			}
			for (int n = 0; n < instance.data.colors32.Length; n++)
			{
				colors32.Add(instance.data.colors32[n]);
			}
			for (int num = 0; num < instance.data.uv.Length; num++)
			{
				uv.Add(instance.data.uv[num]);
			}
			for (int num2 = 0; num2 < instance.data.uv2.Length; num2++)
			{
				uv2.Add(instance.data.uv2[num2]);
			}
			rendererLookup.Add(instance);
		}
	}
}


public sealed class MeshRendererGroup : BasePooledList<MeshRendererInstance, MeshRendererGroup>
{
}


using UnityEngine;

public struct MeshRendererInstance
{
	public Renderer renderer;

	public OBB bounds;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public MeshCache.Data data;

	public Mesh mesh
	{
		get
		{
			return data.mesh;
		}
		set
		{
			data = MeshCache.Get(value);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class MeshRendererLookup
{
	public class LookupGroup
	{
		public List<LookupEntry> data = new List<LookupEntry>();

		public void Clear()
		{
			data.Clear();
		}

		public void Add(MeshRendererInstance instance)
		{
			data.Add(new LookupEntry(instance));
		}

		public LookupEntry Get(int index)
		{
			return data[index];
		}
	}

	public struct LookupEntry
	{
		public Renderer renderer;

		public LookupEntry(MeshRendererInstance instance)
		{
			renderer = instance.renderer;
		}
	}

	public LookupGroup src = new LookupGroup();

	public LookupGroup dst = new LookupGroup();

	public void Apply()
	{
		LookupGroup lookupGroup = src;
		src = dst;
		dst = lookupGroup;
		dst.Clear();
	}

	public void Clear()
	{
		dst.Clear();
	}

	public void Add(MeshRendererInstance instance)
	{
		dst.Add(instance);
	}

	public LookupEntry Get(int index)
	{
		return src.Get(index);
	}
}


using System.Collections.Generic;

public class LookupGroup
{
	public List<LookupEntry> data = new List<LookupEntry>();

	public void Clear()
	{
		data.Clear();
	}

	public void Add(MeshRendererInstance instance)
	{
		data.Add(new LookupEntry(instance));
	}

	public LookupEntry Get(int index)
	{
		return data[index];
	}
}


using UnityEngine;

public struct LookupEntry
{
	public Renderer renderer;

	public LookupEntry(MeshRendererInstance instance)
	{
		renderer = instance.renderer;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

public class RendererInfo : ComponentInfo<Renderer>
{
	public ShadowCastingMode shadows;

	public Material material;

	public Mesh mesh;

	public MeshFilter meshFilter;

	public override void Reset()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		component.shadowCastingMode = shadows;
		if (Object.op_Implicit((Object)(object)material))
		{
			component.sharedMaterial = material;
		}
		Renderer obj = component;
		SkinnedMeshRenderer val = (SkinnedMeshRenderer)(object)((obj is SkinnedMeshRenderer) ? obj : null);
		if (val != null)
		{
			val.sharedMesh = mesh;
		}
		else if (component is MeshRenderer)
		{
			meshFilter.sharedMesh = mesh;
		}
	}

	public override void Setup()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		shadows = component.shadowCastingMode;
		material = component.sharedMaterial;
		Renderer obj = component;
		SkinnedMeshRenderer val = (SkinnedMeshRenderer)(object)((obj is SkinnedMeshRenderer) ? obj : null);
		if (val != null)
		{
			mesh = val.sharedMesh;
		}
		else if (component is MeshRenderer)
		{
			meshFilter = ((Component)this).GetComponent<MeshFilter>();
			mesh = meshFilter.sharedMesh;
		}
	}
}


using UnityEngine;

public class CullWhenInside : MonoBehaviour
{
}


public class DecalBlood : DecalRecycle
{
}


using System;

public abstract class DecalComponent : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(DecalComponent);
	}
}


using UnityEngine;

public class DecalRecycle : BasePrefab, IClientComponent, IEffectRecycle
{
	public float LifeTime = 60f;

	[Range(1f, 50f)]
	public int WarmedUpAmount = 1;
}


public static class DecalRecycleEx
{
}


public class DecalRotate : DecalComponent
{
	[MinMax(0f, 360f)]
	public MinMax range = new MinMax(0f, 360f);
}


public class DecalScale : DecalComponent
{
	[MinMax(0f, 2f)]
	public MinMax range = new MinMax(0.9f, 1.1f);

	public bool uniform = true;
}


using UnityEngine;

public class DemoShotPlayback : MonoBehaviour
{
}


public class DemoShotRecorder : SingletonComponent<DemoShotRecorder>
{
}


public static class DemoShotHelpers
{
}


using System;
using UnityEngine;

[Obsolete]
public class DontBecomeSolidWithPlayerInside : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
public class DrawCameraFrustum : MonoBehaviour
{
	[SerializeField]
	private Material lineMaterial;
}


using UnityEngine;

public class DynamicZNear : MonoBehaviour
{
	public float minimum = 0.05f;

	public float maximum = 1f;
}


public static class EAC
{
}


using System.Runtime.CompilerServices;

public struct EncryptedValue<TInner> where TInner : unmanaged
{
	private TInner _value;

	private int _padding;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public TInner Get()
	{
		return _value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Set(TInner value)
	{
		_value = value;
	}

	public override string ToString()
	{
		return Get().ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator EncryptedValue<TInner>(TInner value)
	{
		EncryptedValue<TInner> result = default(EncryptedValue<TInner>);
		result.Set(value);
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator TInner(EncryptedValue<TInner> encrypted)
	{
		return encrypted.Get();
	}
}


using UnityEngine;

public class FollowCamera : MonoBehaviour, IClientComponent
{
	private void LateUpdate()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)MainCamera.mainCamera == (Object)null))
		{
			((Component)this).transform.position = MainCamera.position;
		}
	}
}


using UnityEngine;

public class Gib : ListComponent<Gib>
{
	public static int gibCount;

	public MeshFilter _meshFilter;

	public MeshRenderer _meshRenderer;

	public MeshCollider _meshCollider;

	public BoxCollider _boxCollider;

	public SphereCollider _sphereCollider;

	public CapsuleCollider _capsuleCollider;

	public Rigidbody _rigidbody;

	public static string GetEffect(PhysicMaterial physicMaterial)
	{
		return physicMaterial.GetNameLower() switch
		{
			"wood" => "assets/bundled/prefabs/fx/building/wood_gib.prefab", 
			"concrete" => "assets/bundled/prefabs/fx/building/stone_gib.prefab", 
			"metal" => "assets/bundled/prefabs/fx/building/metal_sheet_gib.prefab", 
			"rock" => "assets/bundled/prefabs/fx/building/stone_gib.prefab", 
			"flesh" => "assets/bundled/prefabs/fx/building/wood_gib.prefab", 
			_ => "assets/bundled/prefabs/fx/building/wood_gib.prefab", 
		};
	}
}


using System;
using System.Runtime.CompilerServices;
using Facepunch;

public sealed class HiddenValue<T> : IDisposable where T : class
{
	private T _value;

	public HiddenValue()
		: this((T)null)
	{
	}

	public HiddenValue(T value)
	{
		_value = value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public T Get()
	{
		return _value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public HiddenValue<T> Set(T value)
	{
		_value = value;
		return this;
	}

	public void Dispose()
	{
		_value = null;
		HiddenValue<T> hiddenValue = this;
		Pool.FreeUnsafe<HiddenValue<T>>(ref hiddenValue);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class IconSkin : MonoBehaviour, IItemIconChanged, IClientComponent
{
	public Image icon;

	public Text text;
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class IconSkinPicker : MonoBehaviour
{
	public GameObjectRef pickerIcon;

	public GameObject container;

	public Action skinChangedEvent;

	public ScrollRect scroller;

	public SearchFilterInput searchFilter;
}


using System.Collections.Generic;
using UnityEngine;

[DefaultExecutionOrder(-1)]
public class LightEx : UpdateBehaviour, IClientComponent
{
	public bool alterColor;

	public float colorTimeScale = 1f;

	public Color colorA = Color.red;

	public Color colorB = Color.yellow;

	public AnimationCurve blendCurve = new AnimationCurve();

	public bool loopColor = true;

	public bool alterIntensity;

	public float intensityTimeScale = 1f;

	public AnimationCurve intenseCurve = new AnimationCurve();

	public float intensityCurveScale = 3f;

	public bool loopIntensity = true;

	public bool randomOffset;

	public float randomIntensityStartScale = -1f;

	public List<Light> syncLights = new List<Light>(0);

	protected void OnValidate()
	{
		CheckConflict(((Component)this).gameObject);
	}

	public static bool CheckConflict(GameObject go)
	{
		return false;
	}
}


using UnityEngine;

public class LightGroupAtTime : FacepunchBehaviour
{
	public float IntensityOverride = 1f;

	public AnimationCurve IntensityScaleOverTime;

	public Transform SearchRoot;

	[Header("Power Settings")]
	public bool requiresPower;

	[Tooltip("Can NOT be entity, use new blank gameobject!")]
	public Transform powerOverrideTransform;

	public LayerMask checkLayers;

	public GameObject enableWhenLightsOn;

	public float timeBetweenPowerLookup;

	public LightGroupAtTime()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Expected O, but got Unknown
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		AnimationCurve val = new AnimationCurve();
		val.keys = (Keyframe[])(object)new Keyframe[5]
		{
			new Keyframe(0f, 1f),
			new Keyframe(8f, 0f),
			new Keyframe(12f, 0f),
			new Keyframe(19f, 1f),
			new Keyframe(24f, 1f)
		};
		IntensityScaleOverTime = val;
		checkLayers = LayerMask.op_Implicit(1235288065);
		timeBetweenPowerLookup = 10f;
		((FacepunchBehaviour)this)..ctor();
	}
}


using UnityEngine;

public class LocalPositionAnimation : MonoBehaviour, IClientComponent
{
	public Vector3 centerPosition;

	public bool worldSpace;

	public float scaleX = 1f;

	public float timeScaleX = 1f;

	public AnimationCurve movementX = new AnimationCurve();

	public float scaleY = 1f;

	public float timeScaleY = 1f;

	public AnimationCurve movementY = new AnimationCurve();

	public float scaleZ = 1f;

	public float timeScaleZ = 1f;

	public AnimationCurve movementZ = new AnimationCurve();
}


using UnityEngine;

[ExecuteInEditMode]
public class LookAt : MonoBehaviour, IClientComponent
{
	public Transform target;

	private void Update()
	{
		if (!((Object)(object)target == (Object)null))
		{
			((Component)this).transform.LookAt(target);
		}
	}
}


using System;
using UnityEngine;

[ExecuteInEditMode]
public class MainCamera : RustCamera<MainCamera>
{
	public static Camera mainCamera;

	public static Transform mainCameraTransform;

	public static Action PreCullCallback;

	public static bool isValid
	{
		get
		{
			if ((Object)(object)mainCamera != (Object)null && (Object)(object)mainCameraTransform != (Object)null)
			{
				return ((Behaviour)mainCamera).enabled;
			}
			return false;
		}
	}

	public static Vector3 velocity { get; private set; }

	public static Vector3 position
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.position;
		}
		set
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			mainCameraTransform.position = value;
		}
	}

	public static Vector3 forward
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.forward;
		}
		set
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			if (((Vector3)(ref value)).sqrMagnitude > 0f)
			{
				mainCameraTransform.forward = value;
			}
		}
	}

	public static Vector3 right
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.right;
		}
		set
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			if (((Vector3)(ref value)).sqrMagnitude > 0f)
			{
				mainCameraTransform.right = value;
			}
		}
	}

	public static Vector3 up
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.up;
		}
		set
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (((Vector3)(ref value)).sqrMagnitude > 0f)
			{
				((Component)mainCamera).transform.up = value;
			}
		}
	}

	public static Quaternion rotation
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.rotation;
		}
		set
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			mainCameraTransform.rotation = value;
		}
	}

	public static Ray Ray => new Ray(position, forward);
}


using System;
using UnityEngine;

public class MaterialParameterToggle : MonoBehaviour
{
	[Flags]
	public enum ToggleMode
	{
		Detail = 0,
		Emission = 1
	}

	[InspectorFlags]
	public ToggleMode Toggle;

	public Renderer[] TargetRenderers = (Renderer[])(object)new Renderer[0];

	[ColorUsage(true, true)]
	public Color EmissionColor;
}


using System;

[Flags]
public enum ToggleMode
{
	Detail = 0,
	Emission = 1
}


using UnityEngine;

public abstract class BaseMeshPaintable : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class MeshPaintable : BaseMeshPaintable
{
	public string replacementTextureName = "_MainTex";

	public int textureWidth = 256;

	public int textureHeight = 256;

	public Color clearColor = Color.clear;

	public Texture2D targetTexture;

	public bool hasChanges;
}


using UnityEngine;

public class MeshPaintable3D : BaseMeshPaintable
{
	[ClientVar]
	public static float brushScale = 2f;

	[ClientVar]
	public static float uvBufferScale = 2f;

	public string replacementTextureName = "_MainTex";

	public int textureWidth = 256;

	public int textureHeight = 256;

	public Camera cameraPreview;

	public Camera camera3D;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class MeshPaintableSource : MonoBehaviour, IClientComponent
{
	public Vector4 uvRange = new Vector4(0f, 0f, 1f, 1f);

	public int texWidth = 256;

	public int texHeight = 128;

	public string replacementTextureName = "_DecalTexture";

	public float cameraFOV = 60f;

	public float cameraDistance = 2f;

	[NonSerialized]
	public Texture2D texture;

	public GameObject sourceObject;

	public Mesh collisionMesh;

	public Vector3 localPosition;

	public Vector3 localRotation;

	public bool applyToAllRenderers = true;

	public Renderer[] extraRenderers;

	public bool paint3D;

	public bool applyToSkinRenderers = true;

	public bool applyToFirstPersonLegs = true;

	[NonSerialized]
	public bool isSelected;

	[NonSerialized]
	public Renderer legRenderer;

	private static MaterialPropertyBlock block;

	public void Init()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Expected O, but got Unknown
		if ((Object)(object)texture == (Object)null)
		{
			texture = new Texture2D(texWidth, texHeight, (TextureFormat)5, false);
			((Object)texture).name = "MeshPaintableSource_" + ((Object)((Component)this).gameObject).name;
			((Texture)texture).wrapMode = (TextureWrapMode)1;
			TextureEx.Clear(texture, Color32.op_Implicit(Color.clear));
		}
		if (block == null)
		{
			block = new MaterialPropertyBlock();
		}
		else
		{
			block.Clear();
		}
		UpdateMaterials(block, null, forEditing: false, isSelected);
		List<Renderer> list = Pool.Get<List<Renderer>>();
		Transform val = (applyToAllRenderers ? ((Component)this).transform.root : ((Component)this).transform);
		if (applyToSkinRenderers)
		{
			BaseEntity componentInParent = ((Component)this).GetComponentInParent<BaseEntity>();
			if ((Object)(object)componentInParent != (Object)null)
			{
				val = ((Component)componentInParent).transform;
			}
		}
		((Component)val).GetComponentsInChildren<Renderer>(true, list);
		PlayerModelSkin playerModelSkin = default(PlayerModelSkin);
		foreach (Renderer item in list)
		{
			if (applyToSkinRenderers || !((Component)item).TryGetComponent<PlayerModelSkin>(ref playerModelSkin))
			{
				item.SetPropertyBlock(block);
			}
		}
		if (extraRenderers != null)
		{
			Renderer[] array = extraRenderers;
			foreach (Renderer val2 in array)
			{
				if ((Object)(object)val2 != (Object)null)
				{
					val2.SetPropertyBlock(block);
				}
			}
		}
		if (applyToFirstPersonLegs && (Object)(object)legRenderer != (Object)null)
		{
			legRenderer.SetPropertyBlock(block);
		}
		Pool.FreeUnmanaged<Renderer>(ref list);
	}

	public void Free()
	{
		if (Object.op_Implicit((Object)(object)texture))
		{
			Object.Destroy((Object)(object)texture);
			texture = null;
		}
	}

	public void OnDestroy()
	{
		Free();
	}

	public virtual void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride = null, bool forEditing = false, bool isSelected = false)
	{
		block.SetTexture(replacementTextureName, (Texture)(object)(textureOverride ?? texture));
	}

	public virtual Color32[] UpdateFrom(Texture2D input)
	{
		Init();
		Color32[] pixels = input.GetPixels32();
		texture.SetPixels32(pixels);
		texture.Apply(true, false);
		return pixels;
	}

	public void Load(byte[] data)
	{
		Init();
		if (data != null)
		{
			ImageConversion.LoadImage(texture, data);
			texture.Apply(true, false);
		}
	}

	public void Clear()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)texture == (Object)null))
		{
			TextureEx.Clear(texture, Color32.op_Implicit(new Color(0f, 0f, 0f, 0f)));
			texture.Apply(true, false);
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class MeshPaintController : MonoBehaviour, IClientComponent
{
	public enum Tool
	{
		Brush,
		Eraser,
		ColorPicker
	}

	public enum RotateMode
	{
		None,
		Movement,
		Random
	}

	public Camera pickerCamera;

	public Tool currentTool;

	public Texture2D brushTexture;

	public Vector2 brushScale = new Vector2(8f, 8f);

	public Color brushColor = Color.white;

	public float brushSpacing = 2f;

	public float brushSpacingFactor = 0.25f;

	public RawImage brushImage;

	public float brushPreviewScaleMultiplier = 1f;

	public Texture2D stampTexture;

	public RotateMode brushRotation;

	public bool applyDefaults;

	public Texture2D defaltBrushTexture;

	public float defaultBrushSize = 16f;

	public Color defaultBrushColor = Color.black;

	public float defaultBrushAlpha = 0.5f;

	public float maxBrushScale = 32f;

	[Tooltip("When auto-saving is enabled, this is the interval in seconds between saves.")]
	public float autoSaveInterval = 30f;

	public RustButton UndoButton;

	public RustButton RedoButton;

	public GameObject BackgroundBlocker;

	private Vector3 lastPosition;
}


public enum Tool
{
	Brush,
	Eraser,
	ColorPicker
}


public enum RotateMode
{
	None,
	Movement,
	Random
}


using System;
using UnityEngine;

public class OverlayMeshPaintableSource : MeshPaintableSource
{
	private static readonly Memoized<string, string> STPrefixed = new Memoized<string, string>((Func<string, string>)((string s) => s + "_ST"));

	public string baseTextureName = "_Decal1Texture";

	[NonSerialized]
	public Texture2D baseTexture;

	public override void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride = null, bool forEditing = false, bool isSelected = false)
	{
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		base.UpdateMaterials(block, textureOverride, forEditing, isSelected);
		if ((Object)(object)baseTexture != (Object)null)
		{
			float num = (float)((Texture)baseTexture).width / (float)((Texture)baseTexture).height;
			int num2 = texWidth / texHeight;
			float num3 = 1f;
			float num4 = 0f;
			float num5 = 1f;
			float num6 = 0f;
			if ((float)num2 <= num)
			{
				float num7 = (float)texHeight * num;
				num3 = (float)texWidth / num7;
				num4 = (1f - num3) / 2f;
			}
			else
			{
				float num8 = (float)texWidth / num;
				num5 = (float)texHeight / num8;
				num6 = (1f - num5) / 2f;
			}
			block.SetTexture(baseTextureName, (Texture)(object)baseTexture);
			block.SetVector(STPrefixed.Get(baseTextureName), new Vector4(num3, num5, num4, num6));
		}
		else
		{
			block.SetTexture(baseTextureName, (Texture)(object)Texture2D.blackTexture);
		}
	}
}


using Facepunch;
using UnityEngine;

public class Model : MonoBehaviour, IPrefabPreProcess
{
	public SphereCollider collision;

	public Transform rootBone;

	public Transform headBone;

	public Transform eyeBone;

	public Animator animator;

	public Skeleton skeleton;

	[HideInInspector]
	public Transform[] boneTransforms;

	[HideInInspector]
	public string[] boneNames;

	internal BoneDictionary boneDict;

	internal int skin;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	protected void OnEnable()
	{
		skin = -1;
	}

	public void BuildBoneDictionary()
	{
		if (boneDict == null)
		{
			boneDict = new BoneDictionary(((Component)this).transform, boneTransforms, boneNames);
		}
	}

	public int GetSkin()
	{
		return skin;
	}

	private Transform FindBoneInternal(string name)
	{
		BuildBoneDictionary();
		return boneDict.FindBone(name, defaultToRoot: false);
	}

	public Transform FindBone(string name)
	{
		BuildBoneDictionary();
		Transform result = rootBone;
		if (string.IsNullOrEmpty(name))
		{
			return result;
		}
		return boneDict.FindBone(name);
	}

	public Transform FindBone(uint hash)
	{
		BuildBoneDictionary();
		Transform result = rootBone;
		if (hash == 0)
		{
			return result;
		}
		return boneDict.FindBone(hash);
	}

	public uint FindBoneID(Transform transform)
	{
		BuildBoneDictionary();
		return boneDict.FindBoneID(transform);
	}

	public Transform[] GetBones()
	{
		BuildBoneDictionary();
		return boneDict.transforms;
	}

	public Transform FindClosestBone(Vector3 worldPos)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Transform result = rootBone;
		float num = float.MaxValue;
		for (int i = 0; i < boneTransforms.Length; i++)
		{
			Transform val = boneTransforms[i];
			if (!((Object)(object)val == (Object)null))
			{
				float num2 = Vector3.Distance(val.position, worldPos);
				if (!(num2 >= num))
				{
					result = val;
					num = num2;
				}
			}
		}
		return result;
	}

	public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!((Object)(object)this == (Object)null))
		{
			if ((Object)(object)animator == (Object)null)
			{
				animator = ((Component)this).GetComponent<Animator>();
			}
			if ((Object)(object)rootBone == (Object)null)
			{
				rootBone = ((Component)this).transform;
			}
			boneTransforms = ((Component)rootBone).GetComponentsInChildren<Transform>(true);
			boneNames = new string[boneTransforms.Length];
			for (int i = 0; i < boneTransforms.Length; i++)
			{
				boneNames[i] = ((Object)boneTransforms[i]).name;
			}
		}
	}
}


public class NexusClient : SingletonComponent<NexusClient>
{
}


public static class NexusClientUtil
{
}


using UnityEngine;

public class ParticleDisableOnParentDestroy : MonoBehaviour, IOnParentDestroying
{
	public float destroyAfterSeconds;

	public void OnParentDestroying()
	{
		((Component)this).transform.parent = null;
		ParticleSystem component = ((Component)this).GetComponent<ParticleSystem>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.enableEmission = false;
		}
		if (destroyAfterSeconds > 0f)
		{
			GameManager.Destroy(((Component)this).gameObject, destroyAfterSeconds);
		}
	}
}


using UnityEngine;

public class ParticleRandomLifetime : MonoBehaviour
{
	public ParticleSystem mySystem;

	public float minScale = 0.5f;

	public float maxScale = 1f;

	public void Awake()
	{
		if (Object.op_Implicit((Object)(object)mySystem))
		{
			float startLifetime = Random.Range(minScale, maxScale);
			mySystem.startLifetime = startLifetime;
		}
	}
}


using UnityEngine;

public class PlayAudioEx : MonoBehaviour
{
	public float delay;

	private void Start()
	{
	}

	private void OnEnable()
	{
		AudioSource component = ((Component)this).GetComponent<AudioSource>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.PlayDelayed(delay);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PlayerModelHair : MonoBehaviour
{
	public struct RendererMaterials
	{
		public string[] names;

		public Material[] original;

		public Material[] replacement;

		public RendererMaterials(Renderer r)
		{
			original = r.sharedMaterials;
			replacement = original.Clone() as Material[];
			names = new string[original.Length];
			for (int i = 0; i < original.Length; i++)
			{
				names[i] = ((Object)original[i]).name;
			}
		}
	}

	public HairType type;

	private Dictionary<Renderer, RendererMaterials> materials;

	public Dictionary<Renderer, RendererMaterials> Materials => materials;

	private void CacheOriginalMaterials()
	{
		if (materials != null)
		{
			return;
		}
		List<SkinnedMeshRenderer> list = Pool.Get<List<SkinnedMeshRenderer>>();
		((Component)this).gameObject.GetComponentsInChildren<SkinnedMeshRenderer>(true, list);
		materials = new Dictionary<Renderer, RendererMaterials>();
		materials.Clear();
		foreach (SkinnedMeshRenderer item in list)
		{
			materials.Add((Renderer)(object)item, new RendererMaterials((Renderer)(object)item));
		}
		Pool.FreeUnmanaged<SkinnedMeshRenderer>(ref list);
	}

	private void Setup(HairType type, HairSetCollection hair, int meshIndex, float typeNum, float dyeNum, MaterialPropertyBlock block)
	{
		CacheOriginalMaterials();
		HairSetCollection.HairSetEntry hairSetEntry = hair.Get(type, typeNum);
		if ((Object)(object)hairSetEntry.HairSet == (Object)null)
		{
			Debug.LogWarning((object)"Hair.Get returned a NULL hair");
			return;
		}
		int blendShapeIndex = -1;
		if (type == HairType.Facial || type == HairType.Eyebrow)
		{
			blendShapeIndex = meshIndex;
		}
		HairDye dye = null;
		HairDyeCollection hairDyeCollection = hairSetEntry.HairDyeCollection;
		if ((Object)(object)hairDyeCollection != (Object)null)
		{
			dye = hairDyeCollection.Get(dyeNum);
		}
		hairSetEntry.HairSet.Process(this, hairDyeCollection, dye, block);
		hairSetEntry.HairSet.ProcessMorphs(((Component)this).gameObject, blendShapeIndex);
	}

	public void Setup(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
	{
		int index = skin.GetIndex(meshNum);
		SkinSet skinSet = skin.Skins[index];
		if ((Object)(object)skinSet == (Object)null)
		{
			Debug.LogError((object)"Skin.Get returned a NULL skin");
		}
		else if (!((Object)(object)skinSet.HairCollection == (Object)null))
		{
			int typeIndex = (int)type;
			GetRandomVariation(hairNum, typeIndex, index, out var typeNum, out var dyeNum);
			Setup(type, skinSet.HairCollection, index, typeNum, dyeNum, block);
		}
	}

	public static void GetRandomVariation(float hairNum, int typeIndex, int meshIndex, out float typeNum, out float dyeNum)
	{
		int num = Mathf.FloorToInt(hairNum * 100000f);
		typeNum = GetRandomHairType(hairNum, typeIndex);
		Random.InitState(num + meshIndex);
		dyeNum = Random.Range(0f, 1f);
	}

	public static float GetRandomHairType(float hairNum, int typeIndex)
	{
		Random.InitState(Mathf.FloorToInt(hairNum * 100000f) + typeIndex);
		return Random.Range(0f, 1f);
	}
}


using UnityEngine;

public struct RendererMaterials
{
	public string[] names;

	public Material[] original;

	public Material[] replacement;

	public RendererMaterials(Renderer r)
	{
		original = r.sharedMaterials;
		replacement = original.Clone() as Material[];
		names = new string[original.Length];
		for (int i = 0; i < original.Length; i++)
		{
			names[i] = ((Object)original[i]).name;
		}
	}
}


using System;

[Flags]
public enum HairCapMask
{
	Head = 1,
	Eyebrow = 2,
	Facial = 4,
	Armpit = 8,
	Pubic = 0x10
}


using UnityEngine;

public class PlayerModelHairCap : MonoBehaviour
{
	[InspectorFlags]
	public HairCapMask hairCapMask;

	public void SetupHairCap(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
	{
		int index = skin.GetIndex(meshNum);
		SkinSet skinSet = skin.Skins[index];
		if ((Object)(object)skinSet == (Object)null || (Object)(object)skinSet.HairCollection == (Object)null)
		{
			return;
		}
		for (int i = 0; i < 5; i++)
		{
			if (((uint)hairCapMask & (uint)(1 << i)) == 0)
			{
				continue;
			}
			PlayerModelHair.GetRandomVariation(hairNum, i, index, out var typeNum, out var dyeNum);
			HairType hairType = (HairType)i;
			HairSetCollection.HairSetEntry hairSetEntry = skinSet.HairCollection.Get(hairType, typeNum);
			if (!((Object)(object)hairSetEntry.HairSet == (Object)null))
			{
				HairDyeCollection hairDyeCollection = hairSetEntry.HairDyeCollection;
				if (!((Object)(object)hairDyeCollection == (Object)null))
				{
					hairDyeCollection.Get(dyeNum)?.ApplyCap(hairDyeCollection, hairType, block);
				}
			}
		}
	}
}


using UnityEngine;

public class PlayerModelSkin : MonoBehaviour, IPrefabPreProcess
{
	public enum SkinMaterialType
	{
		HEAD,
		EYE,
		BODY
	}

	public SkinMaterialType MaterialType;

	public Renderer SkinRenderer;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public void Setup(SkinSet skin, float hairNum)
	{
		if (Object.op_Implicit((Object)(object)SkinRenderer) && Object.op_Implicit((Object)(object)skin))
		{
			SkinRenderer.enabled = true;
			switch (MaterialType)
			{
			case SkinMaterialType.HEAD:
				SkinRenderer.sharedMaterial = skin.HeadMaterial;
				break;
			case SkinMaterialType.BODY:
				SkinRenderer.sharedMaterial = skin.BodyMaterial;
				break;
			case SkinMaterialType.EYE:
				SkinRenderer.sharedMaterial = skin.EyeMaterial;
				break;
			default:
				SkinRenderer.sharedMaterial = skin.BodyMaterial;
				break;
			}
		}
	}

	public void ToggleSkinRenderer(bool toggle)
	{
		if (Object.op_Implicit((Object)(object)SkinRenderer))
		{
			SkinRenderer.enabled = toggle;
		}
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (clientside)
		{
			SkinRenderer = ((Component)this).GetComponent<Renderer>();
		}
	}
}


public enum SkinMaterialType
{
	HEAD,
	EYE,
	BODY
}


public interface ILerpInfo
{
	public enum LerpType
	{
		Generic,
		Position
	}

	float GetExtrapolationTime();

	float GetInterpolationDelay(LerpType lerpType);

	float GetInterpolationSmoothing();
}


public enum LerpType
{
	Generic,
	Position
}


using System.Collections.Generic;
using Rust.Interpolation;
using UnityEngine;

public interface IPosLerpTarget : ILerpInfo
{
	float GetInterpolationInertia();

	Vector3 GetNetworkPosition();

	Quaternion GetNetworkRotation();

	void SetNetworkPosition(Vector3 pos);

	void SetNetworkRotation(Quaternion rot);

	void DrawInterpolationState(Interpolator<TransformSnapshot>.Segment segment, List<TransformSnapshot> entries);

	void LerpIdleDisable();
}


using System;
using Development.Attributes;
using Facepunch;
using Rust.Interpolation;
using UnityEngine;

[ResetStaticFields]
public class PositionLerp : IPooled
{
	private static ListHashSet<PositionLerp> InstanceList = new ListHashSet<PositionLerp>();

	public static bool DebugLog = false;

	public static bool DebugDraw = false;

	public static int TimeOffsetInterval = 16;

	public static float TimeOffset = 0f;

	public const int TimeOffsetIntervalMin = 4;

	public const int TimeOffsetIntervalMax = 64;

	private bool enabled = true;

	private Action idleDisable;

	private readonly Interpolator<TransformSnapshot> interpolator = new Interpolator<TransformSnapshot>(32);

	private IPosLerpTarget target;

	private static TransformSnapshot snapshotPrototype = default(TransformSnapshot);

	private float timeOffset0 = float.MaxValue;

	private float timeOffset1 = float.MaxValue;

	private float timeOffset2 = float.MaxValue;

	private float timeOffset3 = float.MaxValue;

	private int timeOffsetCount;

	private float lastClientTime;

	private float lastServerTime;

	private float extrapolatedTime;

	private float enabledTime;

	public bool Enabled
	{
		get
		{
			return enabled;
		}
		set
		{
			enabled = value;
			if (enabled)
			{
				OnEnable();
			}
			else
			{
				OnDisable();
			}
		}
	}

	public static float LerpTime => Time.time;

	private void OnEnable()
	{
		InstanceList.Add(this);
		enabledTime = LerpTime;
	}

	private void OnDisable()
	{
		InstanceList.Remove(this);
	}

	public void Initialize(IPosLerpTarget target)
	{
		this.target = target;
		Enabled = true;
	}

	public void Snapshot(Vector3 position, Quaternion rotation, float serverTime)
	{
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		float num = interpolationDelay + interpolationSmoothing + 1f;
		float lerpTime = LerpTime;
		timeOffset0 = Mathf.Min(timeOffset0, lerpTime - serverTime);
		timeOffsetCount++;
		if (timeOffsetCount >= TimeOffsetInterval / 4)
		{
			timeOffset3 = timeOffset2;
			timeOffset2 = timeOffset1;
			timeOffset1 = timeOffset0;
			timeOffset0 = float.MaxValue;
			timeOffsetCount = 0;
		}
		TimeOffset = Mathx.Min(timeOffset0, timeOffset1, timeOffset2, timeOffset3);
		lerpTime = serverTime + TimeOffset;
		if (DebugLog && interpolator.list.Count > 0 && serverTime < lastServerTime)
		{
			Debug.LogWarning((object)(target.ToString() + " adding tick from the past: server time " + serverTime + " < " + lastServerTime));
		}
		else if (DebugLog && interpolator.list.Count > 0 && lerpTime < lastClientTime)
		{
			Debug.LogWarning((object)(target.ToString() + " adding tick from the past: client time " + lerpTime + " < " + lastClientTime));
		}
		else
		{
			lastClientTime = lerpTime;
			lastServerTime = serverTime;
			interpolator.Add(new TransformSnapshot(lerpTime, position, rotation));
		}
		interpolator.Cull(lerpTime - num);
	}

	public void Snapshot(Vector3 position, Quaternion rotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Snapshot(position, rotation, LerpTime - TimeOffset);
	}

	public void SnapTo(Vector3 position, Quaternion rotation, float serverTime)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		interpolator.Clear();
		Snapshot(position, rotation, serverTime);
		target.SetNetworkPosition(position);
		target.SetNetworkRotation(rotation);
	}

	public void SnapTo(Vector3 position, Quaternion rotation)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		interpolator.last = new TransformSnapshot(LerpTime, position, rotation);
		Wipe();
	}

	public void SnapToEnd()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, 0f, 0f, ref snapshotPrototype);
		target.SetNetworkPosition(segment.tick.pos);
		target.SetNetworkRotation(segment.tick.rot);
		Wipe();
	}

	public void Wipe()
	{
		interpolator.Clear();
		timeOffsetCount = 0;
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
	}

	public static void WipeAll()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<PositionLerp> enumerator = InstanceList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Wipe();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	protected void DoCycle()
	{
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		if (target == null)
		{
			return;
		}
		float interpolationInertia = target.GetInterpolationInertia();
		float num = ((interpolationInertia > 0f) ? Mathf.InverseLerp(0f, interpolationInertia, LerpTime - enabledTime) : 1f);
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolation = target.GetInterpolationDelay(ILerpInfo.LerpType.Position) * num;
		float num2 = target.GetInterpolationSmoothing() * num;
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolation, extrapolationTime, num2, ref snapshotPrototype);
		if (segment.next.Time >= interpolator.last.Time)
		{
			extrapolatedTime = Mathf.Min(extrapolatedTime + Time.deltaTime, extrapolationTime);
		}
		else
		{
			extrapolatedTime = Mathf.Max(extrapolatedTime - Time.deltaTime, 0f);
		}
		if (extrapolatedTime > 0f && extrapolationTime > 0f && num2 > 0f)
		{
			float num3 = Time.deltaTime / (extrapolatedTime / extrapolationTime * num2);
			segment.tick.pos = Vector3.Lerp(target.GetNetworkPosition(), segment.tick.pos, num3);
			segment.tick.rot = Quaternion.Slerp(target.GetNetworkRotation(), segment.tick.rot, num3);
		}
		target.SetNetworkPosition(segment.tick.pos);
		target.SetNetworkRotation(segment.tick.rot);
		if (DebugDraw)
		{
			target.DrawInterpolationState(segment, interpolator.list);
		}
		if (LerpTime - lastClientTime > 10f)
		{
			if (idleDisable == null)
			{
				idleDisable = target.LerpIdleDisable;
			}
			IPosLerpTarget posLerpTarget = target;
			InvokeHandler.Invoke((Behaviour)((posLerpTarget is Behaviour) ? posLerpTarget : null), idleDisable, 0f);
		}
	}

	public void TransformEntries(Matrix4x4 matrix)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		Quaternion rotation = ((Matrix4x4)(ref matrix)).rotation;
		for (int i = 0; i < interpolator.list.Count; i++)
		{
			TransformSnapshot value = interpolator.list[i];
			value.pos = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(value.pos);
			value.rot = rotation * value.rot;
			interpolator.list[i] = value;
		}
		interpolator.last.pos = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(interpolator.last.pos);
		interpolator.last.rot = rotation * interpolator.last.rot;
	}

	public Quaternion GetEstimatedAngularVelocity()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (target == null)
		{
			return Quaternion.identity;
		}
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, extrapolationTime, interpolationSmoothing, ref snapshotPrototype);
		TransformSnapshot next = segment.next;
		TransformSnapshot prev = segment.prev;
		if (next.Time == prev.Time)
		{
			return Quaternion.identity;
		}
		return Quaternion.Euler((((Quaternion)(ref prev.rot)).eulerAngles - ((Quaternion)(ref next.rot)).eulerAngles) / (prev.Time - next.Time));
	}

	public Vector3 GetEstimatedVelocity()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (target == null)
		{
			return Vector3.zero;
		}
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, extrapolationTime, interpolationSmoothing, ref snapshotPrototype);
		TransformSnapshot next = segment.next;
		TransformSnapshot prev = segment.prev;
		if (next.Time == prev.Time)
		{
			return Vector3.zero;
		}
		return (prev.pos - next.pos) / (prev.Time - next.Time);
	}

	void IPooled.EnterPool()
	{
		target = null;
		idleDisable = null;
		interpolator.Clear();
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
		lastClientTime = 0f;
		lastServerTime = 0f;
		extrapolatedTime = 0f;
		timeOffsetCount = 0;
		Enabled = false;
	}

	void IPooled.LeavePool()
	{
	}

	public static void Clear()
	{
		InstanceList.Clear();
	}

	public static void Cycle()
	{
		PositionLerp[] buffer = InstanceList.Values.Buffer;
		int count = InstanceList.Count;
		for (int i = 0; i < count; i++)
		{
			buffer[i].DoCycle();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

public class Projectile : ListComponent<Projectile>
{
	public enum EffectMatchMode
	{
		None,
		Velocity,
		InverseVelocity
	}

	[Serializable]
	public class CustomEffectData
	{
		public bool UseCustomEffect;

		public EffectMatchMode MatchMode;
	}

	public struct Modifier
	{
		public float damageScale;

		public float damageOffset;

		public float distanceScale;

		public float distanceOffset;

		public static Modifier Default = new Modifier
		{
			damageScale = 1f,
			damageOffset = 0f,
			distanceScale = 1f,
			distanceOffset = 0f
		};
	}

	public const float moveDeltaTime = 1f / 32f;

	public const float lifeTime = 8f;

	[Header("Attributes")]
	public Vector3 initialVelocity;

	public float drag;

	public float gravityModifier = 1f;

	public float thickness;

	[Tooltip("Tick this box to be able to change the initial orientation of the projectile")]
	[Header("Orientation")]
	public bool changeInitialOrientation;

	[Tooltip("This projectile will raycast for this many units, and then become a projectile. This is typically done for bullets.")]
	public float initialDistance;

	public Vector3 initialOrientation;

	[Header("Impact Rules")]
	public bool remainInWorld;

	[Range(0f, 1f)]
	public float stickProbability = 1f;

	[Range(0f, 1f)]
	public float breakProbability;

	[Range(0f, 1f)]
	public float conditionLoss;

	[Range(0f, 1f)]
	public float ricochetChance;

	public float penetrationPower = 1f;

	public bool canRefract = true;

	public bool penetratesVehicles;

	[Range(0f, 1f)]
	public float waterIntegrityLoss = 0.1f;

	[Header("Damage")]
	public DamageProperties damageProperties;

	[Horizontal(2, -1)]
	public MinMax damageDistances = new MinMax(10f, 100f);

	[Horizontal(2, -1)]
	public MinMax damageMultipliers = new MinMax(1f, 0.8f);

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	[Header("Rendering")]
	public ScaleRenderer rendererToScale;

	public ScaleRenderer firstPersonRenderer;

	public bool createDecals = true;

	[Header("Effects")]
	public bool doDefaultHitEffects = true;

	[Header("Audio")]
	public SoundDefinition flybySound;

	public float flybySoundDistance = 7f;

	public SoundDefinition closeFlybySound;

	public float closeFlybyDistance = 3f;

	[Header("Tumble")]
	public float tumbleSpeed;

	public Vector3 tumbleAxis = Vector3.right;

	[Header("Clientside Custom Impact Effects")]
	public bool playDefaultHitEffects = true;

	public CustomEffectData clientEffectData;

	public GameObjectRef clientEffectPrefab;

	[Header("Swim")]
	public Vector3 swimScale;

	public Vector3 swimSpeed;

	[NonSerialized]
	public BasePlayer owner;

	[NonSerialized]
	public AttackEntity sourceWeaponPrefab;

	[NonSerialized]
	public Projectile sourceProjectilePrefab;

	[NonSerialized]
	public ItemModProjectile mod;

	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public int seed;

	[NonSerialized]
	public bool clientsideEffect;

	[NonSerialized]
	public bool clientsideAttack;

	[NonSerialized]
	public float integrity = 1f;

	[NonSerialized]
	public float maxDistance = float.PositiveInfinity;

	[NonSerialized]
	public Modifier modifier = Modifier.Default;

	[NonSerialized]
	public bool invisible;

	[NonSerialized]
	public bool noHeadshots;

	[NonSerialized]
	public bool noGravity;

	[NonSerialized]
	public float currentThickness;

	[ClientVar(Help = "Should the projectile model attempt to prevent itself being clipped by the camera?", Saved = true)]
	public static bool preventCameraClip = true;

	[ClientVar(Help = "Buffer seconds before turning back on the projectile model.")]
	public static float preventCameraClipBufferSeconds = 0.01f;

	[ClientVar(Help = "Distance before turning back on the server spawned projectiles model.")]
	public static float serverProjectileCameraClipDistance = 0.3f;

	private static uint _fleshMaterialID = 0u;

	private static uint _waterMaterialID = 0u;

	private static uint cachedWaterString = 0u;

	private Vector3? GetCustomEffectNormal()
	{
		return null;
	}

	public void CalculateDamage(HitInfo info, Modifier mod, float scale)
	{
		float num = damageMultipliers.Lerp(mod.distanceOffset + mod.distanceScale * damageDistances.x, mod.distanceOffset + mod.distanceScale * damageDistances.y, info.ProjectileDistance);
		float num2 = scale * (mod.damageOffset + mod.damageScale * num);
		foreach (DamageTypeEntry damageType in damageTypes)
		{
			info.damageTypes.Add(damageType.type, damageType.amount * num2);
		}
		if (Global.developer > 0)
		{
			Debug.Log((object)(" Projectile damage: " + info.damageTypes.Total() + " (scalar=" + num2 + ")"));
		}
	}

	public static uint FleshMaterialID()
	{
		if (_fleshMaterialID == 0)
		{
			_fleshMaterialID = StringPool.Get("flesh");
		}
		return _fleshMaterialID;
	}

	public static uint WaterMaterialID()
	{
		if (_waterMaterialID == 0)
		{
			_waterMaterialID = StringPool.Get("Water");
		}
		return _waterMaterialID;
	}

	public static bool IsWaterMaterial(string hitMaterial)
	{
		if (cachedWaterString == 0)
		{
			cachedWaterString = StringPool.Get("Water");
		}
		if (StringPool.Get(hitMaterial) == cachedWaterString)
		{
			return true;
		}
		return false;
	}

	public static bool ShouldStopProjectile(RaycastHit hit)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity entity = hit.GetEntity();
		if ((Object)(object)entity != (Object)null && !entity.ShouldBlockProjectiles())
		{
			return false;
		}
		return true;
	}
}


public enum EffectMatchMode
{
	None,
	Velocity,
	InverseVelocity
}


using System;

[Serializable]
public class CustomEffectData
{
	public bool UseCustomEffect;

	public EffectMatchMode MatchMode;
}


public struct Modifier
{
	public float damageScale;

	public float damageOffset;

	public float distanceScale;

	public float distanceOffset;

	public static Modifier Default = new Modifier
	{
		damageScale = 1f,
		damageOffset = 0f,
		distanceScale = 1f,
		distanceOffset = 0f
	};
}


using UnityEngine;

public class QueryVis : BaseMonoBehaviour, IClientComponent
{
	public Collider checkCollider;

	private CoverageQueries.Query query;

	public CoverageQueries.RadiusSpace coverageRadiusSpace = CoverageQueries.RadiusSpace.World;

	public float coverageRadius = 0.2f;
}


using Unity.Burst;

[BurstCompile]
public class QueryVisJobRunner : BaseMonoBehaviour, IClientComponent
{
}


internal interface IRagdollInhert
{
}


using UnityEngine;

public class RotateToCamera : MonoBehaviour, IClientComponent
{
	public float maxDistance = 30f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public abstract class RustCamera<T> : SingletonComponent<T> where T : RustCamera<T>
{
	[SerializeField]
	private AmplifyOcclusionEffect ssao;

	[SerializeField]
	private SEScreenSpaceShadows contactShadows;

	[SerializeField]
	private VisualizeTexelDensity visualizeTexelDensity;

	[SerializeField]
	private EnvironmentVolumePropertiesCollection environmentVolumeProperties;

	[SerializeField]
	private PostProcessLayer post;

	[SerializeField]
	private PostProcessVolume baseEffectVolume;
}


using UnityEngine;

public class ScaleByIntensity : MonoBehaviour
{
	public Vector3 initialScale = Vector3.zero;

	public Light intensitySource;

	public float maxIntensity = 1f;

	private void Start()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		initialScale = ((Component)this).transform.localScale;
	}

	private void Update()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = (((Behaviour)intensitySource).enabled ? (initialScale * intensitySource.intensity / maxIntensity) : Vector3.zero);
	}
}


using UnityEngine;

public class ScaleBySpeed : MonoBehaviour, IClientComponent
{
	public float minScale = 0.001f;

	public float maxScale = 1f;

	public float minSpeed;

	public float maxSpeed = 1f;

	public MonoBehaviour component;

	public bool toggleComponent = true;

	public bool onlyWhenSubmerged;

	public float submergedThickness = 0.33f;

	private Vector3 prevPosition = Vector3.zero;
}


using System.Collections.Generic;

public class ScreenshotCamera : RustCamera<ScreenshotCamera>
{
	public static List<ScreenshotCamera> activeScreenshotCameras = new List<ScreenshotCamera>();
}


using Rust.UI;
using UnityEngine;

public class SearchFilterInput : MonoBehaviour
{
	public GameObject OpenRoot;

	public GameObject ClosedRoot;

	public RustInput InputField;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SkinnedMultiMesh : MonoBehaviour
{
	public struct Part
	{
		public Wearable wearable;

		public GameObject gameObject;

		public string name;

		public Item item;

		public Action<IItemSetup> partSetupCallback;
	}

	public bool shadowOnly;

	internal bool IsVisible = true;

	public bool eyesView;

	public Skeleton skeleton;

	public SkeletonSkinLod skeletonSkinLod;

	public List<Part> parts = new List<Part>();

	[NonSerialized]
	public List<Part> createdParts = new List<Part>();

	[NonSerialized]
	public long lastBuildHash;

	[NonSerialized]
	public MaterialPropertyBlock sharedPropertyBlock;

	[NonSerialized]
	public MaterialPropertyBlock hairPropertyBlock;

	public float skinNumber;

	public float meshNumber;

	public float hairNumber;

	public int skinType;

	public SkinSetCollection SkinCollection;

	public List<Renderer> Renderers { get; } = new List<Renderer>(32);
}


using System;
using UnityEngine;

public struct Part
{
	public Wearable wearable;

	public GameObject gameObject;

	public string name;

	public Item item;

	public Action<IItemSetup> partSetupCallback;
}


using UnityEngine;

public class StatusLightRenderer : MonoBehaviour, IClientComponent
{
	public Material offMaterial;

	public Material onMaterial;

	private MaterialPropertyBlock propertyBlock;

	private Renderer targetRenderer;

	private Color lightColor;

	private Light targetLight;

	private int colorID;

	private int emissionID;

	protected void Awake()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		propertyBlock = new MaterialPropertyBlock();
		targetRenderer = ((Component)this).GetComponent<Renderer>();
		targetLight = ((Component)this).GetComponent<Light>();
		colorID = Shader.PropertyToID("_Color");
		emissionID = Shader.PropertyToID("_EmissionColor");
	}

	public void SetOff()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)targetRenderer))
		{
			targetRenderer.sharedMaterial = offMaterial;
			targetRenderer.SetPropertyBlock((MaterialPropertyBlock)null);
		}
		if (Object.op_Implicit((Object)(object)targetLight))
		{
			targetLight.color = Color.clear;
		}
	}

	public void SetOn()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)targetRenderer))
		{
			targetRenderer.sharedMaterial = onMaterial;
			targetRenderer.SetPropertyBlock(propertyBlock);
		}
		if (Object.op_Implicit((Object)(object)targetLight))
		{
			targetLight.color = lightColor;
		}
	}

	public void SetRed()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		propertyBlock.Clear();
		propertyBlock.SetColor(colorID, GetColor(197, 46, 0, byte.MaxValue));
		propertyBlock.SetColor(emissionID, GetColor(191, 0, 2, byte.MaxValue, 2.916925f));
		lightColor = GetColor(byte.MaxValue, 111, 102, byte.MaxValue);
		SetOn();
	}

	public void SetGreen()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		propertyBlock.Clear();
		propertyBlock.SetColor(colorID, GetColor(19, 191, 13, byte.MaxValue));
		propertyBlock.SetColor(emissionID, GetColor(19, 191, 13, byte.MaxValue, 2.5f));
		lightColor = GetColor(156, byte.MaxValue, 102, byte.MaxValue);
		SetOn();
	}

	private Color GetColor(byte r, byte g, byte b, byte a)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return Color32.op_Implicit(new Color32(r, g, b, a));
	}

	private Color GetColor(byte r, byte g, byte b, byte a, float intensity)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return Color32.op_Implicit(new Color32(r, g, b, a)) * intensity;
	}
}


using ConVar;
using UnityEngine;

public class SunSettings : MonoBehaviour, IClientComponent
{
	private Light light;

	private void OnEnable()
	{
		light = ((Component)this).GetComponent<Light>();
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		LightShadows val = (LightShadows)Mathf.Clamp(Graphics.shadowmode, 1, 2);
		if (light.shadows != val)
		{
			light.shadows = val;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class TextureColorPicker : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IDragHandler
{
	[Serializable]
	public class onColorSelectedEvent : UnityEvent<Color>
	{
	}

	public Texture2D texture;

	public onColorSelectedEvent onColorSelected = new onColorSelectedEvent();

	public virtual void OnPointerDown(PointerEventData eventData)
	{
		OnDrag(eventData);
	}

	public virtual void OnDrag(PointerEventData eventData)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		Vector2 val2 = default(Vector2);
		if (RectTransformUtility.ScreenPointToLocalPointInRectangle(val, eventData.position, eventData.pressEventCamera, ref val2))
		{
			ref float x = ref val2.x;
			float num = x;
			Rect rect = val.rect;
			x = num + ((Rect)(ref rect)).width * val.pivot.x;
			ref float y = ref val2.y;
			float num2 = y;
			rect = val.rect;
			y = num2 + ((Rect)(ref rect)).height * val.pivot.y;
			ref float x2 = ref val2.x;
			float num3 = x2;
			rect = val.rect;
			x2 = num3 / ((Rect)(ref rect)).width;
			ref float y2 = ref val2.y;
			float num4 = y2;
			rect = val.rect;
			y2 = num4 / ((Rect)(ref rect)).height;
			Color pixel = texture.GetPixel((int)(val2.x * (float)((Texture)texture).width), (int)(val2.y * (float)((Texture)texture).height));
			((UnityEvent<Color>)onColorSelected).Invoke(pixel);
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Events;

[Serializable]
public class onColorSelectedEvent : UnityEvent<Color>
{
}


using UnityEngine;

public class TimedRemoval : MonoBehaviour
{
	public Object objectToDestroy;

	public float removeDelay = 1f;

	private void OnEnable()
	{
		Object.Destroy(objectToDestroy, removeDelay);
	}
}


using System;
using Facepunch;
using UnityEngine;

[Serializable]
public class TokenisedPhrase : Phrase
{
	public static readonly Phrase LeftMouse = new Phrase("button.mouse.left", "Left Mouse");

	public static readonly Phrase RightMouse = new Phrase("button.mouse.right", "Right Mouse");

	public static readonly Phrase MiddleMouse = new Phrase("button.mouse.middle", "Middle Mouse");

	public override string translated => ReplaceTokens(((Phrase)this).translated);

	public static string ReplaceTokens(string str)
	{
		if (!str.Contains("["))
		{
			return str;
		}
		str = str.Replace("[inventory.toggle]", string.Format("[{0}]", Input.GetButtonWithBind("inventory.toggle", false).ToUpper()));
		str = str.Replace("[inventory.togglecrafting]", string.Format("[{0}]", Input.GetButtonWithBind("inventory.togglecrafting", false).ToUpper()));
		str = str.Replace("[+map]", string.Format("[{0}]", Input.GetButtonWithBind("+map", false).ToUpper()));
		str = str.Replace("[inventory.examineheld]", string.Format("[{0}]", Input.GetButtonWithBind("inventory.examineheld", false).ToUpper()));
		str = str.Replace("[slot2]", string.Format("[{0}]", Input.GetButtonWithBind("+slot2", false).ToUpper()));
		str = str.Replace("[attack]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+attack", true)).ToUpper()));
		str = str.Replace("[attack2]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+attack2", false)).ToUpper()));
		str = str.Replace("[attack3]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+attack3", false)).ToUpper()));
		str = str.Replace("[+use]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+use", false)).ToUpper()));
		str = str.Replace("[+altlook]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+altlook", false)).ToUpper()));
		str = str.Replace("[+reload]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+reload", false)).ToUpper()));
		str = str.Replace("[+voice]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+voice", false)).ToUpper()));
		str = str.Replace("[+lockBreakHealthPercent]", $"{0.2f:0%}");
		str = str.Replace("[+gestures]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+gestures", false)).ToUpper()));
		str = str.Replace("[+left]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+left", false)).ToUpper()));
		str = str.Replace("[+right]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+right", false)).ToUpper()));
		str = str.Replace("[+backward]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+backward", false)).ToUpper()));
		str = str.Replace("[+forward]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+forward", false)).ToUpper()));
		str = str.Replace("[+sprint]", string.Format("[{0}]", Input.GetButtonWithBind("+sprint", false)).ToUpper());
		str = str.Replace("[+duck]", string.Format("[{0}]", Input.GetButtonWithBind("+duck", false)).ToUpper());
		str = str.Replace("[+pets]", string.Format("[{0}]", Input.GetButtonWithBind("+pets", false)).ToUpper());
		str = str.Replace("[lighttoggle]", string.Format("[{0}]", Input.GetButtonWithBind("lighttoggle", false)).ToUpper());
		str = str.Replace("[+ping]", string.Format("[{0}]", Input.GetButtonWithBind("+ping", false)).ToUpper());
		str = str.Replace("[clan.toggleclan]", string.Format("[{0}]", Input.GetButtonWithBind("clan.toggleclan", false)).ToUpper());
		str = str.Replace("[+jump]", string.Format("[{0}]", Input.GetButtonWithBind("+jump", false)).ToUpper());
		str = str.Replace("[movement]", ("[" + TranslateMouseButton(Input.GetButtonWithBind("+forward", false)) + TranslateMouseButton(Input.GetButtonWithBind("+left", false)) + TranslateMouseButton(Input.GetButtonWithBind("+backward", false)) + TranslateMouseButton(Input.GetButtonWithBind("+right", false)) + "]").ToUpper());
		str = str.Replace("[+help]", string.Format("[{0}]", Input.GetButtonWithBind("+opentutorialhelp", false)).ToUpper());
		str = str.Replace("[chat.open]", string.Format("[{0}]", Input.GetButtonWithBind("chat.open", false)).ToUpper());
		return str;
	}

	public TokenisedPhrase(string t = "", string eng = "")
		: base(t, eng)
	{
	}

	public static string TranslateMouseButton(string mouseButton)
	{
		return mouseButton switch
		{
			"mouse0" => LeftMouse.translated, 
			"mouse1" => RightMouse.translated, 
			"mouse2" => MiddleMouse.translated, 
			_ => mouseButton, 
		};
	}

	private static string GetButtonWithBind(string s)
	{
		if (!Application.isPlaying)
		{
			switch (s)
			{
			case "inventory.toggle":
				return "tab";
			case "inventory.togglecrafting":
				return "q";
			case "+map":
				return "g";
			case "inventory.examineheld":
				return "n";
			case "+slot2":
				return "2";
			case "+attack":
				return "mouse0";
			case "+attack2":
				return "mouse1";
			case "+use":
				return "e";
			case "+altlook":
				return "leftalt";
			case "+reload":
				return "r";
			case "+voice":
				return "v";
			}
		}
		return Input.GetButtonWithBind(s, false);
	}
}


using UnityEngine;

public class TriggerMovement : TriggerBase, IClientComponent
{
	[Tooltip("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
	public Transform losEyes;

	public BaseEntity.MovementModify movementModify;
}


using UnityEngine;

public class TriggerVehicleDrag : TriggerBase, IServerComponent
{
	[Tooltip("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
	public Transform losEyes;

	public float vehicleDrag;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if ((Object)(object)losEyes != (Object)null)
		{
			if (entityContents != null && entityContents.Contains(baseEntity))
			{
				return ((Component)baseEntity).gameObject;
			}
			if (!baseEntity.IsVisible(((Component)losEyes).transform.position, baseEntity.CenterPoint()))
			{
				return null;
			}
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UnderwearIcon : MonoBehaviour, IClientComponent
{
	public Image icon;
}


using System;
using UnityEngine;

public class UnderwearSkinPicker : MonoBehaviour
{
	public GameObjectRef pickerIcon;

	public GameObject container;

	public Action skinChangedEvent;

	public Sprite defaultNudeIcon;

	public Sprite defaultIconMale;

	public Sprite defaultIconFemale;
}


using UnityEngine;

public class UnparentOnDestroy : MonoBehaviour, IOnParentDestroying
{
	public float destroyAfterSeconds = 1f;

	public void OnParentDestroying()
	{
		((Component)this).transform.parent = null;
		GameManager.Destroy(((Component)this).gameObject, (destroyAfterSeconds <= 0f) ? 1f : destroyAfterSeconds);
	}

	protected void OnValidate()
	{
		if (destroyAfterSeconds <= 0f)
		{
			destroyAfterSeconds = 1f;
		}
	}
}


using UnityEngine;

public class ViewModel : MonoBehaviour, IClientComponent
{
	public GameObjectRef viewModelPrefab;
}


using UnityEngine;

public class ViewmodelItem : MonoBehaviour
{
}


using System.Collections.Generic;
using UnityEngine;

public class ViewShake
{
	protected class ShakeParameters
	{
		public float endTime;

		public float duration;

		public float amplitude;

		public float frequency;

		public float nextShake;

		public float angle;

		public Vector3 offset;

		public bool infinite;
	}

	protected List<ShakeParameters> Entries = new List<ShakeParameters>();

	public Vector3 PositionOffset { get; protected set; }

	public Vector3 AnglesOffset { get; protected set; }

	public void AddShake(float amplitude, float frequency, float duration)
	{
		Entries.Add(new ShakeParameters
		{
			amplitude = amplitude,
			frequency = Mathf.Max(frequency, 0.01f),
			duration = duration,
			endTime = Time.time + duration,
			nextShake = 0f,
			angle = 0f,
			infinite = (duration <= 0f)
		});
	}

	public void Update()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		Vector3 zero = Vector3.zero;
		Entries.RemoveAll((ShakeParameters i) => !i.infinite && Time.time > i.endTime);
		foreach (ShakeParameters entry in Entries)
		{
			if (Time.time > entry.nextShake)
			{
				entry.nextShake = Time.time + 1f / entry.frequency;
				entry.offset = new Vector3(Random.Range(0f - entry.amplitude, entry.amplitude), Random.Range(0f - entry.amplitude, entry.amplitude), Random.Range(0f - entry.amplitude, entry.amplitude));
				entry.angle = Random.Range((0f - entry.amplitude) * 0.25f, entry.amplitude * 0.25f);
			}
			float num = 0f;
			float num2 = (entry.infinite ? 1f : ((entry.endTime - Time.time) / entry.duration));
			if (num2 != 0f)
			{
				num = entry.frequency / num2;
			}
			num2 *= num2;
			float num3 = Time.time * num;
			num2 *= Mathf.Sin(num3);
			val += entry.offset * num2;
			zero.z += entry.angle * num2;
			if (!entry.infinite)
			{
				entry.amplitude -= entry.amplitude * Time.deltaTime / (entry.duration * entry.frequency);
			}
		}
		PositionOffset = val * 0.01f;
		AnglesOffset = zero;
	}

	public void Stop()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Entries.Clear();
		PositionOffset = Vector3.zero;
		AnglesOffset = Vector3.zero;
	}
}


using UnityEngine;

protected class ShakeParameters
{
	public float endTime;

	public float duration;

	public float amplitude;

	public float frequency;

	public float nextShake;

	public float angle;

	public Vector3 offset;

	public bool infinite;
}


using UnityEngine;

[RequireComponent(typeof(Wearable))]
public class WearableHairCap : MonoBehaviour
{
	public HairType Type;

	[ColorUsage(false, true)]
	public Color BaseColor = Color.black;

	public Texture Mask;

	private static MaterialPropertyBlock block;

	private static int _HairBaseColorUV1 = Shader.PropertyToID("_HairBaseColorUV1");

	private static int _HairBaseColorUV2 = Shader.PropertyToID("_HairBaseColorUV2");

	private static int _HairPackedMapUV1 = Shader.PropertyToID("_HairPackedMapUV1");

	private static int _HairPackedMapUV2 = Shader.PropertyToID("_HairPackedMapUV2");

	public void ApplyHairCap(MaterialPropertyBlock block)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		if (Type == HairType.Head || Type == HairType.Armpit || Type == HairType.Pubic)
		{
			Texture texture = block.GetTexture(_HairPackedMapUV1);
			block.SetColor(_HairBaseColorUV1, ((Color)(ref BaseColor)).gamma);
			block.SetTexture(_HairPackedMapUV1, ((Object)(object)Mask != (Object)null) ? Mask : texture);
		}
		else if (Type == HairType.Facial)
		{
			Texture texture2 = block.GetTexture(_HairPackedMapUV2);
			block.SetColor(_HairBaseColorUV2, ((Color)(ref BaseColor)).gamma);
			block.SetTexture(_HairPackedMapUV2, ((Object)(object)Mask != (Object)null) ? Mask : texture2);
		}
	}
}


using UnityEngine;

public class BaseCollision : MonoBehaviour, IClientComponent
{
	public BaseEntity Owner;

	public Model model;
}


using System;
using UnityEngine;

[Obsolete]
public class ColliderBatch : MonoBehaviour, IEditorComponent
{
}


