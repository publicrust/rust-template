using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Spatial;
using UnityEngine;

public class NpcFireManager : SingletonComponent<NpcFireManager>, IServerComponent
{
	private const float maxFireMeleeAge = 1f;

	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private Grid<BaseEntity> fireGrid = new Grid<BaseEntity>(32, 8096f);

	private Dictionary<BaseEntity, double> recentFireMeleeEvents = new Dictionary<BaseEntity, double>();

	private double nextTickTime;

	public void Add(BaseEntity entity)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		fireGrid.Add(entity, ((Component)entity).transform.position.x, ((Component)entity).transform.position.z);
	}

	public void Move(BaseEntity entity)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFireManager.Move", 0);
		try
		{
			if (IsOnFire(entity))
			{
				Vector3 position = ((Component)entity).transform.position;
				fireGrid.Move(entity, position.x, position.z);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Remove(BaseEntity entity)
	{
		fireGrid.Remove(entity);
	}

	public void GetFiresAround(Vector3 position, float range, List<BaseEntity> results)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFireManager.GetFiresAround", 0);
		try
		{
			if (fireGrid == null)
			{
				return;
			}
			fireGrid.Query<BaseEntity>(position.x, position.z, range, results);
			for (int num = results.Count - 1; num >= 0; num--)
			{
				if (!results[num].IsValid())
				{
					if (AI.logIssues)
					{
						Debug.LogWarning((object)$"Removed null fire from results list near {position}, this is unusual as fires should be removed from the grid when destroyed.");
					}
					results.RemoveAt(num);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnReceivedSignalServer(BaseEntity entity, BaseEntity.Signal signal, string arg)
	{
		if (signal != 0)
		{
			return;
		}
		if (entity is HeldEntity heldEntity && IsOnFire(heldEntity))
		{
			BasePlayer ownerPlayer = heldEntity.GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				recentFireMeleeEvents[ownerPlayer] = Time.timeAsDouble;
			}
		}
		if (entity is BasePlayer basePlayer && IsOnFire(basePlayer.GetHeldEntity()) && (Object)(object)entity != (Object)null)
		{
			recentFireMeleeEvents[entity] = Time.timeAsDouble;
		}
	}

	public bool DidMeleeWithFireRecently(BaseEntity querier, BaseEntity target, out double meleeTime, float maxDistance = 10f)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFireManager.DidMeleeWithFireRecently", 0);
		try
		{
			if (recentFireMeleeEvents.TryGetValue(target, out var value) && Vector3.Distance(((Component)querier).transform.position, ((Component)target).transform.position) <= maxDistance)
			{
				meleeTime = value;
				return true;
			}
			meleeTime = 0.0;
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsOnFire(BaseEntity entity)
	{
		if (!entity.IsValid())
		{
			return false;
		}
		if (entity.IsOnFire())
		{
			return true;
		}
		if (entity is BaseOven baseOven && baseOven.IsOn() && baseOven.hasOpenFlame)
		{
			return true;
		}
		return false;
	}

	public void Tick()
	{
		if (Time.timeAsDouble < nextTickTime)
		{
			return;
		}
		nextTickTime = Time.timeAsDouble + (double)Random.Range(4f, 6f);
		TimeWarning val = TimeWarning.New("NpcFireManager.RemoveStaleEntries", 0);
		try
		{
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				foreach (var (baseEntity2, num2) in recentFireMeleeEvents)
				{
					if (!baseEntity2.IsValid() || Time.timeAsDouble - num2 > 1.0)
					{
						((List<BaseEntity>)(object)val2).Add(baseEntity2);
					}
				}
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					recentFireMeleeEvents.Remove(item);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Spatial;
using UnityEngine;

public class NpcFoodManager : SingletonComponent<NpcFoodManager>, IServerComponent
{
	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private Grid<BaseEntity> foodGrid = new Grid<BaseEntity>(32, 8096f);

	public bool Add(BaseEntity food)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (!IsFood(food))
		{
			return false;
		}
		if (!foodGrid.AddUnique(food, ((Component)food).transform.position.x, ((Component)food).transform.position.z))
		{
			if (AI.logIssues)
			{
				Debug.LogWarning((object)$"Failed to add food to grid: {food.ShortPrefabName}_{food.net.ID}");
			}
			return false;
		}
		return true;
	}

	public void Move(BaseEntity food)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFoodManager.Move", 0);
		try
		{
			if (IsFood(food))
			{
				Vector3 position = ((Component)food).transform.position;
				foodGrid.Move(food, position.x, position.z);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool Contains(BaseEntity food)
	{
		if (!IsFood(food))
		{
			return false;
		}
		return foodGrid.Contains(food);
	}

	public bool Remove(BaseEntity food)
	{
		if (!IsFood(food))
		{
			return false;
		}
		if (!foodGrid.Remove(food))
		{
			return false;
		}
		return true;
	}

	public void GetFoodAround(Vector3 position, float range, List<BaseEntity> results)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcFoodManager.GetFoodAround", 0);
		try
		{
			if (foodGrid != null)
			{
				foodGrid.Query<BaseEntity>(position.x, position.z, range, results);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsFood(BaseEntity entity)
	{
		if (entity is DroppedItem droppedItem)
		{
			if (droppedItem.item == null)
			{
				return false;
			}
			return droppedItem.item.info.Traits.HasFlag(BaseEntity.TraitFlag.Meat);
		}
		return entity is BaseCorpse;
	}

	public static bool IsFoodImmobile(BaseEntity entity)
	{
		if (entity is DroppedItem { IsSleeping: not false })
		{
			return true;
		}
		if (entity is BaseCorpse { IsSleeping: not false })
		{
			return true;
		}
		return false;
	}
}


public enum NpcNoiseIntensity
{
	None,
	Low,
	Medium,
	High
}


using Facepunch;
using UnityEngine;

public class NpcNoiseEvent : IPooled
{
	public BaseEntity Initiator;

	public Vector3 Position;

	public NpcNoiseIntensity Intensity;

	public double EventTime;

	public void EnterPool()
	{
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using Facepunch;
using Spatial;
using UnityEngine;

public class NpcNoiseManager : SingletonComponent<NpcNoiseManager>, IServerComponent
{
	private const float voiceChatEventMaxAge = 1f;

	private const float noiseMaxAge = 10f;

	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private ConcurrentDictionary<BasePlayer, double> recentVoiceChatEvents = new ConcurrentDictionary<BasePlayer, double>();

	private Grid<NpcNoiseEvent> noiseGrid = new Grid<NpcNoiseEvent>(32, 8096f);

	private Queue<NpcNoiseEvent> noises = new Queue<NpcNoiseEvent>();

	private double nextTickTime;

	public void AddNoise(BaseEntity initiator, Vector3 position, NpcNoiseIntensity intensity)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (!((FacepunchBehaviour)this).IsInvoking((Action)RemoveOldNoises))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)RemoveOldNoises, 0f, 0f);
		}
		NpcNoiseEvent npcNoiseEvent = Pool.Get<NpcNoiseEvent>();
		npcNoiseEvent.Initiator = initiator;
		npcNoiseEvent.Position = position;
		npcNoiseEvent.Intensity = intensity;
		npcNoiseEvent.EventTime = Time.timeAsDouble;
		noiseGrid.Add(npcNoiseEvent, npcNoiseEvent.Position.x, npcNoiseEvent.Position.z);
		noises.Enqueue(npcNoiseEvent);
	}

	private void RemoveOldNoises()
	{
		TimeWarning val = TimeWarning.New("RemoveOldNoises", 0);
		try
		{
			while (noises.Count > 0)
			{
				NpcNoiseEvent npcNoiseEvent = noises.Peek();
				if (Time.timeAsDouble - npcNoiseEvent.EventTime <= 10.0)
				{
					break;
				}
				noises.Dequeue();
				noiseGrid.Remove(npcNoiseEvent);
				Pool.Free<NpcNoiseEvent>(ref npcNoiseEvent);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetNoisesAround(Vector3 position, float range, List<NpcNoiseEvent> results)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (noiseGrid != null)
		{
			noiseGrid.Query<NpcNoiseEvent>(position.x, position.z, range, results);
		}
	}

	public void OnServerProjectileHit(BaseEntity entity, ServerProjectile projectile, RaycastHit hit)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		AddNoise(entity, ((Component)projectile).transform.position, NpcNoiseIntensity.High);
	}

	public void OnProjectileHit(BaseEntity entity, HitInfo hit)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		AddNoise(entity, hit.HitPositionWorld, (hit.Weapon is BowWeapon || hit.Weapon is BaseMelee) ? NpcNoiseIntensity.Medium : NpcNoiseIntensity.High);
	}

	public void OnWeaponShot(BasePlayer player, BaseProjectile weapon)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		AddNoise(player, ((Component)player).transform.position, (weapon is BowWeapon) ? NpcNoiseIntensity.Low : NpcNoiseIntensity.High);
	}

	public void OnWeaponThrown(BasePlayer player, BaseMelee weapon, bool canAiHearIt)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (canAiHearIt)
		{
			AddNoise(player, ((Component)player).transform.position, NpcNoiseIntensity.Low);
		}
	}

	public void OnVoiceChat(BasePlayer player)
	{
		recentVoiceChatEvents[player] = Time.timeAsDouble;
	}

	public void OnMeleeHit(BaseMelee weapon, HitInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = weapon.GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			AddNoise(ownerPlayer, ((Component)ownerPlayer).transform.position, NpcNoiseIntensity.Medium);
		}
	}

	public bool HasPlayerSpokenNear(BaseEntity querier, BasePlayer targetPlayer, float maxDistance = 16f)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcNoiseManager.HasPlayerSpokenNear", 0);
		try
		{
			double value;
			return recentVoiceChatEvents.TryGetValue(targetPlayer, out value) && Vector3.Distance(((Component)querier).transform.position, ((Component)targetPlayer).transform.position) <= maxDistance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Tick()
	{
		if (Time.timeAsDouble < nextTickTime)
		{
			return;
		}
		nextTickTime = Time.timeAsDouble + (double)Random.Range(4f, 6f);
		TimeWarning val = TimeWarning.New("NpcNoiseManager.RemoveStaleEntries", 0);
		try
		{
			PooledList<BasePlayer> val2 = Pool.Get<PooledList<BasePlayer>>();
			try
			{
				double value;
				foreach (KeyValuePair<BasePlayer, double> recentVoiceChatEvent in recentVoiceChatEvents)
				{
					recentVoiceChatEvent.Deconstruct(out var key, out value);
					BasePlayer basePlayer = key;
					double num = value;
					if (!basePlayer.IsValid() || Time.timeAsDouble - num > 1.0)
					{
						((List<BasePlayer>)(object)val2).Add(basePlayer);
					}
				}
				foreach (BasePlayer item in (List<BasePlayer>)(object)val2)
				{
					recentVoiceChatEvents.Remove(item, out value);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Rust;
using Rust.Ai;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class DungeonNavmesh : FacepunchBehaviour, IServerComponent
{
	public int NavMeshAgentTypeIndex;

	[Tooltip("The default area associated with the NavMeshAgent index.")]
	public string DefaultAreaName = "HumanNPC";

	public float NavmeshResolutionModifier = 1.25f;

	[Tooltip("Bounds which are auto calculated from CellSize * CellCount")]
	public Bounds Bounds;

	public NavMeshData NavMeshData;

	public NavMeshDataInstance NavMeshDataInstance;

	public LayerMask LayerMask;

	public NavMeshCollectGeometry NavMeshCollectGeometry;

	public static List<DungeonNavmesh> Instances = new List<DungeonNavmesh>();

	[ServerVar]
	public static bool use_baked_terrain_mesh = true;

	private List<NavMeshBuildSource> sources;

	private AsyncOperation BuildingOperation;

	private bool HasBuildOperationStarted;

	private Stopwatch BuildTimer = new Stopwatch();

	private int defaultArea;

	private int agentTypeId;

	public bool IsBuilding
	{
		get
		{
			if (!HasBuildOperationStarted || BuildingOperation != null)
			{
				return true;
			}
			return false;
		}
	}

	public static bool NavReady()
	{
		if (Instances == null || Instances.Count == 0)
		{
			return true;
		}
		foreach (DungeonNavmesh instance in Instances)
		{
			if (instance.IsBuilding)
			{
				return false;
			}
		}
		return true;
	}

	private void OnEnable()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
		agentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		NavMeshData = new NavMeshData(agentTypeId);
		sources = new List<NavMeshBuildSource>();
		defaultArea = NavMesh.GetAreaFromName(DefaultAreaName);
		((FacepunchBehaviour)this).InvokeRepeating((Action)FinishBuildingNavmesh, 0f, 1f);
		Instances.Add(this);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FinishBuildingNavmesh);
			((NavMeshDataInstance)(ref NavMeshDataInstance)).Remove();
			Instances.Remove(this);
		}
	}

	[ContextMenu("Update Monument Nav Mesh")]
	public void UpdateNavMeshAsync()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (!HasBuildOperationStarted && !AiManager.nav_disable && AI.npc_enable)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			Debug.Log((object)("Starting Dungeon Navmesh Build with " + sources.Count + " sources"));
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
			((NavMeshBuildSettings)(ref settingsByIndex)).overrideVoxelSize = true;
			((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize = ((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize * NavmeshResolutionModifier;
			BuildingOperation = NavMeshBuilder.UpdateNavMeshDataAsync(NavMeshData, settingsByIndex, sources, Bounds);
			BuildTimer.Reset();
			BuildTimer.Start();
			HasBuildOperationStarted = true;
			float num = Time.realtimeSinceStartup - realtimeSinceStartup;
			if (num > 0.1f)
			{
				Debug.LogWarning((object)("Calling UpdateNavMesh took " + num));
			}
			NotifyInformationZonesOfCompletion();
		}
	}

	public void NotifyInformationZonesOfCompletion()
	{
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			zone.NavmeshBuildingComplete();
		}
	}

	public void SourcesCollected()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		int count = sources.Count;
		Debug.Log((object)("Source count Pre cull : " + sources.Count));
		Vector3 val = default(Vector3);
		for (int num = sources.Count - 1; num >= 0; num--)
		{
			NavMeshBuildSource item = sources[num];
			Matrix4x4 transform = ((NavMeshBuildSource)(ref item)).transform;
			((Vector3)(ref val))..ctor(((Matrix4x4)(ref transform))[0, 3], ((Matrix4x4)(ref transform))[1, 3], ((Matrix4x4)(ref transform))[2, 3]);
			bool flag = false;
			foreach (AIInformationZone zone in AIInformationZone.zones)
			{
				if (Vector3Ex.Distance2D(zone.ClosestPointTo(val), val) <= 50f)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				sources.Remove(item);
			}
		}
		Debug.Log((object)("Source count post cull : " + sources.Count + " total removed : " + (count - sources.Count)));
	}

	public IEnumerator UpdateNavMeshAndWait()
	{
		if (HasBuildOperationStarted || AiManager.nav_disable || !AI.npc_enable)
		{
			yield break;
		}
		HasBuildOperationStarted = false;
		((Bounds)(ref Bounds)).center = ((Component)this).transform.position;
		((Bounds)(ref Bounds)).size = new Vector3(1000000f, 100000f, 100000f);
		IEnumerator enumerator = NavMeshTools.CollectSourcesAsync(((Component)this).transform, ((LayerMask)(ref LayerMask)).value, NavMeshCollectGeometry, defaultArea, sources, AppendModifierVolumes, UpdateNavMeshAsync);
		if (AiManager.nav_wait)
		{
			yield return enumerator;
		}
		else
		{
			((MonoBehaviour)this).StartCoroutine(enumerator);
		}
		if (!AiManager.nav_wait)
		{
			Debug.Log((object)"nav_wait is false, so we're not waiting for the navmesh to finish generating. This might cause your server to sputter while it's generating.");
			yield break;
		}
		int lastPct = 0;
		while (!HasBuildOperationStarted)
		{
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
		}
		while (BuildingOperation != null)
		{
			int num = (int)(BuildingOperation.progress * 100f);
			if (lastPct != num)
			{
				Debug.LogFormat("{0}%", new object[1] { num });
				lastPct = num;
			}
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
			FinishBuildingNavmesh();
		}
	}

	private void AppendModifierVolumes(List<NavMeshBuildSource> sources)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		Vector3 size = default(Vector3);
		foreach (NavMeshModifierVolume activeModifier in NavMeshModifierVolume.activeModifiers)
		{
			if ((LayerMask.op_Implicit(LayerMask) & (1 << ((Component)activeModifier).gameObject.layer)) != 0 && activeModifier.AffectsAgentType(agentTypeId))
			{
				Vector3 val = ((Component)activeModifier).transform.TransformPoint(activeModifier.center);
				if (((Bounds)(ref Bounds)).Contains(val))
				{
					Vector3 lossyScale = ((Component)activeModifier).transform.lossyScale;
					((Vector3)(ref size))..ctor(activeModifier.size.x * Mathf.Abs(lossyScale.x), activeModifier.size.y * Mathf.Abs(lossyScale.y), activeModifier.size.z * Mathf.Abs(lossyScale.z));
					NavMeshBuildSource item = default(NavMeshBuildSource);
					((NavMeshBuildSource)(ref item)).shape = (NavMeshBuildSourceShape)5;
					((NavMeshBuildSource)(ref item)).transform = Matrix4x4.TRS(val, ((Component)activeModifier).transform.rotation, Vector3.one);
					((NavMeshBuildSource)(ref item)).size = size;
					((NavMeshBuildSource)(ref item)).area = activeModifier.area;
					sources.Add(item);
				}
			}
		}
	}

	public void FinishBuildingNavmesh()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (BuildingOperation != null && BuildingOperation.isDone)
		{
			if (!((NavMeshDataInstance)(ref NavMeshDataInstance)).valid)
			{
				NavMeshDataInstance = NavMesh.AddNavMeshData(NavMeshData);
			}
			Debug.Log((object)$"Monument Navmesh Build took {BuildTimer.Elapsed.TotalSeconds:0.00} seconds");
			BuildingOperation = null;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using Rust;
using Rust.Ai;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class DynamicNavMesh : SingletonComponent<DynamicNavMesh>, IServerComponent
{
	public int NavMeshAgentTypeIndex;

	[Tooltip("The default area associated with the NavMeshAgent index.")]
	public string DefaultAreaName = "Walkable";

	public int AsyncTerrainNavMeshBakeCellSize = 80;

	public int AsyncTerrainNavMeshBakeCellHeight = 100;

	public Bounds Bounds;

	public NavMeshData NavMeshData;

	public NavMeshDataInstance NavMeshDataInstance;

	public LayerMask LayerMask;

	public NavMeshCollectGeometry NavMeshCollectGeometry;

	[ServerVar]
	public static bool use_baked_terrain_mesh;

	private List<NavMeshBuildSource> sources;

	private AsyncOperation BuildingOperation;

	private bool HasBuildOperationStarted;

	private Stopwatch BuildTimer = new Stopwatch();

	private int defaultArea;

	private int agentTypeId;

	public bool IsBuilding
	{
		get
		{
			if (!HasBuildOperationStarted || BuildingOperation != null)
			{
				return true;
			}
			return false;
		}
	}

	private void OnEnable()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
		agentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		NavMeshData = new NavMeshData(agentTypeId);
		sources = new List<NavMeshBuildSource>();
		defaultArea = NavMesh.GetAreaFromName(DefaultAreaName);
		((FacepunchBehaviour)this).InvokeRepeating((Action)FinishBuildingNavmesh, 0f, 1f);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FinishBuildingNavmesh);
			((NavMeshDataInstance)(ref NavMeshDataInstance)).Remove();
		}
	}

	[ContextMenu("Update Nav Mesh")]
	public void UpdateNavMeshAsync()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		if (!HasBuildOperationStarted && !AiManager.nav_disable)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			Debug.Log((object)("Starting Navmesh Build with " + sources.Count + " sources"));
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
			((NavMeshBuildSettings)(ref settingsByIndex)).overrideVoxelSize = true;
			((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize = ((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize * 2f;
			BuildingOperation = NavMeshBuilder.UpdateNavMeshDataAsync(NavMeshData, settingsByIndex, sources, Bounds);
			BuildTimer.Reset();
			BuildTimer.Start();
			HasBuildOperationStarted = true;
			float num = Time.realtimeSinceStartup - realtimeSinceStartup;
			if (num > 0.1f)
			{
				Debug.LogWarning((object)("Calling UpdateNavMesh took " + num));
			}
		}
	}

	public IEnumerator UpdateNavMeshAndWait()
	{
		if (HasBuildOperationStarted || AiManager.nav_disable)
		{
			yield break;
		}
		HasBuildOperationStarted = false;
		((Bounds)(ref Bounds)).size = TerrainMeta.Size;
		NavMesh.pathfindingIterationsPerFrame = AiManager.pathfindingIterationsPerFrame;
		IEnumerator enumerator = NavMeshTools.CollectSourcesAsync(Bounds, LayerMask.op_Implicit(LayerMask), NavMeshCollectGeometry, defaultArea, use_baked_terrain_mesh, AsyncTerrainNavMeshBakeCellSize, sources, AppendModifierVolumes, UpdateNavMeshAsync, null);
		if (AiManager.nav_wait)
		{
			yield return enumerator;
		}
		else
		{
			((MonoBehaviour)this).StartCoroutine(enumerator);
		}
		if (!AiManager.nav_wait)
		{
			Debug.Log((object)"nav_wait is false, so we're not waiting for the navmesh to finish generating. This might cause your server to sputter while it's generating.");
			yield break;
		}
		int lastPct = 0;
		while (!HasBuildOperationStarted)
		{
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
		}
		while (BuildingOperation != null)
		{
			int num = (int)(BuildingOperation.progress * 100f);
			if (lastPct != num)
			{
				Debug.LogFormat("{0}%", new object[1] { num });
				lastPct = num;
			}
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
			FinishBuildingNavmesh();
		}
	}

	private void AppendModifierVolumes(List<NavMeshBuildSource> sources)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 size = default(Vector3);
		foreach (NavMeshModifierVolume activeModifier in NavMeshModifierVolume.activeModifiers)
		{
			if ((LayerMask.op_Implicit(LayerMask) & (1 << ((Component)activeModifier).gameObject.layer)) != 0 && activeModifier.AffectsAgentType(agentTypeId))
			{
				Vector3 val = ((Component)activeModifier).transform.TransformPoint(activeModifier.center);
				Vector3 lossyScale = ((Component)activeModifier).transform.lossyScale;
				((Vector3)(ref size))..ctor(activeModifier.size.x * Mathf.Abs(lossyScale.x), activeModifier.size.y * Mathf.Abs(lossyScale.y), activeModifier.size.z * Mathf.Abs(lossyScale.z));
				NavMeshBuildSource item = default(NavMeshBuildSource);
				((NavMeshBuildSource)(ref item)).shape = (NavMeshBuildSourceShape)5;
				((NavMeshBuildSource)(ref item)).transform = Matrix4x4.TRS(val, ((Component)activeModifier).transform.rotation, Vector3.one);
				((NavMeshBuildSource)(ref item)).size = size;
				((NavMeshBuildSource)(ref item)).area = activeModifier.area;
				sources.Add(item);
			}
		}
	}

	public void FinishBuildingNavmesh()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (BuildingOperation != null && BuildingOperation.isDone)
		{
			if (!((NavMeshDataInstance)(ref NavMeshDataInstance)).valid)
			{
				NavMeshDataInstance = NavMesh.AddNavMeshData(NavMeshData);
			}
			Debug.Log((object)$"Navmesh Build took {BuildTimer.Elapsed.TotalSeconds:0.00} seconds");
			BuildingOperation = null;
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class Eqs
{
	public class PooledScoreList : PooledList<(Vector3 pos, float score)>
	{
		public void SortByScoreDesc(BaseEntity baseEntity = null)
		{
			TimeWarning val = TimeWarning.New("SortByScoreDesc", 0);
			try
			{
				((List<(Vector3, float)>)(object)this).Sort((Comparison<(Vector3, float)>)(((Vector3 pos, float score) a, (Vector3 pos, float score) b) => b.score.CompareTo(a.score)));
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public void Reorder(List<Vector3> positions)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("Reorder", 0);
			try
			{
				for (int i = 0; i < positions.Count; i++)
				{
					positions[i] = ((List<(Vector3, float)>)(object)this)[i].Item1;
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static void SamplePositionsInDonutShape(Vector3 center, List<Vector3> sampledPositions, float radius = 10f, int numRings = 1, int itemsPerRing = 8)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePositionsInDonutShape", 0);
		try
		{
			for (int i = 0; i < itemsPerRing; i++)
			{
				float num = MathF.PI * 2f * (float)i / (float)itemsPerRing;
				Vector3 item = center + new Vector3(Mathf.Cos(num), 0f, Mathf.Sin(num)) * radius;
				sampledPositions.Add(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void SamplePositionsInMultiDonutShape(Vector3 center, List<Vector3> sampledPositions, float outerRadius = 10f, float innerRadius = 10f, int numRings = 1, int itemsPerRing = 8)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePositionsInMultiDonutShape", 0);
		try
		{
			for (int i = 0; i < numRings; i++)
			{
				float num = ((numRings != 1) ? Mathf.Lerp(innerRadius, outerRadius, (float)i / (float)(numRings - 1)) : outerRadius);
				for (int j = 0; j < itemsPerRing; j++)
				{
					float num2 = (float)i * MathF.PI / (float)numRings;
					float num3 = MathF.PI * 2f * (float)j / (float)itemsPerRing + num2;
					Vector3 item = center + new Vector3(Mathf.Cos(num3), 0f, Mathf.Sin(num3)) * num;
					sampledPositions.Add(item);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PooledScoreList : PooledList<(Vector3 pos, float score)>
{
	public void SortByScoreDesc(BaseEntity baseEntity = null)
	{
		TimeWarning val = TimeWarning.New("SortByScoreDesc", 0);
		try
		{
			((List<(Vector3, float)>)(object)this).Sort((Comparison<(Vector3, float)>)(((Vector3 pos, float score) a, (Vector3 pos, float score) b) => b.score.CompareTo(a.score)));
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Reorder(List<Vector3> positions)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Reorder", 0);
		try
		{
			for (int i = 0; i < positions.Count; i++)
			{
				positions[i] = ((List<(Vector3, float)>)(object)this)[i].Item1;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Rust;
using Rust.Ai;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class MonumentNavMesh : FacepunchBehaviour, IServerComponent
{
	public int NavMeshAgentTypeIndex;

	[Tooltip("The default area associated with the NavMeshAgent index.")]
	public string DefaultAreaName = "HumanNPC";

	[Tooltip("How many cells to use squared")]
	public int CellCount = 1;

	[Tooltip("The size of each cell for async object gathering")]
	public int CellSize = 80;

	public int Height = 100;

	public float NavmeshResolutionModifier = 0.5f;

	[Tooltip("Use the bounds specified in editor instead of generating it from cellsize * cellcount")]
	public bool overrideAutoBounds;

	[Tooltip("Bounds which are auto calculated from CellSize * CellCount")]
	public Bounds Bounds;

	public NavMeshData NavMeshData;

	public NavMeshDataInstance NavMeshDataInstance;

	public LayerMask LayerMask;

	public NavMeshCollectGeometry NavMeshCollectGeometry;

	public bool forceCollectTerrain;

	public bool shouldNotifyAIZones = true;

	public Transform CustomNavMeshRoot;

	public bool IgnoreTerrain;

	[ServerVar]
	public static bool use_baked_terrain_mesh = true;

	private List<NavMeshBuildSource> sources;

	private AsyncOperation BuildingOperation;

	private bool HasBuildOperationStarted;

	private Stopwatch BuildTimer = new Stopwatch();

	private int defaultArea;

	private int agentTypeId;

	public bool IsBuilding
	{
		get
		{
			if (!HasBuildOperationStarted || BuildingOperation != null)
			{
				return true;
			}
			return false;
		}
	}

	private void OnEnable()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
		agentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		NavMeshData = new NavMeshData(agentTypeId);
		sources = new List<NavMeshBuildSource>();
		defaultArea = NavMesh.GetAreaFromName(DefaultAreaName);
		((FacepunchBehaviour)this).InvokeRepeating((Action)FinishBuildingNavmesh, 0f, 1f);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FinishBuildingNavmesh);
			((NavMeshDataInstance)(ref NavMeshDataInstance)).Remove();
		}
	}

	[ContextMenu("Update Monument Nav Mesh")]
	public void UpdateNavMeshAsync()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (!HasBuildOperationStarted && !AiManager.nav_disable && AI.npc_enable)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			Debug.Log((object)("Starting Monument Navmesh Build with " + sources.Count + " sources"));
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
			((NavMeshBuildSettings)(ref settingsByIndex)).overrideVoxelSize = true;
			((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize = ((NavMeshBuildSettings)(ref settingsByIndex)).voxelSize * NavmeshResolutionModifier;
			BuildingOperation = NavMeshBuilder.UpdateNavMeshDataAsync(NavMeshData, settingsByIndex, sources, Bounds);
			BuildTimer.Reset();
			BuildTimer.Start();
			HasBuildOperationStarted = true;
			float num = Time.realtimeSinceStartup - realtimeSinceStartup;
			if (num > 0.1f)
			{
				Debug.LogWarning((object)("Calling UpdateNavMesh took " + num));
			}
			if (shouldNotifyAIZones)
			{
				NotifyInformationZonesOfCompletion();
			}
		}
	}

	public IEnumerator UpdateNavMeshAndWait()
	{
		if (HasBuildOperationStarted || AiManager.nav_disable || !AI.npc_enable)
		{
			yield break;
		}
		HasBuildOperationStarted = false;
		((Bounds)(ref Bounds)).center = ((Component)this).transform.position;
		if (!overrideAutoBounds)
		{
			((Bounds)(ref Bounds)).size = new Vector3((float)(CellSize * CellCount), (float)Height, (float)(CellSize * CellCount));
		}
		IEnumerator enumerator = NavMeshTools.CollectSourcesAsync(Bounds, LayerMask.op_Implicit(LayerMask), NavMeshCollectGeometry, defaultArea, use_baked_terrain_mesh && !forceCollectTerrain && !IgnoreTerrain, CellSize, sources, AppendModifierVolumes, UpdateNavMeshAsync, CustomNavMeshRoot);
		if (AiManager.nav_wait)
		{
			yield return enumerator;
		}
		else
		{
			((MonoBehaviour)this).StartCoroutine(enumerator);
		}
		if (!AiManager.nav_wait)
		{
			Debug.Log((object)"nav_wait is false, so we're not waiting for the navmesh to finish generating. This might cause your server to sputter while it's generating.");
			yield break;
		}
		int lastPct = 0;
		while (!HasBuildOperationStarted)
		{
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
		}
		while (BuildingOperation != null)
		{
			int num = (int)(BuildingOperation.progress * 100f);
			if (lastPct != num)
			{
				Debug.LogFormat("{0}%", new object[1] { num });
				lastPct = num;
			}
			yield return CoroutineEx.waitForSecondsRealtime(0.25f);
			FinishBuildingNavmesh();
		}
	}

	public void NotifyInformationZonesOfCompletion()
	{
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			zone.NavmeshBuildingComplete();
		}
	}

	private void AppendModifierVolumes(List<NavMeshBuildSource> sources)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		Vector3 size = default(Vector3);
		foreach (NavMeshModifierVolume activeModifier in NavMeshModifierVolume.activeModifiers)
		{
			if ((LayerMask.op_Implicit(LayerMask) & (1 << ((Component)activeModifier).gameObject.layer)) != 0 && activeModifier.AffectsAgentType(agentTypeId))
			{
				Vector3 val = ((Component)activeModifier).transform.TransformPoint(activeModifier.center);
				if (((Bounds)(ref Bounds)).Contains(val))
				{
					Vector3 lossyScale = ((Component)activeModifier).transform.lossyScale;
					((Vector3)(ref size))..ctor(activeModifier.size.x * Mathf.Abs(lossyScale.x), activeModifier.size.y * Mathf.Abs(lossyScale.y), activeModifier.size.z * Mathf.Abs(lossyScale.z));
					NavMeshBuildSource item = default(NavMeshBuildSource);
					((NavMeshBuildSource)(ref item)).shape = (NavMeshBuildSourceShape)5;
					((NavMeshBuildSource)(ref item)).transform = Matrix4x4.TRS(val, ((Component)activeModifier).transform.rotation, Vector3.one);
					((NavMeshBuildSource)(ref item)).size = size;
					((NavMeshBuildSource)(ref item)).area = activeModifier.area;
					sources.Add(item);
				}
			}
		}
	}

	public void FinishBuildingNavmesh()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (BuildingOperation != null && BuildingOperation.isDone)
		{
			if (!((NavMeshDataInstance)(ref NavMeshDataInstance)).valid)
			{
				NavMeshDataInstance = NavMesh.AddNavMeshData(NavMeshData);
			}
			Debug.Log((object)$"Monument Navmesh Build took {BuildTimer.Elapsed.TotalSeconds:0.00} seconds");
			BuildingOperation = null;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public static class NavMeshTools
{
	public static IEnumerator CollectSourcesAsync(Bounds bounds, int mask, NavMeshCollectGeometry geometry, int area, bool useBakedTerrainMesh, int cellSize, List<NavMeshBuildSource> sources, Action<List<NavMeshBuildSource>> append, Action callback, Transform customNavMeshDataRoot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		while (!AI.move && !AiManager.nav_wait)
		{
			yield return CoroutineEx.waitForSeconds(1f);
		}
		if ((Object)(object)customNavMeshDataRoot != (Object)null)
		{
			((Component)customNavMeshDataRoot).gameObject.SetActive(true);
			yield return (object)new WaitForEndOfFrame();
		}
		float time = Time.realtimeSinceStartup;
		Debug.Log((object)"Starting Navmesh Source Collecting");
		mask = ((!useBakedTerrainMesh) ? (mask | 0x800000) : (mask & -8388609));
		List<NavMeshBuildMarkup> list = new List<NavMeshBuildMarkup>();
		NavMeshBuilder.CollectSources(bounds, mask, geometry, area, list, sources);
		if (useBakedTerrainMesh && (Object)(object)TerrainMeta.HeightMap != (Object)null)
		{
			for (float x = 0f - ((Bounds)(ref bounds)).extents.x; x < ((Bounds)(ref bounds)).extents.x - (float)(cellSize / 2); x += (float)cellSize)
			{
				for (float z = 0f - ((Bounds)(ref bounds)).extents.z; z < ((Bounds)(ref bounds)).extents.z - (float)(cellSize / 2); z += (float)cellSize)
				{
					AsyncTerrainNavMeshBake terrainSource = new AsyncTerrainNavMeshBake(new Vector3(x, 0f, z), cellSize, cellSize, normal: false, alpha: true);
					yield return terrainSource;
					sources.Add(terrainSource.CreateNavMeshBuildSource(area));
				}
			}
		}
		append?.Invoke(sources);
		Debug.Log((object)$"Navmesh Source Collecting took {Time.realtimeSinceStartup - time:0.00} seconds");
		if ((Object)(object)customNavMeshDataRoot != (Object)null)
		{
			((Component)customNavMeshDataRoot).gameObject.SetActive(false);
		}
		callback?.Invoke();
	}

	public static IEnumerator CollectSourcesAsync(Transform root, int mask, NavMeshCollectGeometry geometry, int area, List<NavMeshBuildSource> sources, Action<List<NavMeshBuildSource>> append, Action callback)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		while (!AI.move && !AiManager.nav_wait)
		{
			yield return CoroutineEx.waitForSeconds(1f);
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log((object)"Starting Navmesh Source Collecting");
		List<NavMeshBuildMarkup> list = new List<NavMeshBuildMarkup>();
		NavMeshBuilder.CollectSources(root, mask, geometry, area, list, sources);
		append?.Invoke(sources);
		Debug.Log((object)$"Navmesh Source Collecting took {Time.realtimeSinceStartup - realtimeSinceStartup:0.00} seconds");
		callback?.Invoke();
	}
}


using ConVar;
using UnityEngine;

public class NPCBarricadeTriggerBox : MonoBehaviour
{
	private Barricade target;

	private static int playerServerLayer = -1;

	public void Setup(Barricade t)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		target = t;
		((Component)this).transform.SetParent(((Component)target).transform, false);
		((Component)this).gameObject.layer = 18;
		BoxCollider obj = ((Component)this).gameObject.AddComponent<BoxCollider>();
		((Collider)obj).isTrigger = true;
		obj.center = Vector3.zero;
		obj.size = Vector3.one * AI.npc_door_trigger_size + Vector3.right * ((Bounds)(ref target.bounds)).size.x;
	}

	private void OnTriggerEnter(Collider other)
	{
		if ((Object)(object)target == (Object)null || target.isClient)
		{
			return;
		}
		if (playerServerLayer < 0)
		{
			playerServerLayer = LayerMask.NameToLayer("Player (Server)");
		}
		if ((((Component)other).gameObject.layer & playerServerLayer) > 0)
		{
			BasePlayer component = ((Component)other).gameObject.GetComponent<BasePlayer>();
			if ((Object)(object)component != (Object)null && component.IsNpc && !(component is BasePet))
			{
				target.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}
}


using ConVar;
using UnityEngine;

public class NPCDoorTriggerBox : MonoBehaviour
{
	private Door door;

	private static int playerServerLayer = -1;

	public void Setup(Door d)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		door = d;
		((Component)this).transform.SetParent(((Component)door).transform, false);
		((Component)this).gameObject.layer = 18;
		BoxCollider obj = ((Component)this).gameObject.AddComponent<BoxCollider>();
		((Collider)obj).isTrigger = true;
		obj.center = Vector3.zero;
		obj.size = Vector3.one * AI.npc_door_trigger_size;
	}

	private void OnTriggerEnter(Collider other)
	{
		if ((Object)(object)door == (Object)null || door.isClient || door.IsLocked() || (!door.isSecurityDoor && door.IsOpen()) || (door.isSecurityDoor && !door.IsOpen()))
		{
			return;
		}
		if (playerServerLayer < 0)
		{
			playerServerLayer = LayerMask.NameToLayer("Player (Server)");
		}
		if ((((Component)other).gameObject.layer & playerServerLayer) > 0)
		{
			BasePlayer component = ((Component)other).gameObject.GetComponent<BasePlayer>();
			if ((Object)(object)component != (Object)null && component.IsNpc && !door.isSecurityDoor)
			{
				door.SetOpen(open: true);
			}
		}
	}
}


using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class RealmedNavMeshObstacle : BasePrefab
{
	public NavMeshObstacle Obstacle;

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (bundling)
		{
			return;
		}
		base.PreProcess(process, rootObj, name, serverside, clientside, bundling: false);
		if (base.isServer && Object.op_Implicit((Object)(object)Obstacle))
		{
			if (AiManager.nav_disable)
			{
				process.RemoveComponent((Component)(object)Obstacle);
				Obstacle = null;
			}
			else if (AiManager.nav_obstacles_carve_state >= 2)
			{
				Obstacle.carving = true;
			}
			else if (AiManager.nav_obstacles_carve_state == 1)
			{
				Obstacle.carving = ((Component)Obstacle).gameObject.layer == 21;
			}
			else
			{
				Obstacle.carving = false;
			}
		}
		process.RemoveComponent((Component)(object)this);
	}
}


using System;
using UnityEngine;

public class BaseAnimalNPC : BaseNpc, IAIAttack, IAITirednessAbove, IAISleep, IAIHungerAbove, IAISenses, IThinker
{
	public string deathStatName = "";

	public AnimalBrain brain;

	private TimeSince lastBrainError;

	public override void ServerInit()
	{
		base.ServerInit();
		brain = ((Component)this).GetComponent<AnimalBrain>();
		if (!base.isClient)
		{
			AIThinkManager.AddAnimal(this);
		}
	}

	internal override void DoServerDestroy()
	{
		if (!base.isClient)
		{
			AIThinkManager.RemoveAnimal(this);
			base.DoServerDestroy();
		}
	}

	public virtual void TryThink()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)brain != (Object)null && HasBrain && brain.ShouldServerThink())
		{
			brain.DoThink();
		}
		else if ((Object)(object)brain == (Object)null && TimeSince.op_Implicit(lastBrainError) > 10f)
		{
			lastBrainError = TimeSince.op_Implicit(0f);
			Debug.LogWarning((object)(((Object)((Component)this).gameObject).name + " is missing a brain"));
		}
	}

	public override void OnDied(HitInfo hitInfo = null)
	{
		if (hitInfo != null)
		{
			BasePlayer initiatorPlayer = hitInfo.InitiatorPlayer;
			if ((Object)(object)initiatorPlayer != (Object)null)
			{
				initiatorPlayer.GiveAchievement("KILL_ANIMAL");
				if (!string.IsNullOrEmpty(deathStatName))
				{
					initiatorPlayer.stats.Add(deathStatName, 1, (Stats)5);
					initiatorPlayer.stats.Save();
				}
				initiatorPlayer.LifeStoryKill(this);
			}
		}
		base.OnDied((HitInfo)null);
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer && Object.op_Implicit((Object)(object)info.InitiatorPlayer) && !info.damageTypes.IsMeleeType())
		{
			info.InitiatorPlayer.LifeStoryShotHit(info.Weapon);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Kill();
	}

	public bool CanAttack(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (NeedsToReload())
		{
			return false;
		}
		if (IsOnCooldown())
		{
			return false;
		}
		if (!IsTargetInRange(entity, out var _))
		{
			return false;
		}
		if (!CanSeeTarget(entity))
		{
			return false;
		}
		BasePlayer basePlayer = entity as BasePlayer;
		BaseVehicle baseVehicle = (((Object)(object)basePlayer != (Object)null) ? basePlayer.GetMountedVehicle() : null);
		if ((Object)(object)baseVehicle != (Object)null && baseVehicle is BaseModularVehicle)
		{
			return false;
		}
		return true;
	}

	public bool NeedsToReload()
	{
		return false;
	}

	public float EngagementRange()
	{
		return AttackRange * brain.AttackRangeMultiplier;
	}

	public bool IsTargetInRange(BaseEntity entity, out float dist)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		dist = Vector3.Distance(((Component)entity).transform.position, base.AttackPosition);
		return dist <= EngagementRange();
	}

	public bool CanSeeTarget(BaseEntity entity)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.IsVisible(GetEntity().CenterPoint(), entity.CenterPoint());
	}

	public bool Reload()
	{
		throw new NotImplementedException();
	}

	public bool StartAttacking(BaseEntity target)
	{
		BaseCombatEntity baseCombatEntity = target as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity == (Object)null)
		{
			return false;
		}
		Attack(baseCombatEntity);
		return true;
	}

	public void StopAttacking()
	{
	}

	public float CooldownDuration()
	{
		return AttackRate;
	}

	public bool IsOnCooldown()
	{
		return !AttackReady();
	}

	public bool IsTirednessAbove(float value)
	{
		return 1f - Sleep > value;
	}

	public void StartSleeping()
	{
		SetFact(Facts.IsSleeping, 1);
	}

	public void StopSleeping()
	{
		SetFact(Facts.IsSleeping, 0);
	}

	public bool IsHungerAbove(float value)
	{
		return 1f - Energy.Level > value;
	}

	public bool IsThreat(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null)
		{
			if (baseNpc.Stats.Family == Stats.Family)
			{
				return false;
			}
			return IsAfraidOf(baseNpc.Stats.Family);
		}
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			return IsAfraidOf(basePlayer.Family);
		}
		return false;
	}

	public bool IsTarget(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null && baseNpc.Stats.Family == Stats.Family)
		{
			return false;
		}
		return !IsThreat(entity);
	}

	public bool IsFriendly(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.prefabID == prefabID;
	}

	public float GetAmmoFraction()
	{
		return 1f;
	}

	public BaseEntity GetBestTarget()
	{
		return null;
	}

	public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
	{
	}
}


using UnityEngine;

public class BaseFishNPC : BaseNpc, IAIAttack, IAISenses, IThinker
{
	protected FishBrain brain;

	public override void ServerInit()
	{
		base.ServerInit();
		brain = ((Component)this).GetComponent<FishBrain>();
		if (!base.isClient)
		{
			AIThinkManager.AddAnimal(this);
		}
	}

	internal override void DoServerDestroy()
	{
		if (!base.isClient)
		{
			AIThinkManager.RemoveAnimal(this);
			base.DoServerDestroy();
		}
	}

	public virtual void TryThink()
	{
		if (brain.ShouldServerThink())
		{
			brain.DoThink();
		}
	}

	public bool CanAttack(BaseEntity entity)
	{
		if (IsOnCooldown())
		{
			return false;
		}
		if (!IsTargetInRange(entity, out var _))
		{
			return false;
		}
		if (!CanSeeTarget(entity))
		{
			return false;
		}
		return true;
	}

	public bool NeedsToReload()
	{
		return false;
	}

	public float EngagementRange()
	{
		return AttackRange * brain.AttackRangeMultiplier;
	}

	public bool IsTargetInRange(BaseEntity entity, out float dist)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		dist = Vector3.Distance(((Component)entity).transform.position, base.AttackPosition);
		return dist <= EngagementRange();
	}

	public bool CanSeeTarget(BaseEntity entity)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.IsVisible(GetEntity().CenterPoint(), entity.CenterPoint());
	}

	public bool Reload()
	{
		return true;
	}

	public bool StartAttacking(BaseEntity target)
	{
		BaseCombatEntity baseCombatEntity = target as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity == (Object)null)
		{
			return false;
		}
		Attack(baseCombatEntity);
		return true;
	}

	public void StopAttacking()
	{
	}

	public float CooldownDuration()
	{
		return AttackRate;
	}

	public bool IsOnCooldown()
	{
		return !AttackReady();
	}

	public bool IsThreat(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null)
		{
			if (baseNpc.Stats.Family == Stats.Family)
			{
				return false;
			}
			return IsAfraidOf(baseNpc.Stats.Family);
		}
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			return IsAfraidOf(basePlayer.Family);
		}
		return false;
	}

	public bool IsTarget(BaseEntity entity)
	{
		BaseNpc baseNpc = entity as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null && baseNpc.Stats.Family == Stats.Family)
		{
			return false;
		}
		return !IsThreat(entity);
	}

	public bool IsFriendly(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.prefabID == prefabID;
	}

	public float GetAmmoFraction()
	{
		return 1f;
	}

	public BaseEntity GetBestTarget()
	{
		return null;
	}

	public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
	{
	}
}


using System;
using UnityEngine;

[Serializable]
public struct StateTimer
{
	public float ReleaseTime;

	public Action OnFinished;

	public bool IsActive
	{
		get
		{
			bool num = ReleaseTime > Time.time;
			if (!num && OnFinished != null)
			{
				OnFinished();
				OnFinished = null;
			}
			return num;
		}
	}

	public void Activate(float seconds, Action onFinished = null)
	{
		ReleaseTime = Time.time + seconds;
		OnFinished = onFinished;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct VitalLevel
{
	public float Level;

	private float lastUsedTime;

	public float TimeSinceUsed => Time.time - lastUsedTime;

	internal void Add(float f)
	{
		Level += f;
		if (Level > 1f)
		{
			Level = 1f;
		}
		if (Level < 0f)
		{
			Level = 0f;
		}
	}

	internal void Use(float f)
	{
		if (!Mathf.Approximately(f, 0f))
		{
			Level -= Mathf.Abs(f);
			if (Level < 0f)
			{
				Level = 0f;
			}
			lastUsedTime = Time.time;
		}
	}
}


using ConVar;
using UnityEngine;
using UnityEngine.AI;

public class NPCNavigator : BaseNavigator
{
	public int DestroyOnFailedSampleCount = 5;

	private int sampleFailCount;

	public BaseNpc NPC { get; private set; }

	public override void Init(BaseCombatEntity entity, NavMeshAgent agent)
	{
		base.Init(entity, agent);
		NPC = entity as BaseNpc;
		sampleFailCount = 0;
	}

	public override void OnFailedToPlaceOnNavmesh()
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		base.OnFailedToPlaceOnNavmesh();
		if ((Object)(object)SingletonComponent<DynamicNavMesh>.Instance == (Object)null || SingletonComponent<DynamicNavMesh>.Instance.IsBuilding)
		{
			return;
		}
		sampleFailCount++;
		if (DestroyOnFailedSampleCount > 0 && sampleFailCount >= DestroyOnFailedSampleCount)
		{
			string[] obj = new string[6]
			{
				"Failed to sample navmesh ",
				sampleFailCount.ToString(),
				" times in a row at: ",
				null,
				null,
				null
			};
			Vector3 position = ((Component)this).transform.position;
			obj[3] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
			obj[4] = ". Destroying: ";
			obj[5] = ((Object)((Component)this).gameObject).name;
			Debug.LogWarning((object)string.Concat(obj));
			if ((Object)(object)NPC != (Object)null && !NPC.IsDestroyed)
			{
				NPC.Kill();
			}
		}
	}

	public override void OnPlacedOnNavmesh()
	{
		base.OnPlacedOnNavmesh();
		sampleFailCount = 0;
	}

	protected override bool CanEnableNavMeshNavigation()
	{
		if (!base.CanEnableNavMeshNavigation())
		{
			return false;
		}
		return true;
	}

	protected override bool CanUpdateMovement()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanUpdateMovement())
		{
			return false;
		}
		if ((Object)(object)NPC != (Object)null && (NPC.IsDormant || !NPC.syncPosition) && ((Behaviour)base.Agent).enabled)
		{
			SetDestination(NPC.ServerPosition);
			return false;
		}
		return true;
	}

	protected override void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		base.UpdatePositionAndRotation(moveToPosition, delta);
		UpdateRotation(moveToPosition, delta);
	}

	private void UpdateRotation(Vector3 moveToPosition, float delta)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		if (overrideFacingDirectionMode != 0)
		{
			return;
		}
		if (traversingNavMeshLink)
		{
			Vector3 val = base.Agent.destination - base.BaseEntity.ServerPosition;
			if (((Vector3)(ref val)).sqrMagnitude > 1f)
			{
				val = currentNavMeshLinkEndPos - base.BaseEntity.ServerPosition;
			}
			_ = ((Vector3)(ref val)).sqrMagnitude;
			_ = 0.001f;
			return;
		}
		Vector3 val2 = base.Agent.destination - base.BaseEntity.ServerPosition;
		if (((Vector3)(ref val2)).sqrMagnitude > 1f)
		{
			val2 = base.Agent.desiredVelocity;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			if (((Vector3)(ref normalized)).sqrMagnitude > 0.001f)
			{
				base.BaseEntity.ServerRotation = Quaternion.LookRotation(normalized);
			}
		}
	}

	public override void ApplyFacingDirectionOverride()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyFacingDirectionOverride();
		base.BaseEntity.ServerRotation = Quaternion.LookRotation(base.FacingDirectionOverride);
	}

	public override bool IsSwimming()
	{
		if (!AI.npcswimming)
		{
			return false;
		}
		if ((Object)(object)NPC != (Object)null)
		{
			return NPC.swimming;
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.AI;

public class NPCPlayerNavigator : BaseNavigator
{
	public NPCPlayer NPCPlayerEntity { get; private set; }

	public override void Init(BaseCombatEntity entity, NavMeshAgent agent)
	{
		base.Init(entity, agent);
		NPCPlayerEntity = entity as NPCPlayer;
	}

	protected override bool CanEnableNavMeshNavigation()
	{
		if (!base.CanEnableNavMeshNavigation())
		{
			return false;
		}
		if (NPCPlayerEntity.isMounted && !CanNavigateMounted)
		{
			return false;
		}
		return true;
	}

	protected override bool CanUpdateMovement()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanUpdateMovement())
		{
			return false;
		}
		if (NPCPlayerEntity.IsWounded())
		{
			return false;
		}
		if (base.CurrentNavigationType == NavigationType.NavMesh && (NPCPlayerEntity.IsDormant || !NPCPlayerEntity.syncPosition) && ((Behaviour)base.Agent).enabled)
		{
			SetDestination(NPCPlayerEntity.ServerPosition);
			return false;
		}
		return true;
	}

	protected override void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		base.UpdatePositionAndRotation(moveToPosition, delta);
		if (overrideFacingDirectionMode == OverrideFacingDirectionMode.None)
		{
			if (base.CurrentNavigationType == NavigationType.NavMesh)
			{
				NPCPlayer nPCPlayerEntity = NPCPlayerEntity;
				Vector3 desiredVelocity = base.Agent.desiredVelocity;
				nPCPlayerEntity.SetAimDirection(((Vector3)(ref desiredVelocity)).normalized);
			}
			else if (base.CurrentNavigationType == NavigationType.AStar || base.CurrentNavigationType == NavigationType.Base)
			{
				NPCPlayerEntity.SetAimDirection(Vector3Ex.Direction2D(moveToPosition, ((Component)this).transform.position));
			}
		}
	}

	public override void ApplyFacingDirectionOverride()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyFacingDirectionOverride();
		if (overrideFacingDirectionMode != 0 && !NPCPlayerEntity.IsUnityNull())
		{
			if (overrideFacingDirectionMode == OverrideFacingDirectionMode.Direction)
			{
				NPCPlayerEntity.SetAimDirection(facingDirectionOverride);
			}
			else if ((Object)(object)facingDirectionEntity != (Object)null)
			{
				Vector3 aimDirection = GetAimDirection(NPCPlayerEntity, facingDirectionEntity);
				facingDirectionOverride = aimDirection;
				NPCPlayerEntity.SetAimDirection(facingDirectionOverride);
			}
		}
	}

	private static Vector3 GetAimDirection(BasePlayer aimingPlayer, BaseEntity target)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		if (target.IsUnityNull())
		{
			return Vector3Ex.Direction2D(((Component)aimingPlayer).transform.position + (((Object)(object)aimingPlayer.eyes != (Object)null) ? aimingPlayer.eyes.BodyForward() : ((Component)aimingPlayer).transform.forward) * 1000f, ((Component)aimingPlayer).transform.position);
		}
		if (Vector3Ex.Distance2D(((Component)aimingPlayer).transform.position, ((Component)target).transform.position) <= 0.75f)
		{
			return Vector3Ex.Direction2D(((Component)target).transform.position, ((Component)aimingPlayer).transform.position);
		}
		Vector3 val = TargetAimPositionOffset(target) - (((Object)(object)aimingPlayer.eyes != (Object)null) ? aimingPlayer.eyes.position : ((Component)aimingPlayer).transform.position);
		return ((Vector3)(ref val)).normalized;
	}

	private static Vector3 TargetAimPositionOffset(BaseEntity target)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = target as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsSleeping() || basePlayer.IsWounded())
			{
				return ((Component)basePlayer).transform.position + Vector3.up * 0.1f;
			}
			if ((Object)(object)basePlayer.eyes != (Object)null)
			{
				return basePlayer.eyes.position - Vector3.up * 0.15f;
			}
		}
		return target.CenterPoint();
	}
}


using UnityEngine;

public class NPCPlayerNavigatorTester : BaseMonoBehaviour
{
	public BasePathNode TargetNode;

	private BasePathNode currentNode;

	private void Update()
	{
		if ((Object)(object)TargetNode != (Object)(object)currentNode)
		{
			((Component)this).GetComponent<BaseNavigator>().SetDestination(TargetNode.Path, TargetNode, 0.5f);
			currentNode = TargetNode;
		}
	}
}


using UnityEngine;

public class NavPathTester : MonoBehaviour
{
	[SerializeField]
	private Transform target;

	private void OnDrawGizmosSelected()
	{
		if (!((Object)(object)target == (Object)null) && ((Object)(object)((Component)target).GetComponent<NavPathTester>()).Is<NavPathTester>(out NavPathTester entAsT) && (Object)(object)entAsT.target == (Object)null)
		{
			entAsT.target = ((Component)this).transform;
		}
	}

	public static void GizmosDrawPath(Vector3[] corners, Color color)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		for (int i = 0; i < corners.Length - 1; i++)
		{
			Gizmos.DrawSphere(corners[i], 0.01f);
			Gizmos.DrawLine(corners[i], corners[i + 1]);
		}
		Gizmos.color = color2;
	}
}


using UnityEngine;
using UnityEngine.AI;

public static class NPCOverwatchSpot
{
	public static (Vector3 loc, Vector3 dir)? Find(Vector3[] corners)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		if (corners.Length < 3)
		{
			return null;
		}
		NavMeshHit val9 = default(NavMeshHit);
		RaycastHit val14 = default(RaycastHit);
		RaycastHit val15 = default(RaycastHit);
		for (int num = corners.Length - 1; num >= 2; num--)
		{
			Vector3 val = corners[num];
			Vector3 val2 = corners[num - 1];
			Vector3 val3 = corners[num - 2];
			Gizmos.color = Color.red;
			Vector3 val4 = Vector3Ex.NormalizeXZ(val - val2);
			Vector3 val5 = Vector3Ex.NormalizeXZ(val3 - val2);
			Vector3 val6 = -Vector3Ex.NormalizeXZ(val4 + val5);
			Gizmos.DrawLine(val2, val2 + val6);
			Gizmos.color = Color.blue;
			Vector3 val7 = val6 * 0.01f;
			val += val7;
			val2 += val7;
			Vector3 val8 = Vector3Ex.NormalizeXZ(val2 - val) * 100f;
			if (NavMesh.Raycast(val, val + val8, ref val9, -1))
			{
				Vector3 val10 = val;
				Vector3 val11 = val;
				Vector3 val12 = ((NavMeshHit)(ref val9)).position - val;
				Gizmos.DrawLine(val10, val11 + ((Vector3)(ref val12)).normalized * 100f);
				if (((NavMeshHit)(ref val9)).distance >= 7f)
				{
					Vector3 val13 = corners[^1];
					Vector3 position = ((NavMeshHit)(ref val9)).position;
					bool flag = Physics.Linecast(val13 + 1.7f * Vector3.up, position + 1.7f * Vector3.up, ref val14, 1218652417);
					Gizmos.color = Color.red;
					Gizmos.DrawLine(val13 + 1.7f * Vector3.up, position + 1.7f * Vector3.up);
					if (flag)
					{
						bool flag2 = Physics.Linecast(val13 + 0.2f * Vector3.up, position + 0.2f * Vector3.up, ref val15, 1218652417);
						Gizmos.DrawLine(val13 + 0.2f * Vector3.up, position + 0.2f * Vector3.up);
						if (flag2)
						{
							Gizmos.color = Color.blue;
							Gizmos.DrawWireSphere(((NavMeshHit)(ref val9)).position, 0.1f);
							Vector3 position2 = ((NavMeshHit)(ref val9)).position;
							val12 = val - ((NavMeshHit)(ref val9)).position;
							return (position2, ((Vector3)(ref val12)).normalized);
						}
					}
				}
			}
		}
		return null;
	}
}


using UnityEngine;
using UnityEngine.AI;

public static class NPCFlankSpot
{
	public readonly struct FlankRoute
	{
		public readonly Vector3 FlankPoint;

		public readonly NavMeshPath ToFlankPoint;

		public readonly NavMeshPath FromFlankPointToEnemy;

		public FlankRoute(Vector3 flankPoint, NavMeshPath toFlankPoint, NavMeshPath fromFlankPointToEnemy)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			FlankPoint = flankPoint;
			ToFlankPoint = toFlankPoint;
			FromFlankPointToEnemy = fromFlankPointToEnemy;
		}
	}

	public static bool Find(Vector3[] pathToEnemy, float pathDistance, out FlankRoute flank)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		flank = default(FlankRoute);
		if (!FindMiddlePoint(pathToEnemy, pathDistance, out var middlePoint, out var dir))
		{
			return false;
		}
		Gizmos.color = Color.white;
		Gizmos.DrawSphere(middlePoint, 0.1f);
		Vector3 val = dir * pathDistance * 0.5f;
		val.y = 0f;
		if (TryBuildFlankPath(pathToEnemy, middlePoint, middlePoint + Quaternion.AngleAxis(90f, Vector3.up) * val, out flank))
		{
			return true;
		}
		if (TryBuildFlankPath(pathToEnemy, middlePoint, middlePoint + Quaternion.AngleAxis(-90f, Vector3.up) * val, out flank))
		{
			return true;
		}
		return false;
	}

	private static bool TryBuildFlankPath(Vector3[] pathToEnemy, Vector3 pathMiddle, Vector3 approximateFlankPoint, out FlankRoute flank)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected O, but got Unknown
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Expected O, but got Unknown
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Expected O, but got Unknown
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.white;
		Gizmos.DrawLine(pathMiddle, approximateFlankPoint);
		flank = default(FlankRoute);
		NavMeshHit val = default(NavMeshHit);
		if (!NavMesh.SamplePosition(approximateFlankPoint, ref val, 10f, -1))
		{
			return false;
		}
		Gizmos.DrawLine(approximateFlankPoint, ((NavMeshHit)(ref val)).position);
		NavMeshPath val2 = new NavMeshPath();
		if (!NavMesh.CalculatePath(pathMiddle, ((NavMeshHit)(ref val)).position, -1, val2))
		{
			return false;
		}
		Vector3 val3 = val2.corners[^1];
		NavMeshPath val4 = new NavMeshPath();
		if (!NavMesh.CalculatePath(pathToEnemy[0], val3, -1, val4))
		{
			return false;
		}
		Vector3[] corners = val4.corners;
		NavMeshPath val5 = new NavMeshPath();
		if (!NavMesh.CalculatePath(val3, pathToEnemy[^1], -1, val5))
		{
			return false;
		}
		Vector3[] corners2 = val5.corners;
		if (!ArePathsDifferent(pathToEnemy, corners2))
		{
			NavPathTester.GizmosDrawPath(corners, Color.grey);
			NavPathTester.GizmosDrawPath(corners2, Color.yellow);
			return false;
		}
		if (!ArePathsDifferent(pathToEnemy, corners))
		{
			NavPathTester.GizmosDrawPath(corners, Color.yellow);
			NavPathTester.GizmosDrawPath(corners2, Color.grey);
			return false;
		}
		if (!ArePathsDifferent(corners, corners2))
		{
			NavPathTester.GizmosDrawPath(corners, Color.yellow);
			NavPathTester.GizmosDrawPath(corners2, Color.grey);
			return false;
		}
		if (Vector3.Angle(pathToEnemy[^1] - pathToEnemy[^2], corners2[^1] - corners2[^2]) < 30f)
		{
			NavPathTester.GizmosDrawPath(corners, Color.grey);
			NavPathTester.GizmosDrawPath(corners2, Color.red);
			return false;
		}
		flank = new FlankRoute(val3, val4, val5);
		return true;
	}

	private static bool ArePathsDifferent(Vector3[] path1, Vector3[] path2, float minRatio = 0.25f)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (path1.Length < 3 || path2.Length < 3)
		{
			if (!(path1[0] != path2[0]))
			{
				return path1[^1] != path2[^1];
			}
			return true;
		}
		int num = 0;
		for (int i = 1; i < path1.Length - 1; i++)
		{
			for (int j = 1; j < path2.Length - 1; j++)
			{
				if (path1[i] == path2[j])
				{
					num++;
					break;
				}
			}
		}
		int num2 = Mathf.Min(path1.Length - 2, path2.Length - 2);
		return (float)num / (float)num2 <= minRatio;
	}

	private static bool FindMiddlePoint(Vector3[] corners, float pathLength, out Vector3 middlePoint, out Vector3 dir)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		float num = pathLength * 0.5f;
		float num2 = 0f;
		for (int i = 0; i < corners.Length - 1; i++)
		{
			Vector3 val = corners[i];
			Vector3 val2 = corners[i + 1];
			float num3 = Vector3.Distance(val, val2);
			if (num2 + num3 >= num)
			{
				float num4 = (num - num2) / num3;
				middlePoint = Vector3.Lerp(val, val2, num4);
				Vector3 val3 = val2 - val;
				dir = ((Vector3)(ref val3)).normalized;
				return true;
			}
			num2 += num3;
		}
		middlePoint = default(Vector3);
		dir = default(Vector3);
		return false;
	}
}


using UnityEngine;
using UnityEngine.AI;

public readonly struct FlankRoute
{
	public readonly Vector3 FlankPoint;

	public readonly NavMeshPath ToFlankPoint;

	public readonly NavMeshPath FromFlankPointToEnemy;

	public FlankRoute(Vector3 flankPoint, NavMeshPath toFlankPoint, NavMeshPath fromFlankPointToEnemy)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		FlankPoint = flankPoint;
		ToFlankPoint = toFlankPoint;
		FromFlankPointToEnemy = fromFlankPointToEnemy;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

public static class NPCDynamicCover
{
	public static bool Find(Vector3 pos, Vector3 enemyPos, out NavMeshPath path, out Vector3 coverDir, float radius = 10f, int itemsPerRing = 8, float offset = 0f)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Expected O, but got Unknown
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		path = null;
		coverDir = default(Vector3);
		float num = Vector3.SignedAngle(enemyPos - pos, Vector3.forward, Vector3.up) * (MathF.PI / 180f) + offset;
		NavMeshHit val2 = default(NavMeshHit);
		for (int i = 0; i < itemsPerRing; i++)
		{
			float num2 = MathF.PI * -2f * (float)i / (float)itemsPerRing + num;
			Vector3 val = pos + new Vector3(Mathf.Cos(num2), 0f, Mathf.Sin(num2)) * radius;
			Gizmos.color = Color.white;
			Gizmos.DrawLine(pos, val);
			if (!NavMesh.SamplePosition(val, ref val2, 3f, -1))
			{
				continue;
			}
			Gizmos.DrawLine(val, ((NavMeshHit)(ref val2)).position);
			val = ((NavMeshHit)(ref val2)).position;
			Vector3 val3 = enemyPos - val;
			Vector3 val4 = Vector3.Cross(((Vector3)(ref val3)).normalized, Vector3.up) * 0.5f;
			if (IsPositionVisibleFrom(val + val4, enemyPos) || IsPositionVisibleFrom(val - val4, enemyPos))
			{
				continue;
			}
			if (path == null)
			{
				path = new NavMeshPath();
			}
			if (NavMesh.CalculatePath(pos, val, -1, path) && (int)path.status == 0)
			{
				Gizmos.color = Color.black;
				NavPathTester.GizmosDrawPath(path.corners, Color.black);
				if (!(path.GetPathLength() > radius * 2f))
				{
					Gizmos.color = Color.yellow;
					Gizmos.DrawSphere(val, 0.5f);
					val3 = enemyPos - val;
					coverDir = ((Vector3)(ref val3)).normalized;
					return true;
				}
			}
		}
		path = null;
		return false;
	}

	private static bool IsPositionVisibleFrom(Vector3 pos, Vector3 enemyPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.up * 1.7f;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Linecast(pos + val, enemyPos + val, ref val2, 1218652417))
		{
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(pos + val, ((RaycastHit)(ref val2)).point);
			Gizmos.DrawSphere(((RaycastHit)(ref val2)).point, 0.1f);
			Gizmos.color = Color.red;
			Gizmos.DrawLine(((RaycastHit)(ref val2)).point, enemyPos + val);
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class RootMotionData : BaseScriptableObject
{
	public AnimationCurve xMotionCurve;

	public AnimationCurve yMotionCurve;

	public AnimationCurve zMotionCurve;

	public AnimationCurve yRotationCurve;

	public AnimationClip inPlaceAnimation;
}


using UnityEngine;

public class TraceTester : MonoBehaviour
{
}


using UnityEngine;

public class WaterDepthTester : MonoBehaviour
{
	private void Update()
	{
	}
}


using UnityEngine;

public class AccessbilityMaterialPropertyBlock : AccessibilityComponent
{
	public Renderer TargetRenderer;

	public string TagName;

	public AccessibilityColourCollection ForData;
}


public abstract class AccessibilityComponent : ListComponent<AccessibilityComponent>, IClientComponent
{
}


using UnityEngine;

public class AccessibilityDecalMaterial : AccessibilityComponent
{
	public DeferredDecal DecalRenderer;

	public AccessibilityMaterialCollection TargetData;

	public Material NightVisionTeaMaterial;
}


using UnityEngine.UI;

public class AccessibilityMaterialSprite : AccessibilityComponent
{
	public Image TargetImage;

	public AccessibilityMaterialCollection TargetData;
}


using UnityEngine;

public class AccessibilityMaterialSwap : AccessibilityComponent
{
	public AccessibilityMaterialCollection ForData;

	public Renderer ForRenderer;
}


public class AccessibilityMaterialSwap_NVG : AccessibilityMaterialSwap
{
}


using UnityEngine.UI;

public class AccessibilitySpriteColour : AccessibilityComponent
{
	public AccessibilityColourCollection TargetData;

	public Image SpriteA;

	public Image SpriteB;
}


public class AccessibilityCollection<T> : BaseScriptableObject
{
	public string convarName;

	public T[] AllOptions;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Accessibility/Colour Collection")]
public class AccessibilityColourCollection : AccessibilityCollection<AccessibilityColourCollection.ColourPair>
{
	[Serializable]
	public struct ColourPair
	{
		public Color A;

		public Color B;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ColourPair
{
	public Color A;

	public Color B;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Accessibility/Material Collection")]
public class AccessibilityMaterialCollection : AccessibilityCollection<AccessibilityMaterialCollection.MaterialOption>
{
	[Serializable]
	public struct MaterialOption
	{
		public Material TargetMaterial;

		public Color HudColour;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct MaterialOption
{
	public Material TargetMaterial;

	public Color HudColour;
}


public enum AIState
{
	None,
	Idle,
	Roam,
	Chase,
	Cover,
	Combat,
	Mounted,
	Exfil,
	Patrol,
	Orbit,
	Egress,
	Land,
	DropCrate,
	MoveTowards,
	Flee,
	Attack,
	Sleep,
	Reload,
	TakeCover,
	Dismounted,
	FollowPath,
	NavigateHome,
	CombatStationary,
	Cooldown,
	MoveToPoint,
	MoveToVector3,
	Blinded,
	KillSelf,
	MountAPC
}


public enum AIThinkMode
{
	FixedUpdate,
	Interval
}


using System;
using UnityEngine;

public class BasePathFinder
{
	private static Vector3[] preferedTopologySamples = (Vector3[])(object)new Vector3[4];

	private static Vector3[] topologySamples = (Vector3[])(object)new Vector3[4];

	private Vector3 chosenPosition;

	private const float halfPI = MathF.PI / 180f;

	public virtual Vector3 GetRandomPatrolPoint()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.zero;
	}

	public virtual AIMovePoint GetBestRoamPoint(Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float anchorClampDistance, float lookupMaxRange = 20f)
	{
		return null;
	}

	public void DebugDraw()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Color color = Gizmos.color;
		Gizmos.color = Color.green;
		Gizmos.DrawSphere(chosenPosition, 5f);
		Gizmos.color = Color.blue;
		Vector3[] array = topologySamples;
		for (int i = 0; i < array.Length; i++)
		{
			Gizmos.DrawSphere(array[i], 2.5f);
		}
		Gizmos.color = color;
	}

	public virtual Vector3 GetRandomPositionAround(Vector3 position, float minDistFrom = 0f, float maxDistFrom = 2f)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		if (maxDistFrom < 0f)
		{
			maxDistFrom = 0f;
		}
		Vector2 val = Random.insideUnitCircle * maxDistFrom;
		float num = Mathf.Clamp(Mathf.Max(Mathf.Abs(val.x), minDistFrom), minDistFrom, maxDistFrom) * Mathf.Sign(val.x);
		float num2 = Mathf.Clamp(Mathf.Max(Mathf.Abs(val.y), minDistFrom), minDistFrom, maxDistFrom) * Mathf.Sign(val.y);
		return position + new Vector3(num, 0f, num2);
	}

	public virtual Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		float radius = Random.Range(minRange, maxRange);
		int num = 0;
		int num2 = 0;
		float num3 = Random.Range(0f, 90f);
		for (float num4 = 0f; num4 < 360f; num4 += 90f)
		{
			Vector3 pointOnCircle = GetPointOnCircle(anchorPos, radius, num4 + num3);
			if (navigator.GetNearestNavmeshPosition(pointOnCircle, out var position, 10f) && navigator.IsPositionABiomeRequirement(position) && navigator.IsAcceptableWaterDepth(position) && !navigator.IsPositionPreventTopology(position))
			{
				topologySamples[num] = position;
				num++;
				if (navigator.IsPositionABiomePreference(position) && navigator.IsPositionATopologyPreference(position))
				{
					preferedTopologySamples[num2] = position;
					num2++;
				}
			}
		}
		if (num2 > 0)
		{
			chosenPosition = preferedTopologySamples[Random.Range(0, num2)];
		}
		else if (num > 0)
		{
			chosenPosition = topologySamples[Random.Range(0, num)];
		}
		else
		{
			chosenPosition = fallbackPos;
		}
		return chosenPosition;
	}

	public virtual Vector3 GetBestRoamPositionFromAnchor(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		float radius = Random.Range(minRange, maxRange);
		int num = 0;
		int num2 = 0;
		float num3 = Random.Range(0f, 90f);
		for (float num4 = 0f; num4 < 360f; num4 += 90f)
		{
			Vector3 pointOnCircle = GetPointOnCircle(anchorPos, radius, num4 + num3);
			if (navigator.GetNearestNavmeshPosition(pointOnCircle, out var position, 10f) && navigator.IsAcceptableWaterDepth(position))
			{
				topologySamples[num] = position;
				num++;
				if (navigator.IsPositionABiomePreference(position) && navigator.IsPositionATopologyPreference(position))
				{
					preferedTopologySamples[num2] = position;
					num2++;
				}
			}
		}
		if (Random.Range(0f, 1f) <= 0.9f && num2 > 0)
		{
			chosenPosition = preferedTopologySamples[Random.Range(0, num2)];
		}
		else if (num > 0)
		{
			chosenPosition = topologySamples[Random.Range(0, num)];
		}
		else
		{
			chosenPosition = fallbackPos;
		}
		return chosenPosition;
	}

	public virtual bool GetBestFleePosition(BaseNavigator navigator, AIBrainSenses senses, BaseEntity fleeFrom, Vector3 fallbackPos, float minRange, float maxRange, out Vector3 result)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)fleeFrom == (Object)null)
		{
			result = ((Component)navigator).transform.position;
			return false;
		}
		Vector3 dirFromThreat = Vector3Ex.Direction2D(((Component)navigator).transform.position, ((Component)fleeFrom).transform.position);
		if (TestFleeDirection(navigator, dirFromThreat, 0f, minRange, maxRange, out result))
		{
			return true;
		}
		bool flag = Random.Range(0, 2) == 1;
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 45f : 315f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 315f : 45f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 90f : 270f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, flag ? 270f : 90f, minRange, maxRange, out result))
		{
			return true;
		}
		if (TestFleeDirection(navigator, dirFromThreat, 135f + Random.Range(0f, 90f), minRange, maxRange, out result))
		{
			return true;
		}
		return false;
	}

	private bool TestFleeDirection(BaseNavigator navigator, Vector3 dirFromThreat, float offsetDegrees, float minRange, float maxRange, out Vector3 result)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		result = ((Component)navigator).transform.position;
		Vector3 val = Quaternion.Euler(0f, offsetDegrees, 0f) * dirFromThreat;
		Vector3 target = ((Component)navigator).transform.position + val * Random.Range(minRange, maxRange);
		if (!navigator.GetNearestNavmeshPosition(target, out var position, 20f))
		{
			return false;
		}
		if (!navigator.IsAcceptableWaterDepth(position))
		{
			return false;
		}
		result = position;
		return true;
	}

	public static Vector3 GetPointOnCircle(Vector3 center, float radius, float degrees)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		float num = center.x + radius * Mathf.Cos(degrees * (MathF.PI / 180f));
		float num2 = center.z + radius * Mathf.Sin(degrees * (MathF.PI / 180f));
		return new Vector3(num, center.y, num2);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class UnderwaterPathFinder : BasePathFinder
{
	private BaseEntity npc;

	public void Init(BaseEntity npc)
	{
		this.npc = npc;
	}

	public override Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		List<Vector3> list = Pool.Get<List<Vector3>>();
		(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(((Component)navigator).transform.position, waves: false, volumes: false);
		float item = waterAndTerrainSurface.Item1;
		float item2 = waterAndTerrainSurface.Item2;
		for (int i = 0; i < 8; i++)
		{
			Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(fallbackPos, Random.Range(1f, navigator.MaxRoamDistanceFromHome), Random.Range(0f, 359f));
			pointOnCircle.y += Random.Range(-2f, 2f);
			pointOnCircle.y = Mathf.Clamp(pointOnCircle.y, item2, item);
			list.Add(pointOnCircle);
		}
		float num = -1f;
		int num2 = -1;
		for (int j = 0; j < list.Count; j++)
		{
			Vector3 val = list[j];
			if (npc.IsVisible(val))
			{
				float num3 = 0f;
				Vector3 val2 = Vector3Ex.Direction2D(val, ((Component)navigator).transform.position);
				float num4 = Vector3.Dot(((Component)navigator).transform.forward, val2);
				num3 += Mathf.InverseLerp(0.25f, 0.8f, num4) * 5f;
				float num5 = Mathf.Abs(val.y - ((Component)navigator).transform.position.y);
				num3 += 1f - Mathf.InverseLerp(1f, 3f, num5) * 5f;
				if (num3 > num || num2 == -1)
				{
					num = num3;
					num2 = j;
				}
			}
		}
		Vector3 result = list[num2];
		Pool.FreeUnmanaged<Vector3>(ref list);
		return result;
	}

	public override bool GetBestFleePosition(BaseNavigator navigator, AIBrainSenses senses, BaseEntity fleeFrom, Vector3 fallbackPos, float minRange, float maxRange, out Vector3 result)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)fleeFrom == (Object)null)
		{
			result = ((Component)navigator).transform.position;
			return false;
		}
		Vector3 val = Vector3Ex.Direction2D(((Component)navigator).transform.position, ((Component)fleeFrom).transform.position);
		result = ((Component)navigator).transform.position + val * Random.Range(minRange, maxRange);
		return true;
	}
}


using UnityEngine;

public class AimConeUtil
{
	public static Vector3 GetModifiedAimConeDirection(float aimCone, Vector3 inputVec, bool anywhereInside = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.LookRotation(inputVec);
		aimCone = Mathf.Max(aimCone, 0f);
		Vector2 val2;
		if (!anywhereInside)
		{
			Vector2 insideUnitCircle = Random.insideUnitCircle;
			val2 = ((Vector2)(ref insideUnitCircle)).normalized;
		}
		else
		{
			val2 = Random.insideUnitCircle;
		}
		Vector2 val3 = val2;
		return val * Quaternion.Euler(val3.x * aimCone * 0.5f, val3.y * aimCone * 0.5f, 0f) * Vector3.forward;
	}

	public static Quaternion GetAimConeQuat(float aimCone)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 insideUnitSphere = Random.insideUnitSphere;
		return Quaternion.Euler(insideUnitSphere.x * aimCone * 0.5f, insideUnitSphere.y * aimCone * 0.5f, 0f);
	}
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch.Network.Raknet;
using Facepunch.Rust;
using Network;

public static class PlayerNetworkingProfiler
{
	public static int level = 0;

	public static TimeSpan MinFlushInterval = TimeSpan.FromSeconds(1.0);

	public static int ConnectionsPerFrame = 30;

	private static int currentIndex;

	private static DateTime flushCooldown;

	public static void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp)
	{
		if (level == 0)
		{
			return;
		}
		if (currentIndex >= Net.sv.connections.Count)
		{
			if (flushCooldown > DateTime.UtcNow)
			{
				return;
			}
			flushCooldown = DateTime.UtcNow + MinFlushInterval;
			currentIndex = 0;
		}
		Server sv = Net.sv;
		Server val = (Server)(object)((sv is Server) ? sv : null);
		if (val != null)
		{
			SerializeRaknet(uploader, frameIndex, timestamp, val);
		}
	}

	private static void SerializeRaknet(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp, Server server)
	{
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		int num = Math.Min(((Server)server).connections.Count, currentIndex + ConnectionsPerFrame);
		RaknetStats val2 = default(RaknetStats);
		while (currentIndex < num)
		{
			Connection val = ((Server)server).connections[currentIndex];
			if (server.TryGetConnectionStats(val, ref val2))
			{
				string ipaddress = val.ipaddress;
				string value = ipaddress.Split(':')[0];
				string value2 = ipaddress.Split(':')[1];
				int latestPing = server.GetLatestPing(val);
				EventRecord eventRecord = EventRecord.CSV().AddField("", timestamp).AddField("", frameIndex)
					.AddField("", Server.server_id)
					.AddField("", val.guid)
					.AddField("", val.userid)
					.AddField("", value)
					.AddField("", value2)
					.AddField("", latestPing)
					.AddField("", val2.connectionStartTime)
					.AddField("", val2.isLimitedByCongestionControl)
					.AddField("", val2.isLimitedByOutgoingBandwidthLimit)
					.AddField("", val2.BPSLimitByCongestionControl)
					.AddField("", val2.BPSLimitByOutgoingBandwidthLimit)
					.AddField("", val2.messagesInResendBuffer)
					.AddField("", val2.bytesInResendBuffer)
					.AddField("", val2.packetlossLastSecond)
					.AddField("", val2.packetlossTotal);
				for (int i = 0; i < 4; i++)
				{
					eventRecord.AddField("", (ulong)Unsafe.Add(ref val2.bytesInSendBuffer.FixedElementField, i));
				}
				for (int j = 0; j < 4; j++)
				{
					eventRecord.AddField("", (ulong)Unsafe.Add(ref val2.messageInSendBuffer.FixedElementField, j));
				}
				eventRecord.AddField("", val2.runningTotal.FixedElementField);
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 1));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 2));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 3));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 4));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 5));
				eventRecord.AddField("", Unsafe.Add(ref val2.runningTotal.FixedElementField, 6));
				uploader.Append(eventRecord);
			}
			currentIndex++;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

public static class TypeNameCache
{
	private static Dictionary<Type, string> cache = new Dictionary<Type, string>();

	private static Regex genericPrefixRegex = new Regex("`\\d+\\[");

	public static string GetName(Type type)
	{
		if (!cache.TryGetValue(type, out var value))
		{
			value = CalculateName(type);
			cache[type] = value;
		}
		return value;
	}

	private static string CalculateName(Type type)
	{
		string input = type.ToString();
		input = genericPrefixRegex.Replace(input, "<");
		return input.Replace("]", ">");
	}

	public static void ClearCache()
	{
		cache.Clear();
	}
}


using System;
using UnityEngine;

public class HorseIdleMultiConditionCrossfade : StateMachineBehaviour
{
	[Serializable]
	public struct Condition
	{
		public enum CondtionOperator
		{
			GreaterThan,
			LessThan
		}

		public int FloatParameter;

		public CondtionOperator Operator;

		public float Value;
	}

	public string TargetState = "breathe";

	public float NormalizedTransitionDuration = 0.1f;
}


using System;

[Serializable]
public struct Condition
{
	public enum CondtionOperator
	{
		GreaterThan,
		LessThan
	}

	public int FloatParameter;

	public CondtionOperator Operator;

	public float Value;
}


public enum CondtionOperator
{
	GreaterThan,
	LessThan
}


using UnityEngine;

public class TriggerResetter : StateMachineBehaviour
{
	public string triggerName;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Invalid comparison between Unknown and I4
		AnimatorControllerParameter[] parameters = animator.parameters;
		foreach (AnimatorControllerParameter val in parameters)
		{
			if ((int)val.type == 9 && val.name == triggerName)
			{
				animator.ResetTrigger(val.name);
			}
		}
	}
}


using System;
using UnityEngine;

public class WeightedAnimationRandomiser : StateMachineBehaviour
{
	[Serializable]
	public struct IdleChance
	{
		public string StateName;

		[Range(0f, 100f)]
		public int Chance;
	}

	public int LoopRangeMin = 3;

	public int LoopRangeMax = 5;

	public float NormalizedTransitionDuration;

	public IdleChance[] IdleTransitions = new IdleChance[0];

	public bool AllowRepeats;
}


using System;
using UnityEngine;

[Serializable]
public struct IdleChance
{
	public string StateName;

	[Range(0f, 100f)]
	public int Chance;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Ambience Definition")]
public class AmbienceDefinition : ScriptableObject
{
	[Serializable]
	public class ValueRange
	{
		public float min;

		public float max;

		public ValueRange(float min, float max)
		{
			this.min = min;
			this.max = max;
		}
	}

	[Header("Sound")]
	public List<SoundDefinition> sounds;

	[Horizontal(2, -1)]
	public ValueRange stingFrequency = new ValueRange(15f, 30f);

	[InspectorFlags]
	[Header("Environment")]
	public Enum biomes = (Enum)(-1);

	[InspectorFlags]
	public Enum topologies = (Enum)(-1);

	public EnvironmentType environmentType = EnvironmentType.Underground;

	public bool useEnvironmentType;

	public AnimationCurve time = AnimationCurve.Linear(0f, 0f, 24f, 0f);

	[Horizontal(2, -1)]
	public ValueRange rain = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange wind = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange snow = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange waves = new ValueRange(0f, 10f);
}


using System;

[Serializable]
public class ValueRange
{
	public float min;

	public float max;

	public ValueRange(float min, float max)
	{
		this.min = min;
		this.max = max;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Ambience Definition List")]
public class AmbienceDefinitionList : ScriptableObject
{
	public List<AmbienceDefinition> defs;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class AmbienceEmitter : MonoBehaviour, IClientComponent, IComparable<AmbienceEmitter>
{
	public AmbienceDefinitionList baseAmbience;

	public AmbienceDefinitionList stings;

	public bool isStatic = true;

	public bool followCamera;

	public bool isBaseEmitter;

	public bool active;

	public float cameraDistanceSq = float.PositiveInfinity;

	public BoundingSphere boundingSphere;

	public float crossfadeTime = 2f;

	public Dictionary<AmbienceDefinition, float> nextStingTime = new Dictionary<AmbienceDefinition, float>();

	public float deactivateTime = float.PositiveInfinity;

	public bool playUnderwater = true;

	public bool playAbovewater = true;

	public Enum currentTopology { get; private set; }

	public Enum currentBiome { get; private set; }

	public int CompareTo(AmbienceEmitter other)
	{
		return cameraDistanceSq.CompareTo(other.cameraDistanceSq);
	}
}


using UnityEngine;

public class AmbienceLocalStings : MonoBehaviour
{
	public float maxDistance = 100f;

	public float stingRadius = 10f;

	public float stingFrequency = 30f;

	public float stingFrequencyVariance = 15f;

	public SoundDefinition[] stingSounds;
}


using System;
using System.Collections.Generic;

public class AmbienceManager : SingletonComponent<AmbienceManager>, IClientComponent
{
	[Serializable]
	public class EmitterTypeLimit
	{
		public List<AmbienceDefinitionList> ambience;

		public int limit = 1;

		public int active;
	}

	public List<EmitterTypeLimit> localEmitterLimits = new List<EmitterTypeLimit>();

	public EmitterTypeLimit catchallEmitterLimit = new EmitterTypeLimit();

	public int maxActiveLocalEmitters = 5;

	public int activeLocalEmitters;

	public List<AmbienceEmitter> cameraEmitters = new List<AmbienceEmitter>();

	public List<AmbienceEmitter> emittersInRange = new List<AmbienceEmitter>();

	public List<AmbienceEmitter> activeEmitters = new List<AmbienceEmitter>();

	public float localEmitterRange = 30f;

	public List<AmbienceZone> currentAmbienceZones = new List<AmbienceZone>();

	public bool isUnderwater;

	public float ambienceZoneGain { get; private set; } = 1f;
}


using System;
using System.Collections.Generic;

[Serializable]
public class EmitterTypeLimit
{
	public List<AmbienceDefinitionList> ambience;

	public int limit = 1;

	public int active;
}


using UnityEngine;

public class AmbienceSpawnEmitters : MonoBehaviour, IClientComponent
{
	public int baseEmitterCount = 5;

	public int baseEmitterDistance = 10;

	public GameObjectRef emitterPrefab;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class AmbienceWaveSounds : SingletonComponent<AmbienceWaveSounds>, IClientComponent
{
	[Serializable]
	public class WaveLayer
	{
		public SoundDefinition soundDefinition;

		public AnimationCurve oceanScaleGainCurve;
	}

	public int emitterCount = 3;

	public float emitterDistance = 10f;

	public List<WaveLayer> waveLayers = new List<WaveLayer>();
}


using System;
using UnityEngine;

[Serializable]
public class WaveLayer
{
	public SoundDefinition soundDefinition;

	public AnimationCurve oceanScaleGainCurve;
}


using UnityEngine;

public class AmbienceWaveSoundZone : TriggerBase, IClientComponentEx
{
	public float priority;

	public float gain = 1f;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}
}


using UnityEngine;

public class AmbienceZone : TriggerBase, IClientComponentEx
{
	public AmbienceDefinitionList baseAmbience;

	public AmbienceDefinitionList stings;

	public float priority;

	public bool overrideCrossfadeTime;

	public float crossfadeTime = 1f;

	public float ambienceGain = 1f;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class RainSurfaceAmbience : SingletonComponent<RainSurfaceAmbience>, IClientComponent
{
	[Serializable]
	public class SurfaceSound
	{
		public AmbienceDefinitionList baseAmbience;

		public List<PhysicMaterial> materials = new List<PhysicMaterial>();
	}

	public List<SurfaceSound> surfaces = new List<SurfaceSound>();

	public GameObjectRef emitterPrefab;

	public Dictionary<ParticlePatch, AmbienceEmitter> spawnedEmitters = new Dictionary<ParticlePatch, AmbienceEmitter>();
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class SurfaceSound
{
	public AmbienceDefinitionList baseAmbience;

	public List<PhysicMaterial> materials = new List<PhysicMaterial>();
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Blended Engine Loop Definition")]
public class BlendedEngineLoopDefinition : ScriptableObject
{
	[Serializable]
	public class EngineLoopDefinition
	{
		public SoundDefinition soundDefinition;

		public float RPM;

		public float startRPM;

		public float startFullRPM;

		public float stopFullRPM;

		public float stopRPM;

		public float GetPitchForRPM(float targetRPM)
		{
			return targetRPM / RPM;
		}
	}

	public EngineLoopDefinition[] engineLoops;

	public float minRPM;

	public float maxRPM;

	public float RPMChangeRateUp = 0.5f;

	public float RPMChangeRateDown = 0.2f;
}


using System;

[Serializable]
public class EngineLoopDefinition
{
	public SoundDefinition soundDefinition;

	public float RPM;

	public float startRPM;

	public float startFullRPM;

	public float stopFullRPM;

	public float stopRPM;

	public float GetPitchForRPM(float targetRPM)
	{
		return targetRPM / RPM;
	}
}


using UnityEngine;

public class BlendedLoopEngineSound : MonoBehaviour, IClientComponent
{
	public class EngineLoop
	{
		public BlendedEngineLoopDefinition.EngineLoopDefinition definition;

		public BlendedLoopEngineSound parent;

		public Sound sound;

		public SoundModulation.Modulator gainMod;

		public SoundModulation.Modulator pitchMod;
	}

	public BlendedEngineLoopDefinition loopDefinition;

	public bool engineOn;

	[Range(0f, 1f)]
	public float RPMControl;

	public float smoothedRPMControl;

	private EngineLoop[] engineLoops;

	public bool debugPlayImmediately;

	public float maxDistance => loopDefinition.engineLoops[0].soundDefinition.maxDistance;

	public EngineLoop[] GetEngineLoops()
	{
		return engineLoops;
	}

	public float GetLoopGain(int idx)
	{
		if (engineLoops != null && engineLoops[idx] != null && engineLoops[idx].gainMod != null)
		{
			return engineLoops[idx].gainMod.value;
		}
		return 0f;
	}

	public float GetLoopPitch(int idx)
	{
		if (engineLoops != null && engineLoops[idx] != null && engineLoops[idx].pitchMod != null)
		{
			return engineLoops[idx].pitchMod.value;
		}
		return 0f;
	}
}


public class EngineLoop
{
	public BlendedEngineLoopDefinition.EngineLoopDefinition definition;

	public BlendedLoopEngineSound parent;

	public Sound sound;

	public SoundModulation.Modulator gainMod;

	public SoundModulation.Modulator pitchMod;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class BlendedSoundLoops : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class Loop
	{
		public SoundDefinition soundDef;

		public AnimationCurve gainCurve;

		public AnimationCurve pitchCurve;

		[HideInInspector]
		public Sound sound;

		[HideInInspector]
		public SoundModulation.Modulator gainMod;

		[HideInInspector]
		public SoundModulation.Modulator pitchMod;
	}

	[Range(0f, 1f)]
	public float blend;

	public float blendSmoothing = 1f;

	public float loopFadeOutTime = 0.5f;

	public float loopFadeInTime = 0.5f;

	public float gainModSmoothing = 1f;

	public float pitchModSmoothing = 1f;

	public bool shouldPlay = true;

	public float gain = 1f;

	public List<Loop> loops = new List<Loop>();

	public float maxDistance;
}


using System;
using UnityEngine;

[Serializable]
public class Loop
{
	public SoundDefinition soundDef;

	public AnimationCurve gainCurve;

	public AnimationCurve pitchCurve;

	[HideInInspector]
	public Sound sound;

	[HideInInspector]
	public SoundModulation.Modulator gainMod;

	[HideInInspector]
	public SoundModulation.Modulator pitchMod;
}


using UnityEngine;

public class BlendedSoundLoopSpeedControl : MonoBehaviour, IClientComponent
{
	public BlendedSoundLoops loops;

	public float speed;

	public float speedMax = 10f;
}


using System;
using System.Collections.Generic;
using Facepunch;
using JSON;
using UnityEngine;

public class EngineAudioClip : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class EngineCycle
	{
		public int RPM;

		public int startSample;

		public int endSample;

		public float period;

		public int id;

		public EngineCycle(int RPM, int startSample, int endSample, float period, int id)
		{
			this.RPM = RPM;
			this.startSample = startSample;
			this.endSample = endSample;
			this.period = period;
			this.id = id;
		}
	}

	public class EngineCycleBucket
	{
		public int RPM;

		public List<EngineCycle> cycles = new List<EngineCycle>();

		public List<int> remainingCycles = new List<int>();

		public EngineCycleBucket(int RPM)
		{
			this.RPM = RPM;
		}

		public EngineCycle GetCycle(Random random, int lastCycleId)
		{
			if (remainingCycles.Count == 0)
			{
				ResetRemainingCycles(random);
			}
			int index = Extensions.Pop<int>(remainingCycles);
			if (cycles[index].id == lastCycleId)
			{
				if (remainingCycles.Count == 0)
				{
					ResetRemainingCycles(random);
				}
				index = Extensions.Pop<int>(remainingCycles);
			}
			return cycles[index];
		}

		private void ResetRemainingCycles(Random random)
		{
			for (int i = 0; i < cycles.Count; i++)
			{
				remainingCycles.Add(i);
			}
			ListEx.Shuffle<int>(remainingCycles, (uint)random.Next());
		}

		public void Add(EngineCycle cycle)
		{
			if (!cycles.Contains(cycle))
			{
				cycles.Add(cycle);
			}
		}
	}

	public class Grain : IPooled
	{
		private float[] sourceData;

		private int startSample;

		private int currentSample;

		private int attackTimeSamples;

		private int sustainTimeSamples;

		private int releaseTimeSamples;

		private float gain;

		private float gainPerSampleAttack;

		private float gainPerSampleRelease;

		private int attackEndSample;

		private int releaseStartSample;

		private int endSample;

		public bool finished => currentSample >= endSample;

		public void Init(float[] source, EngineCycle cycle, int cyclePadding)
		{
			sourceData = source;
			startSample = cycle.startSample - cyclePadding;
			currentSample = startSample;
			attackTimeSamples = cyclePadding;
			sustainTimeSamples = cycle.endSample - cycle.startSample;
			releaseTimeSamples = cyclePadding;
			gainPerSampleAttack = 1f / (float)attackTimeSamples;
			gainPerSampleRelease = -1f / (float)releaseTimeSamples;
			attackEndSample = startSample + attackTimeSamples;
			releaseStartSample = attackEndSample + sustainTimeSamples;
			endSample = releaseStartSample + releaseTimeSamples;
			gain = 0f;
		}

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			sourceData = null;
			startSample = 0;
			currentSample = 0;
			attackTimeSamples = 0;
			sustainTimeSamples = 0;
			releaseTimeSamples = 0;
			gain = 0f;
			gainPerSampleAttack = 0f;
			gainPerSampleRelease = 0f;
			attackEndSample = 0;
			releaseStartSample = 0;
			endSample = 0;
		}

		public float GetSample()
		{
			if (currentSample >= sourceData.Length)
			{
				return 0f;
			}
			float num = sourceData[currentSample];
			if (currentSample <= attackEndSample)
			{
				gain += gainPerSampleAttack;
				if (gain > 0.8f)
				{
					gain = 0.8f;
				}
			}
			else if (currentSample >= releaseStartSample)
			{
				gain += gainPerSampleRelease;
				if (gain < 0f)
				{
					gain = 0f;
				}
			}
			currentSample++;
			return num * gain;
		}
	}

	public AudioClip granularClip;

	public AudioClip accelerationClip;

	public TextAsset accelerationCyclesJson;

	public List<EngineCycle> accelerationCycles = new List<EngineCycle>();

	public List<EngineCycleBucket> cycleBuckets = new List<EngineCycleBucket>();

	public Dictionary<int, EngineCycleBucket> accelerationCyclesByRPM = new Dictionary<int, EngineCycleBucket>();

	public Dictionary<int, int> rpmBucketLookup = new Dictionary<int, int>();

	public int sampleRate = 44100;

	public int samplesUntilNextGrain;

	public int lastCycleId;

	public List<Grain> grains = new List<Grain>();

	public int currentRPM;

	public int targetRPM = 1500;

	public int minRPM;

	public int maxRPM;

	public int cyclePadding;

	[Range(0f, 1f)]
	public float RPMControl;

	public AudioSource source;

	public float rpmLerpSpeed = 0.025f;

	public float rpmLerpSpeedDown = 0.01f;

	private int GetBucketRPM(int RPM)
	{
		return Mathf.RoundToInt((float)(RPM / 25)) * 25;
	}
}


using System;

[Serializable]
public class EngineCycle
{
	public int RPM;

	public int startSample;

	public int endSample;

	public float period;

	public int id;

	public EngineCycle(int RPM, int startSample, int endSample, float period, int id)
	{
		this.RPM = RPM;
		this.startSample = startSample;
		this.endSample = endSample;
		this.period = period;
		this.id = id;
	}
}


using System;
using System.Collections.Generic;
using JSON;

public class EngineCycleBucket
{
	public int RPM;

	public List<EngineCycle> cycles = new List<EngineCycle>();

	public List<int> remainingCycles = new List<int>();

	public EngineCycleBucket(int RPM)
	{
		this.RPM = RPM;
	}

	public EngineCycle GetCycle(Random random, int lastCycleId)
	{
		if (remainingCycles.Count == 0)
		{
			ResetRemainingCycles(random);
		}
		int index = Extensions.Pop<int>(remainingCycles);
		if (cycles[index].id == lastCycleId)
		{
			if (remainingCycles.Count == 0)
			{
				ResetRemainingCycles(random);
			}
			index = Extensions.Pop<int>(remainingCycles);
		}
		return cycles[index];
	}

	private void ResetRemainingCycles(Random random)
	{
		for (int i = 0; i < cycles.Count; i++)
		{
			remainingCycles.Add(i);
		}
		ListEx.Shuffle<int>(remainingCycles, (uint)random.Next());
	}

	public void Add(EngineCycle cycle)
	{
		if (!cycles.Contains(cycle))
		{
			cycles.Add(cycle);
		}
	}
}


using Facepunch;

public class Grain : IPooled
{
	private float[] sourceData;

	private int startSample;

	private int currentSample;

	private int attackTimeSamples;

	private int sustainTimeSamples;

	private int releaseTimeSamples;

	private float gain;

	private float gainPerSampleAttack;

	private float gainPerSampleRelease;

	private int attackEndSample;

	private int releaseStartSample;

	private int endSample;

	public bool finished => currentSample >= endSample;

	public void Init(float[] source, EngineCycle cycle, int cyclePadding)
	{
		sourceData = source;
		startSample = cycle.startSample - cyclePadding;
		currentSample = startSample;
		attackTimeSamples = cyclePadding;
		sustainTimeSamples = cycle.endSample - cycle.startSample;
		releaseTimeSamples = cyclePadding;
		gainPerSampleAttack = 1f / (float)attackTimeSamples;
		gainPerSampleRelease = -1f / (float)releaseTimeSamples;
		attackEndSample = startSample + attackTimeSamples;
		releaseStartSample = attackEndSample + sustainTimeSamples;
		endSample = releaseStartSample + releaseTimeSamples;
		gain = 0f;
	}

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		sourceData = null;
		startSample = 0;
		currentSample = 0;
		attackTimeSamples = 0;
		sustainTimeSamples = 0;
		releaseTimeSamples = 0;
		gain = 0f;
		gainPerSampleAttack = 0f;
		gainPerSampleRelease = 0f;
		attackEndSample = 0;
		releaseStartSample = 0;
		endSample = 0;
	}

	public float GetSample()
	{
		if (currentSample >= sourceData.Length)
		{
			return 0f;
		}
		float num = sourceData[currentSample];
		if (currentSample <= attackEndSample)
		{
			gain += gainPerSampleAttack;
			if (gain > 0.8f)
			{
				gain = 0.8f;
			}
		}
		else if (currentSample >= releaseStartSample)
		{
			gain += gainPerSampleRelease;
			if (gain < 0f)
			{
				gain = 0f;
			}
		}
		currentSample++;
		return num * gain;
	}
}


using UnityEngine;

public class FlybySound : MonoBehaviour, IClientComponent
{
	public SoundDefinition flybySound;

	public float flybySoundDistance = 7f;

	public SoundDefinition closeFlybySound;

	public float closeFlybyDistance = 3f;
}


using UnityEngine;

public class FootstepSound : MonoBehaviour, IClientComponent
{
	public enum Hardness
	{
		Light = 1,
		Medium,
		Hard
	}

	public SoundDefinition lightSound;

	public SoundDefinition medSound;

	public SoundDefinition hardSound;

	private const float panAmount = 0.05f;
}


public enum Hardness
{
	Light = 1,
	Medium,
	Hard
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class GranularAudioClip : MonoBehaviour
{
	public class Grain : IPooled
	{
		private float[] sourceData;

		private int sourceDataLength;

		private int startSample;

		private int currentSample;

		private int attackTimeSamples;

		private int sustainTimeSamples;

		private int releaseTimeSamples;

		private float gain;

		private float gainPerSampleAttack;

		private float gainPerSampleRelease;

		private int attackEndSample;

		private int releaseStartSample;

		private int endSample;

		public bool finished => currentSample >= endSample;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			sourceData = null;
			sourceDataLength = 0;
			startSample = 0;
			currentSample = 0;
			attackTimeSamples = 0;
			sustainTimeSamples = 0;
			releaseTimeSamples = 0;
			gain = 0f;
			gainPerSampleAttack = 0f;
			gainPerSampleRelease = 0f;
			attackEndSample = 0;
			releaseStartSample = 0;
			endSample = 0;
		}

		public void Init(float[] source, int start, int attack, int sustain, int release)
		{
			sourceData = source;
			sourceDataLength = sourceData.Length;
			startSample = start;
			currentSample = start;
			attackTimeSamples = attack;
			sustainTimeSamples = sustain;
			releaseTimeSamples = release;
			gainPerSampleAttack = 1f / (float)attackTimeSamples;
			gainPerSampleRelease = -1f / (float)releaseTimeSamples;
			attackEndSample = startSample + attackTimeSamples;
			releaseStartSample = attackEndSample + sustainTimeSamples;
			endSample = releaseStartSample + releaseTimeSamples;
			gain = 0f;
		}

		public float GetSample()
		{
			int num = currentSample % sourceDataLength;
			if (num < 0)
			{
				num += sourceDataLength;
			}
			float num2 = sourceData[num];
			if (currentSample <= attackEndSample)
			{
				gain += gainPerSampleAttack;
			}
			else if (currentSample >= releaseStartSample)
			{
				gain += gainPerSampleRelease;
			}
			currentSample++;
			return num2 * gain;
		}
	}

	public AudioClip sourceClip;

	private float[] sourceAudioData;

	private int sourceChannels = 1;

	public AudioClip granularClip;

	public int sampleRate = 44100;

	public float sourceTime = 0.5f;

	public float sourceTimeVariation = 0.1f;

	public float grainAttack = 0.1f;

	public float grainSustain = 0.1f;

	public float grainRelease = 0.1f;

	public float grainFrequency = 0.1f;

	public int grainAttackSamples;

	public int grainSustainSamples;

	public int grainReleaseSamples;

	public int grainFrequencySamples;

	public int samplesUntilNextGrain;

	public List<Grain> grains = new List<Grain>();

	private Random random = new Random();

	private bool inited;

	private void Update()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Invalid comparison between Unknown and I4
		if (!inited && (int)sourceClip.loadState == 2)
		{
			sampleRate = sourceClip.frequency;
			sourceAudioData = new float[sourceClip.samples * sourceClip.channels];
			sourceClip.GetData(sourceAudioData, 0);
			InitAudioClip();
			AudioSource component = ((Component)this).GetComponent<AudioSource>();
			component.clip = granularClip;
			component.loop = true;
			component.Play();
			inited = true;
		}
		RefreshCachedData();
	}

	private void RefreshCachedData()
	{
		grainAttackSamples = Mathf.FloorToInt(grainAttack * (float)sampleRate * (float)sourceChannels);
		grainSustainSamples = Mathf.FloorToInt(grainSustain * (float)sampleRate * (float)sourceChannels);
		grainReleaseSamples = Mathf.FloorToInt(grainRelease * (float)sampleRate * (float)sourceChannels);
		grainFrequencySamples = Mathf.FloorToInt(grainFrequency * (float)sampleRate * (float)sourceChannels);
	}

	private void InitAudioClip()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Expected O, but got Unknown
		int num = 1;
		int num2 = 1;
		AudioSettings.GetDSPBufferSize(ref num, ref num2);
		granularClip = AudioClip.Create(((Object)sourceClip).name + " (granular)", num, sourceClip.channels, sampleRate, true, new PCMReaderCallback(OnAudioRead));
		sourceChannels = sourceClip.channels;
	}

	private void OnAudioRead(float[] data)
	{
		for (int i = 0; i < data.Length; i++)
		{
			if (samplesUntilNextGrain <= 0)
			{
				SpawnGrain();
			}
			float num = 0f;
			for (int j = 0; j < grains.Count; j++)
			{
				num += grains[j].GetSample();
			}
			data[i] = num;
			samplesUntilNextGrain--;
		}
		CleanupFinishedGrains();
	}

	private void SpawnGrain()
	{
		if (grainFrequencySamples != 0)
		{
			float num = (float)(random.NextDouble() * (double)sourceTimeVariation * 2.0) - sourceTimeVariation;
			int start = Mathf.FloorToInt((sourceTime + num) * (float)sampleRate / (float)sourceChannels);
			Grain grain = Pool.Get<Grain>();
			grain.Init(sourceAudioData, start, grainAttackSamples, grainSustainSamples, grainReleaseSamples);
			grains.Add(grain);
			samplesUntilNextGrain = grainFrequencySamples;
		}
	}

	private void CleanupFinishedGrains()
	{
		for (int num = grains.Count - 1; num >= 0; num--)
		{
			Grain grain = grains[num];
			if (grain.finished)
			{
				Pool.Free<Grain>(ref grain);
				grains.RemoveAt(num);
			}
		}
	}
}


using Facepunch;

public class Grain : IPooled
{
	private float[] sourceData;

	private int sourceDataLength;

	private int startSample;

	private int currentSample;

	private int attackTimeSamples;

	private int sustainTimeSamples;

	private int releaseTimeSamples;

	private float gain;

	private float gainPerSampleAttack;

	private float gainPerSampleRelease;

	private int attackEndSample;

	private int releaseStartSample;

	private int endSample;

	public bool finished => currentSample >= endSample;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		sourceData = null;
		sourceDataLength = 0;
		startSample = 0;
		currentSample = 0;
		attackTimeSamples = 0;
		sustainTimeSamples = 0;
		releaseTimeSamples = 0;
		gain = 0f;
		gainPerSampleAttack = 0f;
		gainPerSampleRelease = 0f;
		attackEndSample = 0;
		releaseStartSample = 0;
		endSample = 0;
	}

	public void Init(float[] source, int start, int attack, int sustain, int release)
	{
		sourceData = source;
		sourceDataLength = sourceData.Length;
		startSample = start;
		currentSample = start;
		attackTimeSamples = attack;
		sustainTimeSamples = sustain;
		releaseTimeSamples = release;
		gainPerSampleAttack = 1f / (float)attackTimeSamples;
		gainPerSampleRelease = -1f / (float)releaseTimeSamples;
		attackEndSample = startSample + attackTimeSamples;
		releaseStartSample = attackEndSample + sustainTimeSamples;
		endSample = releaseStartSample + releaseTimeSamples;
		gain = 0f;
	}

	public float GetSample()
	{
		int num = currentSample % sourceDataLength;
		if (num < 0)
		{
			num += sourceDataLength;
		}
		float num2 = sourceData[num];
		if (currentSample <= attackEndSample)
		{
			gain += gainPerSampleAttack;
		}
		else if (currentSample >= releaseStartSample)
		{
			gain += gainPerSampleRelease;
		}
		currentSample++;
		return num2 * gain;
	}
}


public interface ISoundBudgetedUpdate
{
	void DoUpdate();

	bool IsSyncedToParent();
}


using UnityEngine.Audio;

public class MixerSnapshotManager : SingletonComponent<MixerSnapshotManager>, IClientComponent
{
	public AudioMixerSnapshot defaultSnapshot;

	public AudioMixerSnapshot underwaterSnapshot;

	public AudioMixerSnapshot loadingSnapshot;

	public AudioMixerSnapshot woundedSnapshot;

	public AudioMixerSnapshot cctvSnapshot;

	public AudioMixerSnapshot fadeToBlackSnapshot;

	public SoundDefinition underwaterInSound;

	public SoundDefinition underwaterOutSound;

	public AudioMixerSnapshot recordingSnapshot;

	public SoundDefinition woundedLoop;

	private Sound woundedLoopSound;

	public SoundDefinition cctvModeLoopDef;

	private Sound cctvModeLoop;

	public SoundDefinition cctvModeStartDef;

	public SoundDefinition cctvModeStopDef;

	public AudioMixerSnapshot predatorNearbySnapshot;

	public float deafness;
}


using UnityEngine;

public class MovementSoundTrigger : TriggerBase, IClientComponentEx, ILOD
{
	public SoundDefinition softSound;

	public SoundDefinition medSound;

	public SoundDefinition hardSound;

	public Collider collider;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)collider);
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class MusicChangeIntensity : MonoBehaviour
{
	[Serializable]
	public class DistanceIntensity
	{
		public float distance = 60f;

		public float raiseTo;

		public bool forceStartMusicInSuppressedMusicZones;
	}

	public float raiseTo;

	public List<DistanceIntensity> distanceIntensities = new List<DistanceIntensity>();

	public float tickInterval = 0.2f;
}


using System;

[Serializable]
public class DistanceIntensity
{
	public float distance = 60f;

	public float raiseTo;

	public bool forceStartMusicInSuppressedMusicZones;
}


using System.Collections.Generic;
using UnityEngine;

public class MusicClip : ScriptableObject
{
	public AudioClip audioClip;

	public int lengthInBars = 1;

	public int lengthInBarsWithTail;

	public List<float> fadeInPoints = new List<float>();

	public float GetNextFadeInPoint(float currentClipTimeBars)
	{
		if (fadeInPoints.Count == 0)
		{
			return currentClipTimeBars + 0.125f;
		}
		float result = -1f;
		float num = float.PositiveInfinity;
		for (int i = 0; i < fadeInPoints.Count; i++)
		{
			float num2 = fadeInPoints[i];
			float num3 = num2 - currentClipTimeBars;
			if (!(num2 <= 0.01f) && num3 > 0f && num3 < num)
			{
				num = num3;
				result = num2;
			}
		}
		return result;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class MusicClipLoader
{
	public class LoadedAudioClip : IPooled
	{
		public AudioClip clip;

		public float unloadTime;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			clip = null;
			unloadTime = 0f;
		}
	}

	public List<LoadedAudioClip> loadedClips = new List<LoadedAudioClip>();

	public Dictionary<AudioClip, LoadedAudioClip> loadedClipDict = new Dictionary<AudioClip, LoadedAudioClip>();

	public List<AudioClip> clipsToLoad = new List<AudioClip>();

	public List<AudioClip> clipsToUnload = new List<AudioClip>();

	public void Update()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Invalid comparison between Unknown and I4
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Invalid comparison between Unknown and I4
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Invalid comparison between Unknown and I4
		for (int num = clipsToLoad.Count - 1; num >= 0; num--)
		{
			AudioClip val = clipsToLoad[num];
			if ((int)val.loadState != 2 && (int)val.loadState != 1)
			{
				val.LoadAudioData();
				clipsToLoad.RemoveAt(num);
				return;
			}
		}
		for (int num2 = clipsToUnload.Count - 1; num2 >= 0; num2--)
		{
			AudioClip val2 = clipsToUnload[num2];
			if ((int)val2.loadState == 2)
			{
				val2.UnloadAudioData();
				clipsToUnload.RemoveAt(num2);
				break;
			}
		}
	}

	public void Refresh()
	{
		for (int i = 0; i < SingletonComponent<MusicManager>.Instance.activeMusicClips.Count; i++)
		{
			MusicTheme.PositionedClip positionedClip = SingletonComponent<MusicManager>.Instance.activeMusicClips[i];
			LoadedAudioClip loadedAudioClip = FindLoadedClip(positionedClip.musicClip.audioClip);
			if (loadedAudioClip == null)
			{
				loadedAudioClip = Pool.Get<LoadedAudioClip>();
				loadedAudioClip.clip = positionedClip.musicClip.audioClip;
				loadedAudioClip.unloadTime = (float)AudioSettings.dspTime + loadedAudioClip.clip.length + 1f;
				loadedClips.Add(loadedAudioClip);
				loadedClipDict.Add(loadedAudioClip.clip, loadedAudioClip);
				clipsToLoad.Add(loadedAudioClip.clip);
			}
			else
			{
				loadedAudioClip.unloadTime = (float)AudioSettings.dspTime + loadedAudioClip.clip.length + 1f;
				clipsToUnload.Remove(loadedAudioClip.clip);
			}
		}
		for (int num = loadedClips.Count - 1; num >= 0; num--)
		{
			LoadedAudioClip loadedAudioClip2 = loadedClips[num];
			if (AudioSettings.dspTime > (double)loadedAudioClip2.unloadTime)
			{
				clipsToUnload.Add(loadedAudioClip2.clip);
				loadedClips.Remove(loadedAudioClip2);
				loadedClipDict.Remove(loadedAudioClip2.clip);
				Pool.Free<LoadedAudioClip>(ref loadedAudioClip2);
			}
		}
	}

	private LoadedAudioClip FindLoadedClip(AudioClip clip)
	{
		if (loadedClipDict.ContainsKey(clip))
		{
			return loadedClipDict[clip];
		}
		return null;
	}
}


using Facepunch;
using UnityEngine;

public class LoadedAudioClip : IPooled
{
	public AudioClip clip;

	public float unloadTime;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		clip = null;
		unloadTime = 0f;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.Audio;

public class MusicManager : SingletonComponent<MusicManager>, IClientComponent
{
	[Serializable]
	public class ClipPlaybackData : IPooled
	{
		public AudioSource source;

		public MusicTheme.PositionedClip positionedClip;

		public bool isActive;

		public bool fadingIn;

		public bool fadingOut;

		public double fadeStarted;

		public bool needsSync;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			source = null;
			positionedClip = null;
			isActive = false;
			fadingIn = false;
			fadingOut = false;
			fadeStarted = 0.0;
			needsSync = false;
		}
	}

	public AudioMixerGroup mixerGroup;

	public List<MusicTheme> themes;

	public MusicTheme currentTheme;

	public List<AudioSource> sources = new List<AudioSource>();

	public double nextMusic;

	public double nextMusicFromIntensityRaise;

	[Range(0f, 1f)]
	public float intensity;

	public Dictionary<MusicTheme.PositionedClip, ClipPlaybackData> clipPlaybackData = new Dictionary<MusicTheme.PositionedClip, ClipPlaybackData>();

	public int holdIntensityUntilBar;

	public bool musicPlaying;

	public bool loadingFirstClips;

	public MusicTheme nextTheme;

	public double lastClipUpdate;

	public float clipUpdateInterval = 0.1f;

	public double themeStartTime;

	public int lastActiveClipRefresh = -10;

	public int activeClipRefreshInterval = 1;

	public bool forceThemeChange;

	public float randomIntensityJumpChance;

	public int clipScheduleBarsEarly = 1;

	public List<MusicTheme.PositionedClip> activeClips = new List<MusicTheme.PositionedClip>();

	public List<MusicTheme.PositionedClip> activeMusicClips = new List<MusicTheme.PositionedClip>();

	public List<MusicTheme.PositionedClip> activeControlClips = new List<MusicTheme.PositionedClip>();

	public List<MusicZone> currentMusicZones = new List<MusicZone>();

	public int currentBar;

	public int barOffset;

	public double currentThemeTime => AudioSettings.dspTime - themeStartTime;

	public int themeBar => currentBar + barOffset;

	public static void RaiseIntensityTo(float amount, int holdLengthBars = 0)
	{
	}

	public void StopMusic()
	{
	}
}


using System;
using Facepunch;
using UnityEngine;

[Serializable]
public class ClipPlaybackData : IPooled
{
	public AudioSource source;

	public MusicTheme.PositionedClip positionedClip;

	public bool isActive;

	public bool fadingIn;

	public bool fadingOut;

	public double fadeStarted;

	public bool needsSync;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		source = null;
		positionedClip = null;
		isActive = false;
		fadingIn = false;
		fadingOut = false;
		fadeStarted = 0.0;
		needsSync = false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MusicTheme")]
public class MusicTheme : ScriptableObject
{
	[Serializable]
	public class Layer
	{
		public string name = "layer";
	}

	[Serializable]
	public class PositionedClip
	{
		public MusicTheme theme;

		public MusicClip musicClip;

		public int startingBar;

		public int layerId;

		public float minIntensity;

		public float maxIntensity = 1f;

		public bool allowFadeIn = true;

		public bool allowFadeOut = true;

		public float fadeInTime = 1f;

		public float fadeOutTime = 0.5f;

		public float intensityReduction;

		public int jumpBarCount;

		public float jumpMinimumIntensity = 0.5f;

		public float jumpMaximumIntensity = 0.5f;

		public int endingBar
		{
			get
			{
				if (!((Object)(object)musicClip == (Object)null))
				{
					return startingBar + musicClip.lengthInBarsWithTail;
				}
				return startingBar;
			}
		}

		public bool isControlClip => (Object)(object)musicClip == (Object)null;

		public bool CanPlay(float intensity)
		{
			if (intensity > minIntensity || (minIntensity == 0f && intensity == 0f))
			{
				return intensity <= maxIntensity;
			}
			return false;
		}

		public void CopySettingsFrom(PositionedClip otherClip)
		{
			if (isControlClip == otherClip.isControlClip && otherClip != this)
			{
				allowFadeIn = otherClip.allowFadeIn;
				fadeInTime = otherClip.fadeInTime;
				allowFadeOut = otherClip.allowFadeOut;
				fadeOutTime = otherClip.fadeOutTime;
				maxIntensity = otherClip.maxIntensity;
				minIntensity = otherClip.minIntensity;
				intensityReduction = otherClip.intensityReduction;
			}
		}
	}

	[Serializable]
	public class ValueRange
	{
		public float min;

		public float max;

		public ValueRange(float min, float max)
		{
			this.min = min;
			this.max = max;
		}
	}

	[Header("Basic info")]
	public float tempo = 80f;

	public int intensityHoldBars = 4;

	public int lengthInBars;

	[Header("Playback restrictions")]
	public bool canPlayInMenus = true;

	[Horizontal(2, -1)]
	public ValueRange rain = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange wind = new ValueRange(0f, 1f);

	[Horizontal(2, -1)]
	public ValueRange snow = new ValueRange(0f, 1f);

	[InspectorFlags]
	public Enum biomes = (Enum)(-1);

	[InspectorFlags]
	public Enum topologies = (Enum)(-1);

	public AnimationCurve time = AnimationCurve.Linear(0f, 0f, 24f, 0f);

	[Header("Clip data")]
	public List<PositionedClip> clips = new List<PositionedClip>();

	public List<Layer> layers = new List<Layer>();

	private Dictionary<int, List<PositionedClip>> activeClips = new Dictionary<int, List<PositionedClip>>();

	private List<AudioClip> firstAudioClips = new List<AudioClip>();

	private Dictionary<AudioClip, bool> audioClipDict = new Dictionary<AudioClip, bool>();

	public int layerCount => layers.Count;

	public int samplesPerBar => MusicUtil.BarsToSamples(tempo, 1f, 44100);

	private void OnValidate()
	{
		audioClipDict.Clear();
		activeClips.Clear();
		UpdateLengthInBars();
		for (int i = 0; i < clips.Count; i++)
		{
			PositionedClip positionedClip = clips[i];
			int num = ActiveClipCollectionID(positionedClip.startingBar - 8);
			int num2 = ActiveClipCollectionID(positionedClip.endingBar);
			for (int j = num; j <= num2; j++)
			{
				if (!activeClips.ContainsKey(j))
				{
					activeClips.Add(j, new List<PositionedClip>());
				}
				if (!activeClips[j].Contains(positionedClip))
				{
					activeClips[j].Add(positionedClip);
				}
			}
			if ((Object)(object)positionedClip.musicClip != (Object)null)
			{
				AudioClip audioClip = positionedClip.musicClip.audioClip;
				if (!audioClipDict.ContainsKey(audioClip))
				{
					audioClipDict.Add(audioClip, value: true);
				}
				if (positionedClip.startingBar < 8 && !firstAudioClips.Contains(audioClip))
				{
					firstAudioClips.Add(audioClip);
				}
				positionedClip.musicClip.lengthInBarsWithTail = Mathf.CeilToInt(MusicUtil.SecondsToBars(tempo, positionedClip.musicClip.audioClip.length));
			}
		}
	}

	public List<PositionedClip> GetActiveClipsForBar(int bar)
	{
		int key = ActiveClipCollectionID(bar);
		if (!activeClips.ContainsKey(key))
		{
			return null;
		}
		return activeClips[key];
	}

	private int ActiveClipCollectionID(int bar)
	{
		return Mathf.FloorToInt(Mathf.Max((float)(bar / 4), 0f));
	}

	public Layer LayerById(int id)
	{
		if (layers.Count <= id)
		{
			return null;
		}
		return layers[id];
	}

	public void AddLayer()
	{
		Layer layer = new Layer();
		layer.name = "layer " + layers.Count;
		layers.Add(layer);
	}

	private void UpdateLengthInBars()
	{
		int num = 0;
		for (int i = 0; i < clips.Count; i++)
		{
			PositionedClip positionedClip = clips[i];
			if (!((Object)(object)positionedClip.musicClip == (Object)null))
			{
				int num2 = positionedClip.startingBar + positionedClip.musicClip.lengthInBars;
				if (num2 > num)
				{
					num = num2;
				}
			}
		}
		lengthInBars = num;
	}

	public bool CanPlayInEnvironment(int currentBiome, int currentTopology, float currentRain, float currentSnow, float currentWind)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Invalid comparison between Unknown and I4
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Invalid comparison between Unknown and I4
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance) && time.Evaluate(TOD_Sky.Instance.Cycle.Hour) < 0f)
		{
			return false;
		}
		if ((int)biomes != -1 && (biomes & currentBiome) == 0)
		{
			return false;
		}
		if ((int)topologies != -1 && (topologies & currentTopology) != 0)
		{
			return false;
		}
		if (((rain.min > 0f || rain.max < 1f) && currentRain < rain.min) || currentRain > rain.max)
		{
			return false;
		}
		if (((snow.min > 0f || snow.max < 1f) && currentSnow < snow.min) || currentSnow > snow.max)
		{
			return false;
		}
		if (((wind.min > 0f || wind.max < 1f) && currentWind < wind.min) || currentWind > wind.max)
		{
			return false;
		}
		return true;
	}

	public bool FirstClipsLoaded()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		for (int i = 0; i < firstAudioClips.Count; i++)
		{
			if ((int)firstAudioClips[i].loadState != 2)
			{
				return false;
			}
		}
		return true;
	}

	public bool ContainsAudioClip(AudioClip clip)
	{
		return audioClipDict.ContainsKey(clip);
	}
}


using System;

[Serializable]
public class Layer
{
	public string name = "layer";
}


using System;
using UnityEngine;

[Serializable]
public class PositionedClip
{
	public MusicTheme theme;

	public MusicClip musicClip;

	public int startingBar;

	public int layerId;

	public float minIntensity;

	public float maxIntensity = 1f;

	public bool allowFadeIn = true;

	public bool allowFadeOut = true;

	public float fadeInTime = 1f;

	public float fadeOutTime = 0.5f;

	public float intensityReduction;

	public int jumpBarCount;

	public float jumpMinimumIntensity = 0.5f;

	public float jumpMaximumIntensity = 0.5f;

	public int endingBar
	{
		get
		{
			if (!((Object)(object)musicClip == (Object)null))
			{
				return startingBar + musicClip.lengthInBarsWithTail;
			}
			return startingBar;
		}
	}

	public bool isControlClip => (Object)(object)musicClip == (Object)null;

	public bool CanPlay(float intensity)
	{
		if (intensity > minIntensity || (minIntensity == 0f && intensity == 0f))
		{
			return intensity <= maxIntensity;
		}
		return false;
	}

	public void CopySettingsFrom(PositionedClip otherClip)
	{
		if (isControlClip == otherClip.isControlClip && otherClip != this)
		{
			allowFadeIn = otherClip.allowFadeIn;
			fadeInTime = otherClip.fadeInTime;
			allowFadeOut = otherClip.allowFadeOut;
			fadeOutTime = otherClip.fadeOutTime;
			maxIntensity = otherClip.maxIntensity;
			minIntensity = otherClip.minIntensity;
			intensityReduction = otherClip.intensityReduction;
		}
	}
}


using System;

[Serializable]
public class ValueRange
{
	public float min;

	public float max;

	public ValueRange(float min, float max)
	{
		this.min = min;
		this.max = max;
	}
}


using UnityEngine;

public class MusicUtil
{
	public const float OneSixteenth = 0.0625f;

	public static double BeatsToSeconds(float tempo, float beats)
	{
		return 60.0 / (double)tempo * (double)beats;
	}

	public static double BarsToSeconds(float tempo, float bars)
	{
		return BeatsToSeconds(tempo, bars * 4f);
	}

	public static int SecondsToSamples(double seconds)
	{
		return SecondsToSamples(seconds, AudioSettings.outputSampleRate);
	}

	public static int SecondsToSamples(double seconds, int sampleRate)
	{
		return (int)((double)sampleRate * seconds);
	}

	public static int SecondsToSamples(float seconds)
	{
		return SecondsToSamples(seconds, AudioSettings.outputSampleRate);
	}

	public static int SecondsToSamples(float seconds, int sampleRate)
	{
		return (int)((float)sampleRate * seconds);
	}

	public static int BarsToSamples(float tempo, float bars, int sampleRate)
	{
		return SecondsToSamples(BarsToSeconds(tempo, bars), sampleRate);
	}

	public static int BarsToSamples(float tempo, float bars)
	{
		return SecondsToSamples(BarsToSeconds(tempo, bars));
	}

	public static int BeatsToSamples(float tempo, float beats)
	{
		return SecondsToSamples(BeatsToSeconds(tempo, beats));
	}

	public static float SecondsToBeats(float tempo, double seconds)
	{
		return tempo / 60f * (float)seconds;
	}

	public static float SecondsToBars(float tempo, double seconds)
	{
		return SecondsToBeats(tempo, seconds) / 4f;
	}

	public static float Quantize(float position, float gridSize)
	{
		return Mathf.Round(position / gridSize) * gridSize;
	}

	public static float FlooredQuantize(float position, float gridSize)
	{
		return Mathf.Floor(position / gridSize) * gridSize;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class MusicZone : MonoBehaviour, IClientComponent
{
	public List<MusicTheme> themes;

	public float priority;

	public bool suppressAutomaticMusic;

	public bool startOnEnter;
}


using UnityEngine;

public class OnePoleLowpassFilter : MonoBehaviour
{
	[Range(10f, 20000f)]
	public float frequency = 20000f;
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Reverb Settings")]
public class ReverbSettings : ScriptableObject
{
	[Range(-10000f, 0f)]
	public int room;

	[Range(-10000f, 0f)]
	public int roomHF;

	[Range(-10000f, 0f)]
	public int roomLF;

	[Range(0.1f, 20f)]
	public float decayTime;

	[Range(0.1f, 2f)]
	public float decayHFRatio;

	[Range(-10000f, 1000f)]
	public int reflections;

	[Range(0f, 0.3f)]
	public float reflectionsDelay;

	[Range(-10000f, 2000f)]
	public int reverb;

	[Range(0f, 0.1f)]
	public float reverbDelay;

	[Range(1000f, 20000f)]
	public float HFReference;

	[Range(20f, 1000f)]
	public float LFReference;

	[Range(0f, 100f)]
	public float diffusion;

	[Range(0f, 100f)]
	public float density;
}


using UnityEngine;

public class ReverbZoneTrigger : TriggerBase, IClientComponentEx, ILOD
{
	public Collider trigger;

	public AudioReverbZone reverbZone;

	public float lodDistance = 100f;

	public bool inRange;

	public ReverbSettings reverbSettings;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)trigger);
		p.RemoveComponent((Component)(object)reverbZone);
		p.RemoveComponent((Component)(object)this);
		p.NominateForDeletion(((Component)this).gameObject);
	}

	public bool IsSyncedToParent()
	{
		return false;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ShoutcastStreamer : MonoBehaviour, IClientComponent
{
	public string Host = "http://listen.57fm.com:80/rcxmas";

	public AudioSource Source;

	public static RadioPlaylist[] BuiltinRadios;

	public static Dictionary<string, string> ParsedLocalRadioList;

	public static void CheckBuiltInRadios()
	{
		if (BuiltinRadios == null)
		{
			BuiltinRadios = FileSystem.LoadAll<RadioPlaylist>("assets/prefabs/voiceaudio/boombox/sound/builtinplaylists", "");
			ParsedLocalRadioList = new Dictionary<string, string>();
			RadioPlaylist[] builtinRadios = BuiltinRadios;
			foreach (RadioPlaylist radioPlaylist in builtinRadios)
			{
				ParsedLocalRadioList.Add(radioPlaylist.LocalName, radioPlaylist.Url);
			}
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SlicedGranularAudioClip : MonoBehaviour, IClientComponent
{
	public class Grain : IPooled
	{
		private float[] sourceData;

		private int startSample;

		private int currentSample;

		private int attackTimeSamples;

		private int sustainTimeSamples;

		private int releaseTimeSamples;

		private float gain;

		private float gainPerSampleAttack;

		private float gainPerSampleRelease;

		private int attackEndSample;

		private int releaseStartSample;

		private int endSample;

		public bool finished => currentSample >= endSample;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			sourceData = null;
			startSample = 0;
			currentSample = 0;
			attackTimeSamples = 0;
			sustainTimeSamples = 0;
			releaseTimeSamples = 0;
			gain = 0f;
			gainPerSampleAttack = 0f;
			gainPerSampleRelease = 0f;
			attackEndSample = 0;
			releaseStartSample = 0;
			endSample = 0;
		}

		public void Init(float[] source, int start, int attack, int sustain, int release)
		{
			sourceData = source;
			startSample = start;
			currentSample = start;
			attackTimeSamples = attack;
			sustainTimeSamples = sustain;
			releaseTimeSamples = release;
			gainPerSampleAttack = 0.5f / (float)attackTimeSamples;
			gainPerSampleRelease = -0.5f / (float)releaseTimeSamples;
			attackEndSample = startSample + attackTimeSamples;
			releaseStartSample = attackEndSample + sustainTimeSamples;
			endSample = releaseStartSample + releaseTimeSamples;
			gain = 0f;
		}

		public float GetSample()
		{
			if (currentSample >= sourceData.Length)
			{
				return 0f;
			}
			float num = sourceData[currentSample];
			if (currentSample <= attackEndSample)
			{
				gain += gainPerSampleAttack;
				if (gain > 0.5f)
				{
					gain = 0.5f;
				}
			}
			else if (currentSample >= releaseStartSample)
			{
				gain += gainPerSampleRelease;
				if (gain < 0f)
				{
					gain = 0f;
				}
			}
			currentSample++;
			return num * gain;
		}

		public void FadeOut()
		{
			releaseStartSample = currentSample;
			endSample = releaseStartSample + releaseTimeSamples;
		}
	}

	public AudioSource source;

	public AudioClip sourceClip;

	public AudioClip granularClip;

	public int sampleRate = 44100;

	public float grainAttack = 0.1f;

	public float grainSustain = 0.1f;

	public float grainRelease = 0.1f;

	public float grainFrequency = 0.1f;

	public int grainAttackSamples;

	public int grainSustainSamples;

	public int grainReleaseSamples;

	public int grainFrequencySamples;

	public int samplesUntilNextGrain;

	public List<Grain> grains = new List<Grain>();

	public List<int> startPositions = new List<int>();

	public int lastStartPositionIdx = int.MaxValue;

	public bool playOnAwake = true;
}


using Facepunch;

public class Grain : IPooled
{
	private float[] sourceData;

	private int startSample;

	private int currentSample;

	private int attackTimeSamples;

	private int sustainTimeSamples;

	private int releaseTimeSamples;

	private float gain;

	private float gainPerSampleAttack;

	private float gainPerSampleRelease;

	private int attackEndSample;

	private int releaseStartSample;

	private int endSample;

	public bool finished => currentSample >= endSample;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		sourceData = null;
		startSample = 0;
		currentSample = 0;
		attackTimeSamples = 0;
		sustainTimeSamples = 0;
		releaseTimeSamples = 0;
		gain = 0f;
		gainPerSampleAttack = 0f;
		gainPerSampleRelease = 0f;
		attackEndSample = 0;
		releaseStartSample = 0;
		endSample = 0;
	}

	public void Init(float[] source, int start, int attack, int sustain, int release)
	{
		sourceData = source;
		startSample = start;
		currentSample = start;
		attackTimeSamples = attack;
		sustainTimeSamples = sustain;
		releaseTimeSamples = release;
		gainPerSampleAttack = 0.5f / (float)attackTimeSamples;
		gainPerSampleRelease = -0.5f / (float)releaseTimeSamples;
		attackEndSample = startSample + attackTimeSamples;
		releaseStartSample = attackEndSample + sustainTimeSamples;
		endSample = releaseStartSample + releaseTimeSamples;
		gain = 0f;
	}

	public float GetSample()
	{
		if (currentSample >= sourceData.Length)
		{
			return 0f;
		}
		float num = sourceData[currentSample];
		if (currentSample <= attackEndSample)
		{
			gain += gainPerSampleAttack;
			if (gain > 0.5f)
			{
				gain = 0.5f;
			}
		}
		else if (currentSample >= releaseStartSample)
		{
			gain += gainPerSampleRelease;
			if (gain < 0f)
			{
				gain = 0f;
			}
		}
		currentSample++;
		return num * gain;
	}

	public void FadeOut()
	{
		releaseStartSample = currentSample;
		endSample = releaseStartSample + releaseTimeSamples;
	}
}


using UnityEngine;

public class Sound : MonoBehaviour, IClientComponent
{
	public static float volumeExponent = Mathf.Log(Mathf.Sqrt(10f), 2f);

	public SoundDefinition definition;

	public SoundModifier[] modifiers;

	public SoundSource soundSource;

	public AudioSource[] audioSources = (AudioSource[])(object)new AudioSource[2];

	[SerializeField]
	private SoundFade _fade;

	[SerializeField]
	private SoundModulation _modulation;

	[SerializeField]
	private SoundOcclusion _occlusion;

	public SoundFade fade => _fade;

	public SoundModulation modulation => _modulation;

	public SoundOcclusion occlusion => _occlusion;
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

[CreateAssetMenu(menuName = "Rust/Sound Class")]
public class SoundClass : ScriptableObject
{
	[Header("Mixer Settings")]
	public AudioMixerGroup output;

	public AudioMixerGroup firstPersonOutput;

	[Header("Occlusion Settings")]
	public bool enableOcclusion;

	public bool playIfOccluded = true;

	public float occlusionGain = 1f;

	[Tooltip("Use this mixer group when the sound is occluded to save DSP CPU usage. Only works for non-looping sounds.")]
	public AudioMixerGroup occludedOutput;

	[Header("Voice Limiting")]
	public int globalVoiceMaxCount = 100;

	public int priority = 128;

	public List<SoundDefinition> definitions = new List<SoundDefinition>();
}


using UnityEngine;

public class SoundClassTest : MonoBehaviour
{
	public SoundClass soundClass;

	public float soundInterval = 0.5f;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SoundDefinition : ScriptableObject
{
	[Serializable]
	public class DistanceAudioClipList
	{
		public int distance;

		[Horizontal(2, -1)]
		public List<WeightedAudioClip> audioClips;
	}

	public GameObjectRef template;

	[Horizontal(2, -1)]
	public List<WeightedAudioClip> weightedAudioClips = new List<WeightedAudioClip>
	{
		new WeightedAudioClip()
	};

	public List<DistanceAudioClipList> distanceAudioClips;

	public SoundClass soundClass;

	public bool defaultToFirstPerson;

	public bool loop;

	public bool randomizeStartPosition;

	public bool useHighQualityFades;

	[Range(0f, 1f)]
	public float volume = 1f;

	[Range(0f, 1f)]
	public float volumeVariation;

	[Range(-3f, 3f)]
	public float pitch = 1f;

	[Range(0f, 1f)]
	public float pitchVariation;

	[Header("Voice limiting")]
	public bool dontVoiceLimit;

	public int globalVoiceMaxCount = 100;

	public int localVoiceMaxCount = 100;

	public float localVoiceRange = 10f;

	public float voiceLimitFadeOutTime = 0.05f;

	public float localVoiceDebounceTime = 0.1f;

	[Header("Occlusion Settings")]
	public bool forceOccludedPlayback;

	[Header("Doppler")]
	public bool enableDoppler;

	public float dopplerAmount = 0.18f;

	public float dopplerScale = 1f;

	public float dopplerAdjustmentRate = 1f;

	[Header("Custom curves")]
	public AnimationCurve falloffCurve;

	public bool useCustomFalloffCurve;

	public AnimationCurve spatialBlendCurve;

	public bool useCustomSpatialBlendCurve;

	public AnimationCurve spreadCurve;

	public bool useCustomSpreadCurve;

	public float maxDistance
	{
		get
		{
			if (template == null)
			{
				return 0f;
			}
			AudioSource component = template.Get().GetComponent<AudioSource>();
			if ((Object)(object)component == (Object)null)
			{
				return 0f;
			}
			return component.maxDistance;
		}
	}

	public float GetLength()
	{
		float num = 0f;
		for (int i = 0; i < weightedAudioClips.Count; i++)
		{
			AudioClip audioClip = weightedAudioClips[i].audioClip;
			if (Object.op_Implicit((Object)(object)audioClip))
			{
				num = Mathf.Max(audioClip.length, num);
			}
		}
		for (int j = 0; j < distanceAudioClips.Count; j++)
		{
			List<WeightedAudioClip> audioClips = distanceAudioClips[j].audioClips;
			for (int k = 0; k < audioClips.Count; k++)
			{
				AudioClip audioClip2 = audioClips[k].audioClip;
				if (Object.op_Implicit((Object)(object)audioClip2))
				{
					num = Mathf.Max(audioClip2.length, num);
				}
			}
		}
		float num2 = 1f / (pitch - pitchVariation);
		return num * num2;
	}

	public Sound Play()
	{
		return null;
	}

	public Sound Play(GameObject forGameObject)
	{
		return null;
	}
}


using System;
using System.Collections.Generic;

[Serializable]
public class DistanceAudioClipList
{
	public int distance;

	[Horizontal(2, -1)]
	public List<WeightedAudioClip> audioClips;
}


using UnityEngine;

public class SoundFade : MonoBehaviour, IClientComponent
{
	public enum Direction
	{
		In,
		Out
	}

	public SoundFadeHQAudioFilter hqFadeFilter;

	public float currentGain = 1f;

	public float startingGain;

	public float finalGain = 1f;

	public int sampleRate = 44100;

	public bool highQualityFadeCompleted;

	public float length;

	public Direction currentDirection;
}


public enum Direction
{
	In,
	Out
}


using UnityEngine;

public class SoundFadeHQAudioFilter : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class SoundFollowCollider : MonoBehaviour, IClientComponent
{
	public SoundDefinition soundDefinition;

	public Sound sound;

	public Bounds soundFollowBounds;

	public bool startImmediately;
}


public class SoundManager : SingletonComponent<SoundManager>, IClientComponent
{
	public SoundClass defaultSoundClass;
}


using UnityEngine;

public class SoundModifier : MonoBehaviour
{
	[HideInInspector]
	public Sound sound;
}


using System;
using Facepunch;
using UnityEngine;

public class SoundModulation : MonoBehaviour, IClientComponent
{
	public enum Parameter
	{
		Gain,
		Pitch,
		Spread,
		MaxDistance
	}

	[Serializable]
	public class Modulator : IPooled
	{
		public Parameter param;

		public float value = 1f;

		void IPooled.LeavePool()
		{
		}

		void IPooled.EnterPool()
		{
			param = Parameter.Gain;
			value = 1f;
		}
	}

	private const int parameterCount = 4;
}


public enum Parameter
{
	Gain,
	Pitch,
	Spread,
	MaxDistance
}


using System;
using Facepunch;

[Serializable]
public class Modulator : IPooled
{
	public Parameter param;

	public float value = 1f;

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		param = Parameter.Gain;
		value = 1f;
	}
}


using UnityEngine;

public class SoundOcclusion : MonoBehaviour
{
	public LayerMask occlusionLayerMask;
}


using UnityEngine;

public class SoundPlayer : BaseMonoBehaviour, IClientComponent
{
	public SoundDefinition soundDefinition;

	public bool playImmediately = true;

	public float minStartDelay;

	public float maxStartDelay;

	public bool debugRepeat;

	public bool pending;

	public Vector3 soundOffset = Vector3.zero;
}


using UnityEngine;

public class SoundPlayerCull : MonoBehaviour, IClientComponent, ILOD
{
	public SoundPlayer soundPlayer;

	public float cullDistance = 100f;
}


using UnityEngine;

public class SoundPlayerCullLODComponent : LODComponent
{
	public float Distance = 100f;

	public SoundPlayer TargetSoundPlayer;

	private void OnValidate()
	{
		if ((Object)(object)TargetSoundPlayer == (Object)null)
		{
			TargetSoundPlayer = ((Component)this).GetComponent<SoundPlayer>();
		}
	}
}


public class SoundRandomizer
{
}


using UnityEngine;

[RequireComponent(typeof(SoundPlayer))]
public class SoundRepeater : MonoBehaviour
{
	public float interval = 5f;

	public SoundPlayer player;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SoundSource : MonoBehaviour, IClientComponentEx, ILOD
{
	[Serializable]
	public class OcclusionPoint
	{
		public Vector3 offset = Vector3.zero;

		public bool isOccluded;
	}

	[Header("Occlusion")]
	public bool handleOcclusionChecks;

	public LayerMask occlusionLayerMask;

	public List<OcclusionPoint> occlusionPoints = new List<OcclusionPoint>();

	public bool isOccluded;

	public float occlusionAmount;

	public float lodDistance = 100f;

	public bool inRange;

	public virtual void PreClientComponentCull(IPrefabProcessor p)
	{
		p.RemoveComponent((Component)(object)this);
	}

	public bool IsSyncedToParent()
	{
		return false;
	}
}


using System;
using UnityEngine;

[Serializable]
public class OcclusionPoint
{
	public Vector3 offset = Vector3.zero;

	public bool isOccluded;
}


using UnityEngine;

public class SoundVoiceLimiter : MonoBehaviour, IClientComponent
{
	public int maxSimultaneousSounds = 5;
}


using UnityEngine;

public class TimeBasedSoundSpread : SoundModifier
{
	public AnimationCurve spreadCurve;

	public AnimationCurve wanderIntensityCurve;
}


using System;
using UnityEngine;

[Serializable]
public class WeightedAudioClip
{
	public AudioClip audioClip;

	public int weight = 1;
}


using System;

public class AttractionPoint : PrefabAttribute
{
	public string groupName;

	protected override Type GetIndexedType()
	{
		return typeof(AttractionPoint);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BuildingProximity : PrefabAttribute
{
	public struct ProximityInfo
	{
		public bool hit;

		public bool connection;

		public Line line;

		public float sqrDist;
	}

	private const float check_radius = 2f;

	private const float check_forgiveness = 0.01f;

	private const float foundation_width = 3f;

	private const float foundation_extents = 1.5f;

	public static bool Check(BasePlayer player, Construction construction, Vector3 position, Quaternion rotation)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(position, rotation, construction.bounds);
		float radius = ((Vector3)(ref val.extents)).magnitude + 2f;
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(val.position, radius, list, 2097152, (QueryTriggerInteraction)2);
		uint num = 0u;
		for (int i = 0; i < list.Count; i++)
		{
			BuildingBlock buildingBlock = list[i];
			Construction blockDefinition = buildingBlock.blockDefinition;
			Vector3 position2 = ((Component)buildingBlock).transform.position;
			Quaternion rotation2 = ((Component)buildingBlock).transform.rotation;
			ProximityInfo proximity = GetProximity(construction, position, rotation, blockDefinition, position2, rotation2);
			ProximityInfo proximity2 = GetProximity(blockDefinition, position2, rotation2, construction, position, rotation);
			ProximityInfo proximityInfo = default(ProximityInfo);
			proximityInfo.hit = proximity.hit || proximity2.hit;
			proximityInfo.connection = proximity.connection || proximity2.connection;
			if (proximity.sqrDist <= proximity2.sqrDist)
			{
				proximityInfo.line = proximity.line;
				proximityInfo.sqrDist = proximity.sqrDist;
			}
			else
			{
				proximityInfo.line = proximity2.line;
				proximityInfo.sqrDist = proximity2.sqrDist;
			}
			if (proximityInfo.connection)
			{
				BuildingManager.Building building = buildingBlock.GetBuilding();
				if (building != null)
				{
					BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
					if ((Object)(object)dominatingBuildingPrivilege != (Object)null)
					{
						if (!construction.canBypassBuildingPermission && !dominatingBuildingPrivilege.CanBuild(player))
						{
							Construction.lastPlacementError = Phrase.op_Implicit(ConstructionErrors.CannotAttachToUnauthorized.translated);
							Pool.FreeUnmanaged<BuildingBlock>(ref list);
							return true;
						}
						if (num == 0)
						{
							num = building.ID;
						}
						else if (num != building.ID)
						{
							if (!dominatingBuildingPrivilege.CanBuild(player))
							{
								Construction.lastPlacementError = ConstructionErrors.CannotAttachToUnauthorized;
							}
							else
							{
								Construction.lastPlacementError = ConstructionErrors.CannotConnectTwoBuildings;
							}
							Pool.FreeUnmanaged<BuildingBlock>(ref list);
							return true;
						}
					}
				}
			}
			if (proximityInfo.hit)
			{
				Vector3 val2 = proximityInfo.line.point1 - proximityInfo.line.point0;
				if (!(Mathf.Abs(val2.y) > 1.49f) && !(Vector3Ex.Magnitude2D(val2) > 1.49f))
				{
					string translated = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID).info.name.translated;
					Construction.lastPlacementError = Phrase.op_Implicit(string.Format(ConstructionErrors.TooCloseTo.translated, translated));
					Construction.lastPlacementErrorIsDetailed = true;
					Pool.FreeUnmanaged<BuildingBlock>(ref list);
					return true;
				}
			}
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
		return false;
	}

	public static ProximityInfo GetProximity(Construction construction1, Vector3 position1, Quaternion rotation1, Construction construction2, Vector3 position2, Quaternion rotation2)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		ProximityInfo result = default(ProximityInfo);
		result.hit = false;
		result.connection = false;
		result.line = default(Line);
		result.sqrDist = float.MaxValue;
		for (int i = 0; i < construction1.allSockets.Length; i++)
		{
			ConstructionSocket constructionSocket = construction1.allSockets[i] as ConstructionSocket;
			if (constructionSocket == null)
			{
				continue;
			}
			for (int j = 0; j < construction2.allSockets.Length; j++)
			{
				Socket_Base socket = construction2.allSockets[j];
				if (constructionSocket.CanConnect(position1, rotation1, socket, position2, rotation2))
				{
					result.connection = true;
					return result;
				}
			}
		}
		if (construction1.isServer)
		{
			for (int k = 0; k < construction1.allSockets.Length; k++)
			{
				Socket_Base socket_Base = construction1.allSockets[k];
				if (!(socket_Base is NeighbourSocket) && !(socket_Base is StabilitySocket))
				{
					continue;
				}
				for (int l = 0; l < construction2.allSockets.Length; l++)
				{
					Socket_Base socket2 = construction2.allSockets[l];
					if (socket_Base.CanConnect(position1, rotation1, socket2, position2, rotation2))
					{
						result.connection = true;
						return result;
					}
				}
			}
		}
		if (!result.connection && construction1.allProximities.Length != 0)
		{
			Line val = default(Line);
			for (int m = 0; m < construction1.allSockets.Length; m++)
			{
				ConstructionSocket constructionSocket2 = construction1.allSockets[m] as ConstructionSocket;
				if (constructionSocket2 == null || constructionSocket2.socketType != ConstructionSocket.Type.Wall)
				{
					continue;
				}
				Vector3 selectPivot = constructionSocket2.GetSelectPivot(position1, rotation1);
				for (int n = 0; n < construction2.allProximities.Length; n++)
				{
					Vector3 selectPivot2 = construction2.allProximities[n].GetSelectPivot(position2, rotation2);
					((Line)(ref val))..ctor(selectPivot, selectPivot2);
					Vector3 val2 = val.point1 - val.point0;
					float sqrMagnitude = ((Vector3)(ref val2)).sqrMagnitude;
					if (sqrMagnitude < result.sqrDist)
					{
						result.hit = true;
						result.line = val;
						result.sqrDist = sqrMagnitude;
					}
				}
			}
		}
		return result;
	}

	public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return position + rotation * worldPosition;
	}

	protected override Type GetIndexedType()
	{
		return typeof(BuildingProximity);
	}
}


public struct ProximityInfo
{
	public bool hit;

	public bool connection;

	public Line line;

	public float sqrDist;
}


using System;
using UnityEngine;

public class ConditionalModel : PrefabAttribute
{
	public GameObjectRef prefab;

	public bool onClient = true;

	public bool onServer = true;

	public bool IsImportant;

	[NonSerialized]
	public ModelConditionTest[] conditions;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		conditions = ((Component)this).GetComponentsInChildren<ModelConditionTest>(true);
	}

	public bool RunTests(BaseEntity parent)
	{
		for (int i = 0; i < conditions.Length; i++)
		{
			if (!conditions[i].DoTest(parent))
			{
				return false;
			}
		}
		return true;
	}

	public bool RunTestsExceptFoundationSide(BaseEntity parent)
	{
		for (int i = 0; i < conditions.Length; i++)
		{
			if (!(conditions[i] is ModelConditionTest_FoundationSide) && !conditions[i].DoTest(parent))
			{
				return false;
			}
		}
		return true;
	}

	public virtual GameObject InstantiateSkin(BaseEntity parent)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (!onServer && isServer)
		{
			return null;
		}
		GameObject val = gameManager.CreatePrefab(prefab.resourcePath, ((Component)parent).transform, active: false);
		if (Object.op_Implicit((Object)(object)val))
		{
			val.transform.localPosition = worldPosition;
			val.transform.localRotation = worldRotation;
			val.AwakeFromInstantiate();
		}
		return val;
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConditionalModel);
	}
}


using System;
using UnityEngine;

public class ConditionalModelWallpaper : ConditionalModel
{
	public bool softSide;

	public override GameObject InstantiateSkin(BaseEntity parent)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if (!onServer && isServer)
		{
			return null;
		}
		GameObject val = gameManager.CreatePrefab(prefab.resourcePath, ((Component)parent).transform, active: false);
		if ((Object)(object)val != (Object)null)
		{
			val.transform.localPosition = worldPosition;
			val.transform.localRotation = worldRotation;
			BuildingBlock buildingBlock = parent as BuildingBlock;
			if ((Object)(object)buildingBlock != (Object)null)
			{
				ItemDefinition itemDefForCategory = WallpaperSettings.GetItemDefForCategory(WallpaperPlanner.Settings.GetCategory(buildingBlock, (!softSide) ? 1 : 0));
				SkinHelpers.SetSkin(val, itemDefForCategory, softSide ? buildingBlock.wallpaperID : buildingBlock.wallpaperID2);
				float num = (softSide ? buildingBlock.wallpaperRotation : buildingBlock.wallpaperRotation2);
				if (num != 0f)
				{
					Vector3 localEulerAngles = val.transform.localEulerAngles;
					localEulerAngles.y += num;
					val.transform.localRotation = Quaternion.Euler(localEulerAngles);
				}
				val.AwakeFromInstantiate();
			}
		}
		return val;
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConditionalModel);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Serialization;

public class Construction : PrefabAttribute
{
	public class Grade
	{
		public BuildingGrade grade;

		public float maxHealth;

		public List<ItemAmount> costToBuild;

		public PhysicMaterial physicMaterial => grade.physicMaterial;

		public ProtectionProperties damageProtecton => grade.damageProtecton;
	}

	public struct Target
	{
		public bool valid;

		public Ray ray;

		public BaseEntity entity;

		public Socket_Base socket;

		public bool onTerrain;

		public Vector3 position;

		public Vector3 normal;

		public Vector3 rotation;

		public BasePlayer player;

		public bool inBuildingPrivilege;

		public bool isHoldingShift;

		public Quaternion GetWorldRotation(bool female)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			Quaternion val = socket.rotation;
			if (socket.male && socket.female && female)
			{
				val = socket.rotation * Quaternion.Euler(180f, 0f, 180f);
			}
			return ((Component)entity).transform.rotation * val;
		}

		public Vector3 GetWorldPosition()
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			Matrix4x4 localToWorldMatrix = ((Component)entity).transform.localToWorldMatrix;
			return ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(socket.position);
		}
	}

	public struct Placement
	{
		public Vector3 position;

		public Quaternion rotation;

		public bool isPopulated;

		public readonly bool isHoldingShift;

		public Transform transform;

		public Placement(Target target)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			isHoldingShift = target.isHoldingShift;
			position = Vector3.zero;
			rotation = Quaternion.identity;
			isPopulated = true;
			transform = null;
			if ((Object)(object)target.entity != (Object)null)
			{
				transform = ((Component)target.entity).transform;
			}
		}
	}

	public BaseEntity.Menu.Option info;

	public bool canBypassBuildingPermission;

	public bool showBuildingBlockedPreview = true;

	[InspectorName("Can bypass road checks")]
	public bool canPlaceOnRoads;

	[FormerlySerializedAs("canRotate")]
	public bool canRotateBeforePlacement;

	[FormerlySerializedAs("canRotate")]
	public bool canRotateAfterPlacement;

	public bool checkVolumeOnRotate;

	public bool checkVolumeOnUpgrade;

	public bool canPlaceAtMaxDistance;

	public bool placeOnWater;

	public bool overridePlacementLayer;

	public LayerMask overridedPlacementLayer;

	public Vector3 rotationAmount = new Vector3(0f, 90f, 0f);

	public Vector3 applyStartingRotation = Vector3.zero;

	public Transform deployOffset;

	public bool enforceLineOfSightCheckAgainstParentEntity;

	public bool canSnap;

	public float holdToPlaceDuration;

	public bool canFloodFillSockets;

	[Space]
	public bool alternativeLOSChecks;

	public Vector3[] alternativeLOSPositions;

	public bool canUseLastValidPosition = true;

	[Range(0f, 10f)]
	public float healthMultiplier = 1f;

	[Range(0f, 10f)]
	public float costMultiplier = 1f;

	[Range(1f, 50f)]
	public float maxplaceDistance = 4f;

	[Range(0f, 10f)]
	public float minPlaceDistance = 1f;

	public Mesh guideMesh;

	[NonSerialized]
	public Socket_Base[] allSockets;

	[NonSerialized]
	public BuildingProximity[] allProximities;

	[NonSerialized]
	public ConstructionGrade defaultGrade;

	[NonSerialized]
	public SocketHandle socketHandle;

	[NonSerialized]
	public Bounds bounds;

	[NonSerialized]
	public bool isBuildingPrivilege;

	[NonSerialized]
	public bool isSleepingBag;

	[NonSerialized]
	public ConstructionGrade[] grades;

	[NonSerialized]
	public Deployable deployable;

	[NonSerialized]
	public ConstructionPlaceholder placeholder;

	[ReplicatedVar]
	public static bool alternativeLOSChecks_enabled = true;

	public static Phrase lastPlacementError = Phrase.op_Implicit(string.Empty);

	public static bool lastPlacementErrorIsDetailed;

	public static string lastPlacementErrorDebug;

	public static BuildingBlock lastBuildingBlockError;

	public BaseEntity CreateConstruction(Target target, bool bNeedsValidPlacement = false)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = GameManager.server.CreatePrefab(fullName, Vector3.zero, Quaternion.identity, active: false);
		bool flag = UpdatePlacement(val.transform, this, ref target);
		BaseEntity baseEntity = val.ToBaseEntity();
		if (bNeedsValidPlacement && !flag)
		{
			if (baseEntity.IsValid())
			{
				baseEntity.Kill();
			}
			else
			{
				GameManager.Destroy(val);
			}
			return null;
		}
		DecayEntity decayEntity = baseEntity as DecayEntity;
		if (Object.op_Implicit((Object)(object)decayEntity))
		{
			decayEntity.AttachToBuilding(target.entity as DecayEntity);
		}
		return baseEntity;
	}

	public bool HasMaleSockets(Target target)
	{
		Socket_Base[] array = allSockets;
		foreach (Socket_Base socket_Base in array)
		{
			if (socket_Base.male && !socket_Base.maleDummy && socket_Base.TestTarget(target))
			{
				return true;
			}
		}
		return false;
	}

	public void FindMaleSockets(Target target, List<Socket_Base> sockets)
	{
		Socket_Base[] array = allSockets;
		foreach (Socket_Base socket_Base in array)
		{
			if (socket_Base.male && !socket_Base.maleDummy && socket_Base.TestTarget(target))
			{
				sockets.Add(socket_Base);
			}
		}
	}

	public ConstructionGrade GetGrade(BuildingGrade.Enum iGrade, ulong iSkin)
	{
		ConstructionGrade[] array = grades;
		foreach (ConstructionGrade constructionGrade in array)
		{
			if (constructionGrade.gradeBase.type == iGrade && constructionGrade.gradeBase.skin == iSkin)
			{
				return constructionGrade;
			}
		}
		return defaultGrade;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		isBuildingPrivilege = Object.op_Implicit((Object)(object)rootObj.GetComponent<BuildingPrivlidge>());
		isSleepingBag = Object.op_Implicit((Object)(object)rootObj.GetComponent<SleepingBag>());
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
		deployable = ((Component)this).GetComponent<Deployable>();
		placeholder = ((Component)this).GetComponentInChildren<ConstructionPlaceholder>();
		allSockets = ((Component)this).GetComponentsInChildren<Socket_Base>(true);
		allProximities = ((Component)this).GetComponentsInChildren<BuildingProximity>(true);
		socketHandle = ((Component)this).GetComponentsInChildren<SocketHandle>(true).FirstOrDefault();
		grades = rootObj.GetComponents<ConstructionGrade>();
		ConstructionGrade[] array = grades;
		foreach (ConstructionGrade constructionGrade in array)
		{
			if (!(constructionGrade == null))
			{
				constructionGrade.construction = this;
				if (!(defaultGrade != null))
				{
					defaultGrade = constructionGrade;
				}
			}
		}
	}

	protected override Type GetIndexedType()
	{
		return typeof(Construction);
	}

	public bool HasAlternativeLOSChecks()
	{
		if (alternativeLOSChecks_enabled && alternativeLOSChecks && alternativeLOSPositions != null)
		{
			return alternativeLOSPositions.Length != 0;
		}
		return false;
	}

	public bool UpdatePlacement(Transform transform, Construction common, ref Target target)
	{
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_045e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0464: Unknown result type (might be due to invalid IL or missing references)
		//IL_046a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_041d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		//IL_0491: Unknown result type (might be due to invalid IL or missing references)
		//IL_0533: Unknown result type (might be due to invalid IL or missing references)
		//IL_053a: Unknown result type (might be due to invalid IL or missing references)
		//IL_054d: Unknown result type (might be due to invalid IL or missing references)
		if (!target.valid)
		{
			if (common.placeOnWater)
			{
				lastPlacementError = ConstructionErrors.WantsWater;
			}
			return false;
		}
		if (!common.canBypassBuildingPermission && !target.player.CanBuild())
		{
			lastPlacementError = ConstructionErrors.NoPermission;
			return false;
		}
		List<Socket_Base> list = Pool.Get<List<Socket_Base>>();
		common.FindMaleSockets(target, list);
		foreach (Socket_Base item in list)
		{
			Placement placement = default(Placement);
			if ((Object)(object)target.entity != (Object)null && target.socket != null && target.entity.IsOccupied(target.socket))
			{
				continue;
			}
			if (!placement.isPopulated)
			{
				placement = item.DoPlacement(target);
			}
			if ((Object)(object)target.player != (Object)null && target.player.IsInTutorial)
			{
				TutorialIsland currentTutorialIsland = target.player.GetCurrentTutorialIsland();
				if ((Object)(object)currentTutorialIsland != (Object)null && !currentTutorialIsland.CheckPlacement(common, target, ref placement))
				{
					placement = default(Placement);
				}
			}
			if (!placement.isPopulated)
			{
				continue;
			}
			if (target.player.IsInCreativeMode && Creative.freePlacement)
			{
				transform.SetPositionAndRotation(placement.position, placement.rotation);
				return true;
			}
			if (!item.CheckSocketMods(ref placement))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				continue;
			}
			if (!TestPlacingThroughRock(ref placement, target))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.ThroughRock;
				continue;
			}
			if (common.HasAlternativeLOSChecks())
			{
				if (target.socket == null && !TestPlacingThroughWall(ref placement, transform, common, target))
				{
					transform.position = placement.position;
					transform.rotation = placement.rotation;
					lastPlacementError = ConstructionErrors.ThroughWalls;
					lastPlacementErrorDebug = "Placing through walls";
					continue;
				}
				if (!Planner.HasLineOfSight(ref placement, common, target))
				{
					transform.position = placement.position;
					transform.rotation = placement.rotation;
					lastPlacementError = ConstructionErrors.LineOfSightBlocked;
					continue;
				}
			}
			else if (!TestPlacingThroughWall(ref placement, transform, common, target))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.ThroughWalls;
				lastPlacementErrorDebug = "Placing through walls";
				continue;
			}
			if (!TestPlacingCloseToRoad(ref placement, target, common))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.TooCloseToRoad;
				continue;
			}
			if (target.entity is Door && target.socket == null)
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.CantDeployOnDoor;
				continue;
			}
			if (Vector3.Distance(placement.position, target.player.eyes.position) > common.maxplaceDistance + 1f)
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.TooFarAway;
				continue;
			}
			DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(prefabID);
			if (DeployVolume.Check(placement.position, placement.rotation, volumes))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				if ((Object)(object)DeployVolume.LastDeployHit != (Object)null)
				{
					lastPlacementErrorDebug = ((Object)DeployVolume.LastDeployHit).name;
					string blockedByErrorFromCollider = ConstructionErrors.GetBlockedByErrorFromCollider(DeployVolume.LastDeployHit, target.player);
					if (!string.IsNullOrEmpty(blockedByErrorFromCollider))
					{
						lastPlacementError = Phrase.op_Implicit(blockedByErrorFromCollider);
						lastPlacementErrorIsDetailed = true;
						continue;
					}
				}
				lastPlacementError = ConstructionErrors.NotEnoughSpace;
				continue;
			}
			if (BuildingProximity.Check(target.player, this, placement.position, placement.rotation))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				continue;
			}
			if (common.isBuildingPrivilege && !target.player.CanPlaceBuildingPrivilege(placement.position, placement.rotation, common.bounds))
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.StackPrivilege;
				continue;
			}
			bool flag = target.player.IsBuildingBlocked(placement.position, placement.rotation, common.bounds, cached: false);
			if (!common.canBypassBuildingPermission && flag)
			{
				transform.position = placement.position;
				transform.rotation = placement.rotation;
				lastPlacementError = ConstructionErrors.NoPermission;
				continue;
			}
			target.inBuildingPrivilege = flag;
			transform.SetPositionAndRotation(placement.position, placement.rotation);
			if ((!((Object)(object)target.player != (Object)null) || !target.player.IsInCreativeMode || !Creative.bypassHoldToPlaceDuration) && common.holdToPlaceDuration > 0f && (Object)(object)target.player != (Object)null && isServer && target.player.GetHeldEntity() is Planner planner && (Vector3.Distance(((Component)target.player).transform.position, planner.serverStartDurationPlacementPosition) > 1f || Mathf.Abs(TimeSince.op_Implicit(planner.serverStartDurationPlacementTime) - common.holdToPlaceDuration) > 0.5f))
			{
				return false;
			}
			Pool.FreeUnmanaged<Socket_Base>(ref list);
			return true;
		}
		Pool.FreeUnmanaged<Socket_Base>(ref list);
		return false;
	}

	private bool TestPlacingThroughRock(ref Placement placement, Target target)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(placement.position, Vector3.one, placement.rotation, bounds);
		Vector3 center = target.player.GetCenter(ducked: true);
		Vector3 origin = ((Ray)(ref target.ray)).origin;
		if (Physics.Linecast(center, origin, 65536, (QueryTriggerInteraction)1))
		{
			return false;
		}
		RaycastHit val2 = default(RaycastHit);
		Vector3 val3 = (((OBB)(ref val)).Trace(target.ray, ref val2, float.PositiveInfinity) ? ((RaycastHit)(ref val2)).point : ((OBB)(ref val)).ClosestPoint(origin));
		if (Physics.Linecast(origin, val3, 65536, (QueryTriggerInteraction)1))
		{
			return false;
		}
		return true;
	}

	private static bool TestPlacingThroughWall(ref Placement placement, Transform transform, Construction common, Target target)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = placement.position;
		if ((Object)(object)common.deployOffset != (Object)null)
		{
			val += placement.rotation * common.deployOffset.localPosition;
		}
		Vector3 val2 = val - ((Ray)(ref target.ray)).origin;
		RaycastHit hit = default(RaycastHit);
		if (!Physics.Raycast(((Ray)(ref target.ray)).origin, ((Vector3)(ref val2)).normalized, ref hit, ((Vector3)(ref val2)).magnitude, 2097152))
		{
			return true;
		}
		StabilityEntity stabilityEntity = hit.GetEntity() as StabilityEntity;
		if (!common.enforceLineOfSightCheckAgainstParentEntity && (Object)(object)stabilityEntity != (Object)null && (Object)(object)target.entity == (Object)(object)stabilityEntity)
		{
			return true;
		}
		if (((Vector3)(ref val2)).magnitude - ((RaycastHit)(ref hit)).distance < 0.2f)
		{
			return true;
		}
		transform.SetPositionAndRotation(((RaycastHit)(ref hit)).point, placement.rotation);
		return false;
	}

	private bool TestPlacingCloseToRoad(ref Placement placement, Target target, Construction construction)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		if (construction.canPlaceOnRoads)
		{
			return true;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		if ((Object)(object)heightMap == (Object)null)
		{
			return true;
		}
		if ((Object)(object)topologyMap == (Object)null)
		{
			return true;
		}
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(placement.position, Vector3.one, placement.rotation, bounds);
		float num = Mathf.Abs(heightMap.GetHeight(val.position) - val.position.y);
		if (num > 9f)
		{
			return true;
		}
		float radius = Mathf.Lerp(3f, 0f, num / 9f);
		Vector3 position = val.position;
		Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
		Vector3 point2 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
		Vector3 point3 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
		Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
		int topology = topologyMap.GetTopology(position, radius);
		int topology2 = topologyMap.GetTopology(point, radius);
		int topology3 = topologyMap.GetTopology(point2, radius);
		int topology4 = topologyMap.GetTopology(point3, radius);
		int topology5 = topologyMap.GetTopology(point4, radius);
		if (((topology | topology2 | topology3 | topology4 | topology5) & 0x80800) == 0)
		{
			return true;
		}
		return false;
	}

	public virtual bool ShowAsNeutral(Target target)
	{
		return target.inBuildingPrivilege;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class Grade
{
	public BuildingGrade grade;

	public float maxHealth;

	public List<ItemAmount> costToBuild;

	public PhysicMaterial physicMaterial => grade.physicMaterial;

	public ProtectionProperties damageProtecton => grade.damageProtecton;
}


using UnityEngine;

public struct Target
{
	public bool valid;

	public Ray ray;

	public BaseEntity entity;

	public Socket_Base socket;

	public bool onTerrain;

	public Vector3 position;

	public Vector3 normal;

	public Vector3 rotation;

	public BasePlayer player;

	public bool inBuildingPrivilege;

	public bool isHoldingShift;

	public Quaternion GetWorldRotation(bool female)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = socket.rotation;
		if (socket.male && socket.female && female)
		{
			val = socket.rotation * Quaternion.Euler(180f, 0f, 180f);
		}
		return ((Component)entity).transform.rotation * val;
	}

	public Vector3 GetWorldPosition()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = ((Component)entity).transform.localToWorldMatrix;
		return ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(socket.position);
	}
}


using UnityEngine;

public struct Placement
{
	public Vector3 position;

	public Quaternion rotation;

	public bool isPopulated;

	public readonly bool isHoldingShift;

	public Transform transform;

	public Placement(Target target)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		isHoldingShift = target.isHoldingShift;
		position = Vector3.zero;
		rotation = Quaternion.identity;
		isPopulated = true;
		transform = null;
		if ((Object)(object)target.entity != (Object)null)
		{
			transform = ((Component)target.entity).transform;
		}
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public static class ConstructionErrors
{
	public static readonly Phrase NoPermission = new Phrase("error_buildpermission", "You don't have permission to build here");

	public static readonly Phrase StackPrivilege = new Phrase("error_stackprivilege", "Cannot stack building privileges");

	public static readonly Phrase CantBuildWhileMoving = new Phrase("error_whilemoving", "You can't build this while moving");

	public static readonly Phrase ThroughRock = new Phrase("error_throughrock", "Placing through rock");

	public static readonly Phrase ThroughWalls = new Phrase("error_throughwalls", "Placing through walls");

	public static readonly Phrase InsideObjects = new Phrase("error_insideobjects", "Can't deploy inside objects");

	public static readonly Phrase TooCloseToRoad = new Phrase("error_tooclosetoroad", "Placing too close to road");

	public static readonly Phrase TooFarAway = new Phrase("error_toofar", "Too far away");

	public static readonly Phrase BlockedBy = new Phrase("error_blockedby", "Blocked by {0}");

	public static readonly Phrase BlockedByPlayer = new Phrase("error_blockedbyplayer", "Blocked by Player {0}");

	public static readonly Phrase BlockedByVehicle = new Phrase("error_blockedbyvehicle", "Blocked by Vehicle");

	public static readonly Phrase TooCloseTo = new Phrase("error_toocloseto", "Too close to {0}");

	public static readonly Phrase TooCloseToMonument = new Phrase("error_tooclosetomonument", "Cannot build this close to {0}");

	public static readonly Phrase BlockedByTree = new Phrase("error_blockedbytree", "Blocked by tree");

	public static readonly Phrase BlockedByTerrain = new Phrase("error_blockedbyterrain", "Blocked by terrain");

	public static readonly Phrase SkinNotOwned = new Phrase("error_skinnotowned", "Skin not owned");

	public static readonly Phrase CannotBuildInThisArea = new Phrase("error_cannotbuildarea", "Cannot build in this area");

	public static readonly Phrase NotEnoughSpace = new Phrase("error_notenoughspace", "Not enough space");

	public static readonly Phrase NotStableEnough = new Phrase("error_notstableenough", "Not stable enough");

	public static readonly Phrase MustPlaceOnConstruction = new Phrase("error_wantsconstruction", "Must be placed on a construction");

	public static readonly Phrase CantPlaceOnConstruction = new Phrase("error_doesnotwantconstruction", "Cannot be placed on constructions");

	public static readonly Phrase CantPlaceOnMonument = new Phrase("error_cantplaceonmonument", "Cannot be placed on monument");

	public static readonly Phrase NotInTerrain = new Phrase("error_notinterrain", "Not in terrain");

	public static readonly Phrase MustPlaceOnRoad = new Phrase("error_placement_needs_road", "Must be placed on road");

	public static readonly Phrase CantPlaceOnRoad = new Phrase("error_placement_no_road", "Cannot be placed on road");

	public static readonly Phrase InvalidAreaVehicleLarge = new Phrase("error_invalidarea_vehiclelarge", "Cannot deploy near a large vehicle");

	public static readonly Phrase InvalidAngle = new Phrase("error_invalidangle", "Invalid angle");

	public static readonly Phrase InvalidEntity = new Phrase("error_invalidentitycheck", "Invalid entity");

	public static readonly Phrase InvalidEntityType = new Phrase("error_invalidentitytype", "Invalid entity type");

	public static readonly Phrase WantsWater = new Phrase("error_inwater_wants", "Must be placed in water");

	public static readonly Phrase WantsWaterBody = new Phrase("error_inwater_wants_body", "Must be placed in a body of water");

	public static readonly Phrase InWater = new Phrase("error_inwater", "Can't be placed in water");

	public static readonly Phrase TooDeep = new Phrase("error_toodeep", "Water is too deep");

	public static readonly Phrase TooShallow = new Phrase("error_shallow", "Water is too shallow");

	public static readonly Phrase CouldntFindConstruction = new Phrase("error_counlndfindconstruction", "Couldn't find construction");

	public static readonly Phrase CouldntFindEntity = new Phrase("error_counlndfindentity", "Couldn't find entity");

	public static readonly Phrase CouldntFindSocket = new Phrase("error_counlndfindsocket", "Couldn't find socket");

	public static readonly Phrase Antihack = new Phrase("error_antihack", "Anti hack!");

	public static readonly Phrase AntihackWithReason = new Phrase("error_antihack_reason", "Anti hack! ({0})");

	public static readonly Phrase CantDeployOnDoor = new Phrase("error_cantdeployondoor", "Can't deploy on door");

	public static readonly Phrase DeployableMismatch = new Phrase("error_deployablemismatch", "Deployable mismatch!");

	public static readonly Phrase LineOfSightBlocked = new Phrase("error_lineofsightblocked", "Line of sight blocked");

	public static readonly Phrase ParentTooFar = new Phrase("error_parenttoofar", "Parent too far away");

	public static readonly Phrase SocketOccupied = new Phrase("error_sockectoccupied", "Target socket is occupied");

	public static readonly Phrase SocketNotFemale = new Phrase("error_socketnotfemale", "Target socket is not female");

	public static readonly Phrase WantsInside = new Phrase("error_wantsinside", "Must be placed inside your base");

	public static readonly Phrase WantsOutside = new Phrase("error_wantsoutside", "Can't be placed inside a base");

	public static readonly Phrase PlayerName = new Phrase("error_name_player", "Player {0}");

	public static readonly Phrase HorseName = new Phrase("error_name_horse", "Horse");

	public static readonly Phrase ModularCarName = new Phrase("error_name_modularcar", "Modular Car");

	public static readonly Phrase TreeName = new Phrase("error_name_tree", "Tree");

	public static readonly Phrase DebrisName = new Phrase("error_name_debris", "Debris");

	public static readonly Phrase OreName = new Phrase("error_name_ore", "Ore");

	public static readonly Phrase DroppedItemName = new Phrase("error_dropped_item", "Dropped item");

	public static readonly Phrase CannotAttachToUnauthorized = new Phrase("error_cannotattachtounauth", "Cannot attach to unauthorized building");

	public static readonly Phrase CannotConnectTwoBuildings = new Phrase("error_connecttwobuildings", "Cannot connect two buildings with cupboards");

	public static readonly Phrase CantUpgradeRecentlyDamaged = new Phrase("error_upgraderecentlydamaged", "Recently damaged, upgradable in {0} seconds");

	public static readonly Phrase CantRotateAnymore = new Phrase("grade_rotationblocked", "Can't rotate this block anymore");

	public static readonly Phrase CantDemolishAnymore = new Phrase("grade_demolishblocked", "Can't demolish this block anymore");

	public static string GetTranslatedNameFromEntity(BaseEntity entity, BasePlayer fromPlayer = null)
	{
		if (entity is ModularCar || entity is BaseVehicleModule)
		{
			return ModularCarName.translated;
		}
		if (entity is BaseVehicleSeat && entity.parentEntity.Get(serverside: false) is RidableHorse)
		{
			return HorseName.translated;
		}
		if (entity is BaseNPC2 baseNPC)
		{
			return baseNPC.displayName;
		}
		if (entity is RidableHorse || entity is HorseSaddle)
		{
			return HorseName.translated;
		}
		if (entity is HumanNPC humanNPC)
		{
			return humanNPC.displayName;
		}
		if (entity is BasePlayer { displayName: var arg } basePlayer)
		{
			if ((Object)(object)fromPlayer != (Object)null)
			{
				arg = NameHelper.GetPlayerNameStreamSafe(fromPlayer, basePlayer);
			}
			return string.Format(PlayerName.translated, arg);
		}
		if (entity is BuildingBlock buildingBlock)
		{
			return PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID).info.name.translated;
		}
		if (entity is DebrisEntity)
		{
			return DebrisName.translated;
		}
		if (entity is TreeEntity)
		{
			return TreeName.translated;
		}
		if (entity is OreResourceEntity)
		{
			return OreName.translated;
		}
		if (entity is DroppedItem)
		{
			return DroppedItemName.translated;
		}
		SprayCan.GetItemDefinitionForEntity(entity, out var def);
		if ((Object)(object)def != (Object)null)
		{
			return def.displayName.translated;
		}
		return string.Empty;
	}

	public static string GetBlockedByErrorFromEntity(BaseEntity entity, BasePlayer fromPlayer = null)
	{
		string translatedNameFromEntity = GetTranslatedNameFromEntity(entity, fromPlayer);
		if (!string.IsNullOrEmpty(translatedNameFromEntity))
		{
			return string.Format(BlockedBy.translated, translatedNameFromEntity);
		}
		return null;
	}

	public static string GetBlockedByErrorFromCollider(Collider col, BasePlayer fromPlayer = null)
	{
		PreventBuildingMonumentTag preventBuildingMonumentTag = GetPreventBuildingMonumentTag(col);
		if ((Object)(object)preventBuildingMonumentTag != (Object)null)
		{
			return string.Format(TooCloseToMonument.translated, preventBuildingMonumentTag.GetAttachedMonument().displayPhrase.translated);
		}
		BaseEntity baseEntity = col.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			return GetBlockedByErrorFromEntity(baseEntity, fromPlayer);
		}
		if (col is TerrainCollider)
		{
			return BlockedByTerrain.translated;
		}
		return null;
	}

	public static PreventBuildingMonumentTag GetPreventBuildingMonumentTag(Collider col)
	{
		PreventBuildingMonumentTag preventBuildingMonumentTag = default(PreventBuildingMonumentTag);
		if ((Object)(object)col != (Object)null && ((Component)col).TryGetComponent<PreventBuildingMonumentTag>(ref preventBuildingMonumentTag) && (Object)(object)preventBuildingMonumentTag.GetAttachedMonument() != (Object)null && !((Component)preventBuildingMonumentTag).gameObject.HasCustomTag(GameObjectTag.BlockPlacement))
		{
			return preventBuildingMonumentTag;
		}
		return null;
	}

	public static void Log(BasePlayer player, string message)
	{
		if (!((Object)(object)player == (Object)null) && !string.IsNullOrEmpty(message) && player.isServer && player.net.connection.info.GetBool("client.errortoasts_debug", false))
		{
			player.ChatMessage(message);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

public class ConstructionGrade : PrefabAttribute
{
	private struct CachedAmount
	{
		public List<ItemAmount> costs;

		public float cachedConVarMultiplier;
	}

	[NonSerialized]
	public Construction construction;

	public BuildingGrade gradeBase;

	public GameObjectRef skinObject;

	private Dictionary<BuildingGrade.Enum, CachedAmount> _costs;

	private float _costBuildPercent;

	public float maxHealth
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)gradeBase) || !construction)
			{
				return 0f;
			}
			return gradeBase.baseHealth * construction.healthMultiplier;
		}
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		_costs = new Dictionary<BuildingGrade.Enum, CachedAmount>();
		foreach (BuildingGrade.Enum value in Enum.GetValues(typeof(BuildingGrade.Enum)))
		{
			UpdateCosts(value);
		}
	}

	private void UpdateCosts(BuildingGrade.Enum grade)
	{
		List<ItemAmount> list = new List<ItemAmount>();
		float num = ((grade == gradeBase.type) ? 0.2f : 1f);
		float costMultiplier = ConVar.Decay.GetCostMultiplier(gradeBase.type);
		foreach (ItemAmount item in gradeBase.baseCost)
		{
			list.Add(new ItemAmount(item.itemDef, Mathf.Ceil(item.amount * construction.costMultiplier * num * costMultiplier)));
		}
		_costs[grade] = new CachedAmount
		{
			cachedConVarMultiplier = costMultiplier,
			costs = list
		};
	}

	public List<ItemAmount> CostToBuild(BuildingGrade.Enum fromGrade = BuildingGrade.Enum.None)
	{
		if (ConVar.Decay.GetCostMultiplier(gradeBase.type) != _costs[fromGrade].cachedConVarMultiplier)
		{
			UpdateCosts(fromGrade);
		}
		return _costs[fromGrade].costs;
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConstructionGrade);
	}
}


using System.Collections.Generic;

private struct CachedAmount
{
	public List<ItemAmount> costs;

	public float cachedConVarMultiplier;
}


using System;
using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode]
public class ConstructionPlaceholder : PrefabAttribute, IPrefabPreProcess
{
	public Mesh mesh;

	public Material material;

	public bool renderer;

	public bool collider;

	[NonSerialized]
	public MeshRenderer MeshRenderer;

	[NonSerialized]
	public MeshFilter MeshFilter;

	[NonSerialized]
	public MeshCollider MeshCollider;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		if (!clientside || !((Behaviour)this).enabled)
		{
			return;
		}
		if (renderer)
		{
			MeshFilter = rootObj.GetComponent<MeshFilter>();
			MeshRenderer = rootObj.GetComponent<MeshRenderer>();
			if (!Object.op_Implicit((Object)(object)MeshFilter))
			{
				MeshFilter = rootObj.AddComponent<MeshFilter>();
				MeshFilter.sharedMesh = mesh;
			}
			if (!Object.op_Implicit((Object)(object)MeshRenderer))
			{
				MeshRenderer = rootObj.AddComponent<MeshRenderer>();
				((Renderer)MeshRenderer).sharedMaterial = material;
				((Renderer)MeshRenderer).shadowCastingMode = (ShadowCastingMode)0;
			}
		}
		if (collider)
		{
			MeshCollider = rootObj.GetComponent<MeshCollider>();
			if (!Object.op_Implicit((Object)(object)MeshCollider))
			{
				MeshCollider = rootObj.AddComponent<MeshCollider>();
				MeshCollider.sharedMesh = mesh;
			}
		}
	}

	protected override Type GetIndexedType()
	{
		return typeof(ConstructionPlaceholder);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ConstructionSkin : BasePrefab
{
	public List<GameObject> conditionals;

	public ulong DetermineConditionalModelState(BuildingBlock parent)
	{
		ConditionalModel[] array = PrefabAttribute.server.FindAll<ConditionalModel>(prefabID);
		if (array.Length > 64)
		{
			Debug.LogError((object)("Too many ConditionalModels on " + ((Object)parent).name + "! Maximum supported is 64"));
		}
		ulong num = 0uL;
		for (int i = 0; i < array.Length && i < 64; i++)
		{
			if (array[i].RunTests(parent))
			{
				num |= (ulong)(1L << i);
			}
		}
		return num;
	}

	private void CreateConditionalModels(BuildingBlock parent)
	{
		ConditionalModel[] array = PrefabAttribute.server.FindAll<ConditionalModel>(prefabID);
		for (int i = 0; i < array.Length; i++)
		{
			if (!parent.GetConditionalModel(i))
			{
				continue;
			}
			GameObject val = array[i].InstantiateSkin(parent);
			if (!((Object)(object)val == (Object)null))
			{
				if (conditionals == null)
				{
					conditionals = new List<GameObject>();
				}
				conditionals.Add(val);
			}
		}
	}

	private void DestroyConditionalModels(BuildingBlock parent)
	{
		if (conditionals != null)
		{
			for (int i = 0; i < conditionals.Count; i++)
			{
				parent.gameManager.Retire(conditionals[i]);
			}
			conditionals.Clear();
		}
	}

	public virtual void Refresh(BuildingBlock parent)
	{
		DestroyConditionalModels(parent);
		CreateConditionalModels(parent);
	}

	public void Destroy(BuildingBlock parent)
	{
		DestroyConditionalModels(parent);
		parent.gameManager.Retire(((Component)this).gameObject);
	}

	public virtual uint GetStartingDetailColour(uint playerColourIndex)
	{
		return 0u;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Construction Colour Lookup")]
public class ConstructionSkin_ColourLookup : ScriptableObject
{
	public Texture2D Sample;

	public Color[] AllColours;
}


using UnityEngine;

public class ConstructionSkin_CustomDetail : ConstructionSkin
{
	public ConstructionSkin_ColourLookup ColourLookup;

	public override uint GetStartingDetailColour(uint playerColourIndex)
	{
		if (playerColourIndex != 0)
		{
			return (uint)Mathf.Clamp((float)playerColourIndex, 1f, (float)(ColourLookup.AllColours.Length + 1));
		}
		return (uint)Random.Range(1, ColourLookup.AllColours.Length + 1);
	}
}


using UnityEngine;

public class ConstructionSocket : Socket_Base
{
	public enum Type
	{
		None,
		Foundation,
		Floor,
		Misc,
		Doorway,
		Wall,
		Block,
		Ramp,
		StairsTriangle,
		Stairs,
		FloorFrameTriangle,
		Window,
		Shutters,
		WallFrame,
		FloorFrame,
		WindowDressing,
		DoorDressing,
		Elevator,
		DoubleDoorDressing
	}

	public Type socketType;

	public int rotationDegrees;

	public int rotationOffset;

	public bool restrictPlacementRotation;

	public bool restrictPlacementAngle;

	public float faceAngle;

	public float angleAllowed = 150f;

	public bool wantsInside;

	[Range(0f, 1f)]
	public float support = 1f;

	private static readonly Vector3[] outsideLookupDirs;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.6f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	private void OnDrawGizmosSelected()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (female)
		{
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.DrawWireCube(selectCenter, selectSize);
		}
	}

	public override bool TestTarget(Construction.Target target)
	{
		if (!base.TestTarget(target))
		{
			return false;
		}
		return IsCompatible(target.socket);
	}

	public override bool IsCompatible(Socket_Base socket)
	{
		if (!base.IsCompatible(socket))
		{
			return false;
		}
		ConstructionSocket constructionSocket = socket as ConstructionSocket;
		if (constructionSocket == null)
		{
			return false;
		}
		if (constructionSocket.socketType == Type.None || socketType == Type.None)
		{
			return false;
		}
		if (constructionSocket.socketType != socketType)
		{
			return false;
		}
		return true;
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		Matrix4x4 val = Matrix4x4.TRS(position, rotation, Vector3.one);
		Matrix4x4 val2 = Matrix4x4.TRS(socketPosition, socketRotation, Vector3.one);
		Vector3 val3 = ((Matrix4x4)(ref val)).MultiplyPoint3x4(worldPosition);
		Vector3 val4 = ((Matrix4x4)(ref val2)).MultiplyPoint3x4(socket.worldPosition);
		if (Vector3.Distance(val3, val4) > 0.02f)
		{
			return false;
		}
		Vector3 val5 = ((Matrix4x4)(ref val)).MultiplyVector(worldRotation * Vector3.forward);
		Vector3 val6 = ((Matrix4x4)(ref val2)).MultiplyVector(socket.worldRotation * Vector3.forward);
		float num = Vector3.Angle(val5, val6);
		if (male && female)
		{
			num = Mathf.Min(num, Vector3.Angle(-val5, val6));
		}
		if (socket.male && socket.female)
		{
			num = Mathf.Min(num, Vector3.Angle(val5, -val6));
		}
		if (num > 2f)
		{
			return false;
		}
		return true;
	}

	public bool TestRestrictedAngles(Vector3 suggestedPos, Quaternion suggestedAng, Construction.Target target)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (restrictPlacementAngle)
		{
			Quaternion val = Quaternion.Euler(0f, faceAngle, 0f) * suggestedAng;
			float num = Vector3Ex.DotDegrees(Vector3Ex.XZ3D(((Ray)(ref target.ray)).direction), val * Vector3.forward);
			if (num > angleAllowed * 0.5f)
			{
				return false;
			}
			if (num < angleAllowed * -0.5f)
			{
				return false;
			}
		}
		return true;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)target.entity) || !Object.op_Implicit((Object)(object)((Component)target.entity).transform))
		{
			return default(Construction.Placement);
		}
		if (!CanConnectToEntity(target))
		{
			return default(Construction.Placement);
		}
		ConstructionSocket constructionSocket = target.socket as ConstructionSocket;
		Vector3 val = target.GetWorldPosition();
		Quaternion val2 = target.GetWorldRotation(female: true);
		if (constructionSocket != null && !IsCompatible(constructionSocket))
		{
			return default(Construction.Placement);
		}
		if (wantsInside)
		{
			Vector3 pos = ((Component)target.entity).transform.position + localPosition + ((Component)target.entity).transform.right * 0.2f;
			if (IsOutside(pos, ((Component)target.entity).transform))
			{
				Construction.lastPlacementError = ConstructionErrors.WantsInside;
				return default(Construction.Placement);
			}
		}
		if (rotationDegrees > 0 && (constructionSocket == null || !constructionSocket.restrictPlacementRotation))
		{
			Construction.Placement placement = new Construction.Placement(target);
			float num = float.MaxValue;
			float num2 = 0f;
			for (int i = 0; i < 360; i += rotationDegrees)
			{
				Quaternion val3 = Quaternion.Euler(0f, (float)(rotationOffset + i), 0f);
				Vector3 direction = ((Ray)(ref target.ray)).direction;
				Vector3 val4 = val3 * val2 * Vector3.up;
				float num3 = Vector3.Angle(direction, val4);
				if (num3 < num)
				{
					num = num3;
					num2 = i;
				}
			}
			for (int j = 0; j < 360; j += rotationDegrees)
			{
				Quaternion val5 = val2 * Quaternion.Inverse(rotation);
				Quaternion val6 = Quaternion.Euler(target.rotation);
				Quaternion val7 = Quaternion.Euler(0f, (float)(rotationOffset + j) + num2, 0f);
				Quaternion val8 = val6 * val7 * val5;
				Vector3 val9 = val8 * position;
				placement.position = val - val9;
				placement.rotation = val8;
				if (CheckSocketMods(ref placement))
				{
					return placement;
				}
			}
		}
		Construction.Placement result = new Construction.Placement(target);
		Quaternion val10 = val2 * Quaternion.Inverse(rotation);
		if (ShouldInheritFemaleSocketRotation(socketType))
		{
			Quaternion val11 = Quaternion.Euler(target.rotation);
			val10 *= val11;
		}
		Vector3 val12 = val10 * position;
		result.position = val - val12;
		result.rotation = val10;
		if (!TestRestrictedAngles(val, val2, target))
		{
			return default(Construction.Placement);
		}
		return result;
	}

	protected virtual bool CanConnectToEntity(Construction.Target target)
	{
		return true;
	}

	private bool ShouldInheritFemaleSocketRotation(Type type)
	{
		if (type != Type.WallFrame && type != Type.Doorway && type != Type.FloorFrameTriangle && type != Type.FloorFrame)
		{
			return type == Type.Shutters;
		}
		return true;
	}

	public bool IsOutside(Vector3 pos, Transform tr)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		float num = 5f;
		for (int i = 0; i < outsideLookupDirs.Length; i++)
		{
			Vector3 val = tr.TransformDirection(outsideLookupDirs[i]);
			Vector3 val2 = pos + val * num;
			if (!Physics.Raycast(new Ray(val2, -val), num - 0.5f, 2097152))
			{
				return true;
			}
		}
		return false;
	}

	static ConstructionSocket()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = new Vector3[4];
		Vector3 val = new Vector3(0f, 1f, 0f);
		array[0] = ((Vector3)(ref val)).normalized;
		val = new Vector3(1f, 0f, 0f);
		array[1] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, 1f);
		array[2] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, -1f);
		array[3] = ((Vector3)(ref val)).normalized;
		outsideLookupDirs = (Vector3[])(object)array;
	}
}


public enum Type
{
	None,
	Foundation,
	Floor,
	Misc,
	Doorway,
	Wall,
	Block,
	Ramp,
	StairsTriangle,
	Stairs,
	FloorFrameTriangle,
	Window,
	Shutters,
	WallFrame,
	FloorFrame,
	WindowDressing,
	DoorDressing,
	Elevator,
	DoubleDoorDressing
}


using UnityEngine;

public class ConstructionSocket_Elevator : ConstructionSocket
{
	public int MaxFloor = 5;

	protected override bool CanConnectToEntity(Construction.Target target)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (target.entity is Elevator elevator && elevator.Floor >= MaxFloor)
		{
			return false;
		}
		Vector3 val = target.GetWorldPosition();
		Quaternion val2 = target.GetWorldRotation(female: true);
		if (GamePhysics.CheckOBB(new OBB(val, new Vector3(2f, 0.5f, 2f), val2), 2097152, (QueryTriggerInteraction)0))
		{
			return false;
		}
		return base.CanConnectToEntity(target);
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		Matrix4x4 val = Matrix4x4.TRS(position, rotation, Vector3.one);
		Vector3 val2 = ((Matrix4x4)(ref val)).MultiplyPoint3x4(worldPosition);
		return !GamePhysics.CheckOBB(new OBB(val2, new Vector3(2f, 0.5f, 2f), rotation), 2097152, (QueryTriggerInteraction)0);
	}
}


public class Construction_SleepingBag : Construction
{
}


using System;
using UnityEngine;

public class DecayPoint : PrefabAttribute
{
	[Tooltip("If this point is occupied this will take this % off the power of the decay")]
	public float protection = 0.25f;

	public Socket_Base socket;

	public bool IsOccupied(BaseEntity entity)
	{
		return entity.IsOccupied(socket);
	}

	protected override Type GetIndexedType()
	{
		return typeof(DecayPoint);
	}
}


using System;
using UnityEngine;

public class DirectionProperties : PrefabAttribute
{
	private const float radius = 200f;

	public Bounds bounds = new Bounds(Vector3.zero, Vector3.zero);

	public ProtectionProperties extraProtection;

	protected override Type GetIndexedType()
	{
		return typeof(DirectionProperties);
	}

	public bool IsWeakspot(Transform tx, HitInfo info)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if (((Bounds)(ref bounds)).size == Vector3.zero)
		{
			return false;
		}
		BasePlayer initiatorPlayer = info.InitiatorPlayer;
		if ((Object)(object)initiatorPlayer == (Object)null)
		{
			return false;
		}
		BaseEntity hitEntity = info.HitEntity;
		if ((Object)(object)hitEntity == (Object)null)
		{
			return false;
		}
		Matrix4x4 worldToLocalMatrix = tx.worldToLocalMatrix;
		Vector3 val = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(info.PointStart) - worldPosition;
		float num = Vector3Ex.DotDegrees(worldForward, val);
		Vector3 val2 = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(info.HitPositionWorld);
		OBB val3 = default(OBB);
		((OBB)(ref val3))..ctor(worldPosition, worldRotation, bounds);
		Vector3 position = initiatorPlayer.eyes.position;
		WeakpointProperties[] array = PrefabAttribute.server.FindAll<WeakpointProperties>(hitEntity.prefabID);
		if (array != null && array.Length != 0)
		{
			bool flag = false;
			WeakpointProperties[] array2 = array;
			foreach (WeakpointProperties weakpointProperties in array2)
			{
				if ((!weakpointProperties.BlockWhenRoofAttached || CheckWeakpointRoof(hitEntity)) && IsWeakspotVisible(hitEntity, position, tx.TransformPoint(weakpointProperties.worldPosition)))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return false;
			}
		}
		else if (!IsWeakspotVisible(hitEntity, position, tx.TransformPoint(val3.position)))
		{
			return false;
		}
		if (num > 100f)
		{
			return ((OBB)(ref val3)).Contains(val2);
		}
		return false;
	}

	private bool CheckWeakpointRoof(BaseEntity hitEntity)
	{
		foreach (EntityLink entityLink in hitEntity.GetEntityLinks())
		{
			if (!(entityLink.socket is NeighbourSocket))
			{
				continue;
			}
			foreach (EntityLink connection in entityLink.connections)
			{
				if (connection.owner is BuildingBlock buildingBlock && (buildingBlock.ShortPrefabName == "roof" || buildingBlock.ShortPrefabName == "roof.triangle"))
				{
					return false;
				}
			}
		}
		return true;
	}

	private bool IsWeakspotVisible(BaseEntity hitEntity, Vector3 playerEyes, Vector3 weakspotPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		if (!hitEntity.IsVisible(playerEyes, weakspotPos))
		{
			return false;
		}
		return true;
	}
}


using System;

public abstract class ModelConditionTest : PrefabAttribute
{
	public abstract bool DoTest(BaseEntity ent);

	protected override Type GetIndexedType()
	{
		return typeof(ModelConditionTest);
	}
}


public class ModelConditionTest_False : ModelConditionTest
{
	public ConditionalModel reference;

	public override bool DoTest(BaseEntity ent)
	{
		return !reference.RunTests(ent);
	}
}


using UnityEngine;

public class ModelConditionTest_FoundationSide : ModelConditionTest
{
	private const string square_south = "foundation/sockets/foundation-top/1";

	private const string square_north = "foundation/sockets/foundation-top/3";

	private const string square_west = "foundation/sockets/foundation-top/2";

	private const string square_east = "foundation/sockets/foundation-top/4";

	private const string triangle_south = "foundation.triangle/sockets/foundation-top/1";

	private const string triangle_northwest = "foundation.triangle/sockets/foundation-top/2";

	private const string triangle_northeast = "foundation.triangle/sockets/foundation-top/3";

	private string socket = string.Empty;

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(1.5f, 1.5f, 0f), new Vector3(3f, 3f, 3f));
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = worldRotation * Vector3.right;
		if (name.Contains("foundation.triangle"))
		{
			if (val.z < -0.9f)
			{
				socket = "foundation.triangle/sockets/foundation-top/1";
			}
			if (val.x < -0.1f)
			{
				socket = "foundation.triangle/sockets/foundation-top/2";
			}
			if (val.x > 0.1f)
			{
				socket = "foundation.triangle/sockets/foundation-top/3";
			}
			return;
		}
		if (val.z < -0.9f)
		{
			socket = "foundation/sockets/foundation-top/1";
		}
		if (val.z > 0.9f)
		{
			socket = "foundation/sockets/foundation-top/3";
		}
		if (val.x < -0.9f)
		{
			socket = "foundation/sockets/foundation-top/2";
		}
		if (val.x > 0.9f)
		{
			socket = "foundation/sockets/foundation-top/4";
		}
	}

	public override bool DoTest(BaseEntity ent)
	{
		EntityLink entityLink = ent.FindLink(socket);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock == (Object)null) && !(buildingBlock.blockDefinition.info.name.token == "foundation_steps"))
			{
				if (buildingBlock.grade == BuildingGrade.Enum.TopTier)
				{
					return false;
				}
				if (buildingBlock.grade == BuildingGrade.Enum.Metal)
				{
					return false;
				}
				if (buildingBlock.grade == BuildingGrade.Enum.Stone)
				{
					return false;
				}
			}
		}
		return true;
	}
}


public class ModelConditionTest_Inside : ModelConditionTest
{
	public override bool DoTest(BaseEntity ent)
	{
		return !ModelConditionTest_Outside.CheckCondition(ent);
	}
}


public class ModelConditionTest_Outside : ModelConditionTest
{
	public override bool DoTest(BaseEntity ent)
	{
		return CheckCondition(ent);
	}

	public static bool CheckCondition(BaseEntity ent)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		OBB val = ent.WorldSpaceBounds();
		return ent.IsOutside(((OBB)(ref val)).GetPoint(0f, 1f, 0f));
	}
}


using UnityEngine;

public class ModelConditionTest_RampHigh : ModelConditionTest
{
	private const string socket = "ramp/sockets/block-male/1";

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, 0.75f, 0f), new Vector3(3f, 1.5f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		return ent.FindLink("ramp/sockets/block-male/1")?.IsEmpty() ?? false;
	}
}


using UnityEngine;

public class ModelConditionTest_RampLow : ModelConditionTest
{
	private const string socket = "ramp/sockets/block-male/1";

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, 0.375f, 0f), new Vector3(3f, 0.75f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		EntityLink entityLink = ent.FindLink("ramp/sockets/block-male/1");
		if (entityLink == null)
		{
			return false;
		}
		return !entityLink.IsEmpty();
	}
}


using UnityEngine;

public class ModelConditionTest_RoofBottom : ModelConditionTest
{
	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_bot_right = "sockets/neighbour/3";

	private const string socket_bot_left = "sockets/neighbour/4";

	private const string socket_top_right = "sockets/neighbour/5";

	private const string socket_top_left = "sockets/neighbour/6";

	private static string[] sockets_bot_right = new string[2] { "roof/sockets/neighbour/3", "roof.triangle/sockets/neighbour/3" };

	private static string[] sockets_bot_left = new string[2] { "roof/sockets/neighbour/4", "roof.triangle/sockets/neighbour/4" };

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, -1.5f, 3f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		bool flag = false;
		bool flag2 = false;
		EntityLink entityLink = ent.FindLink(sockets_bot_right);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			if (entityLink.connections[i].name.EndsWith("sockets/neighbour/5"))
			{
				flag = true;
				break;
			}
		}
		EntityLink entityLink2 = ent.FindLink(sockets_bot_left);
		if (entityLink2 == null)
		{
			return false;
		}
		for (int j = 0; j < entityLink2.connections.Count; j++)
		{
			if (entityLink2.connections[j].name.EndsWith("sockets/neighbour/6"))
			{
				flag2 = true;
				break;
			}
		}
		if (flag && flag2)
		{
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class ModelConditionTest_RoofLeft : ModelConditionTest
{
	public enum AngleType
	{
		None = -1,
		Straight = 0,
		Convex60 = 60,
		Convex90 = 90,
		Convex120 = 120,
		Concave30 = -30,
		Concave60 = -60,
		Concave90 = -90,
		Concave120 = -120
	}

	public enum ShapeType
	{
		Any = -1,
		Square,
		Triangle
	}

	public AngleType angle = AngleType.None;

	public ShapeType shape = ShapeType.Any;

	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_right = "sockets/neighbour/3";

	private const string socket_left = "sockets/neighbour/4";

	private static string[] sockets_left = new string[2] { "roof/sockets/neighbour/4", "roof.triangle/sockets/neighbour/4" };

	private bool IsConvex => angle > (AngleType)10;

	private bool IsConcave => angle < (AngleType)(-10);

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(3f, 1.5f, 0f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink(sockets_left);
		if (entityLink == null)
		{
			return false;
		}
		if (angle == AngleType.None)
		{
			for (int i = 0; i < entityLink.connections.Count; i++)
			{
				if (entityLink.connections[i].name.EndsWith("sockets/neighbour/3"))
				{
					return false;
				}
			}
			return true;
		}
		if (entityLink.IsEmpty())
		{
			return false;
		}
		bool result = false;
		for (int j = 0; j < entityLink.connections.Count; j++)
		{
			EntityLink entityLink2 = entityLink.connections[j];
			if (!entityLink2.name.EndsWith("sockets/neighbour/3") || (shape == ShapeType.Square && !entityLink2.name.StartsWith("roof/")) || (shape == ShapeType.Triangle && !entityLink2.name.StartsWith("roof.triangle/")))
			{
				continue;
			}
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null || buildingBlock2.grade != buildingBlock.grade)
			{
				continue;
			}
			int num = (int)angle;
			float num2 = Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (num2 < (float)(num - 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else if (num2 > (float)(num + 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else
			{
				result = true;
			}
		}
		return result;
	}
}


public enum AngleType
{
	None = -1,
	Straight = 0,
	Convex60 = 60,
	Convex90 = 90,
	Convex120 = 120,
	Concave30 = -30,
	Concave60 = -60,
	Concave90 = -90,
	Concave120 = -120
}


public enum ShapeType
{
	Any = -1,
	Square,
	Triangle
}


using UnityEngine;

public class ModelConditionTest_RoofRight : ModelConditionTest
{
	public enum AngleType
	{
		None = -1,
		Straight = 0,
		Convex60 = 60,
		Convex90 = 90,
		Convex120 = 120,
		Concave30 = -30,
		Concave60 = -60,
		Concave90 = -90,
		Concave120 = -120
	}

	public enum ShapeType
	{
		Any = -1,
		Square,
		Triangle
	}

	public AngleType angle = AngleType.None;

	public ShapeType shape = ShapeType.Any;

	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_right = "sockets/neighbour/3";

	private const string socket_left = "sockets/neighbour/4";

	private static string[] sockets_right = new string[2] { "roof/sockets/neighbour/3", "roof.triangle/sockets/neighbour/3" };

	private bool IsConvex => angle > (AngleType)10;

	private bool IsConcave => angle < (AngleType)(-10);

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(-3f, 1.5f, 0f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink(sockets_right);
		if (entityLink == null)
		{
			return false;
		}
		if (angle == AngleType.None)
		{
			for (int i = 0; i < entityLink.connections.Count; i++)
			{
				if (entityLink.connections[i].name.EndsWith("sockets/neighbour/4"))
				{
					return false;
				}
			}
			return true;
		}
		if (entityLink.IsEmpty())
		{
			return false;
		}
		bool result = false;
		for (int j = 0; j < entityLink.connections.Count; j++)
		{
			EntityLink entityLink2 = entityLink.connections[j];
			if (!entityLink2.name.EndsWith("sockets/neighbour/4") || (shape == ShapeType.Square && !entityLink2.name.StartsWith("roof/")) || (shape == ShapeType.Triangle && !entityLink2.name.StartsWith("roof.triangle/")))
			{
				continue;
			}
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null || buildingBlock2.grade != buildingBlock.grade)
			{
				continue;
			}
			int num = (int)angle;
			float num2 = 0f - Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (num2 < (float)(num - 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else if (num2 > (float)(num + 10))
			{
				if (IsConvex)
				{
					return false;
				}
			}
			else
			{
				result = true;
			}
		}
		return result;
	}
}


public enum AngleType
{
	None = -1,
	Straight = 0,
	Convex60 = 60,
	Convex90 = 90,
	Convex120 = 120,
	Concave30 = -30,
	Concave60 = -60,
	Concave90 = -90,
	Concave120 = -120
}


public enum ShapeType
{
	Any = -1,
	Square,
	Triangle
}


using UnityEngine;

public class ModelConditionTest_RoofTop : ModelConditionTest
{
	private const string roof_square = "roof/";

	private const string roof_triangle = "roof.triangle/";

	private const string socket_bot_right = "sockets/neighbour/3";

	private const string socket_bot_left = "sockets/neighbour/4";

	private const string socket_top_right = "sockets/neighbour/5";

	private const string socket_top_left = "sockets/neighbour/6";

	private static string[] sockets_top_right = new string[2] { "roof/sockets/neighbour/5", "roof.triangle/sockets/neighbour/5" };

	private static string[] sockets_top_left = new string[2] { "roof/sockets/neighbour/6", "roof.triangle/sockets/neighbour/6" };

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, -1.5f, 3f), new Vector3(3f, 3f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		bool flag = false;
		bool flag2 = false;
		EntityLink entityLink = ent.FindLink(sockets_top_right);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			if (entityLink.connections[i].name.EndsWith("sockets/neighbour/3"))
			{
				flag = true;
				break;
			}
		}
		EntityLink entityLink2 = ent.FindLink(sockets_top_left);
		if (entityLink2 == null)
		{
			return false;
		}
		for (int j = 0; j < entityLink2.connections.Count; j++)
		{
			if (entityLink2.connections[j].name.EndsWith("sockets/neighbour/4"))
			{
				flag2 = true;
				break;
			}
		}
		if (flag && flag2)
		{
			return false;
		}
		return true;
	}
}


public class ModelConditionTest_RoofTriangle : ModelConditionTest
{
	private const string socket = "roof/sockets/wall-female";

	public override bool DoTest(BaseEntity ent)
	{
		EntityLink entityLink = ent.FindLink("roof/sockets/wall-female");
		if (entityLink == null)
		{
			return true;
		}
		if (!entityLink.IsEmpty())
		{
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class ModelConditionTest_SpiralStairs : ModelConditionTest
{
	private const string stairs_socket_female = "sockets/stairs-female/1";

	private static string[] stairs_sockets_female = new string[2] { "block.stair.spiral/sockets/stairs-female/1", "block.stair.spiral.triangle/sockets/stairs-female/1" };

	private const string floor_socket_female = "sockets/floor-female/1";

	private static string[] floor_sockets_female = new string[2] { "block.stair.spiral/sockets/floor-female/1", "block.stair.spiral.triangle/sockets/floor-female/1" };

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.gray;
		Gizmos.DrawWireCube(new Vector3(0f, 2.35f, 0f), new Vector3(3f, 1.5f, 3f));
	}

	public override bool DoTest(BaseEntity ent)
	{
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink(stairs_sockets_female);
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock2 = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock2 == (Object)null) && buildingBlock2.grade == buildingBlock.grade)
			{
				return false;
			}
		}
		EntityLink entityLink2 = ent.FindLink(floor_sockets_female);
		if (entityLink2 == null)
		{
			return true;
		}
		if (!entityLink2.IsEmpty())
		{
			return false;
		}
		return true;
	}
}


public class ModelConditionTest_True : ModelConditionTest
{
	public ConditionalModel reference;

	public override bool DoTest(BaseEntity ent)
	{
		return reference.RunTests(ent);
	}
}


public class ModelConditionTest_Variant : ModelConditionTest
{
	public ulong VariantSeed;

	public ulong VariantIndex;

	public ulong VariantCount = 3uL;

	public override bool DoTest(BaseEntity ent)
	{
		ulong num = ent.net.ID.Value + VariantSeed;
		SeedRandom.Wanghash(ref num);
		SeedRandom.Wanghash(ref num);
		SeedRandom.Wanghash(ref num);
		return num % VariantCount == VariantIndex;
	}
}


public class ModelConditionTest_Wall : ModelConditionTest
{
	public override bool DoTest(BaseEntity ent)
	{
		if (!ModelConditionTest_WallTriangleLeft.CheckCondition(ent))
		{
			return !ModelConditionTest_WallTriangleRight.CheckCondition(ent);
		}
		return false;
	}
}


using UnityEngine;

public class ModelConditionTest_WallCornerLeft : ModelConditionTest
{
	private const string socket = "sockets/stability/2";

	private static string[] sockets = new string[5] { "wall/sockets/stability/2", "wall.half/sockets/stability/2", "wall.low/sockets/stability/2", "wall.doorway/sockets/stability/2", "wall.window/sockets/stability/2" };

	public override bool DoTest(BaseEntity ent)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		EntityLink entityLink = ent.FindLink(sockets);
		if (entityLink == null)
		{
			return false;
		}
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		bool result = false;
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			EntityLink entityLink2 = entityLink.connections[i];
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null)
			{
				continue;
			}
			float num = Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (entityLink2.name.EndsWith("sockets/stability/2"))
			{
				if (num > -10f || num < -100f)
				{
					return false;
				}
				continue;
			}
			if (num < 10f && num > -10f)
			{
				return false;
			}
			if (num < -10f)
			{
				return false;
			}
			if (buildingBlock2.grade == buildingBlock.grade)
			{
				result = true;
			}
		}
		return result;
	}
}


using UnityEngine;

public class ModelConditionTest_WallCornerRight : ModelConditionTest
{
	private const string socket = "sockets/stability/1";

	private static string[] sockets = new string[5] { "wall/sockets/stability/1", "wall.half/sockets/stability/1", "wall.low/sockets/stability/1", "wall.doorway/sockets/stability/1", "wall.window/sockets/stability/1" };

	public override bool DoTest(BaseEntity ent)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		EntityLink entityLink = ent.FindLink(sockets);
		if (entityLink == null)
		{
			return false;
		}
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		bool result = false;
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			EntityLink entityLink2 = entityLink.connections[i];
			BuildingBlock buildingBlock2 = entityLink2.owner as BuildingBlock;
			if ((Object)(object)buildingBlock2 == (Object)null)
			{
				continue;
			}
			float num = Vector3.SignedAngle(((Component)ent).transform.forward, ((Component)buildingBlock2).transform.forward, Vector3.up);
			if (entityLink2.name.EndsWith("sockets/stability/1"))
			{
				if (num < 10f || num > 100f)
				{
					return false;
				}
				continue;
			}
			if (num < 10f && num > -10f)
			{
				return false;
			}
			if (num > 10f)
			{
				return false;
			}
			if (buildingBlock2.grade == buildingBlock.grade)
			{
				result = true;
			}
		}
		return result;
	}
}


using UnityEngine;

public class ModelConditionTest_Wallpaper : ModelConditionTest
{
	public bool wantsWallpaper = true;

	public bool softSide;

	public override bool DoTest(BaseEntity ent)
	{
		BuildingBlock buildingBlock = ent as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return false;
		}
		bool flag = buildingBlock.HasWallpaper((!softSide) ? 1 : 0);
		if (!wantsWallpaper)
		{
			return !flag;
		}
		return flag;
	}
}


using UnityEngine;

public class ModelConditionTest_WallTriangleLeft : ModelConditionTest
{
	private const string socket_1 = "wall/sockets/wall-female";

	private const string socket_2 = "wall/sockets/floor-female/1";

	private const string socket_3 = "wall/sockets/floor-female/2";

	private const string socket_4 = "wall/sockets/floor-female/3";

	private const string socket_5 = "wall/sockets/floor-female/4";

	private const string socket_6 = "wall/sockets/stability/1";

	private const string socket = "wall/sockets/neighbour/1";

	public static bool CheckCondition(BaseEntity ent)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		if (CheckSocketOccupied(ent, "wall/sockets/wall-female"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/1"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/2"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/3"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/4"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/stability/1"))
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink("wall/sockets/neighbour/1");
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock == (Object)null))
			{
				if (buildingBlock.blockDefinition.info.name.token == "roof" && Vector3.Angle(((Component)ent).transform.forward, ((Component)buildingBlock).transform.forward) < 10f)
				{
					return true;
				}
				if (buildingBlock.blockDefinition.info.name.token == "roof_triangle" && Vector3.Angle(((Component)ent).transform.forward, ((Component)buildingBlock).transform.forward) < 40f)
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool CheckSocketOccupied(BaseEntity ent, string socket)
	{
		EntityLink entityLink = ent.FindLink(socket);
		if (entityLink == null)
		{
			return false;
		}
		return !entityLink.IsEmpty();
	}

	public override bool DoTest(BaseEntity ent)
	{
		return CheckCondition(ent);
	}
}


using UnityEngine;

public class ModelConditionTest_WallTriangleRight : ModelConditionTest
{
	private const string socket_1 = "wall/sockets/wall-female";

	private const string socket_2 = "wall/sockets/floor-female/1";

	private const string socket_3 = "wall/sockets/floor-female/2";

	private const string socket_4 = "wall/sockets/floor-female/3";

	private const string socket_5 = "wall/sockets/floor-female/4";

	private const string socket_6 = "wall/sockets/stability/2";

	private const string socket = "wall/sockets/neighbour/1";

	public static bool CheckCondition(BaseEntity ent)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		if (CheckSocketOccupied(ent, "wall/sockets/wall-female"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/1"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/2"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/3"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/floor-female/4"))
		{
			return false;
		}
		if (CheckSocketOccupied(ent, "wall/sockets/stability/2"))
		{
			return false;
		}
		EntityLink entityLink = ent.FindLink("wall/sockets/neighbour/1");
		if (entityLink == null)
		{
			return false;
		}
		for (int i = 0; i < entityLink.connections.Count; i++)
		{
			BuildingBlock buildingBlock = entityLink.connections[i].owner as BuildingBlock;
			if (!((Object)(object)buildingBlock == (Object)null))
			{
				if (buildingBlock.blockDefinition.info.name.token == "roof" && Vector3.Angle(((Component)ent).transform.forward, -((Component)buildingBlock).transform.forward) < 10f)
				{
					return true;
				}
				if (buildingBlock.blockDefinition.info.name.token == "roof_triangle" && Vector3.Angle(((Component)ent).transform.forward, -((Component)buildingBlock).transform.forward) < 40f)
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool CheckSocketOccupied(BaseEntity ent, string socket)
	{
		EntityLink entityLink = ent.FindLink(socket);
		if (entityLink == null)
		{
			return false;
		}
		return !entityLink.IsEmpty();
	}

	public override bool DoTest(BaseEntity ent)
	{
		return CheckCondition(ent);
	}
}


using UnityEngine;

public class NeighbourSocket : Socket_Base
{
	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.DrawWireCube(selectCenter, selectSize);
	}

	public override bool TestTarget(Construction.Target target)
	{
		return false;
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		OBB selectBounds = GetSelectBounds(position, rotation);
		OBB selectBounds2 = socket.GetSelectBounds(socketPosition, socketRotation);
		return ((OBB)(ref selectBounds)).Intersects(selectBounds2);
	}
}


using System;
using UnityEngine;

public class SocketHandle : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(SocketHandle);
	}

	internal void AdjustTarget(ref Construction.Target target, float maxplaceDistance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = worldPosition;
		Vector3 val2 = ((Ray)(ref target.ray)).origin + ((Ray)(ref target.ray)).direction * maxplaceDistance - val;
		ref Ray ray = ref target.ray;
		Vector3 val3 = val2 - ((Ray)(ref target.ray)).origin;
		((Ray)(ref ray)).direction = ((Vector3)(ref val3)).normalized;
	}
}


using System;
using UnityEngine;

public abstract class SocketMod : PrefabAttribute
{
	[NonSerialized]
	public Socket_Base baseSocket;

	public Phrase FailedPhrase;

	public SocketMod_Grouping SocketGrouping { get; private set; }

	protected virtual Phrase ErrorPhrase => Phrase.op_Implicit(string.Empty);

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		Transform parent = ((Component)this).transform.parent;
		SocketGrouping = ((parent != null) ? ((Component)parent).GetComponent<SocketMod_Grouping>() : null);
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
	}

	public virtual Phrase GetTranslatedErrorMessage()
	{
		if (!string.IsNullOrEmpty(FailedPhrase.token))
		{
			return FailedPhrase;
		}
		return ErrorPhrase;
	}

	public virtual string GetDebugErrorMessage()
	{
		return hierachyName ?? "";
	}

	public virtual bool DoCheck(Construction.Placement place)
	{
		return false;
	}

	public virtual void ModifyPlacement(ref Construction.Placement place)
	{
	}

	protected override Type GetIndexedType()
	{
		return typeof(SocketMod);
	}
}


using UnityEngine;

public class SocketMod_AngleCheck : SocketMod
{
	public bool wantsAngle = true;

	public Vector3 worldNormal = Vector3.up;

	public float withinDegrees = 45f;

	public bool usePlacementNormal;

	protected override Phrase ErrorPhrase => ConstructionErrors.InvalidAngle;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = (usePlacementNormal ? Vector3.forward : Vector3.up);
		float num = Vector3Ex.DotDegrees(worldNormal, place.rotation * val);
		if (!usePlacementNormal)
		{
			return num < withinDegrees;
		}
		return num >= withinDegrees;
	}
}


using UnityEngine;

public class SocketMod_AreaCheck : SocketMod
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 0.1f);

	public LayerMask layerMask;

	public bool wantsInside = true;

	private Phrase lastError = new Phrase("", "");

	protected override Phrase ErrorPhrase => lastError;

	public static bool IsInArea(Vector3 position, Quaternion rotation, Bounds bounds, LayerMask layerMask, BaseEntity entity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckOBBAndEntity(new OBB(position, rotation, bounds), ((LayerMask)(ref layerMask)).value, (QueryTriggerInteraction)0, entity);
	}

	public bool DoCheck(Vector3 position, Quaternion rotation, BaseEntity entity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position2 = position + rotation * worldPosition;
		Quaternion rotation2 = rotation * worldRotation;
		return IsInArea(position2, rotation2, bounds, layerMask, entity) == wantsInside;
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		bool flag = DoCheck(place.position, place.rotation);
		if (!flag)
		{
			lastError = ConstructionErrors.NotStableEnough;
			if (LayerMask.op_Implicit(layerMask) == 2097152 || LayerMask.op_Implicit(layerMask) == 136314880)
			{
				lastError = (wantsInside ? ConstructionErrors.MustPlaceOnConstruction : ConstructionErrors.CantPlaceOnConstruction);
			}
		}
		else if (wantsInside && (LayerMask.op_Implicit(layerMask) & 0x8000000) == 0)
		{
			flag = !GamePhysics.CheckSphere(place.position, 5f, 134217728, (QueryTriggerInteraction)0);
			if (!flag)
			{
				lastError = ConstructionErrors.InvalidAreaVehicleLarge;
			}
		}
		if (flag)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_Attraction : SocketMod
{
	public float outerRadius = 1f;

	public float innerRadius = 0.1f;

	public string groupName = "wallbottom";

	public bool lockRotation;

	public bool bypassPlayerRotation;

	public bool ignoreRotationForRadiusCheck;

	public bool shiftDisableSnap = true;

	public bool applyPostRotationSnapping;

	private static float[] PostSnapRotations = new float[4] { 0f, 90f, 180f, 270f };

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
		Gizmos.DrawSphere(Vector3.zero, outerRadius);
		Gizmos.color = new Color(0f, 1f, 0f, 0.6f);
		Gizmos.DrawSphere(Vector3.zero, innerRadius);
	}

	public override bool DoCheck(Construction.Placement place)
	{
		return true;
	}

	public override void ModifyPlacement(ref Construction.Placement place)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		if (shiftDisableSnap && place.isHoldingShift)
		{
			return;
		}
		Vector3 val = place.position + place.rotation * worldPosition;
		Quaternion rotation = place.rotation;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(val, outerRadius * 2f, list, -1, (QueryTriggerInteraction)2);
		Vector3 position = Vector3.zero;
		float num = float.MaxValue;
		Vector3 position2 = place.position;
		Quaternion rotation2 = Quaternion.identity;
		foreach (BaseEntity item in list)
		{
			if (item.isServer != isServer)
			{
				continue;
			}
			AttractionPoint[] array = prefabAttribute.FindAll<AttractionPoint>(item.prefabID);
			if (array == null)
			{
				continue;
			}
			AttractionPoint[] array2 = array;
			foreach (AttractionPoint attractionPoint in array2)
			{
				if (attractionPoint.groupName != groupName)
				{
					continue;
				}
				Vector3 val2 = ((Component)item).transform.position + ((Component)item).transform.rotation * attractionPoint.worldPosition;
				Vector3 val3 = val2 - val;
				float magnitude = ((Vector3)(ref val3)).magnitude;
				if (ignoreRotationForRadiusCheck)
				{
					Vector3 val4 = ((Component)item).transform.TransformPoint(Vector3.LerpUnclamped(Vector3.zero, Vector3Ex.WithY(attractionPoint.worldPosition, 0f), 2f));
					float num2 = Vector3.Distance(val4, position2);
					if (num2 < num)
					{
						num = num2;
						position = val4;
						rotation2 = ((Component)item).transform.rotation;
					}
				}
				if (magnitude > outerRadius)
				{
					continue;
				}
				Quaternion val5 = ((lockRotation && bypassPlayerRotation) ? (((Component)item).transform.rotation * attractionPoint.localRotation) : QuaternionEx.LookRotationWithOffset(worldPosition, val2 - place.position, Vector3.up));
				float num3 = Mathf.InverseLerp(outerRadius, innerRadius, magnitude);
				if (lockRotation)
				{
					num3 = 1f;
				}
				if (lockRotation)
				{
					if (bypassPlayerRotation)
					{
						place.rotation = ((Component)item).transform.rotation * attractionPoint.localRotation;
					}
					else
					{
						Vector3 eulerAngles = ((Quaternion)(ref place.rotation)).eulerAngles;
						eulerAngles -= new Vector3(eulerAngles.x % 90f, eulerAngles.y % 90f, eulerAngles.z % 90f);
						place.rotation = Quaternion.Euler(eulerAngles + ((Component)item).transform.eulerAngles);
					}
				}
				else
				{
					place.rotation = Quaternion.Lerp(place.rotation, val5, num3);
				}
				val = place.position + place.rotation * worldPosition;
				val3 = val2 - val;
				place.position += val3 * num3;
			}
		}
		if (num < float.MaxValue && ignoreRotationForRadiusCheck)
		{
			place.position = position;
			place.rotation = rotation2;
		}
		if (applyPostRotationSnapping)
		{
			Quaternion rotation3 = place.rotation;
			float num4 = float.MaxValue;
			float[] postSnapRotations = PostSnapRotations;
			foreach (float num5 in postSnapRotations)
			{
				Quaternion val6 = place.rotation * Quaternion.Euler(0f, num5, 0f);
				float num6 = Quaternion.Angle(val6, rotation);
				if (num6 < num4)
				{
					num4 = num6;
					rotation3 = val6;
				}
			}
			if (num4 < float.MaxValue)
			{
				place.rotation = rotation3;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_BuildingBlock : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public bool wantsCollide;

	protected override Phrase ErrorPhrase => ConstructionErrors.MustPlaceOnConstruction;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		bool flag = list.Count > 0;
		if (flag && wantsCollide)
		{
			Pool.FreeUnmanaged<BuildingBlock>(ref list);
			return true;
		}
		if (flag && !wantsCollide)
		{
			Pool.FreeUnmanaged<BuildingBlock>(ref list);
			return false;
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
		return !wantsCollide;
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public class SocketMod_EntityCheck : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public BaseEntity[] entityTypes;

	public bool wantsCollide;

	protected override Phrase ErrorPhrase => ConstructionErrors.InvalidEntity;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		bool result = !wantsCollide;
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		foreach (BaseEntity ent in list)
		{
			bool flag = entityTypes.Any((BaseEntity x) => x.prefabID == ent.prefabID);
			if (flag && wantsCollide)
			{
				result = true;
				break;
			}
			if (flag && !wantsCollide)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_EntityType : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public BaseEntity searchType;

	public bool wantsCollide;

	protected override Phrase ErrorPhrase => ConstructionErrors.InvalidEntityType;

	public override string GetDebugErrorMessage()
	{
		return base.GetDebugErrorMessage() + $" {searchType}";
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		bool result = !wantsCollide;
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		foreach (BaseEntity item in list)
		{
			bool flag = ((object)item).GetType().IsAssignableFrom(((object)searchType).GetType());
			if (flag && wantsCollide)
			{
				result = true;
				break;
			}
			if (flag && !wantsCollide)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


public class SocketMod_EnvironmentVolume : SocketMod
{
	[InspectorFlags]
	public EnvironmentType environmentNone;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		EnvironmentType environmentType = EnvironmentManager.Get(place.position + place.rotation * worldPosition);
		if (environmentNone != 0 && (environmentType & environmentNone) != 0)
		{
			EnvironmentType blockedTypes = environmentType & environmentNone;
			Construction.lastPlacementError = Phrase.op_Implicit(GetErrorMessage(blockedTypes));
			return false;
		}
		return true;
	}

	private string GetErrorMessage(EnvironmentType blockedTypes)
	{
		string text = "Can't be placed ";
		if (blockedTypes.HasFlag(EnvironmentType.TrainTunnels))
		{
			return text + "In Train Tunnels";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Underground))
		{
			return text + "Underground";
		}
		if (blockedTypes.HasFlag(EnvironmentType.NoSunlight))
		{
			return text + "In The Dark";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Submarine))
		{
			return text + "In A Submarine";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Outdoor))
		{
			return text + "Outdoors";
		}
		if (blockedTypes.HasFlag(EnvironmentType.PlayerConstruction))
		{
			return text + "Near Player Construction";
		}
		if (blockedTypes.HasFlag(EnvironmentType.UnderwaterLab))
		{
			return text + "In Underwater Labs";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Elevator))
		{
			return text + "Near Elevators";
		}
		if (blockedTypes.HasFlag(EnvironmentType.Building) || blockedTypes.HasFlag(EnvironmentType.BuildingDark) || blockedTypes.HasFlag(EnvironmentType.BuildingVeryDark))
		{
			return text + "In A Building";
		}
		return text + "(Unknown Environment)";
	}
}


using System.Collections.Generic;
using UnityEngine;

public class SocketMod_Grouping : SocketMod
{
	private List<SocketMod> SocketMods;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		SocketMods = new List<SocketMod>();
		foreach (Transform child in ((Component)this).transform.GetChildren())
		{
			SocketMods.AddRange(((Component)child).GetComponents<SocketMod>());
		}
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
	}

	public override bool DoCheck(Construction.Placement place)
	{
		if (SocketMods == null || SocketMods.Count == 0)
		{
			return true;
		}
		foreach (SocketMod socketMod in SocketMods)
		{
			if (socketMod.DoCheck(place))
			{
				return true;
			}
		}
		return false;
	}
}


using UnityEngine;

public class SocketMod_HotSpot : SocketMod
{
	public float spotSize = 0.1f;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = new Color(1f, 1f, 0f, 0.5f);
		Gizmos.DrawSphere(Vector3.zero, spotSize);
	}

	public override void ModifyPlacement(ref Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		place.position = position;
	}
}


using System;
using Rust;
using UnityEngine;

public class SocketMod_Inside : SocketMod
{
	public bool wantsInside = true;

	public bool customDirections;

	public Vector3[] customRayDirections;

	private static readonly Vector3[] outsideLookupDirs;

	protected override Phrase ErrorPhrase
	{
		get
		{
			if (!wantsInside)
			{
				return ConstructionErrors.WantsOutside;
			}
			return ConstructionErrors.WantsInside;
		}
	}

	private Vector3[] directions
	{
		get
		{
			if (!customDirections)
			{
				return outsideLookupDirs;
			}
			return customRayDirections;
		}
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = place.position + place.rotation * baseSocket.localPosition;
		Quaternion val2 = place.rotation * baseSocket.localRotation;
		Vector3 pos = val + val2 * localPosition;
		Quaternion rotation = val2 * localRotation;
		bool flag = IsOutside(pos, rotation, directions);
		return !wantsInside == flag;
	}

	public static bool IsOutside(Vector3 pos, Transform tr, int layerMask = 2162688)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return IsOutside(pos, tr.rotation, outsideLookupDirs, layerMask);
	}

	public static bool IsOutside(Vector3 pos, Transform tr, Vector3[] dirs, int layerMask = 2162688)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return IsOutside(pos, tr.rotation, dirs, layerMask);
	}

	public static bool IsOutside(Vector3 pos, Quaternion rotation, Vector3[] dirs, int layerMask = 2162688)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SocketMod_Inside.IsOutside", 0);
		try
		{
			float num = 20f;
			int num2 = 0;
			bool flag = true;
			RaycastHit val3 = default(RaycastHit);
			for (int i = 0; i < dirs.Length; i++)
			{
				Vector3 val2 = rotation * dirs[i];
				if (Physics.Raycast(new Ray(pos, val2), ref val3, num - 0.5f, layerMask))
				{
					if (((Component)((RaycastHit)(ref val3)).collider).gameObject.IsOnLayer((Layer)21))
					{
						num2++;
					}
				}
				else
				{
					flag = false;
				}
			}
			if (flag)
			{
				return num2 < 2;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	static SocketMod_Inside()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = new Vector3[8];
		Vector3 val = new Vector3(1f, 1f, 0f);
		array[0] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, -1f, 0f);
		array[1] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 1f, 1f);
		array[2] = ((Vector3)(ref val)).normalized;
		val = new Vector3(-1f, 1f, 0f);
		array[3] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, 1f);
		array[4] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 1f, 0f);
		array[5] = ((Vector3)(ref val)).normalized;
		val = new Vector3(1f, 0f, 0.5f);
		array[6] = ((Vector3)(ref val)).normalized;
		val = new Vector3(-1f, 0f, 0.5f);
		array[7] = ((Vector3)(ref val)).normalized;
		outsideLookupDirs = (Vector3[])(object)array;
	}
}


using UnityEngine;

public class SocketMod_InWater : SocketMod
{
	public bool wantsInWater = true;

	public bool excludeArtificialWater;

	protected override Phrase ErrorPhrase
	{
		get
		{
			if (!wantsInWater)
			{
				return ConstructionErrors.InWater;
			}
			if (!excludeArtificialWater)
			{
				return ConstructionErrors.WantsWater;
			}
			return ConstructionErrors.WantsWaterBody;
		}
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(place.position + place.rotation * worldPosition - new Vector3(0f, 0.1f, 0f), waves: true, volumes: true);
		bool isValid = waterInfo.isValid;
		bool artificalWater = waterInfo.artificalWater;
		if (isValid == wantsInWater)
		{
			if (artificalWater)
			{
				return !excludeArtificialWater;
			}
			return true;
		}
		return false;
	}
}


using UnityEngine;

public class SocketMod_PhysicMaterial : SocketMod
{
	public PhysicMaterial[] ValidMaterials;

	private PhysicMaterial foundMaterial;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position;
		Vector3 eulerAngles = ((Quaternion)(ref place.rotation)).eulerAngles;
		Vector3 val = position + ((Vector3)(ref eulerAngles)).normalized * 0.5f;
		eulerAngles = ((Quaternion)(ref place.rotation)).eulerAngles;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val, -((Vector3)(ref eulerAngles)).normalized, ref val2, 1f, 161546240, (QueryTriggerInteraction)1))
		{
			foundMaterial = ((RaycastHit)(ref val2)).collider.GetMaterialAt(((RaycastHit)(ref val2)).point);
			PhysicMaterial[] validMaterials = ValidMaterials;
			for (int i = 0; i < validMaterials.Length; i++)
			{
				if ((Object)(object)validMaterials[i] == (Object)(object)foundMaterial)
				{
					return true;
				}
			}
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_PlantCheck : SocketMod
{
	public bool CanBePotted = true;

	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public QueryTriggerInteraction queryTriggers;

	public bool wantsCollide;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if (!CanBePotted && (Object)(object)place.transform != (Object)null)
		{
			PlanterBox planterBox = place.transform.ToBaseEntity() as PlanterBox;
			if ((Object)(object)planterBox != (Object)null && planterBox.PlantPot)
			{
				return false;
			}
		}
		Vector3 position = place.position + place.rotation * worldPosition;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, queryTriggers);
		bool result = !wantsCollide;
		foreach (BaseEntity item in list)
		{
			GrowableEntity component = ((Component)item).GetComponent<GrowableEntity>();
			if (Object.op_Implicit((Object)(object)component) && wantsCollide)
			{
				result = true;
				break;
			}
			if (Object.op_Implicit((Object)(object)component) && !wantsCollide)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_RoadCheck : SocketMod
{
	public float sphereRadius = 1f;

	public bool wantsCollide;

	public LayerMask layerMask = LayerMask.op_Implicit(65536);

	protected override Phrase ErrorPhrase
	{
		get
		{
			if (!wantsCollide)
			{
				return ConstructionErrors.CantPlaceOnRoad;
			}
			return ConstructionErrors.MustPlaceOnRoad;
		}
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, (QueryTriggerInteraction)2);
		bool flag = false;
		for (int i = 0; i < list.Count; i++)
		{
			Collider val = list[i];
			if ((Object)(object)val != (Object)null && ((Component)val).gameObject.HasCustomTag(GameObjectTag.Road))
			{
				flag = true;
				break;
			}
		}
		bool num = wantsCollide == flag;
		Pool.FreeUnmanaged<Collider>(ref list);
		if (num)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_SphereCheck : SocketMod
{
	public float sphereRadius = 1f;

	public LayerMask layerMask;

	public bool wantsCollide;

	public bool requireMonument;

	[Space]
	public BaseEntity[] entityWhitelist;

	private Phrase lastError = new Phrase("", "");

	protected override Phrase ErrorPhrase => lastError;

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = place.position + place.rotation * worldPosition;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(position, sphereRadius, list, ((LayerMask)(ref layerMask)).value, (QueryTriggerInteraction)2);
		if (requireMonument)
		{
			for (int i = 0; i < list.Count; i++)
			{
				Collider val = list[i];
				if (!((Component)val).gameObject.HasCustomTag(GameObjectTag.BlockBarricadePlacement) && ((Object)(object)val.GetMonument() == (Object)null || ((Component)val).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement)))
				{
					list.RemoveAt(i);
					i--;
				}
			}
		}
		bool flag = wantsCollide == list.Count > 0;
		if (entityWhitelist.Length != 0)
		{
			foreach (Collider item in list)
			{
				BaseEntity baseEntity = item.ToBaseEntity();
				if ((Object)(object)baseEntity != (Object)null)
				{
					flag = DeployVolume.CheckEntityList(baseEntity, entityWhitelist, trueIfAnyFound: true);
				}
			}
		}
		if (!flag)
		{
			lastError = ConstructionErrors.NotStableEnough;
			if (LayerMask.op_Implicit(layerMask) == 2097152 || LayerMask.op_Implicit(layerMask) == 136314880)
			{
				lastError = (wantsCollide ? ConstructionErrors.MustPlaceOnConstruction : ConstructionErrors.CantPlaceOnConstruction);
			}
			else if (!wantsCollide && requireMonument)
			{
				lastError = ConstructionErrors.CantPlaceOnMonument;
			}
			else if (!wantsCollide && list.Count > 0)
			{
				using List<Collider>.Enumerator enumerator = list.GetEnumerator();
				while (enumerator.MoveNext())
				{
					string blockedByErrorFromCollider = ConstructionErrors.GetBlockedByErrorFromCollider(DeployVolume.LastDeployHit = enumerator.Current);
					if (!string.IsNullOrEmpty(blockedByErrorFromCollider))
					{
						Construction.lastPlacementErrorIsDetailed = true;
						lastError = Phrase.op_Implicit(blockedByErrorFromCollider);
						break;
					}
				}
			}
		}
		else if (wantsCollide && (LayerMask.op_Implicit(layerMask) & 0x8000000) == 0)
		{
			flag = !GamePhysics.CheckSphere(place.position, 5f, 134217728, (QueryTriggerInteraction)0);
			if (!flag)
			{
				lastError = ConstructionErrors.InvalidAreaVehicleLarge;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		if (flag)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SocketMod_TerrainCheck : SocketMod
{
	public bool wantsInTerrain = true;

	public bool preventWorldLayerInMonuments;

	private static Phrase lastError = new Phrase("", "");

	protected override Phrase ErrorPhrase => lastError;

	public static bool IsInTerrain(Vector3 vPoint, bool worldLayerInMonuments)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.OutOfBounds(vPoint))
		{
			if (TerrainMeta.IsPointWithinTutorialBounds(vPoint))
			{
				return Physics.Raycast(new Ray(vPoint + Vector3.up * 3f, Vector3.down), 3f, 65536);
			}
			return false;
		}
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAllUnordered(new Ray(vPoint + Vector3.up * 3f, Vector3.down), 0f, list, 3f, 65536, (QueryTriggerInteraction)0);
		using (List<RaycastHit>.Enumerator enumerator = list.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				RaycastHit current = enumerator.Current;
				if (worldLayerInMonuments)
				{
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return true;
				}
				if (((Component)((RaycastHit)(ref current)).collider).gameObject.HasCustomTag(GameObjectTag.BlockBarricadePlacement))
				{
					lastError = ConstructionErrors.CantPlaceOnMonument;
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return false;
				}
				if (((Component)((RaycastHit)(ref current)).collider).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement))
				{
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return true;
				}
				MonumentInfo monument = ((RaycastHit)(ref current)).collider.GetMonument();
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				if ((Object)(object)monument == (Object)null)
				{
					return true;
				}
				lastError = ConstructionErrors.CantPlaceOnMonument;
				return false;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		if (!Object.op_Implicit((Object)(object)TerrainMeta.Collision) || !TerrainMeta.Collision.GetIgnore(vPoint))
		{
			Terrain[] activeTerrains = Terrain.activeTerrains;
			foreach (Terrain val in activeTerrains)
			{
				if (val.SampleHeight(vPoint) + ((Component)val).transform.position.y > vPoint.y)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vPoint = place.position + place.rotation * worldPosition;
		lastError = null;
		if (IsInTerrain(vPoint, !preventWorldLayerInMonuments) == wantsInTerrain)
		{
			return true;
		}
		if (lastError == null)
		{
			lastError = ConstructionErrors.NotInTerrain;
		}
		return false;
	}
}


using UnityEngine;

public class SocketMod_WaterDepth : SocketMod
{
	public float MinimumWaterDepth = 2f;

	public float MaximumWaterDepth = 4f;

	public bool BlockArtificialWaterVolumes;

	private Phrase lastError = new Phrase("", "");

	private float lastDepth;

	protected override Phrase ErrorPhrase => lastError;

	public override string GetDebugErrorMessage()
	{
		return base.GetDebugErrorMessage() + $" {lastDepth}m";
	}

	public override bool DoCheck(Construction.Placement place)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = place.position + place.rotation * worldPosition;
		pos.y -= 0.2f;
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(pos, waves: false, volumes: true);
		if (BlockArtificialWaterVolumes && waterInfo.artificalWater)
		{
			return false;
		}
		if (waterInfo.overallDepth > MinimumWaterDepth && waterInfo.overallDepth < MaximumWaterDepth)
		{
			return true;
		}
		lastError = ((waterInfo.overallDepth <= MinimumWaterDepth) ? ConstructionErrors.TooShallow : ConstructionErrors.TooDeep);
		return false;
	}
}


using System;
using UnityEngine;

public class Socket_Base : PrefabAttribute
{
	[Serializable]
	public class OccupiedSocketCheck
	{
		public Socket_Base Socket;

		public bool FemaleDummy;
	}

	public bool male = true;

	public bool maleDummy;

	public bool female;

	public bool femaleDummy;

	public bool femaleNoStability;

	public bool monogamous;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Quaternion rotation;

	private Type cachedType;

	public Vector3 selectSize = new Vector3(2f, 0.1f, 2f);

	public Vector3 selectCenter = new Vector3(0f, 0f, 1f);

	[ReadOnly]
	public string socketName;

	[NonSerialized]
	public SocketMod[] socketMods;

	public OccupiedSocketCheck[] checkOccupiedSockets;

	public Socket_Base()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		cachedType = ((object)this).GetType();
	}

	public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return position + rotation * worldPosition;
	}

	public virtual OBB GetSelectBounds(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(position + rotation * worldPosition, Vector3.one, rotation * worldRotation, new Bounds(selectCenter, selectSize));
	}

	protected override Type GetIndexedType()
	{
		return typeof(Socket_Base);
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		position = ((Component)this).transform.position;
		rotation = ((Component)this).transform.rotation;
		socketMods = ((Component)this).GetComponentsInChildren<SocketMod>(true);
		SocketMod[] array = socketMods;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].baseSocket = this;
		}
	}

	public virtual bool TestTarget(Construction.Target target)
	{
		return target.socket != null;
	}

	public virtual bool IsCompatible(Socket_Base socket)
	{
		if (socket == null)
		{
			return false;
		}
		if (!socket.male && !male)
		{
			return false;
		}
		if (!socket.female && !female)
		{
			return false;
		}
		return socket.cachedType == cachedType;
	}

	public virtual bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		return IsCompatible(socket);
	}

	public virtual Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.LookRotation(target.normal, Vector3.up) * Quaternion.Euler(target.rotation);
		Vector3 val2 = target.position;
		val2 -= val * position;
		Construction.Placement result = new Construction.Placement(target);
		result.rotation = val;
		result.position = val2;
		return result;
	}

	public virtual bool CheckSocketMods(ref Construction.Placement placement)
	{
		SocketMod[] array = socketMods;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ModifyPlacement(ref placement);
		}
		array = socketMods;
		foreach (SocketMod socketMod in array)
		{
			if (!(socketMod.SocketGrouping != null) && !socketMod.DoCheck(placement))
			{
				Construction.lastPlacementError = socketMod.GetTranslatedErrorMessage();
				return false;
			}
		}
		return true;
	}
}


using System;

[Serializable]
public class OccupiedSocketCheck
{
	public Socket_Base Socket;

	public bool FemaleDummy;
}


using UnityEngine;

public class Socket_Free : Socket_Base
{
	public Vector3 idealPlacementNormal = Vector3.up;

	public bool useTargetNormal = true;

	public bool blendAimAngle = true;

	public override bool TestTarget(Construction.Target target)
	{
		return target.onTerrain;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		Vector3 val2;
		if (useTargetNormal)
		{
			Vector3 normal = target.normal;
			Vector3 val = idealPlacementNormal;
			if (blendAimAngle || Mathf.Abs(target.normal.y) > 0.98f)
			{
				val2 = target.position - ((Ray)(ref target.ray)).origin;
				Vector3 normalized = ((Vector3)(ref val2)).normalized;
				float num = Mathf.Abs(Vector3.Dot(normalized, normal));
				val = Vector3.Lerp(normalized, idealPlacementNormal, num);
			}
			identity = Quaternion.LookRotation(normal, val) * Quaternion.Inverse(rotation) * Quaternion.Euler(target.rotation);
		}
		else
		{
			val2 = target.position - ((Ray)(ref target.ray)).origin;
			Vector3 normalized2 = ((Vector3)(ref val2)).normalized;
			normalized2.y = 0f;
			identity = Quaternion.LookRotation(normalized2, idealPlacementNormal) * Quaternion.Euler(target.rotation);
		}
		Vector3 val3 = target.position;
		val3 -= identity * position;
		Construction.Placement result = new Construction.Placement(target);
		result.rotation = identity;
		result.position = val3;
		return result;
	}
}


using UnityEngine;

public class Socket_Specific : Socket_Base
{
	public bool useFemaleRotation = true;

	public string targetSocketName;

	public bool blockPlacementOnChildEntities;

	public bool canRotate;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.2f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	public override bool TestTarget(Construction.Target target)
	{
		if (!base.TestTarget(target))
		{
			return false;
		}
		Socket_Specific_Female socket_Specific_Female = target.socket as Socket_Specific_Female;
		if (socket_Specific_Female == null)
		{
			return false;
		}
		if (blockPlacementOnChildEntities && (Object)(object)target.entity != (Object)null && (Object)(object)target.entity.GetParentEntity() != (Object)null)
		{
			return false;
		}
		return socket_Specific_Female.CanAccept(this);
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = target.socket.rotation;
		if (target.socket.male && target.socket.female)
		{
			val = target.socket.rotation * Quaternion.Euler(180f, 0f, 180f);
		}
		Socket_Specific_Female socket_Specific_Female = target.socket as Socket_Specific_Female;
		Transform val2 = (socket_Specific_Female.parentToBone ? target.entity.FindBone(socket_Specific_Female.boneName) : ((Component)target.entity).transform);
		Matrix4x4 localToWorldMatrix = val2.localToWorldMatrix;
		Vector3 val3 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(target.socket.localPosition);
		Quaternion val4;
		if (useFemaleRotation)
		{
			val4 = val2.rotation * val;
		}
		else
		{
			Vector3 val5 = new Vector3(val3.x, 0f, val3.z);
			Vector3 val6 = default(Vector3);
			((Vector3)(ref val6))..ctor(target.player.eyes.position.x, 0f, target.player.eyes.position.z);
			Vector3 val7 = val5 - val6;
			val4 = Quaternion.LookRotation(((Vector3)(ref val7)).normalized) * val;
		}
		Construction.Placement result = new Construction.Placement(target);
		Quaternion val8 = val4 * Quaternion.Inverse(rotation);
		if (canRotate)
		{
			val8 *= Quaternion.Euler(target.rotation);
		}
		Vector3 val9 = val8 * position;
		result.position = val3 - val9;
		result.rotation = val8;
		return result;
	}
}


using UnityEngine;

public class Socket_Specific_Female : Socket_Base
{
	public int rotationDegrees;

	public int rotationOffset;

	public string[] allowedMaleSockets;

	public bool parentToBone;

	public string boneName;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.2f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.DrawWireCube(selectCenter, selectSize);
	}

	public bool CanAccept(Socket_Specific socket)
	{
		string[] array = allowedMaleSockets;
		foreach (string text in array)
		{
			if (socket.targetSocketName == text)
			{
				return true;
			}
		}
		return false;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		return base.DoPlacement(target);
	}
}


using UnityEngine;

public class Socket_Terrain : Socket_Base
{
	public float placementHeight;

	public bool alignToNormal;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.red;
		Gizmos.DrawLine(Vector3.zero, Vector3.forward * 0.2f);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(Vector3.zero, Vector3.right * 0.1f);
		Gizmos.color = Color.green;
		Gizmos.DrawLine(Vector3.zero, Vector3.up * 0.1f);
		Gizmos.color = new Color(0f, 1f, 0f, 0.2f);
		Gizmos.DrawCube(Vector3.zero, new Vector3(0.1f, 0.1f, placementHeight));
		Gizmos.color = new Color(0f, 1f, 0f, 0.5f);
		Gizmos.DrawWireCube(Vector3.zero, new Vector3(0.1f, 0.1f, placementHeight));
		Gizmos.DrawIcon(((Component)this).transform.position, "light_circle_green.png", false);
	}

	public override bool TestTarget(Construction.Target target)
	{
		return target.onTerrain;
	}

	public override Construction.Placement DoPlacement(Construction.Target target)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		Vector3 direction = ((Ray)(ref target.ray)).direction;
		direction.y = 0f;
		((Vector3)(ref direction)).Normalize();
		Vector3 val = Vector3.up;
		if (alignToNormal)
		{
			val = target.normal;
		}
		Quaternion val2 = Quaternion.LookRotation(direction, val) * Quaternion.Euler(0f, eulerAngles.y, 0f) * Quaternion.Euler(target.rotation);
		Vector3 val3 = target.position;
		val3 -= val2 * position;
		Construction.Placement result = new Construction.Placement(target);
		result.rotation = val2;
		result.position = val3;
		return result;
	}
}


using UnityEngine;

public class StabilitySocket : Socket_Base
{
	[Range(0f, 1f)]
	public float support = 1f;

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.DrawWireCube(selectCenter, selectSize);
	}

	public override bool TestTarget(Construction.Target target)
	{
		return false;
	}

	public override bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanConnect(position, rotation, socket, socketPosition, socketRotation))
		{
			return false;
		}
		OBB selectBounds = GetSelectBounds(position, rotation);
		OBB selectBounds2 = socket.GetSelectBounds(socketPosition, socketRotation);
		return ((OBB)(ref selectBounds)).Intersects(selectBounds2);
	}
}


using System;

public class WeakpointProperties : PrefabAttribute
{
	public bool BlockWhenRoofAttached;

	protected override Type GetIndexedType()
	{
		return typeof(WeakpointProperties);
	}
}


using UnityEngine;

public class CanvasOrderHack : MonoBehaviour
{
	private void OnEnable()
	{
		Canvas[] componentsInChildren = ((Component)this).GetComponentsInChildren<Canvas>(true);
		foreach (Canvas val in componentsInChildren)
		{
			if (val.overrideSorting)
			{
				int sortingOrder = val.sortingOrder;
				val.sortingOrder = sortingOrder + 1;
			}
		}
		componentsInChildren = ((Component)this).GetComponentsInChildren<Canvas>(true);
		foreach (Canvas val2 in componentsInChildren)
		{
			if (val2.overrideSorting)
			{
				int sortingOrder = val2.sortingOrder;
				val2.sortingOrder = sortingOrder - 1;
			}
		}
	}
}


using UnityEngine;

public class AnimalSkin : MonoBehaviour, IClientComponent
{
	public SkinnedMeshRenderer[] animalMesh;

	public AnimalMultiSkin[] animalSkins;

	private Model model;

	public bool dontRandomizeOnStart;

	private void Start()
	{
		model = ((Component)this).gameObject.GetComponent<Model>();
		if (!dontRandomizeOnStart)
		{
			int iSkin = Mathf.FloorToInt((float)Random.Range(0, animalSkins.Length));
			ChangeSkin(iSkin);
		}
	}

	public void ChangeSkin(int iSkin)
	{
		if (animalSkins.Length == 0)
		{
			return;
		}
		iSkin = Mathf.Clamp(iSkin, 0, animalSkins.Length - 1);
		SkinnedMeshRenderer[] array = animalMesh;
		foreach (SkinnedMeshRenderer val in array)
		{
			Material[] sharedMaterials = ((Renderer)val).sharedMaterials;
			if (sharedMaterials != null)
			{
				for (int j = 0; j < sharedMaterials.Length; j++)
				{
					sharedMaterials[j] = animalSkins[iSkin].multiSkin[j];
				}
				((Renderer)val).sharedMaterials = sharedMaterials;
			}
		}
		if ((Object)(object)model != (Object)null)
		{
			model.skin = iSkin;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class AnimalMultiSkin
{
	public Material[] multiSkin;
}


using UnityEngine;

public class AnimalAnimation : MonoBehaviour, IClientComponent
{
	public BaseEntity Entity;

	public BaseNpc Target;

	public Animator Animator;

	public MaterialEffect FootstepEffects;

	public Transform[] Feet;

	[Tooltip("Ensure there is a float param called idleOffset if this is enabled")]
	public bool hasIdleOffset;

	[Tooltip("Check animation clip weights when playing sounds so we don't play sounds for clips that are blended out")]
	public bool enforceClipWeights;

	[ReadOnly]
	public string BaseFolder;

	public string OverrideBaseFolder;

	public float RequiredCameraDistanceForSfx;
}


using UnityEngine;

public class AnimalFootIK : MonoBehaviour
{
	public Transform[] Feet;

	public Animator animator;

	public float maxWeightDistance = 0.1f;

	public float minWeightDistance = 0.025f;

	public float actualFootOffset = 0.01f;

	public bool GroundSample(Vector3 origin, out RaycastHit hit)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (Physics.Raycast(origin + Vector3.up * 0.5f, Vector3.down, ref hit, 1f, 455155969))
		{
			return true;
		}
		return false;
	}

	public void Start()
	{
	}

	public AvatarIKGoal GoalFromIndex(int index)
	{
		return (AvatarIKGoal)(index switch
		{
			0 => 2, 
			1 => 3, 
			2 => 0, 
			3 => 1, 
			_ => 2, 
		});
	}

	private void OnAnimatorIK(int layerIndex)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"animal ik!");
		for (int i = 0; i < 4; i++)
		{
			Transform val = Feet[i];
			AvatarIKGoal val2 = GoalFromIndex(i);
			_ = Vector3.up;
			Vector3 position = ((Component)val).transform.position;
			float iKPositionWeight = animator.GetIKPositionWeight(val2);
			if (GroundSample(((Component)val).transform.position - Vector3.down * actualFootOffset, out var hit))
			{
				_ = ((RaycastHit)(ref hit)).normal;
				position = ((RaycastHit)(ref hit)).point;
				float num = Vector3.Distance(((Component)val).transform.position - Vector3.down * actualFootOffset, position);
				iKPositionWeight = 1f - Mathf.InverseLerp(minWeightDistance, maxWeightDistance, num);
				animator.SetIKPosition(val2, position + Vector3.up * actualFootOffset);
			}
			else
			{
				iKPositionWeight = 0f;
			}
			animator.SetIKPositionWeight(val2, iKPositionWeight);
		}
	}
}


using UnityEngine;

public class AvatarSwitcher : StateMachineBehaviour
{
	public Avatar ToApply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateEnter(animator, stateInfo, layerIndex);
		if ((Object)(object)ToApply != (Object)null)
		{
			animator.avatar = ToApply;
			animator.Play(((AnimatorStateInfo)(ref stateInfo)).shortNameHash, layerIndex);
		}
	}
}


using System;
using UnityEngine;

public class BlendShapeController : MonoBehaviour
{
	public enum BlendMode
	{
		Idle,
		Happy,
		Angry
	}

	[Serializable]
	public struct BlendState
	{
		[Range(0f, 100f)]
		public float[] States;

		public BlendMode Mode;
	}

	public SkinnedMeshRenderer TargetRenderer;

	public BlendState[] States;

	public float LerpSpeed = 0.25f;

	public BlendMode CurrentMode;
}


public enum BlendMode
{
	Idle,
	Happy,
	Angry
}


using System;
using UnityEngine;

[Serializable]
public struct BlendState
{
	[Range(0f, 100f)]
	public float[] States;

	public BlendMode Mode;
}


using UnityEngine;

public class BlendTreeEventSender : StateMachineBehaviour
{
	[Tooltip("The name of the Blend Parameter to monitor.")]
	public string blendParameter = "BlendParameter";

	[Tooltip("The blend value threshold to trigger the event.")]
	public float triggerThreshold = 0.5f;

	[Tooltip("The event name that will be sent via SendMessage.")]
	public string eventName = "OnAnimationEvent";

	[Tooltip("Custom string parameter to send along with the event.")]
	public string eventParameter = "";

	[Tooltip("Should the event only fire once per entry?")]
	public bool fireOnce = true;

	private bool eventTriggered;

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		float @float = animator.GetFloat(blendParameter);
		if (@float >= triggerThreshold && (!fireOnce || !eventTriggered))
		{
			FireEvent(animator);
			eventTriggered = true;
		}
		if (@float < triggerThreshold)
		{
			eventTriggered = false;
		}
	}

	private void FireEvent(Animator animator)
	{
		((Component)animator).gameObject.SendMessage(eventName, (object)eventParameter, (SendMessageOptions)1);
	}
}


using UnityEngine;
using UnityEngine.Animations;

public class CurveStateSpeed : StateMachineBehaviour
{
	public AnimationCurve SpeedCurve = AnimationCurve.Constant(0f, 1f, 1f);

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex, controller);
		float speed = 1f;
		if (!animator.IsInTransition(layerIndex))
		{
			speed = SpeedCurve.Evaluate(((AnimatorStateInfo)(ref stateInfo)).normalizedTime);
		}
		animator.speed = speed;
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateExit(animator, stateInfo, layerIndex);
		animator.speed = 1f;
	}
}


using UnityEngine;

public class GameObjectToggleState : StateMachineBehaviour
{
	public bool UseCurve;

	[Tooltip("The normalised range in the animation in which to apply the TargetState")]
	[MinMax(0f, 1f)]
	public Vector2 ValidNormalisedRange;

	public AnimationCurve CurveRange = AnimationCurve.Linear(0f, 0f, 1f, 0f);

	[Tooltip("What state to set the target object to, true = enabled, false = disabled")]
	public bool TargetState;

	[Tooltip("What gameObject to toggle (ensure it's a unique name in the hierarchy)")]
	public string GameObjectName;

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex);
		bool flag = (UseCurve ? (CurveRange.Evaluate(((AnimatorStateInfo)(ref stateInfo)).normalizedTime) > 0f) : (((AnimatorStateInfo)(ref stateInfo)).normalizedTime > ValidNormalisedRange.x && ((AnimatorStateInfo)(ref stateInfo)).normalizedTime < ValidNormalisedRange.y));
		Model model = ((Component)animator).gameObject.GetComponent<Model>();
		if ((Object)(object)model == (Object)null)
		{
			model = ((Component)animator).gameObject.GetComponentInParent<Model>();
		}
		if ((Object)(object)model != (Object)null)
		{
			Transform val = model.FindBone(GameObjectName);
			if ((Object)(object)val != (Object)null)
			{
				((Component)val).gameObject.SetActive(flag ? TargetState : (!TargetState));
			}
		}
	}
}


using UnityEngine;

public class AverageVelocity
{
	private Vector3 pos;

	private float time;

	private float lastEntry;

	private float averageSpeed;

	private Vector3 averageVelocity;

	public float Speed => averageSpeed;

	public Vector3 Average => averageVelocity;

	public void Record(Vector3 newPos)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - time;
		if (!(num < 0.1f))
		{
			if (((Vector3)(ref pos)).sqrMagnitude > 0f)
			{
				Vector3 val = newPos - pos;
				averageVelocity = val * (1f / num);
				averageSpeed = ((Vector3)(ref averageVelocity)).magnitude;
			}
			time = Time.time;
			pos = newPos;
		}
	}
}


using UnityEngine;

public class NpcWalkAnimation : MonoBehaviour, IClientComponent
{
	public Vector3 HipFudge = new Vector3(-90f, 0f, 90f);

	public BaseNpc Npc;

	public Animator Animator;

	public Transform HipBone;

	public Transform LookBone;

	public bool UpdateWalkSpeed = true;

	public bool UpdateFacingDirection = true;

	public bool UpdateGroundNormal = true;

	public Transform alignmentRoot;

	public bool LaggyAss = true;

	public bool LookAtTarget;

	public float MaxLaggyAssRotation = 70f;

	public float MaxWalkAnimSpeed = 25f;

	public bool UseDirectionBlending;

	public bool useTurnPosing;

	public float turnPoseScale = 0.5f;

	public float laggyAssLerpScale = 15f;

	public bool skeletonChainInverted;
}


using UnityEngine;

public class ReliableEventSender : StateMachineBehaviour
{
	[Header("State Enter")]
	public string StateEnter;

	[Header("Mid State")]
	public string MidStateEvent;

	[Range(0f, 1f)]
	public float TargetEventTime;
}


using UnityEngine;

public class ShieldBlockStateBehaviour : StateMachineBehaviour
{
}


using UnityEngine;

public class StateLayerController : StateMachineBehaviour
{
	public int TargetLayer = 2;
}


using UnityEngine;

public class SuppressEyeMovement : StateMachineBehaviour
{
}


using UnityEngine;

public class AnimationEventForward : MonoBehaviour
{
	public GameObject targetObject;

	public void Event(string type)
	{
		targetObject.SendMessage(type);
	}
}


using ConVar;
using UnityEngine;
using UnityEngine.Audio;

public class AudioSettings : MonoBehaviour
{
	public static float duckingFactor = 1f;

	public AudioMixer mixer;

	private void Update()
	{
		if (!((Object)(object)mixer == (Object)null))
		{
			mixer.SetFloat("MasterVol", LinearToDecibel(Audio.master * duckingFactor));
			float num = default(float);
			mixer.GetFloat("MusicVol", ref num);
			if (!LevelManager.isLoaded || !MainCamera.isValid)
			{
				mixer.SetFloat("MusicVol", Mathf.Lerp(num, LinearToDecibel(Audio.musicvolumemenu), Time.deltaTime));
			}
			else
			{
				mixer.SetFloat("MusicVol", Mathf.Lerp(num, LinearToDecibel(Audio.musicvolume), Time.deltaTime));
			}
			float num2 = 1f - (((Object)(object)SingletonComponent<MixerSnapshotManager>.Instance == (Object)null) ? 0f : SingletonComponent<MixerSnapshotManager>.Instance.deafness);
			mixer.SetFloat("WorldVol", LinearToDecibel(Audio.game * num2));
			mixer.SetFloat("UIVol", LinearToDecibel(Audio.game * num2));
			mixer.SetFloat("WorldVolFlashbang", LinearToDecibel(Audio.game));
			mixer.SetFloat("VoiceVol", LinearToDecibel(Audio.voices * num2));
			mixer.SetFloat("InstrumentVol", LinearToDecibel(Audio.instruments * num2));
			float num3 = LinearToDecibel(Audio.voiceProps * num2) - 28.7f;
			mixer.SetFloat("VoicePropsVol", num3 * num2);
			mixer.SetFloat("SeasonalEventsVol", LinearToDecibel(Audio.eventAudio * num2));
		}
	}

	private float LinearToDecibel(float linear)
	{
		if (linear > 0f)
		{
			return 20f * Mathf.Log10(linear);
		}
		return -144f;
	}
}


using System;
using System.Text;
using Facepunch;
using Rust.Workshop;
using TMPro;
using UnityEngine;

public class BenchmarkInfo : SingletonComponent<BenchmarkInfo>
{
	public static string BenchmarkTitle;

	public static string BenchmarkSubtitle;

	public TextMeshProUGUI PerformanceText;

	public TextMeshProUGUI SystemInfoText;

	private StringBuilder sb = new StringBuilder();

	private RealTimeSince timeSinceUpdated;

	private void Start()
	{
		string text = Environment.MachineName + "\n";
		text = text + SystemInfo.operatingSystem + "\n";
		text += $"{(double)SystemInfo.systemMemorySize / 1024.0:0}GB RAM\n";
		text = text + SystemInfo.processorType + "\n";
		text += $"{SystemInfo.graphicsDeviceName} ({(double)SystemInfo.graphicsMemorySize / 1024.0:0}GB)\n";
		text += "\n";
		text = text + BuildInfo.Current.Build.Node + " / " + BuildInfo.Current.Scm.Date + "\n";
		text = text + BuildInfo.Current.Scm.Repo + "/" + BuildInfo.Current.Scm.Branch + "#" + BuildInfo.Current.Scm.ChangeId + "\n";
		text = text + BuildInfo.Current.Scm.Author + " - " + BuildInfo.Current.Scm.Comment + "\n";
		((TMP_Text)SystemInfoText).text = text;
	}

	private void Update()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (!(RealTimeSince.op_Implicit(timeSinceUpdated) < 0.25f))
		{
			timeSinceUpdated = RealTimeSince.op_Implicit(0f);
			sb.Clear();
			sb.AppendLine(BenchmarkTitle);
			sb.AppendLine(BenchmarkSubtitle);
			sb.AppendLine();
			sb.Append(Performance.current.frameRate).Append(" FPS");
			sb.Append(" / ").Append(Performance.current.frameTime.ToString("0.0")).Append("ms");
			sb.AppendLine().Append(Performance.current.memoryAllocations).Append(" MB");
			sb.Append(" / ").Append(Performance.current.memoryCollections).Append(" GC");
			sb.AppendLine().Append(Performance.current.memoryUsageSystem).Append(" RAM");
			sb.AppendLine().Append(Performance.current.loadBalancerTasks).Append(" TASKS");
			sb.Append(" / ").Append(WorkshopSkin.QueuedCount).Append(" SKINS");
			sb.Append(" / ").Append(Performance.current.invokeHandlerTasks).Append(" INVOKES");
			sb.AppendLine();
			sb.AppendLine(DateTime.Now.ToShortDateString() + " " + DateTime.Now.ToLongTimeString());
			((TMP_Text)PerformanceText).text = sb.ToString();
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class BoneDictionary
{
	public Transform transform;

	public Transform[] transforms;

	public string[] names;

	private Dictionary<string, Transform> nameDict = new Dictionary<string, Transform>(StringComparer.OrdinalIgnoreCase);

	private Dictionary<uint, Transform> hashDict = new Dictionary<uint, Transform>();

	private Dictionary<Transform, uint> transformDict = new Dictionary<Transform, uint>();

	public int Count => transforms.Length;

	public BoneDictionary(Transform rootBone)
	{
		transform = rootBone;
		transforms = ((Component)rootBone).GetComponentsInChildren<Transform>(true);
		names = new string[transforms.Length];
		for (int i = 0; i < transforms.Length; i++)
		{
			Transform val = transforms[i];
			if ((Object)(object)val != (Object)null)
			{
				names[i] = ((Object)val).name;
			}
		}
		BuildBoneDictionary();
	}

	public BoneDictionary(Transform rootBone, Transform[] boneTransforms, string[] boneNames)
	{
		transform = rootBone;
		transforms = boneTransforms;
		names = boneNames;
		BuildBoneDictionary();
	}

	private void BuildBoneDictionary()
	{
		for (int i = 0; i < transforms.Length; i++)
		{
			Transform val = transforms[i];
			string text = names[i];
			uint num = StringPool.Get(text);
			if (!nameDict.ContainsKey(text))
			{
				nameDict.Add(text, val);
			}
			if (!hashDict.ContainsKey(num))
			{
				hashDict.Add(num, val);
			}
			if ((Object)(object)val != (Object)null && !transformDict.ContainsKey(val))
			{
				transformDict.Add(val, num);
			}
		}
	}

	public Transform FindBone(string name, bool defaultToRoot = true)
	{
		Transform value = null;
		if (nameDict.TryGetValue(name, out value))
		{
			return value;
		}
		if (!defaultToRoot)
		{
			return null;
		}
		return transform;
	}

	public Transform FindBone(uint hash, bool defaultToRoot = true)
	{
		Transform value = null;
		if (hashDict.TryGetValue(hash, out value))
		{
			return value;
		}
		if (!defaultToRoot)
		{
			return null;
		}
		return transform;
	}

	public uint FindBoneID(Transform transform)
	{
		if (!transformDict.TryGetValue(transform, out var value))
		{
			return StringPool.closest;
		}
		return value;
	}
}


using UnityEngine;

public class BoneRetarget : MonoBehaviour
{
	public bool preserveInFirstPerson;

	public bool restoreBeforePooling;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class AttackHeliCamOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class CCTVOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ClimateOverlay : MonoBehaviour
{
	[Range(0f, 1f)]
	public float blendingSpeed = 1f;

	public PostProcessVolume[] biomeVolumes;

	public const int biomeCount = 5;

	public const int volumeCount = 6;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ColdOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float smoothTime = 1f;

	public bool preventInstantiation;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ExplosionsOverlay : MonoBehaviour, IClientComponent
{
	public static ExplosionsOverlay Instance;

	public PostProcessVolume postProcessVolume;

	public AnimationCurve radialBlurStartCurve;

	public AnimationCurve radialBlurAmountCurve;

	public AnimationCurve lensDirtinessCurve;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class FlashbangOverlay : MonoBehaviour, IClientComponent
{
	public static FlashbangOverlay Instance;

	public PostProcessVolume postProcessVolume;

	public AnimationCurve burnIntensityCurve;

	public AnimationCurve whiteoutIntensityCurve;

	public SoundDefinition deafLoopDef;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HomingLauncherCamOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public NVGCamera nvgCameraOverlay;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HotOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float smoothTime = 1f;

	public bool preventInstantiation;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HurtOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float smoothTime = 1f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HurtPunch : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public static float punchHurtDuration = 0.334f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class NightLightOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public float VisionCareExtraDistance = 20f;

	public float VisionCareExtraBrightness = 0.01f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class OxygenOverlay : MonoBehaviour
{
	[SerializeField]
	private PostProcessVolume postProcessVolume;

	[SerializeField]
	private float smoothTime = 1f;

	[Tooltip("If true, only show this effect when the player is mounted in a submarine.")]
	[SerializeField]
	private bool submarinesOnly;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class RadiationOverlay : MonoBehaviour
{
	public SoundDefinition[] geigerSounds;

	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class SharpenAndVignetteOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class SubmarineOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


using UnityStandardAssets.CinematicEffects;

public class TonemappingOverlay : ImageEffectLayer
{
	public TonemappingColorGrading tonemapping;
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class WaterOverlay : MonoBehaviour, IClientComponent
{
	[Serializable]
	public struct EffectParams
	{
		public float scatterCoefficient;

		public float scatterStrength;

		public bool blur;

		public float blurDistance;

		public float blurSize;

		public bool wiggle;

		public float wiggleSpeed;

		public bool chromaticAberration;

		public bool godRays;

		public static EffectParams Default = new EffectParams
		{
			scatterCoefficient = 1f,
			scatterStrength = 1f,
			blur = true,
			blurDistance = 6.5f,
			blurSize = 4f,
			wiggle = true,
			wiggleSpeed = 0.7f,
			chromaticAberration = false,
			godRays = false
		};

		public static EffectParams DefaultAdmin = new EffectParams
		{
			scatterCoefficient = 0.025f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = true,
			godRays = false
		};

		public static EffectParams DefaultGoggles = new EffectParams
		{
			scatterCoefficient = 0.05f,
			scatterStrength = 1f,
			blur = true,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = true,
			wiggleSpeed = 2f,
			chromaticAberration = true,
			godRays = true
		};

		public static EffectParams DefaultSubmarine = new EffectParams
		{
			scatterCoefficient = 0.025f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = false,
			godRays = false
		};

		public static EffectParams DefaultUnderwaterLab = new EffectParams
		{
			scatterCoefficient = 0.005f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = true,
			godRays = false
		};

		public static EffectParams DefaultCinematic = new EffectParams
		{
			scatterCoefficient = 0.025f,
			scatterStrength = 1f,
			blur = false,
			blurDistance = 10f,
			blurSize = 2f,
			wiggle = false,
			wiggleSpeed = 0f,
			chromaticAberration = true,
			godRays = false
		};
	}

	public PostProcessVolume postProcessVolume;

	public PostProcessVolume blurPostProcessVolume;

	public EffectParams defaultParams = EffectParams.Default;

	public EffectParams adminParams = EffectParams.DefaultAdmin;

	public EffectParams gogglesParams = EffectParams.DefaultGoggles;

	public EffectParams submarineParams = EffectParams.DefaultSubmarine;

	public EffectParams underwaterLabParams = EffectParams.DefaultUnderwaterLab;

	public EffectParams cinematicParams = EffectParams.DefaultCinematic;

	public Material[] UnderwaterFogMaterials;
}


using System;

[Serializable]
public struct EffectParams
{
	public float scatterCoefficient;

	public float scatterStrength;

	public bool blur;

	public float blurDistance;

	public float blurSize;

	public bool wiggle;

	public float wiggleSpeed;

	public bool chromaticAberration;

	public bool godRays;

	public static EffectParams Default = new EffectParams
	{
		scatterCoefficient = 1f,
		scatterStrength = 1f,
		blur = true,
		blurDistance = 6.5f,
		blurSize = 4f,
		wiggle = true,
		wiggleSpeed = 0.7f,
		chromaticAberration = false,
		godRays = false
	};

	public static EffectParams DefaultAdmin = new EffectParams
	{
		scatterCoefficient = 0.025f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = true,
		godRays = false
	};

	public static EffectParams DefaultGoggles = new EffectParams
	{
		scatterCoefficient = 0.05f,
		scatterStrength = 1f,
		blur = true,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = true,
		wiggleSpeed = 2f,
		chromaticAberration = true,
		godRays = true
	};

	public static EffectParams DefaultSubmarine = new EffectParams
	{
		scatterCoefficient = 0.025f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = false,
		godRays = false
	};

	public static EffectParams DefaultUnderwaterLab = new EffectParams
	{
		scatterCoefficient = 0.005f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = true,
		godRays = false
	};

	public static EffectParams DefaultCinematic = new EffectParams
	{
		scatterCoefficient = 0.025f,
		scatterStrength = 1f,
		blur = false,
		blurDistance = 10f,
		blurSize = 2f,
		wiggle = false,
		wiggleSpeed = 0f,
		chromaticAberration = true,
		godRays = false
	};
}


using UnityEngine;
using UnityEngine.UI;

public class CameraMan : SingletonComponent<CameraMan>
{
	public static string DefaultSaveName = string.Empty;

	public const string SavePositionExtension = ".cam";

	public const string SavePositionDirectory = "camsaves";

	public bool OnlyControlWhenCursorHidden = true;

	public bool NeedBothMouseButtonsToZoom;

	public float LookSensitivity = 1f;

	public float MoveSpeed = 1f;

	public static float GuideAspect = 4f;

	public static float GuideRatio = 3f;

	public Canvas canvas;

	public Graphic[] guides;
}


using ConVar;
using UnityEngine;

public class CameraSettings : MonoBehaviour, IClientComponent
{
	private Camera cam;

	private void OnEnable()
	{
		cam = ((Component)this).GetComponent<Camera>();
	}

	private void Update()
	{
		cam.farClipPlane = Mathf.Clamp(Graphics.drawdistance, 500f, 2500f);
	}
}


public class Client : SingletonComponent<Client>
{
	public static Phrase loading_loading = new Phrase("loading.loading", "Loading");

	public static Phrase loading_connecting = new Phrase("loading.connecting", "Connecting");

	public static Phrase loading_connectionaccepted = new Phrase("loading.connectionaccepted", "Connection Accepted");

	public static Phrase loading_connecting_negotiate = new Phrase("loading.connecting.negotiate", "Negotiating Connection");

	public static Phrase loading_level = new Phrase("loading.loadinglevel", "Loading Level");

	public static Phrase loading_skinnablewarmup = new Phrase("loading.skinnablewarmup", "Skinnable Warmup");

	public static Phrase loading_preloadcomplete = new Phrase("loading.preloadcomplete", "Preload Complete");

	public static Phrase loading_openingscene = new Phrase("loading.openingscene", "Opening Scene");

	public static Phrase loading_clientready = new Phrase("loading.clientready", "Client Ready");

	public static Phrase loading_prefabwarmup = new Phrase("loading.prefabwarmup", "Warming Prefabs [{0}/{1}]");

	public static Phrase loading_queue = new Phrase("loading.queue", "Queue");

	public static Phrase loading_queue_status = new Phrase("loading.queue.status", "{0:N0} PLAYERS AHEAD OF YOU, {1:N0} PLAYERS BEHIND");

	public static Phrase loading_queue_next = new Phrase("loading.queue.next", "YOU'RE NEXT - {1:N0} PLAYERS BEHIND YOU");
}


public abstract class ComponentInfo<T> : ComponentInfo
{
	public T component;

	public void Initialize(T source)
	{
		component = source;
		Setup();
	}
}


using UnityEngine;

public abstract class ComponentInfo : MonoBehaviour
{
	public abstract void Setup();

	public abstract void Reset();
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class MeshCache
{
	[Serializable]
	public class Data
	{
		public Mesh mesh;

		public Vector3[] vertices;

		public Vector3[] normals;

		public Vector4[] tangents;

		public Color32[] colors32;

		public int[] triangles;

		public Vector2[] uv;

		public Vector2[] uv2;

		public Vector2[] uv3;

		public Vector2[] uv4;

		public Bounds bounds;
	}

	public static Dictionary<Mesh, Data> dictionary = new Dictionary<Mesh, Data>();

	public static Data Get(Mesh mesh)
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (!dictionary.TryGetValue(mesh, out var value))
		{
			value = new Data();
			value.mesh = mesh;
			value.vertices = mesh.vertices;
			value.normals = mesh.normals;
			value.tangents = mesh.tangents;
			value.colors32 = mesh.colors32;
			value.triangles = mesh.triangles;
			value.uv = mesh.uv;
			value.uv2 = mesh.uv2;
			value.uv3 = mesh.uv3;
			value.uv4 = mesh.uv4;
			value.bounds = mesh.bounds;
			dictionary.Add(mesh, value);
		}
		return value;
	}
}


using System;
using UnityEngine;

[Serializable]
public class Data
{
	public Mesh mesh;

	public Vector3[] vertices;

	public Vector3[] normals;

	public Vector4[] tangents;

	public Color32[] colors32;

	public int[] triangles;

	public Vector2[] uv;

	public Vector2[] uv2;

	public Vector2[] uv3;

	public Vector2[] uv4;

	public Bounds bounds;
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class MeshColliderData
{
	public List<int> triangles;

	public List<Vector3> vertices;

	public List<Vector3> normals;

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref vertices);
		}
		if (normals != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref normals);
		}
	}

	public void Clear()
	{
		if (triangles != null)
		{
			triangles.Clear();
		}
		if (vertices != null)
		{
			vertices.Clear();
		}
		if (normals != null)
		{
			normals.Clear();
		}
	}

	public void Apply(Mesh mesh)
	{
		mesh.Clear();
		if (vertices != null)
		{
			mesh.SetVertices(vertices);
		}
		if (triangles != null)
		{
			mesh.SetTriangles(triangles, 0);
		}
		if (normals != null)
		{
			if (normals.Count == vertices.Count)
			{
				mesh.SetNormals(normals);
			}
			else if (normals.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping collider normals because some meshes were missing them.");
			}
		}
	}

	public void Combine(MeshColliderGroup meshGroup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < ((List<MeshColliderInstance>)(object)meshGroup).Count; i++)
		{
			MeshColliderInstance meshColliderInstance = ((List<MeshColliderInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshColliderInstance.position, meshColliderInstance.rotation, meshColliderInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshColliderInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshColliderInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshColliderInstance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(meshColliderInstance.data.vertices[k]));
			}
			for (int l = 0; l < meshColliderInstance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(meshColliderInstance.data.normals[l]));
			}
		}
	}

	public void Combine(MeshColliderGroup meshGroup, MeshColliderLookup colliderLookup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < ((List<MeshColliderInstance>)(object)meshGroup).Count; i++)
		{
			MeshColliderInstance instance = ((List<MeshColliderInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(instance.position, instance.rotation, instance.scale);
			int count = vertices.Count;
			for (int j = 0; j < instance.data.triangles.Length; j++)
			{
				triangles.Add(count + instance.data.triangles[j]);
			}
			for (int k = 0; k < instance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(instance.data.vertices[k]));
			}
			for (int l = 0; l < instance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(instance.data.normals[l]));
			}
			colliderLookup.Add(instance);
		}
	}
}


public class MeshColliderGroup : PooledList<MeshColliderInstance>
{
}


using UnityEngine;

public struct MeshColliderInstance
{
	public Transform transform;

	public Rigidbody rigidbody;

	public Collider collider;

	public OBB bounds;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public MeshCache.Data data;

	public Mesh mesh
	{
		get
		{
			return data.mesh;
		}
		set
		{
			data = MeshCache.Get(value);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class MeshColliderLookup
{
	public class LookupGroup
	{
		public List<LookupEntry> data = new List<LookupEntry>();

		public List<int> indices = new List<int>();

		public void Clear()
		{
			data.Clear();
			indices.Clear();
		}

		public void Add(MeshColliderInstance instance)
		{
			data.Add(new LookupEntry(instance));
			int item = data.Count - 1;
			int num = instance.data.triangles.Length / 3;
			for (int i = 0; i < num; i++)
			{
				indices.Add(item);
			}
		}

		public LookupEntry Get(int index)
		{
			return data[indices[index]];
		}
	}

	public struct LookupEntry
	{
		public Transform transform;

		public Rigidbody rigidbody;

		public Collider collider;

		public OBB bounds;

		public LookupEntry(MeshColliderInstance instance)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			transform = instance.transform;
			rigidbody = instance.rigidbody;
			collider = instance.collider;
			bounds = instance.bounds;
		}
	}

	public LookupGroup src = new LookupGroup();

	public LookupGroup dst = new LookupGroup();

	public void Apply()
	{
		LookupGroup lookupGroup = src;
		src = dst;
		dst = lookupGroup;
		dst.Clear();
	}

	public void Add(MeshColliderInstance instance)
	{
		dst.Add(instance);
	}

	public LookupEntry Get(int index)
	{
		return src.Get(index);
	}
}


using System.Collections.Generic;

public class LookupGroup
{
	public List<LookupEntry> data = new List<LookupEntry>();

	public List<int> indices = new List<int>();

	public void Clear()
	{
		data.Clear();
		indices.Clear();
	}

	public void Add(MeshColliderInstance instance)
	{
		data.Add(new LookupEntry(instance));
		int item = data.Count - 1;
		int num = instance.data.triangles.Length / 3;
		for (int i = 0; i < num; i++)
		{
			indices.Add(item);
		}
	}

	public LookupEntry Get(int index)
	{
		return data[indices[index]];
	}
}


using UnityEngine;

public struct LookupEntry
{
	public Transform transform;

	public Rigidbody rigidbody;

	public Collider collider;

	public OBB bounds;

	public LookupEntry(MeshColliderInstance instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		transform = instance.transform;
		rigidbody = instance.rigidbody;
		collider = instance.collider;
		bounds = instance.bounds;
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class MeshData
{
	public List<int> triangles;

	public List<Vector3> vertices;

	public List<Vector3> normals;

	public List<Vector4> tangents;

	public List<Color32> colors32;

	public List<Vector2> uv;

	public List<Vector2> uv2;

	public List<Vector4> positions;

	public void AllocMinimal()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
		if (tangents == null)
		{
			tangents = Pool.Get<List<Vector4>>();
		}
		if (uv == null)
		{
			uv = Pool.Get<List<Vector2>>();
		}
	}

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
		if (tangents == null)
		{
			tangents = Pool.Get<List<Vector4>>();
		}
		if (colors32 == null)
		{
			colors32 = Pool.Get<List<Color32>>();
		}
		if (uv == null)
		{
			uv = Pool.Get<List<Vector2>>();
		}
		if (uv2 == null)
		{
			uv2 = Pool.Get<List<Vector2>>();
		}
		if (positions == null)
		{
			positions = Pool.Get<List<Vector4>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref vertices);
		}
		if (normals != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref normals);
		}
		if (tangents != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref tangents);
		}
		if (colors32 != null)
		{
			Pool.FreeUnmanaged<Color32>(ref colors32);
		}
		if (uv != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv);
		}
		if (uv2 != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv2);
		}
		if (positions != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref positions);
		}
	}

	public void Clear()
	{
		if (triangles != null)
		{
			triangles.Clear();
		}
		if (vertices != null)
		{
			vertices.Clear();
		}
		if (normals != null)
		{
			normals.Clear();
		}
		if (tangents != null)
		{
			tangents.Clear();
		}
		if (colors32 != null)
		{
			colors32.Clear();
		}
		if (uv != null)
		{
			uv.Clear();
		}
		if (uv2 != null)
		{
			uv2.Clear();
		}
		if (positions != null)
		{
			positions.Clear();
		}
	}

	public void Apply(Mesh mesh)
	{
		mesh.Clear();
		if (vertices != null)
		{
			mesh.SetVertices(vertices);
		}
		if (triangles != null)
		{
			mesh.SetTriangles(triangles, 0);
		}
		if (normals != null)
		{
			if (normals.Count == vertices.Count)
			{
				mesh.SetNormals(normals);
			}
			else if (normals.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh normals because some meshes were missing them.");
			}
		}
		if (tangents != null)
		{
			if (tangents.Count == vertices.Count)
			{
				mesh.SetTangents(tangents);
			}
			else if (tangents.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh tangents because some meshes were missing them.");
			}
		}
		if (colors32 != null)
		{
			if (colors32.Count == vertices.Count)
			{
				mesh.SetColors(colors32);
			}
			else if (colors32.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh colors because some meshes were missing them.");
			}
		}
		if (uv != null)
		{
			if (uv.Count == vertices.Count)
			{
				mesh.SetUVs(0, uv);
			}
			else if (uv.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh uvs because some meshes were missing them.");
			}
		}
		if (uv2 != null)
		{
			if (uv2.Count == vertices.Count)
			{
				mesh.SetUVs(1, uv2);
			}
			else if (uv2.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping mesh uv2s because some meshes were missing them.");
			}
		}
		if (positions != null)
		{
			mesh.SetUVs(2, positions);
		}
	}

	public void Combine(MeshGroup meshGroup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshInstance>)(object)meshGroup).Count; i++)
		{
			MeshInstance meshInstance = ((List<MeshInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshInstance.position, meshInstance.rotation, meshInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshInstance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(meshInstance.data.vertices[k]));
				positions.Add(Vector4.op_Implicit(meshInstance.position));
			}
			for (int l = 0; l < meshInstance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(meshInstance.data.normals[l]));
			}
			for (int m = 0; m < meshInstance.data.tangents.Length; m++)
			{
				Vector4 val2 = meshInstance.data.tangents[m];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				tangents.Add(new Vector4(val4.x, val4.y, val4.z, val2.w));
			}
			for (int n = 0; n < meshInstance.data.colors32.Length; n++)
			{
				colors32.Add(meshInstance.data.colors32[n]);
			}
			for (int num = 0; num < meshInstance.data.uv.Length; num++)
			{
				uv.Add(meshInstance.data.uv[num]);
			}
			for (int num2 = 0; num2 < meshInstance.data.uv2.Length; num2++)
			{
				uv2.Add(meshInstance.data.uv2[num2]);
			}
		}
	}
}


public class MeshGroup : PooledList<MeshInstance>
{
}


using UnityEngine;

public struct MeshInstance
{
	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public MeshCache.Data data;

	public Mesh mesh
	{
		get
		{
			return data.mesh;
		}
		set
		{
			data = MeshCache.Get(value);
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class MeshRendererData
{
	public List<int> triangles;

	public List<Vector3> vertices;

	public List<Vector3> normals;

	public List<Vector4> tangents;

	public List<Color32> colors32;

	public List<Vector2> uv;

	public List<Vector2> uv2;

	public List<Vector4> positions;

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<Vector3>>();
		}
		if (normals == null)
		{
			normals = Pool.Get<List<Vector3>>();
		}
		if (tangents == null)
		{
			tangents = Pool.Get<List<Vector4>>();
		}
		if (colors32 == null)
		{
			colors32 = Pool.Get<List<Color32>>();
		}
		if (uv == null)
		{
			uv = Pool.Get<List<Vector2>>();
		}
		if (uv2 == null)
		{
			uv2 = Pool.Get<List<Vector2>>();
		}
		if (positions == null)
		{
			positions = Pool.Get<List<Vector4>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref vertices);
		}
		if (normals != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref normals);
		}
		if (tangents != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref tangents);
		}
		if (colors32 != null)
		{
			Pool.FreeUnmanaged<Color32>(ref colors32);
		}
		if (uv != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv);
		}
		if (uv2 != null)
		{
			Pool.FreeUnmanaged<Vector2>(ref uv2);
		}
		if (positions != null)
		{
			Pool.FreeUnmanaged<Vector4>(ref positions);
		}
	}

	public void Clear()
	{
		if (triangles != null)
		{
			triangles.Clear();
		}
		if (vertices != null)
		{
			vertices.Clear();
		}
		if (normals != null)
		{
			normals.Clear();
		}
		if (tangents != null)
		{
			tangents.Clear();
		}
		if (colors32 != null)
		{
			colors32.Clear();
		}
		if (uv != null)
		{
			uv.Clear();
		}
		if (uv2 != null)
		{
			uv2.Clear();
		}
		if (positions != null)
		{
			positions.Clear();
		}
	}

	public void Apply(Mesh mesh)
	{
		mesh.Clear();
		if (vertices != null)
		{
			mesh.SetVertices(vertices);
		}
		if (triangles != null)
		{
			mesh.SetTriangles(triangles, 0);
		}
		if (normals != null)
		{
			if (normals.Count == vertices.Count)
			{
				mesh.SetNormals(normals);
			}
			else if (normals.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer normals because some meshes were missing them.");
			}
		}
		if (tangents != null)
		{
			if (tangents.Count == vertices.Count)
			{
				mesh.SetTangents(tangents);
			}
			else if (tangents.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer tangents because some meshes were missing them.");
			}
		}
		if (colors32 != null)
		{
			if (colors32.Count == vertices.Count)
			{
				mesh.SetColors(colors32);
			}
			else if (colors32.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer colors because some meshes were missing them.");
			}
		}
		if (uv != null)
		{
			if (uv.Count == vertices.Count)
			{
				mesh.SetUVs(0, uv);
			}
			else if (uv.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer uvs because some meshes were missing them.");
			}
		}
		if (uv2 != null)
		{
			if (uv2.Count == vertices.Count)
			{
				mesh.SetUVs(1, uv2);
			}
			else if (uv2.Count > 0 && Batching.verbose > 0)
			{
				Debug.LogWarning((object)"Skipping renderer uv2s because some meshes were missing them.");
			}
		}
		if (positions != null)
		{
			mesh.SetUVs(2, positions);
		}
	}

	public void Combine(MeshRendererGroup meshGroup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshRendererInstance>)(object)meshGroup).Count; i++)
		{
			MeshRendererInstance meshRendererInstance = ((List<MeshRendererInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshRendererInstance.position, meshRendererInstance.rotation, meshRendererInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshRendererInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshRendererInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshRendererInstance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(meshRendererInstance.data.vertices[k]));
				positions.Add(Vector4.op_Implicit(meshRendererInstance.position));
			}
			for (int l = 0; l < meshRendererInstance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(meshRendererInstance.data.normals[l]));
			}
			for (int m = 0; m < meshRendererInstance.data.tangents.Length; m++)
			{
				Vector4 val2 = meshRendererInstance.data.tangents[m];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				tangents.Add(new Vector4(val4.x, val4.y, val4.z, val2.w));
			}
			for (int n = 0; n < meshRendererInstance.data.colors32.Length; n++)
			{
				colors32.Add(meshRendererInstance.data.colors32[n]);
			}
			for (int num = 0; num < meshRendererInstance.data.uv.Length; num++)
			{
				uv.Add(meshRendererInstance.data.uv[num]);
			}
			for (int num2 = 0; num2 < meshRendererInstance.data.uv2.Length; num2++)
			{
				uv2.Add(meshRendererInstance.data.uv2[num2]);
			}
		}
	}

	public void Combine(MeshRendererGroup meshGroup, MeshRendererLookup rendererLookup)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshRendererInstance>)(object)meshGroup).Count; i++)
		{
			MeshRendererInstance instance = ((List<MeshRendererInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(instance.position, instance.rotation, instance.scale);
			int count = vertices.Count;
			for (int j = 0; j < instance.data.triangles.Length; j++)
			{
				triangles.Add(count + instance.data.triangles[j]);
			}
			for (int k = 0; k < instance.data.vertices.Length; k++)
			{
				vertices.Add(((Matrix4x4)(ref val)).MultiplyPoint3x4(instance.data.vertices[k]));
				positions.Add(Vector4.op_Implicit(instance.position));
			}
			for (int l = 0; l < instance.data.normals.Length; l++)
			{
				normals.Add(((Matrix4x4)(ref val)).MultiplyVector(instance.data.normals[l]));
			}
			for (int m = 0; m < instance.data.tangents.Length; m++)
			{
				Vector4 val2 = instance.data.tangents[m];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				tangents.Add(new Vector4(val4.x, val4.y, val4.z, val2.w));
			}
			for (int n = 0; n < instance.data.colors32.Length; n++)
			{
				colors32.Add(instance.data.colors32[n]);
			}
			for (int num = 0; num < instance.data.uv.Length; num++)
			{
				uv.Add(instance.data.uv[num]);
			}
			for (int num2 = 0; num2 < instance.data.uv2.Length; num2++)
			{
				uv2.Add(instance.data.uv2[num2]);
			}
			rendererLookup.Add(instance);
		}
	}
}


public class MeshRendererGroup : PooledList<MeshRendererInstance>
{
}


using UnityEngine;

public struct MeshRendererInstance
{
	public Renderer renderer;

	public OBB bounds;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public MeshCache.Data data;

	public Mesh mesh
	{
		get
		{
			return data.mesh;
		}
		set
		{
			data = MeshCache.Get(value);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class MeshRendererLookup
{
	public class LookupGroup
	{
		public List<LookupEntry> data = new List<LookupEntry>();

		public void Clear()
		{
			data.Clear();
		}

		public void Add(MeshRendererInstance instance)
		{
			data.Add(new LookupEntry(instance));
		}

		public LookupEntry Get(int index)
		{
			return data[index];
		}
	}

	public struct LookupEntry
	{
		public Renderer renderer;

		public LookupEntry(MeshRendererInstance instance)
		{
			renderer = instance.renderer;
		}
	}

	public LookupGroup src = new LookupGroup();

	public LookupGroup dst = new LookupGroup();

	public void Apply()
	{
		LookupGroup lookupGroup = src;
		src = dst;
		dst = lookupGroup;
		dst.Clear();
	}

	public void Clear()
	{
		dst.Clear();
	}

	public void Add(MeshRendererInstance instance)
	{
		dst.Add(instance);
	}

	public LookupEntry Get(int index)
	{
		return src.Get(index);
	}
}


using System.Collections.Generic;

public class LookupGroup
{
	public List<LookupEntry> data = new List<LookupEntry>();

	public void Clear()
	{
		data.Clear();
	}

	public void Add(MeshRendererInstance instance)
	{
		data.Add(new LookupEntry(instance));
	}

	public LookupEntry Get(int index)
	{
		return data[index];
	}
}


using UnityEngine;

public struct LookupEntry
{
	public Renderer renderer;

	public LookupEntry(MeshRendererInstance instance)
	{
		renderer = instance.renderer;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

public class RendererInfo : ComponentInfo<Renderer>
{
	public ShadowCastingMode shadows;

	public Material material;

	public Mesh mesh;

	public MeshFilter meshFilter;

	public override void Reset()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		component.shadowCastingMode = shadows;
		if (Object.op_Implicit((Object)(object)material))
		{
			component.sharedMaterial = material;
		}
		Renderer obj = component;
		SkinnedMeshRenderer val = (SkinnedMeshRenderer)(object)((obj is SkinnedMeshRenderer) ? obj : null);
		if (val != null)
		{
			val.sharedMesh = mesh;
		}
		else if (component is MeshRenderer)
		{
			meshFilter.sharedMesh = mesh;
		}
	}

	public override void Setup()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		shadows = component.shadowCastingMode;
		material = component.sharedMaterial;
		Renderer obj = component;
		SkinnedMeshRenderer val = (SkinnedMeshRenderer)(object)((obj is SkinnedMeshRenderer) ? obj : null);
		if (val != null)
		{
			mesh = val.sharedMesh;
		}
		else if (component is MeshRenderer)
		{
			meshFilter = ((Component)this).GetComponent<MeshFilter>();
			mesh = meshFilter.sharedMesh;
		}
	}
}


using UnityEngine;

public class CullWhenInside : MonoBehaviour
{
}


public class DecalBlood : DecalRecycle
{
}


using System;

public abstract class DecalComponent : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(DecalComponent);
	}
}


using UnityEngine;

public class DecalRecycle : BasePrefab, IClientComponent, IEffectRecycle
{
	public float LifeTime = 60f;

	[Range(1f, 50f)]
	public int WarmedUpAmount = 1;
}


public static class DecalRecycleEx
{
}


public class DecalRotate : DecalComponent
{
	[MinMax(0f, 360f)]
	public MinMax range = new MinMax(0f, 360f);
}


public class DecalScale : DecalComponent
{
	[MinMax(0f, 2f)]
	public MinMax range = new MinMax(0.9f, 1.1f);

	public bool uniform = true;
}


using UnityEngine;

public class DemoShotPlayback : MonoBehaviour
{
}


public class DemoShotRecorder : SingletonComponent<DemoShotRecorder>
{
}


public static class DemoShotHelpers
{
}


using System;
using UnityEngine;

[Obsolete]
public class DontBecomeSolidWithPlayerInside : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
public class DrawCameraFrustum : MonoBehaviour
{
	[SerializeField]
	private Material lineMaterial;
}


using UnityEngine;

public class DynamicZNear : MonoBehaviour
{
	public float minimum = 0.05f;

	public float maximum = 1f;
}


public static class EAC
{
}


using System.Runtime.CompilerServices;

public struct EncryptedValue<TInner> where TInner : unmanaged
{
	private TInner _value;

	private int _padding;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public TInner Get()
	{
		return _value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Set(TInner value)
	{
		_value = value;
	}

	public override string ToString()
	{
		return Get().ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator EncryptedValue<TInner>(TInner value)
	{
		EncryptedValue<TInner> result = default(EncryptedValue<TInner>);
		result.Set(value);
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator TInner(EncryptedValue<TInner> encrypted)
	{
		return encrypted.Get();
	}
}


using UnityEngine;

public class FollowCamera : MonoBehaviour, IClientComponent
{
	private void LateUpdate()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)MainCamera.mainCamera == (Object)null))
		{
			((Component)this).transform.position = MainCamera.position;
		}
	}
}


using UnityEngine;

public class Gib : ListComponent<Gib>
{
	public static int gibCount;

	public MeshFilter _meshFilter;

	public MeshRenderer _meshRenderer;

	public MeshCollider _meshCollider;

	public BoxCollider _boxCollider;

	public SphereCollider _sphereCollider;

	public CapsuleCollider _capsuleCollider;

	public Rigidbody _rigidbody;

	public static string GetEffect(PhysicMaterial physicMaterial)
	{
		return physicMaterial.GetNameLower() switch
		{
			"wood" => "assets/bundled/prefabs/fx/building/wood_gib.prefab", 
			"concrete" => "assets/bundled/prefabs/fx/building/stone_gib.prefab", 
			"metal" => "assets/bundled/prefabs/fx/building/metal_sheet_gib.prefab", 
			"rock" => "assets/bundled/prefabs/fx/building/stone_gib.prefab", 
			"flesh" => "assets/bundled/prefabs/fx/building/wood_gib.prefab", 
			_ => "assets/bundled/prefabs/fx/building/wood_gib.prefab", 
		};
	}
}


using System;
using System.Runtime.CompilerServices;
using Facepunch;

public sealed class HiddenValue<T> : IDisposable where T : class
{
	private T _value;

	public HiddenValue()
		: this((T)null)
	{
	}

	public HiddenValue(T value)
	{
		_value = value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public T Get()
	{
		return _value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public HiddenValue<T> Set(T value)
	{
		_value = value;
		return this;
	}

	public void Dispose()
	{
		_value = null;
		HiddenValue<T> hiddenValue = this;
		Pool.FreeUnsafe<HiddenValue<T>>(ref hiddenValue);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class IconSkin : MonoBehaviour, IItemIconChanged, IClientComponent
{
	public Image icon;

	public Text text;
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class IconSkinPicker : MonoBehaviour
{
	public GameObjectRef pickerIcon;

	public GameObject container;

	public Action skinChangedEvent;

	public ScrollRect scroller;

	public SearchFilterInput searchFilter;
}


using System.Collections.Generic;
using UnityEngine;

[DefaultExecutionOrder(-1)]
public class LightEx : UpdateBehaviour, IClientComponent
{
	public bool alterColor;

	public float colorTimeScale = 1f;

	public Color colorA = Color.red;

	public Color colorB = Color.yellow;

	public AnimationCurve blendCurve = new AnimationCurve();

	public bool loopColor = true;

	public bool alterIntensity;

	public float intensityTimeScale = 1f;

	public AnimationCurve intenseCurve = new AnimationCurve();

	public float intensityCurveScale = 3f;

	public bool loopIntensity = true;

	public bool randomOffset;

	public float randomIntensityStartScale = -1f;

	public List<Light> syncLights = new List<Light>(0);

	protected void OnValidate()
	{
		CheckConflict(((Component)this).gameObject);
	}

	public static bool CheckConflict(GameObject go)
	{
		return false;
	}
}


using UnityEngine;

public class LightGroupAtTime : FacepunchBehaviour
{
	public float IntensityOverride = 1f;

	public AnimationCurve IntensityScaleOverTime;

	public Transform SearchRoot;

	[Header("Power Settings")]
	public bool requiresPower;

	[Tooltip("Can NOT be entity, use new blank gameobject!")]
	public Transform powerOverrideTransform;

	public LayerMask checkLayers;

	public GameObject enableWhenLightsOn;

	public float timeBetweenPowerLookup;

	public LightGroupAtTime()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Expected O, but got Unknown
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		AnimationCurve val = new AnimationCurve();
		val.keys = (Keyframe[])(object)new Keyframe[5]
		{
			new Keyframe(0f, 1f),
			new Keyframe(8f, 0f),
			new Keyframe(12f, 0f),
			new Keyframe(19f, 1f),
			new Keyframe(24f, 1f)
		};
		IntensityScaleOverTime = val;
		checkLayers = LayerMask.op_Implicit(1235288065);
		timeBetweenPowerLookup = 10f;
		((FacepunchBehaviour)this)..ctor();
	}
}


using UnityEngine;

public class LocalPositionAnimation : MonoBehaviour, IClientComponent
{
	public Vector3 centerPosition;

	public bool worldSpace;

	public float scaleX = 1f;

	public float timeScaleX = 1f;

	public AnimationCurve movementX = new AnimationCurve();

	public float scaleY = 1f;

	public float timeScaleY = 1f;

	public AnimationCurve movementY = new AnimationCurve();

	public float scaleZ = 1f;

	public float timeScaleZ = 1f;

	public AnimationCurve movementZ = new AnimationCurve();
}


using UnityEngine;

[ExecuteInEditMode]
public class LookAt : MonoBehaviour, IClientComponent
{
	public Transform target;

	private void Update()
	{
		if (!((Object)(object)target == (Object)null))
		{
			((Component)this).transform.LookAt(target);
		}
	}
}


using System;
using UnityEngine;

[ExecuteInEditMode]
public class MainCamera : RustCamera<MainCamera>
{
	public static Camera mainCamera;

	public static Transform mainCameraTransform;

	public static Action PreCullCallback;

	public static bool isValid
	{
		get
		{
			if ((Object)(object)mainCamera != (Object)null && (Object)(object)mainCameraTransform != (Object)null)
			{
				return ((Behaviour)mainCamera).enabled;
			}
			return false;
		}
	}

	public static Vector3 velocity { get; private set; }

	public static Vector3 position
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.position;
		}
		set
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			mainCameraTransform.position = value;
		}
	}

	public static Vector3 forward
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.forward;
		}
		set
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			if (((Vector3)(ref value)).sqrMagnitude > 0f)
			{
				mainCameraTransform.forward = value;
			}
		}
	}

	public static Vector3 right
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.right;
		}
		set
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			if (((Vector3)(ref value)).sqrMagnitude > 0f)
			{
				mainCameraTransform.right = value;
			}
		}
	}

	public static Vector3 up
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.up;
		}
		set
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (((Vector3)(ref value)).sqrMagnitude > 0f)
			{
				((Component)mainCamera).transform.up = value;
			}
		}
	}

	public static Quaternion rotation
	{
		get
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return mainCameraTransform.rotation;
		}
		set
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			mainCameraTransform.rotation = value;
		}
	}

	public static Ray Ray => new Ray(position, forward);
}


using System;
using UnityEngine;

public class MaterialParameterToggle : MonoBehaviour
{
	[Flags]
	public enum ToggleMode
	{
		Detail = 0,
		Emission = 1
	}

	[InspectorFlags]
	public ToggleMode Toggle;

	public Renderer[] TargetRenderers = (Renderer[])(object)new Renderer[0];

	[ColorUsage(true, true)]
	public Color EmissionColor;
}


using System;

[Flags]
public enum ToggleMode
{
	Detail = 0,
	Emission = 1
}


using UnityEngine;

public abstract class BaseMeshPaintable : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class MeshPaintable : BaseMeshPaintable
{
	public string replacementTextureName = "_MainTex";

	public int textureWidth = 256;

	public int textureHeight = 256;

	public Color clearColor = Color.clear;

	public Texture2D targetTexture;

	public bool hasChanges;
}


using UnityEngine;

public class MeshPaintable3D : BaseMeshPaintable
{
	[ClientVar]
	public static float brushScale = 2f;

	[ClientVar]
	public static float uvBufferScale = 2f;

	public string replacementTextureName = "_MainTex";

	public int textureWidth = 256;

	public int textureHeight = 256;

	public Camera cameraPreview;

	public Camera camera3D;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class MeshPaintableSource : MonoBehaviour, IClientComponent
{
	public Vector4 uvRange = new Vector4(0f, 0f, 1f, 1f);

	public int texWidth = 256;

	public int texHeight = 128;

	public string replacementTextureName = "_DecalTexture";

	public float cameraFOV = 60f;

	public float cameraDistance = 2f;

	[NonSerialized]
	public Texture2D texture;

	public GameObject sourceObject;

	public Mesh collisionMesh;

	public Vector3 localPosition;

	public Vector3 localRotation;

	public bool applyToAllRenderers = true;

	public Renderer[] extraRenderers;

	public bool paint3D;

	public bool applyToSkinRenderers = true;

	public bool applyToFirstPersonLegs = true;

	[NonSerialized]
	public bool isSelected;

	[NonSerialized]
	public Renderer legRenderer;

	private static MaterialPropertyBlock block;

	public void Init()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Expected O, but got Unknown
		if ((Object)(object)texture == (Object)null)
		{
			texture = new Texture2D(texWidth, texHeight, (TextureFormat)5, false);
			((Object)texture).name = "MeshPaintableSource_" + ((Object)((Component)this).gameObject).name;
			((Texture)texture).wrapMode = (TextureWrapMode)1;
			TextureEx.Clear(texture, Color32.op_Implicit(Color.clear));
		}
		if (block == null)
		{
			block = new MaterialPropertyBlock();
		}
		else
		{
			block.Clear();
		}
		UpdateMaterials(block, null, forEditing: false, isSelected);
		List<Renderer> list = Pool.Get<List<Renderer>>();
		Transform val = (applyToAllRenderers ? ((Component)this).transform.root : ((Component)this).transform);
		if (applyToSkinRenderers)
		{
			BaseEntity componentInParent = ((Component)this).GetComponentInParent<BaseEntity>();
			if ((Object)(object)componentInParent != (Object)null)
			{
				val = ((Component)componentInParent).transform;
			}
		}
		((Component)val).GetComponentsInChildren<Renderer>(true, list);
		PlayerModelSkin playerModelSkin = default(PlayerModelSkin);
		foreach (Renderer item in list)
		{
			if (applyToSkinRenderers || !((Component)item).TryGetComponent<PlayerModelSkin>(ref playerModelSkin))
			{
				item.SetPropertyBlock(block);
			}
		}
		if (extraRenderers != null)
		{
			Renderer[] array = extraRenderers;
			foreach (Renderer val2 in array)
			{
				if ((Object)(object)val2 != (Object)null)
				{
					val2.SetPropertyBlock(block);
				}
			}
		}
		if (applyToFirstPersonLegs && (Object)(object)legRenderer != (Object)null)
		{
			legRenderer.SetPropertyBlock(block);
		}
		Pool.FreeUnmanaged<Renderer>(ref list);
	}

	public void Free()
	{
		if (Object.op_Implicit((Object)(object)texture))
		{
			Object.Destroy((Object)(object)texture);
			texture = null;
		}
	}

	public void OnDestroy()
	{
		Free();
	}

	public virtual void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride = null, bool forEditing = false, bool isSelected = false)
	{
		block.SetTexture(replacementTextureName, (Texture)(object)(textureOverride ?? texture));
	}

	public virtual Color32[] UpdateFrom(Texture2D input)
	{
		Init();
		Color32[] pixels = input.GetPixels32();
		texture.SetPixels32(pixels);
		texture.Apply(true, false);
		return pixels;
	}

	public void Load(byte[] data)
	{
		Init();
		if (data != null)
		{
			ImageConversion.LoadImage(texture, data);
			texture.Apply(true, false);
		}
	}

	public void Clear()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)texture == (Object)null))
		{
			TextureEx.Clear(texture, Color32.op_Implicit(new Color(0f, 0f, 0f, 0f)));
			texture.Apply(true, false);
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class MeshPaintController : MonoBehaviour, IClientComponent
{
	public enum Tool
	{
		Brush,
		Eraser,
		ColorPicker
	}

	public enum RotateMode
	{
		None,
		Movement,
		Random
	}

	public Camera pickerCamera;

	public Tool currentTool;

	public Texture2D brushTexture;

	public Vector2 brushScale = new Vector2(8f, 8f);

	public Color brushColor = Color.white;

	public float brushSpacing = 2f;

	public float brushSpacingFactor = 0.25f;

	public RawImage brushImage;

	public float brushPreviewScaleMultiplier = 1f;

	public Texture2D stampTexture;

	public RotateMode brushRotation;

	public bool applyDefaults;

	public Texture2D defaltBrushTexture;

	public float defaultBrushSize = 16f;

	public Color defaultBrushColor = Color.black;

	public float defaultBrushAlpha = 0.5f;

	public float maxBrushScale = 32f;

	public RustButton UndoButton;

	public RustButton RedoButton;

	public GameObject BackgroundBlocker;

	private Vector3 lastPosition;
}


public enum Tool
{
	Brush,
	Eraser,
	ColorPicker
}


public enum RotateMode
{
	None,
	Movement,
	Random
}


using System;
using UnityEngine;

public class OverlayMeshPaintableSource : MeshPaintableSource
{
	private static readonly Memoized<string, string> STPrefixed = new Memoized<string, string>((Func<string, string>)((string s) => s + "_ST"));

	public string baseTextureName = "_Decal1Texture";

	[NonSerialized]
	public Texture2D baseTexture;

	public override void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride = null, bool forEditing = false, bool isSelected = false)
	{
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		base.UpdateMaterials(block, textureOverride, forEditing, isSelected);
		if ((Object)(object)baseTexture != (Object)null)
		{
			float num = (float)((Texture)baseTexture).width / (float)((Texture)baseTexture).height;
			int num2 = texWidth / texHeight;
			float num3 = 1f;
			float num4 = 0f;
			float num5 = 1f;
			float num6 = 0f;
			if ((float)num2 <= num)
			{
				float num7 = (float)texHeight * num;
				num3 = (float)texWidth / num7;
				num4 = (1f - num3) / 2f;
			}
			else
			{
				float num8 = (float)texWidth / num;
				num5 = (float)texHeight / num8;
				num6 = (1f - num5) / 2f;
			}
			block.SetTexture(baseTextureName, (Texture)(object)baseTexture);
			block.SetVector(STPrefixed.Get(baseTextureName), new Vector4(num3, num5, num4, num6));
		}
		else
		{
			block.SetTexture(baseTextureName, (Texture)(object)Texture2D.blackTexture);
		}
	}
}


using Facepunch;
using UnityEngine;

public class Model : MonoBehaviour, IPrefabPreProcess
{
	public SphereCollider collision;

	public Transform rootBone;

	public Transform headBone;

	public Transform eyeBone;

	public Animator animator;

	public Skeleton skeleton;

	[HideInInspector]
	public Transform[] boneTransforms;

	[HideInInspector]
	public string[] boneNames;

	internal BoneDictionary boneDict;

	internal int skin;

	protected void OnEnable()
	{
		skin = -1;
	}

	public void BuildBoneDictionary()
	{
		if (boneDict == null)
		{
			boneDict = new BoneDictionary(((Component)this).transform, boneTransforms, boneNames);
		}
	}

	public int GetSkin()
	{
		return skin;
	}

	private Transform FindBoneInternal(string name)
	{
		BuildBoneDictionary();
		return boneDict.FindBone(name, defaultToRoot: false);
	}

	public Transform FindBone(string name)
	{
		BuildBoneDictionary();
		Transform result = rootBone;
		if (string.IsNullOrEmpty(name))
		{
			return result;
		}
		return boneDict.FindBone(name);
	}

	public Transform FindBone(uint hash)
	{
		BuildBoneDictionary();
		Transform result = rootBone;
		if (hash == 0)
		{
			return result;
		}
		return boneDict.FindBone(hash);
	}

	public uint FindBoneID(Transform transform)
	{
		BuildBoneDictionary();
		return boneDict.FindBoneID(transform);
	}

	public Transform[] GetBones()
	{
		BuildBoneDictionary();
		return boneDict.transforms;
	}

	public Transform FindClosestBone(Vector3 worldPos)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Transform result = rootBone;
		float num = float.MaxValue;
		for (int i = 0; i < boneTransforms.Length; i++)
		{
			Transform val = boneTransforms[i];
			if (!((Object)(object)val == (Object)null))
			{
				float num2 = Vector3.Distance(val.position, worldPos);
				if (!(num2 >= num))
				{
					result = val;
					num = num2;
				}
			}
		}
		return result;
	}

	public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!((Object)(object)this == (Object)null))
		{
			if ((Object)(object)animator == (Object)null)
			{
				animator = ((Component)this).GetComponent<Animator>();
			}
			if ((Object)(object)rootBone == (Object)null)
			{
				rootBone = ((Component)this).transform;
			}
			boneTransforms = ((Component)rootBone).GetComponentsInChildren<Transform>(true);
			boneNames = new string[boneTransforms.Length];
			for (int i = 0; i < boneTransforms.Length; i++)
			{
				boneNames[i] = ((Object)boneTransforms[i]).name;
			}
		}
	}
}


public class NexusClient : SingletonComponent<NexusClient>
{
}


public static class NexusClientUtil
{
}


using UnityEngine;

public class ParticleDisableOnParentDestroy : MonoBehaviour, IOnParentDestroying
{
	public float destroyAfterSeconds;

	public void OnParentDestroying()
	{
		((Component)this).transform.parent = null;
		ParticleSystem component = ((Component)this).GetComponent<ParticleSystem>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.enableEmission = false;
		}
		if (destroyAfterSeconds > 0f)
		{
			GameManager.Destroy(((Component)this).gameObject, destroyAfterSeconds);
		}
	}
}


using UnityEngine;

public class ParticleRandomLifetime : MonoBehaviour
{
	public ParticleSystem mySystem;

	public float minScale = 0.5f;

	public float maxScale = 1f;

	public void Awake()
	{
		if (Object.op_Implicit((Object)(object)mySystem))
		{
			float startLifetime = Random.Range(minScale, maxScale);
			mySystem.startLifetime = startLifetime;
		}
	}
}


using UnityEngine;

public class PlayAudioEx : MonoBehaviour
{
	public float delay;

	private void Start()
	{
	}

	private void OnEnable()
	{
		AudioSource component = ((Component)this).GetComponent<AudioSource>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.PlayDelayed(delay);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PlayerModelHair : MonoBehaviour
{
	public struct RendererMaterials
	{
		public string[] names;

		public Material[] original;

		public Material[] replacement;

		public RendererMaterials(Renderer r)
		{
			original = r.sharedMaterials;
			replacement = original.Clone() as Material[];
			names = new string[original.Length];
			for (int i = 0; i < original.Length; i++)
			{
				names[i] = ((Object)original[i]).name;
			}
		}
	}

	public HairType type;

	private Dictionary<Renderer, RendererMaterials> materials;

	public Dictionary<Renderer, RendererMaterials> Materials => materials;

	private void CacheOriginalMaterials()
	{
		if (materials != null)
		{
			return;
		}
		List<SkinnedMeshRenderer> list = Pool.Get<List<SkinnedMeshRenderer>>();
		((Component)this).gameObject.GetComponentsInChildren<SkinnedMeshRenderer>(true, list);
		materials = new Dictionary<Renderer, RendererMaterials>();
		materials.Clear();
		foreach (SkinnedMeshRenderer item in list)
		{
			materials.Add((Renderer)(object)item, new RendererMaterials((Renderer)(object)item));
		}
		Pool.FreeUnmanaged<SkinnedMeshRenderer>(ref list);
	}

	private void Setup(HairType type, HairSetCollection hair, int meshIndex, float typeNum, float dyeNum, MaterialPropertyBlock block)
	{
		CacheOriginalMaterials();
		HairSetCollection.HairSetEntry hairSetEntry = hair.Get(type, typeNum);
		if ((Object)(object)hairSetEntry.HairSet == (Object)null)
		{
			Debug.LogWarning((object)"Hair.Get returned a NULL hair");
			return;
		}
		int blendShapeIndex = -1;
		if (type == HairType.Facial || type == HairType.Eyebrow)
		{
			blendShapeIndex = meshIndex;
		}
		HairDye dye = null;
		HairDyeCollection hairDyeCollection = hairSetEntry.HairDyeCollection;
		if ((Object)(object)hairDyeCollection != (Object)null)
		{
			dye = hairDyeCollection.Get(dyeNum);
		}
		hairSetEntry.HairSet.Process(this, hairDyeCollection, dye, block);
		hairSetEntry.HairSet.ProcessMorphs(((Component)this).gameObject, blendShapeIndex);
	}

	public void Setup(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
	{
		int index = skin.GetIndex(meshNum);
		SkinSet skinSet = skin.Skins[index];
		if ((Object)(object)skinSet == (Object)null)
		{
			Debug.LogError((object)"Skin.Get returned a NULL skin");
			return;
		}
		int typeIndex = (int)type;
		GetRandomVariation(hairNum, typeIndex, index, out var typeNum, out var dyeNum);
		Setup(type, skinSet.HairCollection, index, typeNum, dyeNum, block);
	}

	public static void GetRandomVariation(float hairNum, int typeIndex, int meshIndex, out float typeNum, out float dyeNum)
	{
		int num = Mathf.FloorToInt(hairNum * 100000f);
		typeNum = GetRandomHairType(hairNum, typeIndex);
		Random.InitState(num + meshIndex);
		dyeNum = Random.Range(0f, 1f);
	}

	public static float GetRandomHairType(float hairNum, int typeIndex)
	{
		Random.InitState(Mathf.FloorToInt(hairNum * 100000f) + typeIndex);
		return Random.Range(0f, 1f);
	}
}


using UnityEngine;

public struct RendererMaterials
{
	public string[] names;

	public Material[] original;

	public Material[] replacement;

	public RendererMaterials(Renderer r)
	{
		original = r.sharedMaterials;
		replacement = original.Clone() as Material[];
		names = new string[original.Length];
		for (int i = 0; i < original.Length; i++)
		{
			names[i] = ((Object)original[i]).name;
		}
	}
}


using System;

[Flags]
public enum HairCapMask
{
	Head = 1,
	Eyebrow = 2,
	Facial = 4,
	Armpit = 8,
	Pubic = 0x10
}


using UnityEngine;

public class PlayerModelHairCap : MonoBehaviour
{
	[InspectorFlags]
	public HairCapMask hairCapMask;

	public void SetupHairCap(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
	{
		int index = skin.GetIndex(meshNum);
		SkinSet skinSet = skin.Skins[index];
		if ((Object)(object)skinSet == (Object)null)
		{
			return;
		}
		for (int i = 0; i < 5; i++)
		{
			if (((uint)hairCapMask & (uint)(1 << i)) == 0)
			{
				continue;
			}
			PlayerModelHair.GetRandomVariation(hairNum, i, index, out var typeNum, out var dyeNum);
			HairType hairType = (HairType)i;
			HairSetCollection.HairSetEntry hairSetEntry = skinSet.HairCollection.Get(hairType, typeNum);
			if (!((Object)(object)hairSetEntry.HairSet == (Object)null))
			{
				HairDyeCollection hairDyeCollection = hairSetEntry.HairDyeCollection;
				if (!((Object)(object)hairDyeCollection == (Object)null))
				{
					hairDyeCollection.Get(dyeNum)?.ApplyCap(hairDyeCollection, hairType, block);
				}
			}
		}
	}
}


using UnityEngine;

public class PlayerModelSkin : MonoBehaviour, IPrefabPreProcess
{
	public enum SkinMaterialType
	{
		HEAD,
		EYE,
		BODY
	}

	public SkinMaterialType MaterialType;

	public Renderer SkinRenderer;

	public void Setup(SkinSetCollection skin, float hairNum, float meshNum)
	{
		if (Object.op_Implicit((Object)(object)SkinRenderer) && Object.op_Implicit((Object)(object)skin))
		{
			switch (MaterialType)
			{
			case SkinMaterialType.HEAD:
				SkinRenderer.sharedMaterial = skin.Get(meshNum).HeadMaterial;
				break;
			case SkinMaterialType.BODY:
				SkinRenderer.sharedMaterial = skin.Get(meshNum).BodyMaterial;
				break;
			case SkinMaterialType.EYE:
				SkinRenderer.sharedMaterial = skin.Get(meshNum).EyeMaterial;
				break;
			default:
				SkinRenderer.sharedMaterial = skin.Get(meshNum).BodyMaterial;
				break;
			}
		}
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (clientside)
		{
			SkinRenderer = ((Component)this).GetComponent<Renderer>();
		}
	}
}


public enum SkinMaterialType
{
	HEAD,
	EYE,
	BODY
}


public interface ILerpInfo
{
	public enum LerpType
	{
		Generic,
		Position
	}

	float GetExtrapolationTime();

	float GetInterpolationDelay(LerpType lerpType);

	float GetInterpolationSmoothing();
}


public enum LerpType
{
	Generic,
	Position
}


using System.Collections.Generic;
using Rust.Interpolation;
using UnityEngine;

public interface IPosLerpTarget : ILerpInfo
{
	float GetInterpolationInertia();

	Vector3 GetNetworkPosition();

	Quaternion GetNetworkRotation();

	void SetNetworkPosition(Vector3 pos);

	void SetNetworkRotation(Quaternion rot);

	void DrawInterpolationState(Interpolator<TransformSnapshot>.Segment segment, List<TransformSnapshot> entries);

	void LerpIdleDisable();
}


using System;
using Facepunch;
using Rust.Interpolation;
using UnityEngine;

public class PositionLerp : IPooled
{
	private static readonly ListHashSet<PositionLerp> InstanceList = new ListHashSet<PositionLerp>();

	public static bool DebugLog = false;

	public static bool DebugDraw = false;

	public static int TimeOffsetInterval = 16;

	public static float TimeOffset = 0f;

	public const int TimeOffsetIntervalMin = 4;

	public const int TimeOffsetIntervalMax = 64;

	private bool enabled = true;

	private Action idleDisable;

	private readonly Interpolator<TransformSnapshot> interpolator = new Interpolator<TransformSnapshot>(32);

	private IPosLerpTarget target;

	private static TransformSnapshot snapshotPrototype = default(TransformSnapshot);

	private float timeOffset0 = float.MaxValue;

	private float timeOffset1 = float.MaxValue;

	private float timeOffset2 = float.MaxValue;

	private float timeOffset3 = float.MaxValue;

	private int timeOffsetCount;

	private float lastClientTime;

	private float lastServerTime;

	private float extrapolatedTime;

	private float enabledTime;

	public bool Enabled
	{
		get
		{
			return enabled;
		}
		set
		{
			enabled = value;
			if (enabled)
			{
				OnEnable();
			}
			else
			{
				OnDisable();
			}
		}
	}

	public static float LerpTime => Time.time;

	private void OnEnable()
	{
		InstanceList.Add(this);
		enabledTime = LerpTime;
	}

	private void OnDisable()
	{
		InstanceList.Remove(this);
	}

	public void Initialize(IPosLerpTarget target)
	{
		this.target = target;
		Enabled = true;
	}

	public void Snapshot(Vector3 position, Quaternion rotation, float serverTime)
	{
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		float num = interpolationDelay + interpolationSmoothing + 1f;
		float lerpTime = LerpTime;
		timeOffset0 = Mathf.Min(timeOffset0, lerpTime - serverTime);
		timeOffsetCount++;
		if (timeOffsetCount >= TimeOffsetInterval / 4)
		{
			timeOffset3 = timeOffset2;
			timeOffset2 = timeOffset1;
			timeOffset1 = timeOffset0;
			timeOffset0 = float.MaxValue;
			timeOffsetCount = 0;
		}
		TimeOffset = Mathx.Min(timeOffset0, timeOffset1, timeOffset2, timeOffset3);
		lerpTime = serverTime + TimeOffset;
		if (DebugLog && interpolator.list.Count > 0 && serverTime < lastServerTime)
		{
			Debug.LogWarning((object)(target.ToString() + " adding tick from the past: server time " + serverTime + " < " + lastServerTime));
		}
		else if (DebugLog && interpolator.list.Count > 0 && lerpTime < lastClientTime)
		{
			Debug.LogWarning((object)(target.ToString() + " adding tick from the past: client time " + lerpTime + " < " + lastClientTime));
		}
		else
		{
			lastClientTime = lerpTime;
			lastServerTime = serverTime;
			interpolator.Add(new TransformSnapshot(lerpTime, position, rotation));
		}
		interpolator.Cull(lerpTime - num);
	}

	public void Snapshot(Vector3 position, Quaternion rotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Snapshot(position, rotation, LerpTime - TimeOffset);
	}

	public void SnapTo(Vector3 position, Quaternion rotation, float serverTime)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		interpolator.Clear();
		Snapshot(position, rotation, serverTime);
		target.SetNetworkPosition(position);
		target.SetNetworkRotation(rotation);
	}

	public void SnapTo(Vector3 position, Quaternion rotation)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		interpolator.last = new TransformSnapshot(LerpTime, position, rotation);
		Wipe();
	}

	public void SnapToEnd()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, 0f, 0f, ref snapshotPrototype);
		target.SetNetworkPosition(segment.tick.pos);
		target.SetNetworkRotation(segment.tick.rot);
		Wipe();
	}

	public void Wipe()
	{
		interpolator.Clear();
		timeOffsetCount = 0;
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
	}

	public static void WipeAll()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<PositionLerp> enumerator = InstanceList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Wipe();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	protected void DoCycle()
	{
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		if (target == null)
		{
			return;
		}
		float interpolationInertia = target.GetInterpolationInertia();
		float num = ((interpolationInertia > 0f) ? Mathf.InverseLerp(0f, interpolationInertia, LerpTime - enabledTime) : 1f);
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolation = target.GetInterpolationDelay(ILerpInfo.LerpType.Position) * num;
		float num2 = target.GetInterpolationSmoothing() * num;
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolation, extrapolationTime, num2, ref snapshotPrototype);
		if (segment.next.Time >= interpolator.last.Time)
		{
			extrapolatedTime = Mathf.Min(extrapolatedTime + Time.deltaTime, extrapolationTime);
		}
		else
		{
			extrapolatedTime = Mathf.Max(extrapolatedTime - Time.deltaTime, 0f);
		}
		if (extrapolatedTime > 0f && extrapolationTime > 0f && num2 > 0f)
		{
			float num3 = Time.deltaTime / (extrapolatedTime / extrapolationTime * num2);
			segment.tick.pos = Vector3.Lerp(target.GetNetworkPosition(), segment.tick.pos, num3);
			segment.tick.rot = Quaternion.Slerp(target.GetNetworkRotation(), segment.tick.rot, num3);
		}
		target.SetNetworkPosition(segment.tick.pos);
		target.SetNetworkRotation(segment.tick.rot);
		if (DebugDraw)
		{
			target.DrawInterpolationState(segment, interpolator.list);
		}
		if (LerpTime - lastClientTime > 10f)
		{
			if (idleDisable == null)
			{
				idleDisable = target.LerpIdleDisable;
			}
			IPosLerpTarget posLerpTarget = target;
			InvokeHandler.Invoke((Behaviour)((posLerpTarget is Behaviour) ? posLerpTarget : null), idleDisable, 0f);
		}
	}

	public void TransformEntries(Matrix4x4 matrix)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		Quaternion rotation = ((Matrix4x4)(ref matrix)).rotation;
		for (int i = 0; i < interpolator.list.Count; i++)
		{
			TransformSnapshot value = interpolator.list[i];
			value.pos = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(value.pos);
			value.rot = rotation * value.rot;
			interpolator.list[i] = value;
		}
		interpolator.last.pos = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(interpolator.last.pos);
		interpolator.last.rot = rotation * interpolator.last.rot;
	}

	public Quaternion GetEstimatedAngularVelocity()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (target == null)
		{
			return Quaternion.identity;
		}
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, extrapolationTime, interpolationSmoothing, ref snapshotPrototype);
		TransformSnapshot next = segment.next;
		TransformSnapshot prev = segment.prev;
		if (next.Time == prev.Time)
		{
			return Quaternion.identity;
		}
		return Quaternion.Euler((((Quaternion)(ref prev.rot)).eulerAngles - ((Quaternion)(ref next.rot)).eulerAngles) / (prev.Time - next.Time));
	}

	public Vector3 GetEstimatedVelocity()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (target == null)
		{
			return Vector3.zero;
		}
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Position);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		Interpolator<TransformSnapshot>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, extrapolationTime, interpolationSmoothing, ref snapshotPrototype);
		TransformSnapshot next = segment.next;
		TransformSnapshot prev = segment.prev;
		if (next.Time == prev.Time)
		{
			return Vector3.zero;
		}
		return (prev.pos - next.pos) / (prev.Time - next.Time);
	}

	void IPooled.EnterPool()
	{
		target = null;
		idleDisable = null;
		interpolator.Clear();
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
		lastClientTime = 0f;
		lastServerTime = 0f;
		extrapolatedTime = 0f;
		timeOffsetCount = 0;
		Enabled = false;
	}

	void IPooled.LeavePool()
	{
	}

	public static void Clear()
	{
		InstanceList.Clear();
	}

	public static void Cycle()
	{
		PositionLerp[] buffer = InstanceList.Values.Buffer;
		int count = InstanceList.Count;
		for (int i = 0; i < count; i++)
		{
			buffer[i].DoCycle();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

public class Projectile : BaseMonoBehaviour
{
	public enum EffectMatchMode
	{
		None,
		Velocity,
		InverseVelocity
	}

	[Serializable]
	public class CustomEffectData
	{
		public bool UseCustomEffect;

		public EffectMatchMode MatchMode;
	}

	public struct Modifier
	{
		public float damageScale;

		public float damageOffset;

		public float distanceScale;

		public float distanceOffset;

		public static Modifier Default = new Modifier
		{
			damageScale = 1f,
			damageOffset = 0f,
			distanceScale = 1f,
			distanceOffset = 0f
		};
	}

	public const float moveDeltaTime = 1f / 32f;

	public const float lifeTime = 8f;

	[Header("Attributes")]
	public Vector3 initialVelocity;

	public float drag;

	public float gravityModifier = 1f;

	public float thickness;

	[Tooltip("Tick this box to be able to change the initial orientation of the projectile")]
	[Header("Orientation")]
	public bool changeInitialOrientation;

	[Tooltip("This projectile will raycast for this many units, and then become a projectile. This is typically done for bullets.")]
	public float initialDistance;

	public Vector3 initialOrientation;

	[Header("Impact Rules")]
	public bool remainInWorld;

	[Range(0f, 1f)]
	public float stickProbability = 1f;

	[Range(0f, 1f)]
	public float breakProbability;

	[Range(0f, 1f)]
	public float conditionLoss;

	[Range(0f, 1f)]
	public float ricochetChance;

	public float penetrationPower = 1f;

	public bool canRefract = true;

	public bool penetratesVehicles;

	[Range(0f, 1f)]
	public float waterIntegrityLoss = 0.1f;

	[Header("Damage")]
	public DamageProperties damageProperties;

	[Horizontal(2, -1)]
	public MinMax damageDistances = new MinMax(10f, 100f);

	[Horizontal(2, -1)]
	public MinMax damageMultipliers = new MinMax(1f, 0.8f);

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	[Header("Rendering")]
	public ScaleRenderer rendererToScale;

	public ScaleRenderer firstPersonRenderer;

	public bool createDecals = true;

	[Header("Effects")]
	public bool doDefaultHitEffects = true;

	[Header("Audio")]
	public SoundDefinition flybySound;

	public float flybySoundDistance = 7f;

	public SoundDefinition closeFlybySound;

	public float closeFlybyDistance = 3f;

	[Header("Tumble")]
	public float tumbleSpeed;

	public Vector3 tumbleAxis = Vector3.right;

	[Header("Clientside Custom Impact Effects")]
	public bool playDefaultHitEffects = true;

	public CustomEffectData clientEffectData;

	public GameObjectRef clientEffectPrefab;

	[Header("Swim")]
	public Vector3 swimScale;

	public Vector3 swimSpeed;

	[NonSerialized]
	public BasePlayer owner;

	[NonSerialized]
	public AttackEntity sourceWeaponPrefab;

	[NonSerialized]
	public Projectile sourceProjectilePrefab;

	[NonSerialized]
	public ItemModProjectile mod;

	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public int seed;

	[NonSerialized]
	public bool clientsideEffect;

	[NonSerialized]
	public bool clientsideAttack;

	[NonSerialized]
	public float integrity = 1f;

	[NonSerialized]
	public float maxDistance = float.PositiveInfinity;

	[NonSerialized]
	public Modifier modifier = Modifier.Default;

	[NonSerialized]
	public bool invisible;

	[NonSerialized]
	public bool noHeadshots;

	[NonSerialized]
	public bool noGravity;

	[NonSerialized]
	public float currentThickness;

	[ClientVar(Help = "Should the projectile model attempt to prevent itself being clipped by the camera?", Saved = true)]
	public static bool preventCameraClip = true;

	[ClientVar(Help = "Buffer seconds before turning back on the projectile model.")]
	public static float preventCameraClipBufferSeconds = 0.01f;

	[ClientVar(Help = "Distance before turning back on the server spawned projectiles model.")]
	public static float serverProjectileCameraClipDistance = 0.3f;

	private static uint _fleshMaterialID = 0u;

	private static uint _waterMaterialID = 0u;

	private static uint cachedWaterString = 0u;

	private Vector3? GetCustomEffectNormal()
	{
		return null;
	}

	public void CalculateDamage(HitInfo info, Modifier mod, float scale)
	{
		float num = damageMultipliers.Lerp(mod.distanceOffset + mod.distanceScale * damageDistances.x, mod.distanceOffset + mod.distanceScale * damageDistances.y, info.ProjectileDistance);
		float num2 = scale * (mod.damageOffset + mod.damageScale * num);
		foreach (DamageTypeEntry damageType in damageTypes)
		{
			info.damageTypes.Add(damageType.type, damageType.amount * num2);
		}
		if (Global.developer > 0)
		{
			Debug.Log((object)(" Projectile damage: " + info.damageTypes.Total() + " (scalar=" + num2 + ")"));
		}
	}

	public static uint FleshMaterialID()
	{
		if (_fleshMaterialID == 0)
		{
			_fleshMaterialID = StringPool.Get("flesh");
		}
		return _fleshMaterialID;
	}

	public static uint WaterMaterialID()
	{
		if (_waterMaterialID == 0)
		{
			_waterMaterialID = StringPool.Get("Water");
		}
		return _waterMaterialID;
	}

	public static bool IsWaterMaterial(string hitMaterial)
	{
		if (cachedWaterString == 0)
		{
			cachedWaterString = StringPool.Get("Water");
		}
		if (StringPool.Get(hitMaterial) == cachedWaterString)
		{
			return true;
		}
		return false;
	}

	public static bool ShouldStopProjectile(RaycastHit hit)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity entity = hit.GetEntity();
		if ((Object)(object)entity != (Object)null && !entity.ShouldBlockProjectiles())
		{
			return false;
		}
		return true;
	}
}


public enum EffectMatchMode
{
	None,
	Velocity,
	InverseVelocity
}


using System;

[Serializable]
public class CustomEffectData
{
	public bool UseCustomEffect;

	public EffectMatchMode MatchMode;
}


public struct Modifier
{
	public float damageScale;

	public float damageOffset;

	public float distanceScale;

	public float distanceOffset;

	public static Modifier Default = new Modifier
	{
		damageScale = 1f,
		damageOffset = 0f,
		distanceScale = 1f,
		distanceOffset = 0f
	};
}


using UnityEngine;

public class QueryVis : BaseMonoBehaviour, IClientComponent
{
	public Collider checkCollider;

	private CoverageQueries.Query query;

	public CoverageQueries.RadiusSpace coverageRadiusSpace = CoverageQueries.RadiusSpace.World;

	public float coverageRadius = 0.2f;
}


internal interface IRagdollInhert
{
}


using UnityEngine;

public class RotateToCamera : MonoBehaviour, IClientComponent
{
	public float maxDistance = 30f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public abstract class RustCamera<T> : SingletonComponent<T> where T : RustCamera<T>
{
	[SerializeField]
	private AmplifyOcclusionEffect ssao;

	[SerializeField]
	private SEScreenSpaceShadows contactShadows;

	[SerializeField]
	private VisualizeTexelDensity visualizeTexelDensity;

	[SerializeField]
	private EnvironmentVolumePropertiesCollection environmentVolumeProperties;

	[SerializeField]
	private PostProcessLayer post;

	[SerializeField]
	private PostProcessVolume baseEffectVolume;
}


using UnityEngine;

public class ScaleByIntensity : MonoBehaviour
{
	public Vector3 initialScale = Vector3.zero;

	public Light intensitySource;

	public float maxIntensity = 1f;

	private void Start()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		initialScale = ((Component)this).transform.localScale;
	}

	private void Update()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = (((Behaviour)intensitySource).enabled ? (initialScale * intensitySource.intensity / maxIntensity) : Vector3.zero);
	}
}


using UnityEngine;

public class ScaleBySpeed : MonoBehaviour, IClientComponent
{
	public float minScale = 0.001f;

	public float maxScale = 1f;

	public float minSpeed;

	public float maxSpeed = 1f;

	public MonoBehaviour component;

	public bool toggleComponent = true;

	public bool onlyWhenSubmerged;

	public float submergedThickness = 0.33f;

	private Vector3 prevPosition = Vector3.zero;
}


using System.Collections.Generic;

public class ScreenshotCamera : RustCamera<ScreenshotCamera>
{
	public static List<ScreenshotCamera> activeScreenshotCameras = new List<ScreenshotCamera>();
}


using Rust.UI;
using UnityEngine;

public class SearchFilterInput : MonoBehaviour
{
	public GameObject OpenRoot;

	public GameObject ClosedRoot;

	public RustInput InputField;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SkinnedMultiMesh : MonoBehaviour
{
	public struct Part
	{
		public Wearable wearable;

		public GameObject gameObject;

		public string name;

		public Item item;
	}

	public bool shadowOnly;

	internal bool IsVisible = true;

	public bool eyesView;

	public Skeleton skeleton;

	public SkeletonSkinLod skeletonSkinLod;

	public List<Part> parts = new List<Part>();

	[NonSerialized]
	public List<Part> createdParts = new List<Part>();

	[NonSerialized]
	public long lastBuildHash;

	[NonSerialized]
	public MaterialPropertyBlock sharedPropertyBlock;

	[NonSerialized]
	public MaterialPropertyBlock hairPropertyBlock;

	public float skinNumber;

	public float meshNumber;

	public float hairNumber;

	public int skinType;

	public SkinSetCollection SkinCollection;

	public List<Renderer> Renderers { get; } = new List<Renderer>(32);
}


using UnityEngine;

public struct Part
{
	public Wearable wearable;

	public GameObject gameObject;

	public string name;

	public Item item;
}


using UnityEngine;

public class StatusLightRenderer : MonoBehaviour, IClientComponent
{
	public Material offMaterial;

	public Material onMaterial;

	private MaterialPropertyBlock propertyBlock;

	private Renderer targetRenderer;

	private Color lightColor;

	private Light targetLight;

	private int colorID;

	private int emissionID;

	protected void Awake()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		propertyBlock = new MaterialPropertyBlock();
		targetRenderer = ((Component)this).GetComponent<Renderer>();
		targetLight = ((Component)this).GetComponent<Light>();
		colorID = Shader.PropertyToID("_Color");
		emissionID = Shader.PropertyToID("_EmissionColor");
	}

	public void SetOff()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)targetRenderer))
		{
			targetRenderer.sharedMaterial = offMaterial;
			targetRenderer.SetPropertyBlock((MaterialPropertyBlock)null);
		}
		if (Object.op_Implicit((Object)(object)targetLight))
		{
			targetLight.color = Color.clear;
		}
	}

	public void SetOn()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)targetRenderer))
		{
			targetRenderer.sharedMaterial = onMaterial;
			targetRenderer.SetPropertyBlock(propertyBlock);
		}
		if (Object.op_Implicit((Object)(object)targetLight))
		{
			targetLight.color = lightColor;
		}
	}

	public void SetRed()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		propertyBlock.Clear();
		propertyBlock.SetColor(colorID, GetColor(197, 46, 0, byte.MaxValue));
		propertyBlock.SetColor(emissionID, GetColor(191, 0, 2, byte.MaxValue, 2.916925f));
		lightColor = GetColor(byte.MaxValue, 111, 102, byte.MaxValue);
		SetOn();
	}

	public void SetGreen()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		propertyBlock.Clear();
		propertyBlock.SetColor(colorID, GetColor(19, 191, 13, byte.MaxValue));
		propertyBlock.SetColor(emissionID, GetColor(19, 191, 13, byte.MaxValue, 2.5f));
		lightColor = GetColor(156, byte.MaxValue, 102, byte.MaxValue);
		SetOn();
	}

	private Color GetColor(byte r, byte g, byte b, byte a)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return Color32.op_Implicit(new Color32(r, g, b, a));
	}

	private Color GetColor(byte r, byte g, byte b, byte a, float intensity)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return Color32.op_Implicit(new Color32(r, g, b, a)) * intensity;
	}
}


using ConVar;
using UnityEngine;

public class SunSettings : MonoBehaviour, IClientComponent
{
	private Light light;

	private void OnEnable()
	{
		light = ((Component)this).GetComponent<Light>();
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		LightShadows val = (LightShadows)Mathf.Clamp(Graphics.shadowmode, 1, 2);
		if (light.shadows != val)
		{
			light.shadows = val;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class TextureColorPicker : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IDragHandler
{
	[Serializable]
	public class onColorSelectedEvent : UnityEvent<Color>
	{
	}

	public Texture2D texture;

	public onColorSelectedEvent onColorSelected = new onColorSelectedEvent();

	public virtual void OnPointerDown(PointerEventData eventData)
	{
		OnDrag(eventData);
	}

	public virtual void OnDrag(PointerEventData eventData)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		Vector2 val2 = default(Vector2);
		if (RectTransformUtility.ScreenPointToLocalPointInRectangle(val, eventData.position, eventData.pressEventCamera, ref val2))
		{
			ref float x = ref val2.x;
			float num = x;
			Rect rect = val.rect;
			x = num + ((Rect)(ref rect)).width * val.pivot.x;
			ref float y = ref val2.y;
			float num2 = y;
			rect = val.rect;
			y = num2 + ((Rect)(ref rect)).height * val.pivot.y;
			ref float x2 = ref val2.x;
			float num3 = x2;
			rect = val.rect;
			x2 = num3 / ((Rect)(ref rect)).width;
			ref float y2 = ref val2.y;
			float num4 = y2;
			rect = val.rect;
			y2 = num4 / ((Rect)(ref rect)).height;
			Color pixel = texture.GetPixel((int)(val2.x * (float)((Texture)texture).width), (int)(val2.y * (float)((Texture)texture).height));
			((UnityEvent<Color>)onColorSelected).Invoke(pixel);
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Events;

[Serializable]
public class onColorSelectedEvent : UnityEvent<Color>
{
}


using UnityEngine;

public class TimedRemoval : MonoBehaviour
{
	public Object objectToDestroy;

	public float removeDelay = 1f;

	private void OnEnable()
	{
		Object.Destroy(objectToDestroy, removeDelay);
	}
}


using System;
using Facepunch;
using UnityEngine;

[Serializable]
public class TokenisedPhrase : Phrase
{
	public static readonly Phrase LeftMouse = new Phrase("button.mouse.left", "Left Mouse");

	public static readonly Phrase RightMouse = new Phrase("button.mouse.right", "Right Mouse");

	public static readonly Phrase MiddleMouse = new Phrase("button.mouse.middle", "Middle Mouse");

	public override string translated => ReplaceTokens(((Phrase)this).translated);

	public static string ReplaceTokens(string str)
	{
		if (!str.Contains("["))
		{
			return str;
		}
		str = str.Replace("[inventory.toggle]", string.Format("[{0}]", Input.GetButtonWithBind("inventory.toggle", false).ToUpper()));
		str = str.Replace("[inventory.togglecrafting]", string.Format("[{0}]", Input.GetButtonWithBind("inventory.togglecrafting", false).ToUpper()));
		str = str.Replace("[+map]", string.Format("[{0}]", Input.GetButtonWithBind("+map", false).ToUpper()));
		str = str.Replace("[inventory.examineheld]", string.Format("[{0}]", Input.GetButtonWithBind("inventory.examineheld", false).ToUpper()));
		str = str.Replace("[slot2]", string.Format("[{0}]", Input.GetButtonWithBind("+slot2", false).ToUpper()));
		str = str.Replace("[attack]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+attack", true)).ToUpper()));
		str = str.Replace("[attack2]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+attack2", false)).ToUpper()));
		str = str.Replace("[attack3]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+attack3", false)).ToUpper()));
		str = str.Replace("[+use]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+use", false)).ToUpper()));
		str = str.Replace("[+altlook]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+altlook", false)).ToUpper()));
		str = str.Replace("[+reload]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+reload", false)).ToUpper()));
		str = str.Replace("[+voice]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+voice", false)).ToUpper()));
		str = str.Replace("[+lockBreakHealthPercent]", $"{0.2f:0%}");
		str = str.Replace("[+gestures]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+gestures", false)).ToUpper()));
		str = str.Replace("[+left]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+left", false)).ToUpper()));
		str = str.Replace("[+right]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+right", false)).ToUpper()));
		str = str.Replace("[+backward]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+backward", false)).ToUpper()));
		str = str.Replace("[+forward]", string.Format("[{0}]", TranslateMouseButton(Input.GetButtonWithBind("+forward", false)).ToUpper()));
		str = str.Replace("[+sprint]", string.Format("[{0}]", Input.GetButtonWithBind("+sprint", false)).ToUpper());
		str = str.Replace("[+duck]", string.Format("[{0}]", Input.GetButtonWithBind("+duck", false)).ToUpper());
		str = str.Replace("[+pets]", string.Format("[{0}]", Input.GetButtonWithBind("+pets", false)).ToUpper());
		str = str.Replace("[lighttoggle]", string.Format("[{0}]", Input.GetButtonWithBind("lighttoggle", false)).ToUpper());
		str = str.Replace("[+ping]", string.Format("[{0}]", Input.GetButtonWithBind("+ping", false)).ToUpper());
		str = str.Replace("[clan.toggleclan]", string.Format("[{0}]", Input.GetButtonWithBind("clan.toggleclan", false)).ToUpper());
		str = str.Replace("[+jump]", string.Format("[{0}]", Input.GetButtonWithBind("+jump", false)).ToUpper());
		str = str.Replace("[movement]", ("[" + TranslateMouseButton(Input.GetButtonWithBind("+forward", false)) + TranslateMouseButton(Input.GetButtonWithBind("+left", false)) + TranslateMouseButton(Input.GetButtonWithBind("+backward", false)) + TranslateMouseButton(Input.GetButtonWithBind("+right", false)) + "]").ToUpper());
		str = str.Replace("[+help]", string.Format("[{0}]", Input.GetButtonWithBind("+opentutorialhelp", false)).ToUpper());
		return str;
	}

	public TokenisedPhrase(string t = "", string eng = "")
		: base(t, eng)
	{
	}

	public static string TranslateMouseButton(string mouseButton)
	{
		return mouseButton switch
		{
			"mouse0" => LeftMouse.translated, 
			"mouse1" => RightMouse.translated, 
			"mouse2" => MiddleMouse.translated, 
			_ => mouseButton, 
		};
	}

	private static string GetButtonWithBind(string s)
	{
		if (!Application.isPlaying)
		{
			switch (s)
			{
			case "inventory.toggle":
				return "tab";
			case "inventory.togglecrafting":
				return "q";
			case "+map":
				return "g";
			case "inventory.examineheld":
				return "n";
			case "+slot2":
				return "2";
			case "+attack":
				return "mouse0";
			case "+attack2":
				return "mouse1";
			case "+use":
				return "e";
			case "+altlook":
				return "leftalt";
			case "+reload":
				return "r";
			case "+voice":
				return "v";
			}
		}
		return Input.GetButtonWithBind(s, false);
	}
}


using UnityEngine;

public class TriggerMovement : TriggerBase, IClientComponent
{
	[Tooltip("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
	public Transform losEyes;

	public BaseEntity.MovementModify movementModify;
}


using UnityEngine;

public class TriggerVehicleDrag : TriggerBase, IServerComponent
{
	[Tooltip("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
	public Transform losEyes;

	public float vehicleDrag;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if ((Object)(object)losEyes != (Object)null)
		{
			if (entityContents != null && entityContents.Contains(baseEntity))
			{
				return ((Component)baseEntity).gameObject;
			}
			if (!baseEntity.IsVisible(((Component)losEyes).transform.position, baseEntity.CenterPoint()))
			{
				return null;
			}
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UnderwearIcon : MonoBehaviour, IClientComponent
{
	public Image icon;
}


using System;
using UnityEngine;

public class UnderwearSkinPicker : MonoBehaviour
{
	public GameObjectRef pickerIcon;

	public GameObject container;

	public Action skinChangedEvent;

	public Sprite defaultNudeIcon;

	public Sprite defaultIconMale;

	public Sprite defaultIconFemale;
}


using UnityEngine;

public class UnparentOnDestroy : MonoBehaviour, IOnParentDestroying
{
	public float destroyAfterSeconds = 1f;

	public void OnParentDestroying()
	{
		((Component)this).transform.parent = null;
		GameManager.Destroy(((Component)this).gameObject, (destroyAfterSeconds <= 0f) ? 1f : destroyAfterSeconds);
	}

	protected void OnValidate()
	{
		if (destroyAfterSeconds <= 0f)
		{
			destroyAfterSeconds = 1f;
		}
	}
}


using UnityEngine;

public class ViewModel : MonoBehaviour, IClientComponent
{
	public GameObjectRef viewModelPrefab;
}


using UnityEngine;

public class ViewmodelItem : MonoBehaviour
{
}


using System.Collections.Generic;
using UnityEngine;

public class ViewShake
{
	protected class ShakeParameters
	{
		public float endTime;

		public float duration;

		public float amplitude;

		public float frequency;

		public float nextShake;

		public float angle;

		public Vector3 offset;

		public bool infinite;
	}

	protected List<ShakeParameters> Entries = new List<ShakeParameters>();

	public Vector3 PositionOffset { get; protected set; }

	public Vector3 AnglesOffset { get; protected set; }

	public void AddShake(float amplitude, float frequency, float duration)
	{
		Entries.Add(new ShakeParameters
		{
			amplitude = amplitude,
			frequency = Mathf.Max(frequency, 0.01f),
			duration = duration,
			endTime = Time.time + duration,
			nextShake = 0f,
			angle = 0f,
			infinite = (duration <= 0f)
		});
	}

	public void Update()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		Vector3 zero = Vector3.zero;
		Entries.RemoveAll((ShakeParameters i) => !i.infinite && Time.time > i.endTime);
		foreach (ShakeParameters entry in Entries)
		{
			if (Time.time > entry.nextShake)
			{
				entry.nextShake = Time.time + 1f / entry.frequency;
				entry.offset = new Vector3(Random.Range(0f - entry.amplitude, entry.amplitude), Random.Range(0f - entry.amplitude, entry.amplitude), Random.Range(0f - entry.amplitude, entry.amplitude));
				entry.angle = Random.Range((0f - entry.amplitude) * 0.25f, entry.amplitude * 0.25f);
			}
			float num = 0f;
			float num2 = (entry.infinite ? 1f : ((entry.endTime - Time.time) / entry.duration));
			if (num2 != 0f)
			{
				num = entry.frequency / num2;
			}
			num2 *= num2;
			float num3 = Time.time * num;
			num2 *= Mathf.Sin(num3);
			val += entry.offset * num2;
			zero.z += entry.angle * num2;
			if (!entry.infinite)
			{
				entry.amplitude -= entry.amplitude * Time.deltaTime / (entry.duration * entry.frequency);
			}
		}
		PositionOffset = val * 0.01f;
		AnglesOffset = zero;
	}

	public void Stop()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Entries.Clear();
		PositionOffset = Vector3.zero;
		AnglesOffset = Vector3.zero;
	}
}


using UnityEngine;

protected class ShakeParameters
{
	public float endTime;

	public float duration;

	public float amplitude;

	public float frequency;

	public float nextShake;

	public float angle;

	public Vector3 offset;

	public bool infinite;
}


using UnityEngine;

[RequireComponent(typeof(Wearable))]
public class WearableHairCap : MonoBehaviour
{
	public HairType Type;

	[ColorUsage(false, true)]
	public Color BaseColor = Color.black;

	public Texture Mask;

	private static MaterialPropertyBlock block;

	private static int _HairBaseColorUV1 = Shader.PropertyToID("_HairBaseColorUV1");

	private static int _HairBaseColorUV2 = Shader.PropertyToID("_HairBaseColorUV2");

	private static int _HairPackedMapUV1 = Shader.PropertyToID("_HairPackedMapUV1");

	private static int _HairPackedMapUV2 = Shader.PropertyToID("_HairPackedMapUV2");

	public void ApplyHairCap(MaterialPropertyBlock block)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		if (Type == HairType.Head || Type == HairType.Armpit || Type == HairType.Pubic)
		{
			Texture texture = block.GetTexture(_HairPackedMapUV1);
			block.SetColor(_HairBaseColorUV1, ((Color)(ref BaseColor)).gamma);
			block.SetTexture(_HairPackedMapUV1, ((Object)(object)Mask != (Object)null) ? Mask : texture);
		}
		else if (Type == HairType.Facial)
		{
			Texture texture2 = block.GetTexture(_HairPackedMapUV2);
			block.SetColor(_HairBaseColorUV2, ((Color)(ref BaseColor)).gamma);
			block.SetTexture(_HairPackedMapUV2, ((Object)(object)Mask != (Object)null) ? Mask : texture2);
		}
	}
}


using UnityEngine;

public class BaseCollision : MonoBehaviour, IClientComponent
{
	public BaseEntity Owner;

	public Model model;
}


using System;
using UnityEngine;

[Obsolete]
public class ColliderBatch : MonoBehaviour, IEditorComponent
{
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using GamePhysicsJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using UnityEngine;
using UtilityJobs;

public static class GamePhysics
{
	public enum Realm
	{
		Client,
		Server
	}

	[Flags]
	public enum MasksToValidate : byte
	{
		None = 0,
		Terrain = 1,
		Water = 2,
		All = 3
	}

	public const int BufferLength = 32768;

	private static RaycastHit[] hitBuffer = (RaycastHit[])(object)new RaycastHit[32768];

	private static RaycastHit[] hitBufferB = (RaycastHit[])(object)new RaycastHit[32768];

	private static Collider[] colBuffer = (Collider[])(object)new Collider[32768];

	public const int DefaultMaxResultsPerQuery = 16;

	public static bool CheckSphere(Vector3 position, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position, layerMask);
		return Physics.CheckSphere(position, radius, layerMask, triggerInteraction);
	}

	public static void CheckSpheres(ReadOnly<Vector3> pos, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<bool> results, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckSpheres", 0);
		try
		{
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(pos.Length, (Allocator)3, (NativeArrayOptions)0);
			OverlapSpheres(pos, radii, layerMasks, hits, 1, triggerInteraction, validate);
			CheckHitsJob checkHitsJob = default(CheckHitsJob);
			checkHitsJob.Results = results;
			checkHitsJob.Hits = hits.AsReadOnly();
			CheckHitsJob checkHitsJob2 = checkHitsJob;
			IJobExtensions.RunByRef<CheckHitsJob>(ref checkHitsJob2);
			hits.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision((start + end) * 0.5f, layerMask);
		return Physics.CheckCapsule(start, end, radius, layerMask, triggerInteraction);
	}

	public static void CheckCapsules(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<bool> results, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All, bool mitigateSpheres = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckCapsules", 0);
		try
		{
			ReadOnly<int> layerMasks2 = layerMasks;
			NativeArray<int> array = default(NativeArray<int>);
			if (validate != 0)
			{
				array = new NativeArray<int>(layerMasks.Length, (Allocator)3, (NativeArrayOptions)0);
				layerMasks.CopyTo(array);
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(starts.Length, (Allocator)3, (NativeArrayOptions)0);
				CalcMidpoingJob calcMidpoingJob = default(CalcMidpoingJob);
				calcMidpoingJob.Results = results2;
				calcMidpoingJob.From = starts;
				calcMidpoingJob.To = ends;
				CalcMidpoingJob calcMidpoingJob2 = calcMidpoingJob;
				IJobExtensions.RunByRef<CalcMidpoingJob>(ref calcMidpoingJob2);
				HandleIgnoreCollision(results2.AsReadOnly(), array, validate);
				results2.Dispose();
				layerMasks2 = array.AsReadOnly();
			}
			NativeArray<OverlapCapsuleCommand> val2 = new NativeArray<OverlapCapsuleCommand>(starts.Length, (Allocator)3, (NativeArrayOptions)0);
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob = default(GenerateOverlapCapsuleCommandsJob);
			generateOverlapCapsuleCommandsJob.CapsuleCommands = val2;
			generateOverlapCapsuleCommandsJob.From = starts;
			generateOverlapCapsuleCommandsJob.To = ends;
			generateOverlapCapsuleCommandsJob.Radiii = radii;
			generateOverlapCapsuleCommandsJob.LayerMasks = layerMasks2;
			generateOverlapCapsuleCommandsJob.TriggerInteraction = triggerInteraction;
			generateOverlapCapsuleCommandsJob.HitBackfaces = false;
			generateOverlapCapsuleCommandsJob.HitMultipleFaces = false;
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob2 = generateOverlapCapsuleCommandsJob;
			IJobExtensions.RunByRef<GenerateOverlapCapsuleCommandsJob>(ref generateOverlapCapsuleCommandsJob2);
			NativeArrayEx.SafeDispose(ref array);
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(starts.Length, (Allocator)3, (NativeArrayOptions)0);
			if (mitigateSpheres)
			{
				MitigateSphereCapsuleCommands(val2, hits, 1);
			}
			else
			{
				ExecuteOverlapCapsuleCommands(val2, hits, 1);
			}
			val2.Dispose();
			CheckHitsJob checkHitsJob = default(CheckHitsJob);
			checkHitsJob.Results = results;
			checkHitsJob.Hits = hits.AsReadOnly();
			CheckHitsJob checkHitsJob2 = checkHitsJob;
			IJobExtensions.RunByRef<CheckHitsJob>(ref checkHitsJob2);
			hits.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool CheckOBB(OBB obb, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		return Physics.CheckBox(obb.position, obb.extents, obb.rotation, layerMask, triggerInteraction);
	}

	public static bool CheckOBBAndEntity(OBB obb, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		int num = Physics.OverlapBoxNonAlloc(obb.position, obb.extents, colBuffer, obb.rotation, layerMask, triggerInteraction);
		for (int i = 0; i < num; i++)
		{
			BaseEntity baseEntity = colBuffer[i].ToBaseEntity();
			if (!((Object)(object)baseEntity != (Object)null) || !((Object)(object)ignoreEntity != (Object)null) || (baseEntity.isServer == ignoreEntity.isServer && !((Object)(object)baseEntity == (Object)(object)ignoreEntity)))
			{
				return true;
			}
		}
		return false;
	}

	public static bool CheckBounds(Bounds bounds, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(((Bounds)(ref bounds)).center, layerMask);
		return Physics.CheckBox(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).extents, Quaternion.identity, layerMask, triggerInteraction);
	}

	public static bool CheckInsideNonConvexMesh(Vector3 point, int layerMask = -5)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		bool queriesHitBackfaces = Physics.queriesHitBackfaces;
		Physics.queriesHitBackfaces = true;
		int num = Physics.RaycastNonAlloc(point, Vector3.up, hitBuffer, 100f, layerMask);
		int num2 = Physics.RaycastNonAlloc(point, -Vector3.up, hitBufferB, 100f, layerMask);
		if (num >= hitBuffer.Length)
		{
			Debug.LogWarning((object)"CheckInsideNonConvexMesh query is exceeding hitBuffer length.");
			return false;
		}
		if (num2 > hitBufferB.Length)
		{
			Debug.LogWarning((object)"CheckInsideNonConvexMesh query is exceeding hitBufferB length.");
			return false;
		}
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num2; j++)
			{
				if ((Object)(object)((RaycastHit)(ref hitBuffer[i])).collider == (Object)(object)((RaycastHit)(ref hitBufferB[j])).collider)
				{
					Physics.queriesHitBackfaces = queriesHitBackfaces;
					return true;
				}
			}
		}
		Physics.queriesHitBackfaces = queriesHitBackfaces;
		return false;
	}

	public static bool CheckInsideAnyCollider(Vector3 point, int layerMask = -5)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (Physics.CheckSphere(point, 0f, layerMask))
		{
			return true;
		}
		if (CheckInsideNonConvexMesh(point, layerMask))
		{
			return true;
		}
		if ((Object)(object)TerrainMeta.HeightMap != (Object)null && TerrainMeta.HeightMap.GetHeight(point) > point.y)
		{
			return true;
		}
		return false;
	}

	public static void OverlapSphere(Vector3 position, float radius, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position, layerMask);
		int count = Physics.OverlapSphereNonAlloc(position, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapSpheres(ReadOnly<Vector3> positions, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<ColliderHit> hits, int maxResPerCast, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.OverlapSpheres", 0);
		try
		{
			ReadOnly<int> layerMasks2 = layerMasks;
			NativeArray<int> array = default(NativeArray<int>);
			if (validate != 0)
			{
				array = new NativeArray<int>(layerMasks.Length, (Allocator)3, (NativeArrayOptions)0);
				layerMasks.CopyTo(array);
				HandleIgnoreCollision(positions, array, validate);
				layerMasks2 = array.AsReadOnly();
			}
			NativeArray<OverlapSphereCommand> val2 = new NativeArray<OverlapSphereCommand>(positions.Length, (Allocator)3, (NativeArrayOptions)0);
			GenerateOverlapSphereCommandsJob generateOverlapSphereCommandsJob = default(GenerateOverlapSphereCommandsJob);
			generateOverlapSphereCommandsJob.SphereCommands = val2;
			generateOverlapSphereCommandsJob.Pos = positions;
			generateOverlapSphereCommandsJob.Radiii = radii;
			generateOverlapSphereCommandsJob.LayerMasks = layerMasks2;
			generateOverlapSphereCommandsJob.TriggerInteraction = triggerInteraction;
			generateOverlapSphereCommandsJob.HitBackfaces = false;
			generateOverlapSphereCommandsJob.HitMultipleFaces = false;
			GenerateOverlapSphereCommandsJob generateOverlapSphereCommandsJob2 = generateOverlapSphereCommandsJob;
			IJobExtensions.RunByRef<GenerateOverlapSphereCommandsJob>(ref generateOverlapSphereCommandsJob2);
			NativeArrayEx.SafeDispose(ref array);
			ExecuteOverlapSphereCommands(val2, hits, maxResPerCast);
			val2.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void ExecuteOverlapSphereCommands(NativeArray<OverlapSphereCommand> commands, NativeArray<ColliderHit> hits, int maxResPerCast)
	{
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		if (Debug.isDebugBuild)
		{
			NativeList<int> invalidIndices = default(NativeList<int>);
			invalidIndices..ctor(commands.Length, AllocatorHandle.op_Implicit((Allocator)3));
			ValidateOverlapSphereCommandsJob validateOverlapSphereCommandsJob = default(ValidateOverlapSphereCommandsJob);
			validateOverlapSphereCommandsJob.InvalidIndices = invalidIndices;
			validateOverlapSphereCommandsJob.Commands = commands.AsReadOnly();
			ValidateOverlapSphereCommandsJob validateOverlapSphereCommandsJob2 = validateOverlapSphereCommandsJob;
			IJobExtensions.RunByRef<ValidateOverlapSphereCommandsJob>(ref validateOverlapSphereCommandsJob2);
			if (!invalidIndices.IsEmpty)
			{
				int num = invalidIndices[0];
				OverlapSphereCommand val = commands[num];
				Debug.LogError((object)string.Concat(string.Concat(string.Concat($"OverlapSpheres has {invalidIndices.Length} invalid sphere commands!" + $"\nFirst one was at index {num}:", $"\n\tPos: {((OverlapSphereCommand)(ref val)).point}"), $"\n\tRadius: {((OverlapSphereCommand)(ref val)).radius}"), "\nThese queries will be skipped!"));
			}
			invalidIndices.Dispose();
		}
		int batchSize = GetBatchSize(commands.Length);
		JobHandle val2 = OverlapSphereCommand.ScheduleBatch(commands, hits, batchSize, maxResPerCast, default(JobHandle));
		((JobHandle)(ref val2)).Complete();
	}

	public static void CapsuleSweep(Vector3 position0, Vector3 position1, float radius, Vector3 direction, float distance, List<RaycastHit> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position0, layerMask);
		layerMask = HandleIgnoreCollision(position1, layerMask);
		HitBufferToList(Physics.CapsuleCastNonAlloc(position0, position1, radius, direction, hitBuffer, distance, layerMask, triggerInteraction), list);
	}

	public static void OverlapCapsule(Vector3 point0, Vector3 point1, float radius, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(point0, layerMask);
		layerMask = HandleIgnoreCollision(point1, layerMask);
		int count = Physics.OverlapCapsuleNonAlloc(point0, point1, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapCapsules(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> layerMasks, NativeArray<ColliderHit> hits, int maxResPerCast, QueryTriggerInteraction triggerInteraction = 1, MasksToValidate validate = MasksToValidate.All, bool mitigateSpheres = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.OverlapCapsules", 0);
		try
		{
			ReadOnly<int> layerMasks2 = layerMasks;
			NativeArray<int> array = default(NativeArray<int>);
			if (validate != 0)
			{
				array = new NativeArray<int>(layerMasks.Length, (Allocator)3, (NativeArrayOptions)0);
				layerMasks.CopyTo(array);
				HandleIgnoreCollision(starts, array, validate);
				HandleIgnoreCollision(ends, array, validate);
				layerMasks2 = array.AsReadOnly();
			}
			NativeArray<OverlapCapsuleCommand> val2 = new NativeArray<OverlapCapsuleCommand>(starts.Length, (Allocator)3, (NativeArrayOptions)0);
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob = default(GenerateOverlapCapsuleCommandsJob);
			generateOverlapCapsuleCommandsJob.CapsuleCommands = val2;
			generateOverlapCapsuleCommandsJob.From = starts;
			generateOverlapCapsuleCommandsJob.To = ends;
			generateOverlapCapsuleCommandsJob.Radiii = radii;
			generateOverlapCapsuleCommandsJob.LayerMasks = layerMasks2;
			generateOverlapCapsuleCommandsJob.TriggerInteraction = triggerInteraction;
			generateOverlapCapsuleCommandsJob.HitBackfaces = false;
			generateOverlapCapsuleCommandsJob.HitMultipleFaces = false;
			GenerateOverlapCapsuleCommandsJob generateOverlapCapsuleCommandsJob2 = generateOverlapCapsuleCommandsJob;
			IJobExtensions.RunByRef<GenerateOverlapCapsuleCommandsJob>(ref generateOverlapCapsuleCommandsJob2);
			NativeArrayEx.SafeDispose(ref array);
			if (mitigateSpheres)
			{
				MitigateSphereCapsuleCommands(val2, hits, maxResPerCast);
			}
			else
			{
				ExecuteOverlapCapsuleCommands(val2, hits, maxResPerCast);
			}
			val2.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void MitigateSphereCapsuleCommands(NativeArray<OverlapCapsuleCommand> commands, NativeArray<ColliderHit> hits, int maxResPerCast)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		NativeList<int> val = default(NativeList<int>);
		val..ctor(commands.Length, AllocatorHandle.op_Implicit((Allocator)3));
		FindSphereCmdsInCapsuleCmdsJob findSphereCmdsInCapsuleCmdsJob = default(FindSphereCmdsInCapsuleCmdsJob);
		findSphereCmdsInCapsuleCmdsJob.SphereIndices = val;
		findSphereCmdsInCapsuleCmdsJob.Commands = commands.AsReadOnly();
		FindSphereCmdsInCapsuleCmdsJob findSphereCmdsInCapsuleCmdsJob2 = findSphereCmdsInCapsuleCmdsJob;
		IJobExtensions.RunByRef<FindSphereCmdsInCapsuleCmdsJob>(ref findSphereCmdsInCapsuleCmdsJob2);
		if (val.IsEmpty)
		{
			val.Dispose();
			ExecuteOverlapCapsuleCommands(commands, hits, maxResPerCast);
			return;
		}
		int num = Math.Max(val.Length, commands.Length - val.Length);
		NativeArray<ColliderHit> hits2 = default(NativeArray<ColliderHit>);
		hits2..ctor(num * maxResPerCast, (Allocator)3, (NativeArrayOptions)0);
		NativeList<OverlapSphereCommand> sphereCommands = default(NativeList<OverlapSphereCommand>);
		sphereCommands..ctor(val.Length, AllocatorHandle.op_Implicit((Allocator)3));
		GenerateSphereCmdsFromCapsuleCmdsJob generateSphereCmdsFromCapsuleCmdsJob = default(GenerateSphereCmdsFromCapsuleCmdsJob);
		generateSphereCmdsFromCapsuleCmdsJob.SphereCommands = sphereCommands;
		generateSphereCmdsFromCapsuleCmdsJob.Commands = commands.AsReadOnly();
		generateSphereCmdsFromCapsuleCmdsJob.Indices = val.AsReadOnly();
		GenerateSphereCmdsFromCapsuleCmdsJob generateSphereCmdsFromCapsuleCmdsJob2 = generateSphereCmdsFromCapsuleCmdsJob;
		IJobExtensions.RunByRef<GenerateSphereCmdsFromCapsuleCmdsJob>(ref generateSphereCmdsFromCapsuleCmdsJob2);
		ExecuteOverlapSphereCommands(sphereCommands.AsArray(), hits2, maxResPerCast);
		ScatterColliderHitsJob scatterColliderHitsJob = default(ScatterColliderHitsJob);
		scatterColliderHitsJob.To = hits;
		scatterColliderHitsJob.From = hits2.AsReadOnly();
		scatterColliderHitsJob.Indices = val.AsReadOnly();
		scatterColliderHitsJob.MaxHitsPerRay = maxResPerCast;
		ScatterColliderHitsJob scatterColliderHitsJob2 = scatterColliderHitsJob;
		IJobExtensions.RunByRef<ScatterColliderHitsJob>(ref scatterColliderHitsJob2);
		sphereCommands.Dispose();
		if (val.Length != commands.Length)
		{
			NativeArray<bool> workBuffer = default(NativeArray<bool>);
			workBuffer..ctor(commands.Length, (Allocator)3, (NativeArrayOptions)0);
			InvertIndexListJob invertIndexListJob = default(InvertIndexListJob);
			invertIndexListJob.Indices = val;
			invertIndexListJob.WorkBuffer = workBuffer;
			InvertIndexListJob invertIndexListJob2 = invertIndexListJob;
			IJobExtensions.RunByRef<InvertIndexListJob>(ref invertIndexListJob2);
			workBuffer.Dispose();
			NativeArray<OverlapCapsuleCommand> val2 = default(NativeArray<OverlapCapsuleCommand>);
			val2..ctor(val.Length, (Allocator)3, (NativeArrayOptions)0);
			GatherJob<OverlapCapsuleCommand> gatherJob = default(GatherJob<OverlapCapsuleCommand>);
			gatherJob.Results = val2;
			gatherJob.Source = commands.AsReadOnly();
			gatherJob.Indices = val.AsReadOnly();
			GatherJob<OverlapCapsuleCommand> gatherJob2 = gatherJob;
			IJobExtensions.RunByRef<GatherJob<OverlapCapsuleCommand>>(ref gatherJob2);
			ExecuteOverlapCapsuleCommands(val2, hits2, maxResPerCast);
			scatterColliderHitsJob = default(ScatterColliderHitsJob);
			scatterColliderHitsJob.To = hits;
			scatterColliderHitsJob.From = hits2.AsReadOnly();
			scatterColliderHitsJob.Indices = val.AsReadOnly();
			scatterColliderHitsJob.MaxHitsPerRay = maxResPerCast;
			ScatterColliderHitsJob scatterColliderHitsJob3 = scatterColliderHitsJob;
			IJobExtensions.RunByRef<ScatterColliderHitsJob>(ref scatterColliderHitsJob3);
			val2.Dispose();
		}
		hits2.Dispose();
		val.Dispose();
	}

	private static void ExecuteOverlapCapsuleCommands(NativeArray<OverlapCapsuleCommand> commands, NativeArray<ColliderHit> hits, int maxResPerCast)
	{
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (Debug.isDebugBuild)
		{
			NativeList<int> invalidIndices = default(NativeList<int>);
			invalidIndices..ctor(commands.Length, AllocatorHandle.op_Implicit((Allocator)3));
			ValidateOverlapCapsuleCommandsJob validateOverlapCapsuleCommandsJob = default(ValidateOverlapCapsuleCommandsJob);
			validateOverlapCapsuleCommandsJob.InvalidIndices = invalidIndices;
			validateOverlapCapsuleCommandsJob.Commands = commands.AsReadOnly();
			ValidateOverlapCapsuleCommandsJob validateOverlapCapsuleCommandsJob2 = validateOverlapCapsuleCommandsJob;
			IJobExtensions.RunByRef<ValidateOverlapCapsuleCommandsJob>(ref validateOverlapCapsuleCommandsJob2);
			if (!invalidIndices.IsEmpty)
			{
				int num = invalidIndices[0];
				OverlapCapsuleCommand val = commands[num];
				Debug.LogError((object)string.Concat(string.Concat(string.Concat(string.Concat($"OverlapCapsules has {invalidIndices.Length} invalid sphere commands!" + $"\nFirst one was at index {num}:", $"\n\tPoint0: {((OverlapCapsuleCommand)(ref val)).point0}"), $"\n\tPoint1: {((OverlapCapsuleCommand)(ref val)).point1}"), $"\n\tRadius: {((OverlapCapsuleCommand)(ref val)).radius}"), "\nThese queries will be skipped!"));
			}
			invalidIndices.Dispose();
		}
		int batchSize = GetBatchSize(commands.Length);
		JobHandle val2 = OverlapCapsuleCommand.ScheduleBatch(commands, hits, batchSize, maxResPerCast, default(JobHandle));
		((JobHandle)(ref val2)).Complete();
	}

	public static void OverlapOBB(OBB obb, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		int count = Physics.OverlapBoxNonAlloc(obb.position, obb.extents, colBuffer, obb.rotation, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapBounds(Bounds bounds, List<Collider> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(((Bounds)(ref bounds)).center, layerMask);
		int count = Physics.OverlapBoxNonAlloc(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).extents, colBuffer, Quaternion.identity, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	private static void BufferToList(Collider[] buffer, int count, List<Collider> list)
	{
		for (int i = 0; i < count; i++)
		{
			list.Add(buffer[i]);
			buffer[i] = null;
		}
	}

	public static bool CheckSphere<T>(Vector3 pos, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapSphere(pos, radius, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static void CheckSpheres<T>(ReadOnly<Vector3> positions, ReadOnly<float> radii, ReadOnly<int> layerMasks, Span<bool> results, QueryTriggerInteraction triggerInteraction = 1, int maxResPerCast = 16, MasksToValidate validate = MasksToValidate.All) where T : Component
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckSpheres<T>", 0);
		try
		{
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(positions.Length * maxResPerCast, (Allocator)3, (NativeArrayOptions)0);
			OverlapSpheres(positions, radii, layerMasks, hits, maxResPerCast, triggerInteraction, validate);
			TimeWarning val2 = TimeWarning.New("FindComponent", 0);
			try
			{
				T val4 = default(T);
				for (int i = 0; i < positions.Length; i++)
				{
					bool flag = false;
					int num = i * maxResPerCast;
					for (int j = 0; j < maxResPerCast; j++)
					{
						ColliderHit val3 = hits[num + j];
						if (((ColliderHit)(ref val3)).instanceID == 0)
						{
							break;
						}
						if (((Component)((ColliderHit)(ref val3)).collider).TryGetComponent<T>(ref val4))
						{
							flag = true;
							break;
						}
					}
					results[i] = flag;
				}
				hits.Dispose();
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool CheckCapsule<T>(Vector3 start, Vector3 end, float radius, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapCapsule(start, end, radius, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckOBB<T>(OBB obb, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapOBB(obb, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckBounds<T>(Bounds bounds, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		OverlapBounds(bounds, list, layerMask, triggerInteraction);
		bool result = CheckComponent<T>(list);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private static bool CheckComponent<T>(List<Collider> list)
	{
		T val = default(T);
		for (int i = 0; i < list.Count; i++)
		{
			if (((Component)list[i]).gameObject.TryGetComponent<T>(ref val))
			{
				return true;
			}
		}
		return false;
	}

	public static void OverlapSphere<T>(Vector3 position, float radius, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(position, layerMask);
		int count = Physics.OverlapSphereNonAlloc(position, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void CheckCapsules<T>(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> layerMasks, Span<bool> results, QueryTriggerInteraction triggerInteraction = 1, int maxResPerCast = 16, MasksToValidate validate = MasksToValidate.All, bool mitigateSpheres = true) where T : Component
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.CheckCapsules<T>", 0);
		try
		{
			NativeArray<ColliderHit> hits = new NativeArray<ColliderHit>(starts.Length * maxResPerCast, (Allocator)3, (NativeArrayOptions)0);
			OverlapCapsules(starts, ends, radii, layerMasks, hits, maxResPerCast, triggerInteraction, validate, mitigateSpheres);
			TimeWarning val2 = TimeWarning.New("FindComponent", 0);
			try
			{
				T val4 = default(T);
				for (int i = 0; i < starts.Length; i++)
				{
					bool flag = false;
					int num = i * maxResPerCast;
					for (int j = 0; j < maxResPerCast; j++)
					{
						ColliderHit val3 = hits[num + j];
						if (((ColliderHit)(ref val3)).instanceID == 0)
						{
							break;
						}
						if (((Component)((ColliderHit)(ref val3)).collider).TryGetComponent<T>(ref val4))
						{
							flag = true;
							break;
						}
					}
					results[i] = flag;
				}
				hits.Dispose();
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void OverlapCapsule<T>(Vector3 point0, Vector3 point1, float radius, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(point0, layerMask);
		layerMask = HandleIgnoreCollision(point1, layerMask);
		int count = Physics.OverlapCapsuleNonAlloc(point0, point1, radius, colBuffer, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapOBB<T>(OBB obb, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(obb.position, layerMask);
		int count = Physics.OverlapBoxNonAlloc(obb.position, obb.extents, colBuffer, obb.rotation, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	public static void OverlapBounds<T>(Bounds bounds, List<T> list, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 1) where T : Component
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		layerMask = HandleIgnoreCollision(((Bounds)(ref bounds)).center, layerMask);
		int count = Physics.OverlapBoxNonAlloc(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).extents, colBuffer, Quaternion.identity, layerMask, triggerInteraction);
		BufferToList(colBuffer, count, list);
	}

	private static void BufferToList<T>(Collider[] buffer, int count, List<T> list) where T : Component
	{
		T item = default(T);
		for (int i = 0; i < count; i++)
		{
			if (((Component)buffer[i]).TryGetComponent<T>(ref item))
			{
				list.Add(item);
			}
			buffer[i] = null;
		}
	}

	private static void HitBufferToList(int count, List<RaycastHit> list)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (count >= hitBuffer.Length)
		{
			Debug.LogWarning((object)"Physics query is exceeding collider buffer length.");
		}
		for (int i = 0; i < count; i++)
		{
			list.Add(hitBuffer[i]);
		}
	}

	public static bool TraceRealm(Realm realm, Ray ray, float radius, out RaycastHit hitInfo, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (Trace(ray, radius, out var hitInfo2, maxDistance, layerMask, triggerInteraction, ignoreEntity))
		{
			hitInfo = hitInfo2;
			return true;
		}
		hitInfo = default(RaycastHit);
		return false;
	}

	public static BaseNetworkable TraceRealmEntity(Realm realm, Ray ray, float radius = 0f, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!Trace(ray, radius, out var hitInfo, maxDistance, layerMask, triggerInteraction, ignoreEntity))
		{
			return null;
		}
		return hitInfo.GetEntity();
	}

	public static bool Trace(Ray ray, float radius, out RaycastHit hitInfo, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		TraceAllUnordered(ray, radius, list, maxDistance, layerMask, triggerInteraction, ignoreEntity);
		if (list.Count == 0)
		{
			hitInfo = default(RaycastHit);
			Pool.FreeUnmanaged<RaycastHit>(ref list);
			return false;
		}
		Sort(list);
		hitInfo = list[0];
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return true;
	}

	public static void TraceAll(Ray ray, float radius, List<RaycastHit> hits, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		TraceAllUnordered(ray, radius, hits, maxDistance, layerMask, triggerInteraction, ignoreEntity);
		Sort(hits);
	}

	public static void TraceAllUnordered(Ray ray, float radius, List<RaycastHit> hits, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity = null)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		int num = ((radius != 0f) ? Physics.SphereCastNonAlloc(ray, radius, hitBuffer, maxDistance, layerMask, triggerInteraction) : Physics.RaycastNonAlloc(ray, hitBuffer, maxDistance, layerMask, triggerInteraction));
		if (num < hitBuffer.Length && (layerMask & 0x10) != 0 && WaterSystem.Trace(ray, out var position, out var normal, maxDistance))
		{
			RaycastHit val = default(RaycastHit);
			((RaycastHit)(ref val)).point = position;
			((RaycastHit)(ref val)).normal = normal;
			Vector3 val2 = position - ((Ray)(ref ray)).origin;
			((RaycastHit)(ref val)).distance = ((Vector3)(ref val2)).magnitude;
			RaycastHit val3 = val;
			hitBuffer[num++] = val3;
		}
		if (num == 0)
		{
			return;
		}
		if (num >= hitBuffer.Length)
		{
			Debug.LogWarning((object)"Physics query is exceeding hit buffer length.");
		}
		for (int i = 0; i < num; i++)
		{
			RaycastHit val4 = hitBuffer[i];
			if (Verify(val4, ((Ray)(ref ray)).origin, ignoreEntity))
			{
				hits.Add(val4);
			}
		}
	}

	public static void TraceRaysUnordered(NativeArray<RaycastCommand> rays, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.TraceRaysUnordered", 0);
		try
		{
			int batchSize = GetBatchSize(rays.Length);
			JobHandle val2 = RaycastCommand.ScheduleBatch(rays, hits, batchSize, maxHitsPerTrace, default(JobHandle));
			((JobHandle)(ref val2)).Complete();
			RaycastHit val5;
			if (traceWater)
			{
				TimeWarning val3 = TimeWarning.New("TraceWater", 0);
				try
				{
					Ray ray = default(Ray);
					for (int i = 0; i < rays.Length; i++)
					{
						RaycastCommand val4 = rays[i];
						if ((val4.queryParameters.layerMask & 0x10) == 0)
						{
							continue;
						}
						int j;
						for (j = 0; j < maxHitsPerTrace; j++)
						{
							val5 = hits[i * maxHitsPerTrace + j];
							if (((RaycastHit)(ref val5)).colliderInstanceID == 0)
							{
								break;
							}
						}
						if (j == maxHitsPerTrace)
						{
							break;
						}
						((Ray)(ref ray))..ctor(((RaycastCommand)(ref val4)).from, ((RaycastCommand)(ref val4)).direction);
						if (WaterSystem.Trace(ray, out var position, out var normal, ((RaycastCommand)(ref val4)).distance))
						{
							val5 = default(RaycastHit);
							((RaycastHit)(ref val5)).point = position;
							((RaycastHit)(ref val5)).normal = normal;
							Vector3 val6 = position - ((Ray)(ref ray)).origin;
							((RaycastHit)(ref val5)).distance = ((Vector3)(ref val6)).magnitude;
							RaycastHit val7 = val5;
							hits[j++] = val7;
							if (j < maxHitsPerTrace)
							{
								val5 = (hits[j] = default(RaycastHit));
							}
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			TimeWarning val9 = TimeWarning.New("Verify", 0);
			try
			{
				for (int k = 0; k < rays.Length; k++)
				{
					RaycastCommand val10 = rays[k];
					int num = k * maxHitsPerTrace;
					int num2 = 0;
					for (int l = 0; l < maxHitsPerTrace; l++)
					{
						int num3 = k * maxHitsPerTrace + l;
						RaycastHit val11 = hits[num3];
						val5 = hits[num3];
						if (((RaycastHit)(ref val5)).normal == Vector3.zero)
						{
							break;
						}
						if (Verify(val11, ((RaycastCommand)(ref val10)).from))
						{
							hits[num + num2++] = val11;
						}
					}
					if (num2 < maxHitsPerTrace)
					{
						val5 = (hits[num + num2] = default(RaycastHit));
					}
				}
			}
			finally
			{
				((IDisposable)val9)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void TraceRays(NativeArray<RaycastCommand> rays, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		TraceRaysUnordered(rays, hits, maxHitsPerTrace, traceWater);
		Sort(hits, rays.Length, maxHitsPerTrace);
	}

	public static void TraceSpheresUnordered(NativeArray<SpherecastCommand> spheres, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.TraceSpheresUnordered", 0);
		try
		{
			int batchSize = GetBatchSize(spheres.Length);
			JobHandle val2 = SpherecastCommand.ScheduleBatch(spheres, hits, batchSize, maxHitsPerTrace, default(JobHandle));
			((JobHandle)(ref val2)).Complete();
			RaycastHit val5;
			if (traceWater)
			{
				TimeWarning val3 = TimeWarning.New("TraceWater", 0);
				try
				{
					Ray ray = default(Ray);
					for (int i = 0; i < spheres.Length; i++)
					{
						SpherecastCommand val4 = spheres[i];
						if ((val4.queryParameters.layerMask & 0x10) == 0)
						{
							continue;
						}
						int j;
						for (j = 0; j < maxHitsPerTrace; j++)
						{
							val5 = hits[i * maxHitsPerTrace + j];
							if (((RaycastHit)(ref val5)).colliderInstanceID == 0)
							{
								break;
							}
						}
						if (j == maxHitsPerTrace)
						{
							break;
						}
						((Ray)(ref ray))..ctor(((SpherecastCommand)(ref val4)).origin, ((SpherecastCommand)(ref val4)).direction);
						if (WaterSystem.Trace(ray, out var position, out var normal, ((SpherecastCommand)(ref val4)).distance))
						{
							val5 = default(RaycastHit);
							((RaycastHit)(ref val5)).point = position;
							((RaycastHit)(ref val5)).normal = normal;
							Vector3 val6 = position - ((Ray)(ref ray)).origin;
							((RaycastHit)(ref val5)).distance = ((Vector3)(ref val6)).magnitude;
							RaycastHit val7 = val5;
							hits[j++] = val7;
							if (j < maxHitsPerTrace)
							{
								val5 = (hits[j] = default(RaycastHit));
							}
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			TimeWarning val9 = TimeWarning.New("Verify", 0);
			try
			{
				for (int k = 0; k < spheres.Length; k++)
				{
					SpherecastCommand val10 = spheres[k];
					int num = k * maxHitsPerTrace;
					int num2 = 0;
					for (int l = 0; l < maxHitsPerTrace; l++)
					{
						int num3 = k * maxHitsPerTrace + l;
						RaycastHit val11 = hits[num3];
						val5 = hits[num3];
						if (((RaycastHit)(ref val5)).normal == Vector3.zero)
						{
							break;
						}
						if (Verify(val11, ((SpherecastCommand)(ref val10)).origin))
						{
							hits[num + num2++] = val11;
						}
					}
					if (num2 < maxHitsPerTrace)
					{
						val5 = (hits[num + num2] = default(RaycastHit));
					}
				}
			}
			finally
			{
				((IDisposable)val9)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void TraceSpheres(NativeArray<SpherecastCommand> spheres, NativeArray<RaycastHit> hits, int maxHitsPerTrace, bool traceWater = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		TraceSpheresUnordered(spheres, hits, maxHitsPerTrace, traceWater);
		Sort(hits, spheres.Length, maxHitsPerTrace);
	}

	public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding0, float padding1, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightInternal(p0, p1, layerMask, radius, padding0, padding1, ignoreEntity);
	}

	public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightInternal(p0, p1, layerMask, radius, padding, padding, ignoreEntity);
	}

	public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightInternal(p0, p1, layerMask, radius, 0f, 0f, ignoreEntity);
	}

	public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding0, float padding1, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightRadius(p0, p1, layerMask, 0f, padding0, padding1, ignoreEntity);
	}

	public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightRadius(p0, p1, layerMask, 0f, padding, padding, ignoreEntity);
	}

	public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return LineOfSightRadius(p0, p1, layerMask, 0f, 0f, 0f, ignoreEntity);
	}

	private static bool LineOfSightInternal(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding0, float padding1, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		if (!ValidBounds.TestOuterBounds(p0))
		{
			return false;
		}
		if (!ValidBounds.TestOuterBounds(p1))
		{
			return false;
		}
		Vector3 val = p1 - p0;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (magnitude <= padding0 + padding1)
		{
			return true;
		}
		Vector3 val2 = val / magnitude;
		Ray val3 = default(Ray);
		((Ray)(ref val3))..ctor(p0 + val2 * padding0, val2);
		float num = magnitude - padding0 - padding1;
		bool flag;
		RaycastHit hitInfo = default(RaycastHit);
		if (!ignoreEntity.IsRealNull() || (layerMask & 0x800000) != 0)
		{
			flag = Trace(val3, 0f, out hitInfo, num, layerMask, (QueryTriggerInteraction)1, ignoreEntity);
			if (radius > 0f && !flag)
			{
				flag = Trace(val3, radius, out hitInfo, num, layerMask, (QueryTriggerInteraction)1, ignoreEntity);
			}
		}
		else
		{
			flag = Physics.Raycast(val3, ref hitInfo, num, layerMask, (QueryTriggerInteraction)1);
			if (radius > 0f && !flag)
			{
				flag = Physics.SphereCast(val3, radius, ref hitInfo, num, layerMask, (QueryTriggerInteraction)1);
			}
		}
		if (!flag)
		{
			if (ConVar.Vis.lineofsight)
			{
				ConsoleNetwork.BroadcastToAllClients("ddraw.line", 60f, Color.green, p0, p1);
			}
			return true;
		}
		if (ConVar.Vis.lineofsight)
		{
			ConsoleNetwork.BroadcastToAllClients("ddraw.line", 60f, Color.red, p0, p1);
			ConsoleNetwork.BroadcastToAllClients("ddraw.text", 60f, Color.white, ((RaycastHit)(ref hitInfo)).point, ((Object)((RaycastHit)(ref hitInfo)).collider).name);
		}
		return false;
	}

	public static bool Verify(RaycastHit hitInfo, Vector3 rayOrigin, BaseEntity ignoreEntity = null)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((RaycastHit)(ref hitInfo)).point;
		if (((RaycastHit)(ref hitInfo)).collider is TerrainCollider && val == Vector3.zero && ((RaycastHit)(ref hitInfo)).distance == 0f)
		{
			val = rayOrigin;
		}
		return Verify(((RaycastHit)(ref hitInfo)).collider, val, ignoreEntity);
	}

	public static bool Verify(Collider collider, Vector3 point, BaseEntity ignoreEntity = null)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)collider == (Object)null)
		{
			if (Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(point))
			{
				return false;
			}
			return true;
		}
		if (collider is TerrainCollider)
		{
			if (Object.op_Implicit((Object)(object)TerrainMeta.Collision) && TerrainMeta.Collision.GetIgnore(point))
			{
				return false;
			}
			return true;
		}
		if (CompareEntity(collider.ToBaseEntity(), ignoreEntity))
		{
			return false;
		}
		return collider.enabled;
	}

	public static bool CompareEntity(BaseEntity a, BaseEntity b)
	{
		if (a.IsRealNull() || b.IsRealNull())
		{
			return false;
		}
		if ((Object)(object)a == (Object)(object)b)
		{
			return true;
		}
		return false;
	}

	public static int HandleIgnoreCollision(Vector3 position, int layerMask)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		int num = 8388608;
		if ((layerMask & num) != 0 && Object.op_Implicit((Object)(object)TerrainMeta.Collision) && TerrainMeta.Collision.GetIgnore(position))
		{
			layerMask &= ~num;
		}
		int num2 = 16;
		if ((layerMask & num2) != 0 && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(position))
		{
			layerMask &= ~num2;
		}
		return layerMask;
	}

	public static void HandleIgnoreTerrain(ReadOnly<Vector3> positions, NativeArray<bool> hitIgnoreVolumes)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<float> values = default(NativeArray<float>);
		values..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
		FillJob<float> fillJob = default(FillJob<float>);
		fillJob.Values = values;
		fillJob.Value = 0.01f;
		FillJob<float> fillJob2 = fillJob;
		IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
		TerrainMeta.Collision.GetIgnore(positions, values.AsReadOnly(), hitIgnoreVolumes);
		values.Dispose();
	}

	public static void HandleIgnoreWater(ReadOnly<Vector3> positions, NativeArray<bool> hitIgnoreVolumes)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<float> values = default(NativeArray<float>);
		values..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
		FillJob<float> fillJob = default(FillJob<float>);
		fillJob.Values = values;
		fillJob.Value = 0.01f;
		FillJob<float> fillJob2 = fillJob;
		IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
		WaterSystem.Collision.GetIgnore(positions, values.AsReadOnly(), hitIgnoreVolumes);
		values.Dispose();
	}

	public static void HandleIgnoreCollision(ReadOnly<Vector3> positions, NativeArray<int> layerMasks, MasksToValidate validate = MasksToValidate.All)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (validate.HasFlag(MasksToValidate.Terrain))
		{
			NativeArray<bool> hitIgnoreVolumes = default(NativeArray<bool>);
			hitIgnoreVolumes..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
			HandleIgnoreTerrain(positions, hitIgnoreVolumes);
			RemoveLayerMaskJob removeLayerMaskJob = default(RemoveLayerMaskJob);
			removeLayerMaskJob.LayerMasks = layerMasks;
			removeLayerMaskJob.ShouldIgnore = hitIgnoreVolumes.AsReadOnly();
			removeLayerMaskJob.MaskToRemove = 8388608;
			RemoveLayerMaskJob removeLayerMaskJob2 = removeLayerMaskJob;
			IJobExtensions.RunByRef<RemoveLayerMaskJob>(ref removeLayerMaskJob2);
			hitIgnoreVolumes.Dispose();
		}
		if (validate.HasFlag(MasksToValidate.Water))
		{
			NativeArray<bool> hitIgnoreVolumes2 = default(NativeArray<bool>);
			hitIgnoreVolumes2..ctor(positions.Length, (Allocator)3, (NativeArrayOptions)0);
			HandleIgnoreWater(positions, hitIgnoreVolumes2);
			RemoveLayerMaskJob removeLayerMaskJob = default(RemoveLayerMaskJob);
			removeLayerMaskJob.LayerMasks = layerMasks;
			removeLayerMaskJob.ShouldIgnore = hitIgnoreVolumes2.AsReadOnly();
			removeLayerMaskJob.MaskToRemove = 16;
			RemoveLayerMaskJob removeLayerMaskJob3 = removeLayerMaskJob;
			IJobExtensions.RunByRef<RemoveLayerMaskJob>(ref removeLayerMaskJob3);
			hitIgnoreVolumes2.Dispose();
		}
	}

	public static void Sort(List<RaycastHit> hits)
	{
		hits.Sort((RaycastHit a, RaycastHit b) => ((RaycastHit)(ref a)).distance.CompareTo(((RaycastHit)(ref b)).distance));
	}

	public static void Sort(RaycastHit[] hits)
	{
		Array.Sort(hits, (RaycastHit a, RaycastHit b) => ((RaycastHit)(ref a)).distance.CompareTo(((RaycastHit)(ref b)).distance));
	}

	public static void Sort(NativeArray<RaycastHit> hits, int queryCount, int maxHitsPerQuery)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GamePhysics.Sort", 0);
		try
		{
			NativeArray<int> counts = new NativeArray<int>(queryCount, (Allocator)3, (NativeArrayOptions)0);
			CountRaycastHitsJobs countRaycastHitsJobs = default(CountRaycastHitsJobs);
			countRaycastHitsJobs.Counts = counts;
			countRaycastHitsJobs.Hits = hits.AsReadOnly();
			countRaycastHitsJobs.MaxHitsPerRay = maxHitsPerQuery;
			CountRaycastHitsJobs countRaycastHitsJobs2 = countRaycastHitsJobs;
			IJobExtensions.RunByRef<CountRaycastHitsJobs>(ref countRaycastHitsJobs2);
			for (int i = 0; i < counts.Length; i++)
			{
				int num = counts[i];
				if (num > 1)
				{
					SortJob<RaycastHit, RaycastHitComparer> val2 = NativeSortExtension.SortJob<RaycastHit, RaycastHitComparer>(hits.GetSubArray(i * maxHitsPerQuery, num), default(RaycastHitComparer));
					JobHandle val3 = default(JobHandle);
					val3 = val2.Schedule(val3);
					((JobHandle)(ref val3)).Complete();
				}
			}
			counts.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static int GetBatchSize(int count, int subdivideFactor = 4, int minBatchSize = 64)
	{
		return Math.Max(count / JobsUtility.JobWorkerCount / subdivideFactor, minBatchSize);
	}
}


public enum Realm
{
	Client,
	Server
}


using System;

[Flags]
public enum MasksToValidate : byte
{
	None = 0,
	Terrain = 1,
	Water = 2,
	All = 3
}


using EZhex1991.EZSoftBone;
using UnityEngine;

[RequireComponent(typeof(HitboxSystem))]
public class EZSoftBoneHitboxSystemCollider : EZSoftBoneColliderBase, IClientComponent
{
	public float radius = 2f;

	public override void Collide(ref Vector3 position, float spacing)
	{
	}
}


public class HitboxCollision : BaseCollision
{
}


using UnityEngine;

public class HitboxDefinition : MonoBehaviour
{
	public enum Type
	{
		BOX,
		CAPSULE
	}

	public Vector3 center;

	public Vector3 rotation;

	public Type type;

	public int priority;

	public PhysicMaterial physicMaterial;

	[SerializeField]
	private Vector3 scale = Vector3.one;

	public Vector3 Scale
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return scale;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			scale = new Vector3(Mathf.Abs(value.x), Mathf.Abs(value.y), Mathf.Abs(value.z));
		}
	}

	public Matrix4x4 LocalMatrix => Matrix4x4.TRS(center, Quaternion.Euler(rotation), scale);

	private void OnValidate()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Scale = Scale;
	}

	protected virtual void OnDrawGizmosSelected()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		switch (type)
		{
		case Type.BOX:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), scale);
			Gizmos.color = new Color(0f, 1f, 0f, 0.2f);
			Gizmos.DrawCube(Vector3.zero, Vector3.one);
			Gizmos.color = Color.green;
			Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		case Type.CAPSULE:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), Vector3.one);
			Gizmos.color = Color.green;
			GizmosUtil.DrawWireCapsuleY(Vector3.zero, scale.x, scale.y);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		}
	}

	protected virtual void OnDrawGizmos()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		switch (type)
		{
		case Type.BOX:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), scale);
			Gizmos.color = Color.black;
			Gizmos.DrawSphere(Vector3.zero, 0.005f);
			Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
			Gizmos.color = new Color(1f, 0f, 0f, 0.2f);
			Gizmos.DrawCube(Vector3.zero, Vector3.one);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		case Type.CAPSULE:
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.matrix *= Matrix4x4.TRS(center, Quaternion.Euler(rotation), Vector3.one);
			Gizmos.color = Color.black;
			Gizmos.DrawSphere(Vector3.zero, 0.005f);
			GizmosUtil.DrawWireCapsuleY(Vector3.zero, scale.x, scale.y);
			Gizmos.color = Color.white;
			Gizmos.matrix = Matrix4x4.identity;
			break;
		}
	}
}


public enum Type
{
	BOX,
	CAPSULE
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public class HitboxSystem : MonoBehaviour, IPrefabPreProcess
{
	[Serializable]
	public class HitboxShape
	{
		public Transform bone;

		public HitboxDefinition.Type type;

		public Matrix4x4 localTransform;

		public PhysicMaterial colliderMaterial;

		private Matrix4x4 transform;

		private Matrix4x4 inverseTransform;

		public Matrix4x4 Transform => transform;

		public Vector3 Position => ((Matrix4x4)(ref transform)).MultiplyPoint(Vector3.zero);

		public Quaternion Rotation => ((Matrix4x4)(ref transform)).rotation;

		public Vector3 Size { get; private set; }

		public void UpdateTransform()
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("HitboxSystem.UpdateTransform", 0);
			try
			{
				transform = bone.localToWorldMatrix * localTransform;
				Size = ((Matrix4x4)(ref transform)).lossyScale;
				transform = Matrix4x4.TRS(Position, Rotation, Vector3.one);
				inverseTransform = ((Matrix4x4)(ref transform)).inverse;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public Vector3 TransformPoint(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref transform)).MultiplyPoint(pt);
		}

		public Vector3 InverseTransformPoint(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref inverseTransform)).MultiplyPoint(pt);
		}

		public Vector3 TransformDirection(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref transform)).MultiplyVector(pt);
		}

		public Vector3 InverseTransformDirection(Vector3 pt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return ((Matrix4x4)(ref inverseTransform)).MultiplyVector(pt);
		}

		public bool Trace(Ray ray, out RaycastHit hit, float forgivness = 0f, float maxDistance = float.PositiveInfinity)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("Hitbox.Trace", 0);
			try
			{
				((Ray)(ref ray)).origin = InverseTransformPoint(((Ray)(ref ray)).origin);
				((Ray)(ref ray)).direction = InverseTransformDirection(((Ray)(ref ray)).direction);
				if (type == HitboxDefinition.Type.BOX)
				{
					AABB val2 = default(AABB);
					((AABB)(ref val2))..ctor(Vector3.zero, Size);
					if (!((AABB)(ref val2)).Trace(ray, ref hit, forgivness, maxDistance))
					{
						return false;
					}
				}
				else
				{
					Capsule val3 = default(Capsule);
					((Capsule)(ref val3))..ctor(Vector3.zero, Size.x, Size.y * 0.5f);
					if (!((Capsule)(ref val3)).Trace(ray, ref hit, forgivness, maxDistance))
					{
						return false;
					}
				}
				((RaycastHit)(ref hit)).point = TransformPoint(((RaycastHit)(ref hit)).point);
				((RaycastHit)(ref hit)).normal = TransformDirection(((RaycastHit)(ref hit)).normal);
				return true;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public Bounds GetBounds()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			Matrix4x4 val = Transform;
			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					((Matrix4x4)(ref val))[i, j] = Mathf.Abs(((Matrix4x4)(ref val))[i, j]);
				}
			}
			Bounds result = default(Bounds);
			Matrix4x4 val2 = Transform;
			((Bounds)(ref result)).center = ((Matrix4x4)(ref val2)).MultiplyPoint(Vector3.zero);
			((Bounds)(ref result)).extents = ((Matrix4x4)(ref val)).MultiplyVector(Size);
			return result;
		}
	}

	public List<HitboxShape> hitboxes = new List<HitboxShape>();

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		List<HitboxDefinition> list = Pool.Get<List<HitboxDefinition>>();
		((Component)this).GetComponentsInChildren<HitboxDefinition>(list);
		if (serverside)
		{
			foreach (HitboxDefinition item2 in list)
			{
				if (preProcess != null)
				{
					preProcess.RemoveComponent((Component)(object)item2);
				}
			}
			if (preProcess != null)
			{
				preProcess.RemoveComponent((Component)(object)this);
			}
		}
		if (clientside)
		{
			hitboxes.Clear();
			foreach (HitboxDefinition item3 in list.OrderBy((HitboxDefinition x) => x.priority))
			{
				HitboxShape item = new HitboxShape
				{
					bone = ((Component)item3).transform,
					localTransform = item3.LocalMatrix,
					colliderMaterial = item3.physicMaterial,
					type = item3.type
				};
				hitboxes.Add(item);
				if (preProcess != null)
				{
					preProcess.RemoveComponent((Component)(object)item3);
				}
			}
		}
		Pool.FreeUnmanaged<HitboxDefinition>(ref list);
	}
}


using System;
using UnityEngine;

[Serializable]
public class HitboxShape
{
	public Transform bone;

	public HitboxDefinition.Type type;

	public Matrix4x4 localTransform;

	public PhysicMaterial colliderMaterial;

	private Matrix4x4 transform;

	private Matrix4x4 inverseTransform;

	public Matrix4x4 Transform => transform;

	public Vector3 Position => ((Matrix4x4)(ref transform)).MultiplyPoint(Vector3.zero);

	public Quaternion Rotation => ((Matrix4x4)(ref transform)).rotation;

	public Vector3 Size { get; private set; }

	public void UpdateTransform()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("HitboxSystem.UpdateTransform", 0);
		try
		{
			transform = bone.localToWorldMatrix * localTransform;
			Size = ((Matrix4x4)(ref transform)).lossyScale;
			transform = Matrix4x4.TRS(Position, Rotation, Vector3.one);
			inverseTransform = ((Matrix4x4)(ref transform)).inverse;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Vector3 TransformPoint(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref transform)).MultiplyPoint(pt);
	}

	public Vector3 InverseTransformPoint(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref inverseTransform)).MultiplyPoint(pt);
	}

	public Vector3 TransformDirection(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref transform)).MultiplyVector(pt);
	}

	public Vector3 InverseTransformDirection(Vector3 pt)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((Matrix4x4)(ref inverseTransform)).MultiplyVector(pt);
	}

	public bool Trace(Ray ray, out RaycastHit hit, float forgivness = 0f, float maxDistance = float.PositiveInfinity)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Hitbox.Trace", 0);
		try
		{
			((Ray)(ref ray)).origin = InverseTransformPoint(((Ray)(ref ray)).origin);
			((Ray)(ref ray)).direction = InverseTransformDirection(((Ray)(ref ray)).direction);
			if (type == HitboxDefinition.Type.BOX)
			{
				AABB val2 = default(AABB);
				((AABB)(ref val2))..ctor(Vector3.zero, Size);
				if (!((AABB)(ref val2)).Trace(ray, ref hit, forgivness, maxDistance))
				{
					return false;
				}
			}
			else
			{
				Capsule val3 = default(Capsule);
				((Capsule)(ref val3))..ctor(Vector3.zero, Size.x, Size.y * 0.5f);
				if (!((Capsule)(ref val3)).Trace(ray, ref hit, forgivness, maxDistance))
				{
					return false;
				}
			}
			((RaycastHit)(ref hit)).point = TransformPoint(((RaycastHit)(ref hit)).point);
			((RaycastHit)(ref hit)).normal = TransformDirection(((RaycastHit)(ref hit)).normal);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Bounds GetBounds()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 val = Transform;
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				((Matrix4x4)(ref val))[i, j] = Mathf.Abs(((Matrix4x4)(ref val))[i, j]);
			}
		}
		Bounds result = default(Bounds);
		Matrix4x4 val2 = Transform;
		((Bounds)(ref result)).center = ((Matrix4x4)(ref val2)).MultiplyPoint(Vector3.zero);
		((Bounds)(ref result)).extents = ((Matrix4x4)(ref val)).MultiplyVector(Size);
		return result;
	}
}


using UnityEngine;

public class Buttons
{
	public class ConButton : IConsoleButton
	{
		private int frame;

		private TimeSince _timePressed;

		public bool IsDown { get; set; }

		public TimeSince TimePressed
		{
			get
			{
				//IL_0014: Unknown result type (might be due to invalid IL or missing references)
				//IL_000d: Unknown result type (might be due to invalid IL or missing references)
				if (!IsDown)
				{
					return TimeSince.op_Implicit(0f);
				}
				return _timePressed;
			}
		}

		public bool JustPressed
		{
			get
			{
				if (IsDown)
				{
					return frame == Time.frameCount;
				}
				return false;
			}
		}

		public bool JustReleased
		{
			get
			{
				if (!IsDown)
				{
					return frame == Time.frameCount;
				}
				return false;
			}
		}

		public bool IsPressed
		{
			get
			{
				return IsDown;
			}
			set
			{
				//IL_0022: Unknown result type (might be due to invalid IL or missing references)
				//IL_0027: Unknown result type (might be due to invalid IL or missing references)
				if (value != IsDown)
				{
					IsDown = value;
					frame = Time.frameCount;
					_timePressed = TimeSince.op_Implicit(0f);
				}
			}
		}

		public void Call(Arg arg)
		{
		}
	}
}


using UnityEngine;

public class ConButton : IConsoleButton
{
	private int frame;

	private TimeSince _timePressed;

	public bool IsDown { get; set; }

	public TimeSince TimePressed
	{
		get
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			if (!IsDown)
			{
				return TimeSince.op_Implicit(0f);
			}
			return _timePressed;
		}
	}

	public bool JustPressed
	{
		get
		{
			if (IsDown)
			{
				return frame == Time.frameCount;
			}
			return false;
		}
	}

	public bool JustReleased
	{
		get
		{
			if (!IsDown)
			{
				return frame == Time.frameCount;
			}
			return false;
		}
	}

	public bool IsPressed
	{
		get
		{
			return IsDown;
		}
		set
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			if (value != IsDown)
			{
				IsDown = value;
				frame = Time.frameCount;
				_timePressed = TimeSince.op_Implicit(0f);
			}
		}
	}

	public void Call(Arg arg)
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[Factory("meta")]
public class Meta : ConsoleSystem
{
	[ServerVar(Clientside = true, Help = "add <convar> <amount> - adds amount to convar")]
	public static void add(Arg args)
	{
		string @string = args.GetString(0, "");
		float @float = args.GetFloat(1, 0.1f);
		Command val = Find(@string);
		float result;
		if (val == null)
		{
			args.ReplyWith("Convar not found: " + (@string ?? "<null>"));
		}
		else if (args.IsClientside && val.Replicated)
		{
			args.ReplyWith("Cannot set replicated convars from the client (use sv to do this)");
		}
		else if (args.IsServerside && val.ServerAdmin && !args.IsAdmin)
		{
			args.ReplyWith("Permission denied");
		}
		else if (!float.TryParse(val.String, out result))
		{
			args.ReplyWith("Convar value cannot be parsed as a number");
		}
		else
		{
			val.Set(result + @float);
		}
	}

	[ClientVar(Help = "if_true <command> <condition> - runs a command if the condition is true")]
	public static void if_true(Arg args)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		bool @bool = args.GetBool(1, false);
		if (@bool)
		{
			ConsoleSystem.Run(Option.Client, @string, new object[1] { @bool });
		}
	}

	[ClientVar(Help = "if_false <command> <condition> - runs a command if the condition is false")]
	public static void if_false(Arg args)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		bool @bool = args.GetBool(1, true);
		if (!@bool)
		{
			ConsoleSystem.Run(Option.Client, @string, new object[1] { @bool });
		}
	}

	[ClientVar(Help = "reset_cycle <key> - resets a cycled bind to the beginning")]
	public static void reset_cycle(Arg args)
	{
		string @string = args.GetString(0, "");
		List<KeyCode> list = default(List<KeyCode>);
		KeyCombos.TryParse(ref @string, ref list);
		Button button = Input.GetButton(@string);
		if (button == null)
		{
			args.ReplyWith("Button not found");
		}
		else if (!button.Cycle)
		{
			args.ReplyWith("Button does not have a cycled bind");
		}
		else
		{
			button.CycleIndex = 0;
		}
	}

	[ClientVar(Help = "exec [command_1] ... - runs all of the commands passed as arguments (also, if the last argument is true/false then that will flow into each command's arguments)")]
	public static void exec(Arg args)
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		List<string> list = Pool.Get<List<string>>();
		for (int i = 0; i < 32; i++)
		{
			string @string = args.GetString(i, "");
			if (string.IsNullOrWhiteSpace(@string))
			{
				break;
			}
			list.Add(@string);
		}
		if (list.Count > 0)
		{
			string text = null;
			string text2 = list[list.Count - 1];
			if (bool.TryParse(text2, out var _))
			{
				text = text2;
				list.RemoveAt(list.Count - 1);
			}
			foreach (string item in list)
			{
				if (text != null)
				{
					ConsoleSystem.Run(Option.Client, item, new object[1] { text });
				}
				else
				{
					ConsoleSystem.Run(Option.Client, item, Array.Empty<object>());
				}
			}
		}
		Pool.FreeUnmanaged<string>(ref list);
	}

	private static Command Find(string name)
	{
		Command val = Server.Find(name);
		if (val != null)
		{
			return val;
		}
		return null;
	}
}


using System;
using System.Runtime.InteropServices;

public static class WindowsAffinityShim
{
	[DllImport("kernel32.dll")]
	public static extern bool SetProcessAffinityMask(IntPtr process, IntPtr mask);

	[DllImport("kernel32.dll")]
	public static extern bool SetPriorityClass(IntPtr process, uint mask);
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public class ArticulatedOccludee : BaseMonoBehaviour
{
	private const float UpdateBoundsFadeStart = 20f;

	private const float UpdateBoundsFadeLength = 1000f;

	private const float UpdateBoundsMaxFrequency = 15f;

	private const float UpdateBoundsMinFrequency = 0.5f;

	private LODGroup lodGroup;

	public List<Collider> colliders = new List<Collider>();

	private OccludeeSphere localOccludee = new OccludeeSphere(-1);

	private List<Renderer> renderers = new List<Renderer>();

	private bool isVisible = true;

	private Action TriggerUpdateVisibilityBoundsDelegate;

	public bool IsVisible => isVisible;

	protected virtual void OnDisable()
	{
		if (!Application.isQuitting)
		{
			UnregisterFromCulling();
			ClearVisibility();
		}
	}

	private void ClearVisibility()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)lodGroup != (Object)null)
		{
			lodGroup.localReferencePoint = Vector3.zero;
			lodGroup.RecalculateBounds();
			lodGroup = null;
		}
		if (renderers != null)
		{
			renderers.Clear();
		}
		localOccludee = new OccludeeSphere(-1);
	}

	public void ProcessVisibility(LODGroup lod)
	{
		lodGroup = lod;
		if ((Object)(object)lod != (Object)null)
		{
			renderers = new List<Renderer>(16);
			LOD[] lODs = lod.GetLODs();
			for (int i = 0; i < lODs.Length; i++)
			{
				Renderer[] array = lODs[i].renderers;
				foreach (Renderer val in array)
				{
					if ((Object)(object)val != (Object)null)
					{
						renderers.Add(val);
					}
				}
			}
		}
		UpdateCullingBounds();
	}

	private void RegisterForCulling(OcclusionCulling.Sphere sphere, bool visible)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (localOccludee.IsRegistered)
		{
			UnregisterFromCulling();
		}
		int num = OcclusionCulling.RegisterOccludee(sphere.position, sphere.radius, visible, 0.25f, isStatic: false, ((Component)this).gameObject.layer, OnVisibilityChanged);
		if (num >= 0)
		{
			localOccludee = new OccludeeSphere(num, localOccludee.sphere);
			return;
		}
		localOccludee.Invalidate();
		Debug.LogWarning((object)("[OcclusionCulling] Occludee registration failed for " + ((Object)this).name + ". Too many registered."));
	}

	private void UnregisterFromCulling()
	{
		if (localOccludee.IsRegistered)
		{
			OcclusionCulling.UnregisterOccludee(localOccludee.id);
			localOccludee.Invalidate();
		}
	}

	public void UpdateCullingBounds()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0315: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		Vector3 val2 = Vector3.zero;
		bool flag = false;
		int num = ((renderers != null) ? renderers.Count : 0);
		int num2 = ((colliders != null) ? colliders.Count : 0);
		if (num > 0 && (num2 == 0 || num < num2))
		{
			for (int i = 0; i < renderers.Count; i++)
			{
				if (renderers[i].isVisible)
				{
					Bounds bounds = renderers[i].bounds;
					Vector3 min = ((Bounds)(ref bounds)).min;
					Vector3 max = ((Bounds)(ref bounds)).max;
					if (!flag)
					{
						val = min;
						val2 = max;
						flag = true;
						continue;
					}
					val.x = ((val.x < min.x) ? val.x : min.x);
					val.y = ((val.y < min.y) ? val.y : min.y);
					val.z = ((val.z < min.z) ? val.z : min.z);
					val2.x = ((val2.x > max.x) ? val2.x : max.x);
					val2.y = ((val2.y > max.y) ? val2.y : max.y);
					val2.z = ((val2.z > max.z) ? val2.z : max.z);
				}
			}
		}
		if (!flag && num2 > 0)
		{
			flag = true;
			Bounds bounds2 = colliders[0].bounds;
			val = ((Bounds)(ref bounds2)).min;
			bounds2 = colliders[0].bounds;
			val2 = ((Bounds)(ref bounds2)).max;
			for (int j = 1; j < colliders.Count; j++)
			{
				Bounds bounds3 = colliders[j].bounds;
				Vector3 min2 = ((Bounds)(ref bounds3)).min;
				Vector3 max2 = ((Bounds)(ref bounds3)).max;
				val.x = ((val.x < min2.x) ? val.x : min2.x);
				val.y = ((val.y < min2.y) ? val.y : min2.y);
				val.z = ((val.z < min2.z) ? val.z : min2.z);
				val2.x = ((val2.x > max2.x) ? val2.x : max2.x);
				val2.y = ((val2.y > max2.y) ? val2.y : max2.y);
				val2.z = ((val2.z > max2.z) ? val2.z : max2.z);
			}
		}
		if (!flag)
		{
			return;
		}
		Vector3 val3 = val2 - val;
		Vector3 position = val + val3 * 0.5f;
		float radius = Mathf.Max(Mathf.Max(val3.x, val3.y), val3.z) * 0.5f;
		OcclusionCulling.Sphere sphere = new OcclusionCulling.Sphere(position, radius);
		if (localOccludee.IsRegistered)
		{
			OcclusionCulling.UpdateDynamicOccludee(localOccludee.id, sphere.position, sphere.radius);
			localOccludee.sphere = sphere;
			return;
		}
		bool visible = true;
		if ((Object)(object)lodGroup != (Object)null)
		{
			visible = lodGroup.enabled;
		}
		RegisterForCulling(sphere, visible);
	}

	protected virtual bool CheckVisibility()
	{
		if (localOccludee.state != null)
		{
			return localOccludee.state.isVisible;
		}
		return true;
	}

	private void ApplyVisibility(bool vis)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)lodGroup != (Object)null)
		{
			float num = ((!vis) ? 100000 : 0);
			if (num != lodGroup.localReferencePoint.x)
			{
				lodGroup.localReferencePoint = new Vector3(num, num, num);
			}
		}
	}

	protected virtual void OnVisibilityChanged(bool visible)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)MainCamera.mainCamera != (Object)null && localOccludee.IsRegistered)
		{
			float dist = Vector3.Distance(MainCamera.position, ((Component)this).transform.position);
			VisUpdateUsingCulling(dist, visible);
			ApplyVisibility(isVisible);
		}
	}

	private void UpdateVisibility(float delay)
	{
	}

	private void VisUpdateUsingCulling(float dist, bool visibility)
	{
	}

	public virtual void TriggerUpdateVisibilityBounds()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (((Behaviour)this).enabled)
		{
			Vector3 val = ((Component)this).transform.position - MainCamera.position;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			float num = 400f;
			float num2;
			if (sqrMagnitude < num)
			{
				num2 = 1f / Random.Range(5f, 25f);
			}
			else
			{
				float num3 = Mathf.Clamp01((Mathf.Sqrt(sqrMagnitude) - 20f) * 0.001f);
				float num4 = Mathf.Lerp(1f / 15f, 2f, num3);
				num2 = Random.Range(num4, num4 + 1f / 15f);
			}
			UpdateVisibility(num2);
			ApplyVisibility(isVisible);
			if (TriggerUpdateVisibilityBoundsDelegate == null)
			{
				TriggerUpdateVisibilityBoundsDelegate = TriggerUpdateVisibilityBounds;
			}
			((FacepunchBehaviour)this).Invoke(TriggerUpdateVisibilityBoundsDelegate, num2);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public static class DamageUtil
{
	public static void RadiusDamage(BaseEntity attackingPlayer, BaseEntity weaponPrefab, Vector3 pos, float minradius, float radius, List<DamageTypeEntry> damage, int layers, bool useLineOfSight, bool ignoreAI = false, bool ignoreAttackingPlayer = false, bool extendedLineOfSight = false, List<DamageTypeEntry> playerDamage = null, bool removeWallpaper = false)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("DamageUtil.RadiusDamage", 0);
		try
		{
			List<HitInfo> list = Pool.Get<List<HitInfo>>();
			List<BaseEntity> list2 = Pool.Get<List<BaseEntity>>();
			List<BaseEntity> list3 = Pool.Get<List<BaseEntity>>();
			Vis.Entities(pos, radius, list3, layers, (QueryTriggerInteraction)2);
			for (int i = 0; i < list3.Count; i++)
			{
				BaseEntity baseEntity = list3[i];
				if (!baseEntity.isServer || list2.Contains(baseEntity) || (ignoreAI && IsIgnoredAI(baseEntity)))
				{
					continue;
				}
				Vector3 val2 = baseEntity.ClosestPoint(pos);
				float num = Mathf.Clamp01((Vector3.Distance(val2, pos) - minradius) / (radius - minradius));
				if (num > 1f)
				{
					continue;
				}
				float amount = 1f - num;
				if (removeWallpaper && baseEntity is BuildingBlock buildingBlock)
				{
					buildingBlock.RemoveWallpaper(0);
					buildingBlock.RemoveWallpaper(1);
				}
				if ((!extendedLineOfSight || GamePhysics.LineOfSight(baseEntity.CenterPoint(), pos, 1218519041, baseEntity)) && (!useLineOfSight || baseEntity.IsVisible(pos)))
				{
					HitInfo hitInfo = new HitInfo();
					hitInfo.Initiator = attackingPlayer;
					hitInfo.WeaponPrefab = weaponPrefab;
					if (playerDamage != null && playerDamage.Count > 0 && baseEntity is BasePlayer)
					{
						hitInfo.damageTypes.Add(playerDamage);
					}
					else
					{
						hitInfo.damageTypes.Add(damage);
					}
					hitInfo.damageTypes.ScaleAll(amount);
					hitInfo.HitPositionWorld = val2;
					Vector3 val3 = pos - val2;
					hitInfo.HitNormalWorld = ((Vector3)(ref val3)).normalized;
					hitInfo.PointStart = pos;
					hitInfo.PointEnd = hitInfo.HitPositionWorld;
					list.Add(hitInfo);
					list2.Add(baseEntity);
				}
			}
			for (int j = 0; j < list2.Count; j++)
			{
				BaseEntity baseEntity2 = list2[j];
				HitInfo info = list[j];
				if (!ignoreAttackingPlayer || !((Object)(object)attackingPlayer != (Object)null) || !baseEntity2.EqualNetID((BaseNetworkable)attackingPlayer))
				{
					baseEntity2.OnAttacked(info);
				}
			}
			Pool.FreeUnmanaged<HitInfo>(ref list);
			Pool.FreeUnmanaged<BaseEntity>(ref list2);
			Pool.FreeUnmanaged<BaseEntity>(ref list3);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static bool IsIgnoredAI(BaseEntity ent)
	{
		return ent is ScientistNPC;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class CinematicEntity : BaseEntity
{
	[Serializable]
	public struct DisableGroup
	{
		public GameObject[] gameObjects;
	}

	private const Flags HideMesh = Flags.Reserved1;

	private const Flags HideMesh2 = Flags.Reserved2;

	private const Flags HideMesh3 = Flags.Reserved3;

	private const Flags HideMesh4 = Flags.Reserved4;

	public List<DisableGroup> DisableObjects;

	private static List<CinematicEntity> serverList = new List<CinematicEntity>();

	public override void ServerInit()
	{
		base.ServerInit();
		if (!serverList.Contains(this))
		{
			serverList.Add(this);
		}
	}

	[ServerVar(Help = "Hides cinematic entities by group (0= none, 1= lights, 2= BGs, 3= props, 4= misc)")]
	public static void HideObjects(Arg args)
	{
		HideObjectShared(args, serverList);
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer && serverList.Contains(this))
		{
			serverList.Remove(this);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool state = !HasFlag(Flags.Reserved1) && !HasFlag(Flags.Reserved2) && !HasFlag(Flags.Reserved3) && !HasFlag(Flags.Reserved4);
		ToggleObjects(state);
	}

	private void ToggleObjects(bool state)
	{
		for (int i = 0; i < DisableObjects.Count; i++)
		{
			DisableGroup disableGroup = DisableObjects[i];
			bool active = state;
			if (!state)
			{
				int f = 1 << 7 + i;
				active = !HasFlag((Flags)f);
			}
			GameObject[] gameObjects = disableGroup.gameObjects;
			for (int j = 0; j < gameObjects.Length; j++)
			{
				gameObjects[j].SetActive(active);
			}
		}
	}

	public static void HideObjectShared(Arg args, List<CinematicEntity> entList)
	{
		if (args.GetString(0, "") == "")
		{
			return;
		}
		List<int> list = new List<int>();
		if (args.GetInt(0, 0) != 0)
		{
			for (int i = 0; i < 4 && !(args.GetString(i, "") == ""); i++)
			{
				int @int = args.GetInt(i, 0);
				if (@int == 0)
				{
					break;
				}
				list.Add(@int - 1);
			}
		}
		foreach (CinematicEntity ent in entList)
		{
			for (int j = 0; j < 4; j++)
			{
				int f = 1 << 7 + j;
				ent.SetFlag((Flags)f, list.Contains(j));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct DisableGroup
{
	public GameObject[] gameObjects;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch.Rust;
using Network;
using UnityEngine;
using UnityEngine.SceneManagement;

[Factory("global")]
public class DiagnosticsConSys : ConsoleSystem
{
	private static void DumpAnimators(string targetFolder)
	{
		Animator[] array = Object.FindObjectsOfType<Animator>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All animators");
		stringBuilder.AppendLine();
		Animator[] array2 = array;
		foreach (Animator val in array2)
		{
			stringBuilder.AppendFormat("{1}\t{0}", ((Component)val).transform.GetRecursiveName(), ((Behaviour)val).enabled);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Animators.List.txt", stringBuilder.ToString());
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("All animators - grouped by object name");
		stringBuilder2.AppendLine();
		foreach (IGrouping<string, Animator> item in from x in array
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder2.AppendFormat("{1:N0}\t{0}", ((Component)item.First()).transform.GetRecursiveName(), item.Count());
			stringBuilder2.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Animators.Counts.txt", stringBuilder2.ToString());
		StringBuilder stringBuilder3 = new StringBuilder();
		stringBuilder3.AppendLine("All animators - grouped by enabled/disabled");
		stringBuilder3.AppendLine();
		foreach (IGrouping<string, Animator> item2 in from x in array
			group x by ((Component)x).transform.GetRecursiveName(((Behaviour)x).enabled ? "" : " (DISABLED)") into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder3.AppendFormat("{1:N0}\t{0}", ((Component)item2.First()).transform.GetRecursiveName(((Behaviour)item2.First()).enabled ? "" : " (DISABLED)"), item2.Count());
			stringBuilder3.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Animators.Counts.Enabled.txt", stringBuilder3.ToString());
	}

	[ClientVar]
	[ServerVar]
	public static void dump(Arg args)
	{
		if (Directory.Exists("diagnostics"))
		{
			Directory.CreateDirectory("diagnostics");
		}
		int num = 1;
		while (Directory.Exists("diagnostics/" + num))
		{
			num++;
		}
		Directory.CreateDirectory("diagnostics/" + num);
		string targetFolder = "diagnostics/" + num + "/";
		DumpLODGroups(targetFolder);
		DumpSystemInformation(targetFolder);
		for (int i = 0; i < SceneManager.sceneCount; i++)
		{
			DumpSceneGameObjects(targetFolder, i);
		}
		DumpAllGameObjects(targetFolder);
		DumpObjects(targetFolder);
		DumpEntities(targetFolder);
		DumpNetwork(targetFolder);
		DumpPhysics(targetFolder);
		DumpAnimators(targetFolder);
		DumpWarmup(targetFolder);
	}

	private static void DumpSystemInformation(string targetFolder)
	{
		WriteTextToFile(targetFolder + "System.Info.txt", SystemInfoGeneralText.currentInfo);
	}

	private static void WriteTextToFile(string file, string text)
	{
		File.WriteAllText(file, text);
	}

	private static void DumpEntities(string targetFolder)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All entities");
		stringBuilder.AppendLine();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				stringBuilder.AppendFormat("{1}\t{0}", current.PrefabName, ((NetworkableId)(((??)current.net?.ID) ?? default(NetworkableId))).Value);
				stringBuilder.AppendLine();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Entity.SV.List.txt", stringBuilder.ToString());
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("All entities");
		stringBuilder2.AppendLine();
		foreach (IGrouping<uint, BaseNetworkable> item in from x in BaseNetworkable.serverEntities
			group x by x.prefabID into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder2.AppendFormat("{1:N0}\t{0}", item.First().PrefabName, item.Count());
			stringBuilder2.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Entity.SV.Counts.txt", stringBuilder2.ToString());
		StringBuilder stringBuilder3 = new StringBuilder();
		stringBuilder3.AppendLine("Saved entities");
		stringBuilder3.AppendLine();
		foreach (IGrouping<uint, BaseEntity> item2 in from x in BaseEntity.saveList
			group x by x.prefabID into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder3.AppendFormat("{1:N0}\t{0}", item2.First().PrefabName, item2.Count());
			stringBuilder3.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Entity.SV.Savelist.Counts.txt", stringBuilder3.ToString());
	}

	private static void DumpLODGroups(string targetFolder)
	{
		DumpLODGroupTotals(targetFolder);
	}

	private static void DumpLODGroupTotals(string targetFolder)
	{
		LODGroup[] source = Object.FindObjectsOfType<LODGroup>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("LODGroups");
		stringBuilder.AppendLine();
		foreach (IGrouping<string, LODGroup> item in from x in source
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", item.Key, item.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "LODGroups.Objects.txt", stringBuilder.ToString());
	}

	private static void DumpNetwork(string targetFolder)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (!((BaseNetwork)Net.sv).IsConnected())
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Server Network Statistics");
		stringBuilder.AppendLine();
		stringBuilder.Append(((BaseNetwork)Net.sv).GetDebug((Connection)null).Replace("\n", "\r\n"));
		stringBuilder.AppendLine();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				stringBuilder.AppendLine("Name: " + current.displayName);
				stringBuilder.AppendLine("SteamID: " + current.userID.Get());
				stringBuilder.Append((current.net == null) ? "INVALID - NET IS NULL" : ((BaseNetwork)Net.sv).GetDebug(current.net.connection).Replace("\n", "\r\n"));
				stringBuilder.AppendLine();
				stringBuilder.AppendLine();
				stringBuilder.AppendLine();
				stringBuilder.AppendLine();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		WriteTextToFile(targetFolder + "Network.Server.txt", stringBuilder.ToString());
	}

	private static void DumpObjects(string targetFolder)
	{
		Object[] array = Object.FindObjectsOfType<Object>();
		Object[] array2 = Object.FindObjectsOfType<Object>(true);
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All active UnityEngine.Object, ordered by count");
		stringBuilder.AppendLine($"Total: {array.Length}");
		stringBuilder.AppendLine();
		foreach (IGrouping<Type, Object> item in from x in array
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((object)item.First()).GetType().Name, item.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object.Count.txt", stringBuilder.ToString());
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("All active + inactive UnityEngine.Object, ordered by count");
		stringBuilder2.AppendLine($"Total: {array2.Length}");
		stringBuilder2.AppendLine();
		foreach (IGrouping<Type, Object> item2 in from x in array2
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder2.AppendFormat("{1:N0}\t{0}", ((object)item2.First()).GetType().Name, item2.Count());
			stringBuilder2.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object_All.Count.txt", stringBuilder2.ToString());
		StringBuilder stringBuilder3 = new StringBuilder();
		stringBuilder3.AppendLine("All active + inactive UnityEngine.Object, ordered by count");
		stringBuilder3.AppendLine($"Total: {array.Length}");
		stringBuilder3.AppendLine();
		foreach (IGrouping<Type, Object> item3 in from x in array
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder3.AppendFormat("{1:N0}\t{0}", ((object)item3.First()).GetType().Name, item3.Count());
			stringBuilder3.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object.Count.txt", stringBuilder3.ToString());
		StringBuilder stringBuilder4 = new StringBuilder();
		stringBuilder4.AppendLine("All active UnityEngine.ScriptableObject, ordered by count");
		stringBuilder4.AppendLine();
		foreach (IGrouping<Type, Object> item4 in from x in array
			where x is ScriptableObject
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder4.AppendFormat("{1:N0}\t{0}", ((object)item4.First()).GetType().Name, item4.Count());
			stringBuilder4.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.ScriptableObject.Count.txt", stringBuilder4.ToString());
	}

	private static void DumpPhysics(string targetFolder)
	{
		DumpTotals(targetFolder);
		DumpColliders(targetFolder);
		DumpRigidBodies(targetFolder);
	}

	private static void DumpTotals(string targetFolder)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Physics Information");
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Total Colliders:\t{0:N0}", Object.FindObjectsOfType<Collider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Active Colliders:\t{0:N0}", (from x in Object.FindObjectsOfType<Collider>()
			where x.enabled
			select x).Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Total RigidBodys:\t{0:N0}", Object.FindObjectsOfType<Rigidbody>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Mesh Colliders:\t{0:N0}", Object.FindObjectsOfType<MeshCollider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Box Colliders:\t{0:N0}", Object.FindObjectsOfType<BoxCollider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Sphere Colliders:\t{0:N0}", Object.FindObjectsOfType<SphereCollider>().Count());
		stringBuilder.AppendLine();
		stringBuilder.AppendFormat("Capsule Colliders:\t{0:N0}", Object.FindObjectsOfType<CapsuleCollider>().Count());
		stringBuilder.AppendLine();
		WriteTextToFile(targetFolder + "Physics.txt", stringBuilder.ToString());
	}

	private static void DumpColliders(string targetFolder)
	{
		Collider[] source = Object.FindObjectsOfType<Collider>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Physics Colliders");
		stringBuilder.AppendLine();
		foreach (IGrouping<string, Collider> item in from x in source
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0} ({2:N0} triggers) ({3:N0} enabled)", item.Key, item.Count(), item.Count((Collider x) => x.isTrigger), item.Count((Collider x) => x.enabled));
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "Physics.Colliders.Objects.txt", stringBuilder.ToString());
	}

	private static void DumpRigidBodies(string targetFolder)
	{
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody[] source = Object.FindObjectsOfType<Rigidbody>();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("RigidBody");
		stringBuilder.AppendLine();
		StringBuilder stringBuilder2 = new StringBuilder();
		stringBuilder2.AppendLine("RigidBody");
		stringBuilder2.AppendLine();
		foreach (IGrouping<string, Rigidbody> item in from x in source
			group x by ((Component)x).transform.GetRecursiveName() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0} ({2:N0} awake) ({3:N0} kinematic) ({4:N0} non-discrete)", item.Key, item.Count(), item.Count((Rigidbody x) => !x.IsSleeping()), item.Count((Rigidbody x) => x.isKinematic), item.Count((Rigidbody x) => (int)x.collisionDetectionMode > 0));
			stringBuilder.AppendLine();
			foreach (Rigidbody item2 in item)
			{
				stringBuilder2.AppendFormat("{0} -{1}{2}{3}", item.Key, item2.isKinematic ? " KIN" : "", item2.IsSleeping() ? " SLEEP" : "", item2.useGravity ? " GRAVITY" : "");
				stringBuilder2.AppendLine();
				stringBuilder2.AppendFormat("Mass: {0}\tVelocity: {1}\tsleepThreshold: {2}", item2.mass, item2.velocity, item2.sleepThreshold);
				stringBuilder2.AppendLine();
				stringBuilder2.AppendLine();
			}
		}
		WriteTextToFile(targetFolder + "Physics.RigidBody.Objects.txt", stringBuilder.ToString());
		WriteTextToFile(targetFolder + "Physics.RigidBody.All.txt", stringBuilder2.ToString());
	}

	private static string GetOutputDirectoryForScene(string targetFolder, int sceneIndex, Scene scene)
	{
		string arg = ((Scene)(ref scene)).name.Replace("\\", "_").Replace("/", "_").Replace(" ", "_");
		targetFolder = Path.Combine(targetFolder, "Scenes", $"{sceneIndex}_{arg}/");
		Directory.CreateDirectory(targetFolder);
		return targetFolder;
	}

	private static void DumpSceneGameObjects(string targetFolder, int sceneIndex)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Scene sceneAt = SceneManager.GetSceneAt(sceneIndex);
		Transform[] rootObjects = (from x in ((Scene)(ref sceneAt)).GetRootGameObjects()
			select x.transform).ToArray();
		targetFolder = GetOutputDirectoryForScene(targetFolder, sceneIndex, sceneAt);
		DumpGameObjects(targetFolder, rootObjects);
	}

	private static void DumpAllGameObjects(string targetFolder)
	{
		Transform[] rootObjects = TransformUtil.GetRootObjects();
		DumpGameObjects(targetFolder, rootObjects);
	}

	private static void DumpGameObjects(string targetFolder, Transform[] rootObjects)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All active game objects");
		stringBuilder.AppendLine();
		Transform[] array = rootObjects;
		foreach (Transform tx in array)
		{
			DumpGameObjectRecursive(stringBuilder, tx, 0);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Hierarchy.txt", stringBuilder.ToString());
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All active game objects including components");
		stringBuilder.AppendLine();
		array = rootObjects;
		foreach (Transform tx2 in array)
		{
			DumpGameObjectRecursive(stringBuilder, tx2, 0, includeComponents: true);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Hierarchy.Components.txt", stringBuilder.ToString());
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Root gameobjects, grouped by name, ordered by the total number of objects excluding children");
		stringBuilder.AppendLine();
		foreach (IGrouping<string, Transform> item in from x in rootObjects
			group x by ((Object)x).name into x
			orderby x.Count() descending
			select x)
		{
			Transform val = item.First();
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((Object)val).name, item.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Count.txt", stringBuilder.ToString());
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Root gameobjects, grouped by name, ordered by the total number of objects including children");
		stringBuilder.AppendLine();
		foreach (KeyValuePair<Transform, int> item2 in from x in rootObjects
			group x by ((Object)x).name into x
			select new KeyValuePair<Transform, int>(x.First(), x.Sum((Transform y) => y.GetAllChildren().Count)) into x
			orderby x.Value descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((Object)item2.Key).name, item2.Value);
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "GameObject.Count.Children.txt", stringBuilder.ToString());
		Component[] source = (from x in rootObjects.SelectMany((Transform x) => ((Component)x).GetComponentsInChildren<Component>(true))
			where (Object)(object)x != (Object)null
			select x).ToArray();
		Object[] array2 = source.Select((Component x) => x.gameObject).Distinct().ToArray()
			.OfType<Object>()
			.Concat(source.OfType<Object>())
			.ToArray();
		stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("All UnityEngine.Object active + inactive, ordered by count");
		stringBuilder.AppendLine($"Total: {array2.Length}");
		foreach (IGrouping<Type, Object> item3 in from x in array2
			group x by ((object)x).GetType() into x
			orderby x.Count() descending
			select x)
		{
			stringBuilder.AppendFormat("{1:N0}\t{0}", ((object)item3.First()).GetType().Name, item3.Count());
			stringBuilder.AppendLine();
		}
		WriteTextToFile(targetFolder + "UnityEngine.Object.Count.txt", stringBuilder.ToString());
	}

	private static void DumpGameObjectRecursive(StringBuilder str, Transform tx, int indent, bool includeComponents = false)
	{
		if ((Object)(object)tx == (Object)null)
		{
			return;
		}
		str.Append(' ', indent);
		str.Append(((Component)tx).gameObject.activeSelf ? "+ " : "- ");
		str.Append(((Object)tx).name);
		str.Append(" [").Append(((Component)tx).GetComponents<Component>().Length - 1).Append(']');
		str.AppendLine();
		if (includeComponents)
		{
			Component[] components = ((Component)tx).GetComponents<Component>();
			foreach (Component val in components)
			{
				if (!(val is Transform))
				{
					str.Append(' ', indent + 3);
					bool? flag = val.IsEnabled();
					if (!flag.HasValue)
					{
						str.Append("[~] ");
					}
					else if (flag == true)
					{
						str.Append("[] ");
					}
					else
					{
						str.Append("[ ] ");
					}
					str.Append(((Object)(object)val == (Object)null) ? "NULL" : ((object)val).GetType().ToString());
					str.AppendLine();
				}
			}
		}
		for (int j = 0; j < tx.childCount; j++)
		{
			DumpGameObjectRecursive(str, tx.GetChild(j), indent + 4, includeComponents);
		}
	}

	private static void DumpWarmup(string targetFolder)
	{
		DumpWarmupTimings(targetFolder);
		DumpWorldSpawnTimings(targetFolder);
	}

	private static void DumpWarmupTimings(string targetFolder)
	{
		if (!FileSystem_Warmup.GetWarmupTimes().Any())
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("index,prefab,time");
		int num = 0;
		foreach (var warmupTime in FileSystem_Warmup.GetWarmupTimes())
		{
			object arg = num;
			var (arg2, timeSpan) = warmupTime;
			stringBuilder.AppendLine($"{arg},{arg2},{timeSpan.Ticks * EventRecord.TicksToNS}");
			num++;
		}
		WriteTextToFile(targetFolder + "Asset.Warmup.csv", stringBuilder.ToString());
	}

	private static void DumpWorldSpawnTimings(string targetFolder)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (!World.GetSpawnTimings().Any())
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("index,prefab,time,category,position,rotation");
		int num = 0;
		foreach (World.SpawnTiming spawnTiming in World.GetSpawnTimings())
		{
			object[] obj = new object[6]
			{
				num,
				spawnTiming.prefab.Name,
				null,
				null,
				null,
				null
			};
			TimeSpan time = spawnTiming.time;
			obj[2] = time.Ticks * EventRecord.TicksToNS;
			obj[3] = spawnTiming.category;
			obj[4] = spawnTiming.position;
			obj[5] = spawnTiming.rotation;
			stringBuilder.AppendLine(string.Format("{0},{1},{2},{3},{4},{5}", obj));
			num++;
		}
		WriteTextToFile(targetFolder + "World.Spawn.csv", stringBuilder.ToString());
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;

public class DirectionalDamageTrigger : TriggerBase
{
	public float repeatRate = 1f;

	public List<DamageTypeEntry> damageType;

	public GameObjectRef attackEffect;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (!(baseEntity is BaseCombatEntity))
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)OnTick, repeatRate, repeatRate);
	}

	public override void OnEmpty()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
	}

	private void OnTick()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		if (attackEffect.isValid)
		{
			Effect.server.Run(attackEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		}
		if (entityContents == null)
		{
			return;
		}
		BaseEntity[] array = entityContents.ToArray();
		foreach (BaseEntity baseEntity in array)
		{
			if (baseEntity.IsValid())
			{
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				if (!((Object)(object)baseCombatEntity == (Object)null))
				{
					HitInfo hitInfo = new HitInfo();
					hitInfo.damageTypes.Add(damageType);
					hitInfo.DoHitEffects = true;
					hitInfo.DidHit = true;
					hitInfo.PointStart = ((Component)this).transform.position;
					hitInfo.PointEnd = ((Component)baseCombatEntity).transform.position;
					baseCombatEntity.Hurt(hitInfo);
				}
			}
		}
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[ExecuteInEditMode]
public class DofExposer : ListComponent<DofExposer>
{
	public PostProcessVolume PostVolume;

	public bool DofEnabled;

	public float FocalLength = 15.24f;

	public float Blur = 2f;

	public float FocalAperture = 13.16f;

	public float AnamorphicSqueeze;

	public float AnamorphicBarrel;

	public bool debug;
}


using UnityEngine;

public class DrawArrow : MonoBehaviour
{
	public Color color = new Color(1f, 1f, 1f, 1f);

	public float length = 0.2f;

	public float arrowLength = 0.02f;

	private void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 up = ((Component)Camera.current).transform.up;
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = ((Component)this).transform.position + forward * length;
		Gizmos.color = color;
		Gizmos.DrawLine(position, val);
		Gizmos.DrawLine(val, val + up * arrowLength - forward * arrowLength);
		Gizmos.DrawLine(val, val - up * arrowLength - forward * arrowLength);
		Gizmos.DrawLine(val + up * arrowLength - forward * arrowLength, val - up * arrowLength - forward * arrowLength);
	}
}


using UnityEngine;

public class DrawSkeleton : MonoBehaviour
{
	private void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.white;
		DrawTransform(((Component)this).transform);
	}

	private static void DrawTransform(Transform t)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < t.childCount; i++)
		{
			Gizmos.DrawLine(t.position, t.GetChild(i).position);
			DrawTransform(t.GetChild(i));
		}
	}
}


using System;
using System.Collections.Generic;

public class FakeSteamItemStub : IPlayerItemDefinition, IEquatable<IPlayerItemDefinition>
{
	private SteamInventoryItem _source;

	public int DefinitionId => _source.id;

	public string Name => _source.displayName.translated;

	public string Description => _source.displayDescription.translated;

	public string Type => "Type";

	public string IconUrl => string.Empty;

	public int LocalPrice => 0;

	public string LocalPriceFormatted => "$0.00";

	public string PriceCategory => "PriceCategory";

	public bool IsGenerator => false;

	public bool IsTradable => false;

	public bool IsMarketable => false;

	public string StoreTags => "StoreTags";

	public DateTime Created { get; }

	public DateTime Modified { get; }

	public string ItemShortName => _source.itemname;

	public ulong WorkshopId
	{
		get
		{
			if (!(_source is ItemSkin itemSkin))
			{
				return 0uL;
			}
			return itemSkin.workshopID;
		}
	}

	public ulong WorkshopDownload { get; }

	public FakeSteamItemStub(SteamInventoryItem itemBacking)
	{
		_source = itemBacking;
	}

	public bool Equals(IPlayerItemDefinition other)
	{
		return other.DefinitionId == DefinitionId;
	}

	public IEnumerable<PlayerItemRecipe> GetRecipesContainingThis()
	{
		return null;
	}
}


using System;
using System.Threading;
using UnityEngine;

public class InvokeSpammer : MonoBehaviour
{
	public int InvokeMilliseconds = 1;

	public float RepeatTime = 0.6f;

	private void Start()
	{
		((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).InvokeRepeating((Action)TestInvoke, RepeatTime, RepeatTime);
	}

	private void TestInvoke()
	{
		Thread.Sleep(InvokeMilliseconds);
	}
}


using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class ItemButtonTools : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler, IScrollHandler
{
	public ScrollRect MainScroll;

	public Image image;

	public Image backgroundImage;

	public ItemDefinition itemDef;

	public void GiveSelf(int amount)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		DebugLog();
		ConsoleSystem.Run(Option.Client, "inventory.giveid", new object[2] { itemDef.itemid, amount });
	}

	public void GiveArmed()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		DebugLog();
		ConsoleSystem.Run(Option.Client, "inventory.givearm", new object[1] { itemDef.itemid });
	}

	public void GiveStack()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		DebugLog();
		ConsoleSystem.Run(Option.Client, "inventory.giveid", new object[2] { itemDef.itemid, itemDef.stackable });
	}

	public void GiveBlueprint()
	{
	}

	private void DebugLog()
	{
		if (Input.GetKey((KeyCode)308))
		{
			Debug.Log((object)((Object)((Component)itemDef).gameObject).name, (Object)(object)((Component)itemDef).gameObject);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		MainScroll.OnBeginDrag(eventData);
	}

	public void OnDrag(PointerEventData eventData)
	{
		MainScroll.OnDrag(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		MainScroll.OnEndDrag(eventData);
	}

	public void OnScroll(PointerEventData data)
	{
		MainScroll.OnScroll(data);
	}
}


using System.Linq;
using Rust;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ItemListTools : MonoBehaviour
{
	public GameObject categoryButton;

	public GameObject itemButton;

	public RustInput searchInputText;

	internal Button lastCategory;

	public ScrollRect MainScrollRect;

	private IOrderedEnumerable<ItemDefinition> currentItems;

	private IOrderedEnumerable<ItemDefinition> allItems;

	public void OnPanelOpened()
	{
		CacheAllItems();
		Refresh();
		searchInputText.InputField.ActivateInputField();
	}

	private void OnOpenDevTools()
	{
		searchInputText.InputField.ActivateInputField();
	}

	private void CacheAllItems()
	{
		if (allItems == null)
		{
			allItems = from x in ItemManager.GetItemDefinitions()
				orderby x.displayName.translated
				select x;
		}
	}

	public void Refresh()
	{
		RebuildCategories();
	}

	private void RebuildCategories()
	{
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Expected O, but got Unknown
		for (int i = 0; i < categoryButton.transform.parent.childCount; i++)
		{
			Transform child = categoryButton.transform.parent.GetChild(i);
			if (!((Object)(object)child == (Object)(object)categoryButton.transform))
			{
				GameManager.Destroy(((Component)child).gameObject);
			}
		}
		categoryButton.SetActive(true);
		foreach (IGrouping<ItemCategory, ItemDefinition> item in from x in ItemManager.GetItemDefinitions()
			group x by x.category into x
			orderby x.First().category
			select x)
		{
			GameObject val = Object.Instantiate<GameObject>(categoryButton);
			val.transform.SetParent(categoryButton.transform.parent, false);
			((TMP_Text)val.GetComponentInChildren<TextMeshProUGUI>()).text = item.First().category.ToString();
			Button btn = val.GetComponentInChildren<Button>();
			ItemDefinition[] itemArray = item.ToArray();
			((UnityEvent)btn.onClick).AddListener((UnityAction)delegate
			{
				if (Object.op_Implicit((Object)(object)lastCategory))
				{
					((Selectable)lastCategory).interactable = true;
				}
				lastCategory = btn;
				((Selectable)lastCategory).interactable = false;
				SwitchItemCategory(itemArray);
			});
			if ((Object)(object)lastCategory == (Object)null)
			{
				lastCategory = btn;
				((Selectable)lastCategory).interactable = false;
				SwitchItemCategory(itemArray);
			}
		}
		categoryButton.SetActive(false);
	}

	private void SwitchItemCategory(ItemDefinition[] defs)
	{
		currentItems = defs.OrderBy((ItemDefinition x) => x.displayName.translated);
		searchInputText.Text = "";
		FilterItems(null);
		MainScrollRect.verticalNormalizedPosition = 1f;
	}

	public void FilterItems(string searchText)
	{
		if ((Object)(object)itemButton == (Object)null)
		{
			return;
		}
		for (int i = 0; i < itemButton.transform.parent.childCount; i++)
		{
			Transform child = itemButton.transform.parent.GetChild(i);
			if (!((Object)(object)child == (Object)(object)itemButton.transform))
			{
				GameManager.Destroy(((Component)child).gameObject);
			}
		}
		itemButton.SetActive(true);
		bool flag = !string.IsNullOrEmpty(searchText);
		string search = (flag ? searchText.ToLower() : null);
		IOrderedEnumerable<ItemDefinition> obj = (flag ? allItems : currentItems);
		int num = 0;
		foreach (ItemDefinition item in obj)
		{
			if (!item.Hidden() && (!flag || ItemSearchUtils.IsValidSearchResult(search, item, checkItemIsValid: false)))
			{
				GameObject obj2 = Object.Instantiate<GameObject>(itemButton);
				obj2.transform.SetParent(itemButton.transform.parent, false);
				((TMP_Text)obj2.GetComponentInChildren<TextMeshProUGUI>()).text = item.displayName.translated;
				obj2.GetComponentInChildren<ItemButtonTools>().itemDef = item;
				obj2.GetComponentInChildren<ItemButtonTools>().MainScroll = MainScrollRect;
				obj2.GetComponentInChildren<ItemButtonTools>().image.sprite = item.iconSprite;
				((Behaviour)obj2.GetComponentInChildren<ItemButtonTools>().backgroundImage).enabled = (Object)(object)item != (Object)null && !item.IsAllowedInEra((EraRestriction)0);
				num++;
				if (num >= 160)
				{
					break;
				}
			}
		}
		itemButton.SetActive(false);
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class MeshTrimTester : MonoBehaviour
{
	public MeshTrimSettings Settings = MeshTrimSettings.Default;

	public Mesh SourceMesh;

	public MeshFilter TargetMeshFilter;

	public int SubtractIndex;
}


using UnityEngine;

public class MoveObjectOverTime : MonoBehaviour
{
	public Transform Mover;

	public Vector3 OffsetAmount;

	public float Speed = 1f;
}


using Network;
using TMPro;
using UnityEngine;

public class NetworkInfoGeneralText : MonoBehaviour
{
	public TextMeshProUGUI text;

	private void Update()
	{
		UpdateText();
	}

	private void UpdateText()
	{
		string text = "";
		if (Net.sv != null)
		{
			text += "Server\n";
			text += ((BaseNetwork)Net.sv).GetDebug((Connection)null);
			text += "\n";
		}
		((TMP_Text)this.text).text = text;
	}

	private static string ChannelStat(int window, int left)
	{
		return $"{left}/{window}";
	}
}


using UnityEngine;

public class ObjectSpam : MonoBehaviour
{
	public GameObject source;

	public int amount = 1000;

	public float radius;

	private void Start()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < amount; i++)
		{
			GameObject obj = Object.Instantiate<GameObject>(source);
			obj.transform.position = ((Component)this).transform.position + Vector3Ex.Range(0f - radius, radius);
			((Object)obj).hideFlags = (HideFlags)3;
		}
	}
}


using UnityEngine;

public class PingPongRotate : MonoBehaviour
{
	public Vector3 rotationSpeed = Vector3.zero;

	public Vector3 offset = Vector3.zero;

	public Vector3 rotationAmount = Vector3.zero;

	private void Update()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.identity;
		for (int i = 0; i < 3; i++)
		{
			val *= GetRotation(i);
		}
		((Component)this).transform.rotation = val;
	}

	public Quaternion GetRotation(int index)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		switch (index)
		{
		case 0:
			val = Vector3.right;
			break;
		case 1:
			val = Vector3.up;
			break;
		case 2:
			val = Vector3.forward;
			break;
		}
		return Quaternion.AngleAxis(Mathf.Sin((((Vector3)(ref offset))[index] + Time.time) * ((Vector3)(ref rotationSpeed))[index]) * ((Vector3)(ref rotationAmount))[index], val);
	}
}


using UnityEngine;

public class RotateObject : MonoBehaviour
{
	public float rotateSpeed_X = 1f;

	public float rotateSpeed_Y = 1f;

	public float rotateSpeed_Z = 1f;

	public bool localSpace;

	public bool randomizeRotation;

	public Vector3 randomVariationRange = new Vector3(0.5f, 0.5f, 0.5f);

	private void Start()
	{
		if (randomizeRotation)
		{
			rotateSpeed_Y = Random.Range(0f - Mathf.Abs(rotateSpeed_X), Mathf.Abs(rotateSpeed_X));
			rotateSpeed_Z = Random.Range(0f - Mathf.Abs(rotateSpeed_X), Mathf.Abs(rotateSpeed_X));
		}
		rotateSpeed_X *= 1f + Random.Range(0f - randomVariationRange.x, randomVariationRange.x);
		rotateSpeed_Y *= 1f + Random.Range(0f - randomVariationRange.y, randomVariationRange.y);
		rotateSpeed_Z *= 1f + Random.Range(0f - randomVariationRange.z, randomVariationRange.z);
	}

	protected void Update()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		if (localSpace)
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(rotateSpeed_X, rotateSpeed_Y, rotateSpeed_Z);
			((Component)this).transform.Rotate(val * Time.deltaTime, (Space)1);
			return;
		}
		if (rotateSpeed_X != 0f)
		{
			((Component)this).transform.Rotate(Vector3.up, Time.deltaTime * rotateSpeed_X);
		}
		if (rotateSpeed_Y != 0f)
		{
			((Component)this).transform.Rotate(((Component)this).transform.forward, Time.deltaTime * rotateSpeed_Y);
		}
		if (rotateSpeed_Z != 0f)
		{
			((Component)this).transform.Rotate(((Component)this).transform.right, Time.deltaTime * rotateSpeed_Z);
		}
	}
}


public static class SafeMode
{
}


using UnityEngine;
using UnityEngine.UI;

public class SeedPosInfo : MonoBehaviour
{
	public CanvasGroup Canvas;

	public Text WorldPos;

	public Text LevelName;

	public Text WorldSize;

	public Text Seed;
}


using System;
using ConVar;
using Facepunch;
using UnityEngine;

public class ServerConsole : SingletonComponent<ServerConsole>
{
	private static bool consoleEnabled => !CommandLine.HasSwitch("-noconsole");

	private DateTime currentGameTime
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)TOD_Sky.Instance))
			{
				return DateTime.Now;
			}
			return TOD_Sky.Instance.Cycle.DateTime;
		}
	}

	private int currentPlayerCount => BasePlayer.activePlayerList.Count;

	private int maxPlayerCount => Server.maxplayers;

	private int currentEntityCount => BaseNetworkable.serverEntities.Count;

	private int currentSleeperCount => BasePlayer.sleepingPlayerList.Count;

	public void OnEnable()
	{
	}

	private void OnDisable()
	{
		Output.OnMessage -= HandleLog;
	}

	private void OnInputText(string obj)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		ConsoleSystem.Run(Option.Server, obj, Array.Empty<object>());
	}

	public static void PrintColoured(params object[] objects)
	{
	}

	private void HandleLog(string message, string stackTrace, LogType type)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Invalid comparison between Unknown and I4
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Invalid comparison between Unknown and I4
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Invalid comparison between Unknown and I4
		if (message.StartsWith("[CHAT]") || message.StartsWith("[TEAM CHAT]") || message.StartsWith("[CARDS CHAT]"))
		{
			return;
		}
		if ((int)type == 2)
		{
			if (!message.StartsWith("HDR RenderTexture format is not") && !message.StartsWith("The image effect") && !message.StartsWith("Image Effects are not supported on this platform") && !message.StartsWith("[AmplifyColor]") && !message.StartsWith("Skipping profile frame.") && !message.StartsWith("Kinematic body only supports Speculative Continuous collision detection"))
			{
				System.Console.ForegroundColor = ConsoleColor.Yellow;
			}
		}
		else if ((int)type == 0)
		{
			System.Console.ForegroundColor = ConsoleColor.Red;
		}
		else if ((int)type == 4)
		{
			System.Console.ForegroundColor = ConsoleColor.Red;
		}
		else if ((int)type == 1)
		{
			System.Console.ForegroundColor = ConsoleColor.Red;
		}
		else
		{
			System.Console.ForegroundColor = ConsoleColor.Gray;
		}
	}
}


using System;
using System.Runtime.InteropServices;
using UnityEngine;

public static class SystemInfoEx
{
	private static bool[] supportedRenderTextureFormats;

	public static int systemMemoryUsed => (int)(System_GetMemoryUsage() / 1024 / 1024);

	[DllImport("RustNative")]
	private static extern ulong System_GetMemoryUsage();

	public static bool SupportsRenderTextureFormat(RenderTextureFormat format)
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if (supportedRenderTextureFormats == null)
		{
			Array values = Enum.GetValues(typeof(RenderTextureFormat));
			int num = (int)values.GetValue(values.Length - 1);
			supportedRenderTextureFormats = new bool[num + 1];
			for (int i = 0; i <= num; i++)
			{
				bool flag = Enum.IsDefined(typeof(RenderTextureFormat), i);
				supportedRenderTextureFormats[i] = flag && SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)i);
			}
		}
		return supportedRenderTextureFormats[format];
	}
}


using System.Text;
using Rust;
using TMPro;
using UnityEngine;

public class SystemInfoGeneralText : MonoBehaviour
{
	public TextMeshProUGUI text;

	public static string currentInfo
	{
		get
		{
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: false);
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("System");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tName: ");
			stringBuilder.Append(SystemInfo.deviceName);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tOS:   ");
			stringBuilder.Append(SystemInfo.operatingSystem);
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("CPU");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tModel:  ");
			stringBuilder.Append(SystemInfo.processorType);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tCores:  ");
			stringBuilder.Append(SystemInfo.processorCount);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory: ");
			stringBuilder.Append(SystemInfo.systemMemorySize);
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("GPU");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tModel:  ");
			stringBuilder.Append(SystemInfo.graphicsDeviceName);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tAPI:    ");
			stringBuilder.Append(SystemInfo.graphicsDeviceVersion);
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory: ");
			stringBuilder.Append(SystemInfo.graphicsMemorySize);
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tSM:     ");
			stringBuilder.Append(SystemInfo.graphicsShaderLevel);
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("Process");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory:   ");
			stringBuilder.Append(SystemInfoEx.systemMemoryUsed);
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.Append("Mono");
			stringBuilder.AppendLine();
			stringBuilder.Append("\tCollects: ");
			stringBuilder.Append(GC.CollectionCount());
			stringBuilder.AppendLine();
			stringBuilder.Append("\tMemory:   ");
			stringBuilder.Append(GC.GetTotalMemory());
			stringBuilder.Append(" MB");
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			if (World.Seed != 0 && World.Size != 0)
			{
				stringBuilder.Append("World");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tSeed:        ");
				if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.ingameMap)
				{
					stringBuilder.Append("?");
				}
				else
				{
					stringBuilder.Append(World.Seed);
				}
				stringBuilder.AppendLine();
				stringBuilder.Append("\tSize:        ");
				stringBuilder.Append(KM2(World.Size));
				stringBuilder.Append(" km");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tHeightmap:   ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) ? TerrainMeta.HeightMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tWatermap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) ? TerrainMeta.WaterMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tSplatmap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.SplatMap) ? TerrainMeta.SplatMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tBiomemap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tTopologymap: ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) ? TerrainMeta.TopologyMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
				stringBuilder.Append("\tAlphamap:    ");
				stringBuilder.Append(MB(Object.op_Implicit((Object)(object)TerrainMeta.AlphaMap) ? TerrainMeta.AlphaMap.GetMemoryUsage() : 0));
				stringBuilder.Append(" MB");
				stringBuilder.AppendLine();
			}
			stringBuilder.AppendLine();
			if (!string.IsNullOrEmpty(World.Checksum))
			{
				stringBuilder.AppendLine("Checksum");
				stringBuilder.Append('\t');
				stringBuilder.AppendLine(World.Checksum);
			}
			return stringBuilder.ToString();
		}
	}

	protected void Update()
	{
		((TMP_Text)text).text = currentInfo;
	}

	private static long MB(long bytes)
	{
		return bytes / 1048576;
	}

	private static long MB(ulong bytes)
	{
		return MB((long)bytes);
	}

	private static int KM2(float meters)
	{
		return Mathf.RoundToInt(meters * meters * 1E-06f);
	}
}


using UnityEngine;

public class TriangleIdentifier : MonoBehaviour
{
	public int TriangleID;

	public int SubmeshID;

	public float LineLength = 1.5f;

	private void OnDrawGizmosSelected()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		MeshFilter component = ((Component)this).GetComponent<MeshFilter>();
		if (!((Object)(object)component == (Object)null) && !((Object)(object)component.sharedMesh == (Object)null))
		{
			int[] triangles = component.sharedMesh.GetTriangles(SubmeshID);
			if (TriangleID >= 0 && TriangleID * 3 <= triangles.Length)
			{
				Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
				Vector3 val = component.sharedMesh.vertices[TriangleID * 3];
				Vector3 val2 = component.sharedMesh.vertices[TriangleID * 3 + 1];
				Vector3 val3 = component.sharedMesh.vertices[TriangleID * 3 + 2];
				Vector3 val4 = component.sharedMesh.normals[TriangleID * 3];
				Vector3 val5 = component.sharedMesh.normals[TriangleID * 3 + 1];
				Vector3 val6 = component.sharedMesh.normals[TriangleID * 3 + 2];
				Vector3 val7 = (val + val2 + val3) / 3f;
				Vector3 val8 = (val4 + val5 + val6) / 3f;
				Gizmos.DrawLine(val7, val7 + val8 * LineLength);
			}
		}
	}
}


[JsonModel]
public struct ClientPerformanceReport
{
	public int request_id;

	public string user_id;

	public float fps_average;

	public int fps;

	public int frame_id;

	public float frame_time;

	public float frame_time_average;

	public long memory_system;

	public long memory_collections;

	public long memory_managed_heap;

	public float realtime_since_startup;

	public bool streamer_mode;

	public int ping;

	public int tasks_invokes;

	public int tasks_load_balancer;

	public int workshop_skins_queued;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DevBotSpawner : FacepunchBehaviour
{
	public GameObjectRef bot;

	public Transform waypointParent;

	public bool autoSelectLatestSpawnedGameObject = true;

	public float spawnRate = 1f;

	public int maxPopulation = 1;

	private Transform[] waypoints;

	private List<BaseEntity> _spawned = new List<BaseEntity>();

	public bool HasFreePopulation()
	{
		for (int num = _spawned.Count - 1; num >= 0; num--)
		{
			BaseEntity baseEntity = _spawned[num];
			if ((Object)(object)baseEntity == (Object)null || baseEntity.Health() <= 0f)
			{
				_spawned.Remove(baseEntity);
			}
		}
		if (_spawned.Count < maxPopulation)
		{
			return true;
		}
		return false;
	}

	public void SpawnBot()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		while (HasFreePopulation())
		{
			Vector3 position = waypoints[0].position;
			BaseEntity baseEntity = GameManager.server.CreateEntity(bot.resourcePath, position);
			if ((Object)(object)baseEntity == (Object)null)
			{
				break;
			}
			_spawned.Add(baseEntity);
			((Component)baseEntity).SendMessage("SetWaypoints", (object)waypoints, (SendMessageOptions)1);
			baseEntity.Spawn();
		}
	}

	public void Start()
	{
		waypoints = ((Component)waypointParent).GetComponentsInChildren<Transform>();
		((FacepunchBehaviour)this).InvokeRepeating((Action)SpawnBot, 5f, spawnRate);
	}
}


using UnityEngine;

public class DevCamera : MonoBehaviour
{
	public float movementScale = 1f;
}


using UnityEngine;

[ExecuteInEditMode]
public class DevControls : MonoBehaviour
{
	public GUISkin skin;
}


public class DevControlsTab : BaseMonoBehaviour
{
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class DevDressPlayer : MonoBehaviour
{
	public bool DressRandomly;

	public List<ItemAmount> clothesToWear;

	private void ServerInitComponent()
	{
		BasePlayer component = ((Component)this).GetComponent<BasePlayer>();
		if (DressRandomly)
		{
			DoRandomClothes(component);
		}
		foreach (ItemAmount item in clothesToWear)
		{
			if (!((Object)(object)item.itemDef == (Object)null))
			{
				ItemManager.Create(item.itemDef, 1, 0uL).MoveToContainer(component.inventory.containerWear);
			}
		}
	}

	private void DoRandomClothes(BasePlayer player)
	{
		string text = "";
		foreach (ItemDefinition item in (from x in ItemManager.GetItemDefinitions()
			where Object.op_Implicit((Object)(object)((Component)x).GetComponent<ItemModWearable>())
			orderby Guid.NewGuid()
			select x).Take(Random.Range(0, 4)))
		{
			ItemManager.Create(item, 1, 0uL).MoveToContainer(player.inventory.containerWear);
			text = text + item.shortname + " ";
		}
		text = text.Trim();
		if (text == "")
		{
			text = "naked";
		}
		player.displayName = text;
	}
}


using System.Linq;
using Facepunch;
using Facepunch.Models;
using UnityEngine;

public static class DeveloperList
{
	public static bool Contains(string steamid)
	{
		if (Application.Manifest == null)
		{
			return false;
		}
		if (Application.Manifest.Administrators == null)
		{
			return false;
		}
		return Application.Manifest.Administrators.Any((Administrator x) => x.UserId == steamid);
	}

	public static bool Contains(ulong steamid)
	{
		return Contains(steamid.ToString());
	}

	public static bool IsDeveloper(BasePlayer ply)
	{
		if ((Object)(object)ply != (Object)null)
		{
			return Contains(ply.UserIDString);
		}
		return false;
	}
}


using UnityEngine;

public class DevEnableDisable : DevControlsTab
{
	public GameObject[] Objects;

	public string CookieName = "Cookie";

	public string TabName = "Scene";
}


public class DevEnvironment : DevControlsTab
{
	public TOD_Sky sky;
}


using UnityEngine;

public class DevImpactEffectTest : MonoBehaviour
{
}


using System;
using UnityEngine;

public class DevMovePlayer : BaseMonoBehaviour
{
	public BasePlayer player;

	public Transform[] Waypoints;

	public bool moveRandomly;

	public Vector3 destination = Vector3.zero;

	public Vector3 lookPoint = Vector3.zero;

	private int waypointIndex;

	private float randRun;

	public void Awake()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		randRun = Random.Range(5f, 10f);
		player = ((Component)this).GetComponent<BasePlayer>();
		if (Waypoints.Length != 0)
		{
			destination = Waypoints[0].position;
		}
		else
		{
			destination = ((Component)this).transform.position;
		}
		if (!player.isClient)
		{
			if ((Object)(object)player.eyes == (Object)null)
			{
				player.eyes = ((Component)player).GetComponent<PlayerEyes>();
			}
			((FacepunchBehaviour)this).Invoke((Action)LateSpawn, 1f);
		}
	}

	public void LateSpawn()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		Item item = ItemManager.CreateByName("rifle.semiauto", 1, 0uL);
		player.inventory.GiveItem(item, player.inventory.containerBelt);
		player.UpdateActiveItem(item.uid);
		player.health = 100f;
	}

	public void SetWaypoints(Transform[] wps)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Waypoints = wps;
		destination = wps[0].position;
	}

	public void Update()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		if (player.isClient || !player.IsAlive() || player.IsWounded())
		{
			return;
		}
		if (Vector3.Distance(destination, ((Component)this).transform.position) < 0.25f)
		{
			if (moveRandomly)
			{
				waypointIndex = Random.Range(0, Waypoints.Length);
			}
			else
			{
				waypointIndex++;
			}
			if (waypointIndex >= Waypoints.Length)
			{
				waypointIndex = 0;
			}
		}
		if (Waypoints.Length > waypointIndex)
		{
			destination = Waypoints[waypointIndex].position;
			Vector3 val = destination - ((Component)this).transform.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float running = Mathf.Sin(Time.time + randRun);
			float speed = player.GetSpeed(running, 0f, 0f);
			Vector3 position = ((Component)this).transform.position;
			float range = 1f;
			LayerMask mask = LayerMask.op_Implicit(1537286401);
			if (TransformUtil.GetGroundInfo(((Component)this).transform.position + normalized * speed * Time.deltaTime, out var hitOut, range, mask, ((Component)player).transform))
			{
				position = ((RaycastHit)(ref hitOut)).point;
			}
			((Component)this).transform.position = position;
			val = new Vector3(destination.x, 0f, destination.z) - new Vector3(((Component)player).transform.position.x, 0f, ((Component)player).transform.position.z);
			_ = ((Vector3)(ref val)).normalized;
			player.SendNetworkUpdate();
		}
	}
}


using UnityEngine;

public class DevTimeAdjust : MonoBehaviour
{
	private void Start()
	{
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			TOD_Sky.Instance.Cycle.Hour = PlayerPrefs.GetFloat("DevTime");
		}
	}

	private void OnGUI()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			float num = (float)Screen.width * 0.2f;
			Rect val = default(Rect);
			((Rect)(ref val))..ctor((float)Screen.width - (num + 20f), (float)Screen.height - 30f, num, 20f);
			float hour = TOD_Sky.Instance.Cycle.Hour;
			hour = GUI.HorizontalSlider(val, hour, 0f, 24f);
			((Rect)(ref val)).y = ((Rect)(ref val)).y - 20f;
			GUI.Label(val, "Time Of Day");
			if (hour != TOD_Sky.Instance.Cycle.Hour)
			{
				TOD_Sky.Instance.Cycle.Hour = hour;
				PlayerPrefs.SetFloat("DevTime", hour);
			}
		}
	}
}


using System;
using UnityEngine;

public class DevWeatherAdjust : MonoBehaviour
{
	protected void Awake()
	{
		SingletonComponent<Climate>.Instance.Overrides.Clouds = 0f;
		SingletonComponent<Climate>.Instance.Overrides.Fog = 0f;
		SingletonComponent<Climate>.Instance.Overrides.Wind = 0f;
		SingletonComponent<Climate>.Instance.Overrides.Rain = 0f;
	}

	protected void OnGUI()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)Screen.width * 0.2f;
		GUILayout.BeginArea(new Rect((float)Screen.width - num - 20f, 20f, num, 400f), "", GUIStyle.op_Implicit("box"));
		GUILayout.Box("Weather", Array.Empty<GUILayoutOption>());
		GUILayout.FlexibleSpace();
		GUILayout.Label("Clouds", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Clouds = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Clouds, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.Label("Fog", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Fog = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Fog, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.Label("Wind", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Wind = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Wind, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.Label("Rain", Array.Empty<GUILayoutOption>());
		SingletonComponent<Climate>.Instance.Overrides.Rain = GUILayout.HorizontalSlider(SingletonComponent<Climate>.Instance.Overrides.Rain, 0f, 1f, Array.Empty<GUILayoutOption>());
		GUILayout.FlexibleSpace();
		GUILayout.EndArea();
	}
}


using System.Collections.Generic;

[JsonModel]
public class ClientFrametimeReport
{
	public int request_id;

	public int start_frame;

	public List<int> frame_times;
}


[JsonModel]
public class ClientFrametimeRequest
{
	public int request_id;

	public int start_frame;

	public int max_frames;
}


using System.Collections.Generic;
using UnityEngine;

public class GameContentList : MonoBehaviour
{
	public enum ResourceType
	{
		Audio,
		Textures,
		Models
	}

	public ResourceType resourceType;

	public List<Object> foundObjects;
}


public enum ResourceType
{
	Audio,
	Textures,
	Models
}


public static class ItemIconUpload
{
}


using UnityEngine;

public class ItemTools : MonoBehaviour
{
}


using UnityEngine;

public class LodLevelDisplay : MonoBehaviour, IEditorComponent
{
	public Color TextColor = Color.green;

	[Range(1f, 6f)]
	public float TextScaleMultiplier = 1f;
}


using UnityEngine;

public class MidiConvar : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using Rust.Workshop;
using UnityEngine;

public class Performance : SingletonComponent<Performance>
{
	public struct Tick
	{
		public int frameID;

		public int frameRate;

		public float frameTime;

		public float frameRateAverage;

		public float frameTimeAverage;

		public long memoryUsageSystem;

		public long memoryAllocations;

		public long memoryCollections;

		public long loadBalancerTasks;

		public long invokeHandlerTasks;

		public long workshopSkinsQueued;

		public int ping;

		public bool gcTriggered;

		public PerformanceSamplePoint performanceSample;
	}

	private struct LagSpike
	{
		public int Index;

		public int Time;
	}

	public static Tick current;

	public static Tick report;

	public const int FrameHistoryCount = 1000;

	private const int HistoryLength = 60;

	private static long cycles = 0L;

	private static int[] frameRateHistory = new int[60];

	private static float[] frameTimeHistory = new float[60];

	private static int[] frameTimes = new int[1000];

	private int frames;

	private float time;

	private void Update()
	{
		frameTimes[Time.frameCount % 1000] = (int)(1000f * Time.deltaTime);
		TimeWarning val = TimeWarning.New("FPSTimer", 0);
		try
		{
			FPSTimer();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public List<int> GetFrameTimes(int requestedStart, int maxCount, out int startIndex)
	{
		startIndex = Math.Max(requestedStart, Math.Max(Time.frameCount - 1000 - 1, 0));
		int num = Math.Min(Math.Min(1000, maxCount), Time.frameCount);
		List<int> list = Pool.Get<List<int>>();
		for (int i = 0; i < num; i++)
		{
			int num2 = (startIndex + i) % 1000;
			list.Add(frameTimes[num2]);
		}
		return list;
	}

	private void FPSTimer()
	{
		frames++;
		time += Time.unscaledDeltaTime;
		if (!(time < 1f))
		{
			long memoryCollections = current.memoryCollections;
			current.frameID = Time.frameCount;
			current.frameRate = frames;
			current.frameTime = time / (float)frames * 1000f;
			frameRateHistory[cycles % frameRateHistory.Length] = current.frameRate;
			frameTimeHistory[cycles % frameTimeHistory.Length] = current.frameTime;
			current.frameRateAverage = AverageFrameRate();
			current.frameTimeAverage = AverageFrameTime();
			current.memoryUsageSystem = SystemInfoEx.systemMemoryUsed;
			current.memoryAllocations = Rust.GC.GetTotalMemory();
			current.memoryCollections = Rust.GC.CollectionCount();
			current.loadBalancerTasks = LoadBalancer.Count();
			current.invokeHandlerTasks = InvokeHandler.Count();
			current.workshopSkinsQueued = WorkshopSkin.QueuedCount;
			current.performanceSample = PerformanceMetrics.PerformancePerSecond;
			PerformanceMetrics.PerformancePerSecond = default(PerformanceSamplePoint);
			current.gcTriggered = memoryCollections != current.memoryCollections;
			frames = 0;
			time = 0f;
			cycles++;
			report = current;
		}
	}

	private float AverageFrameRate()
	{
		float num = 0f;
		int num2 = Math.Min(frameRateHistory.Length, (int)cycles);
		for (int i = 0; i < num2; i++)
		{
			num += (float)frameRateHistory[i];
		}
		return num / (float)num2;
	}

	private float AverageFrameTime()
	{
		float num = 0f;
		int num2 = Math.Min(frameTimeHistory.Length, (int)cycles);
		for (int i = 0; i < frameTimeHistory.Length; i++)
		{
			num += frameTimeHistory[i];
		}
		return num / (float)num2;
	}
}


public struct Tick
{
	public int frameID;

	public int frameRate;

	public float frameTime;

	public float frameRateAverage;

	public float frameTimeAverage;

	public long memoryUsageSystem;

	public long memoryAllocations;

	public long memoryCollections;

	public long loadBalancerTasks;

	public long invokeHandlerTasks;

	public long workshopSkinsQueued;

	public int ping;

	public bool gcTriggered;

	public PerformanceSamplePoint performanceSample;
}


private struct LagSpike
{
	public int Index;

	public int Time;
}


using UnityEngine;

public class PrefabPrepare : MonoBehaviour
{
}


using UnityEngine;

public class PrefabValidate : MonoBehaviour
{
}


using UnityEngine;

public class ProjectileTestSpawner : MonoBehaviour
{
	public Projectile TargetProjectile;

	public float RepeatTime = 1f;

	public float VelocityScale = 1f;
}


using UnityEngine;

public class SteamInventoryGen : MonoBehaviour
{
}


using Rust;
using UnityEngine;

public class DoorAnimEvents : MonoBehaviour, IClientComponent
{
	public GameObjectRef openStart;

	public GameObjectRef openEnd;

	public GameObjectRef closeStart;

	public GameObjectRef closeEnd;

	public GameObject soundTarget;

	public bool checkAnimSpeed;

	public Animator animator => ((Component)this).GetComponent<Animator>();

	public void DoorOpenStart()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !openStart.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime > 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed < 0f)
			{
				return;
			}
		}
		Effect.client.Run(openStart.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}

	public void DoorOpenEnd()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !openEnd.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime < 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed < 0f)
			{
				return;
			}
		}
		Effect.client.Run(openEnd.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}

	public void DoorCloseStart()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !closeStart.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime > 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed > 0f)
			{
				return;
			}
		}
		Effect.client.Run(closeStart.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}

	public void DoorCloseEnd()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || !closeEnd.isValid || animator.IsInTransition(0))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime < 0.5f)
		{
			return;
		}
		if (checkAnimSpeed)
		{
			currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed > 0f)
			{
				return;
			}
		}
		Effect.client.Run(closeEnd.resourcePath, ((Object)(object)soundTarget == (Object)null) ? ((Component)this).gameObject : soundTarget);
	}
}


using UnityEngine;

public class AnimationEvents : BaseMonoBehaviour
{
	public Transform rootObject;

	public HeldEntity targetEntity;

	[Tooltip("Path to the effect folder for these animations. Relative to this object.")]
	public string effectFolder;

	public bool enforceClipWeights;

	public string localFolder;

	[Tooltip("If true the localFolder field won't update with manifest updates, use for custom paths")]
	public bool customLocalFolder;

	public HeldEntity worldModelEntity;

	public bool IsBusy;

	protected void OnEnable()
	{
		if ((Object)(object)rootObject == (Object)null)
		{
			rootObject = ((Component)this).transform;
		}
	}
}


using UnityEngine;

public class AnimationEventsStub : MonoBehaviour
{
}


using UnityEngine;

public abstract class BaseFootstepEffect : MonoBehaviour, IClientComponent
{
	public LayerMask validImpactLayers = LayerMask.op_Implicit(-1);
}


using UnityEngine;

public class BucketVMFluidSim : MonoBehaviour, IClientComponent
{
	public Animator waterbucketAnim;

	public ParticleSystem waterPour;

	public ParticleSystem waterTurbulence;

	public ParticleSystem waterFill;

	public float waterLevel;

	public float targetWaterLevel;

	public AudioSource waterSpill;
}


using UnityEngine;

public class ColdBreath : BaseMonoBehaviour
{
	public GameObjectRef effect;

	private BasePlayer player;

	private Transform jawBone;
}


using System.Collections.Generic;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;

public class Effect : EffectData
{
	public enum Type : uint
	{
		Generic,
		Projectile,
		GenericGlobal
	}

	public static class client
	{
		public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
		{
		}

		public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
		{
			string.IsNullOrEmpty(strName);
		}

		public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3))
		{
		}

		public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3), Type overrideType = Type.Generic)
		{
			string.IsNullOrEmpty(strName);
		}

		public static void Run(string strName, GameObject obj)
		{
			string.IsNullOrEmpty(strName);
		}

		public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			if (info.HitEntity.IsValid())
			{
				Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal + info.HitNormalLocal * 0.1f, info.HitNormalLocal);
			}
			else
			{
				Run(effectName, info.HitPositionWorld + info.HitNormalWorld * 0.1f, info.HitNormalWorld);
			}
		}

		private static bool CanPlayImpactEffect(HitInfo info)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
			{
				return false;
			}
			return true;
		}

		private static Type GetOverrideType(HitInfo info)
		{
			return Type.Generic;
		}

		private static void HandleAdditiveEffects(HitInfo info)
		{
			if (info.damageTypes.Has(DamageType.Explosion))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
			}
			if (info.damageTypes.Has(DamageType.Heat))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
			}
		}

		public static void ImpactEffect(HitInfo info, string customEffect = null)
		{
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0156: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			if (!info.DoHitEffects)
			{
				return;
			}
			string materialName = StringPool.Get(info.HitMaterial);
			string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
			string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
			if (!CanPlayImpactEffect(info))
			{
				return;
			}
			if (info.HitEntity.IsValid())
			{
				if (customEffect == null)
				{
					GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
					if (impactEffect.isValid)
					{
						strName = impactEffect.resourcePath;
					}
				}
				Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
				if (info.DoDecals)
				{
					Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
				}
			}
			else
			{
				Type overrideType = GetOverrideType(info);
				Run(strName, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
				Run(decal, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
			}
			if (info.WeaponPrefab is BaseMelee baseMelee)
			{
				string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
				if (info.HitEntity.IsValid())
				{
					Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
				}
				else
				{
					Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld);
				}
			}
			HandleAdditiveEffects(info);
		}
	}

	public static class server
	{
		public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			reusableInstace.Init(fxtype, ent, boneID, posLocal, normLocal, sourceConnection);
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}

		public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			if (!string.IsNullOrEmpty(strName))
			{
				reusableInstace.Init(Type.Generic, ent, boneID, posLocal, normLocal, sourceConnection);
				reusableInstace.pooledString = strName;
				reusableInstace.broadcast = broadcast;
				reusableInstace.targets = targets;
				EffectNetwork.Send(reusableInstace);
			}
		}

		public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			reusableInstace.Init(fxtype, posWorld, normWorld, sourceConnection);
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}

		public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			if (!string.IsNullOrEmpty(strName))
			{
				reusableInstace.Init(Type.Generic, posWorld, normWorld, sourceConnection);
				reusableInstace.pooledString = strName;
				reusableInstace.broadcast = broadcast;
				reusableInstace.targets = targets;
				EffectNetwork.Send(reusableInstace);
			}
		}

		public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			if (info.HitEntity.IsValid())
			{
				Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			}
			else
			{
				Run(effectName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			}
		}

		private static bool CanPlayImpactEffect(HitInfo info)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
			{
				return false;
			}
			return true;
		}

		private static void HandleAdditiveEffects(HitInfo info)
		{
			if (info.damageTypes.Has(DamageType.Explosion))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
			}
			if (info.damageTypes.Has(DamageType.Heat))
			{
				DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
			}
		}

		private static void HandleWeaponEffects(HitInfo info, string materialName)
		{
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)info.WeaponPrefab))
			{
				return;
			}
			BaseMelee baseMelee = info.WeaponPrefab as BaseMelee;
			if ((Object)(object)baseMelee != (Object)null)
			{
				string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
				if (info.HitEntity.IsValid())
				{
					Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
				}
				else
				{
					Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
				}
			}
		}

		private static bool IsLegalPlacement(HitInfo info)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			Bounds bounds = info.HitEntity.bounds;
			float num = info.HitEntity.BoundsPadding();
			((Bounds)(ref bounds)).extents = ((Bounds)(ref bounds)).extents + new Vector3(num, num, num);
			if (!((Bounds)(ref bounds)).Contains(info.HitPositionLocal))
			{
				BasePlayer initiatorPlayer = info.InitiatorPlayer;
				if ((Object)(object)initiatorPlayer != (Object)null && ((object)initiatorPlayer).GetType() == typeof(BasePlayer))
				{
					float num2 = Mathf.Sqrt(((Bounds)(ref bounds)).SqrDistance(info.HitPositionLocal));
					if (num2 > ConVar.AntiHack.impact_effect_distance_forgiveness)
					{
						AntiHack.Log(initiatorPlayer, AntiHackType.EffectHack, $"Tried to run an impact effect outside of entity '{info.HitEntity.ShortPrefabName}' bounds by {num2}m");
					}
				}
				return false;
			}
			return true;
		}

		public static void ImpactEffect(HitInfo info, string customEffect = null)
		{
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0117: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			if (Interface.CallHook("OnImpactEffectCreate", (object)info, (object)customEffect) != null || (Object.op_Implicit((Object)(object)info.InitiatorPlayer) && info.InitiatorPlayer.limitNetworking) || !info.DoHitEffects)
			{
				return;
			}
			string materialName = StringPool.Get(info.HitMaterial);
			if (!CanPlayImpactEffect(info))
			{
				return;
			}
			string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
			string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
			if (info.HitEntity.IsValid())
			{
				if (customEffect == null)
				{
					GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
					if (impactEffect.isValid)
					{
						strName = impactEffect.resourcePath;
					}
				}
				if (!IsLegalPlacement(info))
				{
					return;
				}
				Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
				Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			}
			else
			{
				Run(strName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
				Run(decal, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			}
			HandleWeaponEffects(info, materialName);
			HandleAdditiveEffects(info);
		}
	}

	public Vector3 upDir;

	public Vector3 worldPos;

	public Vector3 worldNrm;

	public bool attached;

	public Transform transform;

	public GameObject gameObject;

	public string pooledString;

	public bool broadcast;

	public List<Connection> targets;

	private static Effect reusableInstace = new Effect();

	public Effect()
	{
	}

	public Effect(string effectName, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		Init(Type.Generic, posWorld, normWorld, sourceConnection);
		pooledString = effectName;
	}

	public Effect(string effectName, BaseEntity ent, uint boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection = null)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		Init(Type.Generic, ent, boneID, posLocal, normLocal, sourceConnection);
		pooledString = effectName;
	}

	public void Init(Type fxtype, BaseEntity ent, uint boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection = null)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		Clear();
		base.type = (uint)fxtype;
		attached = true;
		base.origin = posLocal;
		base.normal = normLocal;
		if ((Object)(object)ent != (Object)null && !ent.IsValid())
		{
			Debug.LogWarning((object)"Effect.Init - invalid entity");
		}
		base.entity = (NetworkableId)(ent.IsValid() ? ent.net.ID : default(NetworkableId));
		base.source = sourceConnection?.userid ?? 0;
		base.bone = boneID;
	}

	public void Init(Type fxtype, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		Clear();
		base.type = (uint)fxtype;
		attached = false;
		base.origin = (worldPos = posWorld);
		base.normal = (worldNrm = normWorld);
		base.source = sourceConnection?.userid ?? 0;
	}

	public void Clear()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		base.type = 0u;
		base.pooledstringid = 0u;
		base.number = 0;
		base.origin = default(Vector3);
		base.normal = default(Vector3);
		base.scale = 0f;
		base.entity = default(NetworkableId);
		base.bone = 0u;
		base.source = 0uL;
		base.distanceOverride = 0f;
		upDir = Vector3.zero;
		worldPos = Vector3.zero;
		worldNrm = Vector3.zero;
		attached = false;
		transform = null;
		gameObject = null;
		pooledString = null;
		broadcast = false;
		targets = null;
	}
}


public enum Type : uint
{
	Generic,
	Projectile,
	GenericGlobal
}


using Rust;
using UnityEngine;

public static class client
{
	public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
	{
	}

	public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3))
	{
		string.IsNullOrEmpty(strName);
	}

	public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3))
	{
	}

	public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Vector3 up = default(Vector3), Type overrideType = Type.Generic)
	{
		string.IsNullOrEmpty(strName);
	}

	public static void Run(string strName, GameObject obj)
	{
		string.IsNullOrEmpty(strName);
	}

	public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (info.HitEntity.IsValid())
		{
			Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal + info.HitNormalLocal * 0.1f, info.HitNormalLocal);
		}
		else
		{
			Run(effectName, info.HitPositionWorld + info.HitNormalWorld * 0.1f, info.HitNormalWorld);
		}
	}

	private static bool CanPlayImpactEffect(HitInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
		{
			return false;
		}
		return true;
	}

	private static Type GetOverrideType(HitInfo info)
	{
		return Type.Generic;
	}

	private static void HandleAdditiveEffects(HitInfo info)
	{
		if (info.damageTypes.Has(DamageType.Explosion))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
		}
		if (info.damageTypes.Has(DamageType.Heat))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
		}
	}

	public static void ImpactEffect(HitInfo info, string customEffect = null)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		if (!info.DoHitEffects)
		{
			return;
		}
		string materialName = StringPool.Get(info.HitMaterial);
		string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
		string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
		if (!CanPlayImpactEffect(info))
		{
			return;
		}
		if (info.HitEntity.IsValid())
		{
			if (customEffect == null)
			{
				GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
				if (impactEffect.isValid)
				{
					strName = impactEffect.resourcePath;
				}
			}
			Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
			if (info.DoDecals)
			{
				Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
			}
		}
		else
		{
			Type overrideType = GetOverrideType(info);
			Run(strName, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
			Run(decal, info.HitPositionWorld, info.HitNormalWorld, default(Vector3), overrideType);
		}
		if (info.WeaponPrefab is BaseMelee baseMelee)
		{
			string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
			if (info.HitEntity.IsValid())
			{
				Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal);
			}
			else
			{
				Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld);
			}
		}
		HandleAdditiveEffects(info);
	}
}


using System.Collections.Generic;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;

public static class server
{
	public static void Run(Type fxtype, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		reusableInstace.Init(fxtype, ent, boneID, posLocal, normLocal, sourceConnection);
		reusableInstace.broadcast = broadcast;
		reusableInstace.targets = targets;
		EffectNetwork.Send(reusableInstace);
	}

	public static void Run(string strName, BaseEntity ent, uint boneID = 0u, Vector3 posLocal = default(Vector3), Vector3 normLocal = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (!string.IsNullOrEmpty(strName))
		{
			reusableInstace.Init(Type.Generic, ent, boneID, posLocal, normLocal, sourceConnection);
			reusableInstace.pooledString = strName;
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}
	}

	public static void Run(Type fxtype, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		reusableInstace.Init(fxtype, posWorld, normWorld, sourceConnection);
		reusableInstace.broadcast = broadcast;
		reusableInstace.targets = targets;
		EffectNetwork.Send(reusableInstace);
	}

	public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false, List<Connection> targets = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!string.IsNullOrEmpty(strName))
		{
			reusableInstace.Init(Type.Generic, posWorld, normWorld, sourceConnection);
			reusableInstace.pooledString = strName;
			reusableInstace.broadcast = broadcast;
			reusableInstace.targets = targets;
			EffectNetwork.Send(reusableInstace);
		}
	}

	public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (info.HitEntity.IsValid())
		{
			Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
		}
		else
		{
			Run(effectName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
		}
	}

	private static bool CanPlayImpactEffect(HitInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.WaterMap != (Object)null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && WaterLevel.Test(info.HitPositionWorld, waves: false, volumes: false))
		{
			return false;
		}
		return true;
	}

	private static void HandleAdditiveEffects(HitInfo info)
	{
		if (info.damageTypes.Has(DamageType.Explosion))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
		}
		if (info.damageTypes.Has(DamageType.Heat))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
		}
	}

	private static void HandleWeaponEffects(HitInfo info, string materialName)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)info.WeaponPrefab))
		{
			return;
		}
		BaseMelee baseMelee = info.WeaponPrefab as BaseMelee;
		if ((Object)(object)baseMelee != (Object)null)
		{
			string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
			if (info.HitEntity.IsValid())
			{
				Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			}
			else
			{
				Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			}
		}
	}

	private static bool IsLegalPlacement(HitInfo info)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = info.HitEntity.bounds;
		float num = info.HitEntity.BoundsPadding();
		((Bounds)(ref bounds)).extents = ((Bounds)(ref bounds)).extents + new Vector3(num, num, num);
		if (!((Bounds)(ref bounds)).Contains(info.HitPositionLocal))
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((Object)(object)initiatorPlayer != (Object)null && ((object)initiatorPlayer).GetType() == typeof(BasePlayer))
			{
				float num2 = Mathf.Sqrt(((Bounds)(ref bounds)).SqrDistance(info.HitPositionLocal));
				if (num2 > ConVar.AntiHack.impact_effect_distance_forgiveness)
				{
					AntiHack.Log(initiatorPlayer, AntiHackType.EffectHack, $"Tried to run an impact effect outside of entity '{info.HitEntity.ShortPrefabName}' bounds by {num2}m");
				}
			}
			return false;
		}
		return true;
	}

	public static void ImpactEffect(HitInfo info, string customEffect = null)
	{
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnImpactEffectCreate", (object)info, (object)customEffect) != null || (Object.op_Implicit((Object)(object)info.InitiatorPlayer) && info.InitiatorPlayer.limitNetworking) || !info.DoHitEffects)
		{
			return;
		}
		string materialName = StringPool.Get(info.HitMaterial);
		if (!CanPlayImpactEffect(info))
		{
			return;
		}
		string strName = customEffect ?? EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
		string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
		if (info.HitEntity.IsValid())
		{
			if (customEffect == null)
			{
				GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
				if (impactEffect.isValid)
				{
					strName = impactEffect.resourcePath;
				}
			}
			if (!IsLegalPlacement(info))
			{
				return;
			}
			Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
		}
		else
		{
			Run(strName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			Run(decal, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
		}
		HandleWeaponEffects(info, materialName);
		HandleAdditiveEffects(info);
	}
}


using UnityEngine;

public class EffectAudioPerspectiveSwitcher : MonoBehaviour, IEffect
{
	[HideInInspector]
	public EffectParentToWeaponBone parentToWeaponComponent;
}


public interface IEffectRecycle
{
}


public interface IEffect
{
}


public static class EffectLibrary
{
}


using UnityEngine;

public class EffectMuzzleFlash : MonoBehaviour, IEffect
{
}


using System;
using System.IO;
using Network;
using Network.Visibility;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public static class EffectNetwork
{
	public static void Send(Effect effect)
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null || !((BaseNetwork)Net.sv).IsConnected())
		{
			return;
		}
		TimeWarning val = TimeWarning.New("EffectNetwork.Send", 0);
		try
		{
			Group val2 = null;
			if (!string.IsNullOrEmpty(effect.pooledString))
			{
				((EffectData)effect).pooledstringid = StringPool.Get(effect.pooledString);
			}
			if (((EffectData)effect).pooledstringid == 0)
			{
				Debug.Log((object)("String ID is 0 - unknown effect " + effect.pooledString));
				return;
			}
			if (effect.broadcast)
			{
				NetWrite val3 = ((BaseNetwork)Net.sv).StartWrite();
				val3.PacketID((Type)13);
				ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val3, false, 2097152);
				val3.Send(new SendInfo(BaseNetworkable.GlobalNetworkGroup.subscribers));
				return;
			}
			if (effect.targets != null)
			{
				NetWrite val4 = ((BaseNetwork)Net.sv).StartWrite();
				val4.PacketID((Type)13);
				ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val4, false, 2097152);
				val4.Send(new SendInfo(effect.targets));
				return;
			}
			if (((NetworkableId)(ref ((EffectData)effect).entity)).IsValid)
			{
				BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(((EffectData)effect).entity) as BaseEntity;
				if (!baseEntity.IsValid())
				{
					return;
				}
				val2 = baseEntity.net.group;
			}
			else
			{
				val2 = Net.sv.visibility.GetGroup(effect.worldPos);
			}
			if (val2 != null)
			{
				NetWrite val5 = ((BaseNetwork)Net.sv).StartWrite();
				val5.PacketID((Type)13);
				ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val5, false, 2097152);
				val5.Send(new SendInfo(val2.subscribers));
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void Send(Effect effect, Connection target)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		((EffectData)effect).pooledstringid = StringPool.Get(effect.pooledString);
		if (((EffectData)effect).pooledstringid == 0)
		{
			Debug.LogWarning((object)("EffectNetwork.Send - unpooled effect name: " + effect.pooledString));
			return;
		}
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		val.PacketID((Type)13);
		ProtoStreamExtensions.WriteToStream((IProto)(object)effect, (Stream)(object)val, false, 2097152);
		val.Send(new SendInfo(target));
	}
}


public class EffectParentToWeaponBone : BaseMonoBehaviour, IEffect
{
	public string boneName;

	public bool singleFrame;
}


using UnityEngine;

public class EffectScaleWithCameraDistance : MonoBehaviour, IEffect
{
	public float minScale = 1f;

	public float maxScale = 2.5f;

	public float scaleStartDistance = 50f;

	public float scaleEndDistance = 150f;
}


using UnityEngine;

public class EmissionBlink : FacepunchBehaviour, IClientComponent, INotifyLOD
{
	public EmissionToggle emissionToggle;

	public float blinkDuration = 1f;

	public float blinkInterval = 3f;

	public Light light;

	public float onIntensity = 3f;

	public float offIntensity = 1f;

	[Header("Optional Secondary Light")]
	public bool useSecondaryLight;

	public Light secondaryLight;

	public float secondaryOnIntensity = 2f;

	public float secondaryOffIntensity = 0.5f;
}


using UnityEngine;

public class EmissionScaledByLight : MonoBehaviour, IClientComponent
{
	private Color emissionColor;

	public Renderer[] targetRenderers;

	public int materialIndex = -1;

	private static MaterialPropertyBlock block;

	public Light lightToFollow;

	public float maxEmissionValue = 3f;
}


using UnityEngine;

public class EmissionToggle : MonoBehaviour, IClientComponent
{
	private Color emissionColor;

	public Renderer[] targetRenderers;

	public int materialIndex = -1;
}


using UnityEngine;

public class EyeBlink : MonoBehaviour
{
	public Transform LeftEye;

	public Transform LeftEyelid;

	public Vector3 LeftEyeOffset = new Vector3(0.01f, -0.002f, 0f);

	public Transform RightEye;

	public Transform RightEyelid;

	public Vector3 RightEyeOffset = new Vector3(0.01f, -0.002f, 0f);

	public Vector3 ClosedEyelidPosition;

	public Vector3 ClosedEyelidRotation;

	public Vector2 TimeWithoutBlinking = new Vector2(1f, 10f);

	public float BlinkSpeed = 0.2f;

	public Vector3 LeftEyeInitial;

	public Vector3 RightEyeInitial;
}


using UnityEngine;

public class EyeController : MonoBehaviour
{
	public const float MaxLookDot = 0.8f;

	public bool debug;

	public Transform LeftEye;

	public Transform RightEye;

	public Transform EyeTransform;

	public Vector3 Fudge = new Vector3(0f, 90f, 0f);

	public Vector3 FlickerRange;

	private Transform Focus;

	private float FocusUpdateTime;
}


using UnityEngine;

public class FireBomb : MonoBehaviour, IClientComponent
{
	public GameObject fireParticle;

	public float bombRadius;

	public float particleDuration;

	public float emitDuration;
}


using UnityEngine;

public class FirstPersonEffect : MonoBehaviour, IEffect
{
	public bool isGunShot;

	[HideInInspector]
	public EffectParentToWeaponBone parentToWeaponComponent;
}


using UnityEngine;

public class FootstepEffects : BaseFootstepEffect
{
	public Transform leftFoot;

	public Transform rightFoot;

	public string footstepEffectName = "footstep/barefoot";

	public string jumpStartEffectName = "jump-start/barefoot";

	public string jumpLandEffectName = "jump-land/barefoot";

	public SoundDefinition accentSound;
}


public interface IAnimationEventReceiver
{
}


using UnityEngine;

public class LightPulse : MonoBehaviour, IClientComponent
{
	public Light TargetLight;

	public float PulseSpeed = 1f;

	public float Lifetime = 3f;

	public float MaxIntensity = 3f;

	public float FadeOutSpeed = 2f;
}


using UnityEngine;

public class MaterialSwap : MonoBehaviour, IClientComponent
{
	public int materialIndex;

	public Renderer myRenderer;

	public Material OverrideMaterial;
}


using UnityEngine;

public class Muzzleflash_AlphaRandom : MonoBehaviour
{
	public ParticleSystem[] muzzleflashParticles;

	private Gradient grad = new Gradient();

	private GradientColorKey[] gck = (GradientColorKey[])(object)new GradientColorKey[3];

	private GradientAlphaKey[] gak = (GradientAlphaKey[])(object)new GradientAlphaKey[3];

	private void Start()
	{
	}

	private void OnEnable()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		gck[0].color = Color.white;
		gck[0].time = 0f;
		gck[1].color = Color.white;
		gck[1].time = 0.6f;
		gck[2].color = Color.black;
		gck[2].time = 0.75f;
		float alpha = Random.Range(0.2f, 0.85f);
		gak[0].alpha = alpha;
		gak[0].time = 0f;
		gak[1].alpha = alpha;
		gak[1].time = 0.45f;
		gak[2].alpha = 0f;
		gak[2].time = 0.5f;
		grad.SetKeys(gck, gak);
		ParticleSystem[] array = muzzleflashParticles;
		foreach (ParticleSystem val in array)
		{
			if ((Object)(object)val == (Object)null)
			{
				Debug.LogWarning((object)("Muzzleflash_AlphaRandom : null particle system in " + ((Object)((Component)this).gameObject).name));
				continue;
			}
			ColorOverLifetimeModule colorOverLifetime = val.colorOverLifetime;
			((ColorOverLifetimeModule)(ref colorOverLifetime)).color = MinMaxGradient.op_Implicit(grad);
		}
	}
}


using UnityEngine;

public class MuzzleFlash_Flamelet : MonoBehaviour
{
	public ParticleSystem flameletParticle;

	private void OnEnable()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		ShapeModule shape = flameletParticle.shape;
		((ShapeModule)(ref shape)).angle = Random.Range(6, 13);
		float num = Random.Range(7f, 9f);
		flameletParticle.startSpeed = Random.Range(2.5f, num);
		flameletParticle.startSize = Random.Range(0.05f, num * 0.015f);
	}
}


using UnityEngine;

public class NPCFootstepEffects : BaseFootstepEffect
{
	public string impactEffectDirectory = "footstep/stag";

	public Transform frontLeftFoot;

	public Transform frontRightFoot;

	public Transform backLeftFoot;

	public Transform backRightFoot;
}


using UnityEngine;

public class ParticleEmissionSound : FacepunchBehaviour, IClientComponent, ILOD
{
	public ParticleSystem particleSystem;

	public SoundDefinition soundDefinition;

	public float soundCooldown;
}


using UnityEngine;

public class ParticleEmitFromParentObject : MonoBehaviour
{
	public string bonename;

	private Bounds bounds;

	private Transform bone;

	private BaseEntity entity;

	private float lastBoundsUpdate;
}


using ConVar;
using UnityEngine;

public class PhysicsEffects : MonoBehaviour
{
	public BaseEntity entity;

	public SoundDefinition physImpactSoundDef;

	public float minTimeBetweenEffects = 0.25f;

	public float minDistBetweenEffects = 0.1f;

	public float hardnessScale = 1f;

	public float lowMedThreshold = 0.4f;

	public float medHardThreshold = 0.7f;

	public float enableDelay = 0.1f;

	public LayerMask ignoreLayers;

	public bool useCollisionPositionInsteadOfTransform;

	public float minimumRigidbodyImpactWeight;

	private float lastEffectPlayed;

	private float enabledAt = float.PositiveInfinity;

	private float ignoreImpactThreshold = 0.02f;

	private Vector3 lastCollisionPos;

	public void OnEnable()
	{
		enabledAt = Time.time;
	}

	public void OnCollisionEnter(Collision collision)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if (!Physics.sendeffects || Time.time < enabledAt + enableDelay || Time.time < lastEffectPlayed + minTimeBetweenEffects || ((1 << collision.gameObject.layer) & LayerMask.op_Implicit(ignoreLayers)) != 0)
		{
			return;
		}
		Vector3 relativeVelocity = collision.relativeVelocity;
		float magnitude = ((Vector3)(ref relativeVelocity)).magnitude;
		magnitude = magnitude * 0.055f * hardnessScale;
		Rigidbody val = default(Rigidbody);
		if (!(magnitude <= ignoreImpactThreshold) && (!((useCollisionPositionInsteadOfTransform ? Vector3.Distance(((ContactPoint)(ref collision.contacts[0])).point, lastCollisionPos) : Vector3.Distance(((Component)this).transform.position, lastCollisionPos)) < minDistBetweenEffects) || lastEffectPlayed == 0f) && (!(minimumRigidbodyImpactWeight > 0f) || !collision.gameObject.TryGetComponent<Rigidbody>(ref val) || !(val.mass < minimumRigidbodyImpactWeight)))
		{
			if ((Object)(object)entity != (Object)null)
			{
				entity.SignalBroadcast(BaseEntity.Signal.PhysImpact, magnitude.ToString());
			}
			lastEffectPlayed = Time.time;
			if (useCollisionPositionInsteadOfTransform)
			{
				lastCollisionPos = ((Component)this).transform.InverseTransformPoint(((ContactPoint)(ref collision.contacts[0])).point);
			}
			else
			{
				lastCollisionPos = ((Component)this).transform.position;
			}
		}
	}
}


using UnityEngine;

public class RottingFlies : MonoBehaviour, IClientComponent
{
	public GameObjectRef effect;

	public SoundDefinition soundDef;

	public Transform rootBone;
}


using UnityEngine;

public class Sandstorm : MonoBehaviour
{
	public ParticleSystem m_psSandStorm;

	public float m_flSpeed;

	public float m_flSwirl;

	public float m_flEmissionRate;

	private void Start()
	{
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.RotateAround(((Component)this).transform.position, Vector3.up, Time.deltaTime * m_flSwirl);
		Vector3 eulerAngles = ((Component)this).transform.eulerAngles;
		eulerAngles.x = -7f + Mathf.Sin(Time.time * 2.5f) * 7f;
		((Component)this).transform.eulerAngles = eulerAngles;
		if ((Object)(object)m_psSandStorm != (Object)null)
		{
			m_psSandStorm.startSpeed = m_flSpeed;
			ParticleSystem psSandStorm = m_psSandStorm;
			psSandStorm.startSpeed += Mathf.Sin(Time.time * 0.4f) * (m_flSpeed * 0.75f);
			m_psSandStorm.emissionRate = m_flEmissionRate + Mathf.Sin(Time.time * 1f) * (m_flEmissionRate * 0.3f);
		}
	}
}


using System;
using UnityEngine;

public class ScaleParticleSystem : ScaleRenderer
{
	public ParticleSystem pSystem;

	public bool scaleGravity;

	[NonSerialized]
	private float startSize;

	[NonSerialized]
	private float startLifeTime;

	[NonSerialized]
	private float startSpeed;

	[NonSerialized]
	private float startGravity;

	public override void GatherInitialValues()
	{
		base.GatherInitialValues();
		startGravity = pSystem.gravityModifier;
		startSpeed = pSystem.startSpeed;
		startSize = pSystem.startSize;
		startLifeTime = pSystem.startLifetime;
	}

	public override void SetScale_Internal(float scale)
	{
		base.SetScale_Internal(scale);
		pSystem.startSize = startSize * scale;
		pSystem.startLifetime = startLifeTime * scale;
		pSystem.startSpeed = startSpeed * scale;
		pSystem.gravityModifier = startGravity * scale;
	}
}


using UnityEngine;

public class ScaleRenderer : MonoBehaviour
{
	public bool useRandomScale;

	public float scaleMin = 1f;

	public float scaleMax = 1f;

	private float lastScale = -1f;

	protected bool hasInitialValues;

	public Renderer myRenderer;

	private bool ScaleDifferent(float newScale)
	{
		return newScale != lastScale;
	}

	public void Start()
	{
		if (useRandomScale)
		{
			SetScale(Random.Range(scaleMin, scaleMax));
		}
	}

	public void SetScale(float scale)
	{
		if (!hasInitialValues)
		{
			GatherInitialValues();
		}
		if (ScaleDifferent(scale) || (scale > 0f && !myRenderer.enabled))
		{
			SetRendererEnabled(scale != 0f);
			SetScale_Internal(scale);
		}
	}

	public virtual void SetScale_Internal(float scale)
	{
		lastScale = scale;
	}

	public virtual void SetRendererEnabled(bool isEnabled)
	{
		if (Object.op_Implicit((Object)(object)myRenderer) && myRenderer.enabled != isEnabled)
		{
			myRenderer.enabled = isEnabled;
		}
	}

	public virtual void GatherInitialValues()
	{
		hasInitialValues = true;
	}
}


using System;
using UnityEngine;

public class ScaleTrailRenderer : ScaleRenderer
{
	private TrailRenderer trailRenderer;

	[NonSerialized]
	private float startWidth;

	[NonSerialized]
	private float endWidth;

	[NonSerialized]
	private float duration;

	[NonSerialized]
	private float startMultiplier;

	public override void GatherInitialValues()
	{
		base.GatherInitialValues();
		if (Object.op_Implicit((Object)(object)myRenderer))
		{
			trailRenderer = ((Component)myRenderer).GetComponent<TrailRenderer>();
		}
		else
		{
			trailRenderer = ((Component)this).GetComponentInChildren<TrailRenderer>();
		}
		startWidth = trailRenderer.startWidth;
		endWidth = trailRenderer.endWidth;
		duration = trailRenderer.time;
		startMultiplier = trailRenderer.widthMultiplier;
	}

	public override void SetScale_Internal(float scale)
	{
		if (scale == 0f)
		{
			trailRenderer.emitting = false;
			((Renderer)trailRenderer).enabled = false;
			trailRenderer.time = 0f;
			trailRenderer.Clear();
			return;
		}
		if (!trailRenderer.emitting)
		{
			trailRenderer.Clear();
		}
		trailRenderer.emitting = true;
		((Renderer)trailRenderer).enabled = true;
		base.SetScale_Internal(scale);
		trailRenderer.widthMultiplier = startMultiplier * scale;
		trailRenderer.time = duration * scale;
	}
}


using UnityEngine;

public class ScaleTransform : ScaleRenderer
{
	private Vector3 initialScale;

	public override void SetScale_Internal(float scale)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.SetScale_Internal(scale);
		((Component)myRenderer).transform.localScale = initialScale * scale;
	}

	public override void GatherInitialValues()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		initialScale = ((Component)myRenderer).transform.localScale;
		base.GatherInitialValues();
	}
}


using UnityEngine;

public class AnimatedScreenShake : BaseScreenShake
{
	public AnimationClip TargetClip;

	[ReadOnly]
	public AnimationCurve rotX;

	[ReadOnly]
	public AnimationCurve rotY;

	[ReadOnly]
	public AnimationCurve rotZ;

	[ReadOnly]
	public AnimationCurve posX;

	[ReadOnly]
	public AnimationCurve posY;

	[ReadOnly]
	public AnimationCurve posZ;

	private const float VALID_RANGE = 0.1f;

	private bool canPlay;

	public override void Setup()
	{
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		if (canPlay)
		{
			float num = rotX.Evaluate(delta);
			float num2 = rotY.Evaluate(delta);
			float num3 = rotZ.Evaluate(delta);
			float num4 = posX.Evaluate(delta);
			float num5 = posY.Evaluate(delta);
			float num6 = posZ.Evaluate(delta);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(num, num2, num3);
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(num4, num5, num6);
			if ((bool)cam)
			{
				cam.rotation = Quaternion.Euler(((Quaternion)(ref cam.rotation)).eulerAngles + val);
				ref Vector3 position = ref cam.position;
				position += val2;
			}
			if ((bool)vm)
			{
				vm.rotation = Quaternion.Euler(((Quaternion)(ref vm.rotation)).eulerAngles + val);
				ref Vector3 position2 = ref vm.position;
				position2 += val2;
			}
		}
	}
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public abstract class BaseScreenShake : MonoBehaviour
{
	public static List<BaseScreenShake> list = new List<BaseScreenShake>();

	internal static float punchFadeScale = 0f;

	internal static float bobScale = 0f;

	internal static float animPunchMagnitude = 10f;

	internal static AnimationCurve InverseCurve = AnimationCurve.Linear(0f, 1f, 1f, 0.05f);

	public float length = 2f;

	internal float timeTaken;

	private int currentFrame = -1;

	public static void Apply(Camera cam, BaseViewModel vm)
	{
		CachedTransform<Camera> cam2 = new CachedTransform<Camera>(cam);
		CachedTransform<BaseViewModel> vm2 = new CachedTransform<BaseViewModel>(vm);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].Run(ref cam2, ref vm2);
		}
		cam2.Apply();
		vm2.Apply();
	}

	protected void OnEnable()
	{
		list.Add(this);
		timeTaken = 0f;
		Setup();
	}

	protected void OnDisable()
	{
		if (!Application.isQuitting)
		{
			list.Remove(this);
		}
	}

	public void Run(ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		if (!(timeTaken > length))
		{
			if (Time.frameCount != currentFrame)
			{
				timeTaken += Time.deltaTime;
				currentFrame = Time.frameCount;
			}
			float delta = Mathf.InverseLerp(0f, length, timeTaken);
			Run(delta, ref cam, ref vm);
		}
	}

	public abstract void Setup();

	public abstract void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm);
}


using UnityEngine;
using UnityEngine.Serialization;

public class ExplosionScreenBounceFade : ScreenBounceFade
{
	[FormerlySerializedAs("explosionVolumeWeight")]
	public AnimationCurve volumeWeight;
}


using UnityEngine;

public class ScreenBounce : BaseScreenShake
{
	public AnimationCurve bounceScale;

	public AnimationCurve bounceSpeed;

	public AnimationCurve bounceViewmodel;

	private float bounceTime;

	private Vector3 bounceVelocity = Vector3.zero;

	public override void Setup()
	{
		bounceTime = Random.Range(0f, 1000f);
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		bounceTime += Time.deltaTime * bounceSpeed.Evaluate(delta);
		float num = bounceScale.Evaluate(delta) * 0.1f;
		bounceVelocity.x = Mathf.Sin(bounceTime * 20f) * num;
		bounceVelocity.y = Mathf.Cos(bounceTime * 25f) * num;
		bounceVelocity.z = 0f;
		Vector3 zero = Vector3.zero;
		zero += bounceVelocity.x * cam.right;
		zero += bounceVelocity.y * cam.up;
		if ((bool)cam)
		{
			ref Vector3 position = ref cam.position;
			position += zero;
		}
		if ((bool)vm)
		{
			ref Vector3 position2 = ref vm.position;
			position2 += zero * -1f * bounceViewmodel.Evaluate(delta);
		}
	}
}


using UnityEngine;

public class ScreenBounceFade : BaseScreenShake
{
	public AnimationCurve bounceScale;

	public AnimationCurve bounceSpeed;

	public AnimationCurve bounceViewmodel;

	public AnimationCurve distanceFalloff;

	public AnimationCurve timeFalloff;

	private float bounceTime;

	private Vector3 bounceVelocity = Vector3.zero;

	public float maxDistance = 10f;

	public float scale = 1f;

	public override void Setup()
	{
		bounceTime = Random.Range(0f, 1000f);
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(cam.position, ((Component)this).transform.position);
		float num2 = 1f - Mathf.InverseLerp(0f, maxDistance, num);
		bounceTime += Time.deltaTime * bounceSpeed.Evaluate(delta);
		float num3 = distanceFalloff.Evaluate(num2);
		float num4 = bounceScale.Evaluate(delta) * 0.1f * num3 * scale * timeFalloff.Evaluate(delta);
		bounceVelocity.x = Mathf.Sin(bounceTime * 20f) * num4;
		bounceVelocity.y = Mathf.Cos(bounceTime * 25f) * num4;
		bounceVelocity.z = 0f;
		Vector3 zero = Vector3.zero;
		zero += bounceVelocity.x * cam.right;
		zero += bounceVelocity.y * cam.up;
		zero *= num2;
		if ((bool)cam)
		{
			ref Vector3 position = ref cam.position;
			position += zero;
		}
		if ((bool)vm)
		{
			ref Vector3 position2 = ref vm.position;
			position2 += zero * -1f * bounceViewmodel.Evaluate(delta);
		}
	}
}


using UnityEngine;

public class ScreenFov : BaseScreenShake
{
	public AnimationCurve FovAdjustment;

	public override void Setup()
	{
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		if ((bool)cam)
		{
			Camera component = cam.component;
			component.fieldOfView += FovAdjustment.Evaluate(delta);
		}
	}
}


using UnityEngine;

public class ScreenRotate : BaseScreenShake
{
	public AnimationCurve Pitch;

	public AnimationCurve Yaw;

	public AnimationCurve Roll;

	public AnimationCurve ViewmodelEffect;

	public float scale = 1f;

	public bool useViewModelEffect = true;

	public override void Setup()
	{
	}

	public override void Run(float delta, ref CachedTransform<Camera> cam, ref CachedTransform<BaseViewModel> vm)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		zero.x = Pitch.Evaluate(delta);
		zero.y = Yaw.Evaluate(delta);
		zero.z = Roll.Evaluate(delta);
		if ((bool)cam)
		{
			ref Quaternion rotation = ref cam.rotation;
			rotation *= Quaternion.Euler(zero * scale);
		}
		if ((bool)vm && useViewModelEffect)
		{
			ref Quaternion rotation2 = ref vm.rotation;
			rotation2 *= Quaternion.Euler(zero * scale * -1f * (1f - ViewmodelEffect.Evaluate(delta)));
		}
	}
}


using UnityEngine;

public class Shaker : MonoBehaviour
{
	public float Frequency = 0.1f;

	public Vector3 PositionMagnitude;

	public Vector3 RotationMagnitude;

	public float GlobalMultiplier = 1f;
}


using System;
using UnityEngine;

public class SwapAmmoParticle : MonoBehaviour, IClientComponent, IEffect
{
	[Serializable]
	public struct Override
	{
		public ItemDefinition TargetAmmo;

		public Material TargetMaterial;
	}

	public ParticleSystem Target;

	public Override[] Overrides;
}


using System;
using UnityEngine;

[Serializable]
public struct Override
{
	public ItemDefinition TargetAmmo;

	public Material TargetMaterial;
}


using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

public class TransformLineRenderer : MonoBehaviour, IClientComponent
{
	internal struct LineRendererUpdateJob : IJobParallelForTransform
	{
		[NativeMatchesParallelForLength]
		[WriteOnly]
		public NativeArray<Vector3> ResultWorldPositions;

		public void Execute(int index, [ReadOnly] TransformAccess transform)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			ResultWorldPositions[index] = ((TransformAccess)(ref transform)).position;
		}
	}

	public Transform[] TransformSequence;

	public LineRenderer TargetRenderer;

	public bool IsEnabled = true;
}


using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

internal struct LineRendererUpdateJob : IJobParallelForTransform
{
	[NativeMatchesParallelForLength]
	[WriteOnly]
	public NativeArray<Vector3> ResultWorldPositions;

	public void Execute(int index, [ReadOnly] TransformAccess transform)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		ResultWorldPositions[index] = ((TransformAccess)(ref transform)).position;
	}
}


using UnityEngine;

public class EmissionOffsetStepped : MonoBehaviour, IClientComponent
{
	public Material material;

	public float offsetAmount = 0.1f;

	public float minInterval = 0.5f;

	public float maxInterval = 2f;
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch.Rust.Profiling;
using Network;
using Oxide.Core;
using UnityEngine;

public static class ConsoleNetwork
{
	private static Stopwatch timer = new Stopwatch();

	internal static void Init()
	{
	}

	internal static void OnClientCommand(Message packet)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		if (packet.read.Unread > Server.maxpacketsize_command)
		{
			Debug.LogWarning((object)"Dropping client command due to size");
			return;
		}
		timer.Restart();
		string text = packet.read.StringRaw(8388608, false);
		if (packet.connection == null || !packet.connection.connected)
		{
			Debug.LogWarning((object)("Client without connection tried to run command: " + text));
		}
		else if (Interface.CallHook("OnClientCommand", (object)packet.connection, (object)text) == null)
		{
			Option val = Option.Server;
			val = ((Option)(ref val)).FromConnection(packet.connection);
			string text2 = ConsoleSystem.Run(((Option)(ref val)).Quiet(), text, Array.Empty<object>());
			if (!string.IsNullOrEmpty(text2))
			{
				SendClientReply(packet.connection, text2);
			}
			if (timer.Elapsed > RuntimeProfiler.ConsoleCommandWarningThreshold)
			{
				LagSpikeProfiler.ConsoleCommand(timer.Elapsed, packet, text);
			}
		}
	}

	internal static void SendClientReply(Connection cn, string strCommand)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)11);
			obj.String(strCommand, false);
			obj.Send(new SendInfo(cn));
		}
	}

	public static void SendClientCommand(Connection cn, string strCommand, params object[] args)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && Interface.CallHook("OnSendCommand", (object)cn, (object)strCommand, (object)args) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			string text = ConsoleSystem.BuildCommand(strCommand, args);
			obj.String(text, false);
			obj.Send(new SendInfo(cn));
		}
	}

	public static void SendClientCommandImmediate(Connection cn, string strCommand, params object[] args)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			string text = ConsoleSystem.BuildCommand(strCommand, args);
			obj.String(text, false);
			SendInfo val = default(SendInfo);
			((SendInfo)(ref val))..ctor(cn);
			val.priority = (Priority)0;
			obj.SendImmediate(val);
		}
	}

	public static void SendClientCommand(List<Connection> cn, string strCommand, params object[] args)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && Interface.CallHook("OnSendCommand", (object)cn, (object)strCommand, (object)args) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			obj.String(ConsoleSystem.BuildCommand(strCommand, args), false);
			obj.Send(new SendInfo(cn));
		}
	}

	public static void BroadcastToAllClients(string strCommand, params object[] args)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && Interface.CallHook("OnBroadcastCommand", (object)strCommand, (object)args) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)12);
			obj.String(ConsoleSystem.BuildCommand(strCommand, args), false);
			obj.Send(new SendInfo(Net.sv.connections));
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch.Models;
using Newtonsoft.Json.Linq;
using UnityEngine;

public class CpuAffinity
{
	private static bool _appliedAutoCpuAffinity;

	public static void Apply()
	{
	}

	private static void ApplyImpl(Manifest manifest)
	{
		try
		{
			string cpuModel = SystemInfo.processorType;
			(string, int, int) tuple = ReadManifestCoreRanges(manifest).FirstOrDefault(((string Cpu, int Min, int Max) r) => cpuModel.Contains(r.Cpu, StringComparison.OrdinalIgnoreCase));
			if (tuple.Item2 >= 0 && tuple.Item3 > tuple.Item2)
			{
				ulong num = 0uL;
				for (int i = tuple.Item2; i <= tuple.Item3; i++)
				{
					num |= (ulong)(1L << i);
				}
				if (SystemCommands.SetCpuAffinity(num))
				{
					Debug.Log((object)$"Automatically set CPU affinity to cores {tuple.Item2}-{tuple.Item3} ({tuple.Item1})");
				}
			}
		}
		catch (Exception arg)
		{
			Debug.LogWarning((object)$"Failed to auto set CPU affinity: {arg}");
		}
	}

	private static List<(string Cpu, int Min, int Max)> ReadManifestCoreRanges(Manifest manifest)
	{
		List<(string, int, int)> list = new List<(string, int, int)>();
		JObject obj = manifest?.Metadata;
		JToken obj2 = ((obj != null) ? obj["PreferredCoreRanges"] : null);
		JArray val = (JArray)(object)((obj2 is JArray) ? obj2 : null);
		if (val == null || ((JContainer)val).Count <= 0)
		{
			return list;
		}
		foreach (JToken item in val)
		{
			JObject val2 = (JObject)(object)((item is JObject) ? item : null);
			if (val2 != null)
			{
				JToken obj3 = val2["Cpu"];
				string text = ((obj3 != null) ? Extensions.Value<string>((IEnumerable<JToken>)obj3) : null);
				JToken obj4 = val2["Min"];
				int? num = ((obj4 != null) ? new int?(Extensions.Value<int>((IEnumerable<JToken>)obj4)) : ((int?)null));
				JToken obj5 = val2["Max"];
				int? num2 = ((obj5 != null) ? new int?(Extensions.Value<int>((IEnumerable<JToken>)obj5)) : ((int?)null));
				if (text != null && num.HasValue && num2.HasValue)
				{
					list.Add((text, num.Value, num2.Value));
				}
			}
		}
		return list;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Facepunch;
using Facepunch.Utility;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class VDDraw : SingletonComponent<VDDraw>, IServerComponent
{
	private const int maxLogFiles = 10;

	private const string prefix = "VDDraw";

	private const string extension = "vddraw";

	private const string compressionExtension = "gz";

	private const float defaultEntryDuration = 0.2f;

	private const float saveIntervalSeconds = 60f;

	private ConcurrentQueue<VDDrawEntry> logEntries = new ConcurrentQueue<VDDrawEntry>();

	private bool _isRecording;

	private string currentLogPath;

	public static bool isRecording => SingletonComponent<VDDraw>.Instance._isRecording;

	private static string logDirectoryPath => Path.Combine(Application.persistentDataPath, "Logs");

	[ServerVar]
	public static void SetIsRecording(Arg arg)
	{
		bool flag = (arg.HasArgs(1) ? arg.GetBool(0, false) : (!SingletonComponent<VDDraw>.Instance._isRecording));
		if (SingletonComponent<VDDraw>.Instance._isRecording == flag)
		{
			if (SingletonComponent<VDDraw>.Instance._isRecording)
			{
				arg.ReplyWith("Already recording");
			}
			else
			{
				arg.ReplyWith("Not recording");
			}
		}
		else if (flag)
		{
			SingletonComponent<VDDraw>.Instance.StartRecording();
			arg.ReplyWith("Recording started");
		}
		else
		{
			SingletonComponent<VDDraw>.Instance.StopRecording();
			arg.ReplyWith("Recording stopped");
		}
	}

	private void StartRecording()
	{
		if (!_isRecording)
		{
			_isRecording = true;
			if (!Directory.Exists(logDirectoryPath))
			{
				Directory.CreateDirectory(logDirectoryPath);
			}
			ManageLogFiles();
			currentLogPath = GetNewLogFilePath();
			((FacepunchBehaviour)this).InvokeRepeating((Action)SaveLogs, 0f, 60f);
			Application.quitting += StopRecording;
		}
	}

	private void StopRecording()
	{
		if (_isRecording)
		{
			_isRecording = false;
			((FacepunchBehaviour)this).CancelInvoke((Action)SaveLogs);
			SaveLogs();
			CompressCurrentLog();
			currentLogPath = null;
			Application.quitting -= StopRecording;
		}
	}

	public static void Log(BaseEntity entity, bool display, string label, string message)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)1;
			val.message = message;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	public static void Line(BaseEntity entity, bool display, string label, Vector3 start, Vector3 end, Color color, float duration = 0f)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)0;
			val.start = start;
			val.end = end;
			val.color = color;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	public static void Text(BaseEntity entity, bool display, string label, string message, Vector3 position, Color color, float duration = 0f, float scaleMulti = 1f, bool alsoLog = false)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid())
		{
			if (SingletonComponent<VDDraw>.Instance._isRecording)
			{
				VDDrawEntry val = Pool.Get<VDDrawEntry>();
				val.entityName = GetEntityReadableName(entity);
				val.label = label;
				val.frame = Time.frameCount;
				val.category = (Category)2;
				val.start = position;
				val.message = message;
				val.color = color;
				SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
			}
			if (alsoLog)
			{
				Log(entity, display, label, message);
			}
		}
	}

	public static void Sphere(BaseEntity entity, bool display, string label, Vector3 position, float size, Color color, float duration = 0f)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)3;
			val.start = position;
			val.sizeX = size;
			val.color = color;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	public static void Box(BaseEntity entity, bool display, string label, Vector3 center, Quaternion rotation, Vector3 size, Color color, float duration = 0f)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if (entity.IsValid() && SingletonComponent<VDDraw>.Instance._isRecording)
		{
			VDDrawEntry val = Pool.Get<VDDrawEntry>();
			val.entityName = GetEntityReadableName(entity);
			val.label = label;
			val.frame = Time.frameCount;
			val.category = (Category)4;
			val.start = center;
			val.end = rotation * Vector3.forward;
			val.sizeX = size.x;
			val.sizeY = size.y;
			val.sizeZ = size.z;
			val.color = color;
			SingletonComponent<VDDraw>.Instance.logEntries.Enqueue(val);
		}
	}

	private static string GetNewLogFilePath()
	{
		string text = DateTime.Now.ToString("yyyyMMdd_HHmmss");
		return Path.Combine(logDirectoryPath, "VDDraw_" + text + ".vddraw");
	}

	public static string GetLastLogFilePath()
	{
		List<FileInfo> list = (from f in new DirectoryInfo(logDirectoryPath).GetFiles("VDDraw_*")
			orderby f.CreationTime
			select f).ToList();
		if (list.Count == 0)
		{
			return null;
		}
		return list.Last().FullName;
	}

	private void CompressCurrentLog()
	{
		TimeWarning val = TimeWarning.New("VDDraw:CompressCurrentLog", 0);
		try
		{
			string lastLogFilePath = GetLastLogFilePath();
			byte[] data = File.ReadAllBytes(lastLogFilePath);
			File.WriteAllBytes(bytes: Compression.Compress(data), path: lastLogFilePath + ".gz");
			File.Delete(lastLogFilePath);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SaveLogs()
	{
		TimeWarning val = TimeWarning.New("VDDraw:SaveLogs", 0);
		try
		{
			using FileStream fileStream = new FileStream(currentLogPath, FileMode.Append, FileAccess.Write, FileShare.None, 4096, useAsync: true);
			VDDrawEntry result;
			while (logEntries.TryDequeue(out result))
			{
				ProtoStreamExtensions.WriteToStream((IProto)(object)result, (Stream)fileStream, true, 2097152);
				Pool.Free<VDDrawEntry>(ref result);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void ManageLogFiles()
	{
		List<FileInfo> list = (from f in new DirectoryInfo(logDirectoryPath).GetFiles("VDDraw_*")
			orderby f.CreationTime
			select f).ToList();
		if (list.Count > 10)
		{
			int num = list.Count - 10;
			for (int i = 0; i < num; i++)
			{
				Debug.Log((object)("Deleting log file: " + list[i].FullName));
				list[i].Delete();
			}
		}
	}

	public static string GetEntityReadableName(BaseEntity entity)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		string name = ((object)entity).GetType().Name;
		NetworkableId iD = entity.net.ID;
		return name + "_" + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using ConVar;
using UnityEngine;

public class FileSystem_Warmup : MonoBehaviour
{
	public static bool ranInBackground = false;

	public static Coroutine warmupTask;

	private static List<(string, TimeSpan)> warmupTimes = new List<(string, TimeSpan)>();

	private static bool run = true;

	public static string[] ExcludeFilter = new string[13]
	{
		"/bundled/prefabs/autospawn/monument", "/bundled/prefabs/autospawn/mountain", "/bundled/prefabs/autospawn/canyon", "/bundled/prefabs/autospawn/decor", "/bundled/prefabs/autospawn/tunnel", "/bundled/prefabs/remapped", "/bundled/prefabs/navmesh", "/content/ui/", "/prefabs/ui/", "/prefabs/world/",
		"/prefabs/system/", "/standard assets/", "/third party/"
	};

	private static Stopwatch warmupTimer = new Stopwatch();

	public static IEnumerable<(string, TimeSpan)> GetWarmupTimes()
	{
		return warmupTimes;
	}

	public static void Run()
	{
		if (!Global.skipAssetWarmup_crashes && run)
		{
			string[] assetList = GetAssetList(null);
			for (int i = 0; i < assetList.Length; i++)
			{
				PrefabWarmup(assetList[i]);
			}
			run = false;
		}
	}

	public static IEnumerator Run(string[] assetList, Action<string> statusFunction = null, string format = null, int priority = 0)
	{
		if (Global.warmupConcurrency <= 1)
		{
			return RunImpl(assetList, statusFunction, format);
		}
		return RunAsyncImpl(assetList, statusFunction, format, priority);
	}

	private static IEnumerator RunAsyncImpl(string[] assetList, Action<string> statusFunction, string format, int priority)
	{
		if (Global.skipAssetWarmup_crashes || !run)
		{
			yield break;
		}
		Stopwatch statusSw = Stopwatch.StartNew();
		Timing timer = new Timing("asset_warmup_async");
		Stopwatch sw = Stopwatch.StartNew();
		AssetPreloadResult preload = FileSystem.PreloadAssets((IEnumerable<string>)assetList, Global.warmupConcurrency, priority);
		int warmupIndex = 0;
		while (((CustomYieldInstruction)preload).MoveNext() || warmupIndex < preload.TotalCount)
		{
			float num = CalculateFrameBudget();
			if (num > 0f)
			{
				while (warmupIndex < preload.Results.Count && sw.Elapsed.TotalSeconds < (double)num)
				{
					PrefabWarmup(preload.Results[warmupIndex++].Item1);
				}
			}
			if (warmupIndex == 0 || warmupIndex == preload.TotalCount || statusSw.Elapsed.TotalSeconds > 1.0)
			{
				statusFunction?.Invoke(string.Format(format ?? "{0}/{1}", warmupIndex, preload.TotalCount));
				statusSw.Restart();
			}
			yield return CoroutineEx.waitForEndOfFrame;
			sw.Restart();
		}
		timer.End();
		run = false;
	}

	private static IEnumerator RunImpl(string[] assetList, Action<string> statusFunction = null, string format = null)
	{
		if (Global.skipAssetWarmup_crashes || !run)
		{
			yield break;
		}
		Timing timer = new Timing("asset_warmup");
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < assetList.Length; i++)
		{
			if (sw.Elapsed.TotalSeconds > (double)CalculateFrameBudget() || i == 0 || i == assetList.Length - 1)
			{
				statusFunction?.Invoke(string.Format((format != null) ? format : "{0}/{1}", i + 1, assetList.Length));
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Reset();
				sw.Start();
			}
			PrefabWarmup(assetList[i]);
		}
		timer.End();
		run = false;
	}

	private static float CalculateFrameBudget()
	{
		return 2f;
	}

	private static bool ShouldIgnore(string path)
	{
		for (int i = 0; i < ExcludeFilter.Length; i++)
		{
			if (StringEx.Contains(path, ExcludeFilter[i], CompareOptions.IgnoreCase))
			{
				return true;
			}
		}
		return false;
	}

	public static string[] GetAssetList(bool? poolFilter = null)
	{
		if (!poolFilter.HasValue)
		{
			return (from x in GameManifest.Current.prefabProperties
				select x.name into x
				where !ShouldIgnore(x)
				select x).ToArray();
		}
		return (from x in GameManifest.Current.prefabProperties
			where !ShouldIgnore(x.name) && x.pool == poolFilter
			select x.name).Distinct<string>(StringComparer.InvariantCultureIgnoreCase).ToArray();
	}

	private static void PrefabWarmup(string path)
	{
		warmupTimer.Restart();
		GameManager.server.FindPrefab(path);
		warmupTimer.Stop();
		warmupTimes.Add(ValueTuple.Create(path, warmupTimer.Elapsed));
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch.Extend;
using Facepunch.Utility;
using Ionic.Zlib;
using UnityEngine;

public static class ProfileExporter
{
	private struct MainThreadInfo
	{
		public List<uint> SyncIndices;

		public List<uint> FrameStarts;

		public uint Frames;
	}

	public static class JSON
	{
		private struct ThreadMetadata
		{
			internal int ThreadId;

			internal int AllocationThreadId;

			internal void Emit(StringStream builder)
			{
				bool isMainThread = ThreadId == ServerProfiler.GetMainThreadId();
				EmitThreadName(isMainThread, isAllocThread: false, ThreadId, ThreadId, builder);
				builder.Append(',');
				EmitThreadName(isMainThread, isAllocThread: true, AllocationThreadId, ThreadId, builder);
			}

			private static void EmitThreadName(bool isMainThread, bool isAllocThread, int id, int origId, StringStream builder)
			{
				builder.Append("{\"name\":\"thread_name\",\"ph\":\"M\",\"pid\":0,\"tid\":");
				builder.Append(id);
				builder.Append(",\"args\":{\"name\":\"");
				if (isMainThread)
				{
					builder.Append("Main Thread");
				}
				else
				{
					builder.Append("Thread");
				}
				if (isAllocThread)
				{
					if (!isMainThread)
					{
						builder.Append(' ');
						builder.Append(origId);
					}
					builder.Append(" Allocations");
				}
				builder.Append("\"}}");
			}
		}

		public class StringStream : MemoryStream
		{
			private GZipStream outputStream;

			public StringStream(int capacity, GZipStream outputStream)
				: base(capacity)
			{
				this.outputStream = outputStream;
			}

			public override void Write(byte[] buffer, int offset, int count)
			{
				if (base.Position + count < base.Capacity)
				{
					base.Write(buffer, offset, count);
					return;
				}
				int num = base.Capacity - (int)base.Position;
				if (num > 0)
				{
					base.Write(buffer, offset, num);
				}
				Flush();
				if (count - num > 0)
				{
					base.Write(buffer, offset + num, count - num);
				}
			}

			public override void Write(ReadOnlySpan<byte> source)
			{
				throw new NotSupportedException("Write(ReadOnlySpan<byte>) not implemented!");
			}

			public override void WriteByte(byte value)
			{
				if (base.Position + 1 < base.Capacity)
				{
					base.WriteByte(value);
					return;
				}
				Flush();
				base.WriteByte(value);
			}

			public void Append(char c)
			{
				WriteByte((byte)c);
			}

			public void Append(string text)
			{
				foreach (char c in text)
				{
					Append(c);
				}
			}

			public void Append(int num)
			{
				Span<char> destination = stackalloc char[32];
				num.TryFormat(destination, out var charsWritten);
				Append(destination.Slice(0, charsWritten));
			}

			public void Append(long num)
			{
				Span<char> destination = stackalloc char[32];
				num.TryFormat(destination, out var charsWritten);
				Append(destination.Slice(0, charsWritten));
			}

			public void Append(ulong num)
			{
				Span<char> destination = stackalloc char[32];
				num.TryFormat(destination, out var charsWritten);
				Append(destination.Slice(0, charsWritten));
			}

			public void Append(ReadOnlySpan<char> chars)
			{
				ReadOnlySpan<char> readOnlySpan = chars;
				for (int i = 0; i < readOnlySpan.Length; i++)
				{
					char c = readOnlySpan[i];
					Append(c);
				}
			}

			public override void Flush()
			{
				long position = Position;
				if (position > 0)
				{
					byte[] buffer = GetBuffer();
					((Stream)(object)outputStream).Write(buffer, 0, (int)position);
					Position = 0L;
				}
			}
		}

		public static bool Export(string filename, IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
		{
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Expected O, but got Unknown
			try
			{
				Debug.Log((object)"Starting JSON snapshot generation...");
				Preprocess(profiles, out var mainInfo, out var _);
				string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
				if (!Directory.Exists(text))
				{
					Directory.CreateDirectory(text);
				}
				using (FileStream fileStream = new FileStream(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".json.gz")), FileMode.Create, FileAccess.Write, FileShare.None, 20480))
				{
					GZipStream val = new GZipStream((Stream)fileStream, (CompressionMode)0);
					try
					{
						val.FlushMode = (FlushType)2;
						using StringStream stringStream = new StringStream(16384, val);
						stringStream.Append('[');
						int num = 0;
						foreach (ServerProfiler.Profile profile2 in profiles)
						{
							num = Math.Max(num, profile2.ThreadId);
						}
						List<ThreadMetadata> list = new List<ThreadMetadata>();
						for (int i = 0; i < profiles.Count; i++)
						{
							ServerProfiler.Profile profile = profiles[i];
							ThreadMetadata item = default(ThreadMetadata);
							item.ThreadId = profile.ThreadId;
							num = (item.AllocationThreadId = num + 1);
							if (i != 0)
							{
								stringStream.Append(',');
							}
							item.Emit(stringStream);
							list.Add(item);
						}
						long firstMarkTimestamp = 0L;
						for (int j = 0; j < profiles.Count; j++)
						{
							ServerProfiler.Profile mainProfile = profiles[j];
							if (mainProfile.ThreadId == ServerProfiler.GetMainThreadId())
							{
								if (ProcessMainProfile(in mainProfile, in mainInfo, list[j], stringStream, out firstMarkTimestamp))
								{
									break;
								}
								return false;
							}
						}
						for (int k = 0; k < profiles.Count; k++)
						{
							ServerProfiler.Profile workerProfile = profiles[k];
							if (workerProfile.ThreadId != ServerProfiler.GetMainThreadId() && !ProcessWorkerProfile(in workerProfile, list[k], firstMarkTimestamp, stringStream))
							{
								return false;
							}
						}
						ProcessMemoryState(in memState, firstMarkTimestamp, stringStream);
						stringStream.Append("]");
						stringStream.Flush();
						Debug.Log((object)"Generation done, flushing...");
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
				}
				Debug.Log((object)"Snapshot json export done!");
				return true;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				return false;
			}
		}

		private unsafe static bool ProcessMainProfile(in ServerProfiler.Profile mainProfile, in MainThreadInfo info, in ThreadMetadata metadata, StringStream builder, out long firstMarkTimestamp)
		{
			if (info.FrameStarts == null || info.Frames == 0)
			{
				Debug.LogError((object)"ServerProfiler: Didn't find any main frame info!");
				firstMarkTimestamp = 0L;
				return false;
			}
			int num = 0;
			byte* data = mainProfile.Data;
			uint num2 = info.FrameStarts[0];
			firstMarkTimestamp = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num2).Timestamp;
			long num3 = 0L;
			for (int i = 0; i < info.Frames; i++)
			{
				uint num4 = info.FrameStarts[i];
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num4);
				uint num5 = mainProfile.WriteEnd;
				if (i < info.Frames - 1)
				{
					num5 = info.FrameStarts[i + 1];
				}
				ServerProfiler.Mark mark2 = default(ServerProfiler.Mark);
				mark2.Event = ServerProfiler.Mark.Type.Enter;
				mark2.Timestamp = mark.Timestamp;
				AddMark(mark2, $"UnityFrame{i}", mainProfile.ThreadId, firstMarkTimestamp, builder);
				uint totalMem = 0u;
				long offset = ServerProfiler.TimestampToMicros(mark.Timestamp - firstMarkTimestamp);
				EmitCounter("Main Thread", offset, "Total(B)", totalMem, builder);
				uint readInd = num4;
				while (readInd < num5)
				{
					ServerProfiler.Mark mark3 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + readInd);
					num3 = mark3.Timestamp;
					num += AdjustCallstackDepth(in mark3);
					if (num < 0)
					{
						Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {num}, offset: {readInd}, frame: {i}");
						return false;
					}
					AddMark(in mainProfile, in metadata, readInd, ref totalMem, firstMarkTimestamp, builder);
					if (!AdvanceReadInd(in mark3, data, ref readInd))
					{
						return false;
					}
				}
				long timestamp = ((i < info.Frames - 1) ? Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num5).Timestamp : num3);
				mark2 = default(ServerProfiler.Mark);
				mark2.Event = ServerProfiler.Mark.Type.Exit;
				mark2.Timestamp = timestamp;
				AddMark(mark2, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
			}
			while (num > 0)
			{
				ServerProfiler.Mark mark4 = default(ServerProfiler.Mark);
				mark4.Event = ServerProfiler.Mark.Type.Exit;
				mark4.Timestamp = num3;
				AddMark(mark4, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
				num--;
			}
			return true;
		}

		private unsafe static bool ProcessWorkerProfile(in ServerProfiler.Profile workerProfile, in ThreadMetadata metadata, long firstMarkTimestamp, StringStream builder)
		{
			uint readInd = 0u;
			int num = 0;
			while (readInd < workerProfile.WriteEnd)
			{
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd);
				if (mark.Timestamp >= firstMarkTimestamp)
				{
					break;
				}
				if (mark.Event == ServerProfiler.Mark.Type.Sync)
				{
					Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
					return false;
				}
				num += AdjustCallstackDepth(in mark);
				if (!AdvanceReadInd(in mark, workerProfile.Data, ref readInd))
				{
					return false;
				}
			}
			if (readInd >= workerProfile.WriteEnd)
			{
				return true;
			}
			bool flag = false;
			uint readInd2 = readInd;
			while (readInd2 < workerProfile.WriteEnd)
			{
				ServerProfiler.Mark mark2 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd2);
				if (mark2.Event == ServerProfiler.Mark.Type.Sync)
				{
					Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
					return false;
				}
				if (mark2.Event != ServerProfiler.Mark.Type.Alloc)
				{
					flag = true;
					break;
				}
				if (!AdvanceReadInd(in mark2, workerProfile.Data, ref readInd2))
				{
					return false;
				}
			}
			if (!flag)
			{
				return true;
			}
			if (!FindStartingDepth(in workerProfile, 0u, workerProfile.WriteEnd, out var minDepth))
			{
				return false;
			}
			minDepth = num - minDepth;
			for (int num2 = minDepth; num2 > 0; num2--)
			{
				ServerProfiler.Mark mark3 = default(ServerProfiler.Mark);
				mark3.Event = ServerProfiler.Mark.Type.Enter;
				mark3.Timestamp = firstMarkTimestamp;
				AddMark(mark3, "Unknown", workerProfile.ThreadId, firstMarkTimestamp, builder);
			}
			uint totalMem = 0u;
			long timestamp = 0L;
			uint readInd3 = readInd;
			while (readInd3 < workerProfile.WriteEnd)
			{
				ServerProfiler.Mark mark4 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd3);
				timestamp = mark4.Timestamp;
				minDepth += AdjustCallstackDepth(in mark4);
				if (minDepth < 0)
				{
					Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {minDepth}, offset: {readInd3}, thread: {workerProfile.ThreadId}");
					return false;
				}
				if (mark4.Event == ServerProfiler.Mark.Type.Alloc || (mark4.Event == ServerProfiler.Mark.Type.AllocWithStack && totalMem == 0))
				{
					EmitCounter("Thread", metadata.ThreadId, 0L, "Total(B)", 0uL, builder);
				}
				AddMark(in workerProfile, in metadata, readInd3, ref totalMem, firstMarkTimestamp, builder);
				if (!AdvanceReadInd(in mark4, workerProfile.Data, ref readInd3))
				{
					return false;
				}
			}
			while (minDepth > 0)
			{
				ServerProfiler.Mark mark5 = default(ServerProfiler.Mark);
				mark5.Event = ServerProfiler.Mark.Type.Exit;
				mark5.Timestamp = timestamp;
				AddMark(mark5, null, workerProfile.ThreadId, firstMarkTimestamp, builder);
				minDepth--;
			}
			return true;
		}

		private unsafe static void ProcessMemoryState(in ServerProfiler.MemoryState memState, long firstMarkTimestamp, StringStream builder)
		{
			ulong num = 0uL;
			ulong num2 = 0uL;
			for (uint num3 = 0u; num3 < memState.Created; num3++)
			{
				ServerProfiler.MemoryReading memoryReading = memState.Readings[num3];
				long timestamp = memoryReading.Timestamp;
				if (timestamp >= firstMarkTimestamp)
				{
					ulong num4 = memoryReading.WorkingSet / 1024;
					if (num4 != num)
					{
						long offset = ((num == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
						EmitCounter("ws", offset, "WorkingSet(KB)", num4, builder);
						num = num4;
					}
					ulong num5 = memoryReading.VirtualSet / 1024;
					if (num5 != num2)
					{
						long offset2 = ((num2 == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
						EmitCounter("vs", offset2, "VirtualSet(KB)", num5, builder);
						num2 = num5;
					}
				}
			}
		}

		private unsafe static void AddMark(in ServerProfiler.Profile threadProfile, in ThreadMetadata metadata, uint markInd, ref uint totalMem, long startTimestamp, StringStream builder)
		{
			byte* ptr = threadProfile.Data + markInd;
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
			ptr += sizeof(ServerProfiler.Mark);
			switch (mark.Event)
			{
			case ServerProfiler.Mark.Type.Enter:
				builder.Append(",{\"name\":\"");
				ServerProfiler.AppendNameTo(*(ServerProfiler.Native.MonoMethod**)ptr, builder);
				builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append("}");
				break;
			case ServerProfiler.Mark.Type.Exit:
			case ServerProfiler.Mark.Type.Exception:
			case ServerProfiler.Mark.Type.GCEnd:
				builder.Append(",{\"ph\":\"E\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append("}");
				break;
			case ServerProfiler.Mark.Type.Alloc:
			{
				ServerProfiler.Alloc alloc2 = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
				long num2 = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
				builder.Append(",{\"name\":\"");
				builder.Append("Alloc ");
				builder.Append(alloc2.AlignedSize);
				builder.Append("b\",\"ph\":\"i\",\"ts\":");
				builder.Append(num2);
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
				builder.Append(alloc2.AlignedSize);
				builder.Append(",\"type\":\"");
				ServerProfiler.AppendNameTo(alloc2, builder);
				builder.Append("\",\"lastMethod\":\"");
				if (alloc2.LastMethod != null)
				{
					ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
				}
				else
				{
					builder.Append("<mono-native-runtime>");
				}
				builder.Append("\"}}");
				builder.Append(",{\"name\":\"");
				builder.Append("Alloc ");
				builder.Append(alloc2.AlignedSize);
				builder.Append("b\",\"ph\":\"i\",\"ts\":");
				builder.Append(num2);
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(metadata.AllocationThreadId);
				builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
				builder.Append(alloc2.AlignedSize);
				builder.Append(",\"type\":\"");
				ServerProfiler.AppendNameTo(alloc2, builder);
				builder.Append("\",\"lastMethod\":\"");
				if (alloc2.LastMethod != null)
				{
					ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
				}
				else
				{
					builder.Append("<mono-native-runtime>");
				}
				builder.Append("\"}}");
				totalMem += alloc2.AlignedSize;
				if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
				{
					EmitCounter("Main Thread", num2, "Total(B)", totalMem, builder);
				}
				else
				{
					EmitCounter("Thread", metadata.ThreadId, num2, "Total(B)", totalMem, builder);
				}
				break;
			}
			case ServerProfiler.Mark.Type.AllocWithStack:
			{
				ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
				ptr += sizeof(ServerProfiler.Alloc);
				long num = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
				builder.Append(",{\"name\":\"");
				builder.Append("Alloc ");
				builder.Append(alloc.AlignedSize);
				builder.Append("b\",\"ph\":\"i\",\"ts\":");
				builder.Append(num);
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(metadata.ThreadId);
				builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
				builder.Append(alloc.AlignedSize);
				builder.Append(",\"type\":\"");
				ServerProfiler.AppendNameTo(alloc, builder);
				builder.Append("\",\"lastMethod\":\"");
				if (alloc.LastMethod != null)
				{
					ServerProfiler.AppendNameTo(alloc.LastMethod, builder);
				}
				else
				{
					builder.Append("<mono-native-runtime>");
				}
				builder.Append('"');
				byte b = *ptr;
				ptr++;
				if (b > 0)
				{
					builder.Append(",\"callstack\":{");
					ServerProfiler.Native.MonoMethod** ptr2 = (ServerProfiler.Native.MonoMethod**)ptr;
					for (byte b2 = 0; b2 < b; b2++)
					{
						ServerProfiler.Native.MonoMethod* method = ptr2[(int)b2];
						builder.Append('"');
						char c = (char)(b2 + 32);
						if (c >= '"')
						{
							c = (char)(c + 1);
						}
						if (c >= '.')
						{
							c = (char)(c + 1);
						}
						if (c >= '\\')
						{
							c = (char)(c + 1);
						}
						if (c < '\u007f')
						{
							builder.Append(c);
						}
						else
						{
							builder.Append(b2);
						}
						builder.Append("\":\"");
						ServerProfiler.AppendNameTo(method, builder);
						builder.Append('"');
						if (b2 != b - 1)
						{
							builder.Append(',');
						}
					}
					builder.Append('}');
				}
				builder.Append("}}");
				totalMem += alloc.AlignedSize;
				if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
				{
					EmitCounter("Main Thread", num, "Total(B)", totalMem, builder);
				}
				else
				{
					EmitCounter("Thread", metadata.ThreadId, num, "Total(B)", totalMem, builder);
				}
				break;
			}
			case ServerProfiler.Mark.Type.GCBegin:
				builder.Append(",{\"name\":\"");
				builder.Append("GC.Collect");
				builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadProfile.ThreadId);
				builder.Append("}");
				break;
			}
		}

		private static void AddMark(ServerProfiler.Mark mark, string name, int threadId, long startTimestamp, StringStream builder)
		{
			switch (mark.Event)
			{
			case ServerProfiler.Mark.Type.Enter:
				builder.Append(",{\"name\":\"");
				builder.Append(name);
				builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadId);
				builder.Append("}");
				break;
			case ServerProfiler.Mark.Type.Exit:
			case ServerProfiler.Mark.Type.Exception:
				builder.Append(",{\"ph\":\"E\",\"ts\":");
				builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
				builder.Append(",\"pid\":0,\"tid\":");
				builder.Append(threadId);
				builder.Append("}");
				break;
			}
		}

		private static void EmitCounter(string markName, long offset, string counterName, ulong value, StringStream builder)
		{
			builder.Append(",{\"name\":\"");
			builder.Append(markName);
			builder.Append("\",\"ph\":\"C\",\"ts\":");
			builder.Append(offset);
			builder.Append(",\"args\":{\"");
			builder.Append(counterName);
			builder.Append("\":");
			builder.Append(value);
			builder.Append("}}");
		}

		private static void EmitCounter(string markName, int threadId, long offset, string counterName, ulong value, StringStream builder)
		{
			builder.Append(",{\"name\":\"");
			builder.Append(markName);
			builder.Append(" ");
			builder.Append(threadId);
			builder.Append("\",\"ph\":\"C\",\"ts\":");
			builder.Append(offset);
			builder.Append(",\"args\":{\"");
			builder.Append(counterName);
			builder.Append("\":");
			builder.Append(value);
			builder.Append("}}");
		}

		private unsafe static bool FindStartingDepth(in ServerProfiler.Profile threadProfile, uint start, uint end, out int minDepth)
		{
			int num = 0;
			minDepth = 0;
			uint readInd = start;
			while (readInd < end)
			{
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(threadProfile.Data + readInd);
				num += AdjustCallstackDepth(in mark);
				if (mark.Event == ServerProfiler.Mark.Type.Exit || mark.Event == ServerProfiler.Mark.Type.Exception)
				{
					minDepth = Math.Min(num, minDepth);
				}
				if (!AdvanceReadInd(in mark, threadProfile.Data, ref readInd))
				{
					return false;
				}
			}
			return true;
		}

		private static int AdjustCallstackDepth(in ServerProfiler.Mark mark)
		{
			switch (mark.Event)
			{
			case ServerProfiler.Mark.Type.Enter:
				return 1;
			case ServerProfiler.Mark.Type.Exit:
			case ServerProfiler.Mark.Type.Exception:
				return -1;
			default:
				return 0;
			}
		}
	}

	public static class Binary
	{
		private enum Section : byte
		{
			Info,
			Thread,
			Marks
		}

		private struct SectionBlock : IDisposable
		{
			private MemoryStream stream;

			private long startPos;

			public static SectionBlock New(Section section, MemoryStream stream)
			{
				SectionBlock result = default(SectionBlock);
				result.stream = stream;
				result.startPos = stream.Position;
				result.Begin(section);
				return result;
			}

			private void Begin(Section section)
			{
				Write(4276993775u);
				Write((byte)section);
				Write(ulong.MaxValue);
			}

			private void End()
			{
				long num = startPos + 5;
				long num2 = stream.Position - num - 8;
				byte[] buffer = stream.GetBuffer();
				for (byte b = 0; b < 8; b++)
				{
					buffer[num + b] = (byte)(num2 >> 56 - b * 8);
				}
				Write(3735928559u);
			}

			public void Write(string text)
			{
				Write((ushort)text.Length);
				for (int i = 0; i < text.Length; i++)
				{
					stream.WriteByte((byte)text[i]);
				}
			}

			public void Write(ulong value)
			{
				for (byte b = 0; b < 8; b++)
				{
					stream.WriteByte((byte)(value >> 56 - b * 8));
				}
			}

			public void Write(uint value)
			{
				for (byte b = 0; b < 4; b++)
				{
					stream.WriteByte((byte)(value >> 24 - b * 8));
				}
			}

			public void Write(ushort value)
			{
				stream.WriteByte((byte)(value >> 8));
				stream.WriteByte((byte)value);
			}

			public void Write(byte value)
			{
				stream.WriteByte(value);
			}

			void IDisposable.Dispose()
			{
				End();
			}
		}

		public unsafe static void Export(string filename, IList<ServerProfiler.Profile> profiles)
		{
			Debug.Log((object)"Starting BIN snapshot generation...");
			MemoryStream memoryStream = new MemoryStream(134217728);
			using (SectionBlock sectionBlock = SectionBlock.New(Section.Info, memoryStream))
			{
				sectionBlock.Write("Nothing");
			}
			foreach (ServerProfiler.Profile profile in profiles)
			{
				using SectionBlock sectionBlock2 = SectionBlock.New(Section.Thread, memoryStream);
				sectionBlock2.Write((uint)profile.ThreadId);
				using SectionBlock sectionBlock3 = SectionBlock.New(Section.Marks, memoryStream);
				uint readInd = 0u;
				while (readInd < profile.WriteEnd)
				{
					byte* ptr = profile.Data + readInd;
					ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
					sectionBlock3.Write((byte)mark.Event);
					sectionBlock3.Write((ulong)mark.Timestamp);
					switch (mark.Event)
					{
					case ServerProfiler.Mark.Type.Enter:
						ServerProfiler.SerializeNameTo(*(ServerProfiler.Native.MonoMethod**)(ptr + sizeof(ServerProfiler.Mark)), memoryStream);
						break;
					case ServerProfiler.Mark.Type.Alloc:
					{
						ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr + sizeof(ServerProfiler.Mark));
						ServerProfiler.SerializeNameTo(alloc, memoryStream);
						sectionBlock3.Write(alloc.AlignedSize);
						break;
					}
					}
					AdvanceReadInd(in mark, profile.Data, ref readInd);
				}
			}
			Debug.Log((object)"Generation done, compressing...");
			byte[] array = new byte[memoryStream.Position];
			Buffer.BlockCopy(memoryStream.GetBuffer(), 0, array, 0, (int)memoryStream.Position);
			string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
			if (!Directory.Exists(text))
			{
				Directory.CreateDirectory(text);
			}
			File.WriteAllBytes(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".bin.gz")), Compression.Compress(array));
			Debug.Log((object)"Snapshot bin export done!");
		}
	}

	private const string OutputDir = "profiler";

	private unsafe static void Preprocess(IList<ServerProfiler.Profile> profiles, out MainThreadInfo mainInfo, out uint totalBytes)
	{
		mainInfo = default(MainThreadInfo);
		totalBytes = 0u;
		uint num = 0u;
		foreach (ServerProfiler.Profile profile in profiles)
		{
			if (profile.ThreadId == ServerProfiler.GetMainThreadId())
			{
				mainInfo.SyncIndices = new List<uint>(10);
				mainInfo.FrameStarts = new List<uint>(10);
				sbyte b = 0;
				sbyte b2 = 0;
				uint num2 = 0u;
				uint num3 = 0u;
				uint readInd = 0u;
				while (readInd < profile.WriteEnd)
				{
					ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(profile.Data + readInd);
					switch (mark.Event)
					{
					case ServerProfiler.Mark.Type.Enter:
						b++;
						if (num3 <= num2)
						{
							num3 = readInd;
						}
						break;
					case ServerProfiler.Mark.Type.Exit:
					case ServerProfiler.Mark.Type.Exception:
						b--;
						if (b < b2)
						{
							b2 = b;
							num2 = readInd;
						}
						break;
					case ServerProfiler.Mark.Type.Sync:
						mainInfo.SyncIndices.Add(readInd);
						mainInfo.FrameStarts.Add(num3);
						mainInfo.Frames++;
						b = 0;
						b2 = 0;
						break;
					}
					AdvanceReadInd(in mark, profile.Data, ref readInd);
				}
				uint num4 = 0u;
				long num5 = profile.Timestamp;
				for (int i = 0; i < mainInfo.Frames; i++)
				{
					uint num6 = mainInfo.SyncIndices[i];
					long timestamp = Unsafe.ReadUnaligned<ServerProfiler.Mark>(profile.Data + num6).Timestamp;
					_ = ServerProfiler.TimestampToTimespan(timestamp - num5).TotalMilliseconds;
					uint num7 = num6 - num4;
					num += num7;
					num5 = timestamp;
					num4 = num6;
				}
				totalBytes += num;
			}
			else
			{
				totalBytes += profile.WriteEnd;
			}
		}
		Debug.Log((object)("Total data: " + NumberExtensions.FormatBytes<uint>(totalBytes, false) + " (main: " + NumberExtensions.FormatBytes<uint>(num, false) + ", workers: " + NumberExtensions.FormatBytes<uint>(totalBytes - num, false) + ")"));
	}

	public unsafe static bool AdvanceReadInd(in ServerProfiler.Mark mark, byte* data, ref uint readInd)
	{
		readInd += (uint)sizeof(ServerProfiler.Mark);
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			readInd += (uint)sizeof(ServerProfiler.Native.MonoMethod*);
			break;
		case ServerProfiler.Mark.Type.Alloc:
			readInd += (uint)sizeof(ServerProfiler.Alloc);
			break;
		case ServerProfiler.Mark.Type.AllocWithStack:
		{
			readInd += (uint)sizeof(ServerProfiler.Alloc);
			byte b = data[readInd];
			readInd++;
			readInd += (uint)(b * sizeof(ServerProfiler.Native.MonoMethod*));
			break;
		}
		default:
			Debug.LogError((object)"Unhandled ServerProfiler.Mark.Type!");
			return false;
		case ServerProfiler.Mark.Type.Sync:
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
		case ServerProfiler.Mark.Type.GCBegin:
		case ServerProfiler.Mark.Type.GCEnd:
			break;
		}
		return true;
	}
}


using System.Collections.Generic;

private struct MainThreadInfo
{
	public List<uint> SyncIndices;

	public List<uint> FrameStarts;

	public uint Frames;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Ionic.Zlib;
using UnityEngine;

public static class JSON
{
	private struct ThreadMetadata
	{
		internal int ThreadId;

		internal int AllocationThreadId;

		internal void Emit(StringStream builder)
		{
			bool isMainThread = ThreadId == ServerProfiler.GetMainThreadId();
			EmitThreadName(isMainThread, isAllocThread: false, ThreadId, ThreadId, builder);
			builder.Append(',');
			EmitThreadName(isMainThread, isAllocThread: true, AllocationThreadId, ThreadId, builder);
		}

		private static void EmitThreadName(bool isMainThread, bool isAllocThread, int id, int origId, StringStream builder)
		{
			builder.Append("{\"name\":\"thread_name\",\"ph\":\"M\",\"pid\":0,\"tid\":");
			builder.Append(id);
			builder.Append(",\"args\":{\"name\":\"");
			if (isMainThread)
			{
				builder.Append("Main Thread");
			}
			else
			{
				builder.Append("Thread");
			}
			if (isAllocThread)
			{
				if (!isMainThread)
				{
					builder.Append(' ');
					builder.Append(origId);
				}
				builder.Append(" Allocations");
			}
			builder.Append("\"}}");
		}
	}

	public class StringStream : MemoryStream
	{
		private GZipStream outputStream;

		public StringStream(int capacity, GZipStream outputStream)
			: base(capacity)
		{
			this.outputStream = outputStream;
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (base.Position + count < base.Capacity)
			{
				base.Write(buffer, offset, count);
				return;
			}
			int num = base.Capacity - (int)base.Position;
			if (num > 0)
			{
				base.Write(buffer, offset, num);
			}
			Flush();
			if (count - num > 0)
			{
				base.Write(buffer, offset + num, count - num);
			}
		}

		public override void Write(ReadOnlySpan<byte> source)
		{
			throw new NotSupportedException("Write(ReadOnlySpan<byte>) not implemented!");
		}

		public override void WriteByte(byte value)
		{
			if (base.Position + 1 < base.Capacity)
			{
				base.WriteByte(value);
				return;
			}
			Flush();
			base.WriteByte(value);
		}

		public void Append(char c)
		{
			WriteByte((byte)c);
		}

		public void Append(string text)
		{
			foreach (char c in text)
			{
				Append(c);
			}
		}

		public void Append(int num)
		{
			Span<char> destination = stackalloc char[32];
			num.TryFormat(destination, out var charsWritten);
			Append(destination.Slice(0, charsWritten));
		}

		public void Append(long num)
		{
			Span<char> destination = stackalloc char[32];
			num.TryFormat(destination, out var charsWritten);
			Append(destination.Slice(0, charsWritten));
		}

		public void Append(ulong num)
		{
			Span<char> destination = stackalloc char[32];
			num.TryFormat(destination, out var charsWritten);
			Append(destination.Slice(0, charsWritten));
		}

		public void Append(ReadOnlySpan<char> chars)
		{
			ReadOnlySpan<char> readOnlySpan = chars;
			for (int i = 0; i < readOnlySpan.Length; i++)
			{
				char c = readOnlySpan[i];
				Append(c);
			}
		}

		public override void Flush()
		{
			long position = Position;
			if (position > 0)
			{
				byte[] buffer = GetBuffer();
				((Stream)(object)outputStream).Write(buffer, 0, (int)position);
				Position = 0L;
			}
		}
	}

	public static bool Export(string filename, IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Expected O, but got Unknown
		try
		{
			Debug.Log((object)"Starting JSON snapshot generation...");
			Preprocess(profiles, out var mainInfo, out var _);
			string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
			if (!Directory.Exists(text))
			{
				Directory.CreateDirectory(text);
			}
			using (FileStream fileStream = new FileStream(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".json.gz")), FileMode.Create, FileAccess.Write, FileShare.None, 20480))
			{
				GZipStream val = new GZipStream((Stream)fileStream, (CompressionMode)0);
				try
				{
					val.FlushMode = (FlushType)2;
					using StringStream stringStream = new StringStream(16384, val);
					stringStream.Append('[');
					int num = 0;
					foreach (ServerProfiler.Profile profile2 in profiles)
					{
						num = Math.Max(num, profile2.ThreadId);
					}
					List<ThreadMetadata> list = new List<ThreadMetadata>();
					for (int i = 0; i < profiles.Count; i++)
					{
						ServerProfiler.Profile profile = profiles[i];
						ThreadMetadata item = default(ThreadMetadata);
						item.ThreadId = profile.ThreadId;
						num = (item.AllocationThreadId = num + 1);
						if (i != 0)
						{
							stringStream.Append(',');
						}
						item.Emit(stringStream);
						list.Add(item);
					}
					long firstMarkTimestamp = 0L;
					for (int j = 0; j < profiles.Count; j++)
					{
						ServerProfiler.Profile mainProfile = profiles[j];
						if (mainProfile.ThreadId == ServerProfiler.GetMainThreadId())
						{
							if (ProcessMainProfile(in mainProfile, in mainInfo, list[j], stringStream, out firstMarkTimestamp))
							{
								break;
							}
							return false;
						}
					}
					for (int k = 0; k < profiles.Count; k++)
					{
						ServerProfiler.Profile workerProfile = profiles[k];
						if (workerProfile.ThreadId != ServerProfiler.GetMainThreadId() && !ProcessWorkerProfile(in workerProfile, list[k], firstMarkTimestamp, stringStream))
						{
							return false;
						}
					}
					ProcessMemoryState(in memState, firstMarkTimestamp, stringStream);
					stringStream.Append("]");
					stringStream.Flush();
					Debug.Log((object)"Generation done, flushing...");
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			Debug.Log((object)"Snapshot json export done!");
			return true;
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			return false;
		}
	}

	private unsafe static bool ProcessMainProfile(in ServerProfiler.Profile mainProfile, in MainThreadInfo info, in ThreadMetadata metadata, StringStream builder, out long firstMarkTimestamp)
	{
		if (info.FrameStarts == null || info.Frames == 0)
		{
			Debug.LogError((object)"ServerProfiler: Didn't find any main frame info!");
			firstMarkTimestamp = 0L;
			return false;
		}
		int num = 0;
		byte* data = mainProfile.Data;
		uint num2 = info.FrameStarts[0];
		firstMarkTimestamp = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num2).Timestamp;
		long num3 = 0L;
		for (int i = 0; i < info.Frames; i++)
		{
			uint num4 = info.FrameStarts[i];
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num4);
			uint num5 = mainProfile.WriteEnd;
			if (i < info.Frames - 1)
			{
				num5 = info.FrameStarts[i + 1];
			}
			ServerProfiler.Mark mark2 = default(ServerProfiler.Mark);
			mark2.Event = ServerProfiler.Mark.Type.Enter;
			mark2.Timestamp = mark.Timestamp;
			AddMark(mark2, $"UnityFrame{i}", mainProfile.ThreadId, firstMarkTimestamp, builder);
			uint totalMem = 0u;
			long offset = ServerProfiler.TimestampToMicros(mark.Timestamp - firstMarkTimestamp);
			EmitCounter("Main Thread", offset, "Total(B)", totalMem, builder);
			uint readInd = num4;
			while (readInd < num5)
			{
				ServerProfiler.Mark mark3 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + readInd);
				num3 = mark3.Timestamp;
				num += AdjustCallstackDepth(in mark3);
				if (num < 0)
				{
					Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {num}, offset: {readInd}, frame: {i}");
					return false;
				}
				AddMark(in mainProfile, in metadata, readInd, ref totalMem, firstMarkTimestamp, builder);
				if (!AdvanceReadInd(in mark3, data, ref readInd))
				{
					return false;
				}
			}
			long timestamp = ((i < info.Frames - 1) ? Unsafe.ReadUnaligned<ServerProfiler.Mark>(data + num5).Timestamp : num3);
			mark2 = default(ServerProfiler.Mark);
			mark2.Event = ServerProfiler.Mark.Type.Exit;
			mark2.Timestamp = timestamp;
			AddMark(mark2, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
		}
		while (num > 0)
		{
			ServerProfiler.Mark mark4 = default(ServerProfiler.Mark);
			mark4.Event = ServerProfiler.Mark.Type.Exit;
			mark4.Timestamp = num3;
			AddMark(mark4, null, mainProfile.ThreadId, firstMarkTimestamp, builder);
			num--;
		}
		return true;
	}

	private unsafe static bool ProcessWorkerProfile(in ServerProfiler.Profile workerProfile, in ThreadMetadata metadata, long firstMarkTimestamp, StringStream builder)
	{
		uint readInd = 0u;
		int num = 0;
		while (readInd < workerProfile.WriteEnd)
		{
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd);
			if (mark.Timestamp >= firstMarkTimestamp)
			{
				break;
			}
			if (mark.Event == ServerProfiler.Mark.Type.Sync)
			{
				Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
				return false;
			}
			num += AdjustCallstackDepth(in mark);
			if (!AdvanceReadInd(in mark, workerProfile.Data, ref readInd))
			{
				return false;
			}
		}
		if (readInd >= workerProfile.WriteEnd)
		{
			return true;
		}
		bool flag = false;
		uint readInd2 = readInd;
		while (readInd2 < workerProfile.WriteEnd)
		{
			ServerProfiler.Mark mark2 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd2);
			if (mark2.Event == ServerProfiler.Mark.Type.Sync)
			{
				Debug.LogError((object)"Unexpected mark in worker stream, aborting!");
				return false;
			}
			if (mark2.Event != ServerProfiler.Mark.Type.Alloc)
			{
				flag = true;
				break;
			}
			if (!AdvanceReadInd(in mark2, workerProfile.Data, ref readInd2))
			{
				return false;
			}
		}
		if (!flag)
		{
			return true;
		}
		if (!FindStartingDepth(in workerProfile, 0u, workerProfile.WriteEnd, out var minDepth))
		{
			return false;
		}
		minDepth = num - minDepth;
		for (int num2 = minDepth; num2 > 0; num2--)
		{
			ServerProfiler.Mark mark3 = default(ServerProfiler.Mark);
			mark3.Event = ServerProfiler.Mark.Type.Enter;
			mark3.Timestamp = firstMarkTimestamp;
			AddMark(mark3, "Unknown", workerProfile.ThreadId, firstMarkTimestamp, builder);
		}
		uint totalMem = 0u;
		long timestamp = 0L;
		uint readInd3 = readInd;
		while (readInd3 < workerProfile.WriteEnd)
		{
			ServerProfiler.Mark mark4 = Unsafe.ReadUnaligned<ServerProfiler.Mark>(workerProfile.Data + readInd3);
			timestamp = mark4.Timestamp;
			minDepth += AdjustCallstackDepth(in mark4);
			if (minDepth < 0)
			{
				Debug.LogError((object)$"ServerProfiler: Unexpected callstack depth: {minDepth}, offset: {readInd3}, thread: {workerProfile.ThreadId}");
				return false;
			}
			if (mark4.Event == ServerProfiler.Mark.Type.Alloc || (mark4.Event == ServerProfiler.Mark.Type.AllocWithStack && totalMem == 0))
			{
				EmitCounter("Thread", metadata.ThreadId, 0L, "Total(B)", 0uL, builder);
			}
			AddMark(in workerProfile, in metadata, readInd3, ref totalMem, firstMarkTimestamp, builder);
			if (!AdvanceReadInd(in mark4, workerProfile.Data, ref readInd3))
			{
				return false;
			}
		}
		while (minDepth > 0)
		{
			ServerProfiler.Mark mark5 = default(ServerProfiler.Mark);
			mark5.Event = ServerProfiler.Mark.Type.Exit;
			mark5.Timestamp = timestamp;
			AddMark(mark5, null, workerProfile.ThreadId, firstMarkTimestamp, builder);
			minDepth--;
		}
		return true;
	}

	private unsafe static void ProcessMemoryState(in ServerProfiler.MemoryState memState, long firstMarkTimestamp, StringStream builder)
	{
		ulong num = 0uL;
		ulong num2 = 0uL;
		for (uint num3 = 0u; num3 < memState.Created; num3++)
		{
			ServerProfiler.MemoryReading memoryReading = memState.Readings[num3];
			long timestamp = memoryReading.Timestamp;
			if (timestamp >= firstMarkTimestamp)
			{
				ulong num4 = memoryReading.WorkingSet / 1024;
				if (num4 != num)
				{
					long offset = ((num == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
					EmitCounter("ws", offset, "WorkingSet(KB)", num4, builder);
					num = num4;
				}
				ulong num5 = memoryReading.VirtualSet / 1024;
				if (num5 != num2)
				{
					long offset2 = ((num2 == 0L) ? 0 : ServerProfiler.TimestampToMicros(timestamp - firstMarkTimestamp));
					EmitCounter("vs", offset2, "VirtualSet(KB)", num5, builder);
					num2 = num5;
				}
			}
		}
	}

	private unsafe static void AddMark(in ServerProfiler.Profile threadProfile, in ThreadMetadata metadata, uint markInd, ref uint totalMem, long startTimestamp, StringStream builder)
	{
		byte* ptr = threadProfile.Data + markInd;
		ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
		ptr += sizeof(ServerProfiler.Mark);
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			builder.Append(",{\"name\":\"");
			ServerProfiler.AppendNameTo(*(ServerProfiler.Native.MonoMethod**)ptr, builder);
			builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append("}");
			break;
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
		case ServerProfiler.Mark.Type.GCEnd:
			builder.Append(",{\"ph\":\"E\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append("}");
			break;
		case ServerProfiler.Mark.Type.Alloc:
		{
			ServerProfiler.Alloc alloc2 = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
			long num2 = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
			builder.Append(",{\"name\":\"");
			builder.Append("Alloc ");
			builder.Append(alloc2.AlignedSize);
			builder.Append("b\",\"ph\":\"i\",\"ts\":");
			builder.Append(num2);
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
			builder.Append(alloc2.AlignedSize);
			builder.Append(",\"type\":\"");
			ServerProfiler.AppendNameTo(alloc2, builder);
			builder.Append("\",\"lastMethod\":\"");
			if (alloc2.LastMethod != null)
			{
				ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
			}
			else
			{
				builder.Append("<mono-native-runtime>");
			}
			builder.Append("\"}}");
			builder.Append(",{\"name\":\"");
			builder.Append("Alloc ");
			builder.Append(alloc2.AlignedSize);
			builder.Append("b\",\"ph\":\"i\",\"ts\":");
			builder.Append(num2);
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(metadata.AllocationThreadId);
			builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
			builder.Append(alloc2.AlignedSize);
			builder.Append(",\"type\":\"");
			ServerProfiler.AppendNameTo(alloc2, builder);
			builder.Append("\",\"lastMethod\":\"");
			if (alloc2.LastMethod != null)
			{
				ServerProfiler.AppendNameTo(alloc2.LastMethod, builder);
			}
			else
			{
				builder.Append("<mono-native-runtime>");
			}
			builder.Append("\"}}");
			totalMem += alloc2.AlignedSize;
			if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
			{
				EmitCounter("Main Thread", num2, "Total(B)", totalMem, builder);
			}
			else
			{
				EmitCounter("Thread", metadata.ThreadId, num2, "Total(B)", totalMem, builder);
			}
			break;
		}
		case ServerProfiler.Mark.Type.AllocWithStack:
		{
			ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr);
			ptr += sizeof(ServerProfiler.Alloc);
			long num = ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp);
			builder.Append(",{\"name\":\"");
			builder.Append("Alloc ");
			builder.Append(alloc.AlignedSize);
			builder.Append("b\",\"ph\":\"i\",\"ts\":");
			builder.Append(num);
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(metadata.ThreadId);
			builder.Append(",\"s\":\"t\",\"cat\":\"A\",\"args\":{\"size\":");
			builder.Append(alloc.AlignedSize);
			builder.Append(",\"type\":\"");
			ServerProfiler.AppendNameTo(alloc, builder);
			builder.Append("\",\"lastMethod\":\"");
			if (alloc.LastMethod != null)
			{
				ServerProfiler.AppendNameTo(alloc.LastMethod, builder);
			}
			else
			{
				builder.Append("<mono-native-runtime>");
			}
			builder.Append('"');
			byte b = *ptr;
			ptr++;
			if (b > 0)
			{
				builder.Append(",\"callstack\":{");
				ServerProfiler.Native.MonoMethod** ptr2 = (ServerProfiler.Native.MonoMethod**)ptr;
				for (byte b2 = 0; b2 < b; b2++)
				{
					ServerProfiler.Native.MonoMethod* method = ptr2[(int)b2];
					builder.Append('"');
					char c = (char)(b2 + 32);
					if (c >= '"')
					{
						c = (char)(c + 1);
					}
					if (c >= '.')
					{
						c = (char)(c + 1);
					}
					if (c >= '\\')
					{
						c = (char)(c + 1);
					}
					if (c < '\u007f')
					{
						builder.Append(c);
					}
					else
					{
						builder.Append(b2);
					}
					builder.Append("\":\"");
					ServerProfiler.AppendNameTo(method, builder);
					builder.Append('"');
					if (b2 != b - 1)
					{
						builder.Append(',');
					}
				}
				builder.Append('}');
			}
			builder.Append("}}");
			totalMem += alloc.AlignedSize;
			if (metadata.ThreadId == ServerProfiler.GetMainThreadId())
			{
				EmitCounter("Main Thread", num, "Total(B)", totalMem, builder);
			}
			else
			{
				EmitCounter("Thread", metadata.ThreadId, num, "Total(B)", totalMem, builder);
			}
			break;
		}
		case ServerProfiler.Mark.Type.GCBegin:
			builder.Append(",{\"name\":\"");
			builder.Append("GC.Collect");
			builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadProfile.ThreadId);
			builder.Append("}");
			break;
		}
	}

	private static void AddMark(ServerProfiler.Mark mark, string name, int threadId, long startTimestamp, StringStream builder)
	{
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			builder.Append(",{\"name\":\"");
			builder.Append(name);
			builder.Append("\",\"cat\":\"P\",\"ph\":\"B\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadId);
			builder.Append("}");
			break;
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
			builder.Append(",{\"ph\":\"E\",\"ts\":");
			builder.Append(ServerProfiler.TimestampToMicros(mark.Timestamp - startTimestamp));
			builder.Append(",\"pid\":0,\"tid\":");
			builder.Append(threadId);
			builder.Append("}");
			break;
		}
	}

	private static void EmitCounter(string markName, long offset, string counterName, ulong value, StringStream builder)
	{
		builder.Append(",{\"name\":\"");
		builder.Append(markName);
		builder.Append("\",\"ph\":\"C\",\"ts\":");
		builder.Append(offset);
		builder.Append(",\"args\":{\"");
		builder.Append(counterName);
		builder.Append("\":");
		builder.Append(value);
		builder.Append("}}");
	}

	private static void EmitCounter(string markName, int threadId, long offset, string counterName, ulong value, StringStream builder)
	{
		builder.Append(",{\"name\":\"");
		builder.Append(markName);
		builder.Append(" ");
		builder.Append(threadId);
		builder.Append("\",\"ph\":\"C\",\"ts\":");
		builder.Append(offset);
		builder.Append(",\"args\":{\"");
		builder.Append(counterName);
		builder.Append("\":");
		builder.Append(value);
		builder.Append("}}");
	}

	private unsafe static bool FindStartingDepth(in ServerProfiler.Profile threadProfile, uint start, uint end, out int minDepth)
	{
		int num = 0;
		minDepth = 0;
		uint readInd = start;
		while (readInd < end)
		{
			ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(threadProfile.Data + readInd);
			num += AdjustCallstackDepth(in mark);
			if (mark.Event == ServerProfiler.Mark.Type.Exit || mark.Event == ServerProfiler.Mark.Type.Exception)
			{
				minDepth = Math.Min(num, minDepth);
			}
			if (!AdvanceReadInd(in mark, threadProfile.Data, ref readInd))
			{
				return false;
			}
		}
		return true;
	}

	private static int AdjustCallstackDepth(in ServerProfiler.Mark mark)
	{
		switch (mark.Event)
		{
		case ServerProfiler.Mark.Type.Enter:
			return 1;
		case ServerProfiler.Mark.Type.Exit:
		case ServerProfiler.Mark.Type.Exception:
			return -1;
		default:
			return 0;
		}
	}
}


private struct ThreadMetadata
{
	internal int ThreadId;

	internal int AllocationThreadId;

	internal void Emit(StringStream builder)
	{
		bool isMainThread = ThreadId == ServerProfiler.GetMainThreadId();
		EmitThreadName(isMainThread, isAllocThread: false, ThreadId, ThreadId, builder);
		builder.Append(',');
		EmitThreadName(isMainThread, isAllocThread: true, AllocationThreadId, ThreadId, builder);
	}

	private static void EmitThreadName(bool isMainThread, bool isAllocThread, int id, int origId, StringStream builder)
	{
		builder.Append("{\"name\":\"thread_name\",\"ph\":\"M\",\"pid\":0,\"tid\":");
		builder.Append(id);
		builder.Append(",\"args\":{\"name\":\"");
		if (isMainThread)
		{
			builder.Append("Main Thread");
		}
		else
		{
			builder.Append("Thread");
		}
		if (isAllocThread)
		{
			if (!isMainThread)
			{
				builder.Append(' ');
				builder.Append(origId);
			}
			builder.Append(" Allocations");
		}
		builder.Append("\"}}");
	}
}


using System;
using System.IO;
using Ionic.Zlib;

public class StringStream : MemoryStream
{
	private GZipStream outputStream;

	public StringStream(int capacity, GZipStream outputStream)
		: base(capacity)
	{
		this.outputStream = outputStream;
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		if (base.Position + count < base.Capacity)
		{
			base.Write(buffer, offset, count);
			return;
		}
		int num = base.Capacity - (int)base.Position;
		if (num > 0)
		{
			base.Write(buffer, offset, num);
		}
		Flush();
		if (count - num > 0)
		{
			base.Write(buffer, offset + num, count - num);
		}
	}

	public override void Write(ReadOnlySpan<byte> source)
	{
		throw new NotSupportedException("Write(ReadOnlySpan<byte>) not implemented!");
	}

	public override void WriteByte(byte value)
	{
		if (base.Position + 1 < base.Capacity)
		{
			base.WriteByte(value);
			return;
		}
		Flush();
		base.WriteByte(value);
	}

	public void Append(char c)
	{
		WriteByte((byte)c);
	}

	public void Append(string text)
	{
		foreach (char c in text)
		{
			Append(c);
		}
	}

	public void Append(int num)
	{
		Span<char> destination = stackalloc char[32];
		num.TryFormat(destination, out var charsWritten);
		Append(destination.Slice(0, charsWritten));
	}

	public void Append(long num)
	{
		Span<char> destination = stackalloc char[32];
		num.TryFormat(destination, out var charsWritten);
		Append(destination.Slice(0, charsWritten));
	}

	public void Append(ulong num)
	{
		Span<char> destination = stackalloc char[32];
		num.TryFormat(destination, out var charsWritten);
		Append(destination.Slice(0, charsWritten));
	}

	public void Append(ReadOnlySpan<char> chars)
	{
		ReadOnlySpan<char> readOnlySpan = chars;
		for (int i = 0; i < readOnlySpan.Length; i++)
		{
			char c = readOnlySpan[i];
			Append(c);
		}
	}

	public override void Flush()
	{
		long position = Position;
		if (position > 0)
		{
			byte[] buffer = GetBuffer();
			((Stream)(object)outputStream).Write(buffer, 0, (int)position);
			Position = 0L;
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch.Utility;
using UnityEngine;

public static class Binary
{
	private enum Section : byte
	{
		Info,
		Thread,
		Marks
	}

	private struct SectionBlock : IDisposable
	{
		private MemoryStream stream;

		private long startPos;

		public static SectionBlock New(Section section, MemoryStream stream)
		{
			SectionBlock result = default(SectionBlock);
			result.stream = stream;
			result.startPos = stream.Position;
			result.Begin(section);
			return result;
		}

		private void Begin(Section section)
		{
			Write(4276993775u);
			Write((byte)section);
			Write(ulong.MaxValue);
		}

		private void End()
		{
			long num = startPos + 5;
			long num2 = stream.Position - num - 8;
			byte[] buffer = stream.GetBuffer();
			for (byte b = 0; b < 8; b++)
			{
				buffer[num + b] = (byte)(num2 >> 56 - b * 8);
			}
			Write(3735928559u);
		}

		public void Write(string text)
		{
			Write((ushort)text.Length);
			for (int i = 0; i < text.Length; i++)
			{
				stream.WriteByte((byte)text[i]);
			}
		}

		public void Write(ulong value)
		{
			for (byte b = 0; b < 8; b++)
			{
				stream.WriteByte((byte)(value >> 56 - b * 8));
			}
		}

		public void Write(uint value)
		{
			for (byte b = 0; b < 4; b++)
			{
				stream.WriteByte((byte)(value >> 24 - b * 8));
			}
		}

		public void Write(ushort value)
		{
			stream.WriteByte((byte)(value >> 8));
			stream.WriteByte((byte)value);
		}

		public void Write(byte value)
		{
			stream.WriteByte(value);
		}

		void IDisposable.Dispose()
		{
			End();
		}
	}

	public unsafe static void Export(string filename, IList<ServerProfiler.Profile> profiles)
	{
		Debug.Log((object)"Starting BIN snapshot generation...");
		MemoryStream memoryStream = new MemoryStream(134217728);
		using (SectionBlock sectionBlock = SectionBlock.New(Section.Info, memoryStream))
		{
			sectionBlock.Write("Nothing");
		}
		foreach (ServerProfiler.Profile profile in profiles)
		{
			using SectionBlock sectionBlock2 = SectionBlock.New(Section.Thread, memoryStream);
			sectionBlock2.Write((uint)profile.ThreadId);
			using SectionBlock sectionBlock3 = SectionBlock.New(Section.Marks, memoryStream);
			uint readInd = 0u;
			while (readInd < profile.WriteEnd)
			{
				byte* ptr = profile.Data + readInd;
				ServerProfiler.Mark mark = Unsafe.ReadUnaligned<ServerProfiler.Mark>(ptr);
				sectionBlock3.Write((byte)mark.Event);
				sectionBlock3.Write((ulong)mark.Timestamp);
				switch (mark.Event)
				{
				case ServerProfiler.Mark.Type.Enter:
					ServerProfiler.SerializeNameTo(*(ServerProfiler.Native.MonoMethod**)(ptr + sizeof(ServerProfiler.Mark)), memoryStream);
					break;
				case ServerProfiler.Mark.Type.Alloc:
				{
					ServerProfiler.Alloc alloc = Unsafe.ReadUnaligned<ServerProfiler.Alloc>(ptr + sizeof(ServerProfiler.Mark));
					ServerProfiler.SerializeNameTo(alloc, memoryStream);
					sectionBlock3.Write(alloc.AlignedSize);
					break;
				}
				}
				AdvanceReadInd(in mark, profile.Data, ref readInd);
			}
		}
		Debug.Log((object)"Generation done, compressing...");
		byte[] array = new byte[memoryStream.Position];
		Buffer.BlockCopy(memoryStream.GetBuffer(), 0, array, 0, (int)memoryStream.Position);
		string text = Path.Join((ReadOnlySpan<char>)Server.rootFolder, (ReadOnlySpan<char>)"profiler");
		if (!Directory.Exists(text))
		{
			Directory.CreateDirectory(text);
		}
		File.WriteAllBytes(Path.Join((ReadOnlySpan<char>)text, (ReadOnlySpan<char>)(filename + ".bin.gz")), Compression.Compress(array));
		Debug.Log((object)"Snapshot bin export done!");
	}
}


private enum Section : byte
{
	Info,
	Thread,
	Marks
}


using System;
using System.IO;

private struct SectionBlock : IDisposable
{
	private MemoryStream stream;

	private long startPos;

	public static SectionBlock New(Section section, MemoryStream stream)
	{
		SectionBlock result = default(SectionBlock);
		result.stream = stream;
		result.startPos = stream.Position;
		result.Begin(section);
		return result;
	}

	private void Begin(Section section)
	{
		Write(4276993775u);
		Write((byte)section);
		Write(ulong.MaxValue);
	}

	private void End()
	{
		long num = startPos + 5;
		long num2 = stream.Position - num - 8;
		byte[] buffer = stream.GetBuffer();
		for (byte b = 0; b < 8; b++)
		{
			buffer[num + b] = (byte)(num2 >> 56 - b * 8);
		}
		Write(3735928559u);
	}

	public void Write(string text)
	{
		Write((ushort)text.Length);
		for (int i = 0; i < text.Length; i++)
		{
			stream.WriteByte((byte)text[i]);
		}
	}

	public void Write(ulong value)
	{
		for (byte b = 0; b < 8; b++)
		{
			stream.WriteByte((byte)(value >> 56 - b * 8));
		}
	}

	public void Write(uint value)
	{
		for (byte b = 0; b < 4; b++)
		{
			stream.WriteByte((byte)(value >> 24 - b * 8));
		}
	}

	public void Write(ushort value)
	{
		stream.WriteByte((byte)(value >> 8));
		stream.WriteByte((byte)value);
	}

	public void Write(byte value)
	{
		stream.WriteByte(value);
	}

	void IDisposable.Dispose()
	{
		End();
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using UnityEngine;

[SuppressUnmanagedCodeSecurity]
public static class ServerProfiler
{
	[StructLayout(LayoutKind.Sequential, Pack = 1, Size = 9)]
	public struct Mark
	{
		public enum Type : byte
		{
			Sync,
			Enter,
			Exit,
			Exception,
			Alloc,
			GCBegin,
			GCEnd,
			AllocWithStack
		}

		public long Timestamp;

		public Type Event;
	}

	public struct Alloc
	{
		public unsafe Native.MonoClass* Class;

		public unsafe Native.MonoMethod* LastMethod;

		public uint AlignedSize;

		public uint FlatArraySize;
	}

	public struct Profile
	{
		public unsafe byte* Data;

		private uint WriteInd;

		public uint Capacity;

		public uint WriteEnd;

		public int ThreadId;

		public long Timestamp;
	}

	[StructLayout(LayoutKind.Sequential, Size = 64)]
	public struct MemoryReading
	{
		public long Timestamp;

		public ulong WorkingSet;

		public ulong VirtualSet;
	}

	public struct MemoryState
	{
		public unsafe MemoryReading* Readings;

		public uint Created;

		public uint Capacity;
	}

	public enum NotifyMetric : byte
	{
		TotalAllocCount,
		TotalMem,
		MainAllocCount,
		MainMem,
		WorkerAllocCount,
		WorkerMem,
		Count
	}

	public static class Native
	{
		[StructLayout(LayoutKind.Explicit)]
		public struct MonoImage
		{
			[FieldOffset(48)]
			public unsafe byte* AssemblyName;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoClass
		{
			private const int ImageOffset = 56;

			[FieldOffset(56)]
			public unsafe MonoImage* Image;

			[FieldOffset(64)]
			public unsafe byte* Name;

			[FieldOffset(72)]
			public unsafe byte* Namespace;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoMethod
		{
			[FieldOffset(8)]
			public unsafe MonoClass* Class;

			[FieldOffset(24)]
			public unsafe byte* Name;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoVTable
		{
			[FieldOffset(0)]
			public unsafe MonoClass* Class;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct MonoObject
		{
			[FieldOffset(0)]
			public unsafe MonoVTable* VTable;
		}

		public enum StorageType : byte
		{
			FrameLimited,
			FixedBuffer
		}

		[DllImport("ServerProfiler.Core")]
		public static extern void Install();

		[DllImport("ServerProfiler.Core")]
		public static extern void SetStorageType(byte aStorageType);

		[DllImport("ServerProfiler.Core")]
		public static extern bool SetFramesToRecord(byte aFrameCount);

		[DllImport("ServerProfiler.Core")]
		public static extern bool SetFixedBufferCap(uint aMainThreadCap, uint aWorkerThreadCap);

		[DllImport("ServerProfiler.Core")]
		public static extern void TakeSnapshot();

		[DllImport("ServerProfiler.Core")]
		public static extern void StartContinuousProfiling(byte aMaxStackDepth);

		[DllImport("ServerProfiler.Core")]
		public static extern void StopContinuousProfiling();

		[DllImport("ServerProfiler.Core")]
		public static extern void ResumeContinuousProfiling();

		[DllImport("ServerProfiler.Core")]
		public static extern void SetContinuousProfilerNotifySettings(NotifyMetric aSetting, uint aValue);

		[DllImport("ServerProfiler.Core")]
		public static extern bool OnFrameEnd();

		[DllImport("ServerProfiler.Core")]
		public unsafe static extern void GetData(out Profile** profiles, out byte count);

		[DllImport("ServerProfiler.Core")]
		public unsafe static extern void GetMemoryUsage(out MemoryState* state);

		[DllImport("ServerProfiler.Core")]
		public static extern bool ReleaseResources();
	}

	public const byte MaxFrames = 10;

	private static bool canBeActivated;

	private static Action<IList<Profile>, MemoryState> onDoneCallback;

	private static bool isContinuous;

	private static int mainThreadId;

	public static bool IsRunning => onDoneCallback != null;

	[RuntimeInitializeOnLoadMethod(/*Could not decode attribute arguments.*/)]
	public static void Init()
	{
		if (!Environment.CommandLine.Contains("-enableProfiler"))
		{
			Debug.Log((object)"Profiler Disabled!");
			return;
		}
		mainThreadId = Environment.CurrentManagedThreadId;
		Native.Install();
		canBeActivated = true;
		Debug.Log((object)"Profiler Initialized!");
		PostUpdateHook.EndOfFrame = (Action)Delegate.Combine(PostUpdateHook.EndOfFrame, new Action(OnFrameEnd));
	}

	public static void RecordNextFrames(int frames, Action<IList<Profile>, MemoryState> onDone)
	{
		if (onDone != null && IsEnabled())
		{
			onDoneCallback = onDone;
			Native.SetStorageType(0);
			Native.SetFramesToRecord((byte)Math.Clamp(frames, 1, 10));
			Native.TakeSnapshot();
			isContinuous = false;
		}
	}

	public static void RecordIntoBuffer(uint mainThreadCap, uint workerThreadCap, Action<IList<Profile>, MemoryState> onDone)
	{
		if (onDone != null && IsEnabled())
		{
			onDoneCallback = onDone;
			Native.SetStorageType(1);
			Native.SetFixedBufferCap(mainThreadCap, workerThreadCap);
			Native.TakeSnapshot();
			isContinuous = false;
		}
	}

	public static void StartContinuousRecording(byte maxStackDepth, Action<IList<Profile>, MemoryState> onDone)
	{
		if (onDone != null && IsEnabled())
		{
			onDoneCallback = onDone;
			Native.SetStorageType(1);
			Native.SetFixedBufferCap(33554432u, 8388608u);
			Native.StartContinuousProfiling(maxStackDepth);
			isContinuous = true;
		}
	}

	public static void StopContinuousRecording()
	{
		Native.StopContinuousProfiling();
		onDoneCallback = null;
	}

	public static void ResumeContinuousRecording()
	{
		Native.ResumeContinuousProfiling();
	}

	public static void ReleaseResources()
	{
		Native.ReleaseResources();
	}

	public static bool IsEnabled()
	{
		return canBeActivated;
	}

	private unsafe static void OnFrameEnd()
	{
		if (!Native.OnFrameEnd())
		{
			return;
		}
		List<Profile> list = null;
		Native.GetData(out var profiles, out var count);
		list = new List<Profile>(count);
		for (byte b = 0; b < count; b++)
		{
			if (profiles[(int)b]->WriteEnd != 0)
			{
				list.Add(*profiles[(int)b]);
			}
		}
		Native.GetMemoryUsage(out var state);
		MemoryState arg = *state;
		onDoneCallback(list, arg);
		if (!isContinuous)
		{
			onDoneCallback = null;
		}
	}

	public static TimeSpan TimestampToTimespan(long stamp)
	{
		return TimeSpan.FromMilliseconds((double)stamp / 1000000.0);
	}

	public static long TimestampToMicros(long stamp)
	{
		return stamp / 1000;
	}

	public unsafe static void AppendNameTo(Native.MonoMethod* method, StringBuilder builder)
	{
		for (byte* ptr = method->Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = method->Class->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append("::");
		for (byte* ptr = method->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
	}

	public unsafe static void AppendNameTo(Native.MonoMethod* method, ProfileExporter.JSON.StringStream builder)
	{
		for (byte* ptr = method->Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = method->Class->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append("::");
		for (byte* ptr = method->Name; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
	}

	public unsafe static void SerializeNameTo(Native.MonoMethod* method, MemoryStream stream)
	{
		long position = stream.Position;
		ushort num = 0;
		stream.WriteByte(0);
		stream.WriteByte(0);
		byte* ptr = method->Class->Image->AssemblyName;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		stream.WriteByte(33);
		num++;
		ptr = method->Class->Name;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		stream.WriteByte(58);
		stream.WriteByte(58);
		num += 2;
		ptr = method->Name;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		byte[] buffer = stream.GetBuffer();
		buffer[position] = (byte)(num >> 8);
		buffer[position + 1] = (byte)num;
	}

	public unsafe static void AppendNameTo(Alloc alloc, StringBuilder builder)
	{
		for (byte* ptr = alloc.Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = alloc.Class->Name; *ptr != 0; ptr++)
		{
			char c = (char)(*ptr);
			builder.Append(c);
			if (alloc.FlatArraySize != 0 && c == '[')
			{
				builder.Append(alloc.FlatArraySize);
			}
		}
	}

	public unsafe static void AppendNameTo(Alloc alloc, ProfileExporter.JSON.StringStream builder)
	{
		for (byte* ptr = alloc.Class->Image->AssemblyName; *ptr != 0; ptr++)
		{
			builder.Append((char)(*ptr));
		}
		builder.Append('!');
		for (byte* ptr = alloc.Class->Name; *ptr != 0; ptr++)
		{
			char c = (char)(*ptr);
			builder.Append(c);
			if (alloc.FlatArraySize != 0 && c == '[')
			{
				builder.Append(alloc.FlatArraySize);
			}
		}
	}

	public unsafe static void SerializeNameTo(Alloc alloc, MemoryStream stream)
	{
		long position = stream.Position;
		ushort num = 0;
		stream.WriteByte(0);
		stream.WriteByte(0);
		byte* ptr = alloc.Class->Image->AssemblyName;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		stream.WriteByte(33);
		num++;
		ptr = alloc.Class->Name;
		while (*ptr != 0)
		{
			stream.WriteByte(*ptr);
			ptr++;
			num++;
		}
		byte[] buffer = stream.GetBuffer();
		buffer[position] = (byte)(num >> 8);
		buffer[position + 1] = (byte)num;
	}

	public static int GetMainThreadId()
	{
		return mainThreadId;
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 1, Size = 9)]
public struct Mark
{
	public enum Type : byte
	{
		Sync,
		Enter,
		Exit,
		Exception,
		Alloc,
		GCBegin,
		GCEnd,
		AllocWithStack
	}

	public long Timestamp;

	public Type Event;
}


public enum Type : byte
{
	Sync,
	Enter,
	Exit,
	Exception,
	Alloc,
	GCBegin,
	GCEnd,
	AllocWithStack
}


public struct Alloc
{
	public unsafe Native.MonoClass* Class;

	public unsafe Native.MonoMethod* LastMethod;

	public uint AlignedSize;

	public uint FlatArraySize;
}


public struct Profile
{
	public unsafe byte* Data;

	private uint WriteInd;

	public uint Capacity;

	public uint WriteEnd;

	public int ThreadId;

	public long Timestamp;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 64)]
public struct MemoryReading
{
	public long Timestamp;

	public ulong WorkingSet;

	public ulong VirtualSet;
}


public struct MemoryState
{
	public unsafe MemoryReading* Readings;

	public uint Created;

	public uint Capacity;
}


public enum NotifyMetric : byte
{
	TotalAllocCount,
	TotalMem,
	MainAllocCount,
	MainMem,
	WorkerAllocCount,
	WorkerMem,
	Count
}


using System.Runtime.InteropServices;

public static class Native
{
	[StructLayout(LayoutKind.Explicit)]
	public struct MonoImage
	{
		[FieldOffset(48)]
		public unsafe byte* AssemblyName;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoClass
	{
		private const int ImageOffset = 56;

		[FieldOffset(56)]
		public unsafe MonoImage* Image;

		[FieldOffset(64)]
		public unsafe byte* Name;

		[FieldOffset(72)]
		public unsafe byte* Namespace;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoMethod
	{
		[FieldOffset(8)]
		public unsafe MonoClass* Class;

		[FieldOffset(24)]
		public unsafe byte* Name;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoVTable
	{
		[FieldOffset(0)]
		public unsafe MonoClass* Class;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct MonoObject
	{
		[FieldOffset(0)]
		public unsafe MonoVTable* VTable;
	}

	public enum StorageType : byte
	{
		FrameLimited,
		FixedBuffer
	}

	[DllImport("ServerProfiler.Core")]
	public static extern void Install();

	[DllImport("ServerProfiler.Core")]
	public static extern void SetStorageType(byte aStorageType);

	[DllImport("ServerProfiler.Core")]
	public static extern bool SetFramesToRecord(byte aFrameCount);

	[DllImport("ServerProfiler.Core")]
	public static extern bool SetFixedBufferCap(uint aMainThreadCap, uint aWorkerThreadCap);

	[DllImport("ServerProfiler.Core")]
	public static extern void TakeSnapshot();

	[DllImport("ServerProfiler.Core")]
	public static extern void StartContinuousProfiling(byte aMaxStackDepth);

	[DllImport("ServerProfiler.Core")]
	public static extern void StopContinuousProfiling();

	[DllImport("ServerProfiler.Core")]
	public static extern void ResumeContinuousProfiling();

	[DllImport("ServerProfiler.Core")]
	public static extern void SetContinuousProfilerNotifySettings(NotifyMetric aSetting, uint aValue);

	[DllImport("ServerProfiler.Core")]
	public static extern bool OnFrameEnd();

	[DllImport("ServerProfiler.Core")]
	public unsafe static extern void GetData(out Profile** profiles, out byte count);

	[DllImport("ServerProfiler.Core")]
	public unsafe static extern void GetMemoryUsage(out MemoryState* state);

	[DllImport("ServerProfiler.Core")]
	public static extern bool ReleaseResources();
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoImage
{
	[FieldOffset(48)]
	public unsafe byte* AssemblyName;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoClass
{
	private const int ImageOffset = 56;

	[FieldOffset(56)]
	public unsafe MonoImage* Image;

	[FieldOffset(64)]
	public unsafe byte* Name;

	[FieldOffset(72)]
	public unsafe byte* Namespace;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoMethod
{
	[FieldOffset(8)]
	public unsafe MonoClass* Class;

	[FieldOffset(24)]
	public unsafe byte* Name;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoVTable
{
	[FieldOffset(0)]
	public unsafe MonoClass* Class;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MonoObject
{
	[FieldOffset(0)]
	public unsafe MonoVTable* VTable;
}


public enum StorageType : byte
{
	FrameLimited,
	FixedBuffer
}


using ProtoBuf;

public class AggressionTimerAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public AggressionTimerAIEvent()
		: base(AIEventType.AggressionTimer)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		AggressionTimerAIEventData aggressionTimerData = data.aggressionTimerData;
		Value = aggressionTimerData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.aggressionTimerData = new AggressionTimerAIEventData();
		obj.aggressionTimerData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Inverted)
		{
			base.Result = senses.TimeInAgressiveState < Value;
		}
		else
		{
			base.Result = senses.TimeInAgressiveState >= Value;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using Rust.Ai;
using UnityEngine;

public class AIBrainSenses
{
	[ServerVar]
	public static float UpdateInterval = 0.5f;

	[ServerVar]
	public static float HumanKnownPlayersLOSUpdateInterval = 0.2f;

	[ServerVar]
	public static float KnownPlayersLOSUpdateInterval = 0.5f;

	public float knownPlayersLOSUpdateInterval = 0.2f;

	[NonSerialized]
	public float MemoryDuration = 10f;

	[NonSerialized]
	public float LastThreatTimestamp;

	[NonSerialized]
	public float TimeInAgressiveState;

	public static BaseEntity[] queryResults = new BaseEntity[64];

	public static BasePlayer[] playerQueryResults = new BasePlayer[64];

	public float nextUpdateTime;

	public float nextKnownPlayersLOSUpdateTime;

	public BaseEntity owner;

	public BasePlayer playerOwner;

	public IAISenses ownerSenses;

	public float maxRange;

	public float targetLostRange;

	public float visionCone;

	public bool checkVision;

	public bool checkLOS;

	public bool ignoreNonVisionSneakers;

	public float listenRange;

	public bool hostileTargetsOnly;

	public bool senseFriendlies;

	public bool refreshKnownLOS;

	[NonSerialized]
	public bool ignoreTutorialPlayers;

	public EntityType senseTypes;

	public IAIAttack ownerAttack;

	[NonSerialized]
	public BaseAIBrain brain;

	private Func<BaseEntity, bool> aiCaresAbout;

	public float TimeSinceThreat => Time.realtimeSinceStartup - LastThreatTimestamp;

	public SimpleAIMemory Memory { get; set; } = new SimpleAIMemory();

	public float TargetLostRange => targetLostRange;

	public bool ignoreSafeZonePlayers { get; set; }

	public List<BaseEntity> Players => Memory.Players;

	public void Init(BaseEntity owner, BaseAIBrain brain, float memoryDuration, float range, float targetLostRange, float visionCone, bool checkVision, bool checkLOS, bool ignoreNonVisionSneakers, float listenRange, bool hostileTargetsOnly, bool senseFriendlies, bool ignoreSafeZonePlayers, EntityType senseTypes, bool refreshKnownLOS)
	{
		aiCaresAbout = AiCaresAbout;
		this.owner = owner;
		this.brain = brain;
		MemoryDuration = memoryDuration;
		ownerAttack = owner as IAIAttack;
		playerOwner = owner as BasePlayer;
		maxRange = range;
		this.targetLostRange = targetLostRange;
		this.visionCone = visionCone;
		this.checkVision = checkVision;
		this.checkLOS = checkLOS;
		this.ignoreNonVisionSneakers = ignoreNonVisionSneakers;
		this.listenRange = listenRange;
		this.hostileTargetsOnly = hostileTargetsOnly;
		this.senseFriendlies = senseFriendlies;
		this.ignoreSafeZonePlayers = ignoreSafeZonePlayers;
		this.senseTypes = senseTypes;
		LastThreatTimestamp = Time.realtimeSinceStartup;
		this.refreshKnownLOS = refreshKnownLOS;
		ownerSenses = owner as IAISenses;
		knownPlayersLOSUpdateInterval = ((owner is HumanNPC) ? HumanKnownPlayersLOSUpdateInterval : KnownPlayersLOSUpdateInterval);
	}

	public void DelaySenseUpdate(float delay)
	{
		nextUpdateTime = Time.time + delay;
	}

	public void Update()
	{
		if (!((Object)(object)owner == (Object)null))
		{
			UpdateSenses();
			UpdateKnownPlayersLOS();
		}
	}

	private void UpdateSenses()
	{
		if (Time.time < nextUpdateTime)
		{
			return;
		}
		nextUpdateTime = Time.time + UpdateInterval;
		if (senseTypes != 0)
		{
			if (senseTypes == EntityType.Player)
			{
				SensePlayers();
			}
			else
			{
				SenseBrains();
				if (senseTypes.HasFlag(EntityType.Player))
				{
					SensePlayers();
				}
			}
		}
		Memory.Forget(MemoryDuration);
	}

	public void UpdateKnownPlayersLOS()
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time < nextKnownPlayersLOSUpdateTime)
		{
			return;
		}
		nextKnownPlayersLOSUpdateTime = Time.time + knownPlayersLOSUpdateInterval;
		foreach (BaseEntity player in Memory.Players)
		{
			if (!((Object)(object)player == (Object)null) && !player.IsNpc)
			{
				bool flag = ownerAttack.CanSeeTarget(player);
				Memory.SetLOS(player, flag);
				if (refreshKnownLOS && (Object)(object)owner != (Object)null && flag && Vector3.Distance(((Component)player).transform.position, ((Component)owner).transform.position) <= TargetLostRange)
				{
					Memory.SetKnown(player, owner, this);
				}
			}
		}
	}

	private void SensePlayers()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int playersInSphereFast = BaseEntity.Query.Server.GetPlayersInSphereFast(((Component)owner).transform.position, maxRange, playerQueryResults, aiCaresAbout);
		for (int i = 0; i < playersInSphereFast; i++)
		{
			BasePlayer ent = playerQueryResults[i];
			Memory.SetKnown(ent, owner, this);
		}
	}

	private void SenseBrains()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int brainsInSphereFast = BaseEntity.Query.Server.GetBrainsInSphereFast(((Component)owner).transform.position, maxRange, queryResults, aiCaresAbout);
		for (int i = 0; i < brainsInSphereFast; i++)
		{
			BaseEntity ent = queryResults[i];
			Memory.SetKnown(ent, owner, this);
		}
	}

	private bool AiCaresAbout(BaseEntity entity)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (!entity.isServer)
		{
			return false;
		}
		if (entity.EqualNetID((BaseNetworkable)owner))
		{
			return false;
		}
		if (entity.Health() <= 0f)
		{
			return false;
		}
		if (entity.IsTransferProtected())
		{
			return false;
		}
		if (!IsValidSenseType(entity))
		{
			return false;
		}
		BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsDead())
			{
				return false;
			}
			if (ignoreTutorialPlayers && basePlayer.IsInTutorial)
			{
				return false;
			}
		}
		if (ignoreSafeZonePlayers && (Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
		{
			return false;
		}
		if (listenRange > 0f && (Object)(object)baseCombatEntity != (Object)null && baseCombatEntity.TimeSinceLastNoise <= 1f && baseCombatEntity.CanLastNoiseBeHeard(((Component)owner).transform.position, listenRange))
		{
			return true;
		}
		if (senseFriendlies && ownerSenses != null && ownerSenses.IsFriendly(entity))
		{
			return true;
		}
		float num = float.PositiveInfinity;
		if ((Object)(object)baseCombatEntity != (Object)null && AI.accuratevisiondistance)
		{
			num = Vector3.Distance(((Component)owner).transform.position, ((Component)baseCombatEntity).transform.position);
			if (num > maxRange)
			{
				return false;
			}
		}
		if (checkVision && !IsTargetInVision(entity))
		{
			if (!ignoreNonVisionSneakers)
			{
				return false;
			}
			if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsNpc)
			{
				if (!AI.accuratevisiondistance)
				{
					num = Vector3.Distance(((Component)owner).transform.position, ((Component)basePlayer).transform.position);
				}
				if ((basePlayer.IsDucked() && num >= brain.IgnoreSneakersMaxDistance) || num >= brain.IgnoreNonVisionMaxDistance)
				{
					return false;
				}
			}
		}
		if (hostileTargetsOnly && (Object)(object)baseCombatEntity != (Object)null && !baseCombatEntity.IsHostile() && !(baseCombatEntity is ScarecrowNPC))
		{
			return false;
		}
		if (checkLOS && ownerAttack != null)
		{
			bool flag = ownerAttack.CanSeeTarget(entity);
			Memory.SetLOS(entity, flag);
			if (!flag)
			{
				return false;
			}
		}
		return true;
	}

	private bool IsValidSenseType(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsNpc)
			{
				if (ent is BasePet)
				{
					return true;
				}
				if (ent is ScarecrowNPC)
				{
					return true;
				}
				if (senseTypes.HasFlag(EntityType.BasePlayerNPC))
				{
					return true;
				}
			}
			else if (senseTypes.HasFlag(EntityType.Player))
			{
				return true;
			}
		}
		if (senseTypes.HasFlag(EntityType.NPC) && ent is BaseNpc)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.WorldItem) && ent is WorldItem)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.Corpse) && ent is BaseCorpse)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.TimedExplosive) && ent is TimedExplosive)
		{
			return true;
		}
		if (senseTypes.HasFlag(EntityType.Chair) && ent is BaseChair)
		{
			return true;
		}
		return false;
	}

	private bool IsTargetInVision(BaseEntity target)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.Direction(((Component)target).transform.position, ((Component)owner).transform.position);
		return Vector3.Dot(((Object)(object)playerOwner != (Object)null) ? playerOwner.eyes.BodyForward() : ((Component)owner).transform.forward, val) >= visionCone;
	}

	public BaseEntity GetNearestPlayer(float rangeFraction)
	{
		return GetNearest(Memory.Players, rangeFraction);
	}

	public BaseEntity GetNearestThreat(float rangeFraction)
	{
		return GetNearest(Memory.Threats, rangeFraction);
	}

	public BaseEntity GetNearestTarget(float rangeFraction)
	{
		return GetNearest(Memory.Targets, rangeFraction);
	}

	private BaseEntity GetNearest(List<BaseEntity> entities, float rangeFraction)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (entities == null || entities.Count == 0)
		{
			return null;
		}
		float num = float.PositiveInfinity;
		BaseEntity result = null;
		foreach (BaseEntity entity in entities)
		{
			if (!((Object)(object)entity == (Object)null) && !(entity.Health() <= 0f) && Interface.CallHook("OnNpcTarget", (object)owner, (object)entity) == null)
			{
				float num2 = Vector3.Distance(((Component)entity).transform.position, ((Component)owner).transform.position);
				if (num2 <= rangeFraction * maxRange && num2 < num)
				{
					result = entity;
				}
			}
		}
		return result;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/AI Design")]
public class AIDesignSO : BaseScriptableObject
{
	public string Filename;
}


using System.Collections.Generic;
using ProtoBuf;

public class AIDesign
{
	public List<AIState> AvailableStates = new List<AIState>();

	public int DefaultStateContainerID;

	private Dictionary<int, AIStateContainer> stateContainers = new Dictionary<int, AIStateContainer>();

	public AIDesignScope Scope { get; private set; }

	public string Description { get; private set; }

	public void SetAvailableStates(List<AIState> states)
	{
		AvailableStates = new List<AIState>();
		AvailableStates.AddRange(states);
	}

	public void Load(AIDesign design, BaseEntity owner)
	{
		Scope = (AIDesignScope)design.scope;
		DefaultStateContainerID = design.defaultStateContainer;
		Description = design.description;
		InitStateContainers(design, owner);
	}

	private void InitStateContainers(AIDesign design, BaseEntity owner)
	{
		stateContainers = new Dictionary<int, AIStateContainer>();
		if (design.stateContainers == null)
		{
			return;
		}
		foreach (AIStateContainer stateContainer in design.stateContainers)
		{
			AIStateContainer aIStateContainer = new AIStateContainer();
			aIStateContainer.Init(stateContainer, owner);
			stateContainers.Add(aIStateContainer.ID, aIStateContainer);
		}
	}

	public AIStateContainer GetDefaultStateContainer()
	{
		return GetStateContainerByID(DefaultStateContainerID);
	}

	public AIStateContainer GetStateContainerByID(int id)
	{
		if (!stateContainers.ContainsKey(id))
		{
			return null;
		}
		return stateContainers[id];
	}

	public AIStateContainer GetFirstStateContainerOfType(AIState stateType)
	{
		foreach (AIStateContainer value in stateContainers.Values)
		{
			if (value.State == stateType)
			{
				return value;
			}
		}
		return null;
	}

	public AIDesign ToProto(int currentStateID)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		AIDesign val = new AIDesign();
		val.description = Description;
		val.scope = (int)Scope;
		val.defaultStateContainer = DefaultStateContainerID;
		val.availableStates = new List<int>();
		foreach (AIState availableState in AvailableStates)
		{
			val.availableStates.Add((int)availableState);
		}
		val.stateContainers = new List<AIStateContainer>();
		foreach (AIStateContainer value in stateContainers.Values)
		{
			val.stateContainers.Add(value.ToProto());
		}
		val.intialViewStateID = currentStateID;
		return val;
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public static class AIDesigns
{
	public const string DesignFolderPath = "cfg/ai/";

	private static Dictionary<string, AIDesign> designs = new Dictionary<string, AIDesign>();

	public static AIDesign GetByNameOrInstance(string designName, AIDesign entityDesign)
	{
		if (entityDesign != null)
		{
			return entityDesign;
		}
		AIDesign byName = GetByName(designName + "_custom");
		if (byName != null)
		{
			return byName;
		}
		return GetByName(designName);
	}

	public static void RefreshCache(string designName, AIDesign design)
	{
		if (designs.ContainsKey(designName))
		{
			designs[designName] = design;
		}
	}

	private static AIDesign GetByName(string designName)
	{
		designs.TryGetValue(designName, out var value);
		if (value != null)
		{
			return value;
		}
		string text = "cfg/ai/" + designName;
		if (!File.Exists(text))
		{
			return null;
		}
		try
		{
			using FileStream fileStream = File.Open(text, FileMode.Open);
			value = Pool.Get<AIDesign>();
			ProtoStreamExtensions.ReadFromStream((IProto)(object)value, (Stream)fileStream, false, 1048576);
			if (value == null)
			{
				return null;
			}
			designs.Add(designName, value);
			return value;
		}
		catch (Exception)
		{
			Debug.LogWarning((object)("Error trying to find AI design by name: " + text));
			return null;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class AIEvents
{
	public AIMemory Memory = new AIMemory();

	public List<BaseAIEvent> events = new List<BaseAIEvent>();

	private IAIEventListener eventListener;

	public AIBrainSenses senses;

	private int currentEventIndex;

	private bool inBlock;

	public int CurrentInputMemorySlot { get; private set; } = -1;

	public void Init(IAIEventListener listener, AIStateContainer stateContainer, BaseEntity owner, AIBrainSenses senses)
	{
		CurrentInputMemorySlot = stateContainer.InputMemorySlot;
		eventListener = listener;
		RemoveAll();
		AddStateEvents(stateContainer.Events, owner);
		Memory.Entity.Set(owner, 4);
		this.senses = senses;
	}

	public void RemoveAll()
	{
		events.Clear();
	}

	public void AddStateEvents(List<BaseAIEvent> events, BaseEntity owner)
	{
		foreach (BaseAIEvent @event in events)
		{
			Add(@event);
		}
	}

	public void Add(BaseAIEvent aiEvent)
	{
		if (events.Contains(aiEvent))
		{
			Debug.LogWarning((object)("Attempting to add duplicate AI event: " + aiEvent.EventType));
			return;
		}
		aiEvent.Reset();
		events.Add(aiEvent);
	}

	public void Tick(float deltaTime, StateStatus stateStatus)
	{
		foreach (BaseAIEvent @event in events)
		{
			@event.Tick(deltaTime, eventListener);
		}
		inBlock = false;
		currentEventIndex = 0;
		for (currentEventIndex = 0; currentEventIndex < events.Count; currentEventIndex++)
		{
			BaseAIEvent baseAIEvent = events[currentEventIndex];
			BaseAIEvent baseAIEvent2 = ((currentEventIndex < events.Count - 1) ? events[currentEventIndex + 1] : null);
			if (baseAIEvent2 != null && baseAIEvent2.EventType == AIEventType.And && !inBlock)
			{
				inBlock = true;
			}
			if (baseAIEvent.EventType != AIEventType.And)
			{
				if (baseAIEvent.ShouldExecute)
				{
					baseAIEvent.Execute(Memory, senses, stateStatus);
					baseAIEvent.PostExecute();
				}
				bool result = baseAIEvent.Result;
				if (inBlock)
				{
					if (result)
					{
						if ((baseAIEvent2 != null && baseAIEvent2.EventType != AIEventType.And) || baseAIEvent2 == null)
						{
							inBlock = false;
							if (baseAIEvent.HasValidTriggerState)
							{
								baseAIEvent.TriggerStateChange(eventListener, baseAIEvent.ID);
								break;
							}
						}
					}
					else
					{
						inBlock = false;
						currentEventIndex = FindNextEventBlock() - 1;
					}
				}
				else if (result && baseAIEvent.HasValidTriggerState)
				{
					baseAIEvent.TriggerStateChange(eventListener, baseAIEvent.ID);
					break;
				}
			}
		}
	}

	private int FindNextEventBlock()
	{
		for (int i = currentEventIndex; i < events.Count; i++)
		{
			BaseAIEvent baseAIEvent = events[i];
			BaseAIEvent baseAIEvent2 = ((i < events.Count - 1) ? events[i + 1] : null);
			if (baseAIEvent2 != null && baseAIEvent2.EventType != AIEventType.And && baseAIEvent.EventType != AIEventType.And)
			{
				return i + 1;
			}
		}
		return events.Count + 1;
	}
}


public enum AIEventType
{
	Timer,
	PlayerDetected,
	StateError,
	Attacked,
	StateFinished,
	InAttackRange,
	HealthBelow,
	InRange,
	PerformedAttack,
	TirednessAbove,
	HungerAbove,
	ThreatDetected,
	TargetDetected,
	AmmoBelow,
	BestTargetDetected,
	IsVisible,
	AttackTick,
	IsMounted,
	And,
	Chance,
	TargetLost,
	TimeSinceThreat,
	OnPositionMemorySet,
	AggressionTimer,
	Reloading,
	InRangeOfHome,
	IsBlinded
}


using UnityEngine;

public class AIMemory
{
	public AIMemoryBank<BaseEntity> Entity = new AIMemoryBank<BaseEntity>(MemoryBankType.Entity, 8);

	public AIMemoryBank<Vector3> Position = new AIMemoryBank<Vector3>(MemoryBankType.Position, 8);

	public AIMemoryBank<AIPoint> AIPoint = new AIMemoryBank<AIPoint>(MemoryBankType.AIPoint, 8);

	public void Clear()
	{
		Entity.Clear();
		Position.Clear();
		AIPoint.Clear();
	}
}


public enum MemoryBankType
{
	Entity,
	Position,
	AIPoint
}


public enum ReservedEntitySlots
{
	Self = 4,
	OwningPlayer,
	GroupLeader,
	SpecialEntity
}


public enum ReservedPositionSlots
{
	HomePoint = 4,
	GroupRoamPoint,
	RaycastTargetPoint,
	Vector3
}


public enum ReservedAIPointSlots
{
	CoverPoint = 4
}


using UnityEngine;

public class AIMemoryBank<T>
{
	private MemoryBankType type;

	private T[] slots;

	private float[] slotSetTimestamps;

	private int slotCount;

	public AIMemoryBank(MemoryBankType type, int slots)
	{
		Init(type, slots);
	}

	public void Init(MemoryBankType type, int slots)
	{
		this.type = type;
		slotCount = slots;
		this.slots = new T[slotCount];
		slotSetTimestamps = new float[slotCount];
	}

	public void Set(T item, int index)
	{
		if (index >= 0 && index < slotCount)
		{
			slots[index] = item;
			slotSetTimestamps[index] = Time.realtimeSinceStartup;
		}
	}

	public T Get(int index)
	{
		if (index < 0 || index >= slotCount)
		{
			return default(T);
		}
		return slots[index];
	}

	public float GetTimeSinceSet(int index)
	{
		if (index < 0 || index >= slotCount)
		{
			return 0f;
		}
		return Time.realtimeSinceStartup - slotSetTimestamps[index];
	}

	public void Remove(int index)
	{
		if (index >= 0 && index < slotCount)
		{
			slots[index] = default(T);
		}
	}

	public void Clear()
	{
		for (int i = 0; i < 4; i++)
		{
			Remove(i);
		}
	}
}


using ProtoBuf;

public class AmmoBelowAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public AmmoBelowAIEvent()
		: base(AIEventType.AmmoBelow)
	{
		base.Rate = ExecuteRate.Normal;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		AmmoBelowAIEventData ammoBelowData = data.ammoBelowData;
		Value = ammoBelowData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.ammoBelowData = new AmmoBelowAIEventData();
		obj.ammoBelowData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Owner is IAIAttack iAIAttack)
		{
			bool flag = iAIAttack.GetAmmoFraction() < Value;
			if (base.Inverted)
			{
				base.Result = !flag;
			}
			else
			{
				base.Result = flag;
			}
		}
	}
}


public class AndAIEvent : BaseAIEvent
{
	public AndAIEvent()
		: base(AIEventType.And)
	{
		base.Rate = ExecuteRate.Normal;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
	}
}


using UnityEngine;

public class AttackedAIEvent : BaseAIEvent
{
	protected float lastExecuteTime = float.NegativeInfinity;

	private BaseCombatEntity combatEntity;

	public AttackedAIEvent()
		: base(AIEventType.Attacked)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Reset()
	{
		base.Reset();
		lastExecuteTime = Time.time;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		combatEntity = memory.Entity.Get(base.InputEntityMemorySlot) as BaseCombatEntity;
		float num = lastExecuteTime;
		lastExecuteTime = Time.time;
		if ((Object)(object)combatEntity == (Object)null || !(combatEntity.lastAttackedTime >= num) || (Object)(object)combatEntity.lastAttacker == (Object)null || (Object)(object)combatEntity.lastAttacker == (Object)(object)combatEntity)
		{
			return;
		}
		BasePlayer basePlayer = combatEntity.lastAttacker as BasePlayer;
		if (!((Object)(object)basePlayer != (Object)null) || !((Object)(object)basePlayer == (Object)(object)memory.Entity.Get(5)) || !((Object)(object)basePlayer.lastDealtDamageTo == (Object)(object)base.Owner))
		{
			if (base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(combatEntity.lastAttacker, base.OutputEntityMemorySlot);
			}
			base.Result = !base.Inverted;
		}
	}
}


public class AttackTickAIEvent : BaseAIEvent
{
	public AttackTickAIEvent()
		: base(AIEventType.AttackTick)
	{
		base.Rate = ExecuteRate.VeryFast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Owner is IAIAttack iAIAttack)
		{
			BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
			iAIAttack.AttackTick(deltaTime, baseEntity, senses.Memory.IsLOS(baseEntity));
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class BaseAIEvent
{
	public enum ExecuteRate
	{
		Slow,
		Normal,
		Fast,
		VeryFast
	}

	private float executeTimer;

	protected float deltaTime;

	public AIEventType EventType { get; private set; }

	public int TriggerStateContainerID { get; private set; } = -1;

	public ExecuteRate Rate { get; protected set; } = ExecuteRate.Normal;

	public float ExecutionRate => Rate switch
	{
		ExecuteRate.Slow => 1f, 
		ExecuteRate.Normal => 0.5f, 
		ExecuteRate.Fast => 0.25f, 
		ExecuteRate.VeryFast => 0.1f, 
		_ => 0.5f, 
	};

	public bool ShouldExecute { get; protected set; }

	public bool Result { get; protected set; }

	public bool Inverted { get; private set; }

	public int OutputEntityMemorySlot { get; protected set; } = -1;

	public bool ShouldSetOutputEntityMemory => OutputEntityMemorySlot > -1;

	public int InputEntityMemorySlot { get; protected set; } = -1;

	public int ID { get; protected set; }

	public BaseEntity Owner { get; private set; }

	public bool HasValidTriggerState => TriggerStateContainerID != -1;

	public BaseAIEvent(AIEventType type)
	{
		EventType = type;
	}

	public virtual void Init(AIEventData data, BaseEntity owner)
	{
		Init(data.triggerStateContainer, data.id, owner, data.inputMemorySlot, data.outputMemorySlot, data.inverted);
	}

	public virtual void Init(int triggerStateContainer, int id, BaseEntity owner, int inputMemorySlot, int outputMemorySlot, bool inverted)
	{
		TriggerStateContainerID = triggerStateContainer;
		ID = id;
		Owner = owner;
		InputEntityMemorySlot = inputMemorySlot;
		OutputEntityMemorySlot = outputMemorySlot;
		Inverted = inverted;
	}

	public virtual AIEventData ToProto()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Expected O, but got Unknown
		return new AIEventData
		{
			id = ID,
			eventType = (int)EventType,
			triggerStateContainer = TriggerStateContainerID,
			outputMemorySlot = OutputEntityMemorySlot,
			inputMemorySlot = InputEntityMemorySlot,
			inverted = Inverted
		};
	}

	public virtual void Reset()
	{
		executeTimer = 0f;
		deltaTime = 0f;
		Result = false;
	}

	public void Tick(float deltaTime, IAIEventListener listener)
	{
		this.deltaTime += deltaTime;
		executeTimer += deltaTime;
		float executionRate = ExecutionRate;
		if (executeTimer >= executionRate)
		{
			executeTimer = 0f;
			ShouldExecute = true;
		}
		else
		{
			ShouldExecute = false;
		}
	}

	public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
	}

	public virtual void PostExecute()
	{
		deltaTime = 0f;
	}

	public void TriggerStateChange(IAIEventListener listener, int sourceEventID)
	{
		listener.EventTriggeredStateChange(TriggerStateContainerID, sourceEventID);
	}

	public static BaseAIEvent CreateEvent(AIEventType eventType)
	{
		switch (eventType)
		{
		case AIEventType.Timer:
			return new TimerAIEvent();
		case AIEventType.PlayerDetected:
			return new PlayerDetectedAIEvent();
		case AIEventType.StateError:
			return new StateErrorAIEvent();
		case AIEventType.Attacked:
			return new AttackedAIEvent();
		case AIEventType.StateFinished:
			return new StateFinishedAIEvent();
		case AIEventType.InAttackRange:
			return new InAttackRangeAIEvent();
		case AIEventType.HealthBelow:
			return new HealthBelowAIEvent();
		case AIEventType.InRange:
			return new InRangeAIEvent();
		case AIEventType.PerformedAttack:
			return new PerformedAttackAIEvent();
		case AIEventType.TirednessAbove:
			return new TirednessAboveAIEvent();
		case AIEventType.HungerAbove:
			return new HungerAboveAIEvent();
		case AIEventType.ThreatDetected:
			return new ThreatDetectedAIEvent();
		case AIEventType.TargetDetected:
			return new TargetDetectedAIEvent();
		case AIEventType.AmmoBelow:
			return new AmmoBelowAIEvent();
		case AIEventType.BestTargetDetected:
			return new BestTargetDetectedAIEvent();
		case AIEventType.IsVisible:
			return new IsVisibleAIEvent();
		case AIEventType.AttackTick:
			return new AttackTickAIEvent();
		case AIEventType.IsMounted:
			return new IsMountedAIEvent();
		case AIEventType.And:
			return new AndAIEvent();
		case AIEventType.Chance:
			return new ChanceAIEvent();
		case AIEventType.TargetLost:
			return new TargetLostAIEvent();
		case AIEventType.TimeSinceThreat:
			return new TimeSinceThreatAIEvent();
		case AIEventType.OnPositionMemorySet:
			return new OnPositionMemorySetAIEvent();
		case AIEventType.AggressionTimer:
			return new AggressionTimerAIEvent();
		case AIEventType.Reloading:
			return new ReloadingAIEvent();
		case AIEventType.InRangeOfHome:
			return new InRangeOfHomeAIEvent();
		case AIEventType.IsBlinded:
			return new IsBlindedAIEvent();
		default:
			Debug.LogWarning((object)("No case for " + eventType.ToString() + " event in BaseAIEvent.CreateEvent()!"));
			return null;
		}
	}
}


public enum ExecuteRate
{
	Slow,
	Normal,
	Fast,
	VeryFast
}


using ProtoBuf;
using UnityEngine;

public class BestTargetDetectedAIEvent : BaseAIEvent
{
	public BestTargetDetectedAIEvent()
		: base(AIEventType.BestTargetDetected)
	{
		base.Rate = ExecuteRate.Normal;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (!(base.Owner is IAIAttack iAIAttack))
		{
			return;
		}
		BaseEntity bestTarget = iAIAttack.GetBestTarget();
		if (base.Inverted)
		{
			if ((Object)(object)bestTarget == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)bestTarget == (Object)null;
		}
		else
		{
			if ((Object)(object)bestTarget != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(bestTarget, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)bestTarget != (Object)null;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class ChanceAIEvent : BaseAIEvent
{
	public float Chance { get; set; }

	public ChanceAIEvent()
		: base(AIEventType.Chance)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		Chance = data.chanceData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.chanceData = new ChanceAIEventData();
		obj.chanceData.value = Chance;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		bool flag = Random.Range(0f, 1f) <= Chance;
		if (base.Inverted)
		{
			base.Result = !flag;
		}
		else
		{
			base.Result = flag;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class HealthBelowAIEvent : BaseAIEvent
{
	private BaseCombatEntity combatEntity;

	public float HealthFraction { get; set; }

	public HealthBelowAIEvent()
		: base(AIEventType.HealthBelow)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		HealthBelowAIEventData healthBelowData = data.healthBelowData;
		HealthFraction = healthBelowData.healthFraction;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.healthBelowData = new HealthBelowAIEventData();
		obj.healthBelowData.healthFraction = HealthFraction;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		combatEntity = memory.Entity.Get(base.InputEntityMemorySlot) as BaseCombatEntity;
		if (!((Object)(object)combatEntity == (Object)null))
		{
			bool flag = combatEntity.healthFraction < HealthFraction;
			if (base.Inverted)
			{
				base.Result = !flag;
			}
			else
			{
				base.Result = flag;
			}
		}
	}
}


public interface IAIHungerAbove
{
	bool IsHungerAbove(float val);
}


using ProtoBuf;

public class HungerAboveAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public HungerAboveAIEvent()
		: base(AIEventType.HungerAbove)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		HungerAboveAIEventData hungerAboveData = data.hungerAboveData;
		Value = hungerAboveData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.hungerAboveData = new HungerAboveAIEventData();
		obj.hungerAboveData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		if (!(base.Owner is IAIHungerAbove iAIHungerAbove))
		{
			base.Result = false;
			return;
		}
		bool flag = iAIHungerAbove.IsHungerAbove(Value);
		if (base.Inverted)
		{
			base.Result = !flag;
		}
		else
		{
			base.Result = flag;
		}
	}
}


public interface IAIEventListener
{
	void EventTriggeredStateChange(int newStateContainerID, int sourceEventID);
}


using UnityEngine;

public class InAttackRangeAIEvent : BaseAIEvent
{
	public InAttackRangeAIEvent()
		: base(AIEventType.InAttackRange)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		base.Result = false;
		if (!((Object)(object)baseEntity == (Object)null) && base.Owner is IAIAttack iAIAttack)
		{
			float dist;
			bool flag = iAIAttack.IsTargetInRange(baseEntity, out dist);
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class InRangeAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public InRangeAIEvent()
		: base(AIEventType.InRange)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		InRangeAIEventData inRangeData = data.inRangeData;
		Range = inRangeData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.inRangeData = new InRangeAIEventData();
		obj.inRangeData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		base.Result = false;
		if (!((Object)(object)baseEntity == (Object)null))
		{
			bool flag = Vector3Ex.Distance2D(((Component)base.Owner).transform.position, ((Component)baseEntity).transform.position) <= Range;
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class InRangeOfHomeAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public InRangeOfHomeAIEvent()
		: base(AIEventType.InRangeOfHome)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		InRangeOfHomeAIEventData inRangeOfHomeData = data.inRangeOfHomeData;
		Range = inRangeOfHomeData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.inRangeOfHomeData = new InRangeOfHomeAIEventData();
		obj.inRangeOfHomeData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = memory.Position.Get(4);
		base.Result = false;
		bool flag = Vector3Ex.Distance2D(((Component)base.Owner).transform.position, val) <= Range;
		base.Result = (base.Inverted ? (!flag) : flag);
	}
}


public class IsBlindedAIEvent : BaseAIEvent
{
	public IsBlindedAIEvent()
		: base(AIEventType.IsBlinded)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		bool flag = senses.brain.Blinded();
		if (base.Inverted)
		{
			base.Result = !flag;
		}
		else
		{
			base.Result = flag;
		}
	}
}


using UnityEngine;

public class IsVisibleAIEvent : BaseAIEvent
{
	public IsVisibleAIEvent()
		: base(AIEventType.IsVisible)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		if (!((Object)(object)baseEntity == (Object)null) && base.Owner is IAIAttack)
		{
			bool flag = senses.Memory.IsLOS(baseEntity);
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


public class IsMountedAIEvent : BaseAIEvent
{
	public IsMountedAIEvent()
		: base(AIEventType.IsMounted)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		IAIMounted iAIMounted = memory.Entity.Get(base.InputEntityMemorySlot) as IAIMounted;
		base.Result = false;
		if (iAIMounted != null)
		{
			if (base.Inverted && !iAIMounted.IsMounted())
			{
				base.Result = true;
			}
			if (!base.Inverted && iAIMounted.IsMounted())
			{
				base.Result = true;
			}
			if (base.Result && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(memory.Entity.Get(base.InputEntityMemorySlot), base.OutputEntityMemorySlot);
			}
		}
	}
}


public class OnPositionMemorySetAIEvent : BaseAIEvent
{
	public OnPositionMemorySetAIEvent()
		: base(AIEventType.OnPositionMemorySet)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		if (memory.Position.GetTimeSinceSet(5) <= 0.5f)
		{
			base.Result = !base.Inverted;
		}
		else
		{
			base.Result = base.Inverted;
		}
	}
}


using UnityEngine;

public class PerformedAttackAIEvent : BaseAIEvent
{
	protected float lastExecuteTime = float.NegativeInfinity;

	private BaseCombatEntity combatEntity;

	public PerformedAttackAIEvent()
		: base(AIEventType.PerformedAttack)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Reset()
	{
		base.Reset();
		lastExecuteTime = Time.time;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		combatEntity = memory.Entity.Get(base.InputEntityMemorySlot) as BaseCombatEntity;
		float num = lastExecuteTime;
		lastExecuteTime = Time.time;
		if ((Object)(object)combatEntity == (Object)null)
		{
			return;
		}
		if (combatEntity.lastDealtDamageTime >= num)
		{
			if ((Object)(object)combatEntity.lastDealtDamageTo == (Object)null || (Object)(object)combatEntity.lastDealtDamageTo == (Object)(object)combatEntity)
			{
				return;
			}
			BasePlayer basePlayer = combatEntity as BasePlayer;
			if (!((Object)(object)basePlayer != (Object)null) || ((!((Object)(object)basePlayer == (Object)(object)memory.Entity.Get(5)) || !((Object)(object)basePlayer.lastDealtDamageTo == (Object)(object)base.Owner)) && (!((Object)(object)basePlayer == (Object)(object)memory.Entity.Get(5)) || (((Component)basePlayer.lastDealtDamageTo).gameObject.layer != 21 && ((Component)basePlayer.lastDealtDamageTo).gameObject.layer != 8))))
			{
				if (base.ShouldSetOutputEntityMemory)
				{
					memory.Entity.Set(combatEntity.lastDealtDamageTo, base.OutputEntityMemorySlot);
				}
				base.Result = !base.Inverted;
			}
		}
		else
		{
			base.Result = base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class PlayerDetectedAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public PlayerDetectedAIEvent()
		: base(AIEventType.PlayerDetected)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		PlayerDetectedAIEventData playerDetectedData = data.playerDetectedData;
		Range = playerDetectedData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.playerDetectedData = new PlayerDetectedAIEventData();
		obj.playerDetectedData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = false;
		BaseEntity nearestPlayer = senses.GetNearestPlayer(Range);
		if (base.Inverted)
		{
			if ((Object)(object)nearestPlayer == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestPlayer == (Object)null;
		}
		else
		{
			if ((Object)(object)nearestPlayer != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(nearestPlayer, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestPlayer != (Object)null;
		}
	}
}


using UnityEngine;

public class ReloadingAIEvent : BaseAIEvent
{
	public ReloadingAIEvent()
		: base(AIEventType.Reloading)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		base.Result = false;
		NPCPlayer nPCPlayer = baseEntity as NPCPlayer;
		if (!((Object)(object)nPCPlayer == (Object)null))
		{
			bool flag = nPCPlayer.IsReloading();
			base.Result = (base.Inverted ? (!flag) : flag);
		}
	}
}


public class StateErrorAIEvent : BaseAIEvent
{
	public StateErrorAIEvent()
		: base(AIEventType.StateError)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		switch (stateStatus)
		{
		case StateStatus.Error:
			base.Result = !base.Inverted;
			break;
		case StateStatus.Running:
			base.Result = base.Inverted;
			break;
		}
	}
}


public class StateFinishedAIEvent : BaseAIEvent
{
	public StateFinishedAIEvent()
		: base(AIEventType.StateFinished)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (stateStatus == StateStatus.Finished)
		{
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class TargetDetectedAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public TargetDetectedAIEvent()
		: base(AIEventType.TargetDetected)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TargetDetectedAIEventData targetDetectedData = data.targetDetectedData;
		Range = targetDetectedData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.targetDetectedData = new TargetDetectedAIEventData();
		obj.targetDetectedData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		BaseEntity nearestTarget = senses.GetNearestTarget(Range);
		if (base.Inverted)
		{
			if ((Object)(object)nearestTarget == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestTarget == (Object)null;
		}
		else
		{
			if ((Object)(object)nearestTarget != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(nearestTarget, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestTarget != (Object)null;
		}
	}
}


using UnityEngine;

public class TargetLostAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public TargetLostAIEvent()
		: base(AIEventType.TargetLost)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		base.Result = base.Inverted;
		BaseEntity baseEntity = memory.Entity.Get(base.InputEntityMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			base.Result = !base.Inverted;
			return;
		}
		if (Vector3.Distance(((Component)baseEntity).transform.position, ((Component)base.Owner).transform.position) > senses.TargetLostRange)
		{
			base.Result = !base.Inverted;
			return;
		}
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if (baseEntity.Health() <= 0f || ((Object)(object)basePlayer != (Object)null && basePlayer.IsDead()))
		{
			base.Result = !base.Inverted;
		}
		else if (senses.ignoreSafeZonePlayers && (Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
		{
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class ThreatDetectedAIEvent : BaseAIEvent
{
	public float Range { get; set; }

	public ThreatDetectedAIEvent()
		: base(AIEventType.ThreatDetected)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		ThreatDetectedAIEventData threatDetectedData = data.threatDetectedData;
		Range = threatDetectedData.range;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.threatDetectedData = new ThreatDetectedAIEventData();
		obj.threatDetectedData.range = Range;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		BaseEntity nearestThreat = senses.GetNearestThreat(Range);
		if (base.Inverted)
		{
			if ((Object)(object)nearestThreat == (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Remove(base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestThreat == (Object)null;
		}
		else
		{
			if ((Object)(object)nearestThreat != (Object)null && base.ShouldSetOutputEntityMemory)
			{
				memory.Entity.Set(nearestThreat, base.OutputEntityMemorySlot);
			}
			base.Result = (Object)(object)nearestThreat != (Object)null;
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class TimerAIEvent : BaseAIEvent
{
	protected float currentDuration;

	protected float elapsedDuration;

	public float DurationMin { get; set; }

	public float DurationMax { get; set; }

	public TimerAIEvent()
		: base(AIEventType.Timer)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TimerAIEventData timerData = data.timerData;
		DurationMin = timerData.duration;
		DurationMax = timerData.durationMax;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.timerData = new TimerAIEventData();
		obj.timerData.duration = DurationMin;
		obj.timerData.durationMax = DurationMax;
		return obj;
	}

	public override void Reset()
	{
		base.Reset();
		currentDuration = Random.Range(DurationMin, DurationMax);
		elapsedDuration = 0f;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		elapsedDuration += deltaTime;
		if (elapsedDuration >= currentDuration)
		{
			base.Result = !base.Inverted;
		}
	}
}


using ProtoBuf;

public class TimeSinceThreatAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public TimeSinceThreatAIEvent()
		: base(AIEventType.TimeSinceThreat)
	{
		base.Rate = ExecuteRate.Fast;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TimeSinceThreatAIEventData timeSinceThreatData = data.timeSinceThreatData;
		Value = timeSinceThreatData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.timeSinceThreatData = new TimeSinceThreatAIEventData();
		obj.timeSinceThreatData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Inverted)
		{
			base.Result = senses.TimeSinceThreat < Value;
		}
		else
		{
			base.Result = senses.TimeSinceThreat >= Value;
		}
	}
}


public interface IAITirednessAbove
{
	bool IsTirednessAbove(float val);
}


public interface IAISleep
{
	void StartSleeping();

	void StopSleeping();
}


public interface IAISenses
{
	bool IsThreat(BaseEntity entity);

	bool IsTarget(BaseEntity entity);

	bool IsFriendly(BaseEntity entity);
}


public interface IAIMounted
{
	bool IsMounted();
}


using ProtoBuf;

public class TirednessAboveAIEvent : BaseAIEvent
{
	public float Value { get; private set; }

	public TirednessAboveAIEvent()
		: base(AIEventType.TirednessAbove)
	{
		base.Rate = ExecuteRate.Slow;
	}

	public override void Init(AIEventData data, BaseEntity owner)
	{
		base.Init(data, owner);
		TirednessAboveAIEventData tirednessAboveData = data.tirednessAboveData;
		Value = tirednessAboveData.value;
	}

	public override AIEventData ToProto()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		AIEventData obj = base.ToProto();
		obj.tirednessAboveData = new TirednessAboveAIEventData();
		obj.tirednessAboveData.value = Value;
		return obj;
	}

	public override void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
	{
		base.Result = base.Inverted;
		if (base.Owner is IAITirednessAbove iAITirednessAbove)
		{
			bool flag = iAITirednessAbove.IsTirednessAbove(Value);
			if (base.Inverted)
			{
				base.Result = !flag;
			}
			else
			{
				base.Result = flag;
			}
		}
	}
}


using System.Collections.Generic;
using ProtoBuf;

public class AIStateContainer
{
	public List<BaseAIEvent> Events;

	public int ID { get; private set; }

	public AIState State { get; private set; }

	public int InputMemorySlot { get; private set; } = -1;

	public void Init(AIStateContainer container, BaseEntity owner)
	{
		ID = container.id;
		State = (AIState)container.state;
		InputMemorySlot = container.inputMemorySlot;
		Events = new List<BaseAIEvent>();
		if (container.events == null)
		{
			return;
		}
		foreach (AIEventData @event in container.events)
		{
			BaseAIEvent baseAIEvent = BaseAIEvent.CreateEvent((AIEventType)@event.eventType);
			baseAIEvent.Init(@event, owner);
			baseAIEvent.Reset();
			Events.Add(baseAIEvent);
		}
	}

	public AIStateContainer ToProto()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		AIStateContainer val = new AIStateContainer();
		val.id = ID;
		val.state = (int)State;
		val.events = new List<AIEventData>();
		val.inputMemorySlot = InputMemorySlot;
		foreach (BaseAIEvent @event in Events)
		{
			val.events.Add(@event.ToProto());
		}
		return val;
	}
}


public enum StateStatus
{
	Running,
	Finished,
	Error
}


public enum AIDesignScope
{
	Default,
	EntityServerWide,
	EntityInstance
}


using System;

[Flags]
public enum EntityType
{
	Player = 1,
	NPC = 2,
	WorldItem = 4,
	Corpse = 8,
	TimedExplosive = 0x10,
	Chair = 0x20,
	BasePlayerNPC = 0x40
}


internal interface IClientBrainStateListener
{
	void OnClientStateChanged(AIState state);
}


using ProtoBuf;

internal interface IAIDesign
{
	void LoadAIDesign(AIDesign design, BasePlayer player);

	void StopDesigning();

	bool CanPlayerDesignAI(BasePlayer player);
}


public interface IAISleepable
{
	bool AllowedToSleep();

	void SleepAI();

	void WakeAI();
}


using UnityEngine;

public interface IAIGroupable
{
	bool AddMember(IAIGroupable member);

	void RemoveMember(IAIGroupable member);

	void JoinGroup(IAIGroupable leader, BaseEntity leaderEntity);

	void SetGroupRoamRootPosition(Vector3 rootPos);

	bool InGroup();

	void LeaveGroup();

	void SetUngrouped();
}


public interface IAIAttack
{
	void AttackTick(float delta, BaseEntity target, bool targetIsLOS);

	BaseEntity GetBestTarget();

	bool CanAttack(BaseEntity entity);

	float EngagementRange();

	bool IsTargetInRange(BaseEntity entity, out float dist);

	bool CanSeeTarget(BaseEntity entity);

	float GetAmmoFraction();

	bool NeedsToReload();

	bool Reload();

	float CooldownDuration();

	bool IsOnCooldown();

	bool StartAttacking(BaseEntity entity);

	void StopAttacking();
}


public enum PetCommandType
{
	LoadDesign,
	SetState,
	Destroy
}


using UnityEngine;

public interface IPet
{
	bool IsPet();

	void SetPetOwner(BasePlayer player);

	bool IsOwnedBy(BasePlayer player);

	bool IssuePetCommand(PetCommandType cmd, int param, Ray? ray);
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PetCommandList : PrefabAttribute
{
	[Serializable]
	public struct PetCommandDesc
	{
		public PetCommandType CommandType;

		public Phrase Title;

		public Phrase Description;

		public Sprite Icon;

		public int CommandIndex;

		public bool Raycast;

		public int CommandWheelOrder;
	}

	public List<PetCommandDesc> Commands;

	protected override Type GetIndexedType()
	{
		return typeof(PetCommandList);
	}

	public List<PetCommandDesc> GetCommandDescriptions()
	{
		return Commands;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct PetCommandDesc
{
	public PetCommandType CommandType;

	public Phrase Title;

	public Phrase Description;

	public Sprite Icon;

	public int CommandIndex;

	public bool Raycast;

	public int CommandWheelOrder;
}


using UnityEngine;

public class ScentEmission : EntityComponent<BaseCombatEntity>, IClientComponent
{
	[SerializeField]
	private bool startSampling = true;

	[SerializeField]
	private bool generateFakeTrail = true;

	[SerializeField]
	private float sampleIntervalSeconds = 1f;

	[Space]
	[SerializeField]
	private int minInitialPoints = 5;

	[SerializeField]
	private Vector2 initialDistanceRange = new Vector2(50f, 100f);

	[SerializeField]
	private float startAngleDeviation = 45f;

	[SerializeField]
	private float wiggleIntensity = 1f;

	[SerializeField]
	[Space]
	private LineRenderer[] lineRenderers;

	[SerializeField]
	private float heightOffset = 0.5f;

	[SerializeField]
	private bool snapToTerrain = true;
}


using System;
using UnityEngine;

public class AudioVisualisationEntityLight : AudioVisualisationEntity
{
	[Serializable]
	public struct LightColourSet
	{
		[ColorUsage(true, true)]
		public Color LightColor;

		[ColorUsage(true, true)]
		public Color SecondaryLightColour;

		[ColorUsage(true, true)]
		public Color EmissionColour;
	}

	public Light TargetLight;

	public Light SecondaryLight;

	public MeshRenderer[] TargetRenderer;

	public LightColourSet RedColour;

	public LightColourSet GreenColour;

	public LightColourSet BlueColour;

	public LightColourSet YellowColour;

	public LightColourSet PinkColour;

	public float lightMinIntensity = 0.05f;

	public float lightMaxIntensity = 1f;
}


using System;
using UnityEngine;

[Serializable]
public struct LightColourSet
{
	[ColorUsage(true, true)]
	public Color LightColor;

	[ColorUsage(true, true)]
	public Color SecondaryLightColour;

	[ColorUsage(true, true)]
	public Color EmissionColour;
}


