using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class BuildingBlock : StabilityEntity
{
	public static class BlockFlags
	{
		public const Flags CanRotate = Flags.Reserved1;
	}

	public class UpdateSkinWorkQueue : ObjectWorkQueue<BuildingBlock>
	{
		protected override void RunJob(BuildingBlock entity)
		{
			if (((ObjectWorkQueue<BuildingBlock>)this).ShouldAdd(entity))
			{
				entity.UpdateSkin(force: true);
			}
		}

		protected override bool ShouldAdd(BuildingBlock entity)
		{
			return entity.IsValid();
		}
	}

	[NonSerialized]
	public Construction blockDefinition;

	private static Vector3[] outsideLookupOffsets;

	private bool forceSkinRefresh;

	private ulong lastSkinID;

	public ulong lastModelState;

	private uint lastCustomColour;

	public uint playerCustomColourToApply;

	public BuildingGrade.Enum grade;

	public BuildingGrade.Enum lastGrade = BuildingGrade.Enum.None;

	public ConstructionSkin currentSkin;

	private DeferredAction skinChange;

	private MeshRenderer placeholderRenderer;

	private MeshCollider placeholderCollider;

	public static UpdateSkinWorkQueue updateSkinQueueServer;

	public static readonly Phrase RotateTitle;

	public static readonly Phrase RotateDesc;

	private bool globalNetworkCooldown;

	public bool CullBushes;

	public bool CheckForPipesOnModelChange;

	public OBBComponent AlternativePipeBounds;

	public bool useCastNoClipChecks;

	public const int WALLPAPER_MAXHEALTH = 100;

	[HideInInspector]
	public float wallpaperHealth = -1f;

	[HideInInspector]
	public float wallpaperRotation;

	[HideInInspector]
	public float wallpaperHealth2 = -1f;

	[HideInInspector]
	public float wallpaperRotation2;

	public ProtectionProperties wallpaperProtection;

	public override bool IsDemolishSupported => true;

	public ulong modelState { get; set; }

	public uint customColour { get; private set; }

	public ConstructionGrade currentGrade
	{
		get
		{
			if (blockDefinition == null)
			{
				Debug.LogWarning((object)$"blockDefinition is null for {base.ShortPrefabName} {grade} {skinID}");
				return null;
			}
			ConstructionGrade constructionGrade = blockDefinition.GetGrade(grade, skinID);
			if (constructionGrade == null)
			{
				Debug.LogWarning((object)$"currentGrade is null for {base.ShortPrefabName} {grade} {skinID}");
				return null;
			}
			return constructionGrade;
		}
	}

	public ulong wallpaperID { get; private set; }

	public ulong wallpaperID2 { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BuildingBlock.OnRpcMessage", 0);
		try
		{
			if (rpc == 1956645865 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoRotation "));
				}
				TimeWarning val2 = TimeWarning.New("DoRotation", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1956645865u, "DoRotation", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoRotation(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoRotation");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3746288057u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoUpgradeToGrade "));
				}
				TimeWarning val2 = TimeWarning.New("DoUpgradeToGrade", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3746288057u, "DoUpgradeToGrade", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							DoUpgradeToGrade(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in DoUpgradeToGrade");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 526349102 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_PickupWallpaperStart "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_PickupWallpaperStart", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(526349102u, "RPC_PickupWallpaperStart", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_PickupWallpaperStart(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_PickupWallpaperStart");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		blockDefinition = null;
		forceSkinRefresh = false;
		modelState = 0uL;
		lastModelState = 0uL;
		wallpaperID = 0uL;
		wallpaperID2 = 0uL;
		wallpaperHealth = -1f;
		wallpaperHealth2 = -1f;
		wallpaperRotation = 0f;
		wallpaperRotation2 = 0f;
		grade = BuildingGrade.Enum.Twigs;
		lastGrade = BuildingGrade.Enum.None;
		DestroySkin();
		UpdatePlaceholder(state: true);
	}

	public override void InitShared()
	{
		base.InitShared();
		placeholderRenderer = ((Component)this).GetComponent<MeshRenderer>();
		placeholderCollider = ((Component)this).GetComponent<MeshCollider>();
	}

	public override void PostInitShared()
	{
		baseProtection = currentGrade.gradeBase.damageProtecton;
		grade = currentGrade.gradeBase.type;
		base.PostInitShared();
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			RefreshNeighbours(linkToNeighbours: false);
		}
		base.DestroyShared();
	}

	public override string Categorize()
	{
		return "building";
	}

	public override float BoundsPadding()
	{
		return 1f;
	}

	public override bool IsOutside()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		float outside_test_range = ConVar.Decay.outside_test_range;
		Vector3 val = PivotPoint();
		for (int i = 0; i < outsideLookupOffsets.Length; i++)
		{
			Vector3 val2 = outsideLookupOffsets[i];
			Vector3 val3 = val + val2 * outside_test_range;
			if (!Physics.Raycast(new Ray(val3, -val2), outside_test_range - 0.5f, 2097152))
			{
				return true;
			}
		}
		return false;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool CanReturnEmptyBuildingPrivilege()
	{
		return true;
	}

	public void SetConditionalModel(ulong state)
	{
		if (state != modelState)
		{
			modelState = state;
			if (base.isServer)
			{
				GlobalNetworkHandler.server?.TrySendNetworkUpdate(this);
			}
		}
	}

	public bool GetConditionalModel(int index)
	{
		return (modelState & (ulong)(1L << index)) != 0;
	}

	public bool CanChangeToGrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", (object)player, (object)this, (object)iGrade, (object)iSkin);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if (HasUpgradePrivilege(iGrade, iSkin, player))
		{
			return !IsUpgradeBlocked();
		}
		return false;
	}

	public bool HasUpgradePrivilege(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if (iGrade < grade)
		{
			return false;
		}
		if (iGrade == grade && iSkin == skinID)
		{
			return false;
		}
		if (iGrade <= BuildingGrade.Enum.None)
		{
			return false;
		}
		if (iGrade >= BuildingGrade.Enum.Count)
		{
			return false;
		}
		return !player.IsBuildingBlocked(((Component)this).transform.position, ((Component)this).transform.rotation, bounds);
	}

	public bool IsUpgradeBlocked()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (!blockDefinition.checkVolumeOnUpgrade)
		{
			return false;
		}
		DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(prefabID);
		return DeployVolume.Check(((Component)this).transform.position, ((Component)this).transform.rotation, volumes, ~(1 << ((Component)this).gameObject.layer));
	}

	public bool CanAffordUpgrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", (object)player, (object)this, (object)iGrade, (object)iSkin);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)player != (Object)null && player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if (!ConVar.Decay.CanUpgradeToGrade(iGrade))
		{
			return false;
		}
		foreach (ItemAmount item in blockDefinition.GetGrade(iGrade, iSkin).CostToBuild(grade))
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

	public void SetGrade(BuildingGrade.Enum iGrade)
	{
		if (blockDefinition.grades == null || iGrade <= BuildingGrade.Enum.None || iGrade >= BuildingGrade.Enum.Count)
		{
			Debug.LogError((object)("Tried to set to undefined grade! " + blockDefinition.fullName), (Object)(object)((Component)this).gameObject);
			return;
		}
		grade = iGrade;
		grade = currentGrade.gradeBase.type;
		UpdateGrade();
	}

	public void UpdateGrade()
	{
		baseProtection = currentGrade.gradeBase.damageProtecton;
	}

	protected override void OnSkinChanged(ulong oldSkinID, ulong newSkinID)
	{
		if (oldSkinID != newSkinID)
		{
			skinID = newSkinID;
		}
	}

	protected override void OnSkinPreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}

	public void SetHealthToMax()
	{
		base.health = MaxHealth();
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoUpgradeToGrade(RPCMessage msg)
	{
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		if (!msg.player.CanInteract())
		{
			return;
		}
		ConstructionGrade constructionGrade = blockDefinition.GetGrade((BuildingGrade.Enum)msg.read.Int32(), msg.read.UInt64());
		if (constructionGrade == null)
		{
			return;
		}
		if (!CanChangeToGrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))
		{
			if (!((Object)(object)DeployVolume.LastDeployHit != (Object)null))
			{
				return;
			}
			BaseEntity baseEntity = DeployVolume.LastDeployHit.ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null && baseEntity is BasePlayer basePlayer)
			{
				ulong currentTeam = msg.player.currentTeam;
				if (currentTeam != 0L && currentTeam == basePlayer.currentTeam)
				{
					string playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);
					msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, false, playerNameStreamSafe);
				}
			}
		}
		else
		{
			if (Interface.CallHook("OnStructureUpgrade", (object)this, (object)msg.player, (object)constructionGrade.gradeBase.type, (object)constructionGrade.gradeBase.skin) != null || !CanAffordUpgrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))
			{
				return;
			}
			if (base.SecondsSinceAttacked < 30f)
			{
				msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString("N0"));
				return;
			}
			if (!constructionGrade.gradeBase.alwaysUnlock && constructionGrade.gradeBase.skin != 0L && !msg.player.blueprints.steamInventory.HasItem((int)constructionGrade.gradeBase.skin))
			{
				msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.SkinNotOwned, false);
				return;
			}
			PayForUpgrade(constructionGrade, msg.player);
			if ((Object)(object)msg.player != (Object)null)
			{
				playerCustomColourToApply = GetShippingContainerBlockColourForPlayer(msg.player);
			}
			ClientRPC(RpcTarget.NetworkGroup("DoUpgradeEffect"), (int)constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
			BuildingGrade.Enum @enum = grade;
			Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, constructionGrade.gradeBase.type, playerCustomColourToApply, constructionGrade.gradeBase.skin);
			OnSkinChanged(skinID, constructionGrade.gradeBase.skin);
			ChangeGrade(constructionGrade.gradeBase.type, playEffect: true);
			if ((Object)(object)msg.player != (Object)null && @enum != constructionGrade.gradeBase.type)
			{
				msg.player.ProcessMissionEvent(BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE, new BaseMission.MissionEventPayload
				{
					NetworkIdentifier = net.ID,
					IntIdentifier = (int)constructionGrade.gradeBase.type
				}, 1f);
			}
			Interface.CallHook("OnStructureUpgraded", (object)this, (object)msg.player, (object)constructionGrade.gradeBase.type, (object)constructionGrade.gradeBase.skin);
			timePlaced = GetNetworkTime();
		}
	}

	private uint GetShippingContainerBlockColourForPlayer(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return 0u;
		}
		int infoInt = player.GetInfoInt("client.SelectedShippingContainerBlockColour", 0);
		if (infoInt >= 0)
		{
			return (uint)infoInt;
		}
		return 0u;
	}

	public void ChangeGradeAndSkin(BuildingGrade.Enum targetGrade, ulong skin, bool playEffect = false, bool updateSkin = true)
	{
		OnSkinChanged(skinID, skin);
		ChangeGrade(targetGrade, playEffect, updateSkin);
	}

	public void ChangeGrade(BuildingGrade.Enum targetGrade, bool playEffect = false, bool updateSkin = true)
	{
		SetGrade(targetGrade);
		if (grade != lastGrade)
		{
			SetHealthToMax();
			StartBeingRotatable();
		}
		if (updateSkin)
		{
			UpdateSkin();
		}
		SendNetworkUpdate();
		ResetUpkeepTime();
		UpdateSurroundingEntities();
		GlobalNetworkHandler.server.TrySendNetworkUpdate(this);
		BuildingManager.server.GetBuilding(buildingID)?.Dirty();
	}

	public void PayForUpgrade(ConstructionGrade g, BasePlayer player)
	{
		if (Interface.CallHook("OnPayForUpgrade", (object)player, (object)this, (object)g) != null || (player.IsInCreativeMode && Creative.freeBuild))
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in g.CostToBuild(grade))
		{
			player.inventory.Take(list, item.itemid, (int)item.amount);
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.itemid);
			Analytics.Azure.LogResource(Analytics.Azure.ResourceMode.Consumed, "upgrade_block", itemDefinition.shortname, (int)item.amount, this, null, safezone: false, null, player.userID);
			player.Command("note.inv " + item.itemid + " " + item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

	public void SetCustomColour(uint newColour)
	{
		if (newColour != customColour)
		{
			customColour = newColour;
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.NetworkGroup("RefreshSkin"));
			GlobalNetworkHandler.server.TrySendNetworkUpdate(this);
		}
	}

	public bool NeedsSkinChange()
	{
		if (!((Object)(object)currentSkin == (Object)null) && !forceSkinRefresh && lastGrade == grade && lastModelState == modelState)
		{
			return lastSkinID != skinID;
		}
		return true;
	}

	public void UpdateSkin(bool force = false)
	{
		if (force)
		{
			forceSkinRefresh = true;
		}
		if (!NeedsSkinChange())
		{
			return;
		}
		if (cachedStability <= 0f || base.isServer)
		{
			ChangeSkin();
			return;
		}
		if (!skinChange)
		{
			skinChange = new DeferredAction((Object)(object)this, ChangeSkin);
		}
		if (skinChange.Idle)
		{
			skinChange.Invoke();
		}
	}

	private void DestroySkin()
	{
		if ((Object)(object)currentSkin != (Object)null)
		{
			currentSkin.Destroy(this);
			currentSkin = null;
		}
	}

	public void RefreshNeighbours(bool linkToNeighbours)
	{
		List<EntityLink> entityLinks = GetEntityLinks(linkToNeighbours);
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			for (int j = 0; j < entityLink.connections.Count; j++)
			{
				BuildingBlock buildingBlock = entityLink.connections[j].owner as BuildingBlock;
				if (!((Object)(object)buildingBlock == (Object)null))
				{
					if (Application.isLoading)
					{
						buildingBlock.UpdateSkin(force: true);
					}
					else
					{
						((ObjectWorkQueue<BuildingBlock>)updateSkinQueueServer).Add(buildingBlock);
					}
				}
			}
		}
	}

	private void UpdatePlaceholder(bool state)
	{
		if (Object.op_Implicit((Object)(object)placeholderRenderer))
		{
			((Renderer)placeholderRenderer).enabled = state;
		}
		if (Object.op_Implicit((Object)(object)placeholderCollider))
		{
			((Collider)placeholderCollider).enabled = state;
		}
	}

	private void ChangeSkin()
	{
		if (base.IsDestroyed)
		{
			return;
		}
		ConstructionGrade constructionGrade = currentGrade;
		if (currentGrade == null)
		{
			Debug.LogWarning((object)"CurrentGrade is null!");
			return;
		}
		if (constructionGrade.skinObject.isValid)
		{
			ChangeSkin(constructionGrade.skinObject);
			return;
		}
		ConstructionGrade defaultGrade = blockDefinition.defaultGrade;
		if (defaultGrade.skinObject.isValid)
		{
			ChangeSkin(defaultGrade.skinObject);
		}
		else
		{
			Debug.LogWarning((object)("No skins found for " + (object)((Component)this).gameObject));
		}
	}

	public void ChangeSkin(GameObjectRef prefab)
	{
		bool flag = lastGrade != grade || lastSkinID != skinID;
		lastGrade = grade;
		lastSkinID = skinID;
		if (flag)
		{
			if ((Object)(object)currentSkin == (Object)null)
			{
				UpdatePlaceholder(state: false);
			}
			else
			{
				DestroySkin();
			}
			GameObject val = base.gameManager.CreatePrefab(prefab.resourcePath, ((Component)this).transform);
			currentSkin = val.GetComponent<ConstructionSkin>();
			if ((Object)(object)currentSkin != (Object)null && base.isServer && !Application.isLoading)
			{
				customColour = currentSkin.GetStartingDetailColour(playerCustomColourToApply);
			}
			Model component = ((Component)currentSkin).GetComponent<Model>();
			SetModel(component);
			Assert.IsTrue((Object)(object)model == (Object)(object)component, "Didn't manage to set model successfully!");
		}
		if (base.isServer)
		{
			SetConditionalModel(currentSkin.DetermineConditionalModelState(this));
		}
		bool flag2 = lastModelState != modelState;
		lastModelState = modelState;
		bool flag3 = lastCustomColour != customColour;
		lastCustomColour = customColour;
		if (flag || flag2 || forceSkinRefresh || flag3)
		{
			currentSkin.Refresh(this);
			if (base.isServer && flag2)
			{
				CheckForPipes();
			}
			forceSkinRefresh = false;
		}
		if (base.isServer)
		{
			if (flag)
			{
				RefreshNeighbours(linkToNeighbours: true);
			}
			if (flag2)
			{
				SendNetworkUpdate();
			}
			timePlaced = GetNetworkTime();
		}
	}

	public override bool ShouldBlockProjectiles()
	{
		return grade != BuildingGrade.Enum.Twigs;
	}

	[ContextMenu("Check for pipes")]
	public void CheckForPipes()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckForPipesOnModelChange || !ConVar.Server.enforcePipeChecksOnBuildingBlockChanges || Application.isLoading)
		{
			return;
		}
		List<ColliderInfo_Pipe> list = Pool.Get<List<ColliderInfo_Pipe>>();
		Bounds val = bounds;
		((Bounds)(ref val)).extents = ((Bounds)(ref val)).extents * 0.97f;
		Vis.Components<ColliderInfo_Pipe>((OBB)(((Object)(object)AlternativePipeBounds != (Object)null) ? AlternativePipeBounds.GetObb() : new OBB(((Component)this).transform, val)), list, 536870912, (QueryTriggerInteraction)2);
		foreach (ColliderInfo_Pipe item in list)
		{
			if (!((Object)(object)item == (Object)null) && ((Component)item).gameObject.activeInHierarchy && item.HasFlag(ColliderInfo.Flags.OnlyBlockBuildingBlock) && (Object)(object)item.ParentEntity != (Object)null && item.ParentEntity.isServer)
			{
				WireTool.AttemptClearSlot(item.ParentEntity, null, item.OutputSlotIndex, isInput: false);
			}
		}
		Pool.FreeUnmanaged<ColliderInfo_Pipe>(ref list);
	}

	private void OnHammered()
	{
	}

	public override float MaxHealth()
	{
		return currentGrade.maxHealth;
	}

	public override List<ItemAmount> BuildCost()
	{
		return currentGrade.CostToBuild();
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		base.OnHealthChanged(oldvalue, newvalue);
		if (base.isServer && Mathf.RoundToInt(oldvalue) != Mathf.RoundToInt(newvalue))
		{
			SendNetworkUpdate(BasePlayer.NetworkQueue.UpdateDistance);
		}
	}

	public override float RepairCostFraction()
	{
		return 1f;
	}

	public bool CanRotate(BasePlayer player)
	{
		if (IsRotatable() && HasRotationPrivilege(player))
		{
			return !IsRotationBlocked();
		}
		return false;
	}

	public bool IsRotatable()
	{
		if (blockDefinition.grades == null)
		{
			return false;
		}
		if (!blockDefinition.canRotateAfterPlacement)
		{
			return false;
		}
		if (!HasFlag(Flags.Reserved1))
		{
			return false;
		}
		return true;
	}

	public bool IsRotationBlocked()
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		if (children != null)
		{
			foreach (BaseEntity child in children)
			{
				if (child is TimedExplosive)
				{
					return true;
				}
			}
		}
		if (!blockDefinition.checkVolumeOnRotate)
		{
			return false;
		}
		DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(prefabID);
		return DeployVolume.Check(((Component)this).transform.position, ((Component)this).transform.rotation, volumes, ~(1 << ((Component)this).gameObject.layer));
	}

	public bool HasRotationPrivilege(BasePlayer player)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return !player.IsBuildingBlocked(((Component)this).transform.position, ((Component)this).transform.rotation, bounds);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void DoRotation(RPCMessage msg)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotateAfterPlacement && Interface.CallHook("OnStructureRotate", (object)this, (object)msg.player) == null)
		{
			Transform transform = ((Component)this).transform;
			transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);
			RefreshEntityLinks();
			UpdateSurroundingEntities();
			UpdateSkin(force: true);
			RefreshNeighbours(linkToNeighbours: false);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.NetworkGroup("RefreshSkin"));
			if (!globalNetworkCooldown)
			{
				globalNetworkCooldown = true;
				GlobalNetworkHandler.server.TrySendNetworkUpdate(this);
				((FacepunchBehaviour)this).CancelInvoke((Action)ResetGlobalNetworkCooldown);
				((FacepunchBehaviour)this).Invoke((Action)ResetGlobalNetworkCooldown, 15f);
			}
		}
	}

	private void ResetGlobalNetworkCooldown()
	{
		globalNetworkCooldown = false;
		GlobalNetworkHandler.server.TrySendNetworkUpdate(this);
	}

	public void StopBeingRotatable()
	{
		SetFlag(Flags.Reserved1, b: false);
		SendNetworkUpdate();
	}

	public void StartBeingRotatable()
	{
		if (blockDefinition.grades != null && blockDefinition.canRotateAfterPlacement)
		{
			SetFlag(Flags.Reserved1, b: true);
			((FacepunchBehaviour)this).Invoke((Action)StopBeingRotatable, 600f);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.buildingBlock = Pool.Get<BuildingBlock>();
		info.msg.buildingBlock.model = modelState;
		info.msg.buildingBlock.grade = (int)grade;
		info.msg.buildingBlock.wallpaperID = wallpaperID;
		info.msg.buildingBlock.wallpaperID2 = wallpaperID2;
		info.msg.buildingBlock.wallpaperHealth = wallpaperHealth;
		info.msg.buildingBlock.wallpaperHealth2 = wallpaperHealth2;
		info.msg.buildingBlock.wallpaperRotation = wallpaperRotation;
		info.msg.buildingBlock.wallpaperRotation2 = wallpaperRotation2;
		if (customColour != 0)
		{
			info.msg.simpleUint = Pool.Get<SimpleUInt>();
			info.msg.simpleUint.value = customColour;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		customColour = 0u;
		if (info.msg.simpleUint != null)
		{
			customColour = info.msg.simpleUint.value;
		}
		if (info.msg.buildingBlock != null)
		{
			wallpaperID = info.msg.buildingBlock.wallpaperID;
			wallpaperID2 = info.msg.buildingBlock.wallpaperID2;
			wallpaperHealth = info.msg.buildingBlock.wallpaperHealth;
			wallpaperHealth2 = info.msg.buildingBlock.wallpaperHealth2;
			wallpaperRotation = info.msg.buildingBlock.wallpaperRotation;
			wallpaperRotation2 = info.msg.buildingBlock.wallpaperRotation2;
			SetConditionalModel(info.msg.buildingBlock.model);
			SetGrade((BuildingGrade.Enum)info.msg.buildingBlock.grade);
		}
		if (info.fromDisk)
		{
			SetFlag(Flags.Reserved1, b: false);
			UpdateSkin();
		}
	}

	public override void AttachToBuilding(DecayEntity other)
	{
		if ((Object)(object)other != (Object)null && other is BuildingBlock)
		{
			AttachToBuilding(other.buildingID);
			BuildingManager.server.CheckMerge(this);
		}
		else
		{
			AttachToBuilding(BuildingManager.server.NewBuildingID());
		}
	}

	public override void ServerInit()
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		blockDefinition = PrefabAttribute.server.Find<Construction>(prefabID);
		if (blockDefinition == null)
		{
			Debug.LogError((object)("Couldn't find Construction for prefab " + prefabID));
		}
		base.ServerInit();
		UpdateSkin();
		if (HasFlag(Flags.Reserved1) || !Application.isLoadingSave)
		{
			StartBeingRotatable();
		}
		if (!CullBushes || Application.isLoadingSave)
		{
			return;
		}
		List<BushEntity> list = Pool.Get<List<BushEntity>>();
		Vis.Entities(WorldSpaceBounds(), list, 67108864, (QueryTriggerInteraction)2);
		foreach (BushEntity item in list)
		{
			if (item.isServer)
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<BushEntity>(ref list);
	}

	public override void Hurt(HitInfo info)
	{
		if (ConVar.Server.pve && Object.op_Implicit((Object)(object)info.Initiator) && info.Initiator is BasePlayer)
		{
			if (Interface.CallHook("OnPlayerPveDamage", (object)info.Initiator, (object)info, (object)this) == null)
			{
				(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)info.Initiator) && info.Initiator is BasePlayer { IsInTutorial: not false })
			{
				return;
			}
			if (HasWallpaper())
			{
				DamageType majorityDamageType = info.damageTypes.GetMajorityDamageType();
				bool flag = info.damageTypes.Contains(DamageType.Explosion);
				DamageTypeList damageTypeList = info.damageTypes.Clone();
				if ((Object)(object)wallpaperProtection != (Object)null)
				{
					wallpaperProtection.Scale(damageTypeList);
				}
				float totalDamage = damageTypeList.Total();
				if (majorityDamageType == DamageType.Decay || flag || majorityDamageType == DamageType.Heat)
				{
					DamageWallpaper(totalDamage);
					DamageWallpaper(totalDamage, 1);
				}
				else
				{
					bool flag2 = false;
					for (int i = 0; i < propDirection.Length; i++)
					{
						if (propDirection[i].IsWeakspot(((Component)this).transform, info))
						{
							flag2 = true;
							break;
						}
					}
					DamageWallpaper(totalDamage, (!flag2) ? 1 : 0);
				}
			}
			base.Hurt(info);
		}
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		if (!useCastNoClipChecks)
		{
			return base.ShouldUseCastNoClipChecks();
		}
		return true;
	}

	public bool HasWallpaper()
	{
		if (!(wallpaperHealth > 0f))
		{
			return wallpaperHealth2 > 0f;
		}
		return true;
	}

	public bool HasWallpaper(int side)
	{
		if (side != 0)
		{
			return wallpaperHealth2 > 0f;
		}
		return wallpaperHealth > 0f;
	}

	public ulong GetWallpaperSkin(int side)
	{
		if (side != 0)
		{
			return wallpaperID2;
		}
		return wallpaperID;
	}

	public float GetWallpaperRotation(int side)
	{
		if (side != 0)
		{
			return wallpaperRotation2;
		}
		return wallpaperRotation;
	}

	public void SetWallpaper(ulong id, int side = 0, float rotation = 0f)
	{
		if (Interface.CallHook("OnWallpaperSet", (object)this, (object)id, (object)side, (object)rotation) != null)
		{
			return;
		}
		if (side == 0)
		{
			if (HasWallpaper(side) && wallpaperID == id && wallpaperRotation == rotation)
			{
				return;
			}
			wallpaperID = id;
			wallpaperHealth = 100f;
			wallpaperRotation = rotation;
		}
		else
		{
			if (HasWallpaper(side) && wallpaperID2 == id && wallpaperRotation2 == rotation)
			{
				return;
			}
			wallpaperID2 = id;
			wallpaperHealth2 = 100f;
			wallpaperRotation2 = rotation;
		}
		if (base.isServer)
		{
			SetConditionalModel(currentSkin.DetermineConditionalModelState(this));
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.NetworkGroup("RefreshSkin"));
		}
	}

	public void RemoveWallpaper(int side)
	{
		if (Interface.CallHook("OnWallpaperRemove", (object)this, (object)side) == null)
		{
			switch (side)
			{
			case 0:
				wallpaperHealth = -1f;
				wallpaperID = 0uL;
				wallpaperRotation = 0f;
				break;
			case 1:
				wallpaperHealth2 = -1f;
				wallpaperID2 = 0uL;
				wallpaperRotation2 = 0f;
				break;
			}
			if (base.isServer)
			{
				SetConditionalModel(currentSkin.DetermineConditionalModelState(this));
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.NetworkGroup("RefreshSkin"));
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_PickupWallpaperStart(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanPickup(msg.player))
		{
			bool flag = msg.read.Bool();
			if (HasWallpaper((!flag) ? 1 : 0))
			{
				Item item = ItemManager.Create(WallpaperPlanner.Settings.PlacementPrice.itemDef, (int)WallpaperPlanner.Settings.PlacementPrice.amount, 0uL);
				msg.player.GiveItem(item, GiveItemReason.PickedUp);
				RemoveWallpaper((!flag) ? 1 : 0);
			}
		}
	}

	private void DamageWallpaper(float totalDamage, int side = 0)
	{
		switch (side)
		{
		case 0:
			wallpaperHealth -= totalDamage;
			if (wallpaperHealth <= 0f)
			{
				RemoveWallpaper(0);
			}
			break;
		case 1:
			wallpaperHealth2 -= totalDamage;
			if (wallpaperHealth2 <= 0f)
			{
				RemoveWallpaper(1);
			}
			break;
		}
	}

	public override void StabilityCheck()
	{
		base.StabilityCheck();
		if (HasWallpaper())
		{
			((FacepunchBehaviour)this).Invoke((Action)CheckWallpaper, 0.5f);
		}
	}

	public override void OnDecay(Decay decay, float decayDeltaTime)
	{
		base.OnDecay(decay, decayDeltaTime);
		if (HasWallpaper())
		{
			CheckWallpaper();
		}
	}

	public void CheckWallpaper()
	{
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		if (Creative.allUsers && Creative.freePlacement)
		{
			return;
		}
		int side = WallpaperPlanner.Settings.GetSideThatMustBeInside(this);
		if (side == -1 || !HasWallpaper(side))
		{
			return;
		}
		Construction construction = WallpaperPlanner.Settings?.GetConstruction(this, 0);
		if (construction == null)
		{
			construction = WallpaperPlanner.Settings?.GetConstruction(this, 1);
			if (construction == null)
			{
				return;
			}
		}
		Socket_Base socket_Base = PrefabAttribute.server.FindAll<Socket_Base>(prefabID).FirstOrDefault((Socket_Base s) => s.socketName.Contains("wallpaper") && s.socketName.EndsWith((side == 0) ? "1" : "2"));
		if (socket_Base == null)
		{
			return;
		}
		SocketMod[] array = PrefabAttribute.server.FindAll<SocketMod>(construction.prefabID);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] is SocketMod_Inside socketMod_Inside)
			{
				Construction.Placement place = new Construction.Placement(default(Construction.Target));
				place.position = ((Component)this).transform.position + ((Component)this).transform.rotation * socket_Base.localPosition;
				place.rotation = ((Component)this).transform.rotation * socket_Base.localRotation;
				if (!socketMod_Inside.DoCheck(place))
				{
					RemoveWallpaper(side);
					break;
				}
			}
		}
	}

	public bool CanSeeWallpaperSocket(BasePlayer player, int side = 0)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		Construction construction = WallpaperPlanner.Settings?.GetConstruction(this, side);
		if (construction == null)
		{
			return false;
		}
		Vector3 center = player.eyes.center;
		Vector3 position = player.eyes.position;
		if (!GamePhysics.LineOfSightRadius(center, position, 2162688, 0f))
		{
			return false;
		}
		Socket_Base socket_Base = PrefabAttribute.server.FindAll<Socket_Base>(prefabID).FirstOrDefault((Socket_Base s) => s.socketName.Contains("wallpaper") && s.socketName.EndsWith((side == 0) ? "1" : "2"));
		if (socket_Base == null)
		{
			return false;
		}
		Transform deployOffset = construction.deployOffset;
		Vector3 val = ((deployOffset != null) ? deployOffset.localPosition : Vector3.zero);
		Vector3 val2 = socket_Base.rotation * val;
		Vector3 val3 = ((Component)this).transform.position + ((Component)this).transform.rotation * val2;
		bool flag = false;
		Ray val4 = player.eyes.HeadRay();
		Vector3 val5 = val3 - ((Ray)(ref val4)).origin;
		val4 = player.eyes.HeadRay();
		if (!Physics.Raycast(new Ray(((Ray)(ref val4)).origin, ((Vector3)(ref val5)).normalized), ((Vector3)(ref val5)).magnitude, 2097152))
		{
			flag = true;
		}
		if (!flag && construction.HasAlternativeLOSChecks())
		{
			Vector3[] alternativeLOSPositions = construction.alternativeLOSPositions;
			foreach (Vector3 val6 in alternativeLOSPositions)
			{
				Vector3 val7 = ((Component)this).transform.position + ((Component)this).transform.rotation * socket_Base.localPosition;
				Quaternion val8 = ((Component)this).transform.rotation * socket_Base.localRotation;
				Vector3 val9 = val7 + val8 * val6 - center;
				if (!Physics.Raycast(center, val9, ((Vector3)(ref val9)).magnitude, 2097152))
				{
					flag = true;
					break;
				}
			}
		}
		return flag;
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (!HasWallpaper())
		{
			return false;
		}
		if (player.IsHoldingEntity<Hammer>() && player.CanBuild())
		{
			if (!HasWallpaper(0) || !CanSeeWallpaperSocket(player))
			{
				if (HasWallpaper(1))
				{
					return CanSeeWallpaperSocket(player, 1);
				}
				return false;
			}
			return true;
		}
		return false;
	}

	static BuildingBlock()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Expected O, but got Unknown
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Expected O, but got Unknown
		Vector3[] array = new Vector3[5];
		Vector3 val = new Vector3(0f, 1f, 0f);
		array[0] = ((Vector3)(ref val)).normalized;
		val = new Vector3(1f, 1f, 0f);
		array[1] = ((Vector3)(ref val)).normalized;
		val = new Vector3(-1f, 1f, 0f);
		array[2] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 1f, 1f);
		array[3] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 1f, -1f);
		array[4] = ((Vector3)(ref val)).normalized;
		outsideLookupOffsets = (Vector3[])(object)array;
		updateSkinQueueServer = new UpdateSkinWorkQueue();
		RotateTitle = new Phrase("rotate", "Rotate");
		RotateDesc = new Phrase("rotate_building_desc", "Rotate or flip this block to face a different direction");
	}
}


public static class BlockFlags
{
	public const Flags CanRotate = Flags.Reserved1;
}


public class UpdateSkinWorkQueue : ObjectWorkQueue<BuildingBlock>
{
	protected override void RunJob(BuildingBlock entity)
	{
		if (((ObjectWorkQueue<BuildingBlock>)this).ShouldAdd(entity))
		{
			entity.UpdateSkin(force: true);
		}
	}

	protected override bool ShouldAdd(BuildingBlock entity)
	{
		return entity.IsValid();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class BuildingPrivlidge : StorageContainer
{
	public class UpkeepBracket
	{
		public int objectsUpTo;

		public float fraction;

		public float blocksTaxPaid;

		public UpkeepBracket(int numObjs, float frac)
		{
			objectsUpTo = numObjs;
			fraction = frac;
			blocksTaxPaid = 0f;
		}
	}

	public GameObject assignDialog;

	[NonSerialized]
	public HashSet<PlayerNameID> authorizedPlayers = new HashSet<PlayerNameID>();

	public const Flags Flag_MaxAuths = Flags.Reserved5;

	public const Flags Flag_BlockAllFromBuilding = Flags.Reserved6;

	public List<ItemDefinition> allowedConstructionItems = new List<ItemDefinition>();

	public float cachedProtectedMinutes;

	public float nextProtectedCalcTime;

	public static UpkeepBracket[] upkeepBrackets = new UpkeepBracket[4]
	{
		new UpkeepBracket(ConVar.Decay.bracket_0_blockcount, ConVar.Decay.bracket_0_costfraction),
		new UpkeepBracket(ConVar.Decay.bracket_1_blockcount, ConVar.Decay.bracket_1_costfraction),
		new UpkeepBracket(ConVar.Decay.bracket_2_blockcount, ConVar.Decay.bracket_2_costfraction),
		new UpkeepBracket(0, ConVar.Decay.bracket_3_costfraction)
	};

	private static UpkeepBracket[] doorUpkeepBrackets = new UpkeepBracket[4]
	{
		new UpkeepBracket(ConVar.Decay.bracket_0_doorcount, ConVar.Decay.bracket_0_doorfraction),
		new UpkeepBracket(ConVar.Decay.bracket_1_doorcount, ConVar.Decay.bracket_1_doorfraction),
		new UpkeepBracket(ConVar.Decay.bracket_2_doorcount, ConVar.Decay.bracket_2_doorfraction),
		new UpkeepBracket(0, ConVar.Decay.bracket_3_doorfraction)
	};

	public List<ItemAmount> upkeepBuffer = new List<ItemAmount>();

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BuildingPrivlidge.OnRpcMessage", 0);
		try
		{
			if (rpc == 82205621 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AddAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("AddAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(82205621u, "AddAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							AddAuthorize(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AddAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 253307592 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearList "));
				}
				TimeWarning val2 = TimeWarning.New("ClearList", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(253307592u, "ClearList", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							ClearList(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ClearList");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3617985969u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RemoveSelfAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("RemoveSelfAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3617985969u, "RemoveSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							RemoveSelfAuthorize(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RemoveSelfAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2051750736 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Rotate "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Rotate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2051750736u, "RPC_Rotate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Rotate(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_Rotate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnDeployableCorpseSpawned(BaseEntity corpse)
	{
		base.OnDeployableCorpseSpawned(corpse);
		BuildingPrivlidge componentInChildren = ((Component)corpse).GetComponentInChildren<BuildingPrivlidge>();
		if ((Object)(object)componentInChildren == (Object)null)
		{
			Debug.LogError((object)"Not able to transfer auth of TC to corpse: BuildingPrivlidge component not found in child");
			return;
		}
		componentInChildren.SetAuthListFrom(this);
		componentInChildren.AttachToBuilding(buildingID);
	}

	public override bool ShouldDropDeployableCorpse(HitInfo info)
	{
		BuildingManager.Building building = GetBuilding();
		if (building == null)
		{
			return false;
		}
		if (building.buildingBlocks == null || building.buildingBlocks.Count == 0)
		{
			return false;
		}
		return base.ShouldDropDeployableCorpse(info);
	}

	public override void ResetState()
	{
		base.ResetState();
		authorizedPlayers.Clear();
	}

	public bool CanBuild(BasePlayer player)
	{
		if (HasFlag(Flags.Reserved6))
		{
			return false;
		}
		return IsAuthed(player);
	}

	public bool IsAuthed(BasePlayer player)
	{
		return IsAuthed(player.userID);
	}

	public bool IsAuthed(ulong userId)
	{
		return authorizedPlayers.Any((PlayerNameID x) => x.userid == userId);
	}

	public bool AnyAuthed()
	{
		return authorizedPlayers.Count > 0;
	}

	public void SetAuthListFrom(BuildingPrivlidge source)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Expected O, but got Unknown
		authorizedPlayers = new HashSet<PlayerNameID>();
		foreach (PlayerNameID authorizedPlayer in source.authorizedPlayers)
		{
			authorizedPlayers.Add(new PlayerNameID
			{
				ShouldPool = false,
				userid = authorizedPlayer.userid,
				username = authorizedPlayer.username
			});
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		bool flag = allowedConstructionItems.Contains(item.info);
		if (!flag && targetSlot == -1)
		{
			int num = 0;
			foreach (Item item2 in base.inventory.itemList)
			{
				if (!allowedConstructionItems.Contains(item2.info) && ((Object)(object)item2.info != (Object)(object)item.info || item2.amount == item2.MaxStackable()))
				{
					num++;
				}
			}
			if (num >= 24)
			{
				return false;
			}
		}
		if (targetSlot >= 24 && targetSlot <= 28)
		{
			return flag;
		}
		return base.ItemFilter(item, targetSlot);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.buildingPrivilege = Pool.Get<BuildingPrivilege>();
		if (!info.forDisk)
		{
			info.msg.buildingPrivilege.upkeepPeriodMinutes = CalculateUpkeepPeriodMinutes();
			info.msg.buildingPrivilege.costFraction = CalculateUpkeepCostFraction(doors: false);
			info.msg.buildingPrivilege.doorCostFraction = CalculateUpkeepCostFraction(doors: true);
			info.msg.buildingPrivilege.protectedMinutes = GetProtectedMinutes();
			info.msg.buildingPrivilege.clientAuthed = IsAuthed(info.forConnection.userid);
			info.msg.buildingPrivilege.clientAnyAuthed = AnyAuthed();
		}
		if (!info.forDisk && !info.msg.buildingPrivilege.clientAuthed)
		{
			return;
		}
		info.msg.buildingPrivilege.users = Pool.Get<List<PlayerNameID>>();
		foreach (PlayerNameID authorizedPlayer in authorizedPlayers)
		{
			info.msg.buildingPrivilege.users.Add(authorizedPlayer.Copy());
		}
	}

	public override bool CanUseNetworkCache(Connection connection)
	{
		return false;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		foreach (PlayerNameID authorizedPlayer in authorizedPlayers)
		{
			if (authorizedPlayer != null)
			{
				PlayerNameID val = authorizedPlayer;
				Pool.Free<PlayerNameID>(ref val);
			}
		}
		authorizedPlayers.Clear();
		if (info.msg.buildingPrivilege == null)
		{
			return;
		}
		if (info.msg.buildingPrivilege.users != null)
		{
			foreach (PlayerNameID user in info.msg.buildingPrivilege.users)
			{
				authorizedPlayers.Add(user.Copy());
			}
		}
		if (!info.fromDisk)
		{
			cachedProtectedMinutes = info.msg.buildingPrivilege.protectedMinutes;
		}
	}

	public void BuildingDirty()
	{
		if (base.isServer)
		{
			AddDelayedUpdate();
		}
	}

	public bool AtMaxAuthCapacity()
	{
		return HasFlag(Flags.Reserved5);
	}

	public void UpdateMaxAuthCapacity()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode) && activeGameMode.limitTeamAuths)
		{
			SetFlag(Flags.Reserved5, authorizedPlayers.Count >= activeGameMode.GetMaxRelationshipTeamSize());
		}
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		AddDelayedUpdate();
	}

	public override void OnItemAddedOrRemoved(Item item, bool bAdded)
	{
		base.OnItemAddedOrRemoved(item, bAdded);
		AddDelayedUpdate();
	}

	public void AddDelayedUpdate()
	{
		if (((FacepunchBehaviour)this).IsInvoking((Action)DelayedUpdate))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)DelayedUpdate);
		}
		((FacepunchBehaviour)this).Invoke((Action)DelayedUpdate, 1f);
	}

	public void DelayedUpdate()
	{
		MarkProtectedMinutesDirty();
		SendNetworkUpdate();
	}

	public bool CanAdministrate(BasePlayer player)
	{
		BaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;
		if ((Object)(object)baseLock == (Object)null)
		{
			return true;
		}
		return baseLock.OnTryToOpen(player);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void AddAuthorize(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanAdministrate(rpc.player))
		{
			ulong num = rpc.read.UInt64();
			if (Interface.CallHook("IOnCupboardAuthorize", (object)num, (object)rpc.player, (object)this) == null)
			{
				AddPlayer(rpc.player, num);
				SendNetworkUpdate();
			}
		}
	}

	public void AddPlayer(BasePlayer granter, ulong targetPlayerId)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		if (!AtMaxAuthCapacity())
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == targetPlayerId);
			PlayerNameID val = new PlayerNameID();
			val.userid = targetPlayerId;
			string username = BasePlayer.FindByID(targetPlayerId)?.displayName ?? "unknown";
			val.username = username;
			authorizedPlayers.Add(val);
			Analytics.Azure.OnEntityAuthChanged(this, granter, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", targetPlayerId);
			UpdateMaxAuthCapacity();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (rpc2.player.CanInteract() && CanAdministrate(rpc2.player) && Interface.CallHook("OnCupboardDeauthorize", (object)this, (object)rpc.player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)rpc2.player.userID);
			Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc2.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void ClearList(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanAdministrate(rpc.player) && Interface.CallHook("OnCupboardClearList", (object)this, (object)rpc.player) == null)
		{
			authorizedPlayers.Clear();
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Rotate(RPCMessage msg)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (player.CanBuild() && Object.op_Implicit((Object)(object)player.GetHeldEntity()) && (Object)(object)((Component)player.GetHeldEntity()).GetComponent<Hammer>() != (Object)null && ((Object)(object)GetSlot(Slot.Lock) == (Object)null || !GetSlot(Slot.Lock).IsLocked()) && !HasAttachedStorageAdaptor() && !HasAttachedStorageMonitor())
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(-((Component)this).transform.forward, ((Component)this).transform.up);
			SendNetworkUpdate();
			Deployable component = ((Component)this).GetComponent<Deployable>();
			if (component != null && component.placeEffect.isValid)
			{
				Effect.server.Run(component.placeEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
		}
		BaseEntity slot = GetSlot(Slot.Lock);
		if ((Object)(object)slot != (Object)null)
		{
			slot.SendNetworkUpdate();
		}
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		if (item != null && (Object)(object)item.info != (Object)null && allowedConstructionItems.Contains(item.info))
		{
			if ((Object)(object)player != (Object)null && player.IsInTutorial)
			{
				return 0;
			}
			for (int i = 24; i <= 27; i++)
			{
				if (base.inventory.GetSlot(i) == null)
				{
					return i;
				}
			}
		}
		return base.GetIdealSlot(player, container, item);
	}

	private void UnlinkDoorControllers()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		BuildingManager.Building building = GetBuilding();
		if (building == null)
		{
			return;
		}
		Enumerator<DecayEntity> enumerator = building.decayEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (!(enumerator.Current is Door door))
				{
					continue;
				}
				foreach (BaseEntity child in door.children)
				{
					if (child is CustomDoorManipulator customDoorManipulator)
					{
						customDoorManipulator.SetTargetDoor(null);
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public override bool HasSlot(Slot slot)
	{
		if (slot == Slot.Lock)
		{
			return true;
		}
		return base.HasSlot(slot);
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public float CalculateUpkeepPeriodMinutes()
	{
		if (base.isServer)
		{
			return ConVar.Decay.upkeep_period_minutes;
		}
		return 0f;
	}

	public float CalculateUpkeepCostFraction(bool doors)
	{
		if (base.isServer)
		{
			if (!doors)
			{
				return CalculateBuildingTaxRate();
			}
			return CalculateDoorTaxRate();
		}
		return 0f;
	}

	public void CalculateUpkeepCostAmounts(List<ItemAmount> itemAmounts)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		BuildingManager.Building building = GetBuilding();
		if (building == null || !building.HasDecayEntities())
		{
			return;
		}
		float num = CalculateUpkeepCostFraction(doors: false);
		float num2 = CalculateUpkeepCostFraction(doors: true);
		Enumerator<DecayEntity> enumerator = building.decayEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				DecayEntity current = enumerator.Current;
				float multiplier = ((current is Door) ? num2 : num);
				current.CalculateUpkeepCostAmounts(itemAmounts, multiplier);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public float GetProtectedMinutes(bool force = false)
	{
		if (base.isServer)
		{
			if (!force && Time.realtimeSinceStartup < nextProtectedCalcTime)
			{
				return cachedProtectedMinutes;
			}
			nextProtectedCalcTime = Time.realtimeSinceStartup + 60f;
			List<ItemAmount> list = Pool.Get<List<ItemAmount>>();
			CalculateUpkeepCostAmounts(list);
			float num = CalculateUpkeepPeriodMinutes();
			float num2 = -1f;
			if (base.inventory != null)
			{
				PooledList<Item> val = Pool.Get<PooledList<Item>>();
				try
				{
					foreach (ItemAmount item in list)
					{
						((List<Item>)(object)val).Clear();
						base.inventory.FindItemsByItemID((List<Item>)(object)val, item.itemid);
						int num3 = ((IEnumerable<Item>)val).Sum((Item x) => x.amount);
						if (num3 > 0 && item.amount > 0f)
						{
							float num4 = (float)num3 / item.amount * num;
							if (num2 == -1f || num4 < num2)
							{
								num2 = num4;
							}
						}
						else
						{
							num2 = 0f;
						}
					}
					if (num2 == -1f)
					{
						num2 = 0f;
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			Pool.FreeUnmanaged<ItemAmount>(ref list);
			cachedProtectedMinutes = num2;
			Interface.CallHook("OnCupboardProtectionCalculated", (object)this, (object)cachedProtectedMinutes);
			return cachedProtectedMinutes;
		}
		return 0f;
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (info != null && (Object)(object)info.InitiatorPlayer != (Object)null && !info.InitiatorPlayer.IsNpc && info.InitiatorPlayer.serverClan != null)
		{
			IReadOnlyList<ClanMember> members = info.InitiatorPlayer.serverClan.Members;
			bool flag = false;
			foreach (ClanMember item in members)
			{
				if (item.SteamId == base.OwnerID)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				HandleKilledByClanMember(info.InitiatorPlayer);
			}
		}
		UnlinkDoorControllers();
		base.OnDied(info);
	}

	public override void Die(HitInfo info = null)
	{
		if (!IsDead())
		{
			if (ConVar.Decay.upkeep_grief_protection > 0f)
			{
				PurchaseAntiGriefTime(ConVar.Decay.upkeep_grief_protection * 60f);
			}
			base.Die(info);
		}
	}

	private async void HandleKilledByClanMember(BasePlayer player)
	{
		try
		{
			ClanValueResult<IClan> val = await ClanManager.ServerInstance.Backend.GetByMember(base.OwnerID);
			IClan val2 = (val.IsSuccess ? val.Value : null);
			if (val2 != null)
			{
				player.AddClanScore((ClanScoreEventType)4, 1, null, val2);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public override void DecayTick()
	{
		BuildingBlock nearbyBuildingBlock = GetNearbyBuildingBlock();
		if ((Object)(object)nearbyBuildingBlock != (Object)null)
		{
			BuildingManager.Building building = nearbyBuildingBlock.GetBuilding();
			if (building != null && building.ID != buildingID)
			{
				AttachToBuilding(building.ID);
			}
		}
		else
		{
			Kill(DestroyMode.Gib);
		}
		if (EnsurePrimary())
		{
			base.DecayTick();
		}
	}

	public bool EnsurePrimary()
	{
		BuildingManager.Building building = GetBuilding();
		if (building != null)
		{
			BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
			if ((Object)(object)dominatingBuildingPrivilege != (Object)null && (Object)(object)dominatingBuildingPrivilege != (Object)(object)this)
			{
				Kill(DestroyMode.Gib);
				return false;
			}
		}
		return true;
	}

	public void MarkProtectedMinutesDirty(float delay = 0f)
	{
		nextProtectedCalcTime = Time.realtimeSinceStartup + delay;
	}

	private static float CalculateTaxRate(int entityCount, bool blocks)
	{
		if (entityCount == 0)
		{
			if (!blocks)
			{
				return ConVar.Decay.bracket_0_doorfraction;
			}
			return ConVar.Decay.bracket_0_costfraction;
		}
		int num = entityCount;
		float num2 = 0f;
		for (int i = 0; i < 4; i++)
		{
			float num3 = (blocks ? ConVar.Decay.bracket_0_costfraction : ConVar.Decay.bracket_0_doorfraction);
			int num4 = (blocks ? ConVar.Decay.bracket_0_blockcount : ConVar.Decay.bracket_0_doorcount);
			switch (i)
			{
			case 1:
				num3 = (blocks ? ConVar.Decay.bracket_1_costfraction : ConVar.Decay.bracket_1_doorfraction);
				num4 = (blocks ? ConVar.Decay.bracket_1_blockcount : ConVar.Decay.bracket_1_doorcount);
				break;
			case 2:
				num3 = (blocks ? ConVar.Decay.bracket_2_costfraction : ConVar.Decay.bracket_1_doorfraction);
				num4 = (blocks ? ConVar.Decay.bracket_2_blockcount : ConVar.Decay.bracket_1_doorcount);
				break;
			case 3:
				num3 = (blocks ? ConVar.Decay.bracket_3_costfraction : ConVar.Decay.bracket_1_doorfraction);
				num4 = int.MaxValue;
				break;
			}
			if (num > 0)
			{
				int num5 = Mathf.Min(num, num4);
				num -= num5;
				num2 += (float)num5 * num3;
			}
		}
		return num2 /= (float)entityCount;
	}

	private float CalculateDoorTaxRate()
	{
		if (!ConVar.Decay.use_door_upkeep_brackets)
		{
			return CalculateBuildingTaxRate();
		}
		BuildingManager.Building building = GetBuilding();
		if (building == null)
		{
			return ConVar.Decay.bracket_0_doorfraction;
		}
		if (!building.HasDecayEntities())
		{
			return ConVar.Decay.bracket_0_doorfraction;
		}
		return CalculateTaxRate(building.doors.Count, blocks: false);
	}

	public float CalculateBuildingTaxRate()
	{
		BuildingManager.Building building = GetBuilding();
		if (building == null)
		{
			return ConVar.Decay.bracket_0_costfraction;
		}
		if (!building.HasBuildingBlocks())
		{
			return ConVar.Decay.bracket_0_costfraction;
		}
		return CalculateTaxRate(building.buildingBlocks.Count, blocks: true);
	}

	public void ApplyUpkeepPayment()
	{
		List<Item> list = Pool.Get<List<Item>>();
		for (int i = 0; i < upkeepBuffer.Count; i++)
		{
			ItemAmount itemAmount = upkeepBuffer[i];
			int num = (int)itemAmount.amount;
			if (num < 1)
			{
				continue;
			}
			base.inventory.Take(list, itemAmount.itemid, num);
			Analytics.Azure.AddPendingItems(this, itemAmount.itemDef.shortname, num, "upkeep", consumed: true, perEntity: true);
			foreach (Item item in list)
			{
				if (IsDebugging())
				{
					Debug.Log((object)(((object)this).ToString() + ": Using " + item.amount + " of " + item.info.shortname));
				}
				item.UseItem(item.amount);
			}
			list.Clear();
			itemAmount.amount -= num;
			upkeepBuffer[i] = itemAmount;
		}
		Pool.Free<Item>(ref list, false);
	}

	public void QueueUpkeepPayment(List<ItemAmount> itemAmounts)
	{
		for (int i = 0; i < itemAmounts.Count; i++)
		{
			ItemAmount itemAmount = itemAmounts[i];
			bool flag = false;
			foreach (ItemAmount item in upkeepBuffer)
			{
				if ((Object)(object)item.itemDef == (Object)(object)itemAmount.itemDef)
				{
					item.amount += itemAmount.amount;
					if (IsDebugging())
					{
						Debug.Log((object)(((object)this).ToString() + ": Adding " + itemAmount.amount + " of " + itemAmount.itemDef.shortname + " to " + item.amount));
					}
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				if (IsDebugging())
				{
					Debug.Log((object)(((object)this).ToString() + ": Adding " + itemAmount.amount + " of " + itemAmount.itemDef.shortname));
				}
				upkeepBuffer.Add(new ItemAmount(itemAmount.itemDef, itemAmount.amount));
			}
		}
	}

	public bool CanAffordUpkeepPayment(List<ItemAmount> itemAmounts)
	{
		for (int i = 0; i < itemAmounts.Count; i++)
		{
			ItemAmount itemAmount = itemAmounts[i];
			if ((float)base.inventory.GetAmount(itemAmount.itemid, onlyUsableAmounts: true) < itemAmount.amount)
			{
				if (IsDebugging())
				{
					Debug.Log((object)(((object)this).ToString() + ": Can't afford " + itemAmount.amount + " of " + itemAmount.itemDef.shortname));
				}
				return false;
			}
		}
		return true;
	}

	public float PurchaseUpkeepTime(DecayEntity entity, float deltaTime)
	{
		float num = CalculateUpkeepCostFraction(doors: false);
		float num2 = CalculateUpkeepCostFraction(doors: true);
		float num3 = CalculateUpkeepPeriodMinutes() * 60f;
		float multiplier = ((entity is Door) ? num2 : num) * deltaTime / num3;
		List<ItemAmount> itemAmounts = Pool.Get<List<ItemAmount>>();
		entity.CalculateUpkeepCostAmounts(itemAmounts, multiplier);
		bool num4 = CanAffordUpkeepPayment(itemAmounts);
		QueueUpkeepPayment(itemAmounts);
		Pool.FreeUnmanaged<ItemAmount>(ref itemAmounts);
		ApplyUpkeepPayment();
		if (!num4)
		{
			return 0f;
		}
		return deltaTime;
	}

	public void PurchaseUpkeepTime(float deltaTime)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		BuildingManager.Building building = GetBuilding();
		if (building == null || !building.HasDecayEntities())
		{
			return;
		}
		float num = Mathf.Min(GetProtectedMinutes(force: true) * 60f, deltaTime);
		if (!(num > 0f))
		{
			return;
		}
		Enumerator<DecayEntity> enumerator = building.decayEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				DecayEntity current = enumerator.Current;
				float protectedSeconds = current.GetProtectedSeconds();
				if (num > protectedSeconds)
				{
					float time = PurchaseUpkeepTime(current, num - protectedSeconds);
					current.AddUpkeepTime(time);
					if (IsDebugging())
					{
						Debug.Log((object)(((object)this).ToString() + " purchased upkeep time for " + ((object)current).ToString() + ": " + protectedSeconds + " + " + time + " = " + current.GetProtectedSeconds()));
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void PurchaseAntiGriefTime(float deltaTime)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		BuildingManager.Building building = GetBuilding();
		if (building == null || !building.HasDecayEntities())
		{
			return;
		}
		Enumerator<DecayEntity> enumerator = building.decayEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				DecayEntity current = enumerator.Current;
				float protectedSeconds = current.GetProtectedSeconds();
				float num = Mathf.Max(0f, deltaTime - protectedSeconds);
				if (num > 0f)
				{
					float time = PurchaseUpkeepTime(current, num);
					current.AddUpkeepTime(time);
					if (IsDebugging())
					{
						Debug.Log((object)(((object)this).ToString() + " purchased upkeep time for " + ((object)current).ToString() + ": " + protectedSeconds + " + " + time + " = " + current.GetProtectedSeconds()));
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static string FormatUpkeepMinutes(float minutes)
	{
		int num = Mathf.FloorToInt(minutes / 60f);
		int num2 = Mathf.FloorToInt(minutes - (float)num * 60f);
		int num3 = Mathf.FloorToInt(minutes * 60f % 60f);
		if (num >= 72)
		{
			string text = Translate.Get("days", "days");
			int num4 = num / 24;
			if (num4 >= 30)
			{
				return "> 30 " + text;
			}
			return $"{num4:N0} {text}";
		}
		if (num >= 12)
		{
			return $"{num:N0} hrs";
		}
		if (num >= 1)
		{
			return $"{num:N0}h{num2:N0}m";
		}
		if (minutes >= 1f)
		{
			return $"{num2:N0}m{num3:N0}s";
		}
		return $"{minutes * 60f:N0}s";
	}
}


public class UpkeepBracket
{
	public int objectsUpTo;

	public float fraction;

	public float blocksTaxPaid;

	public UpkeepBracket(int numObjs, float frac)
	{
		objectsUpTo = numObjs;
		fraction = frac;
		blocksTaxPaid = 0f;
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class CameraTool : HeldEntity
{
	public GameObjectRef screenshotEffect;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CameraTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 3167878597u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVNoteScreenshot "));
				}
				TimeWarning val2 = TimeWarning.New("SVNoteScreenshot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(3167878597u, "SVNoteScreenshot", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SVNoteScreenshot(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SVNoteScreenshot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	private void SVNoteScreenshot(RPCMessage msg)
	{
	}
}


using System;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Candle : BaseCombatEntity, ISplashable, IIgniteable, IAlwaysOn
{
	public float lifeTimeSeconds = 7200f;

	public float burnRate = 10f;

	public const Flags AlwaysOn = Flags.Reserved3;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Candle.OnRpcMessage", 0);
		try
		{
			if (rpc == 2523893445u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetWantsOn "));
				}
				TimeWarning val2 = TimeWarning.New("SetWantsOn", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2523893445u, "SetWantsOn", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage wantsOn = rPCMessage;
							SetWantsOn(wantsOn);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetWantsOn");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SetWantsOn(RPCMessage msg)
	{
		bool b = msg.read.Bit();
		SetFlag(Flags.On, b);
		UpdateInvokes();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		UpdateInvokes();
	}

	public void UpdateInvokes()
	{
		if (IsOn())
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)Burn, burnRate, burnRate, 1f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)Burn);
		}
	}

	public void Burn()
	{
		if (!IsAlwaysOn())
		{
			float num = burnRate / lifeTimeSeconds;
			Hurt(num * MaxHealth(), DamageType.Decay, this, useProtection: false);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if (base.isServer && info.damageTypes.Get(DamageType.Heat) > 0f && !IsOn())
		{
			SetFlag(Flags.On, b: true);
			UpdateInvokes();
		}
		base.OnAttacked(info);
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (!base.IsDestroyed && amount > 1)
		{
			return IsOn();
		}
		return false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		if (amount > 1)
		{
			SetFlag(Flags.On, b: false);
			UpdateInvokes();
			amount--;
		}
		return amount;
	}

	public void Ignite(Vector3 fromPos)
	{
		SetFlag(Flags.On, b: true);
		UpdateInvokes();
	}

	public bool CanIgnite()
	{
		return !IsOn();
	}

	public virtual bool IsAlwaysOn()
	{
		if (HasFlag(Flags.Reserved3))
		{
			return Creative.alwaysOnEnabled;
		}
		return false;
	}

	public void SetAlwaysOn(bool flag)
	{
		SetFlag(Flags.Reserved3, flag);
		AlwaysOnToggled(flag);
	}

	public void AlwaysOnToggled(bool flag)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (flag)
		{
			if (CanIgnite())
			{
				Ignite(((Component)this).transform.position);
			}
		}
		else
		{
			SetFlag(Flags.On, b: false);
			UpdateInvokes();
		}
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class CardReader : IOEntity
{
	public float accessDuration = 10f;

	public int accessLevel;

	public GameObjectRef accessGrantedEffect;

	public GameObjectRef accessDeniedEffect;

	public GameObjectRef swipeEffect;

	public Transform audioPosition;

	public Flags AccessLevel1 = Flags.Reserved1;

	public Flags AccessLevel2 = Flags.Reserved2;

	public Flags AccessLevel3 = Flags.Reserved3;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CardReader.OnRpcMessage", 0);
		try
		{
			if (rpc == 979061374 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerCardSwiped "));
				}
				TimeWarning val2 = TimeWarning.New("ServerCardSwiped", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(979061374u, "ServerCardSwiped", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerCardSwiped(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerCardSwiped");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetIOState()
	{
		base.ResetIOState();
		((FacepunchBehaviour)this).CancelInvoke((Action)GrantCard);
		((FacepunchBehaviour)this).CancelInvoke((Action)CancelAccess);
		CancelAccess();
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsOn())
		{
			return 0;
		}
		return base.GetPassthroughAmount(outputSlot);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public void CancelAccess()
	{
		SetFlag(Flags.On, b: false);
		MarkDirty();
	}

	public void FailCard()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(accessDeniedEffect.resourcePath, audioPosition.position, Vector3.up);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(AccessLevel1, accessLevel == 1);
		SetFlag(AccessLevel2, accessLevel == 2);
		SetFlag(AccessLevel3, accessLevel == 3);
	}

	public void GrantCard()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.On, b: true);
		MarkDirty();
		Effect.server.Run(accessGrantedEffect.resourcePath, audioPosition.position, Vector3.up);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void ServerCardSwiped(RPCMessage msg)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (!IsPowered() || Vector3Ex.Distance2D(((Component)msg.player).transform.position, ((Component)this).transform.position) > 1f || ((FacepunchBehaviour)this).IsInvoking((Action)GrantCard) || ((FacepunchBehaviour)this).IsInvoking((Action)FailCard) || HasFlag(Flags.On))
		{
			return;
		}
		NetworkableId uid = msg.read.EntityID();
		Keycard keycard = BaseNetworkable.serverEntities.Find(uid) as Keycard;
		Effect.server.Run(swipeEffect.resourcePath, audioPosition.position, Vector3.up, msg.player.net.connection);
		if ((Object)(object)keycard == (Object)null || Interface.CallHook("OnCardSwipe", (object)this, (object)keycard, (object)msg.player) != null)
		{
			return;
		}
		Item item = keycard.GetItem();
		if (item != null && !((Object)(object)item.parent.playerOwner != (Object)(object)msg.player))
		{
			if (keycard.accessLevel == accessLevel && item.conditionNormalized > 0f)
			{
				Analytics.Azure.OnKeycardSwiped(msg.player, this);
				((FacepunchBehaviour)this).Invoke((Action)GrantCard, 0.5f);
				item.LoseCondition(1f);
			}
			else
			{
				((FacepunchBehaviour)this).Invoke((Action)FailCard, 0.5f);
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericInt1 = accessLevel;
		info.msg.ioEntity.genericFloat1 = accessDuration;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			accessLevel = info.msg.ioEntity.genericInt1;
			accessDuration = info.msg.ioEntity.genericFloat1;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class CarvablePumpkin : BaseOven, ILOD, ISignage, IUGCBrowserEntity
{
	private List<ulong> editHistory = new List<ulong>();

	private const float TextureRequestTimeout = 15f;

	public GameObjectRef changeTextDialog;

	public MeshPaintableSource[] paintableSources;

	[NonSerialized]
	public uint[] textureIDs;

	public FileStorage.Type FileType => FileStorage.Type.png;

	public NetworkableId NetworkID => net.ID;

	public UGCType ContentType => UGCType.ImagePng;

	public List<ulong> EditingHistory => editHistory;

	public uint[] GetContentCRCs => textureIDs;

	public override bool ShouldTransferAssociatedFiles => true;

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public Vector2i TextureSize
	{
		get
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			if (paintableSources == null || paintableSources.Length == 0)
			{
				return Vector2i.zero;
			}
			MeshPaintableSource meshPaintableSource = paintableSources[0];
			return new Vector2i(meshPaintableSource.texWidth, meshPaintableSource.texHeight);
		}
	}

	public int TextureCount
	{
		get
		{
			MeshPaintableSource[] array = paintableSources;
			if (array == null)
			{
				return 0;
			}
			return array.Length;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CarvablePumpkin.OnRpcMessage", 0);
		try
		{
			if (rpc == 1455609404 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - LockSign "));
				}
				TimeWarning val2 = TimeWarning.New("LockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455609404u, "LockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							LockSign(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in LockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4149904254u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UnLockSign "));
				}
				TimeWarning val2 = TimeWarning.New("UnLockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4149904254u, "UnLockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							UnLockSign(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UnLockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1255380462 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateSign "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1255380462u, "UpdateSign", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1255380462u, "UpdateSign", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							UpdateSign(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in UpdateSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public uint[] GetTextureCRCs()
	{
		return textureIDs;
	}

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

	public bool CanUnlockSign(BasePlayer player)
	{
		if (!IsLocked())
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	public bool CanLockSign(BasePlayer player)
	{
		if (IsLocked())
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	public override void Load(LoadInfo info)
	{
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		EnsureInitialized();
		bool flag = false;
		if (info.msg.sign != null)
		{
			uint num = textureIDs[0];
			if (info.msg.sign.imageIds != null && info.msg.sign.imageIds.Count > 0)
			{
				int num2 = Mathf.Min(info.msg.sign.imageIds.Count, textureIDs.Length);
				for (int i = 0; i < num2; i++)
				{
					uint num3 = info.msg.sign.imageIds[i];
					bool flag2 = num3 != textureIDs[i];
					flag = flag || flag2;
					textureIDs[i] = num3;
				}
			}
			else
			{
				flag = num != info.msg.sign.imageid;
				textureIDs[0] = info.msg.sign.imageid;
			}
		}
		if (!base.isServer)
		{
			return;
		}
		bool flag3 = false;
		for (int j = 0; j < paintableSources.Length; j++)
		{
			uint num4 = textureIDs[j];
			if (num4 != 0)
			{
				byte[] array = FileStorage.server.Get(num4, FileStorage.Type.png, net.ID, (uint)j);
				if (array == null)
				{
					Log($"Frame {j} (id={num4}) doesn't exist, clearing");
					textureIDs[j] = 0u;
				}
				flag3 = flag3 || array != null;
			}
		}
		if (!flag3)
		{
			SetFlag(Flags.Locked, b: false);
		}
		if (info.msg.sign == null)
		{
			return;
		}
		if (info.msg.sign.editHistory != null)
		{
			if (editHistory == null)
			{
				editHistory = Pool.Get<List<ulong>>();
			}
			editHistory.Clear();
			{
				foreach (ulong item in info.msg.sign.editHistory)
				{
					editHistory.Add(item);
				}
				return;
			}
		}
		if (editHistory != null)
		{
			Pool.FreeUnmanaged<ulong>(ref editHistory);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void UnLockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUnlockSign(msg.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		EnsureInitialized();
		List<uint> list = Pool.Get<List<uint>>();
		uint[] array = textureIDs;
		foreach (uint item in array)
		{
			list.Add(item);
		}
		info.msg.sign = Pool.Get<Sign>();
		info.msg.sign.imageid = 0u;
		info.msg.sign.imageIds = list;
		if (editHistory.Count <= 0)
		{
			return;
		}
		info.msg.sign.editHistory = Pool.Get<List<ulong>>();
		foreach (ulong item2 in editHistory)
		{
			info.msg.sign.editHistory.Add(item2);
		}
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (net != null)
		{
			FileStorage.server.RemoveAllByEntity(net.ID);
		}
		if (textureIDs != null)
		{
			Array.Clear(textureIDs, 0, textureIDs.Length);
		}
		base.OnDied(info);
	}

	public override void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
	{
		base.OnPickedUpPreItemMove(createdItem, player);
		bool flag = false;
		uint[] array = textureIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != 0)
			{
				flag = true;
				break;
			}
		}
		ItemModSign itemModSign = default(ItemModSign);
		if (flag && ((Component)createdItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			itemModSign.OnSignPickedUp(this, this, createdItem);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		ItemModSign itemModSign = default(ItemModSign);
		if (((Component)fromItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			SignContent associatedEntity = ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(fromItem);
			if ((Object)(object)associatedEntity != (Object)null)
			{
				associatedEntity.CopyInfoToSign(this, this);
			}
		}
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public void SetTextureCRCs(uint[] crcs)
	{
		textureIDs = new uint[crcs.Length];
		crcs.CopyTo(textureIDs, 0);
		SendNetworkUpdate();
	}

	private void LogEdit(BasePlayer byPlayer)
	{
		if (!editHistory.Contains(byPlayer.userID))
		{
			editHistory.Insert(0, byPlayer.userID);
			int num = 0;
			while (editHistory.Count > 5 && num < 10)
			{
				editHistory.RemoveAt(5);
				num++;
			}
		}
	}

	public void ClearContent()
	{
		SetTextureCRCs(Array.Empty<uint>());
	}

	public override string Categorize()
	{
		return "sign";
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (paintableSources != null && paintableSources.Length > 1)
		{
			MeshPaintableSource meshPaintableSource = paintableSources[0];
			for (int i = 1; i < paintableSources.Length; i++)
			{
				MeshPaintableSource obj = paintableSources[i];
				obj.texWidth = meshPaintableSource.texWidth;
				obj.texHeight = meshPaintableSource.texHeight;
			}
		}
	}

	[RPC_Server.MaxDistance(5f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void UpdateSign(RPCMessage msg)
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			Debug.LogWarning((object)$"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", (object)this, (object)msg.player);
	}

	public void EnsureInitialized()
	{
		int num = Mathf.Max(paintableSources.Length, 1);
		if (textureIDs == null || textureIDs.Length != num)
		{
			Array.Resize(ref textureIDs, num);
		}
	}

	[Conditional("SIGN_DEBUG")]
	private static void SignDebugLog(string str)
	{
		Debug.Log((object)str);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Cassette : BaseEntity, IUGCBrowserEntity, IServerFileReceiver
{
	public float MaxCassetteLength = 15f;

	[ReplicatedVar]
	public static float MaxCassetteFileSizeMB = 5f;

	public ulong CreatorSteamId;

	public PreloadedCassetteContent.PreloadType PreloadType;

	public PreloadedCassetteContent PreloadContent;

	public SoundDefinition InsertCassetteSfx;

	public int ViewmodelIndex;

	public Sprite HudSprite;

	public int MaximumVoicemailSlots = 1;

	public int preloadedAudioId;

	public ICassettePlayer currentCassettePlayer;

	public uint AudioId { get; private set; }

	public SoundDefinition PreloadedAudio => PreloadContent.GetSoundContent(preloadedAudioId, PreloadType);

	public override bool ShouldTransferAssociatedFiles => true;

	public uint[] GetContentCRCs
	{
		get
		{
			if (AudioId == 0)
			{
				return Array.Empty<uint>();
			}
			return new uint[1] { AudioId };
		}
	}

	public UGCType ContentType => UGCType.AudioOgg;

	public List<ulong> EditingHistory => new List<ulong> { CreatorSteamId };

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Cassette.OnRpcMessage", 0);
		try
		{
			if (rpc == 4031457637u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_MakeNewFile "));
				}
				TimeWarning val2 = TimeWarning.New("Server_MakeNewFile", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4031457637u, "Server_MakeNewFile", this, player, 1uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_MakeNewFile(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_MakeNewFile");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[ServerVar]
	public static void ClearCassettes(Arg arg)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is Cassette cassette && cassette.ClearSavedAudio())
				{
					num++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Deleted the contents of {num} cassettes");
	}

	[ServerVar]
	public static void ClearCassettesByUser(Arg arg)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		ulong uInt = arg.GetUInt64(0, 0uL);
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is Cassette cassette && cassette.CreatorSteamId == uInt)
				{
					cassette.ClearSavedAudio();
					num++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Deleted {num} cassettes recorded by {uInt}");
	}

	public override void Load(LoadInfo info)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.cassette == null)
		{
			return;
		}
		_ = AudioId;
		AudioId = info.msg.cassette.audioId;
		CreatorSteamId = info.msg.cassette.creatorSteamId;
		preloadedAudioId = info.msg.cassette.preloadAudioId;
		if (base.isServer && ((NetworkableId)(ref info.msg.cassette.holder)).IsValid)
		{
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(info.msg.cassette.holder);
			if ((Object)(object)baseNetworkable != (Object)null && baseNetworkable is ICassettePlayer cassettePlayer)
			{
				currentCassettePlayer = cassettePlayer;
			}
		}
	}

	public void AssignPreloadContent()
	{
		switch (PreloadType)
		{
		case PreloadedCassetteContent.PreloadType.Short:
			preloadedAudioId = Random.Range(0, PreloadContent.ShortTapeContent.Length);
			break;
		case PreloadedCassetteContent.PreloadType.Medium:
			preloadedAudioId = Random.Range(0, PreloadContent.MediumTapeContent.Length);
			break;
		case PreloadedCassetteContent.PreloadType.Long:
			preloadedAudioId = Random.Range(0, PreloadContent.LongTapeContent.Length);
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.cassette = Pool.Get<Cassette>();
		info.msg.cassette.audioId = AudioId;
		info.msg.cassette.creatorSteamId = CreatorSteamId;
		info.msg.cassette.preloadAudioId = preloadedAudioId;
		if (!currentCassettePlayer.IsUnityNull() && currentCassettePlayer.ToBaseEntity.IsValid())
		{
			info.msg.cassette.holder = currentCassettePlayer.ToBaseEntity.net.ID;
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		currentCassettePlayer?.OnCassetteRemoved(this);
		currentCassettePlayer = null;
		if ((Object)(object)newParent != (Object)null && newParent is ICassettePlayer cassettePlayer)
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedCassetteInserted, 0.1f);
			currentCassettePlayer = cassettePlayer;
		}
	}

	public void DelayedCassetteInserted()
	{
		if (currentCassettePlayer != null)
		{
			currentCassettePlayer.OnCassetteInserted(this);
		}
	}

	public void SetAudioId(uint id, ulong userId)
	{
		AudioId = id;
		CreatorSteamId = userId;
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void Server_MakeNewFile(RPCMessage msg)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null)
		{
			return;
		}
		if ((Object)(object)GetParentEntity() != (Object)null && GetParentEntity() is HeldEntity heldEntity && (Object)(object)heldEntity.GetOwnerPlayer() != (Object)(object)msg.player)
		{
			Debug.Log((object)"Player mismatch!");
			return;
		}
		byte[] data = msg.read.BytesWithSize(10485760u, false);
		ulong userId = msg.read.UInt64();
		if (IsOggValid(data, this))
		{
			FileStorage.server.RemoveAllByEntity(net.ID);
			uint id = FileStorage.server.Store(data, FileStorage.Type.ogg, net.ID);
			SetAudioId(id, userId);
		}
	}

	public bool ClearSavedAudio()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (AudioId == 0)
		{
			return false;
		}
		FileStorage.server.RemoveAllByEntity(net.ID);
		AudioId = 0u;
		CreatorSteamId = 0uL;
		SendNetworkUpdate();
		return true;
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		ClearSavedAudio();
	}

	public void ClearContent()
	{
		AudioId = 0u;
		SendNetworkUpdate();
	}

	public static bool IsOggValid(byte[] data, Cassette c)
	{
		return IsOggValid(data, c.MaxCassetteLength);
	}

	public static bool IsOggValid(byte[] data, float maxLength)
	{
		if (data == null)
		{
			return false;
		}
		if (ByteToMegabyte(data.Length) >= MaxCassetteFileSizeMB)
		{
			Debug.Log((object)"Audio file is too large! Aborting");
			return false;
		}
		double oggLength = GetOggLength(data);
		if (oggLength > (double)(maxLength * 1.2f))
		{
			Debug.Log((object)$"Audio duration is longer than cassette limit! {oggLength} > {maxLength * 1.2f}");
			return false;
		}
		return true;
	}

	public static float ByteToMegabyte(int byteSize)
	{
		return (float)byteSize / 1024f / 1024f;
	}

	public static double GetOggLength(byte[] t)
	{
		int num = t.Length;
		long num2 = -1L;
		int num3 = -1;
		for (int num4 = num - 1 - 8 - 2 - 4; num4 >= 0; num4--)
		{
			if (t[num4] == 79 && t[num4 + 1] == 103 && t[num4 + 2] == 103 && t[num4 + 3] == 83)
			{
				num2 = BitConverter.ToInt64(new byte[8]
				{
					t[num4 + 6],
					t[num4 + 7],
					t[num4 + 8],
					t[num4 + 9],
					t[num4 + 10],
					t[num4 + 11],
					t[num4 + 12],
					t[num4 + 13]
				}, 0);
				break;
			}
		}
		for (int i = 0; i < num - 8 - 2 - 4; i++)
		{
			if (t[i] == 118 && t[i + 1] == 111 && t[i + 2] == 114 && t[i + 3] == 98 && t[i + 4] == 105 && t[i + 5] == 115)
			{
				num3 = BitConverter.ToInt32(new byte[4]
				{
					t[i + 11],
					t[i + 12],
					t[i + 13],
					t[i + 14]
				}, 0);
				break;
			}
		}
		if (RecorderTool.debugRecording)
		{
			Debug.Log((object)$"{num2} / {num3}");
		}
		return (double)num2 / (double)num3;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Catapult : BaseSiegeWeapon
{
	[Serializable]
	private struct Ammo
	{
		public ItemDefinition item;

		public GameObject go;
	}

	[Serializable]
	private struct FiringEffect
	{
		public ItemDefinition item;

		public GameObjectRef effectPrefab;
	}

	[Header("Catapult")]
	[SerializeField]
	private Animator animator;

	[SerializeField]
	private Transform muzzle;

	[SerializeField]
	private float reloadTime = 6f;

	[SerializeField]
	private Ammo[] ammoPrefabs;

	[SerializeField]
	private GameObject ammoParent;

	[HideInInspector]
	public float reloadProgress;

	private const AmmoTypes ammoType = 8192;

	[SerializeField]
	private CatapultAmmoContainer ammoStoragePrefab;

	private EntityRef<CatapultAmmoContainer> ammoStorageRef;

	private const Flags Flag_Reloading = Flags.Reserved4;

	private const Flags Flag_Loaded = Flags.Unused23;

	private BasePlayer reloadingPlayer;

	private ItemDefinition loadedAmmoDef;

	private TimeSince timeSinceLastFire;

	[Header("Effects")]
	[SerializeField]
	public GameObjectRef dryFireEffectPrefab;

	[SerializeField]
	private FiringEffect[] fireEffects;

	private static ItemDefinition _boulderItemDef;

	private Item loadedAmmoItem;

	private readonly float progressTickRate = 0.1f;

	public override float DriveWheelVelocity { get; }

	public static ItemDefinition BoulderItemDef
	{
		get
		{
			if ((Object)(object)_boulderItemDef == (Object)null)
			{
				_boulderItemDef = ItemManager.FindItemDefinition("catapult.ammo.boulder");
			}
			return _boulderItemDef;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Catapult.OnRpcMessage", 0);
		try
		{
			if (rpc == 1188838966 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_CancelReload "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_CancelReload", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1188838966u, "SERVER_CancelReload", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1188838966u, "SERVER_CancelReload", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1188838966u, "SERVER_CancelReload", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_CancelReload(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_CancelReload");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3952894422u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_OpenAmmo "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_OpenAmmo", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3952894422u, "SERVER_OpenAmmo", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_OpenAmmo(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_OpenAmmo");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2817383917u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_ReloadStart "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_ReloadStart", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2817383917u, "SERVER_ReloadStart", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2817383917u, "SERVER_ReloadStart", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2817383917u, "SERVER_ReloadStart", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SERVER_ReloadStart(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SERVER_ReloadStart");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4172853352u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_WantsFire "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_WantsFire", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4172853352u, "SERVER_WantsFire", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							SERVER_WantsFire(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in SERVER_WantsFire");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.catapult = Pool.Get<Catapult>();
		info.msg.catapult.ammoStorageID = ammoStorageRef.uid;
		info.msg.catapult.reloadProgress = reloadProgress;
		info.msg.catapult.ammoType = ((loadedAmmoItem != null) ? loadedAmmoDef.itemid : 0);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.catapult != null)
		{
			ammoStorageRef.uid = info.msg.catapult.ammoStorageID;
			reloadProgress = info.msg.catapult.reloadProgress;
			_ = loadedAmmoDef;
			loadedAmmoDef = ItemManager.FindItemDefinition(info.msg.catapult.ammoType);
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			animator.SetFloat("Reload", reloadProgress);
		}, 0.25f);
	}

	protected override void CreateEngineController()
	{
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child.prefabID == ammoStoragePrefab.GetEntity().prefabID)
		{
			CatapultAmmoContainer catapultAmmoContainer = (CatapultAmmoContainer)child;
			ammoStorageRef.Set(catapultAmmoContainer);
			catapultAmmoContainer.catapult = this;
		}
	}

	public bool IsArmed()
	{
		return reloadProgress >= 0.4f;
	}

	public bool IsReloading()
	{
		return HasFlag(Flags.Reserved4);
	}

	public bool CanReload()
	{
		if (!IsReloading() && !HasFlag(Flags.Reserved12) && reloadProgress != 1f)
		{
			return !IsWaterlogged();
		}
		return false;
	}

	public bool CanFire()
	{
		if (IsArmed() && !IsReloading())
		{
			return !IsWaterlogged();
		}
		return false;
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if (base.CanPushNow(pusher))
		{
			return TimeSince.op_Implicit(timeSinceLastFire) > 2f;
		}
		return false;
	}

	private void FireAnimation()
	{
		animator.ResetTrigger("Fire");
		animator.SetTrigger("Fire");
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			reloadProgress = 0f;
			animator.SetFloat("Reload", reloadProgress);
		}, 0.5f);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!HasFlag(Flags.Reserved11))
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ammoStorageRef.Set(ammoStoragePrefab);
	}

	public void UpdateLoadedAmmo(Item item, bool added)
	{
		loadedAmmoItem = (added ? item : null);
		loadedAmmoDef = (added ? item.info : null);
		SetFlag(Flags.Unused23, (Object)(object)loadedAmmoDef != (Object)null);
		SendNetworkUpdateImmediate();
	}

	public bool Fire(BasePlayer shooter, float force)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		FireRecoil();
		float num = Mathf.Lerp(2f, 1f, Mathf.Clamp01(force));
		float num2 = Mathf.Lerp(0.5f, 1f, Mathf.Clamp01(force));
		bool flag = true;
		Vector3 firingPos = muzzle.position;
		BasePlayer passenger = GetPassenger();
		object obj = Interface.CallHook("OnCatapultFireForce", (object)this, (object)shooter, (object)num2);
		if (obj is float)
		{
			num2 = (float)obj;
		}
		if ((Object)(object)passenger != (Object)null)
		{
			passenger.ServerPosition = ((Component)muzzle).transform.position;
			passenger.Ragdoll(((Component)muzzle).transform.forward * (20f * num2) + Vector3.up * (2.5f * num), matchPlayerGravity: false, flailInAir: true, dieOnImpact: true, this);
			return true;
		}
		if (GamePhysics.CheckSphere(muzzle.position, 1f, 1236994833, (QueryTriggerInteraction)1))
		{
			Vector3 val = ((Component)this).transform.position + Vector3.up * 2f;
			if (GamePhysics.Trace(new Ray(val, muzzle.position - val), 0f, out var hitInfo, 10f, 1236994833, (QueryTriggerInteraction)1))
			{
				flag = false;
				firingPos = ((RaycastHit)(ref hitInfo)).point - Vector3.up;
			}
		}
		ServerProjectile projectile2;
		if ((Object)(object)loadedAmmoDef == (Object)(object)BoulderItemDef)
		{
			ItemModCatapultBoulder component = ((Component)loadedAmmoDef).GetComponent<ItemModCatapultBoulder>();
			if ((Object)(object)component == (Object)null)
			{
				return false;
			}
			foreach (ItemModCatapultBoulder.ProjectileSettings projectileSetting in component.projectileSettings)
			{
				for (int i = 0; i < projectileSetting.count; i++)
				{
					Vector3 forward = muzzle.forward;
					forward = Quaternion.Euler(Random.Range(0f - component.spreadAngle, component.spreadAngle), Random.Range(0f - component.spreadAngle, component.spreadAngle), 0f) * forward;
					if (FireProjectile(projectileSetting.prefab, firingPos, forward, shooter, 0.25f, 30f * num2, out var projectile))
					{
						if (!flag)
						{
							((Component)projectile).GetComponent<TimedExplosive>()?.ForceExplode();
						}
						projectile.ignoreEntity = this;
						projectile.gravityModifier *= num * Random.Range(1f - projectileSetting.gravityModifier, 1f + projectileSetting.gravityModifier);
						shooter.MarkHostileFor();
					}
				}
			}
			loadedAmmoItem.UseItem();
		}
		else if (TryFireProjectile(ammoStorageRef.Get(base.isServer), (AmmoTypes)8192, firingPos, muzzle.forward, shooter, 0.25f, 30f * num2, out projectile2))
		{
			projectile2.ignoreEntity = this;
			if (!flag)
			{
				((Component)projectile2).GetComponent<TimedExplosive>()?.ForceExplode();
			}
			projectile2.gravityModifier *= num;
			shooter.MarkHostileFor();
			return true;
		}
		return false;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SERVER_WantsFire(RPCMessage msg)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (CanFire() && Interface.CallHook("OnSiegeWeaponFire", (object)this, (object)player) == null)
		{
			float force = reloadProgress;
			Fire(player, force);
			reloadProgress = 0f;
			timeSinceLastFire = TimeSince.op_Implicit(0f);
			FireAnimation();
			GameObjectRef loadedAmmoFiringEffect = GetLoadedAmmoFiringEffect();
			if (loadedAmmoFiringEffect != null && loadedAmmoFiringEffect.isValid)
			{
				Effect.server.Run(loadedAmmoFiringEffect.resourcePath, this, 0u, Vector3.zero, Vector3.up, null, broadcast: true);
			}
			RefreshLastUseTime();
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_Fire"));
		}
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (!HasFlag(Flags.Unused23))
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SERVER_OpenAmmo(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			ammoStorageRef.Get(base.isServer).PlayerOpenLoot(player);
		}
	}

	public void FireRecoil()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)rigidBody == (Object)null))
		{
			if (rigidBody.IsSleeping())
			{
				rigidBody.WakeUp();
			}
			Vector3 val = Vector3.ProjectOnPlane(((Component)this).transform.forward, ((Component)this).transform.up);
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			rigidBody.AddForce(normalized * rigidBody.mass * (carPhysics.HasHandbrake() ? 5f : 1f), (ForceMode)1);
			rigidBody.AddForceAtPosition(Vector3.up * rigidBody.mass * 1.5f, centreOfMassTransform.position + ((Component)this).transform.forward * 1f, (ForceMode)1);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void SERVER_ReloadStart(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanReload())
		{
			SetFlag(Flags.Reserved4, b: true);
			RefreshLastUseTime();
			reloadingPlayer = msg.player;
			((FacepunchBehaviour)this).InvokeRepeating((Action)ReloadProgress, 0f, progressTickRate);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	public void SERVER_CancelReload(RPCMessage msg)
	{
		if ((Object)(object)msg.player == (Object)(object)reloadingPlayer)
		{
			StopPlayerReload();
		}
	}

	private void ReloadProgress()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)reloadingPlayer == (Object)null || reloadingPlayer.IsDead() || reloadingPlayer.IsSleeping() || Vector3Ex.Distance2D(((Component)reloadingPlayer).transform.position, ((Component)this).transform.position) > 5f)
		{
			StopPlayerReload();
			return;
		}
		reloadProgress += progressTickRate / reloadTime;
		animator.SetFloat("Reload", reloadProgress);
		if (reloadProgress >= 1f)
		{
			reloadProgress = 1f;
			StopPlayerReload();
		}
		SendNetworkUpdate();
	}

	public void AdminReload(int ammo)
	{
		SetFlag(Flags.Reserved4, b: true);
		reloadProgress = 1f;
		animator.SetFloat("Reload", reloadProgress);
		switch (ammo)
		{
		case 5:
			((MonoBehaviour)this).StartCoroutine(SpawnAndMountBotPlayer());
			break;
		default:
		{
			ammoStorageRef.Get(base.isServer).inventory.Clear();
			ItemDefinition itemToCreate = null;
			switch (ammo)
			{
			case 1:
				itemToCreate = ItemManager.FindItemDefinition("catapult.ammo.boulder");
				break;
			case 2:
				itemToCreate = ItemManager.FindItemDefinition("catapult.ammo.incendiary");
				break;
			case 3:
				itemToCreate = ItemManager.FindItemDefinition("catapult.ammo.explosive");
				break;
			case 4:
				itemToCreate = ItemManager.FindItemDefinition("catapult.ammo.bee");
				break;
			}
			ammoStorageRef.Get(base.isServer).inventory.AddItem(itemToCreate, 1, 0uL);
			break;
		}
		case 0:
			break;
		}
		SendNetworkUpdateImmediate();
		((FacepunchBehaviour)this).Invoke((Action)StopPlayerReload, 0.5f);
	}

	private IEnumerator SpawnAndMountBotPlayer()
	{
		ConsoleSystem.Run(Option.Server, "spawn player", Array.Empty<object>());
		yield return (object)new WaitForSeconds(0.2f);
		BasePlayer player = ((IEnumerable<BasePlayer>)BasePlayer.bots).Last();
		using Enumerator enumerator = base.allMountPoints.GetEnumerator();
		if (enumerator.MoveNext())
		{
			enumerator.Current.mountable.MountPlayer(player);
		}
	}

	public void StopPlayerReload()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)ReloadProgress);
		SetFlag(Flags.Reserved4, b: false);
		reloadingPlayer = null;
	}

	public override void OnTowAttach()
	{
		base.OnTowAttach();
	}

	public override void OnTowDetach()
	{
		base.OnTowDetach();
	}

	public override void OnEngineStartFailed()
	{
	}

	public override bool MeetsEngineRequirements()
	{
		return false;
	}

	private GameObjectRef GetLoadedAmmoFiringEffect()
	{
		if ((Object)(object)loadedAmmoDef == (Object)null)
		{
			return dryFireEffectPrefab;
		}
		FiringEffect firingEffect = List.FindWith<FiringEffect, ItemDefinition>((IReadOnlyCollection<FiringEffect>)(object)fireEffects, (Func<FiringEffect, ItemDefinition>)((FiringEffect x) => x.item), loadedAmmoDef, (IEqualityComparer<ItemDefinition>)null);
		if (firingEffect.effectPrefab != null && firingEffect.effectPrefab.isValid)
		{
			return firingEffect.effectPrefab;
		}
		return null;
	}

	[ServerVar]
	public static void reload(Arg arg)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Null player.");
		}
		else
		{
			if (!basePlayer.IsAdmin)
			{
				return;
			}
			int @int = arg.GetInt(0, 1);
			@int = Mathf.Clamp(@int, 0, 5);
			Catapult[] array = Util.FindAll<Catapult>();
			int num = 0;
			Catapult[] array2 = array;
			foreach (Catapult catapult in array2)
			{
				if (catapult.isServer && Vector3.Distance(((Component)catapult).transform.position, ((Component)basePlayer).transform.position) <= 100f)
				{
					catapult.AdminReload(@int);
					num++;
				}
			}
			arg.ReplyWith($"Reloaded {num} catapults.");
		}
	}

	[ServerVar]
	public static void fire(Arg arg)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Null player.");
		}
		else
		{
			if (!basePlayer.IsAdmin)
			{
				return;
			}
			Catapult[] array = Util.FindAll<Catapult>();
			foreach (Catapult catapult in array)
			{
				if (catapult.isServer && Vector3.Distance(((Component)catapult).transform.position, ((Component)basePlayer).transform.position) <= 100f)
				{
					RPCMessage rPCMessage = default(RPCMessage);
					rPCMessage.player = basePlayer;
					RPCMessage msg = rPCMessage;
					catapult.SERVER_WantsFire(msg);
				}
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
private struct Ammo
{
	public ItemDefinition item;

	public GameObject go;
}


using System;

[Serializable]
private struct FiringEffect
{
	public ItemDefinition item;

	public GameObjectRef effectPrefab;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

[Factory("cctv")]
public class CCTV_RC : PoweredRemoteControlEntity, IRemoteControllableClientCallbacks, IRemoteControllable
{
	public Transform pivotOrigin;

	public Transform yaw;

	public Transform pitch;

	public Vector2 pitchClamp = new Vector2(-50f, 50f);

	public Vector2 yawClamp = new Vector2(-50f, 50f);

	public float turnSpeed = 25f;

	public float serverLerpSpeed = 15f;

	public float clientLerpSpeed = 10f;

	public float zoomLerpSpeed = 10f;

	public float[] fovScales;

	public float pitchAmount;

	public float yawAmount;

	public int fovScaleIndex;

	public float fovScaleLerped = 1f;

	public bool hasPTZ = true;

	public AnimationCurve dofCurve = AnimationCurve.Constant(0f, 1f, 0f);

	public float dofApertureMax = 10f;

	public const Flags Flag_HasViewer = Flags.Reserved5;

	public bool disableWhenShot = true;

	[ServerVar(Name = "camera_disable_seconds")]
	public static float CameraDisableSeconds = 300f;

	public SoundDefinition movementLoopSoundDef;

	public AnimationCurve movementLoopGainCurve;

	public float movementLoopSmoothing = 1f;

	public float movementLoopReference = 50f;

	private Sound movementLoop;

	private SoundModulation.Modulator movementLoopGainModulator;

	public SoundDefinition zoomInSoundDef;

	public SoundDefinition zoomOutSoundDef;

	public RealTimeSinceEx timeSinceLastServerTick;

	public override bool RequiresMouse => hasPTZ;

	protected override bool EntityCanPing => true;

	public override bool CanAcceptInput => hasPTZ;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CCTV_RC.OnRpcMessage", 0);
		try
		{
			if (rpc == 3353964129u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetDir "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetDir", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_SetDir(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_SetDir");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return 3;
	}

	public override void ServerInit()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (!base.isClient)
		{
			if (IsStatic())
			{
				pitchAmount = pitch.localEulerAngles.x;
				yawAmount = yaw.localEulerAngles.y;
				UpdateRCAccess(isOnline: true);
			}
			timeSinceLastServerTick = 0.0;
			((FacepunchBehaviour)this).InvokeRandomized((Action)ServerTick, Random.Range(0f, 1f), 0.015f, 0.01f);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		UpdateRotation(10000f);
	}

	public override void UserInput(InputState inputState, CameraViewerId viewerID)
	{
		if (UpdateManualAim(inputState))
		{
			SendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.rcEntity == null)
		{
			info.msg.rcEntity = Pool.Get<RCEntity>();
		}
		info.msg.rcEntity.aim.x = pitchAmount;
		info.msg.rcEntity.aim.y = yawAmount;
		info.msg.rcEntity.aim.z = 0f;
		info.msg.rcEntity.zoom = fovScaleIndex;
	}

	public override void Hurt(HitInfo info)
	{
		DamageType majorityDamageType = info.damageTypes.GetMajorityDamageType();
		if ((uint)(majorityDamageType - 9) <= 2u || (uint)(majorityDamageType - 15) <= 1u)
		{
			TryDisableCamera();
		}
		base.Hurt(info);
	}

	private void TryDisableCamera()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)EndCameraDisable);
		if (disableWhenShot)
		{
			SetFlag(Flags.OnFire, b: true);
			((FacepunchBehaviour)this).Invoke((Action)EndCameraDisable, CameraDisableSeconds);
		}
	}

	private void EndCameraDisable()
	{
		SetFlag(Flags.OnFire, b: false);
	}

	[RPC_Server]
	public void Server_SetDir(RPCMessage msg)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (!IsStatic())
		{
			BasePlayer player = msg.player;
			if (player.CanBuild() && player.IsBuildingAuthed() && Interface.CallHook("OnCCTVDirectionChange", (object)this, (object)player) == null)
			{
				Vector3 val = Vector3Ex.Direction(player.eyes.position, ((Component)yaw).transform.position);
				val = ((Component)this).transform.InverseTransformDirection(val);
				Quaternion val2 = Quaternion.LookRotation(val);
				Vector3 val3 = BaseMountable.ConvertVector(((Quaternion)(ref val2)).eulerAngles);
				pitchAmount = Mathf.Clamp(val3.x, pitchClamp.x, pitchClamp.y);
				yawAmount = Mathf.Clamp(val3.y, yawClamp.x, yawClamp.y);
				SendNetworkUpdate();
			}
		}
	}

	public override bool InitializeControl(CameraViewerId viewerID)
	{
		bool result = base.InitializeControl(viewerID);
		UpdateViewers();
		return result;
	}

	public override void StopControl(CameraViewerId viewerID)
	{
		base.StopControl(viewerID);
		UpdateViewers();
	}

	public void UpdateViewers()
	{
		SetFlag(Flags.Reserved5, base.ViewerCount > 0);
	}

	public void ServerTick()
	{
		if (!base.isClient && !base.IsDestroyed)
		{
			float delta = (float)(double)timeSinceLastServerTick;
			timeSinceLastServerTick = 0.0;
			UpdateRotation(delta);
			if (HasFlag(Flags.Reserved5) && !isStatic)
			{
				bool b = IsObstructedByGeometry();
				SetFlag(Flags.Locked, b);
			}
		}
	}

	private bool IsObstructedByGeometry()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = viewEyes.position - viewEyes.forward * 0.1f;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(val, 0.17f, list, 2162688, (QueryTriggerInteraction)1);
		bool flag = false;
		foreach (Collider item in list)
		{
			BaseEntity baseEntity = item.ToBaseEntity();
			if (!((Object)(object)baseEntity != (Object)null) || !((Object)(object)baseEntity == (Object)(object)this))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			flag = GamePhysics.Trace(new Ray(val, viewEyes.forward), 0f, out var _, 0.2f, 2162688, (QueryTriggerInteraction)0);
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return flag;
	}

	public bool UpdateManualAim(InputState inputState)
	{
		if (!hasPTZ)
		{
			return false;
		}
		float num = 0f - inputState.current.mouseDelta.y;
		float x = inputState.current.mouseDelta.x;
		bool flag = inputState.WasJustPressed(BUTTON.FIRE_PRIMARY);
		pitchAmount = Mathf.Clamp(pitchAmount + num * turnSpeed, pitchClamp.x, pitchClamp.y);
		yawAmount = Mathf.Clamp(yawAmount + x * turnSpeed, yawClamp.x, yawClamp.y) % 360f;
		if (flag)
		{
			fovScaleIndex = (fovScaleIndex + 1) % fovScales.Length;
		}
		return num != 0f || x != 0f || flag;
	}

	public void UpdateRotation(float delta)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.Euler(pitchAmount, 0f, 0f);
		Quaternion val2 = Quaternion.Euler(0f, yawAmount, 0f);
		float num = ((base.isServer && !base.IsBeingControlled) ? serverLerpSpeed : clientLerpSpeed);
		((Component)pitch).transform.localRotation = Mathx.Lerp(((Component)pitch).transform.localRotation, val, num, delta);
		((Component)yaw).transform.localRotation = Mathx.Lerp(((Component)yaw).transform.localRotation, val2, num, delta);
		if (fovScales != null && fovScales.Length != 0)
		{
			if (fovScales.Length > 1)
			{
				fovScaleLerped = Mathx.Lerp(fovScaleLerped, fovScales[fovScaleIndex], zoomLerpSpeed, delta);
			}
			else
			{
				fovScaleLerped = fovScales[0];
			}
		}
		else
		{
			fovScaleLerped = 1f;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.rcEntity != null)
		{
			int num = Mathf.Clamp((int)info.msg.rcEntity.zoom, 0, fovScales.Length - 1);
			if (base.isServer)
			{
				pitchAmount = info.msg.rcEntity.aim.x;
				yawAmount = info.msg.rcEntity.aim.y;
				fovScaleIndex = num;
			}
		}
	}

	public override float GetFovScale()
	{
		return fovScaleLerped;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Rust;
using UnityEngine;

public class CeilingLight : IOEntity
{
	public float pushScale = 2f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CeilingLight.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return 2;
	}

	public override void Hurt(HitInfo info)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			if (info.damageTypes.Has(DamageType.Explosion))
			{
				ClientRPC(RpcTarget.NetworkGroup("ClientPhysPush"), default(NetworkableId), info.attackNormal * 3f * (info.damageTypes.Total() / 50f), info.HitPositionWorld);
			}
			base.Hurt(info);
		}
	}

	public void RefreshGrowables()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
		Vis.Entities(((Component)this).transform.position + new Vector3(0f, 0f - ConVar.Server.ceilingLightHeightOffset, 0f), ConVar.Server.ceilingLightGrowableRange, list, 524288, (QueryTriggerInteraction)2);
		List<PlanterBox> list2 = Pool.Get<List<PlanterBox>>();
		foreach (GrowableEntity item in list)
		{
			if (item.isServer)
			{
				PlanterBox planter = item.GetPlanter();
				if ((Object)(object)planter != (Object)null && !list2.Contains(planter))
				{
					list2.Add(planter);
					planter.ForceLightUpdate();
				}
				item.CalculateQualities(firstTime: false, forceArtificialLightUpdates: true);
				item.SendNetworkUpdate();
			}
		}
		Pool.FreeUnmanaged<PlanterBox>(ref list2);
		Pool.FreeUnmanaged<GrowableEntity>(ref list);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		bool num = IsOn();
		bool flag = IsPowered();
		if (num != flag)
		{
			SetFlag(Flags.On, flag, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
			if (flag)
			{
				LightsOn();
			}
			else
			{
				LightsOff();
			}
		}
	}

	public void LightsOn()
	{
		RefreshGrowables();
	}

	public void LightsOff()
	{
		RefreshGrowables();
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		RefreshGrowables();
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		float num = 3f * (info.damageTypes.Total() / 50f);
		NetworkableId arg = (NetworkableId)(((Object)(object)info.Initiator != (Object)null && info.Initiator is BasePlayer && !info.IsPredicting) ? info.Initiator.net.ID : default(NetworkableId));
		ClientRPC(RpcTarget.NetworkGroup("ClientPhysPush"), arg, info.attackNormal * num, info.HitPositionWorld);
		base.OnAttacked(info);
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Chainsaw : BaseMelee
{
	public float attackFadeInTime = 0.1f;

	public float attackFadeInDelay = 0.1f;

	public float attackFadeOutTime = 0.1f;

	public float idleFadeInTimeFromOff = 0.1f;

	public float idleFadeInTimeFromAttack = 0.3f;

	public float idleFadeInDelay = 0.1f;

	public float idleFadeOutTime = 0.1f;

	public Renderer chainRenderer;

	private MaterialPropertyBlock block;

	private Vector2 saveST;

	public static readonly Phrase UnloadAmmoTitle = new Phrase("unload_ammo", "Unload Ammo");

	public static readonly Phrase UnloadAmmoDesc = new Phrase("unload_ammo_desc", "Unload the ammunition in this weapon and place it in your inventory.");

	[Header("Chainsaw")]
	public float fuelPerSec = 1f;

	public int maxAmmo = 100;

	public int ammo = 100;

	public ItemDefinition fuelType;

	public float reloadDuration = 2.5f;

	[Header("Sounds")]
	public SoundPlayer idleLoop;

	public SoundPlayer attackLoopAir;

	public SoundPlayer revUp;

	public SoundPlayer revDown;

	public SoundPlayer offSound;

	private int failedAttempts;

	public float engineStartChance = 0.33f;

	private TimeSince lastReloadSignalFromClient;

	private float ammoRemainder;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Chainsaw.OnRpcMessage", 0);
		try
		{
			if (rpc == 3381353917u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoReload "));
				}
				TimeWarning val2 = TimeWarning.New("DoReload", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3381353917u, "DoReload", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoReload(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoReload");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 706698034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetAttacking "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetAttacking", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(706698034u, "Server_SetAttacking", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_SetAttacking(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_SetAttacking");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3881794867u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_StartEngine "));
				}
				TimeWarning val2 = TimeWarning.New("Server_StartEngine", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3881794867u, "Server_StartEngine", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							Server_StartEngine(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in Server_StartEngine");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 841093980 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_StopEngine "));
				}
				TimeWarning val2 = TimeWarning.New("Server_StopEngine", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(841093980u, "Server_StopEngine", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							Server_StopEngine(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in Server_StopEngine");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool EngineOn()
	{
		return HasFlag(Flags.On);
	}

	public bool IsAttacking()
	{
		return HasFlag(Flags.Busy);
	}

	protected override void OnReceivedSignalServer(Signal signal, string arg)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		base.OnReceivedSignalServer(signal, arg);
		if (signal == Signal.Reload && base.isServer)
		{
			lastReloadSignalFromClient = TimeSince.op_Implicit(0f);
		}
	}

	public void ServerNPCStart()
	{
		if (!HasFlag(Flags.On))
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null && ownerPlayer.IsNpc)
			{
				DoReload(default(RPCMessage));
				SetEngineStatus(status: true);
				SendNetworkUpdateImmediate();
			}
		}
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		base.ServerUse(damageModifier, speedModifier, originOverride, useBulletThickness);
		SetAttackStatus(status: true);
		((FacepunchBehaviour)this).Invoke((Action)DelayedStopAttack, attackSpacing + 0.5f);
	}

	public override void ServerUse_OnHit(HitInfo info)
	{
		EnableHitEffect(info.HitMaterial);
	}

	private void DelayedStopAttack()
	{
		SetAttackStatus(status: false);
	}

	protected override bool VerifyClientAttack(BasePlayer player)
	{
		if (!EngineOn() || !IsAttacking())
		{
			return false;
		}
		return base.VerifyClientAttack(player);
	}

	public override void CollectedForCrafting(Item item, BasePlayer crafter)
	{
		ServerCommand(item, "unload_ammo", crafter);
	}

	public override void SetHeld(bool bHeld)
	{
		if (!bHeld)
		{
			SetEngineStatus(status: false);
		}
		base.SetHeld(bHeld);
	}

	public void ReduceAmmo(float firingTime)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null && ownerPlayer.IsNpc)
		{
			return;
		}
		ammoRemainder += firingTime;
		if (ammoRemainder >= 1f)
		{
			int num = Mathf.FloorToInt(ammoRemainder);
			ammoRemainder -= num;
			if (ammoRemainder >= 1f)
			{
				num++;
				ammoRemainder -= 1f;
			}
			ammo -= num;
			if (ammo <= 0)
			{
				ammo = 0;
			}
		}
		if ((float)ammo <= 0f)
		{
			SetEngineStatus(status: false);
		}
		SendNetworkUpdate();
		MarkChainsawItemDirty();
	}

	private void MarkChainsawItemDirty()
	{
		GetItem()?.MarkDirty();
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void DoReload(RPCMessage msg)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer == (Object)null) && !IsAttacking() && (ownerPlayer.IsNpc || (!(TimeSince.op_Implicit(lastReloadSignalFromClient) < reloadDuration * 0.25f) && !(TimeSince.op_Implicit(lastReloadSignalFromClient) > reloadDuration * 2f))))
		{
			Item item;
			while (ammo < maxAmmo && (item = GetAmmo()) != null && item.amount > 0)
			{
				int num = Mathf.Min(maxAmmo - ammo, item.amount);
				ammo += num;
				item.UseItem(num);
			}
			MarkChainsawItemDirty();
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseProjectile = Pool.Get<BaseProjectile>();
		info.msg.baseProjectile.primaryMagazine = Pool.Get<Magazine>();
		info.msg.baseProjectile.primaryMagazine.contents = ammo;
	}

	public void SetEngineStatus(bool status)
	{
		SetFlag(Flags.On, status);
		if (!status)
		{
			SetAttackStatus(status: false);
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)EngineTick);
		if (status)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)EngineTick, 0f, 1f);
		}
	}

	public void SetAttackStatus(bool status)
	{
		if (!EngineOn())
		{
			status = false;
		}
		SetFlag(Flags.Busy, status);
		((FacepunchBehaviour)this).CancelInvoke((Action)AttackTick);
		if (status)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)AttackTick, 0f, 1f);
		}
	}

	public void EngineTick()
	{
		ReduceAmmo(0.05f);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null && ownerPlayer.IsSleeping())
		{
			SetEngineStatus(status: false);
			SetAttackStatus(status: false);
		}
	}

	public void AttackTick()
	{
		ReduceAmmo(fuelPerSec);
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void Server_StartEngine(RPCMessage msg)
	{
		if (ammo > 0 && !EngineOn())
		{
			ReduceAmmo(0.25f);
			bool num = Random.Range(0f, 1f) <= engineStartChance;
			if (!num)
			{
				failedAttempts++;
			}
			if (num || failedAttempts >= 3)
			{
				failedAttempts = 0;
				SetEngineStatus(status: true);
				SendNetworkUpdateImmediate();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void Server_StopEngine(RPCMessage msg)
	{
		SetEngineStatus(status: false);
		SendNetworkUpdateImmediate();
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	public void Server_SetAttacking(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (IsAttacking() != flag && EngineOn())
		{
			SetAttackStatus(flag);
			SendNetworkUpdateImmediate();
		}
	}

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (item == null || !(command == "unload_ammo"))
		{
			return;
		}
		int num = ammo;
		if (num > 0)
		{
			ammo = 0;
			item.MarkDirty();
			SendNetworkUpdateImmediate();
			Item item2 = ItemManager.Create(fuelType, num, 0uL);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			MarkChainsawItemDirty();
		}
	}

	public void DisableHitEffects()
	{
		SetFlag(Flags.Reserved6, b: false);
		SetFlag(Flags.Reserved7, b: false);
		SetFlag(Flags.Reserved8, b: false);
		SendNetworkUpdateImmediate();
	}

	public void EnableHitEffect(uint hitMaterial)
	{
		SetFlag(Flags.Reserved6, b: false);
		SetFlag(Flags.Reserved7, b: false);
		SetFlag(Flags.Reserved8, b: false);
		if (hitMaterial == StringPool.Get("Flesh"))
		{
			SetFlag(Flags.Reserved8, b: true);
		}
		else if (hitMaterial == StringPool.Get("Wood"))
		{
			SetFlag(Flags.Reserved7, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved6, b: true);
		}
		SendNetworkUpdateImmediate();
		((FacepunchBehaviour)this).CancelInvoke((Action)DisableHitEffects);
		((FacepunchBehaviour)this).Invoke((Action)DisableHitEffects, 0.5f);
	}

	public override void DoAttackShared(HitInfo info)
	{
		base.DoAttackShared(info);
		if (base.isServer)
		{
			EnableHitEffect(info.HitMaterial);
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.baseProjectile != null && info.msg.baseProjectile.primaryMagazine != null)
		{
			ammo = info.msg.baseProjectile.primaryMagazine.contents;
		}
	}

	public bool HasAmmo()
	{
		return GetAmmo() != null;
	}

	public Item GetAmmo()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return null;
		}
		object obj = Interface.CallHook("OnInventoryAmmoItemFind", (object)ownerPlayer.inventory, (object)fuelType);
		if (obj is Item)
		{
			return (Item)obj;
		}
		return ownerPlayer.inventory.FindItemByItemName(fuelType.shortname);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class ChickenCoop : StorageContainer
{
	public struct AnimalStatus
	{
		public EntityRef<FarmableAnimal> SpawnedAnimal;

		public TimeUntil TimeUntilHatch;

		public void CopyTo(ChickenStatus status)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			status.spawnedChicken = SpawnedAnimal.uid;
			status.timeUntilHatch = TimeUntil.op_Implicit(TimeUntilHatch);
		}

		public void CopyFrom(ChickenStatus status)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			SpawnedAnimal.uid = status.spawnedChicken;
			TimeUntilHatch = TimeUntil.op_Implicit(status.timeUntilHatch);
		}
	}

	public class ChickenCoopWorkQueue : ObjectWorkQueue<ChickenCoop>
	{
		protected override void RunJob(ChickenCoop entity)
		{
			entity.QueuedWorkJob();
		}
	}

	public Transform[] SpawnPoints;

	public GameObjectRef ChickenPrefab;

	public int MaxChickens = 4;

	public float ChickenHatchTimeMinutes = 30f;

	public float SunCheckRate = 10f;

	public Transform SunSampler;

	public List<AnimalStatus> Animals = new List<AnimalStatus>();

	public const Flags Hatching = Flags.Reserved1;

	public const Flags Full = Flags.Reserved3;

	public const int EggInsertSlot = 0;

	public const int FoodSlot = 1;

	public const int WaterSlot = 2;

	public const int FoodProductionSlot = 3;

	public GameObjectRef hatchEffect;

	private float currentSunValue;

	public Plane MovementPlane;

	public static ChickenCoopWorkQueue CoopWorkQueue = new ChickenCoopWorkQueue();

	public bool IsInSun => currentSunValue > 0f;

	public bool IsOnTerrain { get; private set; }

	public Item CurrentFoodItem => base.inventory?.GetSlot(1);

	public Item CurrentWaterItem => base.inventory?.GetSlot(2);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ChickenCoop.OnRpcMessage", 0);
		try
		{
			if (rpc == 3418655327u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestAnimalStats "));
				}
				TimeWarning val2 = TimeWarning.New("RequestAnimalStats", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3418655327u, "RequestAnimalStats", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3418655327u, "RequestAnimalStats", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RequestAnimalStats(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RequestAnimalStats");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1409078750 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SubmitEggForHatching "));
				}
				TimeWarning val2 = TimeWarning.New("SubmitEggForHatching", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1409078750u, "SubmitEggForHatching", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SubmitEggForHatching(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SubmitEggForHatching");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)ScheduleWorkQueue, Random.Range(0f, SunCheckRate), SunCheckRate);
		if (GamePhysics.Trace(new Ray(((Component)this).transform.position + ((Component)this).transform.up, -((Component)this).transform.up), 0f, out var hitInfo, 1.1f, 10485760, (QueryTriggerInteraction)0))
		{
			IsOnTerrain = ((RaycastHit)(ref hitInfo)).collider.IsOnLayer((Layer)23);
			if (!IsOnTerrain)
			{
				MovementPlane = new Plane(((Component)this).transform.up, ((Component)this).transform.position);
			}
		}
	}

	private void ScheduleWorkQueue()
	{
		((ObjectWorkQueue<ChickenCoop>)CoopWorkQueue).Add(this);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void SubmitEggForHatching(RPCMessage msg)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		if (HasFlag(Flags.Reserved3) || HasFlag(Flags.Reserved1))
		{
			return;
		}
		Item slot = base.inventory.GetSlot(0);
		if (slot != null && !(slot.info.shortname != "egg") && !((Object)(object)msg.player.inventory.loot.entitySource != (Object)(object)this))
		{
			slot.UseItem();
			Animals.Add(new AnimalStatus
			{
				TimeUntilHatch = TimeUntil.op_Implicit(ChickenHatchTimeMinutes * 60f)
			});
			SetFlag(Flags.Reserved1, b: true);
			SetFlag(Flags.Reserved3, Animals.Count >= MaxChickens);
			if (!((FacepunchBehaviour)this).IsInvoking((Action)CheckEggHatchState))
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CheckEggHatchState, 10f, 10f);
			}
			SendNetworkUpdate();
		}
	}

	private void CheckEggHatchState()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		for (int i = 0; i < Animals.Count; i++)
		{
			AnimalStatus value = Animals[i];
			if (!value.SpawnedAnimal.IsSet && TimeUntil.op_Implicit(value.TimeUntilHatch) <= 0f)
			{
				FarmableAnimal farmableAnimal = SpawnChicken(i);
				value.SpawnedAnimal.Set(farmableAnimal);
				flag = true;
				Animals[i] = value;
				if (hatchEffect != null && hatchEffect.isValid)
				{
					Effect.server.Run(hatchEffect.resourcePath, ((Component)farmableAnimal).transform.position);
				}
			}
		}
		if (flag)
		{
			SetFlag(Flags.Reserved1, b: false);
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckEggHatchState);
			SendNetworkUpdate();
		}
	}

	private FarmableAnimal SpawnChicken(int index)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		FarmableAnimal obj = base.gameManager.CreateEntity(ChickenPrefab.resourcePath, GetRandomMovePoint(), Quaternion.Euler(0f, Random.Range(0f, 360f), 0f)) as FarmableAnimal;
		obj.SetParent(this, worldPositionStays: true);
		string text = RandomUsernames.Get(Random.Range(0, 1000));
		text = text[0].ToString().ToUpper() + text.Substring(1);
		obj.ApplyStartingStats(text);
		obj.Spawn();
		return obj;
	}

	public Vector3 GetRandomMovePoint()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.Server.farmChickenLocalAvoidance)
		{
			int num = 10;
			for (int i = 0; i < num; i++)
			{
				Vector3 position = SpawnPoints[Random.Range(0, SpawnPoints.Length)].position;
				if (IsLocationClear(position, 0.25f))
				{
					return position;
				}
			}
		}
		return SpawnPoints[Random.Range(0, SpawnPoints.Length)].position;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.chickenCoop = Pool.Get<ChickenCoop>();
		info.msg.chickenCoop.chickens = Pool.Get<List<ChickenStatus>>();
		foreach (AnimalStatus animal in Animals)
		{
			ChickenStatus val = Pool.Get<ChickenStatus>();
			animal.CopyTo(val);
			info.msg.chickenCoop.chickens.Add(val);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (HasFlag(Flags.Reserved1) && !((FacepunchBehaviour)this).IsInvoking((Action)CheckEggHatchState))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)CheckEggHatchState, 10f, 10f);
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (targetSlot == 0 && item.info.shortname != "egg")
		{
			return false;
		}
		if (targetSlot == 1 && !IsValidFoodItem(item))
		{
			return false;
		}
		switch (targetSlot)
		{
		case 2:
			return item.info.shortname == "water";
		case 3:
			if (item.info.shortname != "egg")
			{
				return false;
			}
			break;
		}
		return base.ItemFilter(item, targetSlot);
	}

	private void QueuedWorkJob()
	{
		if (Animals.Count != 0)
		{
			UpdateSunValue();
		}
	}

	private void UpdateSunValue()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (TOD_Sky.Instance.IsNight)
		{
			currentSunValue = 0f;
			return;
		}
		Vector3 sunDirection = TOD_Sky.Instance.SunDirection;
		float num = Vector3.Dot(SunSampler.forward, sunDirection);
		currentSunValue = Mathf.InverseLerp(0.1f, 0.6f, num);
		if (currentSunValue > 0f && !IsVisible(SunSampler.position + sunDirection * 100f, 101f))
		{
			currentSunValue = 0f;
		}
	}

	public void DebugFillCoop()
	{
		while (Animals.Count < MaxChickens)
		{
			AnimalStatus item = default(AnimalStatus);
			FarmableAnimal entity = SpawnChicken(Animals.Count);
			item.SpawnedAnimal.Set(entity);
			Animals.Add(item);
		}
		SetFlag(Flags.Reserved3, b: true);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	private void RequestAnimalStats(RPCMessage msg)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		ChickenCoopStatusUpdate val = Pool.Get<ChickenCoopStatusUpdate>();
		try
		{
			val.animals = Pool.Get<List<FarmableAnimalStatus>>();
			foreach (AnimalStatus animal in Animals)
			{
				FarmableAnimalStatus val2 = Pool.Get<FarmableAnimalStatus>();
				val2.data = Pool.Get<FarmableAnimal>();
				EntityRef<FarmableAnimal> spawnedAnimal = animal.SpawnedAnimal;
				if ((Object)(object)spawnedAnimal.Get(serverside: true) != (Object)null)
				{
					spawnedAnimal = animal.SpawnedAnimal;
					spawnedAnimal.Get(serverside: true).SaveToData(val2.data);
					spawnedAnimal = animal.SpawnedAnimal;
					val2.animal = spawnedAnimal.uid;
					val.animals.Add(val2);
				}
			}
			ClientRPC(RpcTarget.Player("OnReceivedChickenStats", player), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnAnimalDied(FarmableAnimal animal)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Animals.Count; i++)
		{
			if (Animals[i].SpawnedAnimal.uid == animal.net.ID)
			{
				Animals.RemoveAt(i);
				break;
			}
		}
		SetFlag(Flags.Reserved3, Animals.Count >= MaxChickens, recursive: false, networkupdate: false);
		SendNetworkUpdate();
	}

	public override void DropItems(BaseEntity initiator = null)
	{
		base.inventory.GetSlot(2)?.Remove();
		base.DropItems(initiator);
	}

	public bool IsLocationClear(Vector3 pos, float radius, FarmableAnimal ignoreAnimal = null)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		foreach (AnimalStatus animal in Animals)
		{
			FarmableAnimal farmableAnimal = animal.SpawnedAnimal.Get(serverside: true);
			if ((Object)(object)farmableAnimal != (Object)null && (Object)(object)farmableAnimal != (Object)(object)ignoreAnimal)
			{
				Vector3 val = ((Component)farmableAnimal).transform.position - pos;
				if (((Vector3)(ref val)).sqrMagnitude < radius * radius)
				{
					return false;
				}
			}
		}
		return true;
	}

	private bool IsValidFoodItem(Item item)
	{
		ItemModConsumable itemModConsumable = default(ItemModConsumable);
		if (item != null && ((Component)item.info).TryGetComponent<ItemModConsumable>(ref itemModConsumable))
		{
			return itemModConsumable.chickenCoopFood;
		}
		return false;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		Animals.Clear();
		if (info.msg.chickenCoop == null || info.msg.chickenCoop.chickens == null)
		{
			return;
		}
		foreach (ChickenStatus chicken in info.msg.chickenCoop.chickens)
		{
			AnimalStatus item = default(AnimalStatus);
			item.CopyFrom(chicken);
			Animals.Add(item);
		}
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (base.CanPickup(player))
		{
			return Animals.Count == 0;
		}
		return false;
	}
}


using ProtoBuf;

public struct AnimalStatus
{
	public EntityRef<FarmableAnimal> SpawnedAnimal;

	public TimeUntil TimeUntilHatch;

	public void CopyTo(ChickenStatus status)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		status.spawnedChicken = SpawnedAnimal.uid;
		status.timeUntilHatch = TimeUntil.op_Implicit(TimeUntilHatch);
	}

	public void CopyFrom(ChickenStatus status)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		SpawnedAnimal.uid = status.spawnedChicken;
		TimeUntilHatch = TimeUntil.op_Implicit(status.timeUntilHatch);
	}
}


public class ChickenCoopWorkQueue : ObjectWorkQueue<ChickenCoop>
{
	protected override void RunJob(ChickenCoop entity)
	{
		entity.QueuedWorkJob();
	}
}


using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class ClanManager : BaseEntity
{
	private RealTimeSince _sinceLastLeaderboardUpdate;

	private List<ClanLeaderboardEntry> _leaderboardCache;

	public static readonly TokenisedPhrase InvitationToast = new TokenisedPhrase("clan.invitation.toast", "You were invited to {clanName}! Press [clan.toggleclan] to manage your clan invitations.");

	public const int LogoSize = 512;

	private string _backendType;

	private ClanChangeTracker _changeTracker;

	private const int MaxMetadataRequestsPerSecond = 3;

	private const float MaxMetadataRequestInterval = 0.5f;

	private const float MetadataExpiry = 300f;

	private readonly Dictionary<long, List<Connection>> _clanMemberConnections = new Dictionary<long, List<Connection>>();

	public static ClanManager ServerInstance { get; private set; }

	public IClanBackend Backend { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ClanManager.OnRpcMessage", 0);
		try
		{
			if (rpc == 3593616087u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AcceptInvitation "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AcceptInvitation", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3593616087u, "Server_AcceptInvitation", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_AcceptInvitation(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_AcceptInvitation");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 73135447 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_CancelInvitation "));
				}
				TimeWarning val2 = TimeWarning.New("Server_CancelInvitation", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(73135447u, "Server_CancelInvitation", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_CancelInvitation(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_CancelInvitation");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 785874715 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_CancelInvite "));
				}
				TimeWarning val2 = TimeWarning.New("Server_CancelInvite", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(785874715u, "Server_CancelInvite", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							Server_CancelInvite(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in Server_CancelInvite");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4017901233u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_CreateClan "));
				}
				TimeWarning val2 = TimeWarning.New("Server_CreateClan", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4017901233u, "Server_CreateClan", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							Server_CreateClan(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in Server_CreateClan");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 835697933 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_CreateRole "));
				}
				TimeWarning val2 = TimeWarning.New("Server_CreateRole", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(835697933u, "Server_CreateRole", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							Server_CreateRole(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in Server_CreateRole");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3966624879u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_DeleteRole "));
				}
				TimeWarning val2 = TimeWarning.New("Server_DeleteRole", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3966624879u, "Server_DeleteRole", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							Server_DeleteRole(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in Server_DeleteRole");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4071826018u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_GetClan "));
				}
				TimeWarning val2 = TimeWarning.New("Server_GetClan", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4071826018u, "Server_GetClan", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							Server_GetClan(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in Server_GetClan");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2338234158u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_GetClanMetadata "));
				}
				TimeWarning val2 = TimeWarning.New("Server_GetClanMetadata", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2338234158u, "Server_GetClanMetadata", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg9 = rPCMessage;
							Server_GetClanMetadata(msg9);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in Server_GetClanMetadata");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 507204008 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_GetInvitations "));
				}
				TimeWarning val2 = TimeWarning.New("Server_GetInvitations", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(507204008u, "Server_GetInvitations", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							Server_GetInvitations(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in Server_GetInvitations");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1953068009 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_GetLeaderboard "));
				}
				TimeWarning val2 = TimeWarning.New("Server_GetLeaderboard", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1953068009u, "Server_GetLeaderboard", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							Server_GetLeaderboard(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in Server_GetLeaderboard");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3858074978u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_GetLogs "));
				}
				TimeWarning val2 = TimeWarning.New("Server_GetLogs", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3858074978u, "Server_GetLogs", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg12 = rPCMessage;
							Server_GetLogs(msg12);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in Server_GetLogs");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 558876504 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_GetScoreEvents "));
				}
				TimeWarning val2 = TimeWarning.New("Server_GetScoreEvents", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(558876504u, "Server_GetScoreEvents", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg13 = rPCMessage;
							Server_GetScoreEvents(msg13);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogException(ex12);
						player.Kick("RPC Error in Server_GetScoreEvents");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1782867876 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_Invite "));
				}
				TimeWarning val2 = TimeWarning.New("Server_Invite", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1782867876u, "Server_Invite", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg14 = rPCMessage;
							Server_Invite(msg14);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex13)
					{
						Debug.LogException(ex13);
						player.Kick("RPC Error in Server_Invite");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3093528332u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_Kick "));
				}
				TimeWarning val2 = TimeWarning.New("Server_Kick", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3093528332u, "Server_Kick", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg15 = rPCMessage;
							Server_Kick(msg15);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex14)
					{
						Debug.LogException(ex14);
						player.Kick("RPC Error in Server_Kick");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2235419116u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetColor "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetColor", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2235419116u, "Server_SetColor", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg16 = rPCMessage;
							Server_SetColor(msg16);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex15)
					{
						Debug.LogException(ex15);
						player.Kick("RPC Error in Server_SetColor");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1189444132 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetLogo "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetLogo", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1189444132u, "Server_SetLogo", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg17 = rPCMessage;
							Server_SetLogo(msg17);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex16)
					{
						Debug.LogException(ex16);
						player.Kick("RPC Error in Server_SetLogo");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4088477037u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetMotd "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetMotd", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4088477037u, "Server_SetMotd", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg18 = rPCMessage;
							Server_SetMotd(msg18);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex17)
					{
						Debug.LogException(ex17);
						player.Kick("RPC Error in Server_SetMotd");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 285489852 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetPlayerNotes "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetPlayerNotes", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(285489852u, "Server_SetPlayerNotes", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg19 = rPCMessage;
							Server_SetPlayerNotes(msg19);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex18)
					{
						Debug.LogException(ex18);
						player.Kick("RPC Error in Server_SetPlayerNotes");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3232449870u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetPlayerRole "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetPlayerRole", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3232449870u, "Server_SetPlayerRole", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg20 = rPCMessage;
							Server_SetPlayerRole(msg20);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex19)
					{
						Debug.LogException(ex19);
						player.Kick("RPC Error in Server_SetPlayerRole");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 738181899 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SwapRoles "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SwapRoles", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(738181899u, "Server_SwapRoles", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg21 = rPCMessage;
							Server_SwapRoles(msg21);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex20)
					{
						Debug.LogException(ex20);
						player.Kick("RPC Error in Server_SwapRoles");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1548667516 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_UpdateRole "));
				}
				TimeWarning val2 = TimeWarning.New("Server_UpdateRole", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1548667516u, "Server_UpdateRole", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg22 = rPCMessage;
							Server_UpdateRole(msg22);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex21)
					{
						Debug.LogException(ex21);
						player.Kick("RPC Error in Server_UpdateRole");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_CreateClan(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		string text = default(string);
		if (!ClanValidator.ValidateClanName(msg.read.String(256, false), ref text))
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)6, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Create((ulong)msg.player.userID, text);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)1, clan));
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public async void Server_GetClan(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			await clan.RefreshIfStale();
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)1, clan));
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_GetLogs(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanValueResult<ClanLogs> val = await clan.GetLogs(100, (ulong)msg.player.userID);
			if (val.IsSuccess)
			{
				ClientRPC(RpcTarget.Player("Client_ReceiveClanLogs", msg.player), val.Value.ToProto());
			}
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, val.Result, clan));
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_GetScoreEvents(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanValueResult<ClanScoreEvents> val = await clan.GetScoreEvents(100, (ulong)msg.player.userID);
			if (val.IsSuccess)
			{
				ClientRPCPlayer<ClanScoreEvents>(null, msg.player, "Client_ReceiveClanScoreEvents", val.Value.ToProto());
			}
			ClientRPCPlayer<ClanActionResult>(null, msg.player, "Client_ReceiveActionResult", BuildActionResult(requestId, val.Result, clan));
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public async void Server_GetInvitations(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		ClanValueResult<List<ClanInvitation>> val = await Backend.ListInvitations((ulong)msg.player.userID);
		if (val.IsSuccess)
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveClanInvitations", msg.player), val.Value.ToProto());
		}
		ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, val.Result, null, hasClanInfo: false));
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_GetLeaderboard(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		if (_leaderboardCache == null || RealTimeSince.op_Implicit(_sinceLastLeaderboardUpdate) > 30f)
		{
			ClanValueResult<List<ClanLeaderboardEntry>> val = await Backend.GetLeaderboard(100);
			if (val.IsSuccess)
			{
				_leaderboardCache = val.Value;
				_sinceLastLeaderboardUpdate = RealTimeSince.op_Implicit(0f);
			}
			else
			{
				_leaderboardCache = null;
			}
		}
		if (_leaderboardCache != null)
		{
			ClientRPCPlayer<ClanLeaderboard>(null, msg.player, "Client_ReceiveClanLeaderboard", _leaderboardCache.ToProto());
		}
		ClanResult result = (ClanResult)(_leaderboardCache != null);
		ClientRPCPlayer<ClanActionResult>(null, msg.player, "Client_ReceiveActionResult", BuildActionResult(requestId, result, null, hasClanInfo: false));
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public async void Server_SetLogo(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		byte[] newLogo = msg.read.BytesWithSize(10485760u, false);
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		if (!ImageProcessing.IsValidPNG(newLogo, 512, 512))
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)7, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.SetLogo(newLogo, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, clan));
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_SetColor(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		Color32 newColor = msg.read.Color32();
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		if (newColor.a != byte.MaxValue)
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)8, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.SetColor(newColor, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, clan));
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public async void Server_SetMotd(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		string text = msg.read.StringMultiLine(2048, false);
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		string validatedMotd = default(string);
		if (!ClanValidator.ValidateMotd(text, ref validatedMotd))
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)6, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			long previousTimestamp = clan.MotdTimestamp;
			ClanResult val = await clan.SetMotd(validatedMotd, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, val, clan));
			if ((int)val == 1)
			{
				ClanPushNotifications.SendClanAnnouncement(clan, previousTimestamp, msg.player.userID);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public async void Server_Invite(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		ulong steamId = msg.read.UInt64();
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.Invite(steamId, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, clan));
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_CancelInvite(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		ulong steamId = msg.read.UInt64();
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.CancelInvite(steamId, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, clan));
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_AcceptInvitation(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		long num = msg.read.Int64();
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(num);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.AcceptInvite((ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, null));
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public async void Server_CancelInvitation(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		long num = msg.read.Int64();
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(num);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.CancelInvite((ulong)msg.player.userID, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, null));
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public async void Server_Kick(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		ulong steamId = msg.read.UInt64();
		if ((ulong)msg.player.userID != steamId && !msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.Kick(steamId, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, clan));
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_SetPlayerRole(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		ulong steamId = msg.read.UInt64();
		int newRoleId = msg.read.Int32();
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.SetPlayerRole(steamId, newRoleId, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, clan));
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_SetPlayerNotes(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		ulong steamId = msg.read.UInt64();
		string text = msg.read.StringMultiLine(1024, false);
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		string validatedNotes = default(string);
		if (!ClanValidator.ValidatePlayerNote(text, ref validatedNotes))
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)6, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.SetPlayerNotes(steamId, validatedNotes, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, clan));
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_CreateRole(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		string text = msg.read.String(128, false);
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		string name = default(string);
		if (!ClanValidator.ValidateRoleName(text, ref name))
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)6, null, hasClanInfo: false));
			return;
		}
		ClanRole role = new ClanRole
		{
			Name = name
		};
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.CreateRole(role, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, clan));
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public async void Server_UpdateRole(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		Role role = msg.read.Proto<Role>((Role)null);
		try
		{
			string name = default(string);
			if (!ClanValidator.ValidateRoleName(role.name, ref name))
			{
				ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)6, null, hasClanInfo: false));
				return;
			}
			role.name = name;
			ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
			if (CheckClanResult(requestId, msg.player, result, out var clan))
			{
				ClanResult result2 = await clan.UpdateRole(role.FromProto(), (ulong)msg.player.userID);
				ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, clan));
			}
		}
		finally
		{
			((IDisposable)role)?.Dispose();
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_DeleteRole(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		int roleId = msg.read.Int32();
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.DeleteRole(roleId, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, clan));
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_SwapRoles(RPCMessage msg)
	{
		int requestId = msg.read.Int32();
		int roleIdA = msg.read.Int32();
		int roleIdB = msg.read.Int32();
		if (!msg.player.CanModifyClan())
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, (ClanResult)16, null, hasClanInfo: false));
			return;
		}
		ClanValueResult<IClan> result = await Backend.Get(msg.player.clanId);
		if (CheckClanResult(requestId, msg.player, result, out var clan))
		{
			ClanResult result2 = await clan.SwapRoleRanks(roleIdA, roleIdB, (ulong)msg.player.userID);
			ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", msg.player), BuildActionResult(requestId, result2, clan));
		}
	}

	private bool CheckClanResult(int requestId, BasePlayer player, ClanValueResult<IClan> result, out IClan clan)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (result.IsSuccess)
		{
			clan = result.Value;
			return true;
		}
		ClientRPC(RpcTarget.Player("Client_ReceiveActionResult", player), BuildActionResult(requestId, result.Result, null));
		clan = null;
		return false;
	}

	private static ClanActionResult BuildActionResult(int requestId, ClanResult result, IClan clan, bool hasClanInfo = true)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected I4, but got Unknown
		ClanActionResult obj = Pool.Get<ClanActionResult>();
		obj.requestId = requestId;
		obj.result = (int)result;
		obj.hasClanInfo = hasClanInfo;
		obj.clanInfo = clan.ToProto();
		return obj;
	}

	public async Task Initialize()
	{
		if (string.IsNullOrWhiteSpace(_backendType))
		{
			throw new InvalidOperationException("Clan backend type has not been assigned!");
		}
		IClanBackend backend = CreateBackendInstance(_backendType);
		if (backend == null)
		{
			throw new InvalidOperationException("Clan backend failed to create (returned null)");
		}
		try
		{
			_changeTracker = new ClanChangeTracker(this);
			await backend.Initialize((IClanChangeSink)(object)_changeTracker);
			Backend = backend;
			((FacepunchBehaviour)this).InvokeRandomized((Action)delegate
			{
				_changeTracker.HandleEvents();
			}, 1f, 0.25f, 0.1f);
		}
		catch (Exception innerException)
		{
			throw new InvalidOperationException("Clan backend failed to initialize (threw exception)", innerException);
		}
	}

	public void Shutdown()
	{
		if (Backend == null)
		{
			return;
		}
		try
		{
			((IDisposable)Backend).Dispose();
			Backend = null;
		}
		catch (Exception innerException)
		{
			throw new InvalidOperationException("Clan backend failed to shutdown (threw exception)", innerException);
		}
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!base.isServer)
		{
			return;
		}
		if (Application.isLoadingSave)
		{
			if (!Clan.enabled)
			{
				Debug.LogWarning((object)"Clan manager was loaded from a save, but the server has the clan system disabled - destroying clan manager!");
				((FacepunchBehaviour)this).Invoke((Action)delegate
				{
					Kill();
				}, 0.1f);
			}
		}
		else if (!Application.isLoadingSave)
		{
			_backendType = ChooseBackendType();
			if (string.IsNullOrWhiteSpace(_backendType))
			{
				Debug.LogError((object)"Clan manager did not choose a backend type!");
			}
			else
			{
				Debug.Log((object)("Clan manager will use backend type: " + _backendType));
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.clanManager = Pool.Get<ClanManager>();
			info.msg.clanManager.backendType = _backendType;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.clanManager != null)
		{
			_backendType = info.msg.clanManager.backendType;
		}
	}

	private static string ChooseBackendType()
	{
		if (NexusServer.Started)
		{
			return "nexus";
		}
		return "local";
	}

	private static IClanBackend CreateBackendInstance(string type)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Expected O, but got Unknown
		if (!(type == "local"))
		{
			if (type == "nexus")
			{
				return (IClanBackend)(object)new NexusClanBackend();
			}
			throw new NotSupportedException("Clan backend '" + type + "' is not supported");
		}
		return (IClanBackend)new LocalClanBackend(ConVar.Server.rootFolder, Clan.maxMemberCount);
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			if ((Object)(object)ServerInstance != (Object)null)
			{
				Debug.LogError((object)"Major fuckup! Server ClanManager spawned twice, contact Developers!");
				Object.Destroy((Object)(object)((Component)this).gameObject);
			}
			else
			{
				ServerInstance = this;
			}
		}
	}

	public void OnDestroy()
	{
		if (base.isServer)
		{
			if ((Object)(object)ServerInstance == (Object)(object)this)
			{
				ServerInstance = null;
			}
			Shutdown();
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public async void Server_GetClanMetadata(RPCMessage msg)
	{
		long clanId = msg.read.Int64();
		ClanValueResult<IClan> val = await Backend.Get(clanId);
		if (val.IsSuccess)
		{
			IClan value = val.Value;
			ClientRPC(RpcTarget.Player("Client_GetClanMetadataResponse", msg.player), clanId, value.Name ?? "", value.Members?.Count ?? 0, value.Color);
		}
		else
		{
			ClientRPC(RpcTarget.Player("Client_GetClanMetadataResponse", msg.player), clanId, "[unknown]", 0, Color32.op_Implicit(Color.white));
		}
	}

	public void AddScore(IClan clan, ClanScoreEvent entry)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsNotNull<IClan>(clan, "clan != null");
		ValueTask<ClanResult> task2 = clan.AddScoreEvent(entry);
		if (task2.IsCompletedSuccessfully)
		{
			CheckResult(task2.Result);
		}
		else
		{
			AwaitResult(task2);
		}
		async void AwaitResult(ValueTask<ClanResult> task)
		{
			try
			{
				CheckResult(await task);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)$"Exception while adding score event to clan {clan.ClanId}:");
				Debug.LogException(ex);
			}
		}
		void CheckResult(ClanResult result)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if ((int)result != 1)
			{
				Debug.LogWarning((object)$"Failed to add score event to clan {clan.ClanId}: {result}");
			}
		}
	}

	public void SendClanChanged(IClan clan)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		List<Connection> list = Pool.Get<List<Connection>>();
		foreach (ClanMember member in clan.Members)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(member.SteamId);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsConnected)
			{
				list.Add(basePlayer.net.connection);
			}
		}
		ClientRPC(RpcTarget.Players("Client_CurrentClanChanged", list));
		Pool.FreeUnmanaged<Connection>(ref list);
	}

	public void SendClanInvitation(ulong steamId, long clanId)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(steamId);
		if (!((Object)(object)basePlayer == (Object)null) && basePlayer.IsConnected)
		{
			ClientRPC(RpcTarget.Player("Client_ReceiveClanInvitation", basePlayer), clanId);
		}
	}

	public bool TryGetClanMemberConnections(long clanId, out List<Connection> connections)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (_clanMemberConnections.TryGetValue(clanId, out connections))
		{
			return true;
		}
		IClan val = default(IClan);
		if (!Backend.TryGet(clanId, ref val))
		{
			return false;
		}
		connections = Pool.Get<List<Connection>>();
		foreach (ClanMember member in val.Members)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(member.SteamId);
			if ((Object)(object)basePlayer == (Object)null)
			{
				basePlayer = BasePlayer.FindSleeping(member.SteamId);
			}
			if (!((Object)(object)basePlayer == (Object)null) && basePlayer.IsConnected)
			{
				connections.Add(basePlayer.Connection);
			}
		}
		_clanMemberConnections.Add(clanId, connections);
		return true;
	}

	public void ClanMemberConnectionsChanged(long clanId)
	{
		if (_clanMemberConnections.TryGetValue(clanId, out var value))
		{
			_clanMemberConnections.Remove(clanId);
			Pool.FreeUnmanaged<Connection>(ref value);
		}
	}

	public async void LoadClanInfoForSleepers()
	{
		Dictionary<ulong, BasePlayer> sleepers = Pool.Get<Dictionary<ulong, BasePlayer>>();
		sleepers.Clear();
		Enumerator<BasePlayer> enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (current.IsValid() && !current.IsNpc && !current.IsBot)
				{
					sleepers.Add(current.userID, current);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		HashSet<ulong> found = Pool.Get<HashSet<ulong>>();
		found.Clear();
		foreach (BasePlayer player in sleepers.Values)
		{
			if (!player.IsValid() || player.IsConnected || found.Contains(player.userID))
			{
				continue;
			}
			try
			{
				ClanValueResult<IClan> val = await Backend.GetByMember((ulong)player.userID);
				if (val.IsSuccess)
				{
					IClan value = val.Value;
					player.serverClan = value;
					player.clanId = value.ClanId;
					SendNetworkUpdate();
					found.Add(player.userID);
					foreach (ClanMember member in value.Members)
					{
						if (sleepers.TryGetValue(member.SteamId, out var value2) && found.Add(member.SteamId))
						{
							value2.serverClan = value;
							value2.clanId = value.ClanId;
							value2.SendNetworkUpdate();
						}
					}
				}
				else if ((int)val.Result == 3)
				{
					player.serverClan = null;
					player.clanId = 0L;
					SendNetworkUpdate();
					found.Add(player.userID);
				}
				else
				{
					Debug.LogError((object)$"Failed to find clan for {player.userID.Get()}: {val.Result}");
					((FacepunchBehaviour)this).Invoke((Action)delegate
					{
						player.LoadClanInfo();
					}, (float)(45 + Random.Range(0, 30)));
				}
			}
			catch (Exception ex)
			{
				DebugEx.Log((object)$"Exception was thrown while loading clan info for {player.userID.Get()}:", (StackTraceLogType)0);
				Debug.LogException(ex);
			}
		}
		found.Clear();
		Pool.FreeUnmanaged<ulong>(ref found);
		sleepers.Clear();
		Pool.FreeUnmanaged<ulong, BasePlayer>(ref sleepers);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class CodeLock : BaseLock, ISprayCallback
{
	public GameObjectRef keyEnterDialog;

	public GameObjectRef effectUnlocked;

	public GameObjectRef effectLocked;

	public GameObjectRef effectDenied;

	public GameObjectRef effectCodeChanged;

	public GameObjectRef effectShock;

	public bool hasCode;

	public const Flags Flag_CodeEntryBlocked = Flags.Reserved11;

	public static readonly Phrase blockwarning = new Phrase("codelock.blockwarning", "Further failed attempts will block code entry for some time");

	[ServerVar]
	public static float maxFailedAttempts = 8f;

	[ServerVar]
	public static float lockoutCooldown = 900f;

	public bool hasGuestCode;

	[NonSerialized]
	public string code = string.Empty;

	[NonSerialized]
	public string guestCode = string.Empty;

	[NonSerialized]
	public List<ulong> whitelistPlayers = new List<ulong>();

	[NonSerialized]
	public List<ulong> guestPlayers = new List<ulong>();

	public int wrongCodes;

	public float lastWrongTime = float.NegativeInfinity;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CodeLock.OnRpcMessage", 0);
		try
		{
			if (rpc == 4013784361u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ChangeCode "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ChangeCode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4013784361u, "RPC_ChangeCode", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_ChangeCode(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_ChangeCode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2626067433u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - TryLock "));
				}
				TimeWarning val2 = TimeWarning.New("TryLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2626067433u, "TryLock", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							TryLock(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in TryLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1718262 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - TryUnlock "));
				}
				TimeWarning val2 = TimeWarning.New("TryUnlock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1718262u, "TryUnlock", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							TryUnlock(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in TryUnlock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 418605506 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UnlockWithCode "));
				}
				TimeWarning val2 = TimeWarning.New("UnlockWithCode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(418605506u, "UnlockWithCode", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc5 = rPCMessage;
							UnlockWithCode(rpc5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in UnlockWithCode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsCodeEntryBlocked()
	{
		return HasFlag(Flags.Reserved11);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.codeLock != null)
		{
			hasCode = info.msg.codeLock.hasCode;
			hasGuestCode = info.msg.codeLock.hasGuestCode;
			LoadCodelockPrivateData(info.msg.codeLock);
		}
	}

	public void LoadCodelockPrivateData(CodeLock proto)
	{
		if (proto?.pv != null)
		{
			code = proto.pv.code;
			whitelistPlayers = List.ShallowClonePooled<ulong>(proto.pv.users);
			guestCode = proto.pv.guestCode;
			guestPlayers = List.ShallowClonePooled<ulong>(proto.pv.guestUsers);
		}
	}

	internal void DoEffect(string effect)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(effect, this, 0u, Vector3.zero, Vector3.forward);
	}

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsLocked())
		{
			return true;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

	public override bool OnTryToClose(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsLocked())
		{
			return true;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

	public override bool CanUseNetworkCache(Connection connection)
	{
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.codeLock = Pool.Get<CodeLock>();
		info.msg.codeLock.hasGuestCode = guestCode.Length > 0;
		info.msg.codeLock.hasCode = code.Length > 0;
		if (!info.forDisk && info.forConnection != null)
		{
			info.msg.codeLock.hasAuth = whitelistPlayers.Contains(info.forConnection.userid);
			info.msg.codeLock.hasGuestAuth = guestPlayers.Contains(info.forConnection.userid);
		}
		if (info.forDisk)
		{
			info.msg.codeLock.pv = Pool.Get<Private>();
			info.msg.codeLock.pv.code = code;
			info.msg.codeLock.pv.users = List.ShallowClonePooled<ulong>(whitelistPlayers);
			info.msg.codeLock.pv.guestCode = guestCode;
			info.msg.codeLock.pv.guestUsers = List.ShallowClonePooled<ulong>(guestPlayers);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String(256, false);
		bool flag = rpc.read.Bit();
		if (!IsLocked() && text.Length == 4 && StringEx.IsNumeric(text) && !(!hasCode && flag) && Interface.CallHook("CanChangeCode", (object)rpc.player, (object)this, (object)text, (object)flag) == null)
		{
			if (!hasCode && !flag)
			{
				SetFlag(Flags.Locked, b: true);
			}
			Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			Interface.CallHook("OnCodeChanged", (object)rpc.player, (object)this, (object)text, (object)flag);
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	private void TryUnlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", (object)rpc.player, (object)this) == null && !IsCodeEntryBlocked() && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	private void TryLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && Interface.CallHook("CanLock", (object)rpc.player, (object)this) == null && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectLocked.resourcePath);
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

	public void ClearCodeEntryBlocked()
	{
		SetFlag(Flags.Reserved11, b: false);
		wrongCodes = 0;
	}

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void UnlockWithCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || !IsLocked() || IsCodeEntryBlocked())
		{
			return;
		}
		string text = rpc.read.String(256, false);
		if (Interface.CallHook("OnCodeEntered", (object)this, (object)rpc.player, (object)text) != null)
		{
			return;
		}
		bool flag = text == guestCode;
		bool flag2 = text == code;
		if (!(text == code) && (!hasGuestCode || !(text == guestCode)))
		{
			if (Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			DoEffect(effectDenied.resourcePath);
			DoEffect(effectShock.resourcePath);
			rpc.player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, this, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				rpc.player.ShowToast(GameTip.Styles.Red_Normal, blockwarning, false);
			}
			if ((float)wrongCodes >= maxFailedAttempts)
			{
				SetFlag(Flags.Reserved11, b: true);
				((FacepunchBehaviour)this).Invoke((Action)ClearCodeEntryBlocked, lockoutCooldown);
			}
			lastWrongTime = Time.realtimeSinceStartup;
			return;
		}
		SendNetworkUpdate();
		if (flag2)
		{
			if (!whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectCodeChanged.resourcePath);
				whitelistPlayers.Add(rpc.player.userID);
				wrongCodes = 0;
			}
			Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: false);
		}
		else if (flag && !guestPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectCodeChanged.resourcePath);
			guestPlayers.Add(rpc.player.userID);
			Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: true);
		}
	}

	void ISprayCallback.OnReskinned(BasePlayer byPlayer)
	{
		hasCode = code.Length > 0;
		hasGuestCode = guestCode.Length > 0;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved11, b: false);
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class CollectableEasterEgg : BaseEntity, INotifyLOD
{
	public Transform artwork;

	public float bounceRange = 0.2f;

	public float bounceSpeed = 1f;

	public GameObjectRef pickupEffect;

	public ItemDefinition itemToGive;

	public Renderer vfx;

	[NonSerialized]
	public ulong ownerUserID;

	private float lastPickupStartTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CollectableEasterEgg.OnRpcMessage", 0);
		try
		{
			if (rpc == 2436818324u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_PickUp "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_PickUp", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2436818324u, "RPC_PickUp", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_PickUp(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_PickUp");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2243088389u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_StartPickUp "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_StartPickUp", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2243088389u, "RPC_StartPickUp", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_StartPickUp(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_StartPickUp");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		int num = Random.Range(0, 3);
		SetFlag(Flags.Reserved1, num == 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, num == 1, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, num == 2, recursive: false, networkupdate: false);
		base.ServerInit();
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_StartPickUp(RPCMessage msg)
	{
		if (!((Object)(object)msg.player == (Object)null))
		{
			lastPickupStartTime = Time.realtimeSinceStartup;
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_PickUp(RPCMessage msg)
	{
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null)
		{
			return;
		}
		float num = Time.realtimeSinceStartup - lastPickupStartTime;
		if (!Object.op_Implicit((Object)(object)(msg.player.GetHeldEntity() as EasterBasket)) && (num > 2f || num < 0.8f))
		{
			return;
		}
		if (Object.op_Implicit((Object)(object)EggHuntEvent.serverEvent))
		{
			if (!EggHuntEvent.serverEvent.IsEventActive() || Interface.CallHook("OnEventCollectablePickup", (object)msg.player, (object)this) != null)
			{
				return;
			}
			EggHuntEvent.serverEvent.OnEggCollected(msg.player, this);
			int iAmount = 1;
			msg.player.GiveItem(ItemManager.Create(itemToGive, iAmount, 0uL));
		}
		Effect.server.Run(pickupEffect.resourcePath, ((Component)this).transform.position + Vector3.up * 0.3f, Vector3.up);
		Kill();
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class CollectibleEntity : BaseEntity, IPrefabPreProcess
{
	public static readonly Phrase EatTitle = new Phrase("eat", "Eat");

	public Phrase itemName;

	public ItemAmount[] itemList;

	public GameObjectRef pickupEffect;

	public float xpScale = 1f;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CollectibleEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 2778075470u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Pickup "));
				}
				TimeWarning val2 = TimeWarning.New("Pickup", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2778075470u, "Pickup", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Pickup(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Pickup");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3528769075u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - PickupEat "));
				}
				TimeWarning val2 = TimeWarning.New("PickupEat", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3528769075u, "PickupEat", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							PickupEat(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in PickupEat");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsFood(bool checkConsumeMod = false)
	{
		for (int i = 0; i < itemList.Length; i++)
		{
			if (itemList[i].itemDef.category == ItemCategory.Food && (!checkConsumeMod || (Object)(object)((Component)itemList[i].itemDef).GetComponent<ItemModConsume>() != (Object)null))
			{
				return true;
			}
		}
		return false;
	}

	public void DoPickup(BasePlayer reciever, bool eat = false)
	{
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		if (itemList == null || Interface.CallHook("OnCollectiblePickup", (object)this, (object)reciever, (object)eat) != null)
		{
			return;
		}
		float num = (((Object)(object)reciever.modifiers != (Object)null) ? reciever.modifiers.GetValue(Modifier.ModifierType.Collectible_DoubleYield) : 0f);
		bool flag = num != 0f && Random.value < num;
		ItemAmount[] array = itemList;
		foreach (ItemAmount itemAmount in array)
		{
			if ((Object)(object)reciever != (Object)null && reciever.IsInTutorial && itemAmount.ignoreInTutorial)
			{
				continue;
			}
			Item item = ItemManager.Create(itemAmount.itemDef, flag ? ((int)itemAmount.amount * 2) : ((int)itemAmount.amount), 0uL);
			if (item == null)
			{
				continue;
			}
			item.SetItemOwnership(reciever, ItemOwnershipPhrases.GatheredPhrase);
			if (eat && item.info.category == ItemCategory.Food && (Object)(object)reciever != (Object)null)
			{
				ItemModConsume component = ((Component)item.info).GetComponent<ItemModConsume>();
				if ((Object)(object)component != (Object)null)
				{
					component.DoAction(item, reciever);
					continue;
				}
			}
			if (Object.op_Implicit((Object)(object)reciever))
			{
				Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);
				Interface.CallHook("OnCollectiblePickedup", (object)this, (object)reciever, (object)item);
				reciever.GiveItem(item, GiveItemReason.ResourceHarvested);
			}
			else
			{
				item.Drop(((Component)this).transform.position + Vector3.up * 0.5f, Vector3.up);
			}
		}
		itemList = null;
		if (pickupEffect.isValid)
		{
			Effect.server.Run(pickupEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up);
		}
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(reciever, ((Component)this).transform.position);
		}
		Kill();
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			DoPickup(msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void PickupEat(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			DoPickup(msg.player, eat: true);
		}
	}

	public bool HasItem(ItemDefinition def)
	{
		ItemAmount[] array = itemList;
		for (int i = 0; i < array.Length; i++)
		{
			if ((Object)(object)array[i].itemDef == (Object)(object)def)
			{
				return true;
			}
		}
		return false;
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (serverside)
		{
			preProcess.RemoveComponent((Component)(object)((Component)this).GetComponent<Collider>());
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class CommandBlock : IOEntity
{
	public GameObjectRef commandPanelPrefab;

	[HideInInspector]
	public string currentCommand;

	private int currentPower;

	private ulong lastPlayerID;

	private static readonly Phrase disabledErrorPhrase = new Phrase("commandblock.disabled.error", "Command blocks are currently disabled");

	[ServerVar(Help = "Can command blocks execute commands")]
	public static bool commands_enabled = false;

	[ServerVar(Help = "If enabled, commands from command blocks will run using the last player who set them, allowing for a wider range of commands to be used")]
	public static bool use_player = false;

	[ServerVar(Help = "Print a log message when a command block is executed")]
	public static bool log_executions = true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CommandBlock.OnRpcMessage", 0);
		try
		{
			if (rpc == 1558722905 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetCommand "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetCommand", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1558722905u, "RPC_SetCommand", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1558722905u, "RPC_SetCommand", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_SetCommand(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_SetCommand");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1052196345 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestOpenPanel "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestOpenPanel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_RequestOpenPanel(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_RequestOpenPanel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.commandBlock != null)
		{
			currentCommand = info.msg.commandBlock.currentCommand;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if (info.msg.commandBlock == null)
			{
				info.msg.commandBlock = Pool.Get<CommandBlock>();
			}
			info.msg.commandBlock.currentCommand = currentCommand;
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		base.IOStateChanged(inputAmount, inputSlot);
		if (!commands_enabled)
		{
			currentPower = inputAmount;
			return;
		}
		if (inputAmount == 0 || currentPower > 0)
		{
			currentPower = inputAmount;
			return;
		}
		if (string.IsNullOrEmpty(currentCommand))
		{
			currentPower = inputAmount;
			return;
		}
		if (log_executions)
		{
			Debug.Log((object)("Executing \"" + currentCommand + "\" via CommandBlock"));
		}
		Option val = Option.Server;
		if (use_player)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(lastPlayerID);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.Connection != null)
			{
				Option server = Option.Server;
				val = ((Option)(ref server)).FromConnection(basePlayer.Connection);
			}
		}
		ConsoleSystem.Run(val, currentCommand, Array.Empty<object>());
		currentPower = inputAmount;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_RequestOpenPanel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && (player.IsAdmin || player.IsDeveloper))
		{
			if (!commands_enabled)
			{
				player.ShowToast(GameTip.Styles.Error, disabledErrorPhrase, true);
			}
			ClientRPC(RpcTarget.Player("CLIENT_OpenPanel", player), currentCommand);
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_SetCommand(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && (player.IsAdmin || player.IsDeveloper))
		{
			string text = msg.read.String(256, false);
			currentCommand = text;
			lastPlayerID = player.userID.Get();
		}
	}
}


using System;
using Network;
using UnityEngine;

public class CommunityEntity : PointEntity
{
	private class Countdown : MonoBehaviour
	{
		public enum TimerFormat
		{
			None,
			SecondsHundreth,
			MinutesSeconds,
			MinutesSecondsHundreth,
			HoursMinutes,
			HoursMinutesSeconds,
			HoursMinutesSecondsMilliseconds,
			HoursMinutesSecondsTenths,
			DaysHoursMinutes,
			DaysHoursMinutesSeconds,
			Custom
		}

		public string command = "";

		public float endTime;

		public float startTime;

		public float step = 1f;

		public float interval = 1f;

		public TimerFormat timerFormat;

		public string numberFormat = "0.####";

		public bool destroyIfDone = true;
	}

	private class FadeOut : MonoBehaviour
	{
		public float duration;
	}

	public static CommunityEntity ServerInstance;

	public static CommunityEntity ClientInstance;

	public GameObject[] OverallPanels;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CommunityEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		if (base.isServer)
		{
			ServerInstance = this;
		}
		else
		{
			ClientInstance = this;
		}
		base.InitShared();
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer)
		{
			ServerInstance = null;
		}
		else
		{
			ClientInstance = null;
		}
	}
}


using UnityEngine;

private class Countdown : MonoBehaviour
{
	public enum TimerFormat
	{
		None,
		SecondsHundreth,
		MinutesSeconds,
		MinutesSecondsHundreth,
		HoursMinutes,
		HoursMinutesSeconds,
		HoursMinutesSecondsMilliseconds,
		HoursMinutesSecondsTenths,
		DaysHoursMinutes,
		DaysHoursMinutesSeconds,
		Custom
	}

	public string command = "";

	public float endTime;

	public float startTime;

	public float step = 1f;

	public float interval = 1f;

	public TimerFormat timerFormat;

	public string numberFormat = "0.####";

	public bool destroyIfDone = true;
}


public enum TimerFormat
{
	None,
	SecondsHundreth,
	MinutesSeconds,
	MinutesSecondsHundreth,
	HoursMinutes,
	HoursMinutesSeconds,
	HoursMinutesSecondsMilliseconds,
	HoursMinutesSecondsTenths,
	DaysHoursMinutes,
	DaysHoursMinutesSeconds,
	Custom
}


using UnityEngine;

private class FadeOut : MonoBehaviour
{
	public float duration;
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class CompoundBowWeapon : BowWeapon
{
	public float stringHoldDurationMax = 3f;

	public float stringBonusDamage = 1f;

	public float stringBonusDistance = 0.5f;

	public float stringBonusVelocity = 1f;

	public float movementPenaltyRampUpTime = 0.5f;

	public float conditionLossPerSecondHeld = 1f;

	public float conditionLossHeldDelay = 3f;

	public SoundDefinition chargeUpSoundDef;

	public SoundDefinition stringHeldSoundDef;

	public SoundDefinition drawFinishSoundDef;

	private Sound chargeUpSound;

	private Sound stringHeldSound;

	protected float movementPenalty;

	internal float stringHoldTimeStart;

	protected float conditionLossCheckTickRate = 0.5f;

	protected float serverMovementCheckTickRate = 0.1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CompoundBowWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 618693016 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_StringHoldStatus "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_StringHoldStatus", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_StringHoldStatus(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_StringHoldStatus");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void UpdateMovementPenalty(float delta)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		bool flag = false;
		if (base.isServer)
		{
			if ((Object)(object)ownerPlayer == (Object)null)
			{
				return;
			}
			flag = ownerPlayer.estimatedSpeed > 0.1f;
		}
		if (flag)
		{
			movementPenalty += delta * (1f / movementPenaltyRampUpTime);
		}
		else
		{
			movementPenalty -= delta * (1f / stringHoldDurationMax);
		}
		movementPenalty = Mathf.Clamp01(movementPenalty);
	}

	public void UpdateConditionLoss()
	{
		if (stringHoldTimeStart != 0f && Time.time - stringHoldTimeStart > conditionLossHeldDelay && GetStringBonusScale() > 0f)
		{
			GetOwnerItem()?.LoseCondition(conditionLossCheckTickRate * conditionLossPerSecondHeld);
		}
	}

	public void ServerMovementCheck()
	{
		UpdateMovementPenalty(serverMovementCheckTickRate);
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		if (IsDisabled())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ServerMovementCheck);
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateConditionLoss);
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ServerMovementCheck, 0f, serverMovementCheckTickRate);
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateConditionLoss, 0f, conditionLossCheckTickRate);
		}
	}

	[RPC_Server]
	public void RPC_StringHoldStatus(RPCMessage msg)
	{
		if (msg.read.Bit())
		{
			stringHoldTimeStart = Time.time;
		}
		else
		{
			stringHoldTimeStart = 0f;
		}
	}

	public override void DidAttackServerside()
	{
		base.DidAttackServerside();
		stringHoldTimeStart = 0f;
	}

	public float GetLastPlayerMovementTime()
	{
		_ = base.isServer;
		return 0f;
	}

	public float GetStringBonusScale()
	{
		if (stringHoldTimeStart == 0f)
		{
			return 0f;
		}
		return Mathf.Clamp01(Mathf.Clamp01((Time.time - stringHoldTimeStart) / stringHoldDurationMax) - movementPenalty);
	}

	public override float GetDamageScale(bool getMax = false)
	{
		float num = (getMax ? 1f : GetStringBonusScale());
		return damageScale + stringBonusDamage * num;
	}

	public override float GetDistanceScale(bool getMax = false)
	{
		float num = (getMax ? 1f : GetStringBonusScale());
		return distanceScale + stringBonusDistance * num;
	}

	public override float GetProjectileVelocityScale(bool getMax = false)
	{
		float num = (getMax ? 1f : GetStringBonusScale());
		return projectileVelocityScale + stringBonusVelocity * num;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Network.Visibility;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class ComputerStation : BaseMountable
{
	public const Flags Flag_HasFullControl = Flags.Reserved2;

	[Header("Computer")]
	public GameObjectRef menuPrefab;

	public ComputerMenu computerMenu;

	public EntityRef currentlyControllingEnt;

	public List<string> controlBookmarks = new List<string>();

	public Transform leftHandIKPosition;

	public Transform rightHandIKPosition;

	public SoundDefinition turnOnSoundDef;

	public SoundDefinition turnOffSoundDef;

	public SoundDefinition onLoopSoundDef;

	public bool isStatic;

	public float autoGatherRadius;

	public ulong currentPlayerID;

	public float nextAddTime;

	public static readonly char[] BookmarkSplit = new char[1] { ';' };

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ComputerStation.OnRpcMessage", 0);
		try
		{
			if (rpc == 481778085 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AddBookmark "));
				}
				TimeWarning val2 = TimeWarning.New("AddBookmark", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						AddBookmark(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in AddBookmark");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 552248427 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BeginControllingBookmark "));
				}
				TimeWarning val2 = TimeWarning.New("BeginControllingBookmark", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						BeginControllingBookmark(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in BeginControllingBookmark");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2498687923u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DeleteBookmark "));
				}
				TimeWarning val2 = TimeWarning.New("DeleteBookmark", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg4 = rPCMessage;
						DeleteBookmark(msg4);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex3)
				{
					Debug.LogException(ex3);
					player.Kick("RPC Error in DeleteBookmark");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2139261430 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_DisconnectControl "));
				}
				TimeWarning val2 = TimeWarning.New("Server_DisconnectControl", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg5 = rPCMessage;
						Server_DisconnectControl(msg5);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex4)
				{
					Debug.LogException(ex4);
					player.Kick("RPC Error in Server_DisconnectControl");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool AllowPings()
	{
		BaseEntity baseEntity = currentlyControllingEnt.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity is IRemoteControllable { CanPing: not false })
		{
			return true;
		}
		return false;
	}

	public static bool IsValidIdentifier(string str)
	{
		if (string.IsNullOrEmpty(str))
		{
			return false;
		}
		if (str.Length > 32)
		{
			return false;
		}
		return StringEx.IsAlphaNumeric(str);
	}

	public override void DestroyShared()
	{
		if (base.isServer && Object.op_Implicit((Object)(object)GetMounted()))
		{
			StopControl(GetMounted());
		}
		base.DestroyShared();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)GatherStaticCameras, 5f);
	}

	public void GatherStaticCameras()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoadingSave)
		{
			((FacepunchBehaviour)this).Invoke((Action)GatherStaticCameras, 1f);
		}
		else
		{
			if (!isStatic || !(autoGatherRadius > 0f))
			{
				return;
			}
			List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
			Vis.Entities(((Component)this).transform.position, autoGatherRadius, list, 256, (QueryTriggerInteraction)1);
			foreach (BaseEntity item in list)
			{
				IRemoteControllable component = ((Component)item).GetComponent<IRemoteControllable>();
				if (component != null)
				{
					CCTV_RC component2 = ((Component)item).GetComponent<CCTV_RC>();
					if (!((Object)(object)component2 == (Object)null) && component2.IsStatic() && !controlBookmarks.Contains(component.GetIdentifier()))
					{
						ForceAddBookmark(component.GetIdentifier());
					}
				}
			}
			Pool.FreeUnmanaged<BaseEntity>(ref list);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		GatherStaticCameras();
	}

	public void StopControl(BasePlayer ply)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			if (Interface.CallHook("OnBookmarkControlEnd", (object)this, (object)ply, (object)baseEntity) != null)
			{
				return;
			}
			((Component)baseEntity).GetComponent<IRemoteControllable>().StopControl(new CameraViewerId(currentPlayerID, 0L));
		}
		if (Object.op_Implicit((Object)(object)ply))
		{
			ply.net.SwitchSecondaryGroup((Group)null);
			ply.SetRcEntityPosition(null);
		}
		currentlyControllingEnt.uid = default(NetworkableId);
		currentPlayerID = 0uL;
		SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate();
		SendControlBookmarks(ply);
		((FacepunchBehaviour)this).CancelInvoke((Action)ControlCheck);
		Interface.CallHook("OnBookmarkControlEnded", (object)this, (object)ply, (object)baseEntity);
		((FacepunchBehaviour)this).CancelInvoke((Action)CheckCCTVAchievement);
	}

	public bool IsPlayerAdmin(BasePlayer player)
	{
		return (Object)(object)player == (Object)(object)GetMounted();
	}

	[RPC_Server]
	public void DeleteBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player) || isStatic)
		{
			return;
		}
		string text = msg.read.String(256, false);
		if (IsValidIdentifier(text) && controlBookmarks.Contains(text) && Interface.CallHook("OnBookmarkDelete", (object)this, (object)player, (object)text) == null)
		{
			controlBookmarks.Remove(text);
			SendControlBookmarks(player);
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			IRemoteControllable remoteControllable = default(IRemoteControllable);
			if ((Object)(object)baseEntity != (Object)null && ((Component)baseEntity).TryGetComponent<IRemoteControllable>(ref remoteControllable) && remoteControllable.GetIdentifier() == text)
			{
				StopControl(player);
			}
		}
	}

	[RPC_Server]
	public void Server_DisconnectControl(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (IsPlayerAdmin(player))
		{
			StopControl(player);
		}
	}

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String(256, false);
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if ((Object)(object)ent == (Object)null)
		{
			Debug.LogWarning((object)("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen"));
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(((Component)this).transform.position, ((Component)ent).transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", (object)this, (object)player, (object)text, (object)remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				IRemoteControllable component = ((Component)baseEntity).GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", (object)this, (object)player, (object)component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			player.SetRcEntityPosition(((Component)ent).transform.position);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CheckCCTVAchievement, 1f, 3f);
			}
			Interface.CallHook("OnBookmarkControlStarted", (object)this, (object)player, (object)text, (object)remoteControllable);
			((FacepunchBehaviour)this).InvokeRepeating((Action)ControlCheck, 0f, 0f);
		}
	}

	public void CheckCCTVAchievement()
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer mounted = GetMounted();
		if (!((Object)(object)mounted != (Object)null))
		{
			return;
		}
		BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
		if (!((Object)(object)baseEntity != (Object)null) || !(baseEntity is CCTV_RC cCTV_RC))
		{
			return;
		}
		foreach (Connection subscriber in mounted.net.secondaryGroup.subscribers)
		{
			if (!subscriber.active)
			{
				continue;
			}
			BasePlayer basePlayer = subscriber.player as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null))
			{
				Vector3 val = basePlayer.CenterPoint();
				Vector3 val2 = val - cCTV_RC.pitch.position;
				float num = Vector3.Dot(((Vector3)(ref val2)).normalized, cCTV_RC.pitch.forward);
				Vector3 val3 = cCTV_RC.pitch.InverseTransformPoint(val);
				if (num > 0.6f && ((Vector3)(ref val3)).magnitude < 10f)
				{
					mounted.GiveAchievement("BIG_BROTHER");
					((FacepunchBehaviour)this).CancelInvoke((Action)CheckCCTVAchievement);
					break;
				}
			}
		}
	}

	public bool CanAddBookmark(BasePlayer player)
	{
		if (!IsPlayerAdmin(player))
		{
			return false;
		}
		if (isStatic)
		{
			return false;
		}
		if (Time.realtimeSinceStartup < nextAddTime)
		{
			return false;
		}
		if (controlBookmarks.Count > 3)
		{
			player.ChatMessage("Too many bookmarks, delete some");
			return false;
		}
		return true;
	}

	public void ForceAddBookmark(string identifier)
	{
		if (controlBookmarks.Count >= 128 || !IsValidIdentifier(identifier) || controlBookmarks.Contains(identifier))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(identifier);
		if (remoteControllable != null)
		{
			if ((Object)(object)remoteControllable.GetEnt() == (Object)null)
			{
				Debug.LogWarning((object)("RC identifier " + identifier + " was found but has a null or destroyed entity, this should never happen"));
			}
			else
			{
				controlBookmarks.Add(identifier);
			}
		}
	}

	[RPC_Server]
	public void AddBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player) || isStatic)
		{
			return;
		}
		if (Time.realtimeSinceStartup < nextAddTime)
		{
			player.ChatMessage("Slow down...");
			return;
		}
		if (controlBookmarks.Count >= 128)
		{
			player.ChatMessage("Too many bookmarks, delete some");
			return;
		}
		nextAddTime = Time.realtimeSinceStartup + 1f;
		string text = msg.read.String(256, false);
		if (Interface.CallHook("OnBookmarkAdd", (object)this, (object)player, (object)text) == null)
		{
			ForceAddBookmark(text);
			SendControlBookmarks(player);
		}
	}

	public void ControlCheck()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		BaseEntity baseEntity = currentlyControllingEnt.Get(base.isServer);
		BasePlayer mounted = GetMounted();
		if (Object.op_Implicit((Object)(object)baseEntity) && Object.op_Implicit((Object)(object)mounted))
		{
			IRemoteControllable component = ((Component)baseEntity).GetComponent<IRemoteControllable>();
			if (component != null && component.CanControl(mounted.userID) && Vector3.Distance(((Component)this).transform.position, ((Component)baseEntity).transform.position) < component.MaxRange)
			{
				flag = true;
				mounted.net.SwitchSecondaryGroup(baseEntity.net.group);
				mounted.SetRcEntityPosition(((Component)baseEntity).transform.position);
			}
		}
		if (!flag)
		{
			StopControl(mounted);
		}
	}

	public string GenerateControlBookmarkString()
	{
		return string.Join(";", controlBookmarks);
	}

	public void SendControlBookmarks(BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null))
		{
			string text = GenerateControlBookmarkString();
			if (Interface.CallHook("OnBookmarksSendControl", (object)this, (object)player, (object)text) == null)
			{
				ClientRPC(RpcTarget.Player("ReceiveBookmarks", player), text);
			}
		}
	}

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		BasePlayer mounted = GetMounted();
		if (Object.op_Implicit((Object)(object)mounted))
		{
			SendControlBookmarks(mounted);
		}
		SetFlag(Flags.On, b: true);
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		StopControl(player);
		SetFlag(Flags.On, b: false);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (HasFlag(Flags.Reserved2) && currentlyControllingEnt.IsValid(serverside: true) && Interface.CallHook("OnBookmarkInput", (object)this, (object)player, (object)inputState) == null)
		{
			((Component)currentlyControllingEnt.Get(serverside: true)).GetComponent<IRemoteControllable>().UserInput(inputState, new CameraViewerId(player.userID, 0L));
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.ioEntity = Pool.Get<IOEntity>();
			info.msg.ioEntity.genericEntRef1 = currentlyControllingEnt.uid;
		}
		else
		{
			info.msg.computerStation = Pool.Get<ComputerStation>();
			info.msg.computerStation.bookmarks = GenerateControlBookmarkString();
		}
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (CanPlayerSeeMountAnchor(player))
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	private bool CanPlayerSeeMountAnchor(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		return !GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position + Vector3.up * 0.3f, 0.05f, 2097152, (QueryTriggerInteraction)0);
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (!info.fromDisk)
		{
			if (info.msg.ioEntity != null)
			{
				currentlyControllingEnt.uid = info.msg.ioEntity.genericEntRef1;
			}
		}
		else
		{
			if (info.msg.computerStation == null)
			{
				return;
			}
			string[] array = info.msg.computerStation.bookmarks.Split(BookmarkSplit, StringSplitOptions.RemoveEmptyEntries);
			foreach (string text in array)
			{
				if (IsValidIdentifier(text))
				{
					controlBookmarks.Add(text);
				}
			}
		}
	}
}


using System;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class ConfettiCannon : DecayEntity, IIgniteable
{
	public float InitialBlastDelay = 1f;

	public float BlastCooldown = 3f;

	public GameObjectRef ConfettiPrefab;

	public Transform ConfettiPrefabSpawnPoint;

	public const Flags Ignited = Flags.OnFire;

	public float DamagePerBlast = 3f;

	private Action blastAction;

	private Action clearBusy;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ConfettiCannon.OnRpcMessage", 0);
		try
		{
			if (rpc == 2995985310u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Blast "));
				}
				TimeWarning val2 = TimeWarning.New("Blast", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2995985310u, "Blast", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Blast(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Blast");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void Blast(RPCMessage msg)
	{
		if (!IsBusy())
		{
			SetFlag(Flags.Busy, b: true);
			SetFlag(Flags.OnFire, b: true);
			if (blastAction == null)
			{
				blastAction = TriggerBlast;
			}
			if (clearBusy == null)
			{
				clearBusy = ClearBusy;
			}
			((FacepunchBehaviour)this).Invoke(blastAction, InitialBlastDelay);
			((FacepunchBehaviour)this).Invoke(clearBusy, InitialBlastDelay + BlastCooldown);
		}
	}

	private void TriggerBlast()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (ConfettiPrefab.isValid && (Object)(object)ConfettiPrefabSpawnPoint != (Object)null)
		{
			Effect.server.Run(ConfettiPrefab.resourcePath, ConfettiPrefabSpawnPoint.position, ConfettiPrefabSpawnPoint.forward);
		}
		SetFlag(Flags.OnFire, b: false);
		Hurt(DamagePerBlast, DamageType.Generic, null, useProtection: false);
	}

	private void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		ClearBusy();
	}

	public void Ignite(Vector3 fromPos)
	{
		Blast(default(RPCMessage));
	}

	public bool CanIgnite()
	{
		return !IsBusy();
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer && info.damageTypes.Has(DamageType.Heat))
		{
			Blast(default(RPCMessage));
		}
	}
}


using System;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class ConnectedSpeaker : IOEntity
{
	public AudioSource SoundSource;

	private EntityRef<IOEntity> connectedTo;

	public VoiceProcessor VoiceProcessor;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ConnectedSpeaker.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		base.OnFlagsChanged(old, next);
		if (!base.isServer || old.HasFlag(Flags.Reserved8) == next.HasFlag(Flags.Reserved8))
		{
			return;
		}
		if (next.HasFlag(Flags.Reserved8))
		{
			IAudioConnectionSource connectionSource = GetConnectionSource(this, BoomBox.BacktrackLength);
			if (connectionSource != null)
			{
				ClientRPC(RpcTarget.NetworkGroup("Client_PlayAudioFrom"), connectionSource.ToEntity().net.ID);
				connectedTo.Set(connectionSource.ToEntity());
			}
		}
		else if (connectedTo.IsSet)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_StopPlayingAudio"), connectedTo.uid);
			connectedTo.Set(null);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.connectedSpeaker != null)
		{
			connectedTo.uid = info.msg.connectedSpeaker.connectedTo;
		}
	}

	private IAudioConnectionSource GetConnectionSource(IOEntity entity, int depth)
	{
		if (depth <= 0)
		{
			return null;
		}
		IOSlot[] array = entity.inputs;
		for (int i = 0; i < array.Length; i++)
		{
			IOEntity iOEntity = array[i].connectedTo.Get(base.isServer);
			if ((Object)(object)iOEntity == (Object)(object)this)
			{
				return null;
			}
			if ((Object)(object)iOEntity != (Object)null && iOEntity is IAudioConnectionSource result)
			{
				return result;
			}
			if ((Object)(object)iOEntity != (Object)null)
			{
				IAudioConnectionSource connectionSource = GetConnectionSource(iOEntity, depth - 1);
				if (connectionSource != null)
				{
					return connectionSource;
				}
			}
		}
		return null;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.connectedSpeaker == null)
		{
			info.msg.connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		}
		info.msg.connectedSpeaker.connectedTo = connectedTo.uid;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ContainerCorpse : ConstructableEntity
{
	[Header("Container Corpse")]
	public Collider mainCollider;

	public const Flags Flag_Empty = Flags.Reserved13;

	private CodeLock codelockData;

	private KeyLock keylockData;

	private ulong lockOwnerId;

	private BuildingPrivlidge _cachedTc;

	private float _cacheTimeout;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ContainerCorpse.OnRpcMessage", 0);
		try
		{
			if (rpc == 1735184033 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestOwnerData "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestOwnerData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1735184033u, "SERVER_RequestOwnerData", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1735184033u, "SERVER_RequestOwnerData", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_RequestOwnerData(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_RequestOwnerData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static bool IsValidPointForEntity(uint prefabID, Vector3 point, Quaternion rotation, BaseEntity ignoredEntity = null, int mask = 536870912)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		DeployVolume[] array = null;
		array = PrefabAttribute.server.FindAll<DeployVolume>(prefabID);
		List<Type> list = Pool.Get<List<Type>>();
		list.Add(typeof(DebrisEntity));
		if (DeployVolume.Check(point, rotation, array, list, DeployVolume.TypeFilterMode.Ignore, ignoredEntity, mask))
		{
			return false;
		}
		Socket_Base[] array2 = PrefabAttribute.server.FindAll<Socket_Base>(prefabID);
		Construction.Target target = new Construction.Target
		{
			position = point,
			rotation = ((Quaternion)(ref rotation)).eulerAngles,
			onTerrain = (Mathf.Abs(TerrainMeta.HeightMap.GetHeight(point) - point.y) < 0.05f)
		};
		Construction.Placement placement = new Construction.Placement(target)
		{
			position = target.position,
			rotation = rotation
		};
		Socket_Base[] array3 = array2;
		foreach (Socket_Base socket_Base in array3)
		{
			if (socket_Base.male && !socket_Base.CheckSocketMods(ref placement))
			{
				return false;
			}
		}
		return true;
	}

	public bool InValidPosition()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		int mask = (IsNearlyBuilt() ? 537001984 : 536870912);
		return IsValidPointForEntity(entityToSpawn.resourceID, ((Component)this).transform.position, ((Component)this).transform.rotation, this, mask);
	}

	public override bool CanPickup(BasePlayer player)
	{
		bool flag = false;
		if (base.isServer)
		{
			flag = IsOwner(player);
		}
		if (flag && pickup.enabled)
		{
			if (pickup.requireHammer)
			{
				return player.IsHoldingEntity<Hammer>();
			}
			return true;
		}
		return false;
	}

	public override bool HasSlot(Slot slot)
	{
		if (slot == Slot.Lock)
		{
			return false;
		}
		return base.HasSlot(slot);
	}

	public override void OnInventoryFirstCreated(ItemContainer container)
	{
		base.OnInventoryFirstCreated(container);
		base.inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
	}

	public void TakeFrom(ItemContainer[] source, float savePercent = 0f)
	{
		DroppedItemContainer.TakeFractionOfItems(source, base.inventory, savePercent);
		base.inventory.capacity = base.inventory.itemList.Count;
	}

	protected override bool CanRepair(BasePlayer player)
	{
		if (!RunBuildingChecks(player))
		{
			return false;
		}
		bool flag = IsOwner(player);
		if (flag && !InValidPosition())
		{
			if ((Object)(object)DeployVolume.LastDeployHit != (Object)null)
			{
				BaseEntity baseEntity = DeployVolume.LastDeployHit.ToBaseEntity();
				if ((Object)(object)baseEntity != (Object)null)
				{
					player.ShowBlockedByEntityToast(baseEntity, Construction.lastPlacementError);
				}
			}
			else
			{
				player.ShowToast(GameTip.Styles.Error, Construction.lastPlacementError, false);
			}
			return false;
		}
		if (flag)
		{
			return base.CanRepair(player);
		}
		return false;
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (isLootable)
		{
			return IsOwner(player);
		}
		return false;
	}

	private bool RunBuildingChecks(BasePlayer player)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		GameObject obj = entityToSpawn.Get();
		BaseEntity baseEntity = ((obj != null) ? obj.GetComponent<BaseEntity>() : null);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Debug.LogError((object)("Prefab not found for '" + entityToSpawn.resourcePath + "'"));
			return false;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(baseEntity.prefabID);
		if (construction == null)
		{
			Debug.LogError((object)("Construction not found on '" + entityToSpawn.resourcePath + "'"));
			return false;
		}
		if (construction.isBuildingPrivilege)
		{
			BuildingPrivlidge componentInChildren = ((Component)this).GetComponentInChildren<BuildingPrivlidge>();
			if (!player.CanPlaceBuildingPrivilege(((Component)this).transform.position, ((Component)this).transform.rotation, construction.bounds, componentInChildren))
			{
				player.ShowToast(GameTip.Styles.Red_Normal, Phrase.op_Implicit("Can't stack building privileges"), false);
				return false;
			}
		}
		return true;
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityToSpawn.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
		if (HasParent())
		{
			baseEntity.SetParent(GetParentEntity(), worldPositionStays: true);
		}
		baseEntity.OwnerID = base.OwnerID;
		baseEntity.skinID = skinID;
		baseEntity.Spawn();
		if (baseEntity is StorageContainer storageContainer)
		{
			storageContainer.MoveAllInventoryItems(base.inventory);
		}
		else if (baseEntity is ContainerIOEntity containerIOEntity)
		{
			containerIOEntity.MoveAllInventoryItems(base.inventory);
		}
		if (baseEntity is BuildingPrivlidge buildingPrivlidge)
		{
			BuildingPrivlidge componentInChildren = ((Component)this).GetComponentInChildren<BuildingPrivlidge>();
			if ((Object)(object)componentInChildren == (Object)null)
			{
				Debug.LogError((object)("Can't copy auth list from corpse to TC: no BuildingPrivilege found in '" + base.PrefabName + "'"));
			}
			else
			{
				buildingPrivlidge.SetAuthListFrom(componentInChildren);
			}
		}
		if (baseEntity is DecayEntity decayEntity)
		{
			decayEntity.AttachToBuilding(null);
		}
		SpawnLock(baseEntity);
		Kill();
		baseEntity.SendNetworkUpdateImmediate();
		if (spawnEffect.isValid)
		{
			Effect.server.Run(spawnEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		}
	}

	public void SaveLock(BaseLock lockEntity)
	{
		SaveInfo info = default(SaveInfo);
		info.forDisk = true;
		Entity val = (info.msg = Pool.Get<Entity>());
		try
		{
			lockEntity.Save(info);
			CodeLock codeLock = info.msg.codeLock;
			codelockData = ((codeLock != null) ? codeLock.Copy() : null);
			KeyLock keyLock = info.msg.keyLock;
			keylockData = ((keyLock != null) ? keyLock.Copy() : null);
			lockOwnerId = lockEntity.OwnerID;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SpawnLock(BaseEntity parent)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		BaseEntity baseEntity;
		if (codelockData != null)
		{
			baseEntity = GameManager.server.CreateEntity("Assets/Prefabs/Locks/Keypad/lock.code.prefab") as CodeLock;
			flag = codelockData.pv != null && !string.IsNullOrEmpty(codelockData.pv.code);
		}
		else
		{
			if (keylockData == null)
			{
				return;
			}
			baseEntity = GameManager.server.CreateEntity("Assets/Prefabs/Locks/keylock/lock.key.prefab") as KeyLock;
			flag = true;
		}
		baseEntity.SetParent(parent, parent.GetSlotAnchorName(Slot.Lock));
		baseEntity.OwnerID = lockOwnerId;
		if (baseEntity is CodeLock codeLock && codelockData != null)
		{
			codeLock.LoadCodelockPrivateData(codelockData);
		}
		else if (baseEntity is KeyLock keyLock && keylockData != null)
		{
			keyLock.LoadKeylockData(keylockData);
		}
		baseEntity.SetFlag(Flags.Locked, flag, recursive: false, networkupdate: false);
		baseEntity.Spawn();
		parent.SetSlot(Slot.Lock, baseEntity);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (base.inventory.IsEmpty())
		{
			SetFlag(Flags.Reserved13, b: true);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	private void SERVER_RequestOwnerData(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && IsOwner(player))
		{
			SendOwnerData(player);
		}
	}

	public virtual void SendOwnerData(BasePlayer player)
	{
		ClientRPC(RpcTarget.Player("CLIENT_ReceiveOwnerData", player));
	}

	public bool IsOwner(BasePlayer player)
	{
		if ((ulong)player.userID == base.OwnerID)
		{
			return true;
		}
		BuildingPrivlidge cachedTc = GetCachedTc();
		if ((Object)(object)cachedTc != (Object)null && cachedTc.IsAuthed(player))
		{
			return true;
		}
		return false;
	}

	private BuildingPrivlidge GetCachedTc()
	{
		if ((Object)(object)_cachedTc != (Object)null && _cachedTc.IsDestroyed)
		{
			_cachedTc = null;
		}
		if ((Object)(object)_cachedTc == (Object)null || Time.realtimeSinceStartup > _cacheTimeout)
		{
			_cachedTc = null;
			BuildingManager.Building building = GetBuilding();
			if (building != null)
			{
				_cachedTc = building.GetDominatingBuildingPrivilege();
			}
			if ((Object)(object)_cachedTc == (Object)null)
			{
				return GetNearestBuildingPrivilege(cached: true, 3f);
			}
			_cacheTimeout = Time.realtimeSinceStartup + 3f;
		}
		return _cachedTc;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if (base.inventory != null)
			{
				info.msg.storageBox = Pool.Get<StorageBox>();
				info.msg.storageBox.contents = base.inventory.Save();
			}
			ContainerCorpseData val = Pool.Get<ContainerCorpseData>();
			info.msg.containerCorpse = val;
			val.codeLock = codelockData;
			val.keyLock = keylockData;
			val.lockOwnerId = lockOwnerId;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.storageBox != null)
		{
			base.inventory.Load(info.msg.storageBox.contents);
			base.inventory.capacity = info.msg.storageBox.contents.slots;
		}
		if (info.msg.containerCorpse != null)
		{
			CodeLock codeLock = info.msg.containerCorpse.codeLock;
			codelockData = ((codeLock != null) ? codeLock.Copy() : null);
			KeyLock keyLock = info.msg.containerCorpse.keyLock;
			keylockData = ((keyLock != null) ? keyLock.Copy() : null);
			lockOwnerId = info.msg.containerCorpse.lockOwnerId;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ContainerIOEntity : IOEntity, IItemContainerEntity, IIdealSlotEntity, ILootableEntity, IInventoryProvider, LootPanel.IHasLootPanel, IContainerSounds
{
	public ItemDefinition onlyAllowedItem;

	public ItemContainer.ContentsType allowedContents = ItemContainer.ContentsType.Generic;

	public int maxStackSize = 1;

	public int numSlots;

	public string lootPanelName = "generic";

	public Phrase panelTitle = new Phrase("loot", "Loot");

	public bool needsBuildingPrivilegeToUse;

	public bool requireAuthIfNotLocked;

	public bool isLootable = true;

	public bool isMonitorable;

	public bool dropsLoot;

	public float dropLootDestroyPercent;

	public bool dropFloats;

	public bool onlyOneUser;

	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	private ItemContainer _inventory;

	public Phrase LootPanelTitle => panelTitle;

	public ItemContainer inventory => _inventory;

	public Transform Transform => ((Component)this).transform;

	public bool DropsLoot => dropsLoot;

	public bool DropFloats => dropFloats;

	public float DestroyLootPercent
	{
		get
		{
			if (!ShouldDropDeployableCorpse(lastAttacker, lastDamage))
			{
				return dropLootDestroyPercent;
			}
			return 0f;
		}
	}

	public ulong LastLootedBy { get; set; }

	public BasePlayer LastLootedByPlayer { get; set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ContainerIOEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (!pickup.requireEmptyInv || _inventory == null || _inventory.itemList.Count == 0)
		{
			return base.CanPickup(player);
		}
		return false;
	}

	public override void ServerInit()
	{
		if (_inventory == null)
		{
			CreateInventory(giveUID: true);
			OnInventoryFirstCreated(_inventory);
		}
		base.ServerInit();
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Pool.Free<ItemContainer>(ref _inventory);
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		CreateInventory(giveUID: false);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (_inventory != null && !((ItemContainerId)(ref _inventory.uid)).IsValid)
		{
			_inventory.GiveUID();
		}
		SetFlag(Flags.Open, b: false);
	}

	public void CreateInventory(bool giveUID)
	{
		Debug.Assert(_inventory == null, "Double init of inventory!");
		_inventory = Pool.Get<ItemContainer>();
		_inventory.entityOwner = this;
		_inventory.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
		_inventory.SetOnlyAllowedItem(onlyAllowedItem);
		_inventory.maxStackSize = maxStackSize;
		_inventory.ServerInitialize(null, numSlots);
		if (giveUID)
		{
			_inventory.GiveUID();
		}
		_inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
		_inventory.onDirty += OnInventoryDirty;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if (_inventory != null)
			{
				info.msg.storageBox = Pool.Get<StorageBox>();
				info.msg.storageBox.contents = _inventory.Save();
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public virtual void OnInventoryFirstCreated(ItemContainer container)
	{
	}

	public virtual void OnItemAddedOrRemoved(Item item, bool added)
	{
	}

	protected virtual void OnInventoryDirty()
	{
	}

	public override void OnDied(HitInfo info)
	{
		DropItems();
		base.OnDied(info);
	}

	public void DropItems(BaseEntity initiator = null)
	{
		StorageContainer.DropItems(this, initiator);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (_inventory != null)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract())
			{
				PlayerOpenLoot(player, lootPanelName);
			}
		}
	}

	public virtual bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		if (!CanBeLooted(player))
		{
			return false;
		}
		BaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;
		if ((Object)(object)baseLock != (Object)null && !baseLock.OnTryToOpen(player))
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
			return false;
		}
		return true;
	}

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", (object)player, (object)this) != null)
		{
			return false;
		}
		if ((needsBuildingPrivilegeToUse || StorageContainer.ShouldRequireAuthIfNoCodelock(this, requireAuthIfNotLocked)) && !player.CanBuild())
		{
			return false;
		}
		if (needsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if ((onlyOneUser && IsOpen()) || IsTransferring())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, StorageContainer.LockedMessage, false);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = lootPanelName;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(_inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), panelToOpen);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", (object)player, (object)this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

	public bool ShouldDropItemsIndividually()
	{
		return false;
	}

	public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return -1;
	}

	public virtual ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return default(ItemContainerId);
	}

	public virtual void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
	}

	public void GetAllInventories(List<ItemContainer> list)
	{
		list.Add(inventory);
	}

	public override void OnDeployableCorpseSpawned(BaseEntity corpse)
	{
		base.OnDeployableCorpseSpawned(corpse);
		if (corpse is ContainerCorpse containerCorpse)
		{
			containerCorpse.TakeFrom(new ItemContainer[1] { inventory }, StorageContainer.corpseItemsSavedPercent);
		}
	}

	public bool MoveAllInventoryItems(ItemContainer from)
	{
		return StorageContainer.MoveAllInventoryItems(from, inventory);
	}

	public override bool HasSlot(Slot slot)
	{
		if (isMonitorable && slot == Slot.StorageMonitor)
		{
			return true;
		}
		return base.HasSlot(slot);
	}

	protected bool HasAttachedStorageAdaptor()
	{
		if (children == null)
		{
			return false;
		}
		foreach (BaseEntity child in children)
		{
			if (child is IndustrialStorageAdaptor)
			{
				return true;
			}
		}
		return false;
	}

	protected bool HasAttachedStorageMonitor()
	{
		if (children == null)
		{
			return false;
		}
		foreach (BaseEntity child in children)
		{
			if (child is StorageMonitor)
			{
				return true;
			}
		}
		return false;
	}

	public bool OccupiedCheck(BasePlayer player = null)
	{
		if ((Object)(object)player != (Object)null && (Object)(object)player.inventory.loot.entitySource == (Object)(object)this)
		{
			return true;
		}
		if (onlyOneUser)
		{
			return !IsOpen();
		}
		return true;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && info.msg.storageBox != null)
		{
			if (_inventory != null)
			{
				_inventory.Load(info.msg.storageBox.contents);
				_inventory.capacity = numSlots;
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using ConVar;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class CopyPasteEntity : PointEntity
{
	public static CopyPasteEntity ServerInstance;

	public const string ClientDirectory = "copypaste";

	public const string FileExtension = ".data";

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CopyPasteEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 2913956655u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Paste "));
				}
				TimeWarning val2 = TimeWarning.New("Paste", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage rpc2 = rPCMessage;
						Paste(rpc2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Paste");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static string MakeFilenameSafe(string input)
	{
		return Regex.Replace(input, "[^a-zA-Z0-9_\\-]", "");
	}

	public static string GetClientPath(string fileName)
	{
		return Path.Combine("copypaste", MakeFilenameSafe(fileName) + ".data");
	}

	[RPC_Server]
	public void Paste(RPCMessage rpc)
	{
		if (rpc.player.IsAdmin)
		{
			PasteRequest obj = rpc.read.Proto<PasteRequest>((PasteRequest)null);
			CopyPasteEntityInfo pasteData = obj.pasteData;
			CopyPaste.PasteOptions options = new CopyPaste.PasteOptions(obj);
			List<BaseEntity> list = CopyPaste.PasteEntities(pasteData, options, rpc.player.userID);
			rpc.player.ConsoleMessage($"Pasted {list.Count} entities");
		}
	}

	public void OnEnable()
	{
		if (base.isServer)
		{
			if ((Object)(object)ServerInstance != (Object)null)
			{
				Debug.LogError((object)"Major fuckup! CopyPasteEntity spawned twice, Contact Developers!");
				Object.Destroy((Object)(object)((Component)this).gameObject);
			}
			else
			{
				ServerInstance = this;
			}
		}
	}

	public void OnDestroy()
	{
		if (base.isServer)
		{
			ServerInstance = null;
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class CustomDoorManipulator : DoorManipulator
{
	public static Phrase pairAttemptPhrase = new Phrase("doorcontroller.unlock", "Door must be unlocked for pairing!");

	private int inputOpenAmount;

	private int inputCloseAmount;

	private DoorEffect delayedAction;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CustomDoorManipulator.OnRpcMessage", 0);
		try
		{
			if (rpc == 114855818 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_DoPair "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_DoPair", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(114855818u, "RPC_DoPair", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_DoPair(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_DoPair");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsPaired()
	{
		return (Object)(object)targetDoor != (Object)null;
	}

	public override void SetupInitialDoorConnection()
	{
		if (entityRef.IsValid(serverside: true) && !IsPaired())
		{
			Door component = ((Component)entityRef.Get(serverside: true)).GetComponent<Door>();
			SetTargetDoor(component);
		}
	}

	public override void SetTargetDoor(Door newTargetDoor)
	{
		targetDoor = newTargetDoor;
		SetFlag(Flags.On, (Object)(object)targetDoor != (Object)null);
		entityRef.Set(newTargetDoor);
	}

	public override void DoAction(DoorEffect action)
	{
		if (!IsPaired())
		{
			DoActionDoorMissing();
			return;
		}
		if (targetDoor.IsBusy())
		{
			delayedAction = action;
			((FacepunchBehaviour)this).Invoke((Action)DoDelayedAction, 1f);
			return;
		}
		switch (action)
		{
		case DoorEffect.Open:
			targetDoor.SetOpen(open: true);
			break;
		case DoorEffect.Close:
			targetDoor.SetOpen(open: false);
			break;
		}
	}

	private void DoDelayedAction()
	{
		DoAction(delayedAction);
	}

	public override void DoActionDoorMissing()
	{
		SetTargetDoor(null);
	}

	public override Door FindDoor(bool allowLocked = true)
	{
		if (parentEntity.Get(serverside: true) is Door result)
		{
			return result;
		}
		return null;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_DoPair(RPCMessage msg)
	{
		Door door = targetDoor;
		Door door2 = FindDoor();
		if ((Object)(object)door2 != (Object)null && (Object)(object)door2 != (Object)(object)door)
		{
			PairDoorAttempt(door2, msg.player);
		}
	}

	private void PairDoorAttempt(Door door, BasePlayer byPlayer)
	{
		if (door.GetPlayerLockPermission(byPlayer))
		{
			SetTargetDoor(door);
		}
		else
		{
			byPlayer.ShowToast(GameTip.Styles.Blue_Normal, pairAttemptPhrase, false);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		Door door = parent as Door;
		if ((Object)(object)door != (Object)null)
		{
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				PairDoorAttempt(door, deployedBy);
			}, 0.25f);
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			bool flag = currentEnergy != 0;
			base.UpdateFromInput(inputAmount, inputSlot);
			if (inputAmount == 0 && flag && inputOpenAmount == 0)
			{
				DoAction(DoorEffect.Close);
			}
			else if (inputAmount > 0 && !flag)
			{
				inputCloseAmount = GetPowerAtInput(2);
				DoAction((inputCloseAmount == 0) ? DoorEffect.Open : DoorEffect.Close);
			}
		}
		if (inputSlot == 1 && inputOpenAmount != inputAmount)
		{
			if (inputAmount > 0 && IsPowered())
			{
				DoAction(DoorEffect.Open);
			}
			inputOpenAmount = inputAmount;
		}
		else if (inputSlot == 2 && inputCloseAmount != inputAmount)
		{
			if (inputAmount > 0 && IsPowered())
			{
				DoAction(DoorEffect.Close);
			}
			inputCloseAmount = inputAmount;
		}
	}

	public override bool WantsPower(int inputIndex)
	{
		return inputIndex == 0;
	}

	private int GetPowerAtInput(int slotIndex)
	{
		IOSlot iOSlot = inputs[slotIndex];
		if (!iOSlot.IsConnected())
		{
			return 0;
		}
		int connectedToSlot = iOSlot.connectedToSlot;
		return iOSlot.connectedTo.Get().GetPassthroughAmount(connectedToSlot);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		targetDoor = entityRef.Get(base.isServer) as Door;
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class CustomTimerSwitch : TimerSwitch
{
	public GameObjectRef timerPanelPrefab;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("CustomTimerSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 1019813162 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_SetTime "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_SetTime", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1019813162u, "SERVER_SetTime", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_SetTime(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_SetTime");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_SetTime(RPCMessage msg)
	{
		if (CanPlayerAdmin(msg.player))
		{
			float num = msg.read.Float();
			if (!FloatEx.IsNaNOrInfinity(num))
			{
				timerLength = num;
				SendNetworkUpdate();
			}
		}
	}

	public bool CanPlayerAdmin(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null && player.CanBuild())
		{
			return !IsOn();
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class DecayEntity : BaseCombatEntity
{
	[Serializable]
	public struct DebrisPosition
	{
		public Vector3 Position;

		public Vector3 Rotation;

		public bool dropToTerrain;
	}

	public static readonly Phrase CancelTitle = new Phrase("cancel", "Cancel");

	public static readonly Phrase CancelDesc = new Phrase("cancel_desc", "");

	public GameObjectRef debrisPrefab;

	public Vector3 debrisRotationOffset = Vector3.zero;

	public DebrisPosition[] DebrisPositions;

	[NonSerialized]
	public uint buildingID;

	public float timePlaced;

	public float decayTimer;

	public float upkeepTimer;

	public Upkeep upkeep;

	public Decay decay;

	public DecayPoint[] decayPoints;

	public float lastDecayTick;

	public float decayVariance = 1f;

	public static readonly Phrase DemolishTitle = new Phrase("demolish", "Demolish");

	public static readonly Phrase DemolishDesc = new Phrase("demolish_desc", "Slowly and automatically dismantle this block");

	[ServerVar]
	public static int demolish_seconds = 600;

	public const Flags DemolishFlag = Flags.Reserved2;

	[Header("Demolish")]
	public bool canBeDemolished;

	public Upkeep Upkeep => upkeep;

	public virtual bool BypassInsideDecayMultiplier => false;

	public virtual bool AllowOnCargoShip => false;

	public virtual bool IsDemolishSupported => canBeDemolished;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DecayEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 2858062413u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoDemolish "));
				}
				TimeWarning val2 = TimeWarning.New("DoDemolish", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2858062413u, "DoDemolish", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoDemolish(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoDemolish");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 216608990 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoImmediateDemolish "));
				}
				TimeWarning val2 = TimeWarning.New("DoImmediateDemolish", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(216608990u, "DoImmediateDemolish", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							DoImmediateDemolish(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in DoImmediateDemolish");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		buildingID = 0u;
		if (base.isServer)
		{
			decayTimer = 0f;
		}
	}

	public void AttachToBuilding(uint id)
	{
		if (base.isServer)
		{
			BuildingManager.server.Remove(this);
			buildingID = id;
			BuildingManager.server.Add(this);
			SendNetworkUpdate();
		}
	}

	public BuildingManager.Building GetBuilding()
	{
		if (base.isServer)
		{
			return BuildingManager.server.GetBuilding(buildingID);
		}
		return null;
	}

	public override BuildingPrivlidge GetBuildingPrivilege()
	{
		BuildingManager.Building building = GetBuilding();
		if (building != null)
		{
			BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
			if ((Object)(object)dominatingBuildingPrivilege != (Object)null || CanReturnEmptyBuildingPrivilege())
			{
				return dominatingBuildingPrivilege;
			}
		}
		return base.GetBuildingPrivilege();
	}

	public virtual bool CanReturnEmptyBuildingPrivilege()
	{
		return false;
	}

	public void CalculateUpkeepCostAmounts(List<ItemAmount> itemAmounts, float multiplier)
	{
		if (upkeep == null)
		{
			return;
		}
		float num = upkeep.upkeepMultiplier * multiplier;
		if (num == 0f)
		{
			return;
		}
		List<ItemAmount> list = BuildCost();
		if (list == null)
		{
			return;
		}
		foreach (ItemAmount item in list)
		{
			if (item.itemDef.category != ItemCategory.Resources)
			{
				continue;
			}
			float num2 = item.amount * num;
			bool flag = false;
			foreach (ItemAmount itemAmount in itemAmounts)
			{
				if ((Object)(object)itemAmount.itemDef == (Object)(object)item.itemDef)
				{
					itemAmount.amount += num2;
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				itemAmounts.Add(new ItemAmount(item.itemDef, num2));
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		decayVariance = Random.Range(0.95f, 1f);
		decay = PrefabAttribute.server.Find<Decay>(prefabID);
		decayPoints = PrefabAttribute.server.FindAll<DecayPoint>(prefabID);
		upkeep = PrefabAttribute.server.Find<Upkeep>(prefabID);
		BuildingManager.server.Add(this);
		if (!Application.isLoadingSave)
		{
			BuildingManager.server.CheckMerge(this);
		}
		lastDecayTick = Time.time;
		if (IsDemolishSupported && (HasFlag(Flags.Reserved2) || !Application.isLoadingSave))
		{
			StartBeingDemolishable();
		}
	}

	public override void DoServerDestroy()
	{
		base.DoServerDestroy();
		BuildingManager.server.Remove(this);
		BuildingManager.server.CheckSplit(this);
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return Time.time - timePlaced <= 5f;
	}

	public virtual void AttachToBuilding(DecayEntity other)
	{
		if ((Object)(object)other != (Object)null)
		{
			AttachToBuilding(other.buildingID);
			BuildingManager.server.CheckMerge(this);
			return;
		}
		BuildingBlock nearbyBuildingBlock = GetNearbyBuildingBlock();
		if (Object.op_Implicit((Object)(object)nearbyBuildingBlock))
		{
			AttachToBuilding(nearbyBuildingBlock.buildingID);
		}
	}

	public BuildingBlock GetNearbyBuildingBlock()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		BuildingBlock result = null;
		Vector3 position = PivotPoint();
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(position, 1.5f, list, 2097152, (QueryTriggerInteraction)2);
		for (int i = 0; i < list.Count; i++)
		{
			BuildingBlock buildingBlock = list[i];
			if (buildingBlock.isServer == base.isServer)
			{
				float num2 = buildingBlock.SqrDistance(position);
				if (!buildingBlock.grounded)
				{
					num2 += 1f;
				}
				if (num2 < num)
				{
					num = num2;
					result = buildingBlock;
				}
			}
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
		return result;
	}

	public void ResetUpkeepTime()
	{
		upkeepTimer = 0f;
	}

	public void DecayTouch()
	{
		decayTimer = 0f;
	}

	public void AddUpkeepTime(float time)
	{
		upkeepTimer -= time;
	}

	public float GetProtectedSeconds()
	{
		return Mathf.Max(0f, 0f - upkeepTimer);
	}

	public virtual float GetEntityDecayDuration()
	{
		return decay.GetDecayDuration(this);
	}

	public virtual float GetEntityHealScale()
	{
		return decay.GetHealScale(this);
	}

	public virtual float GetEntityDecayDelay()
	{
		return decay.GetDecayDelay(this);
	}

	public virtual void DecayTick()
	{
		if (!(decay == null))
		{
			float num = decay.GetDecayTickOverride();
			if (num == 0f)
			{
				num = ConVar.Decay.tick;
			}
			float num2 = Time.time - lastDecayTick;
			if (!(num2 < num))
			{
				OnDecay(decay, num2);
			}
		}
	}

	public virtual void OnDecay(Decay decay, float decayDeltaTime)
	{
		lastDecayTick = Time.time;
		if (HasParent() || !decay.ShouldDecay(this))
		{
			return;
		}
		float num = decayDeltaTime * ConVar.Decay.scale;
		if (ConVar.Decay.upkeep)
		{
			upkeepTimer += num;
			if (upkeepTimer > 0f)
			{
				BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
				if ((Object)(object)buildingPrivilege != (Object)null)
				{
					upkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));
				}
			}
			if (upkeepTimer < 1f)
			{
				if (base.healthFraction < 1f && GetEntityHealScale() > 0f && base.SecondsSinceAttacked > 600f && Interface.CallHook("OnDecayHeal", (object)this) == null)
				{
					float num2 = decayDeltaTime / GetEntityDecayDuration() * GetEntityHealScale();
					Heal(MaxHealth() * num2);
				}
				return;
			}
			upkeepTimer = 1f;
		}
		decayTimer += num;
		if (decayTimer < GetEntityDecayDelay())
		{
			return;
		}
		TimeWarning val = TimeWarning.New("DecayTick", 0);
		try
		{
			float num3 = 1f;
			if (ConVar.Decay.upkeep)
			{
				if (!BypassInsideDecayMultiplier && !IsOutside())
				{
					num3 *= ConVar.Decay.upkeep_inside_decay_scale;
				}
			}
			else
			{
				for (int i = 0; i < decayPoints.Length; i++)
				{
					DecayPoint decayPoint = decayPoints[i];
					if (decayPoint.IsOccupied(this))
					{
						num3 -= decayPoint.protection;
					}
				}
			}
			if (Interface.CallHook("OnDecayDamage", (object)this) == null && num3 > 0f)
			{
				float num4 = num / GetEntityDecayDuration() * MaxHealth();
				Hurt(num4 * num3 * decayVariance, DamageType.Decay);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		DecayTouch();
	}

	public override void OnDied(HitInfo info)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (debrisPrefab.isValid)
		{
			if (DebrisPositions != null && DebrisPositions.Length != 0)
			{
				DebrisPosition[] debrisPositions = DebrisPositions;
				for (int i = 0; i < debrisPositions.Length; i++)
				{
					DebrisPosition debrisPosition = debrisPositions[i];
					SpawnDebris(debrisPosition.Position, Quaternion.Euler(debrisPosition.Rotation), debrisPosition.dropToTerrain);
				}
			}
			else
			{
				SpawnDebris(Vector3.zero, Quaternion.Euler(debrisRotationOffset), dropToTerrain: false);
			}
		}
		base.OnDied(info);
	}

	private void SpawnDebris(Vector3 localPos, Quaternion rot, bool dropToTerrain)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnDebrisSpawn", (object)this, (object)localPos, (object)rot, (object)dropToTerrain) != null)
		{
			return;
		}
		Vector3 val = ((Component)this).transform.TransformPoint(localPos);
		RaycastHit val2 = default(RaycastHit);
		if (dropToTerrain && Physics.Raycast(val, Vector3.down, ref val2, 6f, 8388608))
		{
			float num = val.y - ((RaycastHit)(ref val2)).point.y;
			val.y = ((RaycastHit)(ref val2)).point.y;
			localPos.y -= num;
		}
		List<DebrisEntity> list = Pool.Get<List<DebrisEntity>>();
		Vis.Entities(val, 0.1f, list, 256, (QueryTriggerInteraction)2);
		if (list.Count > 0)
		{
			Pool.FreeUnmanaged<DebrisEntity>(ref list);
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(debrisPrefab.resourcePath, ((Component)this).transform.TransformPoint(localPos), ((Component)this).transform.rotation * rot);
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			baseEntity.SetParent(parentEntity.Get(serverside: true), worldPositionStays: true);
			baseEntity.Spawn();
		}
		Pool.FreeUnmanaged<DebrisEntity>(ref list);
	}

	public override bool SupportsChildDeployables()
	{
		BaseEntity baseEntity = GetParentEntity();
		if (!((Object)(object)baseEntity != (Object)null))
		{
			return false;
		}
		return baseEntity.ForceDeployableSetParent();
	}

	public override bool ForceDeployableSetParent()
	{
		BaseEntity baseEntity = GetParentEntity();
		if (!((Object)(object)baseEntity != (Object)null))
		{
			return false;
		}
		return baseEntity.ForceDeployableSetParent();
	}

	public bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsDemolishSupported && IsDemolishable())
		{
			return HasDemolishPrivilege(player);
		}
		return false;
	}

	public bool IsDemolishable()
	{
		if (!ConVar.Server.pve && !HasFlag(Flags.Reserved2))
		{
			return false;
		}
		return true;
	}

	public bool HasDemolishPrivilege(BasePlayer player)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return player.IsBuildingAuthed(((Component)this).transform.position, ((Component)this).transform.rotation, bounds);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("OnStructureDemolish", (object)this, (object)msg.player, (object)false) == null)
		{
			StabilityEntity stabilityEntity = this as StabilityEntity;
			if ((Object)(object)stabilityEntity != (Object)null)
			{
				Analytics.Azure.OnBuildingBlockDemolished(msg.player, stabilityEntity);
			}
			Kill(DestroyMode.Gib);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoImmediateDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && msg.player.IsAdmin && Interface.CallHook("OnStructureDemolish", (object)this, (object)msg.player, (object)true) == null)
		{
			StabilityEntity stabilityEntity = this as StabilityEntity;
			if ((Object)(object)stabilityEntity != (Object)null)
			{
				Analytics.Azure.OnBuildingBlockDemolished(msg.player, stabilityEntity);
			}
			Kill(DestroyMode.Gib);
		}
	}

	public void StopBeingDemolishable()
	{
		SetFlag(Flags.Reserved2, b: false);
		SendNetworkUpdate();
	}

	public void StartBeingDemolishable()
	{
		SetFlag(Flags.Reserved2, b: true);
		((FacepunchBehaviour)this).Invoke((Action)StopBeingDemolishable, (float)demolish_seconds);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.decayEntity = Pool.Get<DecayEntity>();
		info.msg.decayEntity.buildingID = buildingID;
		if (info.forDisk)
		{
			info.msg.decayEntity.decayTimer = decayTimer;
			info.msg.decayEntity.upkeepTimer = upkeepTimer;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.decayEntity != null)
		{
			decayTimer = info.msg.decayEntity.decayTimer;
			upkeepTimer = info.msg.decayEntity.upkeepTimer;
			if (buildingID != info.msg.decayEntity.buildingID)
			{
				AttachToBuilding(info.msg.decayEntity.buildingID);
				if (info.fromDisk)
				{
					BuildingManager.server.LoadBuildingID(buildingID);
				}
			}
		}
		if (info.fromDisk && IsDemolishSupported)
		{
			SetFlag(Flags.Reserved2, b: false);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct DebrisPosition
{
	public Vector3 Position;

	public Vector3 Rotation;

	public bool dropToTerrain;
}


using System;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class DeployableBoomBox : ContainerIOEntity, ICassettePlayer, IAudioConnectionSource
{
	public BoomBox BoxController;

	public int PowerUsageWhilePlaying = 10;

	public const int MaxBacktrackHopsClient = 30;

	public bool IsStatic;

	public BaseEntity ToBaseEntity => this;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DeployableBoomBox.OnRpcMessage", 0);
		try
		{
			if (rpc == 1918716764 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_UpdateRadioIP "));
				}
				TimeWarning val2 = TimeWarning.New("Server_UpdateRadioIP", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1918716764u, "Server_UpdateRadioIP", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1918716764u, "Server_UpdateRadioIP", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_UpdateRadioIP(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_UpdateRadioIP");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1785864031 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerTogglePlay "));
				}
				TimeWarning val2 = TimeWarning.New("ServerTogglePlay", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1785864031u, "ServerTogglePlay", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1785864031u, "ServerTogglePlay", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ServerTogglePlay(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerTogglePlay");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public IOEntity ToEntity()
	{
		return this;
	}

	public override int ConsumptionAmount()
	{
		return 10;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (!IsOn() || inputIndex != 0)
		{
			return 0;
		}
		return PowerUsageWhilePlaying;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
			if (!IsPowered() && IsOn())
			{
				BoxController.ServerTogglePlay(play: false);
			}
		}
		else if (IsPowered() && !IsConnectedToAnySlot(this, inputSlot, IOEntity.backtracking))
		{
			BoxController.ServerTogglePlay(inputAmount > 0);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.canAcceptItem = ItemFilter;
		BoxController.HurtCallback = HurtCallback;
		if (IsStatic)
		{
			SetFlag(Flags.Reserved8, b: true);
		}
	}

	public bool ItemFilter(Item item, int count)
	{
		ItemDefinition[] validCassettes = BoxController.ValidCassettes;
		for (int i = 0; i < validCassettes.Length; i++)
		{
			if ((Object)(object)validCassettes[i] == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsOn())
		{
			return 0;
		}
		return base.GetPassthroughAmount(outputSlot);
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		if (inputSlot != 0)
		{
			return currentEnergy;
		}
		return base.CalculateCurrentEnergy(inputAmount, inputSlot);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.IsVisible(3f)]
	public void ServerTogglePlay(RPCMessage msg)
	{
		BoxController.ServerTogglePlay(msg);
	}

	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Server_UpdateRadioIP(RPCMessage msg)
	{
		BoxController.Server_UpdateRadioIP(msg);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		BoxController.Save(info);
	}

	public bool ClearRadioByUserId(ulong id)
	{
		return BoxController.ClearRadioByUserId(id);
	}

	public void OnCassetteInserted(Cassette c)
	{
		BoxController.OnCassetteInserted(c);
	}

	public void OnCassetteRemoved(Cassette c)
	{
		BoxController.OnCassetteRemoved(c);
	}

	public void HurtCallback(float amount)
	{
		Hurt(amount, DamageType.Decay);
	}

	public override void Load(LoadInfo info)
	{
		BoxController.Load(info);
		base.Load(info);
		if (base.isServer && IsStatic)
		{
			SetFlag(Flags.Reserved8, b: true);
		}
	}
}


using System;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class DeployedFigurine : BaseCombatEntity
{
	public float UseCooldown = 4f;

	public float HurtPerUse = 5f;

	public Animator WobbleAnimator;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DeployedFigurine.OnRpcMessage", 0);
		try
		{
			if (rpc == 1279596472 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_Poke "));
				}
				TimeWarning val2 = TimeWarning.New("Server_Poke", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1279596472u, "Server_Poke", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_Poke(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_Poke");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void Server_Poke(RPCMessage msg)
	{
		if (CanWobble() && !((Object)(object)msg.player == (Object)null))
		{
			Hurt(HurtPerUse, DamageType.Generic, null, useProtection: false);
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearBusy, UseCooldown);
		}
	}

	private void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Busy, b: false);
	}

	private bool CanWobble()
	{
		return !HasFlag(Flags.Busy);
	}
}


using System;
using System.IO;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class DeployedRecorder : StorageContainer, ICassettePlayer
{
	public AudioSource SoundSource;

	public ItemDefinition[] ValidCassettes;

	public SoundDefinition PlaySfx;

	public SoundDefinition StopSfx;

	public SwapKeycard TapeSwapper;

	private CollisionDetectionMode? initialCollisionDetectionMode;

	public BaseEntity ToBaseEntity => this;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DeployedRecorder.OnRpcMessage", 0);
		try
		{
			if (rpc == 1785864031 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerTogglePlay "));
				}
				TimeWarning val2 = TimeWarning.New("ServerTogglePlay", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1785864031u, "ServerTogglePlay", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1785864031u, "ServerTogglePlay", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerTogglePlay(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerTogglePlay");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	public void ServerTogglePlay(RPCMessage msg)
	{
		bool play = ((Stream)(object)msg.read).ReadByte() == 1;
		ServerTogglePlay(play);
	}

	private void ServerTogglePlay(bool play)
	{
		SetFlag(Flags.On, play);
	}

	public void OnCassetteInserted(Cassette c)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.NetworkGroup("Client_OnCassetteInserted"), c.net.ID);
		SendNetworkUpdate();
	}

	public void OnCassetteRemoved(Cassette c)
	{
		ClientRPC(RpcTarget.NetworkGroup("Client_OnCassetteRemoved"));
		ServerTogglePlay(play: false);
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		ItemDefinition[] validCassettes = ValidCassettes;
		for (int i = 0; i < validCassettes.Length; i++)
		{
			if ((Object)(object)validCassettes[i] == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (base.isServer)
		{
			DoCollisionStick(collision, hitEntity);
		}
	}

	private void DoCollisionStick(Collision collision, BaseEntity ent)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		ContactPoint contact = collision.GetContact(0);
		DoStick(((ContactPoint)(ref contact)).point, ((ContactPoint)(ref contact)).normal, ent, collision.collider);
	}

	public virtual void SetMotionEnabled(bool wantsMotion)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component))
		{
			if (!initialCollisionDetectionMode.HasValue)
			{
				initialCollisionDetectionMode = component.collisionDetectionMode;
			}
			component.useGravity = wantsMotion;
			if (!wantsMotion)
			{
				component.collisionDetectionMode = (CollisionDetectionMode)0;
			}
			component.isKinematic = !wantsMotion;
			if (wantsMotion)
			{
				component.collisionDetectionMode = initialCollisionDetectionMode.Value;
			}
		}
	}

	public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent, Collider hitCollider)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent != (Object)null && ent is TimedExplosive)
		{
			if (!ent.HasParent())
			{
				return;
			}
			position = ((Component)ent).transform.position;
			ent = ent.parentEntity.Get(serverside: true);
		}
		SetMotionEnabled(wantsMotion: false);
		SetCollisionEnabled(wantsCollision: false);
		if (!((Object)(object)ent != (Object)null) || !HasChild(ent))
		{
			((Component)this).transform.position = position;
			((Component)this).transform.rotation = Quaternion.LookRotation(normal, ((Component)this).transform.up);
			if ((Object)(object)hitCollider != (Object)null && (Object)(object)ent != (Object)null)
			{
				SetParent(ent, ent.FindBoneID(((Component)hitCollider).transform), worldPositionStays: true);
			}
			else
			{
				SetParent(ent, StringPool.closest, worldPositionStays: true);
			}
			ReceiveCollisionMessages(b: false);
		}
	}

	private void UnStick()
	{
		if (Object.op_Implicit((Object)(object)GetParentEntity()))
		{
			SetParent(null, worldPositionStays: true, sendImmediate: true);
			SetMotionEnabled(wantsMotion: true);
			SetCollisionEnabled(wantsCollision: true);
			ReceiveCollisionMessages(b: true);
		}
	}

	internal override void OnParentRemoved()
	{
		UnStick();
	}

	public virtual void SetCollisionEnabled(bool wantsCollision)
	{
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component) && component.enabled != wantsCollision)
		{
			component.enabled = wantsCollision;
		}
	}

	public override void ResetState()
	{
		base.ResetState();
		if (base.isServer)
		{
			initialCollisionDetectionMode = null;
		}
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class Deployer : HeldEntity
{
	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Deployer.OnRpcMessage", 0);
		try
		{
			if (rpc == 3001117906u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoDeploy "));
				}
				TimeWarning val2 = TimeWarning.New("DoDeploy", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3001117906u, "DoDeploy", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoDeploy(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoDeploy");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public ItemModDeployable GetModDeployable()
	{
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		if ((Object)(object)ownerItemDefinition == (Object)null)
		{
			return null;
		}
		return ((Component)ownerItemDefinition).GetComponent<ItemModDeployable>();
	}

	public Deployable GetDeployable()
	{
		ItemModDeployable modDeployable = GetModDeployable();
		if ((Object)(object)modDeployable == (Object)null)
		{
			return null;
		}
		return modDeployable.GetDeployable(this);
	}

	public Quaternion GetDeployedRotation(Vector3 normal, Vector3 placeDir)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.LookRotation(normal, placeDir) * Quaternion.Euler(90f, 0f, 0f);
	}

	public bool IsPlacementAngleAcceptable(Vector3 pos, Quaternion rot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = rot * Vector3.up;
		if (Mathf.Acos(Vector3.Dot(val, Vector3.up)) <= 0.61086524f)
		{
			return true;
		}
		return false;
	}

	public bool CheckPlacement(Deployable deployable, Ray ray, float fDistance)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Deploy.CheckPlacement", 0);
		try
		{
			RaycastHit val2 = default(RaycastHit);
			if (!Physics.Raycast(ray, ref val2, fDistance, 1235288065))
			{
				return false;
			}
			DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(deployable.prefabID);
			Vector3 point = ((RaycastHit)(ref val2)).point;
			Quaternion deployedRotation = GetDeployedRotation(((RaycastHit)(ref val2)).normal, ((Ray)(ref ray)).direction);
			if (DeployVolume.Check(point, deployedRotation, volumes))
			{
				return false;
			}
			if (!IsPlacementAngleAcceptable(((RaycastHit)(ref val2)).point, deployedRotation))
			{
				return false;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return true;
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void DoDeploy(RPCMessage msg)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (!msg.player.CanInteract())
		{
			return;
		}
		Deployable deployable = GetDeployable();
		if (deployable == null)
		{
			return;
		}
		Ray ray = msg.read.Ray();
		NetworkableId val = msg.read.EntityID();
		if (Interface.CallHook("CanDeployItem", (object)msg.player, (object)this, (object)val) == null)
		{
			if (deployable.toSlot)
			{
				DoDeploy_Slot(deployable, ray, val);
			}
			else
			{
				DoDeploy_Regular(deployable, ray);
			}
		}
	}

	public void DoDeploy_Slot(Deployable deployable, Ray ray, NetworkableId entityID)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if ((Object)(object)baseEntity == (Object)null || !baseEntity.HasSlot(deployable.slot) || (Object)(object)baseEntity.GetSlot(deployable.slot) != (Object)null)
		{
			return;
		}
		if (ownerPlayer.Distance(baseEntity) > 3f)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.TooFarAway, false);
			return;
		}
		if (!ownerPlayer.CanBuild(baseEntity.WorldSpaceBounds()))
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
			return;
		}
		if (ownerPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = ownerPlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null && !currentTutorialIsland.CheckPlacement(ownerPlayer, deployable, ((Component)baseEntity).transform.position, ((Component)baseEntity).transform.rotation))
			{
				return;
			}
		}
		Item ownerItem = GetOwnerItem();
		ItemModDeployable modDeployable = GetModDeployable();
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);
		if ((Object)(object)baseEntity2 != (Object)null)
		{
			baseEntity2.skinID = ownerItem.skin;
			baseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));
			baseEntity2.OwnerID = ownerPlayer.userID;
			baseEntity2.OnDeployed(baseEntity, ownerPlayer, ownerItem);
			baseEntity2.Spawn();
			baseEntity.SetSlot(deployable.slot, baseEntity2);
			if (deployable.placeEffect.isValid)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, ((Component)baseEntity).transform.position, Vector3.up);
			}
			if (ownerPlayer.IsInTutorial)
			{
				TutorialIsland currentTutorialIsland2 = ownerPlayer.GetCurrentTutorialIsland();
				if ((Object)(object)currentTutorialIsland2 != (Object)null)
				{
					currentTutorialIsland2.OnPlayerBuiltConstruction(ownerPlayer);
				}
			}
			if ((Object)(object)GetOwnerItemDefinition() != (Object)null)
			{
				ownerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload
				{
					WorldPosition = ((Component)baseEntity2).transform.position,
					UintIdentifier = baseEntity2.prefabID,
					IntIdentifier = GetOwnerItemDefinition().itemid
				}, 1f);
			}
		}
		modDeployable.OnDeployed(baseEntity2, ownerPlayer);
		Interface.CallHook("OnItemDeployed", (object)this, (object)baseEntity, (object)baseEntity2);
		Analytics.Azure.OnEntityBuilt(baseEntity2, ownerPlayer);
		if (!ownerPlayer.IsInCreativeMode || !Creative.freeBuild)
		{
			UseItemAmount(1);
		}
	}

	public void DoDeploy_Regular(Deployable deployable, Ray ray)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
		}
		else if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredMovementAntiHack())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.AntihackWithReason, false, ownerPlayer.lastViolationType.ToString());
		}
		else
		{
			RaycastHit val = default(RaycastHit);
			if (!CheckPlacement(deployable, ray, 8f) || !Physics.Raycast(ray, ref val, 8f, 1235288065))
			{
				return;
			}
			Vector3 point = ((RaycastHit)(ref val)).point;
			Quaternion deployedRotation = GetDeployedRotation(((RaycastHit)(ref val)).normal, ((Ray)(ref ray)).direction);
			Item ownerItem = GetOwnerItem();
			ItemModDeployable modDeployable = GetModDeployable();
			if (ownerPlayer.Distance(point) > 3f)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.TooFarAway, false);
				return;
			}
			if (!ownerPlayer.CanBuild(point, deployedRotation, deployable.bounds))
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
				return;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath, point, deployedRotation);
			if (!Object.op_Implicit((Object)(object)baseEntity))
			{
				Debug.LogWarning((object)("Couldn't create prefab:" + modDeployable.entityPrefab.resourcePath));
				return;
			}
			baseEntity.skinID = ownerItem.skin;
			((Component)baseEntity).SendMessage("SetDeployedBy", (object)ownerPlayer, (SendMessageOptions)1);
			baseEntity.OwnerID = ownerPlayer.userID;
			baseEntity.Spawn();
			modDeployable.OnDeployed(baseEntity, ownerPlayer);
			Interface.CallHook("OnItemDeployed", (object)this, (object)modDeployable, (object)baseEntity);
			Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);
			UseItemAmount(1);
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Detonator : HeldEntity, IRFObject
{
	public int frequency = 55;

	private float timeSinceDeploy;

	public GameObjectRef frequencyPanelPrefab;

	public GameObjectRef attackEffect;

	public GameObjectRef unAttackEffect;

	private float nextChangeTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Detonator.OnRpcMessage", 0);
		try
		{
			if (rpc == 2778616053u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSetFrequency "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSetFrequency", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						ServerSetFrequency(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in ServerSetFrequency");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1106698135 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetPressed "));
				}
				TimeWarning val2 = TimeWarning.New("SetPressed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage pressed = rPCMessage;
						SetPressed(pressed);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in SetPressed");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	public void SetPressed(RPCMessage msg)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)msg.player == (Object)null) && !((Object)(object)msg.player != (Object)(object)GetOwnerPlayer()))
		{
			bool num = HasFlag(Flags.On);
			bool flag = msg.read.Bit();
			InternalSetPressed(flag);
			if (num != flag)
			{
				Effect.server.Run(flag ? attackEffect.resourcePath : unAttackEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

	internal void InternalSetPressed(bool pressed)
	{
		SetFlag(Flags.On, pressed);
		if (pressed)
		{
			RFManager.AddBroadcaster(frequency, this);
		}
		else
		{
			RFManager.RemoveBroadcaster(frequency, this);
		}
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public float GetMaxRange()
	{
		return 100000f;
	}

	public void RFSignalUpdate(bool on)
	{
	}

	public override void SetHeld(bool bHeld)
	{
		if (!bHeld)
		{
			InternalSetPressed(pressed: false);
		}
		base.SetHeld(bHeld);
	}

	[RPC_Server]
	public void ServerSetFrequency(RPCMessage msg)
	{
		ServerSetFrequency(msg.player, msg.read.Int32());
	}

	public void ServerSetFrequency(BasePlayer player, int freq)
	{
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Expected O, but got Unknown
		if ((Object)(object)player == (Object)null || (Object)(object)GetOwnerPlayer() != (Object)(object)player || Time.time < nextChangeTime)
		{
			return;
		}
		nextChangeTime = Time.time + 2f;
		if (RFManager.IsReserved(freq))
		{
			RFManager.ReserveErrorPrint(player);
		}
		else
		{
			if (Interface.CallHook("OnRfFrequencyChange", (object)this, (object)freq, (object)player) != null)
			{
				return;
			}
			Item ownerItem = GetOwnerItem();
			RFManager.ChangeFrequency(frequency, freq, this, isListener: false, IsOn());
			frequency = freq;
			SendNetworkUpdate();
			Item item = GetItem();
			if (item != null)
			{
				if (item.instanceData == null)
				{
					item.instanceData = new InstanceData();
					item.instanceData.ShouldPool = false;
				}
				item.instanceData.dataInt = frequency;
				item.MarkDirty();
			}
			ownerItem?.LoseCondition(ownerItem.maxCondition * 0.01f);
			Interface.CallHook("OnRfFrequencyChanged", (object)this, (object)freq, (object)player);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.ioEntity == null)
		{
			info.msg.ioEntity = Pool.Get<IOEntity>();
		}
		info.msg.ioEntity.genericInt1 = frequency;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			frequency = info.msg.ioEntity.genericInt1;
		}
	}

	public int GetFrequency()
	{
		return frequency;
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class DieselEngine : StorageContainer
{
	public GameObjectRef rumbleEffect;

	public Transform rumbleOrigin;

	public const Flags Flag_HasFuel = Flags.Reserved3;

	public float runningTimePerFuelUnit = 120f;

	public float cachedFuelTime;

	private const float rumbleMaxDistSq = 100f;

	private const string EXCAVATOR_ACTIVATED_STAT = "excavator_activated";

	private BasePlayer startedByPlayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DieselEngine.OnRpcMessage", 0);
		try
		{
			if (rpc == 578721460 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - EngineSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("EngineSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(578721460u, "EngineSwitch", this, player, 6f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							EngineSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in EngineSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void FixedUpdate()
	{
		if (!base.isClient && IsOn())
		{
			if (cachedFuelTime <= Time.fixedDeltaTime && ConsumeFuelItem())
			{
				cachedFuelTime += runningTimePerFuelUnit;
			}
			cachedFuelTime -= Time.fixedDeltaTime;
			if (cachedFuelTime <= 0f)
			{
				cachedFuelTime = 0f;
				EngineOff();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(6f)]
	public void EngineSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnDieselEngineToggle", (object)this, (object)msg.player) != null)
		{
			return;
		}
		if (msg.read.Bit())
		{
			if (GetFuelAmount() > 0)
			{
				EngineOn();
				startedByPlayer = msg.player;
				if (GameInfo.HasAchievements && (Object)(object)msg.player != (Object)null)
				{
					msg.player.stats.Add("excavator_activated", 1, Stats.All);
					msg.player.stats.Save(forceSteamSave: true);
				}
			}
		}
		else
		{
			EngineOff();
		}
	}

	public void TimedShutdown()
	{
		EngineOff();
	}

	public bool ConsumeFuelItem(int amount = 1)
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || slot.amount < amount)
		{
			return false;
		}
		slot.UseItem(amount);
		Analytics.Azure.OnExcavatorConsumeFuel(slot, amount, this);
		if ((Object)(object)startedByPlayer != (Object)null && startedByPlayer.serverClan != null)
		{
			startedByPlayer.AddClanScore((ClanScoreEventType)8, amount);
		}
		UpdateHasFuelFlag();
		return true;
	}

	public int GetFuelAmount()
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		return slot.amount;
	}

	public void UpdateHasFuelFlag()
	{
		SetFlag(Flags.Reserved3, GetFuelAmount() > 0);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		UpdateHasFuelFlag();
	}

	public void EngineOff()
	{
		SetFlag(Flags.On, b: false);
		BroadcastEntityMessage("DieselEngineOff");
		Interface.CallHook("OnDieselEngineToggled", (object)this);
	}

	public void EngineOn()
	{
		SetFlag(Flags.On, b: true);
		BroadcastEntityMessage("DieselEngineOn");
		Interface.CallHook("OnDieselEngineToggled", (object)this);
	}

	public void RescheduleEngineShutdown()
	{
		float num = 120f;
		((FacepunchBehaviour)this).Invoke((Action)TimedShutdown, num);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (IsOn())
		{
			BroadcastEntityMessage("DieselEngineOn");
		}
		else
		{
			BroadcastEntityMessage("DieselEngineOff");
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.dieselEngine = Pool.Get<DieselEngine>();
		info.msg.dieselEngine.fuelTime = cachedFuelTime;
		if (info.forDisk)
		{
			info.msg.dieselEngine.startedByPlayer = (((Object)(object)startedByPlayer != (Object)null) ? startedByPlayer.userID : ((EncryptedValue<ulong>)0uL));
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			cachedFuelTime = info.msg.ioEntity.genericFloat1;
		}
		else if (info.msg.dieselEngine != null)
		{
			cachedFuelTime = info.msg.dieselEngine.fuelTime;
			if (base.isServer)
			{
				startedByPlayer = BasePlayer.FindAwakeOrSleepingByID(info.msg.dieselEngine.startedByPlayer);
			}
		}
	}

	public bool HasFuel()
	{
		return HasFlag(Flags.Reserved3);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using TMPro;
using UnityEngine;
using UnityEngine.Assertions;

public class DigitalClock : IOEntity, INotifyLOD
{
	public struct Alarm
	{
		public TimeSpan time;

		public bool active;

		public Alarm(TimeSpan time, bool active)
		{
			this.time = time;
			this.active = active;
		}

		public Alarm(DigitalClockAlarm alarm)
		{
			time = alarm.time.ToTimeSpan();
			active = alarm.active;
		}
	}

	[SerializeField]
	private TextMeshPro clockText;

	[SerializeField]
	private SoundDefinition ringingSoundDef;

	[SerializeField]
	private SoundDefinition ringingStartSoundDef;

	[SerializeField]
	private SoundDefinition ringingStopSoundDef;

	public GameObjectRef clockConfigPanel;

	public List<Alarm> alarms = new List<Alarm>();

	[HideInInspector]
	public bool muted;

	private bool isRinging;

	public const float ringDuration = 5f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DigitalClock.OnRpcMessage", 0);
		try
		{
			if (rpc == 2287159130u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetAlarms "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetAlarms", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2287159130u, "RPC_SetAlarms", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2287159130u, "RPC_SetAlarms", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_SetAlarms(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_SetAlarms");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private void OnMinute()
	{
		if (IsOn() && base.isServer)
		{
			CheckAlarms();
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	public bool CanPlayerAdmin(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			return player.CanBuild();
		}
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		TOD_Sky.Instance.Components.Time.OnMinute += OnMinute;
	}

	private void CheckAlarms()
	{
		TimeSpan timeOfDay = TOD_Sky.Instance.Cycle.DateTime.TimeOfDay;
		foreach (Alarm alarm in alarms)
		{
			if (!alarm.active)
			{
				continue;
			}
			int hours = timeOfDay.Hours;
			TimeSpan time = alarm.time;
			if (hours == time.Hours)
			{
				int minutes = timeOfDay.Minutes;
				time = alarm.time;
				if (minutes == time.Minutes)
				{
					Ring();
				}
			}
		}
	}

	private void Ring()
	{
		if (Interface.CallHook("OnDigitalClockRing", (object)this) == null)
		{
			isRinging = true;
			ClientRPC(RpcTarget.NetworkGroup("RPC_StartRinging"));
			((FacepunchBehaviour)this).Invoke((Action)StopRinging, 5f);
			MarkDirty();
		}
	}

	private void StopRinging()
	{
		if (Interface.CallHook("OnDigitalClockRingStop", (object)this) == null)
		{
			isRinging = false;
			ClientRPC(RpcTarget.NetworkGroup("RPC_StopRinging"));
			MarkDirty();
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_SetAlarms(RPCMessage msg)
	{
		if (!CanPlayerAdmin(msg.player))
		{
			return;
		}
		DigitalClockMessage val = msg.read.Proto<DigitalClockMessage>((DigitalClockMessage)null);
		if (Interface.CallHook("OnDigitalClockAlarmsSet", (object)this, (object)val) != null)
		{
			return;
		}
		try
		{
			alarms.Clear();
			foreach (DigitalClockAlarm alarm in val.alarms)
			{
				Alarm item = new Alarm(alarm.time.ToTimeSpan(), alarm.active);
				alarms.Add(item);
			}
			muted = val.muted;
			MarkDirty();
			SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!isRinging)
		{
			return 0;
		}
		return base.GetPassthroughAmount(outputSlot);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputAmount == 0)
		{
			ResetIOState();
		}
		SetFlag(Flags.On, HasFlag(Flags.Reserved8));
	}

	public override void ResetIOState()
	{
		isRinging = false;
		SetFlag(Flags.On, b: false);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Expected O, but got Unknown
		base.Save(info);
		info.msg.digitalClock = Pool.Get<DigitalClock>();
		List<DigitalClockAlarm> list = Pool.Get<List<DigitalClockAlarm>>();
		foreach (Alarm alarm in alarms)
		{
			DigitalClockAlarm val = new DigitalClockAlarm();
			val.active = alarm.active;
			val.time = alarm.time.ToFloat();
			list.Add(val);
		}
		info.msg.digitalClock.alarms = list;
		info.msg.digitalClock.muted = muted;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.digitalClock == null)
		{
			return;
		}
		alarms.Clear();
		foreach (DigitalClockAlarm alarm in info.msg.digitalClock.alarms)
		{
			alarms.Add(new Alarm(alarm));
		}
		muted = info.msg.digitalClock.muted;
	}
}


using System;
using ProtoBuf;

public struct Alarm
{
	public TimeSpan time;

	public bool active;

	public Alarm(TimeSpan time, bool active)
	{
		this.time = time;
		this.active = active;
	}

	public Alarm(DigitalClockAlarm alarm)
	{
		time = alarm.time.ToTimeSpan();
		active = alarm.active;
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class DigitSendCodeLock : CodeLock
{
	public ParticleSystem digitsViewParticleSystem;

	public List<Transform> digitsParticleAnchorsFront;

	public List<Transform> digitsParticleAnchorsBack;

	private int __sync_digitsInputted;

	[Sync]
	private int digitsInputted
	{
		[CompilerGenerated]
		get
		{
			return __sync_digitsInputted;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_digitsInputted, value))
			{
				__sync_digitsInputted = value;
				byte nameID = __GetWeaverID("digitsInputted");
				QueueSyncVar(nameID);
			}
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DigitSendCodeLock.OnRpcMessage", 0);
		try
		{
			if (rpc == 3077276815u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - OnDigitEntered "));
				}
				TimeWarning val2 = TimeWarning.New("OnDigitEntered", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3077276815u, "OnDigitEntered", this, player, 4uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3077276815u, "OnDigitEntered", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							OnDigitEntered(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in OnDigitEntered");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(4uL)]
	[RPC_Server.MaxDistance(3f)]
	private void OnDigitEntered(RPCMessage rpc)
	{
		int num = rpc.read.Int16();
		digitsInputted = num;
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			if (Global.developer > 2)
			{
				NetworkableId iD = net.ID;
				Debug.Log((object)("SyncVar Writing: digitsInputted for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_digitsInputted);
			return true;
		}
		return false;
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		return false;
	}

	private byte __GetWeaverID(string propertyName)
	{
		_ = propertyName == "digitsInputted";
		return 0;
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		return true;
	}

	protected override void ResetSyncVars()
	{
		__sync_digitsInputted = 0;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Utility;
using Network;
using ProtoBuf;
using Rust;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;

public class DiverPropulsionVehicle : BaseMountable, IEngineControllerUser, IEntity
{
	[SerializeField]
	[Header("DPV")]
	private Buoyancy buoyancy;

	[SerializeField]
	private GameObjectRef fuelStoragePrefab;

	[SerializeField]
	private Transform propellerTransform;

	[SerializeField]
	private float engineKW = 25f;

	[SerializeField]
	private float turnPower = 0.1f;

	[SerializeField]
	private float depthChangeTargetSpeed = 1f;

	[SerializeField]
	private float engineStartupTime = 0.5f;

	[SerializeField]
	private float idleFuelPerSec = 0.03f;

	[SerializeField]
	private float maxFuelPerSec = 0.15f;

	[SerializeField]
	private GameObject characterWorldCollider;

	[SerializeField]
	private float timeUntilAutoSurface = 600f;

	[SerializeField]
	private float minWaterDepth = 0.75f;

	[Header("DPV - Control stability")]
	[SerializeField]
	private float rotStability = 0.05f;

	[SerializeField]
	private float rotPower = 1f;

	[SerializeField]
	private float rotTargetChangeRate = 1f;

	[SerializeField]
	private float vertStability = 0.1f;

	[SerializeField]
	private float maxPitchDegrees = 20f;

	[SerializeField]
	private float maxRollDegrees = 30f;

	[SerializeField]
	[Header("DPV - UI")]
	private Canvas dashboardCanvas;

	[SerializeField]
	private RustText fuelBarsText;

	[SerializeField]
	private RustText speedometerText;

	[SerializeField]
	private float fuelAmountWarning;

	[SerializeField]
	private RustText batteryWarningText;

	[SerializeField]
	private float healthWarningFraction;

	[SerializeField]
	private RustText healthWarningText;

	[SerializeField]
	[Header("DPV - FX")]
	private Transform leftHandGrip;

	[SerializeField]
	private Transform rightHandGrip;

	[SerializeField]
	private GameObject lightsToggleGroup;

	[SerializeField]
	private DiverPropulsionVehicleAudio dpvAudio;

	[SerializeField]
	private ParticleSystem fxUnderWaterEngineThrustForward;

	[SerializeField]
	private ParticleSystem[] fxUnderWaterEngineThrustForwardSubs;

	[SerializeField]
	private ParticleSystem fxUnderWaterEngineThrustReverse;

	[SerializeField]
	private ParticleSystem[] fxUnderWaterEngineThrustReverseSubs;

	private float waterLevelY;

	private float waterDepthHere;

	private float ourDepthInWaterY;

	public const Flags Flag_Headlights = Flags.Reserved5;

	public const Flags Flag_Stationary = Flags.Reserved6;

	protected VehicleEngineController<DiverPropulsionVehicle> engineController;

	private float _throttle;

	private float _steer;

	private float _upDown;

	private float normalDrag;

	private float highDrag;

	private float targetClimbSpeed;

	private TimeSince timeSinceLastUsed;

	private const float DECAY_TICK_TIME = 60f;

	private float targetPitch;

	private float targetRoll;

	private BoxCollider characterBoxCollider;

	private bool IsInWater => ourDepthInWaterY > 0.1f;

	public VehicleEngineController<DiverPropulsionVehicle>.EngineState EngineState => engineController.CurEngineState;

	public bool LightsOn => HasFlag(Flags.Reserved5);

	public bool IsActive => !HasFlag(Flags.Reserved6);

	public float ThrottleInput
	{
		get
		{
			if (!engineController.IsOn)
			{
				return 0f;
			}
			return _throttle;
		}
		protected set
		{
			_throttle = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public float SteerInput
	{
		get
		{
			return _steer;
		}
		set
		{
			_steer = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public float UpDownInput
	{
		get
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			if (base.isServer)
			{
				if (TimeSince.op_Implicit(timeSinceLastUsed) >= timeUntilAutoSurface)
				{
					return 0.15f;
				}
				if (!engineController.IsOn)
				{
					return Mathf.Max(0f, _upDown);
				}
				return _upDown;
			}
			return _upDown;
		}
		protected set
		{
			_upDown = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DiverPropulsionVehicle.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		EntityFuelSystem entityFuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
		if (base.isServer)
		{
			StorageContainer fuelContainer = entityFuelSystem.GetFuelContainer();
			if ((Object)(object)fuelContainer != (Object)null)
			{
				SetFuelUpdateInventoryCallback(fuelContainer);
			}
		}
		engineController = new VehicleEngineController<DiverPropulsionVehicle>(this, entityFuelSystem, base.isServer, engineStartupTime);
	}

	public override void Load(LoadInfo info)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.diverPropulsionVehicle != null)
		{
			engineController.FuelSystem.SetInstanceID(info.msg.diverPropulsionVehicle.fuelStorageID);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			characterWorldCollider.SetActive(next.HasFlag(Flags.Busy));
		}
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		info = WaterLevel.GetWaterInfo(player.eyes.position, waves: true, volumes: true);
		if (!info.isValid)
		{
			return 0f;
		}
		return 1f;
	}

	private void UpdateWaterInfo()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		GetWaterInfo(this, ((Component)this).transform, out waterLevelY, out waterDepthHere);
		ourDepthInWaterY = waterLevelY - ((Component)this).transform.position.y;
	}

	private static void GetWaterInfo(BaseEntity forEntity, Transform referencePoint, out float surfaceY, out float depth)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(referencePoint.position, waves: true, volumes: true, forEntity);
		if (waterInfo.isValid)
		{
			depth = waterInfo.overallDepth;
			surfaceY = waterInfo.surfaceLevel;
		}
		else
		{
			depth = 0f;
			surfaceY = referencePoint.position.y - 1f;
		}
	}

	private bool WaterIsDeepEnough(bool updateWaterInfo)
	{
		if (updateWaterInfo)
		{
			UpdateWaterInfo();
		}
		return waterDepthHere >= minWaterDepth;
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		normalDrag = rigidBody.drag;
		highDrag = normalDrag * 2.5f;
		characterWorldCollider.SetActive(HasFlag(Flags.Busy));
		characterBoxCollider = characterWorldCollider.GetComponent<BoxCollider>();
		((FacepunchBehaviour)this).InvokeRandomized((Action)SendClientUpdate, 0f, 0.15f, 0.02f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)DPVDecay, Random.Range(30f, 60f), 60f, 6f);
	}

	private void SendClientUpdate()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (IsMounted())
		{
			int arg = Compression.PackVector3ToInt(new Vector3(SteerInput, UpDownInput, ThrottleInput), -1f, 1f);
			ClientRPC(RpcTarget.NetworkGroup("CL_UpdateCosmetics"), arg);
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		SetFlag(Flags.Reserved5, !LightsOn);
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned && GetFuelSystem().CheckNewChild(child))
		{
			SetFuelUpdateInventoryCallback(child as StorageContainer);
		}
	}

	private void SetFuelUpdateInventoryCallback(StorageContainer sc)
	{
		ItemContainer inventory = sc.inventory;
		inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, (Action<Item, bool>)delegate
		{
			SendClientFuelInfo();
		});
	}

	private void UpdateMovementState()
	{
		SetFlag(Flags.Reserved6, rigidBody.IsSleeping() && !AnyMounted());
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("DPV.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			UpdateMovementState();
			if (!IsActive)
			{
				return;
			}
			UpdateWaterInfo();
			rigidBody.drag = (IsMounted() ? normalDrag : highDrag);
			engineController.CheckEngineState();
			if (engineController.IsOn)
			{
				float fuelPerSecond = Mathf.Lerp(idleFuelPerSec, maxFuelPerSec, Mathf.Abs(ThrottleInput));
				if (engineController.TickFuel(fuelPerSecond) > 0)
				{
					SendClientFuelInfo();
				}
			}
			if (!IsInWater)
			{
				return;
			}
			if (WaterIsDeepEnough(updateWaterInfo: false))
			{
				Vector3 localVelocity = GetLocalVelocity();
				float num = Vector3.Dot(localVelocity, ((Component)this).transform.forward);
				float num2 = depthChangeTargetSpeed * UpDownInput;
				float num3 = (((!(UpDownInput > 0f) || !(num2 > targetClimbSpeed) || !(targetClimbSpeed > 0f)) && (!(UpDownInput < 0f) || !(num2 < targetClimbSpeed) || !(targetClimbSpeed < 0f))) ? 4f : 0.7f);
				targetClimbSpeed = Mathf.MoveTowards(targetClimbSpeed, num2, num3 * Time.fixedDeltaTime);
				float num4 = rigidBody.velocity.y - targetClimbSpeed;
				float num5 = buoyancy.buoyancyScale - num4 * 50f * Time.fixedDeltaTime;
				buoyancy.buoyancyScale = Mathf.Clamp(num5, 0.01f, 1f);
				targetPitch = Mathf.Lerp(targetPitch, (0f - UpDownInput) * maxPitchDegrees, Time.fixedDeltaTime * rotTargetChangeRate);
				targetRoll = Mathf.Lerp(targetRoll, (0f - SteerInput) * maxRollDegrees, Time.fixedDeltaTime * rotTargetChangeRate);
				Vector3 right = ((Component)this).transform.right;
				Vector3 forward = ((Component)this).transform.forward;
				Quaternion val2 = Quaternion.AngleAxis(targetPitch, right);
				Vector3 val3 = Quaternion.AngleAxis(targetRoll, forward) * val2 * Vector3.up;
				Vector3 angularVelocity = rigidBody.angularVelocity;
				Vector3 val4 = Vector3.Cross(Quaternion.AngleAxis(((Vector3)(ref angularVelocity)).magnitude * 57.29578f * rotStability / rotPower, rigidBody.angularVelocity) * ((Component)this).transform.up, val3) * rotPower * rotPower;
				rigidBody.AddTorque(val4);
				rigidBody.AddForce(Vector3.up * (0f - num4) * vertStability, (ForceMode)2);
				if (IsOn())
				{
					rigidBody.AddForce(((Component)this).transform.forward * (engineKW * ThrottleInput), (ForceMode)0);
					if (Mathf.Abs(num) > 1f)
					{
						Vector3 normalized = ((Vector3)(ref localVelocity)).normalized;
						float num6 = Mathf.Abs(Vector3.Dot(normalized, ((Component)this).transform.right));
						rigidBody.AddForce(-normalized * (num6 * (0.08f * engineKW) * rigidBody.mass * rigidBody.drag));
					}
					float num7 = turnPower * rigidBody.mass * rigidBody.angularDrag;
					float num8 = Mathf.Min(Mathf.Abs(num) * 0.6f, 1f);
					float num9 = num7 * SteerInput * num8;
					if (num < -1f)
					{
						num9 *= -1f;
					}
					rigidBody.AddTorque(Vector3.up * num9, (ForceMode)0);
				}
			}
			else
			{
				DismountAllPlayers();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return Vector3.zero;
		}
		return rigidBody.velocity;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			ThrottleInput = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			ThrottleInput = -1f;
		}
		else
		{
			ThrottleInput = 0f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			SteerInput = -1f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			SteerInput = 1f;
		}
		else
		{
			SteerInput = 0f;
		}
		if (inputState.IsDown(BUTTON.SPRINT))
		{
			UpDownInput = 1f;
		}
		else if (inputState.IsDown(BUTTON.DUCK))
		{
			UpDownInput = -1f;
		}
		else
		{
			UpDownInput = 0f;
		}
		if (engineController.IsOff && ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD))))
		{
			engineController.TryStartEngine(player);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		info.msg.diverPropulsionVehicle.fuelStorageID = GetFuelSystem().GetInstanceID();
		info.msg.diverPropulsionVehicle.fuelAmount = GetFuelSystem().GetFuelAmount();
		info.msg.diverPropulsionVehicle.fuelTicks = Mathf.RoundToInt(GetFuelSystem().GetFuelFraction() * 12f);
	}

	public IFuelSystem GetFuelSystem()
	{
		return engineController.FuelSystem;
	}

	public bool AdminFixUp()
	{
		if (IsDead())
		{
			return false;
		}
		GetFuelSystem()?.FillFuel();
		SetHealth(MaxHealth());
		SendNetworkUpdate();
		return true;
	}

	public void OnEngineStartFailed()
	{
		ClientRPC(RpcTarget.NetworkGroup("CL_EngineStartFailed"));
	}

	public bool MeetsEngineRequirements()
	{
		return AnyMounted();
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (!PlayerIsMounted(player))
		{
			return !IsOn();
		}
		return true;
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		base.OnPickedUp(createdItem, player);
		if (GetFuelSystem().GetFuelAmount() > 0)
		{
			EntityFuelSystem entityFuelSystem = GetFuelSystem() as EntityFuelSystem;
			player.GiveItem(entityFuelSystem.GetFuelItem(), GiveItemReason.PickedUp);
		}
	}

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		SendClientFuelInfo();
	}

	private void SendClientFuelInfo()
	{
		IFuelSystem fuelSystem = GetFuelSystem();
		byte arg = (byte)Mathf.RoundToInt(GetFuelSystem().GetFuelFraction() * 12f);
		ClientRPC(RpcTarget.NetworkGroup("CL_SetFuel"), (ushort)fuelSystem.GetFuelAmount(), arg);
	}

	private void DPVDecay()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		BaseBoat.WaterVehicleDecay(this, 60f, TimeSince.op_Implicit(timeSinceLastUsed), BaseSubmarine.outsidedecayminutes, BaseSubmarine.deepwaterdecayminutes, MotorRowboat.decaystartdelayminutes, preventDecayIndoors: true);
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (!WaterIsDeepEnough(updateWaterInfo: true))
		{
			ClientRPC(RpcTarget.Player("CL_TooShallowToMount", player));
			return;
		}
		List<Collider> list = Pool.Get<List<Collider>>();
		Vector3 val = default(Vector3);
		Quaternion val2 = default(Quaternion);
		((Component)characterBoxCollider).transform.GetPositionAndRotation(ref val, ref val2);
		GamePhysics.OverlapOBB(new OBB(val + val2 * characterBoxCollider.center, characterBoxCollider.size, val2), list, 1218652417, (QueryTriggerInteraction)1);
		foreach (Collider item in list)
		{
			BaseEntity baseEntity = item.ToBaseEntity();
			if (!((Object)(object)baseEntity != (Object)null) || (!((Object)(object)baseEntity == (Object)(object)this) && !((Object)(object)baseEntity == (Object)(object)player)))
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				ClientRPC(RpcTarget.Player("CL_MountingBlocked", player));
				return;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		base.AttemptMount(player, doMountChecks);
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Assertions;

public class Door : AnimatedBuildingBlock, INotifyTrigger, ISimpleUpgradable
{
	public static readonly Phrase UpgradeBlockedLock = new Phrase("simple.upgrade.blocked_lock", "Remove lock to upgrade.");

	public GameObjectRef knockEffect;

	public bool canTakeLock = true;

	public bool hasHatch;

	public bool canTakeCloser;

	public bool canTakeKnocker;

	public bool canNpcOpen = true;

	public bool canHandOpen = true;

	public bool isSecurityDoor;

	public bool canReverseOpen;

	public TriggerNotify[] vehiclePhysBoxes;

	public bool checkPhysBoxesOnOpen;

	public SoundDefinition vehicleCollisionSfx;

	public GameObject[] BusyColliderRoots;

	public GameObject[] ClosedColliderRoots;

	public bool allowOnCargoShip;

	public List<ItemDefinition> UpgradeItems;

	public Menu.Option UpgradeMenu;

	[ReadOnly]
	[SerializeField]
	private float openAnimLength = 4f;

	[SerializeField]
	[ReadOnly]
	private float closeAnimLength = 4f;

	public const Flags ReverseOpen = Flags.Reserved1;

	public NavMeshModifierVolume NavMeshVolumeAnimals;

	public NavMeshModifierVolume NavMeshVolumeHumanoids;

	public NPCDoorTriggerBox NpcTriggerBox;

	public NavMeshLink NavMeshLink;

	private static int nonWalkableArea = -1;

	private static int animalAgentTypeId = -1;

	private static int humanoidAgentTypeId = -1;

	private float decayResetTimeLast = float.NegativeInfinity;

	private Dictionary<BasePlayer, TimeSince> woundedOpens = new Dictionary<BasePlayer, TimeSince>();

	private Dictionary<BasePlayer, TimeSince> woundedCloses = new Dictionary<BasePlayer, TimeSince>();

	private float nextKnockTime = float.NegativeInfinity;

	private static int openHash = Animator.StringToHash("open");

	private static int closeHash = Animator.StringToHash("close");

	private static int reverseOpenHash = Animator.StringToHash("reverseOpen");

	private static int reverseCloseAnimHash = Animator.StringToHash("CloseReverse");

	private static int reverseOpenAnimHash = Animator.StringToHash("OpenReverse");

	public override bool AllowOnCargoShip => allowOnCargoShip;

	private bool HasVehiclePushBoxes
	{
		get
		{
			if (vehiclePhysBoxes != null)
			{
				return vehiclePhysBoxes.Length != 0;
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Door.OnRpcMessage", 0);
		try
		{
			if (rpc == 2824056853u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoSimpleUpgrade "));
				}
				TimeWarning val2 = TimeWarning.New("DoSimpleUpgrade", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2824056853u, "DoSimpleUpgrade", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2824056853u, "DoSimpleUpgrade", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoSimpleUpgrade(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoSimpleUpgrade");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3999508679u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_CloseDoor "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_CloseDoor", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3999508679u, "RPC_CloseDoor", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_CloseDoor(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_CloseDoor");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1487779344 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_KnockDoor "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_KnockDoor", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1487779344u, "RPC_KnockDoor", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_KnockDoor(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_KnockDoor");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3314360565u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenDoor "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenDoor", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3314360565u, "RPC_OpenDoor", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							RPC_OpenDoor(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_OpenDoor");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3000490601u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ToggleHatch "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ToggleHatch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3000490601u, "RPC_ToggleHatch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc5 = rPCMessage;
							RPC_ToggleHatch(rpc5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in RPC_ToggleHatch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3672787865u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_NotifyWoundedClose "));
				}
				TimeWarning val2 = TimeWarning.New("Server_NotifyWoundedClose", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3672787865u, "Server_NotifyWoundedClose", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_NotifyWoundedClose(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in Server_NotifyWoundedClose");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3730851545u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_NotifyWoundedOpen "));
				}
				TimeWarning val2 = TimeWarning.New("Server_NotifyWoundedOpen", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3730851545u, "Server_NotifyWoundedOpen", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							Server_NotifyWoundedOpen(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in Server_NotifyWoundedOpen");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		if (base.isServer)
		{
			decayResetTimeLast = float.NegativeInfinity;
			if (isSecurityDoor && (Object)(object)NavMeshLink != (Object)null)
			{
				SetNavMeshLinkEnabled(wantsOn: false);
			}
			woundedCloses.Clear();
			woundedOpens.Clear();
		}
	}

	public override void ServerInit()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (nonWalkableArea < 0)
		{
			nonWalkableArea = NavMesh.GetAreaFromName("Not Walkable");
		}
		NavMeshBuildSettings settingsByIndex;
		if (animalAgentTypeId < 0)
		{
			settingsByIndex = NavMesh.GetSettingsByIndex(1);
			animalAgentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		}
		if ((Object)(object)NavMeshVolumeAnimals == (Object)null)
		{
			NavMeshVolumeAnimals = ((Component)this).gameObject.AddComponent<NavMeshModifierVolume>();
			NavMeshVolumeAnimals.area = nonWalkableArea;
			NavMeshVolumeAnimals.AddAgentType(animalAgentTypeId);
			NavMeshVolumeAnimals.center = Vector3.zero;
			NavMeshVolumeAnimals.size = Vector3.one;
		}
		if (HasSlot(Slot.Lock))
		{
			canNpcOpen = false;
		}
		if (!canNpcOpen)
		{
			if (humanoidAgentTypeId < 0)
			{
				settingsByIndex = NavMesh.GetSettingsByIndex(0);
				humanoidAgentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
			}
			if ((Object)(object)NavMeshVolumeHumanoids == (Object)null)
			{
				NavMeshVolumeHumanoids = ((Component)this).gameObject.AddComponent<NavMeshModifierVolume>();
				NavMeshVolumeHumanoids.area = nonWalkableArea;
				NavMeshVolumeHumanoids.AddAgentType(humanoidAgentTypeId);
				NavMeshVolumeHumanoids.center = Vector3.zero;
				NavMeshVolumeHumanoids.size = Vector3.one + Vector3.up + Vector3.forward;
			}
		}
		else if ((Object)(object)NpcTriggerBox == (Object)null)
		{
			if (isSecurityDoor)
			{
				NavMeshObstacle obj = ((Component)this).gameObject.AddComponent<NavMeshObstacle>();
				obj.carving = true;
				obj.center = Vector3.zero;
				obj.size = Vector3.one;
				obj.shape = (NavMeshObstacleShape)1;
			}
			NpcTriggerBox = new GameObject("NpcTriggerBox").AddComponent<NPCDoorTriggerBox>();
			NpcTriggerBox.Setup(this);
		}
		AIInformationZone forPoint = AIInformationZone.GetForPoint(((Component)this).transform.position);
		if ((Object)(object)forPoint != (Object)null && (Object)(object)NavMeshLink == (Object)null)
		{
			NavMeshLink = forPoint.GetClosestNavMeshLink(((Component)this).transform.position);
		}
		DisableVehiclePhysBox();
		UpdateColliderStates();
	}

	public override bool HasSlot(Slot slot)
	{
		if (slot == Slot.Lock && canTakeLock)
		{
			return true;
		}
		switch (slot)
		{
		case Slot.UpperModifier:
			return true;
		case Slot.CenterDecoration:
			if (canTakeCloser)
			{
				return true;
			}
			break;
		}
		if (slot == Slot.LowerCenterDecoration && canTakeKnocker)
		{
			return true;
		}
		return base.HasSlot(slot);
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (!IsOpen())
		{
			return false;
		}
		if (Object.op_Implicit((Object)(object)GetSlot(Slot.Lock)))
		{
			return false;
		}
		if (Object.op_Implicit((Object)(object)GetSlot(Slot.UpperModifier)))
		{
			return false;
		}
		if (Object.op_Implicit((Object)(object)GetSlot(Slot.CenterDecoration)))
		{
			return false;
		}
		if (Object.op_Implicit((Object)(object)GetSlot(Slot.LowerCenterDecoration)))
		{
			return false;
		}
		return base.CanPickup(player);
	}

	public void CloseRequest()
	{
		SetOpen(open: false);
	}

	public void SetOpen(bool open, bool suppressBlockageChecks = false)
	{
		SetFlag(Flags.Open, open);
		SendNetworkUpdateImmediate();
		if (isSecurityDoor && (Object)(object)NavMeshLink != (Object)null)
		{
			SetNavMeshLinkEnabled(open);
		}
		if (!suppressBlockageChecks && (!open || checkPhysBoxesOnOpen))
		{
			StartCheckingForBlockages(open);
		}
	}

	public void SetLocked(bool locked)
	{
		SetFlag(Flags.Locked, b: false);
		SendNetworkUpdateImmediate();
	}

	public bool GetPlayerLockPermission(BasePlayer player)
	{
		BaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;
		if ((Object)(object)baseLock == (Object)null)
		{
			return true;
		}
		return baseLock.GetPlayerLockPermission(player);
	}

	public void SetNavMeshLinkEnabled(bool wantsOn)
	{
		if ((Object)(object)NavMeshLink != (Object)null)
		{
			if (wantsOn)
			{
				((Component)NavMeshLink).gameObject.SetActive(true);
				((Behaviour)NavMeshLink).enabled = true;
			}
			else
			{
				((Behaviour)NavMeshLink).enabled = false;
				((Component)NavMeshLink).gameObject.SetActive(false);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	protected void RPC_OpenDoor(RPCMessage rpc)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		if (!rpc.player.CanInteract(usableWhileCrawling: true) || !canHandOpen || IsOpen() || IsBusy() || IsLocked() || ((FacepunchBehaviour)this).IsInvoking((Action)DelayedDoorOpening))
		{
			return;
		}
		if (rpc.player.IsWounded())
		{
			if (!woundedOpens.ContainsKey(rpc.player) || !(TimeSince.op_Implicit(woundedOpens[rpc.player]) > 2.5f))
			{
				return;
			}
			woundedOpens.Remove(rpc.player);
		}
		BaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;
		if ((Object)(object)baseLock != (Object)null)
		{
			if (!baseLock.OnTryToOpen(rpc.player))
			{
				return;
			}
			if (baseLock.IsLocked() && Time.realtimeSinceStartup - decayResetTimeLast > 60f)
			{
				BuildingBlock buildingBlock = FindLinkedEntity<BuildingBlock>();
				if (Object.op_Implicit((Object)(object)buildingBlock))
				{
					Decay.BuildingDecayTouch(buildingBlock);
				}
				else
				{
					Decay.RadialDecayTouch(((Component)this).transform.position, 40f, 2097408);
				}
				decayResetTimeLast = Time.realtimeSinceStartup;
			}
		}
		if (canReverseOpen)
		{
			Vector3 val = ((Component)this).transform.InverseTransformPoint(((Component)rpc.player).transform.position);
			SetFlag(Flags.Reserved1, val.x > 0f, recursive: false, networkupdate: false);
		}
		if (ShouldDelayOpen(rpc.player, out var delay))
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedDoorOpening, delay);
		}
		else
		{
			SetFlag(Flags.Open, b: true);
			SendNetworkUpdateImmediate();
		}
		if (isSecurityDoor && (Object)(object)NavMeshLink != (Object)null)
		{
			SetNavMeshLinkEnabled(wantsOn: true);
		}
		if (checkPhysBoxesOnOpen)
		{
			StartCheckingForBlockages(isOpening: true);
		}
		Analytics.Azure.OnBaseInteract(rpc.player, this);
		OnPlayerOpenedDoor(rpc.player);
		Interface.CallHook("OnDoorOpened", (object)this, (object)rpc.player);
	}

	private void DelayedDoorOpening()
	{
		SetFlag(Flags.Open, b: true);
		SendNetworkUpdateImmediate();
	}

	protected virtual void OnPlayerOpenedDoor(BasePlayer p)
	{
	}

	protected virtual bool ShouldDelayOpen(BasePlayer forPlayer, out float delay)
	{
		delay = 0f;
		return false;
	}

	private void StartCheckingForBlockages(bool isOpening)
	{
		if (HasVehiclePushBoxes)
		{
			float num = (isOpening ? openAnimLength : closeAnimLength);
			((FacepunchBehaviour)this).Invoke((Action)EnableVehiclePhysBoxes, num * 0.1f);
			((FacepunchBehaviour)this).Invoke((Action)DisableVehiclePhysBox, num * 0.8f);
		}
	}

	private void StopCheckingForBlockages()
	{
		if (HasVehiclePushBoxes)
		{
			ToggleVehiclePushBoxes(state: false);
			((FacepunchBehaviour)this).CancelInvoke((Action)DisableVehiclePhysBox);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_CloseDoor(RPCMessage rpc)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (!rpc.player.CanInteract(usableWhileCrawling: true) || !canHandOpen || !IsOpen() || IsBusy() || IsLocked())
		{
			return;
		}
		if (rpc.player.IsWounded())
		{
			if (!woundedCloses.ContainsKey(rpc.player) || !(TimeSince.op_Implicit(woundedCloses[rpc.player]) > 2.5f))
			{
				return;
			}
			woundedCloses.Remove(rpc.player);
		}
		BaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;
		if (!((Object)(object)baseLock != (Object)null) || baseLock.OnTryToClose(rpc.player))
		{
			SetFlag(Flags.Open, b: false);
			SendNetworkUpdateImmediate();
			if (isSecurityDoor && (Object)(object)NavMeshLink != (Object)null)
			{
				SetNavMeshLinkEnabled(wantsOn: false);
			}
			Analytics.Azure.OnBaseInteract(rpc.player, this);
			StartCheckingForBlockages(isOpening: false);
			Interface.CallHook("OnDoorClosed", (object)this, (object)rpc.player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_KnockDoor(RPCMessage rpc)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		if (!rpc.player.CanInteract(usableWhileCrawling: true) || !knockEffect.isValid || Time.realtimeSinceStartup < nextKnockTime)
		{
			return;
		}
		nextKnockTime = Time.realtimeSinceStartup + 0.5f;
		BaseEntity slot = GetSlot(Slot.LowerCenterDecoration);
		if ((Object)(object)slot != (Object)null)
		{
			DoorKnocker component = ((Component)slot).GetComponent<DoorKnocker>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.Knock(rpc.player);
				return;
			}
		}
		Effect.server.Run(knockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		Interface.CallHook("OnDoorKnocked", (object)this, (object)rpc.player);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_ToggleHatch(RPCMessage rpc)
	{
		if (rpc.player.CanInteract(usableWhileCrawling: true) && hasHatch)
		{
			BaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;
			if (!Object.op_Implicit((Object)(object)baseLock) || baseLock.OnTryToOpen(rpc.player))
			{
				SetFlag(Flags.Reserved3, !HasFlag(Flags.Reserved3));
			}
		}
	}

	private void EnableVehiclePhysBoxes()
	{
		ToggleVehiclePushBoxes(state: true);
	}

	private void DisableVehiclePhysBox()
	{
		ToggleVehiclePushBoxes(state: false);
	}

	private void ToggleVehiclePushBoxes(bool state)
	{
		if (vehiclePhysBoxes == null)
		{
			return;
		}
		TriggerNotify[] array = vehiclePhysBoxes;
		foreach (TriggerNotify triggerNotify in array)
		{
			if ((Object)(object)triggerNotify != (Object)null)
			{
				((Component)triggerNotify).gameObject.SetActive(state);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void Server_NotifyWoundedOpen(RPCMessage msg)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (player.IsWounded())
		{
			if (!woundedOpens.ContainsKey(player))
			{
				woundedOpens.Add(player, default(TimeSince));
			}
			else
			{
				woundedOpens[player] = TimeSince.op_Implicit(0f);
			}
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				CheckTimedOutPlayers(woundedOpens);
			}, 5f);
		}
	}

	private void CheckTimedOutPlayers(Dictionary<BasePlayer, TimeSince> dictionary)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		foreach (KeyValuePair<BasePlayer, TimeSince> item in dictionary)
		{
			if (TimeSince.op_Implicit(item.Value) > 5f)
			{
				list.Add(item.Key);
			}
		}
		foreach (BasePlayer item2 in list)
		{
			if (dictionary.ContainsKey(item2))
			{
				dictionary.Remove(item2);
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void Server_NotifyWoundedClose(RPCMessage msg)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (player.IsWounded())
		{
			if (!woundedCloses.ContainsKey(player))
			{
				woundedCloses.Add(player, default(TimeSince));
			}
			else
			{
				woundedCloses[player] = TimeSince.op_Implicit(0f);
			}
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				CheckTimedOutPlayers(woundedCloses);
			}, 5f);
		}
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		base.OnPickedUp(createdItem, player);
		foreach (BaseEntity child in children)
		{
			if (child is CustomDoorManipulator customDoorManipulator)
			{
				player.GiveItem(ItemManager.CreateByItemID(customDoorManipulator.sourceItem.itemid, 1, 0uL), GiveItemReason.PickedUp);
			}
		}
	}

	private void ReverseDoorAnimation(bool wasOpening, bool reverse)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)model == (Object)null) && !((Object)(object)model.animator == (Object)null))
		{
			AnimatorStateInfo currentAnimatorStateInfo = model.animator.GetCurrentAnimatorStateInfo(0);
			if (reverse)
			{
				model.animator.Play(wasOpening ? reverseCloseAnimHash : reverseOpenAnimHash, 0, 1f - ((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime);
			}
			else
			{
				model.animator.Play(wasOpening ? closeHash : openHash, 0, 1f - ((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime);
			}
		}
	}

	public override float BoundsPadding()
	{
		return 2f;
	}

	protected virtual bool OnlyCheckForVehicles()
	{
		return true;
	}

	protected virtual bool InverseDotCheck()
	{
		return false;
	}

	protected virtual bool CheckOnClose()
	{
		return true;
	}

	public void OnObjects(TriggerNotify trigger)
	{
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer || (!HasFlag(Flags.Open) && !CheckOnClose()))
		{
			return;
		}
		bool flag = false;
		BaseEntity baseEntity = null;
		if (trigger.entityContents != null || trigger.entityContents.Count != 0)
		{
			foreach (BaseEntity entityContent in trigger.entityContents)
			{
				if (OnlyCheckForVehicles())
				{
					if (entityContent is BaseMountable { BlocksDoors: not false } baseMountable)
					{
						flag = true;
						baseEntity = baseMountable;
						break;
					}
					if (entityContent is BaseVehicleModule baseVehicleModule && (Object)(object)baseVehicleModule.Vehicle != (Object)null && baseVehicleModule.Vehicle.BlocksDoors)
					{
						flag = true;
						baseEntity = baseVehicleModule.VehicleParent();
						break;
					}
				}
				else if (!((Object)(object)entityContent == (Object)null) && entityContent.IsValid() && !((Object)(object)entityContent == (Object)(object)this) && !((Object)(object)parentEntity.Get(serverside: true) == (Object)(object)entityContent))
				{
					flag = true;
					baseEntity = entityContent;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		bool flag2 = HasFlag(Flags.Open);
		bool flag3 = HasFlag(Flags.Reserved1);
		if (checkPhysBoxesOnOpen && !canReverseOpen)
		{
			bool flag4 = true;
			TriggerNotify[] array = vehiclePhysBoxes;
			foreach (TriggerNotify triggerNotify in array)
			{
				Vector3 forward = ((Component)triggerNotify).transform.forward;
				Vector3 val = ((Component)baseEntity).transform.position - ((Component)triggerNotify).transform.position;
				float num = Vector3.Dot(forward, ((Vector3)(ref val)).normalized);
				if (InverseDotCheck() ? (num < 0f) : (num > 0f))
				{
					flag4 = false;
					break;
				}
			}
			if (flag4 == flag2 || flag4 == flag3)
			{
				return;
			}
		}
		ReverseDoorAnimation(flag2, flag3);
		SetOpen(!flag2, suppressBlockageChecks: true);
		StopCheckingForBlockages();
		ClientRPC(RpcTarget.NetworkGroup("OnDoorInterrupted"), flag2, flag3);
	}

	public void OnEmpty()
	{
	}

	protected override void ApplySubAnimationParameters(bool init, Animator toAnimator)
	{
		base.ApplySubAnimationParameters(init, toAnimator);
		if (canReverseOpen)
		{
			toAnimator.SetBool(reverseOpenHash, HasFlag(Flags.Reserved1));
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			BaseEntity slot = GetSlot(Slot.UpperModifier);
			if (Object.op_Implicit((Object)(object)slot))
			{
				((Component)slot).SendMessage("Think");
			}
		}
		UpdateColliderStates();
	}

	private void UpdateColliderStates()
	{
		UpdateBusyColliderState();
		UpdateClosedColliderState();
	}

	private void UpdateBusyColliderState()
	{
		if (BusyColliderRoots == null)
		{
			return;
		}
		bool flag = HasFlag(Flags.Busy);
		GameObject[] busyColliderRoots = BusyColliderRoots;
		foreach (GameObject val in busyColliderRoots)
		{
			if ((Object)(object)val != (Object)null && val.gameObject.activeSelf != flag)
			{
				val.gameObject.SetActive(flag);
			}
		}
	}

	private void UpdateClosedColliderState()
	{
		if (ClosedColliderRoots == null)
		{
			return;
		}
		bool flag = !HasFlag(Flags.Open) && !HasFlag(Flags.Busy);
		GameObject[] closedColliderRoots = ClosedColliderRoots;
		foreach (GameObject val in closedColliderRoots)
		{
			if ((Object)(object)val != (Object)null && val.gameObject.activeSelf != flag)
			{
				val.gameObject.SetActive(flag);
			}
		}
	}

	public List<ItemDefinition> GetUpgradeItems()
	{
		return UpgradeItems;
	}

	public bool CanUpgrade(BasePlayer player, ItemDefinition upgradeItem)
	{
		if (IsOpen())
		{
			return false;
		}
		return SimpleUpgrade.CanUpgrade(this, upgradeItem, player);
	}

	public bool HasLock()
	{
		return (Object)(object)GetSlot(Slot.Lock) != (Object)null;
	}

	public void DoUpgrade(BasePlayer player, ItemDefinition upgradeItem)
	{
		SimpleUpgrade.DoUpgrade(this, player, upgradeItem);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void DoSimpleUpgrade(RPCMessage msg)
	{
		if (base.SecondsSinceAttacked < 30f)
		{
			msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString("N0"));
			return;
		}
		int num = msg.read.Int32();
		if (num >= 0 && num < UpgradeItems.Count && CanUpgrade(msg.player, UpgradeItems[num]))
		{
			DoUpgrade(msg.player, UpgradeItems[num]);
		}
	}

	public bool UpgradingEnabled()
	{
		if (UpgradeItems != null)
		{
			return UpgradeItems.Count > 0;
		}
		return false;
	}

	public bool CostIsItem()
	{
		return true;
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class DoorCloser : BaseEntity
{
	[ItemSelector]
	public ItemDefinition itemType;

	public float delay = 3f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DoorCloser.OnRpcMessage", 0);
		try
		{
			if (rpc == 342802563 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Take "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Take", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(342802563u, "RPC_Take", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_Take(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Take");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float BoundsPadding()
	{
		return 1f;
	}

	public void Think()
	{
		((FacepunchBehaviour)this).Invoke((Action)SendClose, delay);
	}

	public void SendClose()
	{
		BaseEntity baseEntity = GetParentEntity();
		if (children != null)
		{
			foreach (BaseEntity child in children)
			{
				if ((Object)(object)child != (Object)null)
				{
					((FacepunchBehaviour)this).Invoke((Action)SendClose, delay);
					return;
				}
			}
		}
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			((Component)baseEntity).SendMessage("CloseRequest");
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_Take(RPCMessage rpc)
	{
		if (Interface.CallHook("ICanPickupEntity", (object)rpc.player, (object)this) != null || !rpc.player.CanInteract() || !rpc.player.CanBuild())
		{
			return;
		}
		Door door = GetDoor();
		if (!((Object)(object)door == (Object)null) && door.GetPlayerLockPermission(rpc.player))
		{
			Item item = ItemManager.Create(itemType, 1, skinID);
			if (item != null)
			{
				rpc.player.GiveItem(item);
			}
			Kill();
		}
	}

	public Door GetDoor()
	{
		return GetParentEntity() as Door;
	}
}


using System;
using Network;
using Oxide.Core;
using UnityEngine;

public class DoorKnocker : BaseCombatEntity
{
	public Animator knocker1;

	public Animator knocker2;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DoorKnocker.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void Knock(BasePlayer player)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.NetworkGroup("ClientKnock"), ((Component)player).transform.position);
		Interface.CallHook("OnDoorKnocked", (object)this, (object)player);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class DroppedItemContainer : BaseCombatEntity, LootPanel.IHasLootPanel, IContainerSounds, ILootableEntity, IInventoryProvider
{
	public string lootPanelName = "generic";

	public int maxItemCount = 36;

	[NonSerialized]
	public ulong playerSteamID;

	[NonSerialized]
	public string _playerName;

	public bool ItemBasedDespawn;

	public bool onlyOwnerLoot;

	public bool buryLeftoverItems;

	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	public const Flags HasItems = Flags.Reserved1;

	public const Flags HasBeenOpened = Flags.Reserved2;

	public ItemContainer inventory;

	public Phrase LootPanelTitle => Phrase.op_Implicit(playerName);

	public string playerName
	{
		get
		{
			if (playerSteamID == 0L)
			{
				return "";
			}
			return NameHelper.Get(playerSteamID, _playerName, base.isClient);
		}
		set
		{
			_playerName = value;
		}
	}

	public ulong LastLootedBy { get; set; }

	public BasePlayer LastLootedByPlayer { get; set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DroppedItemContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		if ((baseEntity.InSafeZone() || InSafeZone()) && (ulong)baseEntity.userID != playerSteamID)
		{
			return false;
		}
		if (onlyOwnerLoot && (ulong)baseEntity.userID != playerSteamID)
		{
			return false;
		}
		SetFlag(Flags.Reserved2, b: true);
		EvaluateBagConditions();
		return base.OnStartBeingLooted(baseEntity);
	}

	public override void ServerInit()
	{
		ResetRemovalTime();
		base.ServerInit();
	}

	public void RemoveMe()
	{
		if (IsOpen())
		{
			ResetRemovalTime();
			return;
		}
		try
		{
			BuryLeftoverItems();
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		Kill();
	}

	private void BuryLeftoverItems()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("DroppedItemContainer.BuryLeftoverItems", 0);
		try
		{
			if (!buryLeftoverItems || inventory == null)
			{
				return;
			}
			Vector3 position = ((Component)this).transform.position;
			foreach (Item item in inventory.itemList)
			{
				if (item.IsValid())
				{
					BuriedItems.Instance.Register(item, position);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void EvaluateBagConditions()
	{
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		SetFlag(Flags.Reserved1, inventory != null && inventory.itemList.Count > 0 && inventory.itemList.Count > 3 && (Object)(object)component != (Object)null && component.IsSleeping());
	}

	public void ResetRemovalTime(float dur)
	{
		TimeWarning val = TimeWarning.New("ResetRemovalTime", 0);
		try
		{
			((FacepunchBehaviour)this).Invoke((Action)RemoveMe, dur);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ResetRemovalTime()
	{
		ResetRemovalTime(CalculateRemovalTime());
	}

	public float CalculateRemovalTime()
	{
		if (!ItemBasedDespawn)
		{
			return Server.itemdespawn * 16f * Server.itemdespawn_container_scale;
		}
		float num = Server.itemdespawn_quick;
		if (inventory != null)
		{
			foreach (Item item in inventory.itemList)
			{
				num = Mathf.Max(num, item.GetDespawnDuration());
			}
		}
		return num;
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (inventory != null)
		{
			Pool.Free<ItemContainer>(ref inventory);
		}
	}

	private ItemContainer CreateContainer()
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.ServerInitialize(null, maxItemCount);
		itemContainer.GiveUID();
		itemContainer.entityOwner = this;
		itemContainer.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
		return itemContainer;
	}

	public void TakeFrom(ItemContainer[] source, float destroyPercent)
	{
		Assert.IsTrue(inventory == null, "Initializing Twice");
		inventory = CreateContainer();
		destroyPercent = Mathf.Clamp01(destroyPercent);
		float movePercent = 1f - destroyPercent;
		TakeFractionOfItems(source, inventory, movePercent);
		inventory.capacity = inventory.itemList.Count;
		ResetRemovalTime();
	}

	public static void TakeFractionOfItems(ItemContainer[] source, ItemContainer output, float movePercent)
	{
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		output.containerVolume = source.Max((ItemContainer x) => x.containerVolume);
		List<Item> list = Pool.Get<List<Item>>();
		ItemContainer[] array = source;
		foreach (ItemContainer obj in array)
		{
			obj.RemoveFractionOfContainer(list, movePercent);
			obj.MergeAllStacks();
		}
		foreach (Item item in list)
		{
			if (item.MoveToContainer(output))
			{
				continue;
			}
			bool flag = false;
			array = source;
			foreach (ItemContainer newcontainer in array)
			{
				if (item.MoveToContainer(newcontainer))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				item.DropAndTossUpwards(output.dropPosition);
			}
		}
		Pool.Free<Item>(ref list, false);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract() && Interface.CallHook("CanLootEntity", (object)player, (object)this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", (object)player, (object)this);
		if (inventory == null || inventory.itemList == null || inventory.itemList.Count == 0)
		{
			Kill();
		}
		else
		{
			ResetRemovalTime();
			SetFlag(Flags.Open, b: false);
			SendNetworkUpdate();
		}
		EvaluateBagConditions();
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		Debug.Assert(inventory == null, "Double init of inventory!");
		inventory = Pool.Get<ItemContainer>();
		inventory.entityOwner = this;
		inventory.ServerInitialize(null, 0);
		inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.lootableCorpse = Pool.Get<LootableCorpse>();
		info.msg.lootableCorpse.playerName = playerName;
		info.msg.lootableCorpse.playerID = playerSteamID;
		if (info.forDisk)
		{
			if (inventory != null)
			{
				info.msg.storageBox = Pool.Get<StorageBox>();
				info.msg.storageBox.contents = inventory.Save();
			}
			else
			{
				Debug.LogWarning((object)("Dropped item container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public void GetAllInventories(List<ItemContainer> list)
	{
		list.Add(inventory);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.lootableCorpse != null)
		{
			playerName = info.msg.lootableCorpse.playerName;
			playerSteamID = info.msg.lootableCorpse.playerID;
		}
		if (info.msg.storageBox != null)
		{
			if (inventory != null)
			{
				inventory.Load(info.msg.storageBox.contents);
			}
			else
			{
				Debug.LogWarning((object)("Dropped item container without inventory: " + ((object)this).ToString()));
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class DudTimedExplosive : TimedExplosive, IIgniteable, ISplashable
{
	public GameObjectRef fizzleEffect;

	public GameObject wickSpark;

	public AudioSource wickSound;

	public float dudChance = 0.4f;

	[ItemSelector]
	public ItemDefinition itemToGive;

	[NonSerialized]
	private float explodeTime;

	public bool becomeDudInWater;

	protected override bool AlwaysRunWaterCheck => becomeDudInWater;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("DudTimedExplosive.OnRpcMessage", 0);
		try
		{
			if (rpc == 2436818324u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Pickup "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Pickup", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2436818324u, "RPC_Pickup", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Pickup(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Pickup");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private bool IsWickBurning()
	{
		return HasFlag(Flags.On);
	}

	public override void WaterCheck()
	{
		if (becomeDudInWater && WaterFactor() >= 0.5f)
		{
			if ((Object)(object)creatorEntity != (Object)null && creatorEntity.IsNpc)
			{
				base.Explode();
				return;
			}
			BecomeDud();
			if (((FacepunchBehaviour)this).IsInvoking((Action)WaterCheck))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)WaterCheck);
			}
			if (((FacepunchBehaviour)this).IsInvoking((Action)Explode))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Explode);
			}
		}
		else
		{
			base.WaterCheck();
		}
	}

	public override float GetRandomTimerTime()
	{
		float randomTimerTime = base.GetRandomTimerTime();
		float num = 1f;
		if (Random.Range(0f, 1f) <= 0.15f)
		{
			num = 0.334f;
		}
		else if (Random.Range(0f, 1f) <= 0.15f)
		{
			num = 3f;
		}
		return randomTimerTime * num;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_Pickup(RPCMessage msg)
	{
		if (IsWickBurning())
		{
			return;
		}
		BasePlayer player = msg.player;
		if (Random.Range(0f, 1f) >= 0.5f && HasParent())
		{
			SetFuse(Random.Range(2.5f, 3f));
			return;
		}
		Item item = ItemManager.Create(itemToGive, 1, skinID);
		if (ItemOwnership.IsValid())
		{
			item.SetItemOwnership(ItemOwnership);
		}
		player.GiveItem(item);
		Kill();
	}

	public override void SetFuse(float fuseLength)
	{
		base.SetFuse(fuseLength);
		explodeTime = Time.realtimeSinceStartup + fuseLength;
		SetFlag(Flags.On, b: true);
		SendNetworkUpdate();
		((FacepunchBehaviour)this).CancelInvoke((Action)base.KillMessage);
	}

	public override void Explode()
	{
		if ((Object)(object)creatorEntity != (Object)null && creatorEntity.IsNpc)
		{
			base.Explode();
		}
		else if (Random.Range(0f, 1f) < dudChance && Interface.CallHook("OnExplosiveDud", (object)this) == null)
		{
			BecomeDud();
		}
		else
		{
			base.Explode();
		}
	}

	public override bool CanStickTo(BaseEntity entity)
	{
		if (base.CanStickTo(entity))
		{
			return IsWickBurning();
		}
		return false;
	}

	public virtual void BecomeDud()
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		EntityRef entityRef = parentEntity;
		while (entityRef.IsValid(base.isServer) && !flag)
		{
			BaseEntity baseEntity = entityRef.Get(base.isServer);
			if (baseEntity.syncPosition)
			{
				flag = true;
			}
			entityRef = baseEntity.parentEntity;
		}
		if (flag)
		{
			SetParent(null, worldPositionStays: true);
		}
		SetFlag(Flags.On, b: false);
		if (flag)
		{
			SetMotionEnabled(wantsMotion: true);
		}
		if (fizzleEffect.isValid)
		{
			Effect.server.Run(fizzleEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
		SendNetworkUpdate();
		((FacepunchBehaviour)this).CancelInvoke((Action)base.KillMessage);
		((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 1200f);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.dudExplosive = Pool.Get<DudExplosive>();
		info.msg.dudExplosive.fuseTimeLeft = explodeTime - Time.realtimeSinceStartup;
	}

	public void Ignite(Vector3 fromPos)
	{
		SetFuse(GetRandomTimerTime());
		ReceiveCollisionMessages(b: true);
		if (waterCausesExplosion)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)WaterCheck, 0f, 0.5f);
		}
	}

	public bool CanIgnite()
	{
		return !HasFlag(Flags.On);
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (!base.IsDestroyed)
		{
			return HasFlag(Flags.On);
		}
		return false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		BecomeDud();
		if (((FacepunchBehaviour)this).IsInvoking((Action)Explode))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)Explode);
		}
		return 1;
	}

	protected override bool ShouldBypassClippingWallCheck()
	{
		if (!IsWickBurning())
		{
			return true;
		}
		return false;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.dudExplosive != null)
		{
			explodeTime = Time.realtimeSinceStartup + info.msg.dudExplosive.fuseTimeLeft;
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class EasterBasket : AttackEntity
{
	public GameObjectRef eggProjectile;

	public ItemDefinition ammoType;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("EasterBasket.OnRpcMessage", 0);
		try
		{
			if (rpc == 3763591455u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ThrowEgg "));
				}
				TimeWarning val2 = TimeWarning.New("ThrowEgg", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3763591455u, "ThrowEgg", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ThrowEgg(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ThrowEgg");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return player.GetInheritedProjectileVelocity(direction);
	}

	public Item GetAmmo()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return null;
		}
		Item item = ownerPlayer.inventory.containerMain.FindItemByItemID(ammoType.itemid);
		if (item == null)
		{
			item = ownerPlayer.inventory.containerBelt.FindItemByItemID(ammoType.itemid);
		}
		return item;
	}

	public bool HasAmmo()
	{
		return GetAmmo() != null;
	}

	public void UseAmmo()
	{
		GetAmmo()?.UseItem();
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void ThrowEgg(RPCMessage msg)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if (!HasAmmo())
			{
				return;
			}
			UseAmmo();
			Vector3 val = msg.read.Vector3();
			Vector3 val2 = msg.read.Vector3();
			Vector3 val3 = ((Vector3)(ref val2)).normalized;
			bool num = msg.read.Bit();
			BaseEntity mounted = player.GetParentEntity();
			if ((Object)(object)mounted == (Object)null)
			{
				mounted = player.GetMounted();
			}
			if (num)
			{
				if ((Object)(object)mounted != (Object)null)
				{
					val = ((Component)mounted).transform.TransformPoint(val);
					val3 = ((Component)mounted).transform.TransformDirection(val3);
				}
				else
				{
					val = player.eyes.position;
					val3 = player.eyes.BodyForward();
				}
			}
			if (!ValidateEyePos(player, val))
			{
				return;
			}
			float num2 = 2f;
			if (num2 > 0f)
			{
				val3 = AimConeUtil.GetModifiedAimConeDirection(num2, val3);
			}
			float num3 = 1f;
			RaycastHit val4 = default(RaycastHit);
			if (Physics.Raycast(val, val3, ref val4, num3, 1237003025))
			{
				num3 = ((RaycastHit)(ref val4)).distance - 0.1f;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(eggProjectile.resourcePath, val + val3 * num3);
			if (!((Object)(object)baseEntity == (Object)null))
			{
				baseEntity.creatorEntity = player;
				ServerProjectile component = ((Component)baseEntity).GetComponent<ServerProjectile>();
				if (Object.op_Implicit((Object)(object)component))
				{
					component.InitializeVelocity(GetInheritedVelocity(player, val3) + val3 * component.speed);
				}
				baseEntity.Spawn();
				GetOwnerItem()?.LoseCondition(Random.Range(1f, 2f));
			}
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class ElectricalBranch : IOEntity
{
	public int branchAmount = 2;

	public GameObjectRef branchPanelPrefab;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ElectricalBranch.OnRpcMessage", 0);
		try
		{
			if (rpc == 4207410429u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetBranchOffPower "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetBranchOffPower", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4207410429u, "RPC_SetBranchOffPower", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4207410429u, "RPC_SetBranchOffPower", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_SetBranchOffPower(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_SetBranchOffPower");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void RPC_SetBranchOffPower(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && player.CanBuild())
		{
			int branchOffPower = msg.read.Int32();
			SetBranchOffPower(branchOffPower);
		}
	}

	public void SetBranchOffPower(int power)
	{
		power = Mathf.Clamp(power, 1, 10000000);
		branchAmount = power;
		MarkDirtyForceUpdateOutputs();
		SendNetworkUpdate();
	}

	public override bool AllowDrainFrom(int outputSlot)
	{
		return true;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return outputSlot switch
		{
			0 => Mathf.Clamp(GetCurrentEnergy() - branchAmount, 0, GetCurrentEnergy()), 
			1 => Mathf.Min(GetCurrentEnergy(), branchAmount), 
			_ => 0, 
		};
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericInt1 = branchAmount;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			branchAmount = info.msg.ioEntity.genericInt1;
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class ElectricSwitch : IOEntity
{
	public bool isToggleSwitch;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ElectricSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 3043863856u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Switch "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Switch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3043863856u, "RPC_Switch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Switch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Switch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex == 0)
		{
			return IsOn();
		}
		return false;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void ResetIOState()
	{
		SetFlag(Flags.On, b: false);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsOn())
		{
			return 0;
		}
		return GetCurrentEnergy();
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		if (inputSlot != 0)
		{
			return currentEnergy;
		}
		return base.CalculateCurrentEnergy(inputAmount, inputSlot);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 1 && inputAmount > 0)
		{
			SetSwitch(state: true);
		}
		if (inputSlot == 2 && inputAmount > 0)
		{
			SetSwitch(state: false);
		}
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Busy, b: false);
	}

	public virtual void SetSwitch(bool state)
	{
		if (state != IsOn())
		{
			SetFlag(Flags.On, state);
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)UnBusy, 0.5f);
			SendNetworkUpdateImmediate();
			MarkDirty();
		}
	}

	public void Flip()
	{
		SetSwitch(!IsOn());
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Switch(RPCMessage msg)
	{
		if (Interface.CallHook("OnSwitchToggle", (object)this, (object)msg.player) == null)
		{
			bool @switch = msg.read.Bool();
			SetSwitch(@switch);
			Interface.CallHook("OnSwitchToggled", (object)this, (object)msg.player);
		}
	}

	private void UnBusy()
	{
		SetFlag(Flags.Busy, b: false);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ElevatorLift : BaseCombatEntity
{
	public GameObject DescendingHurtTrigger;

	public GameObject MovementCollider;

	public ElevatorButton[] Buttons;

	public Transform UpButtonPoint;

	public Transform DownButtonPoint;

	public Transform GoTopButtonPoint;

	public Transform GoBottomButtonPoint;

	public TriggerNotify VehicleTrigger;

	public GameObjectRef LiftArrivalScreenBounce;

	public SoundDefinition liftMovementLoopDef;

	public SoundDefinition liftMovementStartDef;

	public SoundDefinition liftMovementStopDef;

	public SoundDefinition liftMovementAccentSoundDef;

	public GameObjectRef liftButtonPressedEffect;

	public float movementAccentMinInterval = 0.75f;

	public float movementAccentMaxInterval = 3f;

	private Sound liftMovementLoopSound;

	private float nextMovementAccent;

	public Vector3 lastPosition;

	public List<BaseEntity> vehicleWhitelist;

	private EntityRef<Elevator> ownerElevator;

	public const Flags PressedUp = Flags.Reserved1;

	public const Flags PressedDown = Flags.Reserved2;

	public const Flags Express = Flags.Reserved6;

	public const Flags FlagCanMove = Flags.Reserved5;

	private HashSet<uint> vehiclePrefabWhitelist = new HashSet<uint>();

	private Elevator owner => ownerElevator.Get(base.isServer);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ElevatorLift.OnRpcMessage", 0);
		try
		{
			if (rpc == 4061236510u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RaiseLowerFloor "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RaiseLowerFloor", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4061236510u, "Server_RaiseLowerFloor", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_RaiseLowerFloor(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_RaiseLowerFloor");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.elevatorLift != null)
		{
			ownerElevator.uid = info.msg.elevatorLift.owner;
		}
	}

	public void SetOwnerElevator(Elevator e)
	{
		ownerElevator.Set(e);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.elevatorLift = Pool.Get<ElevatorLift>();
		if ((Object)(object)owner != (Object)null)
		{
			info.msg.elevatorLift.owner = ownerElevator.uid;
			info.msg.elevatorLift.topElevatorHeight = ((Component)owner).transform.position.y;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		FillVehicleWhitelist();
		ToggleHurtTrigger(state: false);
	}

	public void ToggleHurtTrigger(bool state)
	{
		if ((Object)(object)DescendingHurtTrigger != (Object)null)
		{
			DescendingHurtTrigger.SetActive(state);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void Server_RaiseLowerFloor(RPCMessage msg)
	{
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		Elevator.Direction direction = (Elevator.Direction)msg.read.Int32();
		bool flag = msg.read.Unread > 0 && msg.read.Bit();
		if (Interface.CallHook("OnElevatorButtonPress", (object)this, (object)msg.player, (object)direction, (object)flag) == null)
		{
			SetFlag((direction == Elevator.Direction.Up) ? Flags.Reserved1 : Flags.Reserved2, b: true);
			SetFlag(Flags.Reserved6, flag);
			owner.Server_RaiseLowerElevator(direction, flag);
			((FacepunchBehaviour)this).Invoke((Action)ClearDirection, 0.7f);
			if (liftButtonPressedEffect.isValid)
			{
				Effect.server.Run(liftButtonPressedEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
		}
	}

	private void FillVehicleWhitelist()
	{
		foreach (BaseEntity item in vehicleWhitelist)
		{
			vehiclePrefabWhitelist.Add(item.prefabID);
		}
	}

	private void ClearDirection()
	{
		SetFlag(Flags.Reserved1, b: false);
		SetFlag(Flags.Reserved2, b: false);
		SetFlag(Flags.Reserved6, b: false);
	}

	public override void Hurt(HitInfo info)
	{
		if ((Object)(object)owner != (Object)null)
		{
			owner.Hurt(info);
		}
	}

	public override void AdminKill()
	{
		if ((Object)(object)owner != (Object)null)
		{
			owner.AdminKill();
		}
		else
		{
			base.AdminKill();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		ClearDirection();
	}

	public bool CanMove()
	{
		object obj = Interface.CallHook("CanElevatorLiftMove", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (VehicleTrigger.HasContents && VehicleTrigger.entityContents != null)
		{
			foreach (BaseEntity entityContent in VehicleTrigger.entityContents)
			{
				if (!vehiclePrefabWhitelist.Contains(entityContent.prefabID))
				{
					return false;
				}
			}
		}
		return true;
	}

	public virtual void NotifyNewFloor(int newFloor, int totalFloors)
	{
	}

	private void ToggleMovementCollider(bool state)
	{
		if ((Object)(object)MovementCollider != (Object)null)
		{
			MovementCollider.SetActive(state);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		ToggleMovementCollider(!next.HasFlag(Flags.Busy));
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class EngineSwitch : BaseEntity
{
	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("EngineSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 1249530220 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartEngine "));
				}
				TimeWarning val2 = TimeWarning.New("StartEngine", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1249530220u, "StartEngine", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							StartEngine(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in StartEngine");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1739656243 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StopEngine "));
				}
				TimeWarning val2 = TimeWarning.New("StopEngine", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1739656243u, "StopEngine", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							StopEngine(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in StopEngine");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void StopEngine(RPCMessage msg)
	{
		MiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;
		if (Object.op_Implicit((Object)(object)miningQuarry) && Interface.CallHook("OnQuarryToggle", (object)miningQuarry, (object)msg.player) == null)
		{
			miningQuarry.EngineSwitch(isOn: false);
			Interface.CallHook("OnQuarryToggled", (object)miningQuarry, (object)msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void StartEngine(RPCMessage msg)
	{
		MiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;
		if (Object.op_Implicit((Object)(object)miningQuarry) && Interface.CallHook("OnQuarryToggle", (object)miningQuarry, (object)msg.player) == null)
		{
			miningQuarry.EngineSwitch(isOn: true);
			Interface.CallHook("OnQuarryToggled", (object)miningQuarry, (object)msg.player);
		}
	}
}


using System;
using System.Linq;
using ConVar;
using Facepunch.Rust;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class EntityPrivilege : SimplePrivilege
{
	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("EntityPrivilege.OnRpcMessage", 0);
		try
		{
			if (rpc == 1092560690 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AddSelfAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("AddSelfAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1092560690u, "AddSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							AddSelfAuthorize(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AddSelfAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 253307592 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearList "));
				}
				TimeWarning val2 = TimeWarning.New("ClearList", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(253307592u, "ClearList", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							ClearList(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ClearList");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3617985969u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RemoveSelfAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("RemoveSelfAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3617985969u, "RemoveSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							RemoveSelfAuthorize(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RemoveSelfAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		if (rpc.player.CanInteract())
		{
			AddPlayer(rpc.player);
			SendNetworkUpdate();
		}
	}

	public void AddPlayer(BasePlayer player)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		if (!AtMaxAuthCapacity())
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == (ulong)player.userID);
			PlayerNameID val = new PlayerNameID();
			val.userid = player.userID;
			val.username = player.displayName;
			authorizedPlayers.Add(val);
			Analytics.Azure.OnEntityAuthChanged(this, player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", player.userID);
			UpdateMaxAuthCapacity();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		if (rpc.player.CanInteract())
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == (ulong)rpc.player.userID);
			Analytics.Azure.OnEntityAuthChanged(this, rpc.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void ClearList(RPCMessage rpc)
	{
		if (rpc.player.CanInteract())
		{
			authorizedPlayers.Clear();
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ExcavatorArm : BaseEntity
{
	public float yaw1;

	public float yaw2;

	public Transform wheel;

	public float wheelSpeed = 2f;

	public float turnSpeed = 0.1f;

	public Transform miningOffset;

	public GameObjectRef bounceEffect;

	public LightGroupAtTime lights;

	public Material conveyorMaterial;

	public float beltSpeedMax = 0.1f;

	public const Flags Flag_HasPower = Flags.Reserved8;

	public List<ExcavatorOutputPile> outputPiles;

	public SoundDefinition miningStartButtonSoundDef;

	[Header("Production")]
	public ItemAmount[] resourcesToMine;

	public float resourceProductionTickRate = 3f;

	public float timeForFullResources = 120f;

	public ItemAmount[] pendingResources;

	public Phrase excavatorPhrase;

	public float movedAmount;

	public float currentTurnThrottle;

	public float lastMoveYaw;

	private float excavatorStartTime;

	private float nextNotificationTime;

	public int resourceMiningIndex;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ExcavatorArm.OnRpcMessage", 0);
		try
		{
			if (rpc == 2059417170 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetResourceTarget "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetResourceTarget", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2059417170u, "RPC_SetResourceTarget", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_SetResourceTarget(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_SetResourceTarget");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2882020740u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_StopMining "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_StopMining", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2882020740u, "RPC_StopMining", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_StopMining(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_StopMining");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsPowered()
	{
		return HasFlag(Flags.Reserved8);
	}

	public bool IsMining()
	{
		return IsOn();
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public void FixedUpdate()
	{
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient)
		{
			bool flag = IsMining() && IsPowered();
			float num = (flag ? 1f : 0f);
			currentTurnThrottle = Mathf.Lerp(currentTurnThrottle, num, Time.fixedDeltaTime * (flag ? 0.333f : 1f));
			if (Mathf.Abs(num - currentTurnThrottle) < 0.025f)
			{
				currentTurnThrottle = num;
			}
			movedAmount += Time.fixedDeltaTime * turnSpeed * currentTurnThrottle;
			float num2 = (Mathf.Sin(movedAmount) + 1f) / 2f;
			float num3 = Mathf.Lerp(yaw1, yaw2, num2);
			if (num3 != lastMoveYaw)
			{
				lastMoveYaw = num3;
				((Component)this).transform.rotation = Quaternion.Euler(0f, num3, 0f);
				((Component)this).transform.hasChanged = true;
			}
		}
	}

	public void BeginMining()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!IsPowered())
		{
			return;
		}
		SetFlag(Flags.On, b: true);
		((FacepunchBehaviour)this).InvokeRepeating((Action)ProduceResources, resourceProductionTickRate, resourceProductionTickRate);
		if (Time.time > nextNotificationTime)
		{
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if (!current.IsNpc && current.IsConnected && !current.IsInTutorial)
					{
						current.ShowToast(GameTip.Styles.Server_Event, excavatorPhrase, false);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			nextNotificationTime = Time.time + 60f;
		}
		ExcavatorServerEffects.SetMining(isMining: true);
		excavatorStartTime = GetNetworkTime();
		Interface.CallHook("OnExcavatorMiningToggled", (object)this);
	}

	public void StopMining()
	{
		ExcavatorServerEffects.SetMining(isMining: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ProduceResources);
		SetFlag(Flags.On, b: false);
		Interface.CallHook("OnExcavatorMiningToggled", (object)this);
	}

	public void ProduceResources()
	{
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		float num = resourceProductionTickRate / timeForFullResources;
		float num2 = resourcesToMine[resourceMiningIndex].amount * num;
		pendingResources[resourceMiningIndex].amount += num2;
		ItemAmount[] array = pendingResources;
		foreach (ItemAmount itemAmount in array)
		{
			if (!(itemAmount.amount >= (float)outputPiles.Count))
			{
				continue;
			}
			int num3 = Mathf.FloorToInt(itemAmount.amount / (float)outputPiles.Count);
			itemAmount.amount -= num3 * 2;
			foreach (ExcavatorOutputPile outputPile in outputPiles)
			{
				Item item = ItemManager.Create(resourcesToMine[resourceMiningIndex].itemDef, num3, 0uL);
				if (Interface.CallHook("OnExcavatorGather", (object)this, (object)item) != null)
				{
					return;
				}
				Analytics.Azure.OnExcavatorProduceItem(item, this);
				if (!item.MoveToContainer(outputPile.inventory))
				{
					item.Drop(outputPile.GetDropPosition(), outputPile.GetDropVelocity());
				}
			}
		}
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		base.OnEntityMessage(from, msg);
		if (msg == "DieselEngineOn")
		{
			SetFlag(Flags.Reserved8, b: true);
		}
		else if (msg == "DieselEngineOff")
		{
			SetFlag(Flags.Reserved8, b: false);
			StopMining();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_SetResourceTarget(RPCMessage msg)
	{
		string text = msg.read.String(256, false);
		if (Interface.CallHook("OnExcavatorResourceSet", (object)this, (object)text, (object)msg.player) == null)
		{
			switch (text)
			{
			case "HQM":
				resourceMiningIndex = 0;
				break;
			case "Sulfur":
				resourceMiningIndex = 1;
				break;
			case "Stone":
				resourceMiningIndex = 2;
				break;
			case "Metal":
				resourceMiningIndex = 3;
				break;
			}
			if (!IsOn())
			{
				BeginMining();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_StopMining(RPCMessage msg)
	{
	}

	public override void Spawn()
	{
		base.Spawn();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Init();
		if (IsOn() && IsPowered())
		{
			BeginMining();
		}
		else
		{
			StopMining();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.genericFloat1 = movedAmount;
		info.msg.ioEntity.genericInt1 = resourceMiningIndex;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			movedAmount = info.msg.ioEntity.genericFloat1;
			resourceMiningIndex = info.msg.ioEntity.genericInt1;
		}
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		Init();
	}

	public void Init()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		pendingResources = new ItemAmount[resourcesToMine.Length];
		for (int i = 0; i < resourcesToMine.Length; i++)
		{
			pendingResources[i] = new ItemAmount(resourcesToMine[i].itemDef);
		}
		List<ExcavatorOutputPile> list = Pool.Get<List<ExcavatorOutputPile>>();
		Vis.Entities(((Component)this).transform.position, 200f, list, 512, (QueryTriggerInteraction)2);
		outputPiles = new List<ExcavatorOutputPile>();
		foreach (ExcavatorOutputPile item in list)
		{
			if (!item.isClient)
			{
				outputPiles.Add(item);
			}
		}
		Pool.FreeUnmanaged<ExcavatorOutputPile>(ref list);
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;

public class ExcavatorSignalComputer : BaseCombatEntity
{
	public float chargePower;

	public const Flags Flag_Ready = Flags.Reserved7;

	public const Flags Flag_HasPower = Flags.Reserved8;

	public GameObjectRef supplyPlanePrefab;

	public Transform[] dropPoints;

	public Text statusText;

	public Text timerText;

	public static readonly Phrase readyphrase = new Phrase("excavator.signal.ready", "READY");

	public static readonly Phrase chargephrase = new Phrase("excavator.signal.charging", "COMSYS CHARGING");

	[ServerVar]
	public static float chargeNeededForSupplies = 600f;

	private float lastChargeTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ExcavatorSignalComputer.OnRpcMessage", 0);
		try
		{
			if (rpc == 1824723998 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestSupplies "));
				}
				TimeWarning val2 = TimeWarning.New("RequestSupplies", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1824723998u, "RequestSupplies", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1824723998u, "RequestSupplies", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RequestSupplies(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RequestSupplies");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.genericFloat1 = chargePower;
		info.msg.ioEntity.genericFloat2 = chargeNeededForSupplies;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		lastChargeTime = Time.time;
		((FacepunchBehaviour)this).InvokeRepeating((Action)ChargeThink, 0f, 1f);
	}

	public override void PostServerLoad()
	{
		SetFlag(Flags.Reserved8, b: false);
		SetFlag(Flags.Reserved7, b: false);
	}

	public void ChargeThink()
	{
		float num = chargePower;
		float num2 = Time.time - lastChargeTime;
		lastChargeTime = Time.time;
		if (IsPowered())
		{
			chargePower += num2;
		}
		chargePower = Mathf.Clamp(chargePower, 0f, chargeNeededForSupplies);
		SetFlag(Flags.Reserved7, chargePower >= chargeNeededForSupplies);
		if (num != chargePower)
		{
			SendNetworkUpdate();
		}
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		base.OnEntityMessage(from, msg);
		if (msg == "DieselEngineOn")
		{
			SetFlag(Flags.Reserved8, b: true);
		}
		else if (msg == "DieselEngineOff")
		{
			SetFlag(Flags.Reserved8, b: false);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void RequestSupplies(RPCMessage rpc)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (HasFlag(Flags.Reserved7) && IsPowered() && chargePower >= chargeNeededForSupplies && Interface.CallHook("OnExcavatorSuppliesRequest", (object)this, (object)rpc.player) == null)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(supplyPlanePrefab.resourcePath);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				Vector3 position = dropPoints[Random.Range(0, dropPoints.Length)].position;
				Vector3 val = default(Vector3);
				((Vector3)(ref val))..ctor(Random.Range(-3f, 3f), 0f, Random.Range(-3f, 3f));
				((Component)baseEntity).SendMessage("InitDropPosition", (object)(position + val), (SendMessageOptions)1);
				baseEntity.Spawn();
			}
			Interface.CallHook("OnExcavatorSuppliesRequested", (object)this, (object)rpc.player, (object)baseEntity);
			chargePower -= chargeNeededForSupplies;
			SetFlag(Flags.Reserved7, b: false);
			SendNetworkUpdate();
		}
	}

	public bool IsPowered()
	{
		return HasFlag(Flags.Reserved8);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			chargePower = info.msg.ioEntity.genericFloat1;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class FarmableAnimal : BaseCombatEntity
{
	public class FarmableAnimalNeedsWorkQueue : ObjectWorkQueue<FarmableAnimal>
	{
		protected override void RunJob(FarmableAnimal entity)
		{
			entity.TickHappiness();
		}
	}

	[Header("Client")]
	public Animator AnimalAnimator;

	public Renderer[] AllRenderers;

	public Gradient RendererColourGradient;

	public GameObjectRef CorpsePrefab;

	public GestureConfig PettingGesture;

	[Header("Movements")]
	public float RepositionMinTime = 10f;

	public float RepositionMaxTime = 30f;

	public float AnimalMoveSpeed = 0.75f;

	[Header("Needs")]
	public float HungerDecayRate = 0.5f;

	public float ThirstDecayRate = 0.1f;

	public float LoveDecayRate = 0.1f;

	public float SunlightDecayRate = 0.05f;

	public float SunlightIncreaseRate = 0.05f;

	[Header("Eating")]
	public float MinimumTimeBetweenEating = 30f;

	[Range(0f, 1f)]
	public float AmountPerFood = 0.4f;

	[Header("Drinking")]
	public float MinimumTimeBetweenDrinking = 10f;

	[Range(0f, 1f)]
	public float AmountPerDrink = 0.1f;

	[Header("Health")]
	public float HealthChangeRate = 10f;

	public float HealthChangeScale = 1f;

	[Header("Egg Production")]
	public float MinimumMinutesBetweenProduction = 10f;

	public float MaximumMinutesBetweenProduction = 50f;

	public ItemDefinition ItemToCreate;

	public const float StatCount = 4f;

	public const Flags RecentlyPetted = Flags.Reserved1;

	public const Flags Moving = Flags.Reserved2;

	public const Flags Sleeping = Flags.Reserved3;

	public const float MaxHappinessStat = 100f;

	public const int MaxNameLength = 12;

	private Vector3 currentMoveTarget;

	private TimeSince lastHappinessTick;

	private Action moveChickenAction;

	private Action moveToNewLocationAction;

	private TimeSince lastEat;

	private TimeSince lastDrink;

	private TimeUntil nextEggProduction;

	private TimeUntil nextHealthCheck;

	private TimeSince wokenUp;

	public static FarmableAnimalNeedsWorkQueue NeedsWorkQueue = new FarmableAnimalNeedsWorkQueue();

	public float AnimalHunger { get; private set; } = 100f;

	public float AnimalThirst { get; private set; } = 100f;

	public float AnimalLove { get; private set; } = 100f;

	public float AnimalSunlight { get; private set; } = 100f;

	public string AnimalName { get; private set; } = string.Empty;

	public float HappinessNormalised => (AnimalHunger + AnimalThirst + AnimalLove + AnimalSunlight) / 4f / 100f;

	private ChickenCoop ParentCoop => parentEntity.Get(base.isServer) as ChickenCoop;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("FarmableAnimal.OnRpcMessage", 0);
		try
		{
			if (rpc == 3115049114u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestNameChange "));
				}
				TimeWarning val2 = TimeWarning.New("RequestNameChange", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3115049114u, "RequestNameChange", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RequestNameChange(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RequestNameChange");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2457655601u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerPetChicken "));
				}
				TimeWarning val2 = TimeWarning.New("ServerPetChicken", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2457655601u, "ServerPetChicken", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ServerPetChicken(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerPetChicken");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		moveToNewLocationAction = MoveToNewLocation;
		((FacepunchBehaviour)this).Invoke(moveToNewLocationAction, Random.Range(RepositionMinTime, RepositionMaxTime));
		((Component)this).transform.position = SnapMovementPos(((Component)this).transform.position);
		lastHappinessTick = TimeSince.op_Implicit(0f);
		nextEggProduction = TimeUntil.op_Implicit(Random.Range(MinimumMinutesBetweenProduction, MaximumMinutesBetweenProduction) * 60f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)QueueHappinessTick, 10f, 1f);
	}

	private void QueueHappinessTick()
	{
		((ObjectWorkQueue<FarmableAnimal>)NeedsWorkQueue).Add(this);
	}

	private float ConvertDecayRateToSecondMultiplier(float rate)
	{
		return rate / 60f / 60f;
	}

	private void TickHappiness()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		float num = TimeSince.op_Implicit(lastHappinessTick);
		lastHappinessTick = TimeSince.op_Implicit(0f);
		AnimalHunger = Mathf.Clamp(AnimalHunger - num * ConvertDecayRateToSecondMultiplier(HungerDecayRate), 0f, 100f);
		AnimalThirst = Mathf.Clamp(AnimalThirst - num * ConvertDecayRateToSecondMultiplier(ThirstDecayRate), 0f, 100f);
		AnimalLove = Mathf.Clamp(AnimalLove - num * ConvertDecayRateToSecondMultiplier(LoveDecayRate), 0f, 100f);
		if ((Object)(object)ParentCoop != (Object)null && ParentCoop.IsInSun)
		{
			AnimalSunlight = Mathf.Clamp(AnimalSunlight + num * ConvertDecayRateToSecondMultiplier(SunlightIncreaseRate), 0f, 100f);
		}
		else
		{
			AnimalSunlight = Mathf.Clamp(AnimalSunlight - num * ConvertDecayRateToSecondMultiplier(SunlightDecayRate), 0f, 100f);
		}
		if (TOD_Sky.Instance.IsNight && !HasFlag(Flags.Reserved2))
		{
			SetFlag(Flags.Reserved3, b: true);
		}
		else if (!TOD_Sky.Instance.IsNight)
		{
			if (HasFlag(Flags.Reserved3))
			{
				wokenUp = TimeSince.op_Implicit(0f);
			}
			SetFlag(Flags.Reserved3, b: false);
		}
		if (TimeSince.op_Implicit(lastEat) > MinimumTimeBetweenEating && AnimalHunger / 100f <= 1f - AmountPerFood * 0.2f)
		{
			lastEat = TimeSince.op_Implicit(0f);
			if ((Object)(object)ParentCoop != (Object)null)
			{
				Item currentFoodItem = ParentCoop.CurrentFoodItem;
				if (currentFoodItem != null)
				{
					currentFoodItem.UseItem();
					AnimalHunger = Mathf.Clamp(AnimalHunger + AmountPerFood * 100f, 0f, 100f);
				}
			}
		}
		if (TimeSince.op_Implicit(lastDrink) > MinimumTimeBetweenDrinking && AnimalThirst / 100f <= 1f - AmountPerDrink * 0.5f)
		{
			lastDrink = TimeSince.op_Implicit(0f);
			if ((Object)(object)ParentCoop != (Object)null)
			{
				Item currentWaterItem = ParentCoop.CurrentWaterItem;
				if (currentWaterItem != null)
				{
					currentWaterItem.UseItem();
					AnimalThirst = Mathf.Clamp(AnimalThirst + AmountPerDrink * 100f, 0f, 100f);
				}
			}
		}
		if (TimeUntil.op_Implicit(nextEggProduction) < 0f && (Object)(object)ItemToCreate != (Object)null)
		{
			nextEggProduction = TimeUntil.op_Implicit(Random.Range(MinimumMinutesBetweenProduction, MaximumMinutesBetweenProduction) * 60f);
			if (base.healthFraction > 0.75f)
			{
				float num2 = Mathx.RemapValClamped(HappinessNormalised, 0.75f, 1f, 0f, 1f);
				if (Random.Range(0f, 1f) < num2 && (Object)(object)ParentCoop != (Object)null)
				{
					Item item = ItemManager.Create(ItemToCreate, 1, 0uL);
					if (!item.MoveToContainer(ParentCoop.inventory, 3))
					{
						item.Remove();
					}
				}
			}
		}
		if (TimeUntil.op_Implicit(nextHealthCheck) <= 0f)
		{
			nextHealthCheck = TimeUntil.op_Implicit(HealthChangeRate);
			if (HappinessNormalised < 0.5f)
			{
				float num3 = 1f - Mathx.RemapValClamped(HappinessNormalised, 0f, 0.5f, 0f, 1f);
				float amount = HealthChangeScale * num3;
				Hurt(amount);
			}
			else
			{
				float num4 = Mathx.RemapValClamped(HappinessNormalised, 0.5f, 1f, 0f, 1f);
				float amount2 = HealthChangeScale * num4;
				Heal(amount2);
			}
		}
	}

	private void MoveToNewLocation()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (HasFlag(Flags.Reserved3) || TimeSince.op_Implicit(wokenUp) <= 2f)
		{
			((FacepunchBehaviour)this).Invoke(moveToNewLocationAction, Random.Range(RepositionMinTime, RepositionMaxTime));
			return;
		}
		ChickenCoop parentCoop = ParentCoop;
		if ((Object)(object)parentCoop != (Object)null)
		{
			Vector3 randomMovePoint = parentCoop.GetRandomMovePoint();
			currentMoveTarget = randomMovePoint;
			if (moveChickenAction == null)
			{
				moveChickenAction = MoveChicken;
			}
			((FacepunchBehaviour)this).InvokeRepeating(moveChickenAction, 0f, 0f);
		}
	}

	private void MoveChicken()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Quaternion val = ((Component)this).transform.rotation;
		position = SnapMovementPos(Vector3.MoveTowards(position, currentMoveTarget, AnimalMoveSpeed * Time.deltaTime));
		if ((Object)(object)ParentCoop != (Object)null && !ParentCoop.IsLocationClear(position, 0.25f, this))
		{
			StopMoving();
			return;
		}
		if (Vector3.Distance(currentMoveTarget, position) > 0.3f)
		{
			Vector3 val2 = Vector3Ex.WithY(currentMoveTarget, position.y) - position;
			val = Quaternion.LookRotation(((Vector3)(ref val2)).normalized);
		}
		((Component)this).transform.SetPositionAndRotation(position, val);
		if (Vector3.Distance(position, Vector3Ex.WithY(currentMoveTarget, position.y)) < 0.1f)
		{
			StopMoving();
		}
		else
		{
			SetFlag(Flags.Reserved2, b: true);
		}
	}

	private void StopMoving()
	{
		SetFlag(Flags.Reserved2, b: false);
		((FacepunchBehaviour)this).CancelInvoke(moveChickenAction);
		((FacepunchBehaviour)this).CancelInvoke(moveToNewLocationAction);
		((FacepunchBehaviour)this).Invoke(moveToNewLocationAction, Random.Range(RepositionMinTime, RepositionMaxTime));
	}

	private Vector3 SnapMovementPos(Vector3 desiredPos)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ParentCoop != (Object)null)
		{
			desiredPos = ((!ParentCoop.IsOnTerrain) ? ((Plane)(ref ParentCoop.MovementPlane)).ClosestPointOnPlane(desiredPos) : Vector3Ex.WithY(desiredPos, TerrainMeta.HeightMap.GetHeight(desiredPos)));
		}
		return desiredPos;
	}

	public void ApplyStartingStats(string defaultName)
	{
		AnimalName = defaultName;
		AnimalHunger = Random.Range(20f, 40f);
		AnimalThirst = Random.Range(20f, 40f);
		AnimalLove = Random.Range(20f, 40f);
		AnimalSunlight = Random.Range(20f, 40f);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ServerPetChicken(RPCMessage msg)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (CanPetChicken(msg.player))
		{
			AnimalLove = Mathf.Clamp(AnimalLove + 15f, 0f, 100f);
			SetFlag(Flags.Reserved1, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearPettedFlag, 5f);
			StopMoving();
			ClientRPC(RpcTarget.NetworkGroup("OnPetted"));
			Transform transform = ((Component)this).transform;
			Vector3 val = Vector3Ex.WithY(((Component)msg.player).transform.position, ((Component)this).transform.position.y) - ((Component)this).transform.position;
			transform.rotation = Quaternion.LookRotation(((Vector3)(ref val)).normalized, ((Component)this).transform.up);
			if ((Object)(object)PettingGesture != (Object)null && (Object)(object)msg.player != (Object)null)
			{
				msg.player.Server_StartGesture(PettingGesture, BasePlayer.GestureStartSource.ServerAction, bypassOwnershipCheck: true);
			}
		}
	}

	private void ClearPettedFlag()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.farmableAnimal = Pool.Get<FarmableAnimal>();
		SaveToData(info.msg.farmableAnimal);
	}

	public void SaveToData(FarmableAnimal data)
	{
		data.hunger = AnimalHunger;
		data.thirst = AnimalThirst;
		data.love = AnimalLove;
		data.sunlight = AnimalSunlight;
		data.animalName = AnimalName;
	}

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void RequestNameChange(RPCMessage msg)
	{
		if (msg.player.CanBuild(cached: true))
		{
			string text = msg.read.String(12, false);
			if (!string.IsNullOrWhiteSpace(text))
			{
				AnimalName = text;
				SendNetworkUpdate();
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		if ((Object)(object)ParentCoop != (Object)null)
		{
			ParentCoop.OnAnimalDied(this);
		}
		BaseCorpse baseCorpse = DropCorpse(CorpsePrefab.resourcePath);
		if (Object.op_Implicit((Object)(object)baseCorpse))
		{
			baseCorpse.Spawn();
			baseCorpse.TakeChildren(this);
		}
		base.OnDied(info);
	}

	public override void AdminKill()
	{
		if ((Object)(object)ParentCoop != (Object)null)
		{
			ParentCoop.OnAnimalDied(this);
		}
		base.AdminKill();
	}

	[ServerVar(Help = "Simulates the provided number of hours on all farm animals within 10m")]
	public static void SimHours(Arg arg)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		int @int = arg.GetInt(0, 0);
		PooledList<FarmableAnimal> val = Pool.Get<PooledList<FarmableAnimal>>();
		try
		{
			Vis.Entities(((Component)basePlayer).transform.position, 10f, (List<FarmableAnimal>)(object)val, 2048, (QueryTriggerInteraction)2);
			foreach (FarmableAnimal item in (List<FarmableAnimal>)(object)val)
			{
				if (item.isServer)
				{
					item.lastHappinessTick = TimeSince.op_Implicit(TimeSince.op_Implicit(item.lastHappinessTick) + (float)@int * 60f * 60f);
					item.TickHappiness();
					item.SendNetworkUpdate();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.farmableAnimal != null)
		{
			LoadFromData(info.msg.farmableAnimal);
		}
		if (base.isServer)
		{
			SetFlag(Flags.Reserved1, b: false);
		}
	}

	public void LoadFromData(FarmableAnimal data)
	{
		AnimalHunger = data.hunger;
		AnimalThirst = data.thirst;
		AnimalLove = data.love;
		AnimalSunlight = data.sunlight;
		AnimalName = data.animalName;
	}

	private bool CanPetChicken(BasePlayer bp)
	{
		if (!HasFlag(Flags.Reserved1) && !HasFlag(Flags.Reserved3) && (Object)(object)bp != (Object)null && !bp.isMounted && !bp.modelState.blocking)
		{
			return !bp.InGesture;
		}
		return false;
	}

	public ChickenCoop.AnimalStatus GetStatus()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ParentCoop != (Object)null)
		{
			foreach (ChickenCoop.AnimalStatus animal in ParentCoop.Animals)
			{
				EntityRef<FarmableAnimal> spawnedAnimal = animal.SpawnedAnimal;
				if (spawnedAnimal.uid == net.ID)
				{
					return animal;
				}
			}
		}
		return default(ChickenCoop.AnimalStatus);
	}
}


public class FarmableAnimalNeedsWorkQueue : ObjectWorkQueue<FarmableAnimal>
{
	protected override void RunJob(FarmableAnimal entity)
	{
		entity.TickHappiness();
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class FishMount : StorageContainer
{
	public Animator[] FishRoots = (Animator[])(object)new Animator[0];

	public GameObjectRef FishInteractSound = new GameObjectRef();

	public float UseCooldown = 3f;

	public const Flags HasFish = Flags.Reserved1;

	private int GetCurrentFishItemIndex
	{
		get
		{
			ItemModFishable itemModFishable = default(ItemModFishable);
			if (base.inventory.GetSlot(0) == null || !((Component)base.inventory.GetSlot(0).info).TryGetComponent<ItemModFishable>(ref itemModFishable))
			{
				return -1;
			}
			return itemModFishable.FishMountIndex;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("FishMount.OnRpcMessage", 0);
		try
		{
			if (rpc == 3280542489u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UseFish "));
				}
				TimeWarning val2 = TimeWarning.New("UseFish", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3280542489u, "UseFish", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							UseFish(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in UseFish");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.simpleInt == null)
		{
			info.msg.simpleInt = Pool.Get<SimpleInt>();
		}
		info.msg.simpleInt.value = GetCurrentFishItemIndex;
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		ItemModFishable itemModFishable = default(ItemModFishable);
		if (((Component)item.info).TryGetComponent<ItemModFishable>(ref itemModFishable) && itemModFishable.CanBeMounted)
		{
			return true;
		}
		return false;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Busy, b: false);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		SetFlag(Flags.Reserved1, GetCurrentFishItemIndex >= 0);
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void UseFish(RPCMessage msg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (HasFlag(Flags.Reserved1) && !IsBusy())
		{
			Effect.server.Run(FishInteractSound.resourcePath, ((Component)this).transform.position);
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearBusy, UseCooldown);
			ClientRPC(RpcTarget.NetworkGroup("PlayAnimation"));
		}
	}

	private void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class FlameThrower : AttackEntity
{
	[Header("Flame Thrower")]
	public int maxAmmo = 100;

	public int ammo = 100;

	public ItemDefinition fuelType;

	public float timeSinceLastAttack;

	[FormerlySerializedAs("nextAttackTime")]
	public float nextReadyTime;

	public float flameRange = 10f;

	public float flameRadius = 2.5f;

	public ParticleSystem[] flameEffects;

	public FlameJet jet;

	public GameObjectRef fireballPrefab;

	public List<DamageTypeEntry> damagePerSec;

	public float playerDamageMultiplier = 4f;

	public SoundDefinition flameStart3P;

	public SoundDefinition flameLoop3P;

	public SoundDefinition flameStop3P;

	public SoundDefinition pilotLoopSoundDef;

	private float tickRate = 0.15f;

	private float lastFlameTick;

	public float fuelPerSec;

	private float ammoRemainder;

	public float reloadDuration = 3.5f;

	private float lastReloadTime = -10f;

	private float nextFlameTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("FlameThrower.OnRpcMessage", 0);
		try
		{
			if (rpc == 3381353917u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoReload "));
				}
				TimeWarning val2 = TimeWarning.New("DoReload", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3381353917u, "DoReload", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoReload(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoReload");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3749570935u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetFiring "));
				}
				TimeWarning val2 = TimeWarning.New("SetFiring", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3749570935u, "SetFiring", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage firing = rPCMessage;
							SetFiring(firing);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SetFiring");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1057268396 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - TogglePilotLight "));
				}
				TimeWarning val2 = TimeWarning.New("TogglePilotLight", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1057268396u, "TogglePilotLight", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							TogglePilotLight(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in TogglePilotLight");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private bool IsWeaponBusy()
	{
		return Time.realtimeSinceStartup < nextReadyTime;
	}

	private void SetBusyFor(float dur)
	{
		nextReadyTime = Time.realtimeSinceStartup + dur;
	}

	private void ClearBusy()
	{
		nextReadyTime = Time.realtimeSinceStartup - 1f;
	}

	public void ReduceAmmo(float firingTime)
	{
		if (base.UsingInfiniteAmmoCheat)
		{
			return;
		}
		ammoRemainder += fuelPerSec * firingTime;
		if (ammoRemainder >= 1f)
		{
			int num = Mathf.FloorToInt(ammoRemainder);
			ammoRemainder -= num;
			if (ammoRemainder >= 1f)
			{
				num++;
				ammoRemainder -= 1f;
			}
			ammo -= num;
			if (ammo <= 0)
			{
				ammo = 0;
			}
			OnFuelAmountChanged();
		}
	}

	private void OnFuelAmountChanged()
	{
		GetItem()?.MarkDirty();
	}

	public void PilotLightToggle_Shared()
	{
		SetFlag(Flags.On, !HasFlag(Flags.On));
		if (base.isServer)
		{
			SendNetworkUpdateImmediate();
		}
	}

	public bool IsPilotOn()
	{
		return HasFlag(Flags.On);
	}

	public bool IsFlameOn()
	{
		return HasFlag(Flags.OnFire);
	}

	public bool HasAmmo()
	{
		return GetAmmo() != null;
	}

	public Item GetAmmo()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return null;
		}
		object obj = Interface.CallHook("OnInventoryAmmoItemFind", (object)ownerPlayer.inventory, (object)fuelType);
		if (obj is Item)
		{
			return (Item)obj;
		}
		return ownerPlayer.inventory.FindItemByItemName(fuelType.shortname);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.baseProjectile != null && info.msg.baseProjectile.primaryMagazine != null)
		{
			ammo = info.msg.baseProjectile.primaryMagazine.contents;
		}
	}

	public override void CollectedForCrafting(Item item, BasePlayer crafter)
	{
		ServerCommand(item, "unload_ammo", crafter);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseProjectile = Pool.Get<BaseProjectile>();
		info.msg.baseProjectile.primaryMagazine = Pool.Get<Magazine>();
		info.msg.baseProjectile.primaryMagazine.contents = ammo;
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void SetFiring(RPCMessage msg)
	{
		bool flameState = msg.read.Bit();
		SetFlameState(flameState);
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		if (!IsOnFire() && !ServerIsReloading())
		{
			if (!IsFlameOn())
			{
				SetFlameState(wantsOn: true);
			}
			((FacepunchBehaviour)this).Invoke((Action)StopFlameState, 1.25f);
			base.ServerUse(damageModifier, speedModifier, originOverride, useBulletThickness);
		}
	}

	public override void TopUpAmmo()
	{
		ammo = maxAmmo;
	}

	public override float AmmoFraction()
	{
		return (float)ammo / (float)maxAmmo;
	}

	public override bool ServerIsReloading()
	{
		return Time.time < lastReloadTime + reloadDuration;
	}

	public override bool CanReload()
	{
		return ammo < maxAmmo;
	}

	public override void ServerReload()
	{
		if (!ServerIsReloading())
		{
			SetFlameState(wantsOn: false);
			lastReloadTime = Time.time;
			StartAttackCooldown(reloadDuration);
			GetOwnerPlayer().SignalBroadcast(Signal.Reload);
			ammo = maxAmmo;
		}
	}

	public void StopFlameState()
	{
		SetFlameState(wantsOn: false);
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void DoReload(RPCMessage msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer == (Object)null))
		{
			Item item = null;
			while (ammo < maxAmmo && (item = GetAmmo()) != null && item.amount > 0)
			{
				int num = Mathf.Min(maxAmmo - ammo, item.amount);
				ammo += num;
				item.UseItem(num);
			}
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			OnFuelAmountChanged();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

	public void SetFlameState(bool wantsOn)
	{
		if (wantsOn)
		{
			if (!base.UsingInfiniteAmmoCheat)
			{
				ammo--;
			}
			if (ammo < 0)
			{
				ammo = 0;
			}
		}
		if (wantsOn && ammo <= 0)
		{
			wantsOn = false;
		}
		SetFlag(Flags.OnFire, wantsOn);
		if (IsFlameOn())
		{
			float num = 1f;
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null && ownerPlayer.IsNpc)
			{
				num = 0.4f;
			}
			nextFlameTime = Time.realtimeSinceStartup + num;
			lastFlameTick = Time.realtimeSinceStartup;
			((FacepunchBehaviour)this).InvokeRepeating((Action)FlameTick, tickRate, tickRate);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FlameTick);
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	public void TogglePilotLight(RPCMessage msg)
	{
		PilotLightToggle_Shared();
	}

	public override void OnHeldChanged()
	{
		SetFlameState(wantsOn: false);
		base.OnHeldChanged();
	}

	public void FlameTick()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.realtimeSinceStartup - lastFlameTick;
		lastFlameTick = Time.realtimeSinceStartup;
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return;
		}
		SingletonComponent<NpcFireManager>.Instance.Move(this);
		ReduceAmmo(num);
		SendNetworkUpdate();
		Ray val = ownerPlayer.eyes.BodyRay();
		Vector3 origin = ((Ray)(ref val)).origin;
		RaycastHit val2 = default(RaycastHit);
		bool num2 = Physics.SphereCast(val, 0.3f, ref val2, flameRange, 1218652417);
		if (!num2)
		{
			((RaycastHit)(ref val2)).point = origin + ((Ray)(ref val)).direction * flameRange;
		}
		float num3 = (ownerPlayer.IsNpc ? npcDamageScale : 1f);
		float amount = damagePerSec[0].amount;
		damagePerSec[0].amount = amount * num * num3;
		int num4 = 2146305;
		int layers = 133376;
		if (!ownerPlayer.IsNpc)
		{
			num4 |= 0x800;
		}
		DamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), ((RaycastHit)(ref val2)).point - ((Ray)(ref val)).direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, num4, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true, extendedLineOfSight: true);
		damagePerSec[0].amount = damagePerSec[0].amount * playerDamageMultiplier;
		DamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), ((RaycastHit)(ref val2)).point - ((Ray)(ref val)).direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, layers, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true, extendedLineOfSight: true);
		damagePerSec[0].amount = amount;
		if (num2 && Time.realtimeSinceStartup >= nextFlameTime && ((RaycastHit)(ref val2)).distance > 1.1f)
		{
			nextFlameTime = Time.realtimeSinceStartup + (ownerPlayer.IsNpc ? 0.25f : 0.45f);
			Vector3 val3 = ((RaycastHit)(ref val2)).point - ((Ray)(ref val)).direction * 0.25f;
			Vector3 val4 = val3 + new Vector3(0f, 0.2f, 0f);
			bool flag = !GamePhysics.CheckSphere(val3, 0.1f, 1084293377, (QueryTriggerInteraction)0);
			if (!flag && GamePhysics.LineOfSight(val3, val4, 1084293377))
			{
				val3 = val4;
				flag = !GamePhysics.CheckSphere(val3, 0.1f, 1084293377, (QueryTriggerInteraction)0);
			}
			if (flag)
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, val3);
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					Interface.CallHook("OnFlameThrowerBurn", (object)this, (object)baseEntity);
					baseEntity.creatorEntity = ownerPlayer;
					FireBall fireBall = baseEntity as FireBall;
					if ((Object)(object)fireBall != (Object)null && ownerPlayer.IsNpc)
					{
						fireBall.ignoreNPC = true;
					}
					baseEntity.Spawn();
				}
			}
		}
		if (ammo == 0)
		{
			SetFlameState(wantsOn: false);
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null && !base.UsingInfiniteAmmoCheat && !ownerPlayer.IsNpc)
		{
			ownerItem.LoseCondition(num);
		}
	}

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (item == null || !(command == "unload_ammo"))
		{
			return;
		}
		int num = ammo;
		if (num > 0)
		{
			ammo = 0;
			item.MarkDirty();
			SendNetworkUpdateImmediate();
			Item item2 = ItemManager.Create(fuelType, num, 0uL);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.eyes.position, player.eyes.BodyForward() * 2f);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;

public class FlameTurret : StorageContainer
{
	public class UpdateFlameTurretWorkQueue : ObjectWorkQueue<FlameTurret>
	{
		protected override void RunJob(FlameTurret entity)
		{
			if (((ObjectWorkQueue<FlameTurret>)this).ShouldAdd(entity))
			{
				entity.ServerThink();
			}
		}

		protected override bool ShouldAdd(FlameTurret entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	public Transform upper;

	public Vector3 aimDir;

	public float arc = 45f;

	public float triggeredDuration = 5f;

	public float flameRange = 7f;

	public float flameRadius = 4f;

	public float fuelPerSec = 1f;

	public Transform eyeTransform;

	public List<DamageTypeEntry> damagePerSec;

	public GameObjectRef triggeredEffect;

	public GameObjectRef fireballPrefab;

	public GameObjectRef explosionEffect;

	public TargetTrigger trigger;

	private float nextFireballTime;

	private int turnDir = 1;

	private float lastMovementUpdate;

	private float triggeredTime;

	private float lastServerThink;

	private float triggerCheckRate = 2f;

	private float nextTriggerCheckTime;

	private BuildingPrivlidge _cachedTc;

	private float _cacheTimeout;

	private float pendingFuel;

	public static UpdateFlameTurretWorkQueue updateFlameTurretQueueServer = new UpdateFlameTurretWorkQueue();

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("FlameTurret.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsTriggered()
	{
		return HasFlag(Flags.Reserved4);
	}

	public Vector3 GetEyePosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return eyeTransform.position;
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (base.CanPickup(player))
		{
			return !IsTriggered();
		}
		return false;
	}

	public void SetTriggered(bool triggered)
	{
		if (triggered && HasFuel())
		{
			triggeredTime = Time.realtimeSinceStartup;
		}
		SetFlag(Flags.Reserved4, triggered && HasFuel());
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)SendAimDir, 0f, 0.1f);
	}

	public void SendAimDir()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		float delta = Time.realtimeSinceStartup - lastMovementUpdate;
		lastMovementUpdate = Time.realtimeSinceStartup;
		MovementUpdate(delta);
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_ReceiveAimDir"), aimDir);
		((ObjectWorkQueue<FlameTurret>)updateFlameTurretQueueServer).Add(this);
	}

	public float GetSpinSpeed()
	{
		return IsTriggered() ? 180 : 45;
	}

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isClient)
		{
			if (info.damageTypes.IsMeleeType())
			{
				SetTriggered(triggered: true);
			}
			base.OnAttacked(info);
		}
	}

	public void MovementUpdate(float delta)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		aimDir += new Vector3(0f, delta * GetSpinSpeed(), 0f) * (float)turnDir;
		if (aimDir.y >= arc || aimDir.y <= 0f - arc)
		{
			turnDir *= -1;
			aimDir.y = Mathf.Clamp(aimDir.y, 0f - arc, arc);
		}
	}

	public void ServerThink()
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		bool num = IsTriggered();
		float delta = Time.realtimeSinceStartup - lastServerThink;
		lastServerThink = Time.realtimeSinceStartup;
		if (IsTriggered() && (Time.realtimeSinceStartup - triggeredTime > triggeredDuration || !HasFuel()))
		{
			SetTriggered(triggered: false);
		}
		if (!IsTriggered() && HasFuel() && CheckTrigger())
		{
			SetTriggered(triggered: true);
			Effect.server.Run(triggeredEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		}
		if (num != IsTriggered())
		{
			SendNetworkUpdateImmediate();
		}
		if (IsTriggered())
		{
			DoFlame(delta);
		}
	}

	public bool CheckTrigger()
	{
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		if (Time.realtimeSinceStartup < nextTriggerCheckTime)
		{
			return false;
		}
		nextTriggerCheckTime = Time.realtimeSinceStartup + 1f / triggerCheckRate;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		BuildingPrivlidge cachedTc = GetCachedTc();
		bool flag = false;
		if (entityContents != null)
		{
			foreach (BaseEntity item in entityContents)
			{
				BasePlayer component = ((Component)item).GetComponent<BasePlayer>();
				if (component.IsSleeping())
				{
					continue;
				}
				object obj = Interface.CallHook("CanBeTargeted", (object)component, (object)this);
				if (obj is bool)
				{
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return (bool)obj;
				}
				if (!component.IsAlive() || !(((Component)component).transform.position.y <= GetEyePosition().y + 0.5f) || (!((Object)(object)cachedTc == (Object)null) && cachedTc.IsAuthed(component)))
				{
					continue;
				}
				list.Clear();
				Vector3 position = component.eyes.position;
				Vector3 val = GetEyePosition() - component.eyes.position;
				GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref val)).normalized), 0f, list, 9f, 1218519297, (QueryTriggerInteraction)0);
				for (int i = 0; i < list.Count; i++)
				{
					BaseEntity entity = list[i].GetEntity();
					if ((Object)(object)entity != (Object)null && ((Object)(object)entity == (Object)(object)this || entity.EqualNetID((BaseNetworkable)this)))
					{
						flag = true;
						break;
					}
					if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return flag;
	}

	private BuildingPrivlidge GetCachedTc()
	{
		if ((Object)(object)_cachedTc != (Object)null && _cachedTc.IsDestroyed)
		{
			_cachedTc = null;
		}
		if ((Object)(object)_cachedTc == (Object)null || Time.realtimeSinceStartup > _cacheTimeout)
		{
			_cachedTc = null;
			BuildingManager.Building building = GetBuilding();
			if (building != null)
			{
				_cachedTc = building.GetDominatingBuildingPrivilege();
			}
			if ((Object)(object)_cachedTc == (Object)null)
			{
				return GetNearestBuildingPrivilege(cached: true, 3f);
			}
			_cacheTimeout = Time.realtimeSinceStartup + 3f;
		}
		return _cachedTc;
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)GetFuelAmount() / 500f;
		DamageUtil.RadiusDamage(this, LookupPrefab(), GetEyePosition(), 2f, 6f, damagePerSec, 133120, useLineOfSight: true);
		SeismicSensor.Notify(GetEyePosition(), 1);
		Effect.server.Run(explosionEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		int num2 = Mathf.CeilToInt(Mathf.Clamp(num * 8f, 1f, 8f));
		for (int i = 0; i < num2; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				Vector3 onUnitSphere = Random.onUnitSphere;
				((Component)baseEntity).transform.position = ((Component)this).transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * Random.Range(-1f, 1f);
				baseEntity.Spawn();
				baseEntity.SetVelocity(onUnitSphere * (float)Random.Range(3, 10));
			}
		}
		base.OnDied(info);
	}

	public int GetFuelAmount()
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		return slot.amount;
	}

	public bool HasFuel()
	{
		return GetFuelAmount() > 0;
	}

	public bool UseFuel(float seconds)
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return false;
		}
		pendingFuel += seconds * fuelPerSec;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			Analytics.Azure.AddPendingItems(this, slot.info.shortname, num, "flame_turret");
			pendingFuel -= num;
		}
		return true;
	}

	public void DoFlame(float delta)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		if (!UseFuel(delta))
		{
			return;
		}
		Ray val = default(Ray);
		((Ray)(ref val))..ctor(GetEyePosition(), ((Component)this).transform.TransformDirection(Quaternion.Euler(aimDir) * Vector3.forward));
		Vector3 origin = ((Ray)(ref val)).origin;
		RaycastHit val2 = default(RaycastHit);
		bool flag = Physics.SphereCast(val, 0.4f, ref val2, flameRange, 1218652417);
		if (!flag)
		{
			((RaycastHit)(ref val2)).point = origin + ((Ray)(ref val)).direction * flameRange;
		}
		float amount = damagePerSec[0].amount;
		damagePerSec[0].amount = amount * delta;
		DamageUtil.RadiusDamage(this, LookupPrefab(), ((RaycastHit)(ref val2)).point - ((Ray)(ref val)).direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, 2230272, useLineOfSight: true);
		DamageUtil.RadiusDamage(this, LookupPrefab(), ((Component)this).transform.position + new Vector3(0f, 1.25f, 0f), 0.25f, 0.25f, damagePerSec, 133120, useLineOfSight: false);
		damagePerSec[0].amount = amount;
		if (Time.realtimeSinceStartup >= nextFireballTime)
		{
			nextFireballTime = Time.realtimeSinceStartup + Random.Range(1f, 2f);
			Vector3 val3 = ((Random.Range(0, 10) <= 7 && flag) ? ((RaycastHit)(ref val2)).point : (((Ray)(ref val)).origin + ((Ray)(ref val)).direction * (flag ? ((RaycastHit)(ref val2)).distance : flameRange) * Random.Range(0.4f, 1f)));
			BaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, val3 - ((Ray)(ref val)).direction * 0.25f);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.creatorEntity = this;
				baseEntity.Spawn();
			}
		}
	}
}


public class UpdateFlameTurretWorkQueue : ObjectWorkQueue<FlameTurret>
{
	protected override void RunJob(FlameTurret entity)
	{
		if (((ObjectWorkQueue<FlameTurret>)this).ShouldAdd(entity))
		{
			entity.ServerThink();
		}
	}

	protected override bool ShouldAdd(FlameTurret entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


using System;
using Network;
using UnityEngine;

public class Flashbang : TimedExplosive
{
	public SoundDefinition deafLoopDef;

	public float flashReductionPerSecond = 1f;

	public float flashToAdd = 3f;

	public float flashMinRange = 5f;

	public float flashMaxRange = 10f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Flashbang.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Explode()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.NetworkGroup("Client_DoFlash"), ((Component)this).transform.position);
		base.Explode();
	}

	public void DelayedDestroy()
	{
		Kill(DestroyMode.Gib);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class Food : BaseMelee
{
	public FoodViewModel.FoodVisualConfig VisualConfig;

	public List<GameObject> VisualRoots;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Food.OnRpcMessage", 0);
		try
		{
			if (rpc == 1921839088 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Consume "));
				}
				TimeWarning val2 = TimeWarning.New("Consume", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1921839088u, "Consume", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1921839088u, "Consume", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							Consume();
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Consume");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void Consume()
	{
		if (base.isServer)
		{
			if (HasAttackCooldown())
			{
				return;
			}
			StartAttackCooldown(repeatDelay / 2f);
		}
		Item item = GetItem();
		if (item == null)
		{
			return;
		}
		ItemModConsume component = ((Component)item.info).GetComponent<ItemModConsume>();
		if (!((Object)(object)component == (Object)null))
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if (!((Object)(object)ownerPlayer == (Object)null))
			{
				component.DoAction(item, ownerPlayer);
			}
		}
	}
}


using System;
using System.Collections;
using Network;
using Rust;
using UnityEngine;

public class FrankensteinPet : BasePet, IAISenses, IAIAttack
{
	[Header("Frankenstein")]
	[ServerVar(Help = "How long before a Frankenstein Pet dies un controlled and not asleep on table")]
	public static float decayminutes = 180f;

	[Header("Audio")]
	public SoundDefinition AttackVocalSFX;

	public float nextAttackTime;

	protected override string CorpsePath => "assets/rust.ai/agents/NPCPlayer/pet/frankensteinpet_corpse.prefab";

	protected override bool ShouldCorpseTakeChildren => false;

	protected override bool KeepCorpseClothingIntact => false;

	protected override string OverrideCorpseName => "Frankenstein";

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("FrankensteinPet.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!base.isClient)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)TickDecay, Random.Range(30f, 60f), 60f, 6f);
		}
	}

	public IEnumerator DelayEquipWeapon(ItemDefinition item, float delay)
	{
		yield return (object)new WaitForSeconds(delay);
		if (!((Object)(object)base.inventory == (Object)null) && base.inventory.containerBelt != null && !((Object)(object)item == (Object)null))
		{
			base.inventory.GiveItem(ItemManager.Create(item, 1, 0uL), base.inventory.containerBelt);
			EquipWeapon();
		}
	}

	private void TickDecay()
	{
		BasePlayer basePlayer = BasePlayer.FindByID(base.OwnerID);
		if ((!((Object)(object)basePlayer != (Object)null) || basePlayer.IsSleeping()) && !(base.healthFraction <= 0f) && !base.IsDestroyed)
		{
			float num = 1f / decayminutes;
			float amount = MaxHealth() * num;
			Hurt(amount, DamageType.Decay, this, useProtection: false);
		}
	}

	public float EngagementRange()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (Object.op_Implicit((Object)(object)attackEntity))
		{
			return attackEntity.effectiveRange * (attackEntity.aiOnlyInRange ? 1f : 2f) * base.Brain.AttackRangeMultiplier;
		}
		return base.Brain.SenseRange;
	}

	public bool IsThreat(BaseEntity entity)
	{
		return IsTarget(entity);
	}

	public bool IsTarget(BaseEntity entity)
	{
		if (entity is BasePlayer)
		{
			return !entity.IsNpc;
		}
		return false;
	}

	public bool IsFriendly(BaseEntity entity)
	{
		return false;
	}

	public bool CanAttack(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (((Component)entity).gameObject.layer == 21 || ((Component)entity).gameObject.layer == 8)
		{
			return false;
		}
		if (NeedsToReload())
		{
			return false;
		}
		if (IsOnCooldown())
		{
			return false;
		}
		if (!IsTargetInRange(entity, out var _))
		{
			return false;
		}
		if (InSafeZone() || (entity is BasePlayer basePlayer && basePlayer.InSafeZone()))
		{
			return false;
		}
		if (!CanSeeTarget(entity))
		{
			return false;
		}
		return true;
	}

	public bool IsTargetInRange(BaseEntity entity, out float dist)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		dist = Vector3.Distance(((Component)entity).transform.position, ((Component)this).transform.position);
		return dist <= EngagementRange();
	}

	public bool CanSeeTarget(BaseEntity entity)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.IsVisible(GetEntity().CenterPoint(), entity.CenterPoint());
	}

	public bool NeedsToReload()
	{
		return false;
	}

	public bool Reload()
	{
		return true;
	}

	public float CooldownDuration()
	{
		return BaseAttackRate;
	}

	public bool IsOnCooldown()
	{
		return Time.realtimeSinceStartup < nextAttackTime;
	}

	public bool StartAttacking(BaseEntity target)
	{
		BaseCombatEntity baseCombatEntity = target as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity == (Object)null)
		{
			return false;
		}
		Attack(baseCombatEntity);
		return true;
	}

	private void Attack(BaseCombatEntity target)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)target == (Object)null))
		{
			Vector3 val = target.ServerPosition - ServerPosition;
			if (((Vector3)(ref val)).magnitude > 0.001f)
			{
				ServerRotation = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
			}
			target.Hurt(BaseAttackDamge, AttackDamageType, this);
			SignalBroadcast(Signal.Attack);
			ClientRPC(RpcTarget.NetworkGroup("OnAttack"));
			nextAttackTime = Time.realtimeSinceStartup + CooldownDuration();
		}
	}

	public void StopAttacking()
	{
	}

	public float GetAmmoFraction()
	{
		return AmmoFractionRemaining();
	}

	public BaseEntity GetBestTarget()
	{
		return null;
	}

	public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
	{
	}

	public override bool ShouldDropActiveItem()
	{
		return false;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class FrankensteinTable : StorageContainer
{
	public GameObjectRef FrankensteinPrefab;

	public Transform SpawnLocation;

	public ItemDefinition WeaponItem;

	public List<ItemDefinition> HeadItems;

	public List<ItemDefinition> TorsoItems;

	public List<ItemDefinition> LegItems;

	[HideInInspector]
	public List<ItemDefinition> ItemsToUse;

	public FrankensteinTableVisuals TableVisuals;

	[Header("Timings")]
	public float TableDownDuration = 0.9f;

	private bool waking;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("FrankensteinTable.OnRpcMessage", 0);
		try
		{
			if (rpc == 629197370 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CreateFrankenstein "));
				}
				TimeWarning val2 = TimeWarning.New("CreateFrankenstein", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(629197370u, "CreateFrankenstein", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							CreateFrankenstein(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in CreateFrankenstein");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4797457 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestSleepFrankenstein "));
				}
				TimeWarning val2 = TimeWarning.New("RequestSleepFrankenstein", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4797457u, "RequestSleepFrankenstein", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RequestSleepFrankenstein(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RequestSleepFrankenstein");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3804893505u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestWakeFrankenstein "));
				}
				TimeWarning val2 = TimeWarning.New("RequestWakeFrankenstein", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3804893505u, "RequestWakeFrankenstein", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RequestWakeFrankenstein(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RequestWakeFrankenstein");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsHeadItem(ItemDefinition itemDef)
	{
		return HeadItems.Contains(itemDef);
	}

	public bool IsTorsoItem(ItemDefinition itemDef)
	{
		return TorsoItems.Contains(itemDef);
	}

	public bool IsLegsItem(ItemDefinition itemDef)
	{
		return LegItems.Contains(itemDef);
	}

	public bool HasValidItems(ItemContainer container)
	{
		return GetValidItems(container) != null;
	}

	public List<ItemDefinition> GetValidItems(ItemContainer container)
	{
		if (container == null)
		{
			return null;
		}
		if (container.itemList == null)
		{
			return null;
		}
		if (container.itemList.Count == 0)
		{
			return null;
		}
		bool set = false;
		bool set2 = false;
		bool set3 = false;
		List<ItemDefinition> list = new List<ItemDefinition>();
		for (int i = 0; i < container.capacity; i++)
		{
			Item slot = container.GetSlot(i);
			if (slot != null)
			{
				CheckItem(slot.info, list, HeadItems, ref set);
				CheckItem(slot.info, list, TorsoItems, ref set2);
				CheckItem(slot.info, list, LegItems, ref set3);
				if (set && set2 && set3)
				{
					return list;
				}
			}
		}
		return null;
	}

	public bool HasAllValidItems(List<ItemDefinition> items)
	{
		if (items == null)
		{
			return false;
		}
		if (items.Count < 3)
		{
			return false;
		}
		bool set = false;
		bool set2 = false;
		bool set3 = false;
		foreach (ItemDefinition item in items)
		{
			if ((Object)(object)item == (Object)null)
			{
				return false;
			}
			CheckItem(item, null, HeadItems, ref set);
			CheckItem(item, null, TorsoItems, ref set2);
			CheckItem(item, null, LegItems, ref set3);
		}
		return set && set2 && set3;
	}

	private void CheckItem(ItemDefinition item, List<ItemDefinition> itemList, List<ItemDefinition> validItems, ref bool set)
	{
		if (!set && validItems.Contains(item))
		{
			set = true;
			itemList?.Add(item);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
		base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		SendNetworkUpdateImmediate();
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		if (item == null)
		{
			return false;
		}
		if (HeadItems != null && IsHeadItem(item.info))
		{
			return true;
		}
		if (TorsoItems != null && IsTorsoItem(item.info))
		{
			return true;
		}
		if (LegItems != null && IsLegsItem(item.info))
		{
			return true;
		}
		return false;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void CreateFrankenstein(RPCMessage msg)
	{
	}

	private bool CanStartCreating(BasePlayer player)
	{
		if (waking)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if ((Object)(object)player.PetEntity != (Object)null)
		{
			return false;
		}
		if (!HasValidItems(base.inventory))
		{
			return false;
		}
		return true;
	}

	private bool IsInventoryEmpty()
	{
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			if (base.inventory.GetSlot(i) != null)
			{
				return false;
			}
		}
		return true;
	}

	private void ConsumeInventory()
	{
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			slot?.UseItem(slot.amount);
		}
		ItemManager.DoRemoves();
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RequestWakeFrankenstein(RPCMessage msg)
	{
		WakeFrankenstein(msg.player);
	}

	private void WakeFrankenstein(BasePlayer owner)
	{
		if (!((Object)(object)owner == (Object)null) && CanStartCreating(owner) && Interface.CallHook("OnFrankensteinPetWake", (object)this, (object)owner) == null)
		{
			waking = true;
			base.inventory.SetLocked(isLocked: true);
			SendNetworkUpdateImmediate();
			((MonoBehaviour)this).StartCoroutine(DelayWakeFrankenstein(owner));
			ClientRPC(RpcTarget.NetworkGroup("CL_WakeFrankenstein"));
		}
	}

	private IEnumerator DelayWakeFrankenstein(BasePlayer owner)
	{
		yield return (object)new WaitForSeconds(1.5f);
		yield return (object)new WaitForSeconds(TableDownDuration);
		if ((Object)(object)owner != (Object)null && (Object)(object)owner.PetEntity != (Object)null)
		{
			base.inventory.SetLocked(isLocked: false);
			SendNetworkUpdateImmediate();
			waking = false;
			yield break;
		}
		ItemsToUse = GetValidItems(base.inventory);
		BaseEntity baseEntity = GameManager.server.CreateEntity(FrankensteinPrefab.resourcePath, SpawnLocation.position, SpawnLocation.rotation, startActive: false);
		baseEntity.enableSaving = false;
		((Component)baseEntity).gameObject.AwakeFromInstantiate();
		baseEntity.Spawn();
		EquipFrankenstein(baseEntity as FrankensteinPet);
		ConsumeInventory();
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdateImmediate();
		((MonoBehaviour)this).StartCoroutine(WaitForFrankensteinBrainInit(baseEntity as BasePet, owner));
		waking = false;
		yield return null;
	}

	private void EquipFrankenstein(FrankensteinPet frank)
	{
		if (ItemsToUse == null || (Object)(object)frank == (Object)null || (Object)(object)frank.inventory == (Object)null)
		{
			return;
		}
		foreach (ItemDefinition item in ItemsToUse)
		{
			frank.inventory.GiveItem(ItemManager.Create(item, 1, 0uL), frank.inventory.containerWear);
		}
		if ((Object)(object)WeaponItem != (Object)null)
		{
			((MonoBehaviour)this).StartCoroutine(frank.DelayEquipWeapon(WeaponItem, 1.5f));
		}
		ItemsToUse.Clear();
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RequestSleepFrankenstein(RPCMessage msg)
	{
		SleepFrankenstein(msg.player);
	}

	private void SleepFrankenstein(BasePlayer owner)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (IsInventoryEmpty() && !((Object)(object)owner == (Object)null) && !((Object)(object)owner.PetEntity == (Object)null))
		{
			FrankensteinPet frankensteinPet = owner.PetEntity as FrankensteinPet;
			if (!((Object)(object)frankensteinPet == (Object)null) && !(Vector3.Distance(((Component)this).transform.position, ((Component)frankensteinPet).transform.position) >= 5f) && Interface.CallHook("OnFrankensteinPetSleep", (object)frankensteinPet, (object)this, (object)owner) == null)
			{
				ReturnFrankensteinItems(frankensteinPet);
				ItemManager.DoRemoves();
				SendNetworkUpdateImmediate();
				frankensteinPet.Kill();
			}
		}
	}

	private void ReturnFrankensteinItems(FrankensteinPet frank)
	{
		if (!((Object)(object)frank == (Object)null) && !((Object)(object)frank.inventory == (Object)null) && frank.inventory.containerWear != null)
		{
			for (int i = 0; i < frank.inventory.containerWear.capacity; i++)
			{
				frank.inventory.containerWear.GetSlot(i)?.MoveToContainer(base.inventory);
			}
		}
	}

	private IEnumerator WaitForFrankensteinBrainInit(BasePet frankenstein, BasePlayer player)
	{
		yield return (object)new WaitForEndOfFrame();
		frankenstein.ApplyPetStatModifiers();
		frankenstein.Brain.SetOwningPlayer(player);
		frankenstein.CreateMapMarker();
		player.SendClientPetLink();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			return;
		}
		info.msg.FrankensteinTable = Pool.Get<FrankensteinTable>();
		info.msg.FrankensteinTable.itemIds = new List<int>();
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				info.msg.FrankensteinTable.itemIds.Add(slot.info.itemid);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class FreeableLootContainer : LootContainer
{
	private const Flags tiedDown = Flags.Reserved8;

	public Buoyancy buoyancy;

	public GameObjectRef freedEffect;

	private Rigidbody rb;

	private const float untieTime = 6f;

	public uint skinOverride;

	private float startUntieTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("FreeableLootContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 2202685945u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_FreeCrate "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_FreeCrate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2202685945u, "RPC_FreeCrate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_FreeCrate(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_FreeCrate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1460413277 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_FreeCrateTimer "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_FreeCrateTimer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1460413277u, "RPC_FreeCrateTimer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_FreeCrateTimer(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_FreeCrateTimer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public Rigidbody GetRB()
	{
		if ((Object)(object)rb == (Object)null)
		{
			rb = ((Component)this).GetComponent<Rigidbody>();
		}
		return rb;
	}

	public bool IsTiedDown()
	{
		return HasFlag(Flags.Reserved8);
	}

	public override void ServerInit()
	{
		GetRB().isKinematic = true;
		buoyancy.buoyancyScale = 0f;
		((Behaviour)buoyancy).enabled = false;
		base.ServerInit();
		if (skinOverride != 0)
		{
			skinID = skinOverride;
			SendNetworkUpdate();
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if (base.isServer && (Object)(object)info.Weapon != (Object)null)
		{
			BaseMelee component = ((Component)info.Weapon).GetComponent<BaseMelee>();
			if (Object.op_Implicit((Object)(object)component) && component.canUntieCrates && IsTiedDown())
			{
				base.health -= 1f;
				info.DidGather = true;
				if (base.health <= 0f)
				{
					base.health = MaxHealth();
					Release(info.InitiatorPlayer);
				}
			}
		}
		base.OnAttacked(info);
	}

	public void Release(BasePlayer ply)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnFreeableContainerRelease", (object)this, (object)ply) == null)
		{
			GetRB().isKinematic = false;
			((Behaviour)buoyancy).enabled = true;
			buoyancy.buoyancyScale = 1f;
			SetFlag(Flags.Reserved8, b: false);
			if (freedEffect.isValid)
			{
				Effect.server.Run(freedEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
			if ((Object)(object)ply != (Object)null && !ply.IsNpc && ply.IsConnected && net != null)
			{
				ply.ProcessMissionEvent(BaseMission.MissionEventType.FREE_CRATE, net.ID, 1f);
				Analytics.Azure.OnFreeUnderwaterCrate(ply, this);
			}
			Interface.CallHook("OnFreeableContainerReleased", (object)this, (object)ply);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_FreeCrate(RPCMessage msg)
	{
		if (IsTiedDown() && !(Mathf.Abs(startUntieTime + 6f - Time.realtimeSinceStartup) > ConVar.AntiHack.rpc_timer_forgiveness))
		{
			BasePlayer player = msg.player;
			Release(player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_FreeCrateTimer(RPCMessage msg)
	{
		if (IsTiedDown())
		{
			startUntieTime = Time.realtimeSinceStartup;
			Interface.CallHook("OnFreeableContainerReleaseStarted", (object)this, (object)msg.player);
		}
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class FuelGenerator : ContainerIOEntity
{
	public int outputEnergy = 35;

	public float fuelPerSec = 1f;

	protected float fuelTickRate = 3f;

	private float pendingFuel;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("FuelGenerator.OnRpcMessage", 0);
		try
		{
			if (rpc == 1401355317 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_EngineSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_EngineSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1401355317u, "RPC_EngineSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_EngineSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_EngineSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int MaximalPowerOutput()
	{
		return outputEnergy;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void Init()
	{
		if (IsOn())
		{
			UpdateCurrentEnergy();
			((FacepunchBehaviour)this).InvokeRepeating((Action)FuelConsumption, fuelTickRate, fuelTickRate);
		}
		base.Init();
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0 && inputAmount > 0)
		{
			TurnOn();
		}
		if (inputSlot == 1 && inputAmount > 0)
		{
			TurnOff();
		}
		base.UpdateFromInput(inputAmount, inputSlot);
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		if (!IsOn())
		{
			return 0;
		}
		return outputEnergy;
	}

	public void UpdateCurrentEnergy()
	{
		currentEnergy = CalculateCurrentEnergy(0, 0);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot != 0)
		{
			return 0;
		}
		return currentEnergy;
	}

	public override bool AllowDrainFrom(int outputSlot)
	{
		return false;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_EngineSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnSwitchToggle", (object)this, (object)msg.player) == null)
		{
			bool generatorState = msg.read.Bit();
			SetGeneratorState(generatorState);
			Interface.CallHook("OnSwitchToggled", (object)this, (object)msg.player);
		}
	}

	public void SetGeneratorState(bool wantsOn)
	{
		if (wantsOn)
		{
			TurnOn();
		}
		else
		{
			TurnOff();
		}
	}

	public int GetFuelAmount()
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		return slot.amount;
	}

	public bool HasFuel()
	{
		return GetFuelAmount() >= 1;
	}

	public bool UseFuel(float seconds)
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return false;
		}
		pendingFuel += seconds * fuelPerSec;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			Analytics.Azure.AddPendingItems(this, slot.info.shortname, num, "generator");
			pendingFuel -= num;
		}
		return true;
	}

	public void TurnOn()
	{
		if (!IsOn() && UseFuel(1f))
		{
			SetFlag(Flags.On, b: true);
			UpdateCurrentEnergy();
			MarkDirty();
			((FacepunchBehaviour)this).InvokeRepeating((Action)FuelConsumption, fuelTickRate, fuelTickRate);
		}
	}

	public void FuelConsumption()
	{
		if (!UseFuel(fuelTickRate))
		{
			TurnOff();
		}
	}

	public void TurnOff()
	{
		if (IsOn())
		{
			SetFlag(Flags.On, b: false);
			UpdateCurrentEnergy();
			MarkDirty();
			((FacepunchBehaviour)this).CancelInvoke((Action)FuelConsumption);
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class GestureDoor : Door
{
	public GestureConfig OpenGesture;

	public GestureConfig KickGesture;

	public float KickAnimationDelay = 1f;

	public float PushAnimationDelay = 0.25f;

	public float WeaponAdditiveDelay = 0.1f;

	private bool wasKick;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("GestureDoor.OnRpcMessage", 0);
		try
		{
			if (rpc == 872065295 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerKick "));
				}
				TimeWarning val2 = TimeWarning.New("ServerKick", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(872065295u, "ServerKick", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerKick(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerKick");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	protected override void OnPlayerOpenedDoor(BasePlayer p)
	{
		base.OnPlayerOpenedDoor(p);
		if (wasKick)
		{
			p.Server_StartGesture(KickGesture, BasePlayer.GestureStartSource.ServerAction);
		}
		else
		{
			p.Server_StartGesture(OpenGesture, BasePlayer.GestureStartSource.ServerAction);
		}
		wasKick = false;
	}

	protected override bool ShouldDelayOpen(BasePlayer player, out float delay)
	{
		delay = PushAnimationDelay;
		if (wasKick)
		{
			delay = KickAnimationDelay;
		}
		if ((Object)(object)player.GetHeldEntity() != (Object)null)
		{
			delay += WeaponAdditiveDelay;
		}
		return delay > 0f;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void ServerKick(RPCMessage msg)
	{
		wasKick = true;
		RPC_OpenDoor(msg);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;

public class GlobalNetworkHandler : PointEntity
{
	public static GlobalNetworkHandler server;

	[NonSerialized]
	public Dictionary<NetworkableId, GlobalEntityData> serverData = new Dictionary<NetworkableId, GlobalEntityData>();

	private List<Connection> globalConnections = new List<Connection>();

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("GlobalNetworkHandler.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static bool ShouldSendEntity(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null || entity.IsDestroyed)
		{
			return false;
		}
		if (entity.HasParent())
		{
			return false;
		}
		if (entity.net != null && entity.net.group != null && entity.net.group.restricted)
		{
			return false;
		}
		if (entity.globalBuildingBlock)
		{
			return true;
		}
		return false;
	}

	public override void ServerInit()
	{
		server = this;
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			LoadEntitiesOnStartup();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		LoadEntitiesOnStartup();
	}

	public void OnClientConnected(Connection connection)
	{
		if (connection.globalNetworking)
		{
			globalConnections.Add(connection);
		}
	}

	public void OnClientDisconnected(Connection connection)
	{
		globalConnections.Remove(connection);
	}

	private void LoadEntitiesOnStartup()
	{
		Stopwatch stopwatch = Stopwatch.StartNew();
		Debug.Log((object)"Starting to load entities into GlobalNetworkHandler...");
		foreach (BaseEntity item in BaseNetworkable.serverEntities.OfType<BaseEntity>())
		{
			if (ShouldSendEntity(item))
			{
				OnEntityUpdate(item, sendNetworkUpdate: false);
			}
		}
		Debug.Log((object)$"Took {stopwatch.ElapsedMilliseconds}ms to load entities into GlobalNetworkHandler");
	}

	public void TrySendNetworkUpdate(BaseNetworkable net)
	{
		if (net is BaseEntity entity && ShouldSendEntity(entity))
		{
			OnEntityUpdate(entity);
		}
	}

	private void OnEntityUpdate(BaseEntity entity, bool sendNetworkUpdate = true)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		if (entity.net != null)
		{
			GlobalEntityData val = Pool.Get<GlobalEntityData>();
			val.prefabId = entity.prefabID;
			val.uid = entity.net.ID;
			val.pos = ((Component)entity).transform.position;
			Quaternion rotation = ((Component)entity).transform.rotation;
			val.rot = ((Quaternion)(ref rotation)).eulerAngles;
			if (entity is BuildingBlock buildingBlock)
			{
				val.grade = (int)buildingBlock.grade;
				val.modelState = buildingBlock.modelState;
				val.skin = buildingBlock.skinID;
				val.customColor = (int)buildingBlock.customColour;
			}
			if (entity is Door door)
			{
				val.flags = (int)(door.flags & Flags.Open);
			}
			if (serverData.TryGetValue(entity.net.ID, out var value))
			{
				Pool.Free<GlobalEntityData>(ref value);
			}
			serverData[entity.net.ID] = val;
			if (sendNetworkUpdate)
			{
				SendGlobalEntity(val, new SendInfo(Net.limit_global_update_broadcast ? globalConnections : Net.sv.connections));
			}
		}
	}

	public void OnEntityKilled(BaseNetworkable entity)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (serverData.Remove(entity.net.ID))
		{
			SendEntityDelete(entity.net.ID, new SendInfo(Net.limit_global_update_broadcast ? globalConnections : Net.sv.connections));
		}
	}

	public void StartSendingSnapshot(BasePlayer player)
	{
		OnClientConnected(player.Connection);
		if (!Net.limit_global_update_broadcast || player.Connection.globalNetworking)
		{
			SendAsSnapshot(player.Connection);
			SendSnapshot(player);
		}
	}

	private void SendSnapshot(BasePlayer player)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		if (!Net.globalNetworkedBases)
		{
			return;
		}
		Stopwatch stopwatch = Stopwatch.StartNew();
		GlobalEntityCollection val = Pool.Get<GlobalEntityCollection>();
		try
		{
			val.entities = Pool.Get<List<GlobalEntityData>>();
			foreach (GlobalEntityData value in serverData.Values)
			{
				val.entities.Add(value);
				if (val.entities.Count >= ConVar.Server.maxpacketsize_globalentities)
				{
					SendGlobalEntities(val, new SendInfo(player.Connection));
					val.entities.Clear();
				}
			}
			if (val.entities.Count > 0)
			{
				SendGlobalEntities(val, new SendInfo(player.Connection));
				val.entities.Clear();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		stopwatch.Stop();
		if (Net.global_network_debug)
		{
			Debug.Log((object)$"Took {stopwatch.ElapsedMilliseconds}ms to send {serverData.Count} global entities to {((object)player).ToString()}");
		}
	}

	private void SendEntityDelete(NetworkableId networkableId, SendInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (Net.globalNetworkedBases)
		{
			NetWrite val = ClientRPCStart("CLIENT_EntityDeletes");
			int num = Math.Min(ConVar.Server.maxpacketsize_globalentities, 1);
			val.UInt16((ushort)num);
			for (int i = 0; i < num; i++)
			{
				val.EntityID(networkableId);
			}
			ClientRPCSend(val, info);
		}
	}

	private void SendGlobalEntities(GlobalEntityCollection entities, SendInfo info)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (Net.globalNetworkedBases)
		{
			ClientRPC(RpcTarget.SendInfo("CLIENT_EntityUpdates", info), entities);
		}
	}

	private void SendGlobalEntity(GlobalEntityData entity, SendInfo info)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!Net.globalNetworkedBases)
		{
			return;
		}
		GlobalEntityCollection val = Pool.Get<GlobalEntityCollection>();
		try
		{
			val.entities = Pool.Get<List<GlobalEntityData>>();
			val.entities.Add(entity);
			SendGlobalEntities(val, info);
			val.entities.Clear();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class GrowableEntity : BaseCombatEntity, IInstanceDataReceiver, IHeatSourceListener
{
	public class GrowableEntityUpdateQueue : ObjectWorkQueue<GrowableEntity>
	{
		protected override void RunJob(GrowableEntity entity)
		{
			if (((ObjectWorkQueue<GrowableEntity>)this).ShouldAdd(entity))
			{
				entity.CalculateQualities_Water();
			}
		}

		protected override bool ShouldAdd(GrowableEntity entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	public PlantProperties Properties;

	public ItemDefinition SourceItemDef;

	public float stageAge;

	public GrowableGenes Genes = new GrowableGenes();

	public const float startingHealth = 10f;

	public const float artificalLightQuality = 1f;

	public const float planterGroundModifierBase = 0.6f;

	public const float fertilizerGroundModifierBonus = 0.4f;

	public const float growthGeneSpeedMultiplier = 0.25f;

	public const float waterGeneRequirementMultiplier = 0.1f;

	public const float hardinessGeneModifierBonus = 0.2f;

	public const float hardinessGeneTemperatureModifierBonus = 0.05f;

	public const float baseYieldIncreaseMultiplier = 1f;

	public const float yieldGeneBonusMultiplier = 0.25f;

	public const float maxNonPlanterGroundQuality = 0.6f;

	public const float deathRatePerQuality = 0.1f;

	public TimeCachedValue<float> sunExposure;

	public TimeCachedValue<float> artificialLightExposure;

	public TimeCachedValue<float> artificialTemperatureExposure;

	[ServerVar]
	[Help("How many miliseconds to budget for processing growable quality updates per frame")]
	public static float framebudgetms = 0.25f;

	public const Flags GodSpawn = Flags.Reserved1;

	public static GrowableEntityUpdateQueue growableEntityUpdateQueue = new GrowableEntityUpdateQueue();

	public bool underWater;

	public int seasons;

	public int harvests;

	public float terrainTypeValue;

	public float yieldPool;

	public PlanterBox planter;

	public PlantProperties.State State { get; set; }

	public float Age { get; set; }

	public float LightQuality { get; set; }

	public float GroundQuality { get; set; } = 1f;

	public float WaterQuality { get; set; }

	public float WaterConsumption { get; set; }

	public bool Fertilized { get; set; }

	public float TemperatureQuality { get; set; }

	public float OverallQuality { get; set; }

	public float Yield { get; set; }

	public float StageProgressFraction => stageAge / currentStage.lifeLengthSeconds;

	public PlantProperties.Stage currentStage => Properties.stages[(int)State];

	public static float ThinkDeltaTime => ConVar.Server.planttick;

	public float growDeltaTime => ConVar.Server.planttick * ConVar.Server.planttickscale;

	public int CurrentPickAmount => Mathf.RoundToInt(CurrentPickAmountFloat);

	public float CurrentPickAmountFloat => (currentStage.resources + Yield) * (float)Properties.pickupMultiplier;

	private bool god => HasFlag(Flags.Reserved1);

	public float CurrentTemperature
	{
		get
		{
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)GetPlanter() != (Object)null)
			{
				return GetPlanter().GetPlantTemperature();
			}
			return Climate.GetTemperature(((Component)this).transform.position) + (artificialTemperatureExposure?.Get(force: false) ?? 0f);
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("GrowableEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 759768385 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_EatFruit "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_EatFruit", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(759768385u, "RPC_EatFruit", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(759768385u, "RPC_EatFruit", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_EatFruit(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_EatFruit");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 598660365 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_PickFruit "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_PickFruit", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(598660365u, "RPC_PickFruit", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(598660365u, "RPC_PickFruit", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_PickFruit(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_PickFruit");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3465633431u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_PickFruitAll "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_PickFruitAll", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3465633431u, "RPC_PickFruitAll", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3465633431u, "RPC_PickFruitAll", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_PickFruitAll(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_PickFruitAll");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1959480148 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RemoveDying "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RemoveDying", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1959480148u, "RPC_RemoveDying", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_RemoveDying(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_RemoveDying");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1771718099 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RemoveDyingAll "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RemoveDyingAll", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1771718099u, "RPC_RemoveDyingAll", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							RPC_RemoveDyingAll(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in RPC_RemoveDyingAll");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 232075937 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestQualityUpdate "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestQualityUpdate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(232075937u, "RPC_RequestQualityUpdate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							RPC_RequestQualityUpdate(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in RPC_RequestQualityUpdate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2222960834u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TakeClone "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TakeClone", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2222960834u, "RPC_TakeClone", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2222960834u, "RPC_TakeClone", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							RPC_TakeClone(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in RPC_TakeClone");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 95639240 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TakeCloneAll "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TakeCloneAll", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(95639240u, "RPC_TakeCloneAll", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(95639240u, "RPC_TakeCloneAll", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg9 = rPCMessage;
							RPC_TakeCloneAll(msg9);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in RPC_TakeCloneAll");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void ReceiveInstanceData(InstanceData data)
	{
		GrowableGeneEncoding.DecodeIntToGenes(data.dataInt, Genes);
		GrowableGeneEncoding.DecodeIntToPreviousGenes(data.dataInt, Genes);
	}

	public override void ResetState()
	{
		base.ResetState();
		State = PlantProperties.State.Seed;
	}

	public bool CanPick()
	{
		return currentStage.resources > 0f;
	}

	public bool CanTakeSeeds()
	{
		if (currentStage.resources > 0f)
		{
			return (Object)(object)Properties.SeedItem != (Object)null;
		}
		return false;
	}

	public bool CanClone()
	{
		if (currentStage.resources > 0f)
		{
			return (Object)(object)Properties.CloneItem != (Object)null;
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.growableEntity = Pool.Get<GrowableEntity>();
		info.msg.growableEntity.state = (int)State;
		info.msg.growableEntity.totalAge = Age;
		info.msg.growableEntity.stageAge = stageAge;
		info.msg.growableEntity.yieldFraction = Yield;
		info.msg.growableEntity.yieldPool = yieldPool;
		info.msg.growableEntity.fertilized = Fertilized;
		if (Genes != null)
		{
			Genes.Save(info);
		}
		if (!info.forDisk)
		{
			info.msg.growableEntity.lightModifier = LightQuality;
			info.msg.growableEntity.groundModifier = GroundQuality;
			info.msg.growableEntity.waterModifier = WaterQuality;
			info.msg.growableEntity.happiness = OverallQuality;
			info.msg.growableEntity.temperatureModifier = TemperatureQuality;
			info.msg.growableEntity.waterConsumption = WaterConsumption;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.growableEntity != null)
		{
			Age = info.msg.growableEntity.totalAge;
			stageAge = info.msg.growableEntity.stageAge;
			Yield = info.msg.growableEntity.yieldFraction;
			Fertilized = info.msg.growableEntity.fertilized;
			yieldPool = info.msg.growableEntity.yieldPool;
			Genes.Load(info);
			ChangeState((PlantProperties.State)info.msg.growableEntity.state, resetAge: false, loading: true);
		}
		else
		{
			Genes.GenerateRandom(this);
		}
	}

	public void ChangeState(PlantProperties.State state, bool resetAge, bool loading = false)
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnGrowableStateChange", (object)this, (object)state) != null || (base.isServer && State == state))
		{
			return;
		}
		State = state;
		if (!base.isServer)
		{
			return;
		}
		if (!loading)
		{
			if (currentStage.resources > 0f)
			{
				yieldPool = currentStage.yield;
			}
			if (state == PlantProperties.State.Crossbreed)
			{
				if (Properties.CrossBreedEffect.isValid)
				{
					Effect.server.Run(Properties.CrossBreedEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
				}
				GrowableGenetics.CrossBreed(this);
			}
			SendNetworkUpdate();
		}
		if (resetAge)
		{
			stageAge = 0f;
		}
	}

	public void OnHeatSourceChanged()
	{
		CalculateQualities(firstTime: false, forceArtificialLightUpdates: false, forceArtificialTemperatureUpdates: true);
		SendNetworkUpdate();
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		float num = (((Object)(object)deployedBy.modifiers != (Object)null) ? deployedBy.modifiers.GetValue(Modifier.ModifierType.Farming_BetterGenes) : 0f);
		if (num != 0f && fromItem.instanceData == null)
		{
			Genes.GenerateFavourableGenes(this, num);
			SendNetworkUpdate();
		}
		if ((Object)(object)parent != (Object)null && parent is PlanterBox planterBox)
		{
			planterBox.OnPlantInserted(this, deployedBy);
		}
	}

	public void QueueForQualityUpdate()
	{
		((ObjectWorkQueue<GrowableEntity>)growableEntityUpdateQueue).Add(this);
	}

	public void SetGodQuality(bool qual)
	{
		SetFlag(Flags.Reserved1, qual);
	}

	public void CalculateQualities(bool firstTime, bool forceArtificialLightUpdates = false, bool forceArtificialTemperatureUpdates = false)
	{
		if (IsDead())
		{
			return;
		}
		if (god)
		{
			SetMaxGrowingConditions();
			return;
		}
		if (sunExposure == null)
		{
			sunExposure = new TimeCachedValue<float>
			{
				refreshCooldown = 30f,
				refreshRandomRange = 5f,
				updateValue = SunRaycast
			};
		}
		if (artificialLightExposure == null)
		{
			artificialLightExposure = new TimeCachedValue<float>
			{
				refreshCooldown = 60f,
				refreshRandomRange = 5f,
				updateValue = CalculateArtificialLightExposure
			};
		}
		if (artificialTemperatureExposure == null)
		{
			artificialTemperatureExposure = new TimeCachedValue<float>
			{
				refreshCooldown = 60f,
				refreshRandomRange = 5f,
				updateValue = CalculateArtificialTemperature
			};
		}
		if (forceArtificialTemperatureUpdates)
		{
			artificialTemperatureExposure.ForceNextRun();
		}
		CalculateLightQuality(forceArtificialLightUpdates || firstTime);
		CalculateWaterQuality();
		CalculateWaterConsumption();
		CalculateGroundQuality(firstTime);
		CalculateTemperatureQuality();
		CalculateOverallQuality();
	}

	private void CalculateQualities_Water()
	{
		CalculateWaterQuality();
		CalculateWaterConsumption();
		CalculateOverallQuality();
	}

	public void CalculateLightQuality(bool forceArtificalUpdate)
	{
		float num = Mathf.Clamp01(Properties.timeOfDayHappiness.Evaluate(TOD_Sky.Instance.Cycle.Hour));
		if (!ConVar.Server.plantlightdetection)
		{
			LightQuality = num;
			return;
		}
		LightQuality = CalculateSunExposure(forceArtificalUpdate) * num;
		if (LightQuality <= 0f)
		{
			LightQuality = GetArtificialLightExposure(forceArtificalUpdate);
		}
		LightQuality = RemapValue(LightQuality, 0f, Properties.OptimalLightQuality, 0f, 1f);
	}

	public float CalculateSunExposure(bool force)
	{
		if (TOD_Sky.Instance.IsNight)
		{
			return 0f;
		}
		if ((Object)(object)GetPlanter() != (Object)null)
		{
			return GetPlanter().GetSunExposure();
		}
		return sunExposure?.Get(force) ?? 0f;
	}

	public float SunRaycast()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return SunRaycast(((Component)this).transform.position + new Vector3(0f, 1f, 0f));
	}

	public float GetArtificialLightExposure(bool force)
	{
		if ((Object)(object)GetPlanter() != (Object)null)
		{
			return GetPlanter().GetArtificialLightExposure();
		}
		return artificialLightExposure?.Get(force) ?? 0f;
	}

	public float CalculateArtificialLightExposure()
	{
		return CalculateArtificialLightExposure(((Component)this).transform);
	}

	public static float CalculateArtificialLightExposure(Transform forTransform)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		float result = 0f;
		List<CeilingLight> list = Pool.Get<List<CeilingLight>>();
		Vis.Entities(forTransform.position + new Vector3(0f, ConVar.Server.ceilingLightHeightOffset, 0f), ConVar.Server.ceilingLightGrowableRange, list, 256, (QueryTriggerInteraction)2);
		foreach (CeilingLight item in list)
		{
			if (item.IsOn())
			{
				result = 1f;
				break;
			}
		}
		Pool.FreeUnmanaged<CeilingLight>(ref list);
		return result;
	}

	public static float SunRaycast(Vector3 checkPosition)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = TOD_Sky.Instance.Components.Sun.transform.position - checkPosition;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		RaycastHit val2 = default(RaycastHit);
		if (!Physics.Raycast(checkPosition, normalized, ref val2, 100f, 10551297))
		{
			return 1f;
		}
		return 0f;
	}

	public void CalculateWaterQuality()
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Invalid comparison between Unknown and I4
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Invalid comparison between Unknown and I4
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Invalid comparison between Unknown and I4
		if ((Object)(object)GetPlanter() != (Object)null)
		{
			float soilSaturationFraction = planter.soilSaturationFraction;
			if (soilSaturationFraction > ConVar.Server.optimalPlanterQualitySaturation)
			{
				WaterQuality = RemapValue(soilSaturationFraction, ConVar.Server.optimalPlanterQualitySaturation, 1f, 1f, 0.6f);
			}
			else
			{
				WaterQuality = RemapValue(soilSaturationFraction, 0f, ConVar.Server.optimalPlanterQualitySaturation, 0f, 1f);
			}
		}
		else
		{
			Enum val = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(((Component)this).transform.position);
			if (val - 1 > 1 && (int)val != 4)
			{
				if ((int)val == 8)
				{
					WaterQuality = 0.1f;
				}
				else
				{
					WaterQuality = 0f;
				}
			}
			else
			{
				WaterQuality = 0.3f;
			}
		}
		WaterQuality = Mathf.Clamp01(WaterQuality);
		WaterQuality = RemapValue(WaterQuality, 0f, Properties.OptimalWaterQuality, 0f, 1f);
	}

	public void CalculateGroundQuality(bool firstCheck)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (underWater && !firstCheck)
		{
			GroundQuality = 0f;
			return;
		}
		if (firstCheck)
		{
			Vector3 position = ((Component)this).transform.position;
			if (WaterLevel.Test(position, waves: true, volumes: true, this))
			{
				underWater = true;
				GroundQuality = 0f;
				return;
			}
			underWater = false;
			terrainTypeValue = GetGroundTypeValue(position);
		}
		if ((Object)(object)GetPlanter() != (Object)null)
		{
			GroundQuality = 0.6f;
			GroundQuality += (Fertilized ? 0.4f : 0f);
		}
		else
		{
			GroundQuality = terrainTypeValue;
			float num = (float)Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Hardiness) * 0.2f;
			float num2 = GroundQuality + num;
			GroundQuality = Mathf.Min(0.6f, num2);
		}
		GroundQuality = RemapValue(GroundQuality, 0f, Properties.OptimalGroundQuality, 0f, 1f);
	}

	public float GetGroundTypeValue(Vector3 pos)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Invalid comparison between Unknown and I4
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Invalid comparison between Unknown and I4
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected I4, but got Unknown
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Invalid comparison between Unknown and I4
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Invalid comparison between Unknown and I4
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Invalid comparison between Unknown and I4
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Invalid comparison between Unknown and I4
		Enum val = (Enum)TerrainMeta.SplatMap.GetSplatMaxType(pos);
		if ((int)val <= 16)
		{
			switch (val - 1)
			{
			default:
				if ((int)val != 8)
				{
					if ((int)val != 16)
					{
						break;
					}
					return 0.3f;
				}
				return 0f;
			case 1:
				return 0f;
			case 0:
				return 0.3f;
			case 3:
				return 0f;
			case 2:
				break;
			}
		}
		else
		{
			if ((int)val == 32)
			{
				return 0.2f;
			}
			if ((int)val == 64)
			{
				return 0f;
			}
			if ((int)val == 128)
			{
				return 0f;
			}
		}
		return 0.5f;
	}

	public void CalculateTemperatureQuality()
	{
		TemperatureQuality = Mathf.Clamp01(Properties.temperatureHappiness.Evaluate(CurrentTemperature));
		float num = (float)Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Hardiness) * 0.05f;
		TemperatureQuality = Mathf.Clamp01(TemperatureQuality + num);
		TemperatureQuality = RemapValue(TemperatureQuality, 0f, Properties.OptimalTemperatureQuality, 0f, 1f);
	}

	public void SetMaxGrowingConditions()
	{
		LightQuality = 1f;
		WaterQuality = 1f;
		GroundQuality = 1f;
		TemperatureQuality = 1f;
		OverallQuality = 1f;
	}

	public float CalculateOverallQuality()
	{
		float num = 1f;
		if (ConVar.Server.useMinimumPlantCondition)
		{
			num = Mathf.Min(num, LightQuality);
			num = Mathf.Min(num, WaterQuality);
			num = Mathf.Min(num, GroundQuality);
			num = Mathf.Min(num, TemperatureQuality);
		}
		else
		{
			num = LightQuality * WaterQuality * GroundQuality * TemperatureQuality;
		}
		OverallQuality = num;
		return OverallQuality;
	}

	public void CalculateWaterConsumption()
	{
		float num = Properties.temperatureWaterRequirementMultiplier.Evaluate(CurrentTemperature);
		float num2 = 1f + (float)Genes.GetGeneTypeCount(GrowableGenetics.GeneType.WaterRequirement) * 0.1f;
		WaterConsumption = Properties.WaterIntake * num * num2;
	}

	public float CalculateArtificialTemperature()
	{
		return CalculateArtificialTemperature(((Component)this).transform);
	}

	public static float CalculateArtificialTemperature(Transform forTransform)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = forTransform.position;
		List<GrowableHeatSource> list = Pool.Get<List<GrowableHeatSource>>();
		Vis.Components<GrowableHeatSource>(position, ConVar.Server.artificialTemperatureGrowableRange, list, 256, (QueryTriggerInteraction)2);
		float num = 0f;
		foreach (GrowableHeatSource item in list)
		{
			num = Mathf.Max(item.ApplyHeat(position), num);
		}
		Pool.FreeUnmanaged<GrowableHeatSource>(ref list);
		return num;
	}

	public int CalculateMarketValue()
	{
		int baseMarketValue = Properties.BaseMarketValue;
		int num = Genes.GetPositiveGeneCount() * 10;
		int num2 = Genes.GetNegativeGeneCount() * -10;
		baseMarketValue += num;
		baseMarketValue += num2;
		return Mathf.Max(0, baseMarketValue);
	}

	private static float RemapValue(float inValue, float minA, float maxA, float minB, float maxB)
	{
		if (inValue >= maxA)
		{
			return maxB;
		}
		float num = Mathf.InverseLerp(minA, maxA, inValue);
		return Mathf.Lerp(minB, maxB, num);
	}

	public bool IsFood()
	{
		if (Properties.pickupItem.category == ItemCategory.Food)
		{
			return (Object)(object)((Component)Properties.pickupItem).GetComponent<ItemModConsume>() != (Object)null;
		}
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)RunUpdate, ThinkDeltaTime, ThinkDeltaTime, ThinkDeltaTime * 0.1f);
		base.health = 10f;
		ResetSeason();
		Genes.GenerateRandom(this);
		if (!Application.isLoadingSave)
		{
			CalculateQualities(firstTime: true);
		}
	}

	public PlanterBox GetPlanter()
	{
		if ((Object)(object)planter == (Object)null)
		{
			BaseEntity baseEntity = GetParentEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				planter = baseEntity as PlanterBox;
			}
		}
		return planter;
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		planter = newParent as PlanterBox;
		if (!Application.isLoadingSave && (Object)(object)planter != (Object)null)
		{
			planter.FertilizeGrowables();
		}
		CalculateQualities(firstTime: true);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		CalculateQualities(firstTime: true);
	}

	public void ResetSeason()
	{
		Yield = 0f;
		yieldPool = 0f;
	}

	public void RunUpdate()
	{
		if (!IsDead())
		{
			CalculateQualities(firstTime: false);
			float overallQuality = CalculateOverallQuality();
			float actualStageAgeIncrease = UpdateAge(overallQuality);
			UpdateHealthAndYield(overallQuality, actualStageAgeIncrease);
			if (base.health <= 0f)
			{
				TellPlanter();
				Die();
			}
			else
			{
				UpdateState();
				ConsumeWater();
				SendNetworkUpdate();
			}
		}
	}

	public float UpdateAge(float overallQuality)
	{
		Age += growDeltaTime;
		float num = (currentStage.IgnoreConditions ? 1f : (Mathf.Max(overallQuality, 0f) * GetGrowthBonus(overallQuality)));
		float num2 = growDeltaTime * num;
		stageAge += num2;
		return num2;
	}

	public void UpdateHealthAndYield(float overallQuality, float actualStageAgeIncrease)
	{
		if ((Object)(object)GetPlanter() == (Object)null && Random.Range(0f, 1f) <= ConVar.Server.nonPlanterDeathChancePerTick)
		{
			base.health = 0f;
			return;
		}
		if (overallQuality <= 0f)
		{
			ApplyDeathRate();
		}
		base.health += overallQuality * currentStage.health * growDeltaTime;
		if (yieldPool > 0f)
		{
			float num = currentStage.yield / (currentStage.lifeLengthSeconds / growDeltaTime);
			float num2 = Mathf.Min(yieldPool, num * (actualStageAgeIncrease / growDeltaTime));
			yieldPool -= num;
			float num3 = 1f + (float)Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) * 0.25f;
			Yield += num2 * 1f * num3;
		}
	}

	public void ApplyDeathRate()
	{
		float num = 0f;
		if (WaterQuality <= 0f)
		{
			num += 0.1f;
		}
		if (LightQuality <= 0f)
		{
			num += 0.1f;
		}
		if (GroundQuality <= 0f)
		{
			num += 0.1f;
		}
		if (TemperatureQuality <= 0f)
		{
			num += 0.1f;
		}
		base.health -= num;
	}

	public float GetGrowthBonus(float overallQuality)
	{
		float result = 1f + (float)Genes.GetGeneTypeCount(GrowableGenetics.GeneType.GrowthSpeed) * 0.25f;
		if (overallQuality <= 0f)
		{
			result = 1f;
		}
		return result;
	}

	public PlantProperties.State UpdateState()
	{
		if (stageAge <= currentStage.lifeLengthSeconds)
		{
			return State;
		}
		if (State == PlantProperties.State.Dying)
		{
			TellPlanter();
			Die();
			return PlantProperties.State.Dying;
		}
		if (currentStage.nextState <= State)
		{
			seasons++;
		}
		if (seasons >= Properties.MaxSeasons)
		{
			ChangeState(PlantProperties.State.Dying, resetAge: true);
		}
		else
		{
			ChangeState(currentStage.nextState, resetAge: true);
		}
		return State;
	}

	public void ConsumeWater()
	{
		if (State != PlantProperties.State.Dying && !((Object)(object)GetPlanter() == (Object)null))
		{
			int num = Mathf.CeilToInt(Mathf.Min((float)planter.soilSaturation, WaterConsumption));
			if ((float)num > 0f)
			{
				planter.ConsumeWater(num, this);
			}
		}
	}

	public void Fertilize()
	{
		if (!Fertilized)
		{
			Fertilized = true;
			CalculateQualities(firstTime: false);
			SendNetworkUpdate();
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_TakeClone(RPCMessage msg)
	{
		TakeClones(msg.player);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TakeCloneAll(RPCMessage msg)
	{
		if ((Object)(object)GetParentEntity() != (Object)null)
		{
			List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
			foreach (BaseEntity child in GetParentEntity().children)
			{
				if ((Object)(object)child != (Object)(object)this && child is GrowableEntity item)
				{
					list.Add(item);
				}
			}
			foreach (GrowableEntity item2 in list)
			{
				item2.TakeClones(msg.player);
			}
			Pool.FreeUnmanaged<GrowableEntity>(ref list);
		}
		TakeClones(msg.player);
	}

	public void TakeClones(BasePlayer player)
	{
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null || !CanClone() || Interface.CallHook("CanTakeCutting", (object)player, (object)this) != null)
		{
			return;
		}
		int num = Properties.BaseCloneCount + Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2;
		if (num > 0)
		{
			Item item = ItemManager.Create(Properties.CloneItem, num, 0uL);
			item.SetItemOwnership(player, ItemOwnershipPhrases.Cloned);
			GrowableGeneEncoding.EncodeGenesToItem(this, item);
			Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested);
			if (Properties.pickEffect.isValid)
			{
				Effect.server.Run(Properties.pickEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
			TellPlanter();
			Die();
		}
	}

	public void PickFruit(BasePlayer player, bool eat = false)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		if (!CanPick() || Interface.CallHook("OnGrowableGather", (object)this, (object)player, (object)eat) != null)
		{
			return;
		}
		harvests++;
		GiveFruit(player, CurrentPickAmount, eat);
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(player, ((Component)this).transform.position);
		}
		ResetSeason();
		if (Properties.pickEffect.isValid)
		{
			Effect.server.Run(Properties.pickEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		}
		if (harvests >= Properties.maxHarvests)
		{
			if (Properties.disappearAfterHarvest)
			{
				TellPlanter();
				Die();
			}
			else
			{
				ChangeState(PlantProperties.State.Dying, resetAge: true);
			}
		}
		else
		{
			ChangeState(PlantProperties.State.Mature, resetAge: true);
		}
	}

	public void GiveFruit(BasePlayer player, int amount, bool eat)
	{
		if (amount <= 0)
		{
			return;
		}
		bool enabled = Properties.pickupItem.condition.enabled;
		if (enabled)
		{
			for (int i = 0; i < amount; i++)
			{
				GiveFruit(player, 1, enabled, eat);
			}
		}
		else
		{
			GiveFruit(player, amount, enabled, eat);
		}
	}

	public void GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat)
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		Item item = ItemManager.Create(Properties.pickupItem, amount, 0uL);
		item.SetItemOwnership(player, ItemOwnershipPhrases.Harvested);
		if (applyCondition)
		{
			item.conditionNormalized = Properties.fruitVisualScaleCurve.Evaluate(StageProgressFraction);
		}
		if (eat && (Object)(object)player != (Object)null && IsFood())
		{
			ItemModConsume component = ((Component)item.info).GetComponent<ItemModConsume>();
			if ((Object)(object)component != (Object)null)
			{
				component.DoAction(item, player);
				return;
			}
		}
		if ((Object)(object)player != (Object)null)
		{
			Interface.CallHook("OnGrowableGathered", (object)this, (object)item, (object)player);
			Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested);
		}
		else
		{
			item.Drop(((Component)this).transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_PickFruit(RPCMessage msg)
	{
		PickFruit(msg.player);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_EatFruit(RPCMessage msg)
	{
		PickFruit(msg.player, eat: true);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_PickFruitAll(RPCMessage msg)
	{
		if ((Object)(object)GetParentEntity() != (Object)null)
		{
			List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
			foreach (BaseEntity child in GetParentEntity().children)
			{
				if ((Object)(object)child != (Object)(object)this && child is GrowableEntity item)
				{
					list.Add(item);
				}
			}
			foreach (GrowableEntity item2 in list)
			{
				item2.PickFruit(msg.player);
			}
			Pool.FreeUnmanaged<GrowableEntity>(ref list);
		}
		PickFruit(msg.player);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_RemoveDying(RPCMessage msg)
	{
		RemoveDying(msg.player);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_RemoveDyingAll(RPCMessage msg)
	{
		if ((Object)(object)GetParentEntity() != (Object)null)
		{
			List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
			foreach (BaseEntity child in GetParentEntity().children)
			{
				if ((Object)(object)child != (Object)(object)this && child is GrowableEntity item)
				{
					list.Add(item);
				}
			}
			foreach (GrowableEntity item2 in list)
			{
				item2.RemoveDying(msg.player);
			}
			Pool.FreeUnmanaged<GrowableEntity>(ref list);
		}
		RemoveDying(msg.player);
	}

	public void RemoveAllForce()
	{
		if ((Object)(object)GetParentEntity() != (Object)null)
		{
			List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
			foreach (BaseEntity child in GetParentEntity().children)
			{
				if ((Object)(object)child != (Object)(object)this && child is GrowableEntity item)
				{
					list.Add(item);
				}
			}
			foreach (GrowableEntity item2 in list)
			{
				item2.RemoveDying(null);
			}
			Pool.FreeUnmanaged<GrowableEntity>(ref list);
		}
		ForceRemove();
	}

	public void ForceRemove()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)Properties.removeDyingItem == (Object)null))
		{
			if (Properties.removeDyingEffect.isValid)
			{
				Effect.server.Run(Properties.removeDyingEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
			TellPlanter();
			Die();
		}
	}

	public void RemoveDying(BasePlayer receiver)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		if (State == PlantProperties.State.Dying && !((Object)(object)Properties.removeDyingItem == (Object)null) && Interface.CallHook("OnRemoveDying", (object)this, (object)receiver) == null)
		{
			if (Properties.removeDyingEffect.isValid)
			{
				Effect.server.Run(Properties.removeDyingEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
			Item item = ItemManager.Create(Properties.removeDyingItem, 1, 0uL);
			if ((Object)(object)receiver != (Object)null)
			{
				receiver.GiveItem(item, GiveItemReason.PickedUp);
			}
			else
			{
				item.Drop(((Component)this).transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
			}
			TellPlanter();
			Die();
		}
	}

	private void TellPlanter()
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity is PlanterBox planterBox)
		{
			planterBox.OnPlantRemoved(this, null);
		}
	}

	[ServerVar(ServerAdmin = true)]
	public static void GrowAll(Arg arg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin)
		{
			return;
		}
		List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
		Vis.Entities(basePlayer.ServerPosition, 6f, list, -1, (QueryTriggerInteraction)2);
		foreach (GrowableEntity item in list)
		{
			if (item.isServer)
			{
				item.ChangeState(item.currentStage.nextState, resetAge: false);
			}
		}
		Pool.FreeUnmanaged<GrowableEntity>(ref list);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_RequestQualityUpdate(RPCMessage msg)
	{
		if ((Object)(object)msg.player != (Object)null)
		{
			GrowableEntity val = Pool.Get<GrowableEntity>();
			val.lightModifier = LightQuality;
			val.groundModifier = GroundQuality;
			val.waterModifier = WaterQuality;
			val.happiness = OverallQuality;
			val.temperatureModifier = TemperatureQuality;
			val.waterConsumption = WaterConsumption;
			ClientRPC(RpcTarget.Player("RPC_ReceiveQualityUpdate", msg.player), val);
		}
	}
}


public class GrowableEntityUpdateQueue : ObjectWorkQueue<GrowableEntity>
{
	protected override void RunJob(GrowableEntity entity)
	{
		if (((ObjectWorkQueue<GrowableEntity>)this).ShouldAdd(entity))
		{
			entity.CalculateQualities_Water();
		}
	}

	protected override bool ShouldAdd(GrowableEntity entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;

public class GunTrap : StorageContainer
{
	public static class GunTrapFlags
	{
		public const Flags Triggered = Flags.Reserved1;
	}

	public class GunTrapScanWorkQueue : PersistentObjectWorkQueue<GunTrap>
	{
		protected override void RunJob(GunTrap entity)
		{
			if (((PersistentObjectWorkQueue<GunTrap>)this).ShouldAdd(entity))
			{
				entity.TriggerCheck();
			}
		}

		protected override bool ShouldAdd(GunTrap entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	public GameObjectRef gun_fire_effect;

	public GameObjectRef bulletEffect;

	public GameObjectRef triggeredEffect;

	public Transform muzzlePos;

	public Transform eyeTransform;

	public int numPellets = 15;

	public int aimCone = 30;

	public float sensorRadius = 1.25f;

	public ItemDefinition ammoType;

	public TargetTrigger trigger;

	private float triggerCooldown;

	private BuildingPrivlidge _cachedTc;

	private float _cacheTimeout;

	[ServerVar(Help = "How many milliseconds to spend on target scanning per frame")]
	public static float gun_trap_budget_ms = 0.5f;

	public static GunTrapScanWorkQueue updateGunTrapWorkQueue = new GunTrapScanWorkQueue();

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("GunTrap.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override string Categorize()
	{
		return "GunTrap";
	}

	public bool CanFire()
	{
		foreach (Item item in base.inventory.itemList)
		{
			if ((Object)(object)item.info == (Object)(object)ammoType && item.amount > 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool UseAmmo()
	{
		foreach (Item item in base.inventory.itemList)
		{
			if ((Object)(object)item.info == (Object)(object)ammoType && item.amount > 0)
			{
				item.UseItem();
				return true;
			}
		}
		return false;
	}

	public void FireWeapon()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (UseAmmo())
		{
			Effect.server.Run(gun_fire_effect.resourcePath, this, StringPool.Get(((Object)((Component)muzzlePos).gameObject).name), Vector3.zero, Vector3.zero);
			for (int i = 0; i < numPellets; i++)
			{
				FireBullet();
			}
		}
	}

	public void FireBullet()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		float damageAmount = 10f;
		Vector3 val = ((Component)muzzlePos).transform.position - muzzlePos.forward * 0.25f;
		Vector3 val2 = AimConeUtil.GetModifiedAimConeDirection(inputVec: ((Component)muzzlePos).transform.forward, aimCone: aimCone);
		ClientRPC(arg1: val + val2 * 300f, target: RpcTarget.NetworkGroup("CLIENT_FireGun"));
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		int layerMask = 1220225793;
		GamePhysics.TraceAll(new Ray(val, val2), 0.1f, list, 300f, layerMask, (QueryTriggerInteraction)0);
		for (int i = 0; i < list.Count; i++)
		{
			RaycastHit hit = list[i];
			BaseEntity entity = hit.GetEntity();
			if ((Object)(object)entity != (Object)null && ((Object)(object)entity == (Object)(object)this || entity.EqualNetID((BaseNetworkable)this)))
			{
				continue;
			}
			if ((Object)(object)(entity as BaseCombatEntity) != (Object)null)
			{
				HitInfo info = new HitInfo(this, entity, DamageType.Bullet, damageAmount, ((RaycastHit)(ref hit)).point);
				entity.OnAttacked(info);
				if (entity is BasePlayer || entity is BaseNpc)
				{
					Effect.server.ImpactEffect(new HitInfo
					{
						HitPositionWorld = ((RaycastHit)(ref hit)).point,
						HitNormalWorld = -((RaycastHit)(ref hit)).normal,
						HitMaterial = StringPool.Get("Flesh")
					});
				}
			}
			if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
			{
				Vector3 point = ((RaycastHit)(ref hit)).point;
				break;
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((PersistentObjectWorkQueue<GunTrap>)updateGunTrapWorkQueue).Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		((PersistentObjectWorkQueue<GunTrap>)updateGunTrapWorkQueue).Remove(this);
	}

	public void TriggerCheck()
	{
		if (!(triggerCooldown > Time.realtimeSinceStartup) && CheckTrigger())
		{
			FireWeapon();
			triggerCooldown = Time.realtimeSinceStartup + 0.5f;
		}
	}

	private BuildingPrivlidge GetCachedTc()
	{
		if ((Object)(object)_cachedTc != (Object)null && _cachedTc.IsDestroyed)
		{
			_cachedTc = null;
		}
		if ((Object)(object)_cachedTc == (Object)null || Time.realtimeSinceStartup > _cacheTimeout)
		{
			_cachedTc = null;
			BuildingManager.Building building = GetBuilding();
			if (building != null)
			{
				_cachedTc = building.GetDominatingBuildingPrivilege();
			}
			if ((Object)(object)_cachedTc == (Object)null)
			{
				return GetNearestBuildingPrivilege(cached: true, 3f);
			}
			_cacheTimeout = Time.realtimeSinceStartup + 3f;
		}
		return _cachedTc;
	}

	public bool CheckTrigger()
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		if (entityContents == null || entityContents.Count == 0)
		{
			return false;
		}
		if (!CanFire())
		{
			return false;
		}
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		BuildingPrivlidge cachedTc = GetCachedTc();
		bool flag = false;
		foreach (BaseEntity item in entityContents)
		{
			BasePlayer component = ((Component)item).GetComponent<BasePlayer>();
			if (component.IsSleeping() || !component.IsAlive() || (!((Object)(object)cachedTc == (Object)null) && cachedTc.IsAuthed(component)))
			{
				continue;
			}
			object obj = Interface.CallHook("CanBeTargeted", (object)component, (object)this);
			if (obj is bool)
			{
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				return (bool)obj;
			}
			list.Clear();
			Vector3 position = component.eyes.position;
			Vector3 val = GetEyePosition() - component.eyes.position;
			GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref val)).normalized), 0f, list, 9f, 1218519297, (QueryTriggerInteraction)0);
			for (int i = 0; i < list.Count; i++)
			{
				BaseEntity entity = list[i].GetEntity();
				if ((Object)(object)entity != (Object)null && ((Object)(object)entity == (Object)(object)this || entity.EqualNetID((BaseNetworkable)this)))
				{
					flag = true;
					break;
				}
				if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (flag)
			{
				break;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return flag;
	}

	public bool IsTriggered()
	{
		return HasFlag(Flags.Reserved1);
	}

	public Vector3 GetEyePosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return eyeTransform.position;
	}
}


public static class GunTrapFlags
{
	public const Flags Triggered = Flags.Reserved1;
}


public class GunTrapScanWorkQueue : PersistentObjectWorkQueue<GunTrap>
{
	protected override void RunJob(GunTrap entity)
	{
		if (((PersistentObjectWorkQueue<GunTrap>)this).ShouldAdd(entity))
		{
			entity.TriggerCheck();
		}
	}

	protected override bool ShouldAdd(GunTrap entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;

public class HackableLockedCrate : LootContainer
{
	public const Flags Flag_Hacking = Flags.Reserved1;

	public const Flags Flag_FullyHacked = Flags.Reserved2;

	public Text timerText;

	[ServerVar(Help = "How many seconds for the crate to unlock")]
	public static float requiredHackSeconds = 900f;

	[ServerVar(Help = "How many seconds until the crate is destroyed without any hack attempts")]
	public static float decaySeconds = 7200f;

	public SoundPlayer hackProgressBeep;

	public float hackSeconds;

	public GameObjectRef shockEffect;

	public GameObjectRef mapMarkerEntityPrefab;

	public GameObjectRef landEffect;

	public bool shouldDecay = true;

	public BasePlayer originalHackerPlayer;

	public ulong originalHackerPlayerId;

	public bool hasBeenOpened;

	public BaseEntity mapMarkerInstance;

	public bool hasLanded;

	public bool wasDropped;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HackableLockedCrate.OnRpcMessage", 0);
		try
		{
			if (rpc == 888500940 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Hack "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Hack", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(888500940u, "RPC_Hack", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Hack(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Hack");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsBeingHacked()
	{
		return HasFlag(Flags.Reserved1);
	}

	public bool IsFullyHacked()
	{
		return HasFlag(Flags.Reserved2);
	}

	public override void DestroyShared()
	{
		if (base.isServer && Object.op_Implicit((Object)(object)mapMarkerInstance))
		{
			mapMarkerInstance.Kill();
		}
		base.DestroyShared();
	}

	public void CreateMapMarker(float durationMinutes)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)mapMarkerInstance))
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, ((Component)this).transform.position, Quaternion.identity);
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		((Component)baseEntity).transform.localPosition = Vector3.zero;
		baseEntity.SendNetworkUpdate();
		mapMarkerInstance = baseEntity;
	}

	public void RefreshDecay()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)DelayedDestroy);
		if (shouldDecay)
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, decaySeconds);
		}
	}

	public void DelayedDestroy()
	{
		Kill();
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			if (StringPool.Get(info.HitBone) == "laptopcollision")
			{
				if (Interface.CallHook("OnCrateLaptopAttack", (object)this, (object)info) != null)
				{
					return;
				}
				Effect.server.Run(shockEffect.resourcePath, this, info.HitBone, info.HitPositionLocal, Vector3.up);
				hackSeconds -= 8f * (info.damageTypes.Total() / 50f);
				if (hackSeconds < 0f)
				{
					hackSeconds = 0f;
				}
			}
			RefreshDecay();
		}
		base.OnAttacked(info);
	}

	public void SetWasDropped()
	{
		wasDropped = true;
		Interface.CallHook("OnCrateDropped", (object)this);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (base.isClient)
		{
			return;
		}
		if (!Application.isLoadingSave)
		{
			SetFlag(Flags.Reserved1, b: false);
			SetFlag(Flags.Reserved2, b: false);
			if (wasDropped)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)LandCheck, 0f, 0.015f);
			}
			Analytics.Azure.OnEntitySpawned(this);
		}
		RefreshDecay();
		isLootable = IsFullyHacked();
		CreateMapMarker(120f);
		base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		if (!added && (Object)(object)mapMarkerInstance != (Object)null)
		{
			mapMarkerInstance.Kill();
		}
		base.OnItemAddedOrRemoved(item, added);
	}

	public void LandCheck()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (hasLanded)
		{
			Interface.CallHook("OnCrateLanded", (object)this);
		}
		else if (Physics.Raycast(new Ray(((Component)this).transform.position + Vector3.up * 0.5f, Vector3.down), ref val, 1f, 1084293377))
		{
			Effect.server.Run(landEffect.resourcePath, ((RaycastHit)(ref val)).point, Vector3.up);
			hasLanded = true;
			((FacepunchBehaviour)this).CancelInvoke((Action)LandCheck);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved1, b: false);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Hack(RPCMessage msg)
	{
		if (!IsBeingHacked() && Interface.CallHook("CanHackCrate", (object)msg.player, (object)this) == null)
		{
			Analytics.Azure.OnLockedCrateStarted(msg.player, this);
			originalHackerPlayerId = msg.player.userID;
			originalHackerPlayer = msg.player;
			StartHacking();
		}
	}

	public void StartHacking()
	{
		Interface.CallHook("OnCrateHack", (object)this);
		BroadcastEntityMessage("HackingStarted", 20f, 256);
		SetFlag(Flags.Reserved1, b: true);
		((FacepunchBehaviour)this).InvokeRepeating((Action)HackProgress, 1f, 1f);
		ClientRPC(RpcTarget.NetworkGroup("UpdateHackProgress"), 0, (int)requiredHackSeconds);
		RefreshDecay();
	}

	public void HackProgress()
	{
		hackSeconds += 1f;
		if (hackSeconds > requiredHackSeconds)
		{
			Interface.CallHook("OnCrateHackEnd", (object)this);
			Analytics.Azure.OnLockedCrateFinished(originalHackerPlayerId, this);
			if ((Object)(object)originalHackerPlayer != (Object)null && originalHackerPlayer.serverClan != null)
			{
				originalHackerPlayer.AddClanScore((ClanScoreEventType)5);
			}
			RefreshDecay();
			SetFlag(Flags.Reserved2, b: true);
			isLootable = true;
			((FacepunchBehaviour)this).CancelInvoke((Action)HackProgress);
		}
		ClientRPC(RpcTarget.NetworkGroup("UpdateHackProgress"), (int)hackSeconds, (int)requiredHackSeconds);
	}

	public override bool OnStartBeingLooted(BasePlayer player)
	{
		bool num = base.OnStartBeingLooted(player);
		if (num && !hasBeenOpened)
		{
			hasBeenOpened = true;
			player.AddClanScore((ClanScoreEventType)6);
		}
		return num;
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class Handcuffs : BaseMelee
{
	public static int PrisonerHoodItemID = -892718768;

	[ServerVar]
	public static float restrainedPushDamage = 5f;

	[ServerVar]
	public static float maxConditionRepairLossOnPush = 0.4f;

	[Header("Handcuffs")]
	public AnimatorOverrideController CaptiveHoldAnimationOverride;

	public GameObjectRef lockEffect;

	public GameObjectRef escapeEffect;

	[Header("Handcuff Behaviour")]
	public bool BlockInventory = true;

	public bool BlockSuicide = true;

	public bool BlockUse = true;

	public bool BlockCrafting = true;

	public float UnlockMiniGameDuration = 60f;

	public float UseDistance = 1.8f;

	public float ConditionLossPerSecond = 1f;

	private float unlockStartTime;

	private float startCondition;

	public bool Locked
	{
		get
		{
			if (GetItem() != null)
			{
				return GetItem().IsOn();
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Handcuffs.OnRpcMessage", 0);
		try
		{
			if (rpc == 695796023 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqCancelUnlockMiniGame "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqCancelUnlockMiniGame", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(695796023u, "RPC_ReqCancelUnlockMiniGame", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(695796023u, "RPC_ReqCancelUnlockMiniGame", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_ReqCancelUnlockMiniGame(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_ReqCancelUnlockMiniGame");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3883360127u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqCompleteUnlockMiniGame "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqCompleteUnlockMiniGame", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3883360127u, "RPC_ReqCompleteUnlockMiniGame", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3883360127u, "RPC_ReqCompleteUnlockMiniGame", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_ReqCompleteUnlockMiniGame(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_ReqCompleteUnlockMiniGame");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1571851761 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqLock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1571851761u, "RPC_ReqLock", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1571851761u, "RPC_ReqLock", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							RPC_ReqLock(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_ReqLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3248381320u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqStartUnlockMiniGame "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqStartUnlockMiniGame", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3248381320u, "RPC_ReqStartUnlockMiniGame", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3248381320u, "RPC_ReqStartUnlockMiniGame", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc5 = rPCMessage;
							RPC_ReqStartUnlockMiniGame(rpc5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_ReqStartUnlockMiniGame");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		Item item = GetItem();
		if (base.isServer && item != null)
		{
			SetLocked(Locked);
		}
		SetWMLocked(Locked);
	}

	private void SetWMLocked(bool flag)
	{
	}

	private void StartUnlockMiniGame()
	{
		InterruptUnlockMiniGame();
		unlockStartTime = Time.realtimeSinceStartup;
	}

	public void HeldWhenOwnerDied(BasePlayer player)
	{
		if (Locked)
		{
			SetLocked(flag: false, player);
		}
	}

	public void SetLocked(bool flag, BasePlayer player = null, Item handcuffsItem = null)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		if (handcuffsItem == null)
		{
			handcuffsItem = GetOwnerItem();
		}
		handcuffsItem?.SetFlag(Item.Flag.IsOn, flag);
		if ((Object)(object)player == (Object)null)
		{
			player = GetOwnerPlayer();
		}
		if (!((Object)(object)player == (Object)null))
		{
			player.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, flag);
			if (handcuffsItem != null)
			{
				player.restraintItemId = (flag ? new ItemId?(handcuffsItem.uid) : ((ItemId?)null));
			}
			else
			{
				player.restraintItemId = null;
			}
			if (BlockInventory)
			{
				player.inventory.SetLockedByRestraint(flag);
			}
			ClientRPC(RpcTarget.Player("CL_SetLocked", player), Locked);
		}
	}

	[ServerVar]
	public static void togglecuffslocked(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		HeldEntity heldEntity = basePlayer.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			Handcuffs handcuffs = heldEntity as Handcuffs;
			if (!((Object)(object)handcuffs == (Object)null))
			{
				handcuffs.SetLocked(!handcuffs.Locked, basePlayer);
			}
		}
	}

	private void ModifyConditionForElapsedTime(float elapsed)
	{
		if (unlockStartTime <= 0f || elapsed <= 0f)
		{
			return;
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null)
		{
			return;
		}
		float num = elapsed * ConditionLossPerSecond;
		if (num + 1f >= ownerItem.condition)
		{
			num = ownerItem.condition;
		}
		if (!(num > 1f) && !(num >= ownerItem.condition))
		{
			return;
		}
		ownerItem.condition -= num;
		if (ownerItem.condition <= 0f)
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				ownerPlayer.ApplyWoundedStartTime();
			}
			SetLocked(flag: false);
			ownerItem.UseItem();
		}
	}

	public void RepairOnPush()
	{
		if (base.isServer)
		{
			GetOwnerItem()?.DoRepair(maxConditionRepairLossOnPush);
		}
	}

	public void InterruptUnlockMiniGame(bool wasPushedOrDamaged = false)
	{
		if (base.isServer && unlockStartTime > 0f && !wasPushedOrDamaged)
		{
			ModifyConditionForElapsedTime(Time.realtimeSinceStartup - unlockStartTime);
		}
		unlockStartTime = 0f;
		if (base.isServer)
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if (!((Object)(object)ownerPlayer == (Object)null))
			{
				ClientRPC(RpcTarget.Player("CL_CancelUnlockMiniGame", ownerPlayer), wasPushedOrDamaged ? 2f : 0f);
			}
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void RPC_ReqStartUnlockMiniGame(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null))
		{
			SV_StartUnlockMiniGame(player);
		}
	}

	private void SV_StartUnlockMiniGame(BasePlayer player)
	{
		if (!player.IsDead() && !player.IsWounded())
		{
			StartUnlockMiniGame();
			ClientRPC(RpcTarget.Player("CL_StartUnlockMiniGame", player));
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	private void RPC_ReqCancelUnlockMiniGame(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null))
		{
			SV_CancelUnlockMiniGame(player);
		}
	}

	private void SV_CancelUnlockMiniGame(BasePlayer player)
	{
		InterruptUnlockMiniGame();
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	private void RPC_ReqCompleteUnlockMiniGame(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null))
		{
			SV_ReqCompleteUnlockMiniGame(player);
		}
	}

	private void SV_ReqCompleteUnlockMiniGame(BasePlayer player)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		InterruptUnlockMiniGame();
		Effect.server.Run(escapeEffect.resourcePath, player, 0u, Vector3.zero, Vector3.zero);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void RPC_ReqLock(RPCMessage rpc)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null))
		{
			NetworkableId uid = rpc.read.EntityID();
			BasePlayer basePlayer = BaseNetworkable.serverEntities.Find(uid) as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null))
			{
				SV_HandcuffVictim(basePlayer, player);
			}
		}
	}

	private void SV_HandcuffVictim(BasePlayer victim, BasePlayer handcuffer)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)victim == (Object)null || (Object)(object)handcuffer == (Object)null || victim.IsRestrained || (!victim.CurrentGestureIsSurrendering && !victim.IsWounded()) || Vector3.Distance(((Component)victim).transform.position, ((Component)handcuffer).transform.position) > UseDistance)
		{
			return;
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null || Interface.CallHook("OnPlayerHandcuff", (object)victim, (object)handcuffer) != null)
		{
			return;
		}
		victim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: true);
		victim.SendNetworkUpdateImmediate();
		ownerItem.SetFlag(Item.Flag.IsOn, b: true);
		bool flag = true;
		if (!ownerItem.MoveToContainer(victim.inventory.containerBelt))
		{
			Item slot = victim.inventory.containerBelt.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(victim.inventory.containerMain))
				{
					if (slot.contents != null)
					{
						slot.contents.SetLocked(isLocked: false, lockSubItems: true);
					}
					slot.DropAndTossUpwards(((Component)victim).transform.position);
				}
				if (!ownerItem.MoveToContainer(victim.inventory.containerBelt))
				{
					flag = false;
				}
			}
		}
		if (!flag)
		{
			ownerItem.SetFlag(Item.Flag.IsOn, b: false);
			victim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: false);
		}
		ownerItem.MarkDirty();
		if (flag)
		{
			victim.Server_CancelGesture();
			if (victim.IsBot)
			{
				Inventory.EquipItemInSlot(victim, 0);
			}
			victim.ClientRPC(RpcTarget.Player("SetActiveBeltSlot", victim), ownerItem.position, ownerItem.uid);
			SetLocked(flag: true, victim, ownerItem);
			Effect.server.Run(lockEffect.resourcePath, victim, 0u, Vector3.zero, Vector3.zero);
			Interface.CallHook("OnPlayerHandcuffed", (object)victim, (object)handcuffer);
		}
	}

	public void UnlockAndReturnToPlayer(BasePlayer returnToPlayer)
	{
		SetLocked(flag: false);
		if (!((Object)(object)returnToPlayer == (Object)null))
		{
			Item ownerItem = GetOwnerItem();
			if (ownerItem != null)
			{
				returnToPlayer.GiveItem(ownerItem);
			}
		}
	}

	public override bool CanHit(HitTest info)
	{
		if (info.HitEntity is BasePlayer basePlayer)
		{
			if (!basePlayer.CurrentGestureIsSurrendering && !basePlayer.IsSleeping())
			{
				return basePlayer.IsWounded();
			}
			return true;
		}
		return false;
	}

	public override void DoAttackShared(HitInfo info)
	{
		if (!base.isServer)
		{
			return;
		}
		BasePlayer basePlayer = info.HitEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null && (Object)(object)basePlayer != (Object)null)
			{
				SV_HandcuffVictim(basePlayer, ownerPlayer);
			}
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class HBHFSensor : BaseDetector
{
	public static int MinRange = 2;

	public static int MaxRange = 10;

	public int range = 10;

	public GameObjectRef detectUp;

	public GameObjectRef detectDown;

	public GameObjectRef panelPrefab;

	public const Flags Flag_IncludeOthers = Flags.Reserved2;

	public const Flags Flag_IncludeAuthed = Flags.Reserved3;

	private int detectedPlayers;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HBHFSensor.OnRpcMessage", 0);
		try
		{
			if (rpc == 4073303808u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetConfig "));
				}
				TimeWarning val2 = TimeWarning.New("SetConfig", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4073303808u, "SetConfig", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4073303808u, "SetConfig", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage config = rPCMessage;
							SetConfig(config);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetConfig");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return Mathf.Min(detectedPlayers, GetCurrentEnergy());
	}

	public override void OnObjects()
	{
		base.OnObjects();
		UpdatePassthroughAmount();
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdatePassthroughAmount, 0f, 1f, 0.1f);
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		UpdatePassthroughAmount();
		((FacepunchBehaviour)this).CancelInvoke((Action)UpdatePassthroughAmount);
	}

	public void UpdatePassthroughAmount()
	{
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || !IsPowered())
		{
			return;
		}
		int num = detectedPlayers;
		detectedPlayers = 0;
		if (myTrigger.entityContents != null && myTrigger.entityContents.Count > 0)
		{
			BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
			foreach (BaseEntity entityContent in myTrigger.entityContents)
			{
				if (entityContent is BasePlayer basePlayer && Interface.CallHook("OnSensorDetect", (object)this, (object)basePlayer) == null && !((Object)(object)basePlayer == (Object)null) && !basePlayer.IsDead() && !basePlayer.IsSleeping() && basePlayer.isServer)
				{
					bool flag = (Object)(object)buildingPrivilege != (Object)null && buildingPrivilege.IsAuthed(basePlayer);
					if ((!flag || ShouldIncludeAuthorized()) && (flag || ShouldIncludeOthers()) && entityContent.IsVisible(((Component)this).transform.position + ((Component)this).transform.forward * 0.1f, (float)range))
					{
						detectedPlayers++;
					}
				}
			}
		}
		if (num != detectedPlayers)
		{
			MarkDirty();
			if (detectedPlayers > num)
			{
				Effect.server.Run(detectUp.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
			else if (detectedPlayers < num)
			{
				Effect.server.Run(detectDown.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void SetConfig(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanUse(player))
		{
			bool b = msg.read.Bit();
			bool b2 = msg.read.Bit();
			SetFlag(Flags.Reserved3, b);
			SetFlag(Flags.Reserved2, b2);
			int num = msg.read.Int32();
			SetRange(num);
		}
	}

	public void SetRange(int value)
	{
		value = Mathf.Clamp(value, MinRange, MaxRange);
		range = value;
		SendNetworkUpdate();
	}

	public bool CanUse(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseHBHFSensor", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

	public bool ShouldIncludeAuthorized()
	{
		return HasFlag(Flags.Reserved3);
	}

	public bool ShouldIncludeOthers()
	{
		return HasFlag(Flags.Reserved2);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericInt1 = range;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			range = info.msg.ioEntity.genericInt1;
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class HeldBoomBox : HeldEntity, ICassettePlayer
{
	public BoomBox BoxController;

	public SwapKeycard cassetteSwapper;

	public BaseEntity ToBaseEntity => this;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HeldBoomBox.OnRpcMessage", 0);
		try
		{
			if (rpc == 1918716764 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_UpdateRadioIP "));
				}
				TimeWarning val2 = TimeWarning.New("Server_UpdateRadioIP", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1918716764u, "Server_UpdateRadioIP", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(1918716764u, "Server_UpdateRadioIP", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_UpdateRadioIP(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_UpdateRadioIP");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1785864031 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerTogglePlay "));
				}
				TimeWarning val2 = TimeWarning.New("ServerTogglePlay", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1785864031u, "ServerTogglePlay", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(1785864031u, "ServerTogglePlay", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ServerTogglePlay(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerTogglePlay");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		BoxController.HurtCallback = HurtCallback;
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.IsActiveItem]
	public void ServerTogglePlay(RPCMessage msg)
	{
		BoxController.ServerTogglePlay(msg);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.IsActiveItem]
	private void Server_UpdateRadioIP(RPCMessage msg)
	{
		BoxController.Server_UpdateRadioIP(msg);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		BoxController.Save(info);
	}

	public void OnCassetteInserted(Cassette c)
	{
		BoxController.OnCassetteInserted(c);
	}

	public void OnCassetteRemoved(Cassette c)
	{
		BoxController.OnCassetteRemoved(c);
	}

	public bool ClearRadioByUserId(ulong id)
	{
		return BoxController.ClearRadioByUserId(id);
	}

	public void HurtCallback(float amount)
	{
		if ((Object)(object)GetOwnerPlayer() != (Object)null && GetOwnerPlayer().IsSleeping())
		{
			BoxController.ServerTogglePlay(play: false);
		}
		else
		{
			GetItem()?.LoseCondition(amount);
		}
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		if (IsDisabled())
		{
			BoxController.ServerTogglePlay(play: false);
		}
	}

	public override void Load(LoadInfo info)
	{
		BoxController.Load(info);
		base.Load(info);
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class HeldEntity : BaseEntity
{
	[Serializable]
	public class HolsterInfo
	{
		public enum HolsterSlot
		{
			BACK,
			RIGHT_THIGH,
			LEFT_THIGH,
			BACK_SHIELD
		}

		public enum BackpackSlot
		{
			LEFT,
			RIGHT
		}

		public HolsterSlot slot;

		public BackpackSlot backpackSlot;

		public bool displayWhenHolstered;

		public string holsterBone = "spine3";

		public Vector3 holsterOffset;

		public Vector3 holsterRotationOffset;

		public Vector3 backpackHolsterOffset;

		public Vector3 backpackHolsterRotationOffset;

		public Quaternion holsterRotationOffsetQ
		{
			get
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_001e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0018: Unknown result type (might be due to invalid IL or missing references)
				if (!(holsterRotationOffset == Vector3.zero))
				{
					return Quaternion.Euler(holsterRotationOffset);
				}
				return Quaternion.identity;
			}
		}

		public Quaternion backpackHolsterRotationOffsetQ
		{
			get
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_001e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0018: Unknown result type (might be due to invalid IL or missing references)
				if (!(backpackHolsterRotationOffset == Vector3.zero))
				{
					return Quaternion.Euler(backpackHolsterRotationOffset);
				}
				return Quaternion.identity;
			}
		}
	}

	public static class HeldEntityFlags
	{
		public const Flags Deployed = Flags.Reserved4;

		public const Flags LightsOn = Flags.Reserved5;

		public const Flags ShieldEquipped = Flags.Reserved13;
	}

	public enum heldEntityVisState
	{
		UNSET,
		Invis,
		Hand,
		Holster,
		GenericVis
	}

	public Animator worldModelAnimator;

	public SoundDefinition thirdPersonDeploySound;

	public SoundDefinition thirdPersonAimSound;

	public SoundDefinition thirdPersonAimEndSound;

	public const Flags Flag_ForceVisible = Flags.Reserved8;

	[Header("Held Entity")]
	public string handBone = "r_prop";

	public AnimatorOverrideController HoldAnimationOverride;

	public bool isBuildingTool;

	public bool canBeUsedWithShield;

	public HolsterInfo holsterInfo;

	[Header("Hostility")]
	public float hostileScore;

	[Header("Camera")]
	public BasePlayer.CameraMode HeldCameraMode;

	public Vector3 FirstPersonArmOffset;

	public Vector3 FirstPersonArmRotation;

	[Range(0f, 1f)]
	public float FirstPersonRotationStrength = 1f;

	public bool holsterVisible;

	public bool genericVisible;

	private heldEntityVisState currentVisState;

	public ItemId ownerItemUID;

	private Item cachedItem;

	public bool hostile => hostileScore > 0f;

	public virtual Transform MuzzleTransform => null;

	public virtual ItemModWearable WearableWhileEquipped => null;

	public virtual bool IsShield => false;

	protected bool UsingInfiniteAmmoCheat
	{
		get
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer == (Object)null || (!ownerPlayer.IsAdmin && !ownerPlayer.IsDeveloper))
			{
				return false;
			}
			return ownerPlayer.GetInfoBool("player.infiniteammo", defaultVal: false);
		}
	}

	public virtual bool IsUsableByTurret => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HeldEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool LightsOn()
	{
		return HasFlag(Flags.Reserved5);
	}

	public bool IsDeployed()
	{
		return HasFlag(Flags.Reserved4);
	}

	public bool HasShieldEquipped()
	{
		return HasFlag(Flags.Reserved13);
	}

	public BasePlayer GetOwnerPlayer()
	{
		BaseEntity baseEntity = GetParentEntity();
		if (!baseEntity.IsValid())
		{
			return null;
		}
		BasePlayer basePlayer = baseEntity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return null;
		}
		if (basePlayer.IsDead())
		{
			return null;
		}
		return basePlayer;
	}

	public Connection GetOwnerConnection()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return null;
		}
		if (ownerPlayer.net == null)
		{
			return null;
		}
		return ownerPlayer.net.connection;
	}

	public virtual void SetOwnerPlayer(BasePlayer player)
	{
		Assert.IsTrue(base.isServer, "Should be server!");
		Assert.IsTrue(player.isServer, "Player should be serverside!");
		((Component)this).gameObject.Identity();
		SetParent(player, handBone);
		if (!IsShield)
		{
			SetHeld(bHeld: false);
		}
	}

	public virtual void ClearOwnerPlayer()
	{
		Assert.IsTrue(base.isServer, "Should be server!");
		SetHeld(bHeld: false);
		SetParent(null);
	}

	public virtual void SetVisibleWhileHolstered(bool visible)
	{
		if (holsterInfo.displayWhenHolstered)
		{
			holsterVisible = visible;
			genericVisible = false;
			UpdateHeldItemVisibility();
		}
	}

	public virtual void SetGenericVisible(bool wantsVis)
	{
		genericVisible = wantsVis;
		SetFlag(Flags.Reserved8, wantsVis);
		UpdateHeldItemVisibility();
	}

	public uint GetBone(string bone)
	{
		return StringPool.Get(bone);
	}

	public virtual void SetLightsOn(bool isOn)
	{
		SetFlag(Flags.Reserved5, isOn);
	}

	public void UpdateHeldItemVisibility()
	{
		bool flag = false;
		if (!genericVisible && Object.op_Implicit((Object)(object)GetOwnerPlayer()))
		{
			bool flag2 = (Object)(object)GetOwnerPlayer().GetHeldEntity() == (Object)(object)this || IsShield;
			flag = ((!Server.showHolsteredItems && !flag2) ? UpdateVisiblity_Invis() : (flag2 ? UpdateVisibility_Hand() : ((!holsterVisible) ? UpdateVisiblity_Invis() : UpdateVisiblity_Holster())));
		}
		else if (genericVisible)
		{
			flag = UpdateVisibility_GenericVis();
		}
		else if (!genericVisible)
		{
			flag = UpdateVisiblity_Invis();
		}
		if (flag)
		{
			SendNetworkUpdate();
		}
	}

	public bool UpdateVisibility_Hand()
	{
		if (currentVisState == heldEntityVisState.Hand)
		{
			return false;
		}
		currentVisState = heldEntityVisState.Hand;
		base.limitNetworking = false;
		SetFlag(Flags.Disabled, b: false);
		SetParent(GetOwnerPlayer(), GetBone(handBone));
		return true;
	}

	public bool UpdateVisibility_GenericVis()
	{
		if (currentVisState == heldEntityVisState.GenericVis)
		{
			return false;
		}
		currentVisState = heldEntityVisState.GenericVis;
		base.limitNetworking = false;
		SetFlag(Flags.Disabled, b: false);
		return true;
	}

	public bool UpdateVisiblity_Holster()
	{
		if (currentVisState == heldEntityVisState.Holster)
		{
			return false;
		}
		currentVisState = heldEntityVisState.Holster;
		base.limitNetworking = false;
		SetFlag(Flags.Disabled, b: false);
		SetParent(GetOwnerPlayer(), GetBone(holsterInfo.holsterBone));
		return true;
	}

	public bool UpdateVisiblity_Invis()
	{
		if (currentVisState == heldEntityVisState.Invis)
		{
			return false;
		}
		currentVisState = heldEntityVisState.Invis;
		SetParent(GetOwnerPlayer(), GetBone(handBone));
		base.limitNetworking = true;
		SetFlag(Flags.Disabled, b: true);
		return true;
	}

	public virtual void SetHeld(bool bHeld)
	{
		Assert.IsTrue(base.isServer, "Should be server!");
		bool num = HasFlag(Flags.Reserved4);
		SetFlag(Flags.Reserved4, bHeld);
		if (!bHeld)
		{
			UpdateVisiblity_Invis();
		}
		if (num || bHeld)
		{
			UpdateShieldState(bHeld && canBeUsedWithShield);
		}
		base.limitNetworking = !bHeld;
		SetFlag(Flags.Disabled, !bHeld);
		SendNetworkUpdate();
		OnHeldChanged();
	}

	public void UpdateShieldState(bool bHeld)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer != (Object)null))
		{
			return;
		}
		Item anyBackpack = ownerPlayer.inventory.GetAnyBackpack();
		ItemModShield itemModShield = default(ItemModShield);
		if (canBeUsedWithShield && anyBackpack != null && ((Component)anyBackpack.info).TryGetComponent<ItemModShield>(ref itemModShield))
		{
			HeldEntity heldEntity = anyBackpack.GetHeldEntity() as HeldEntity;
			if (anyBackpack.isBroken)
			{
				bHeld = false;
			}
			if ((Object)(object)heldEntity != (Object)null && bHeld)
			{
				heldEntity.UpdateVisibility_Hand();
				heldEntity.SetFlag(Flags.Reserved4, b: true);
				SetFlag(Flags.Reserved13, b: true);
				return;
			}
			if ((Object)(object)heldEntity != (Object)null)
			{
				heldEntity.UpdateVisiblity_Holster();
				heldEntity.SetFlag(Flags.Reserved4, b: false);
			}
			SetFlag(Flags.Reserved13, b: false);
		}
		else
		{
			SetFlag(Flags.Reserved13, b: false);
		}
	}

	public virtual void OnHeldChanged()
	{
	}

	public virtual bool CanBeUsedInWater()
	{
		return false;
	}

	public virtual bool BlocksGestures()
	{
		return false;
	}

	protected Item GetOwnerItem()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null || (Object)(object)ownerPlayer.inventory == (Object)null)
		{
			return null;
		}
		return ownerPlayer.inventory.FindItemByUID(ownerItemUID);
	}

	public override Item GetItem()
	{
		return GetOwnerItem();
	}

	public ItemDefinition GetOwnerItemDefinition()
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null)
		{
			Debug.LogWarning((object)"GetOwnerItem - null!", (Object)(object)this);
			return null;
		}
		return ownerItem.info;
	}

	public virtual void CollectedForCrafting(Item item, BasePlayer crafter)
	{
	}

	public virtual void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
	{
	}

	public virtual void ServerCommand(Item item, string command, BasePlayer player)
	{
	}

	public virtual void SetupHeldEntity(Item item)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		ownerItemUID = item.uid;
		InitOwnerPlayer();
	}

	public Item GetCachedItem()
	{
		return cachedItem;
	}

	public void OnItemChanged(Item item)
	{
		cachedItem = item;
	}

	public override void PostServerLoad()
	{
		InitOwnerPlayer();
	}

	private void InitOwnerPlayer()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			SetOwnerPlayer(ownerPlayer);
		}
		else
		{
			ClearOwnerPlayer();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.heldEntity = Pool.Get<HeldEntity>();
		info.msg.heldEntity.itemUID = ownerItemUID;
	}

	public void DestroyThis()
	{
		GetOwnerItem()?.Remove();
	}

	protected bool HasItemAmount()
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			return ownerItem.amount > 0;
		}
		return false;
	}

	protected bool UseItemAmount(int iAmount, bool reduceItemOwnership = true)
	{
		if (iAmount <= 0)
		{
			return true;
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null)
		{
			DestroyThis();
			return true;
		}
		ownerItem.amount -= iAmount;
		ownerItem.MarkDirty();
		if (reduceItemOwnership)
		{
			ownerItem.ReduceItemOwnership(iAmount);
		}
		if (ownerItem.amount <= 0)
		{
			DestroyThis();
			return true;
		}
		return false;
	}

	public virtual void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
	}

	public virtual void ServerTick(BasePlayer byPlayer)
	{
	}

	public virtual bool IsInstrument()
	{
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.heldEntity != null)
		{
			ownerItemUID = info.msg.heldEntity.itemUID;
		}
	}

	public void SendPunch(Vector3 amount, float duration)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.Player("CL_Punch", GetOwnerPlayer()), amount, duration);
	}
}


using System;
using UnityEngine;

[Serializable]
public class HolsterInfo
{
	public enum HolsterSlot
	{
		BACK,
		RIGHT_THIGH,
		LEFT_THIGH,
		BACK_SHIELD
	}

	public enum BackpackSlot
	{
		LEFT,
		RIGHT
	}

	public HolsterSlot slot;

	public BackpackSlot backpackSlot;

	public bool displayWhenHolstered;

	public string holsterBone = "spine3";

	public Vector3 holsterOffset;

	public Vector3 holsterRotationOffset;

	public Vector3 backpackHolsterOffset;

	public Vector3 backpackHolsterRotationOffset;

	public Quaternion holsterRotationOffsetQ
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (!(holsterRotationOffset == Vector3.zero))
			{
				return Quaternion.Euler(holsterRotationOffset);
			}
			return Quaternion.identity;
		}
	}

	public Quaternion backpackHolsterRotationOffsetQ
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (!(backpackHolsterRotationOffset == Vector3.zero))
			{
				return Quaternion.Euler(backpackHolsterRotationOffset);
			}
			return Quaternion.identity;
		}
	}
}


public enum HolsterSlot
{
	BACK,
	RIGHT_THIGH,
	LEFT_THIGH,
	BACK_SHIELD
}


public enum BackpackSlot
{
	LEFT,
	RIGHT
}


public static class HeldEntityFlags
{
	public const Flags Deployed = Flags.Reserved4;

	public const Flags LightsOn = Flags.Reserved5;

	public const Flags ShieldEquipped = Flags.Reserved13;
}


public enum heldEntityVisState
{
	UNSET,
	Invis,
	Hand,
	Holster,
	GenericVis
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class HotAirBalloon : BaseCombatEntity, VehicleSpawner.IVehicleSpawnUser, SamSite.ISamSiteTarget, SeekerTarget.ISeekerTargetOwner
{
	[Serializable]
	public struct UpgradeOption
	{
		public ItemDefinition TokenItem;

		public Phrase Title;

		public Phrase Description;

		public Sprite Icon;

		public int order;
	}

	public const Flags Flag_HasFuel = Flags.Reserved6;

	public const Flags Flag_Grounded = Flags.Reserved7;

	public const Flags Flag_CanModifyEquipment = Flags.Reserved8;

	public const Flags Flag_HalfInflated = Flags.Reserved1;

	public const Flags Flag_FullInflated = Flags.Reserved2;

	public const Flags Flag_OnlyOwnerEntry = Flags.Locked;

	public Transform centerOfMass;

	public Rigidbody myRigidbody;

	public Transform buoyancyPoint;

	public float liftAmount = 10f;

	public Transform windSock;

	public Transform[] windFlags;

	public GameObject staticBalloonDeflated;

	public GameObject staticBalloon;

	public GameObject animatedBalloon;

	public Animator balloonAnimator;

	public Transform groundSample;

	public float inflationLevel;

	[Header("Fuel")]
	public GameObjectRef fuelStoragePrefab;

	public float fuelPerSec = 0.25f;

	[Header("Storage")]
	public GameObjectRef storageUnitPrefab;

	public EntityRef<StorageContainer> storageUnitInstance;

	[Header("Damage")]
	public DamageRenderer damageRenderer;

	public Transform engineHeight;

	public GameObject[] killTriggers;

	[Header("Upgrades")]
	public List<UpgradeOption> UpgradeOptions;

	public EntityFuelSystem fuelSystem;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population = 1f;

	[ServerVar(Help = "How long before a HAB loses all its health while outside")]
	public static float outsidedecayminutes = 180f;

	public float NextUpgradeTime;

	public float windForce = 30000f;

	public Vector3 currentWindVec = Vector3.zero;

	public Bounds collapsedBounds;

	public Bounds raisedBounds;

	public GameObject[] balloonColliders;

	[ServerVar]
	public static float serviceCeiling = 175f;

	[ServerVar]
	public static float minimumAltitudeTerrain = 25f;

	public Vector3 lastFailedDecayPosition = Vector3.zero;

	public float currentBuoyancy;

	public TimeSince sinceLastBlast;

	public float avgTerrainHeight;

	public bool grounded;

	public float spawnTime = -1f;

	public float safeAreaRadius;

	public Vector3 safeAreaOrigin;

	public bool IsFullyInflated => inflationLevel >= 1f;

	public bool Grounded => HasFlag(Flags.Reserved7);

	public SamSite.SamTargetType SAMTargetType => SamSite.targetTypeVehicle;

	public bool IsClient => base.isClient;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HotAirBalloon.OnRpcMessage", 0);
		try
		{
			if (rpc == 578721460 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - EngineSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("EngineSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(578721460u, "EngineSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							EngineSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in EngineSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						RPC_OpenFuel(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2441951484u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqEquipItem "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqEquipItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2441951484u, "RPC_ReqEquipItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_ReqEquipItem(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_ReqEquipItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		fuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
	}

	public override void Load(LoadInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.hotAirBalloon != null)
		{
			inflationLevel = info.msg.hotAirBalloon.inflationAmount;
			sinceLastBlast = TimeSince.op_Implicit(info.msg.hotAirBalloon.sinceLastBlast);
			if (info.fromDisk && Object.op_Implicit((Object)(object)myRigidbody))
			{
				myRigidbody.velocity = info.msg.hotAirBalloon.velocity;
			}
		}
		if (info.msg.motorBoat != null)
		{
			fuelSystem.SetInstanceID(info.msg.motorBoat.fuelStorageID);
			storageUnitInstance.uid = info.msg.motorBoat.storageid;
		}
	}

	public bool CanModifyEquipment()
	{
		if (base.isServer && Time.time < NextUpgradeTime)
		{
			return false;
		}
		return true;
	}

	public void DelayNextUpgrade(float delay)
	{
		if (Time.time + delay > NextUpgradeTime)
		{
			NextUpgradeTime = Time.time + delay;
		}
	}

	public int GetEquipmentCount(ItemModHABEquipment item)
	{
		int num = 0;
		for (int num2 = children.Count - 1; num2 >= 0; num2--)
		{
			BaseEntity baseEntity = children[num2];
			if (!((Object)(object)baseEntity == (Object)null) && baseEntity.prefabID == item.Prefab.resourceID)
			{
				num++;
			}
		}
		return num;
	}

	public void RemoveItemsOfType(ItemModHABEquipment item)
	{
		for (int num = children.Count - 1; num >= 0; num--)
		{
			BaseEntity baseEntity = children[num];
			if (!((Object)(object)baseEntity == (Object)null) && baseEntity.prefabID == item.Prefab.resourceID)
			{
				baseEntity.Kill();
			}
		}
	}

	public bool WaterLogged()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return WaterLevel.Test(engineHeight.position, waves: true, volumes: true, this);
	}

	public bool OnlyOwnerAccessible()
	{
		return HasFlag(Flags.Locked);
	}

	public override void OnAttacked(HitInfo info)
	{
		if (IsSafe() && !info.damageTypes.Has(DamageType.Decay))
		{
			info.damageTypes.ScaleAll(0f);
		}
		base.OnAttacked(info);
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer)
		{
			if (isSpawned)
			{
				fuelSystem.CheckNewChild(child);
			}
			if (child.prefabID == storageUnitPrefab.GetEntity().prefabID)
			{
				storageUnitInstance.Set((StorageContainer)child);
				_ = storageUnitInstance.Get(serverside: true).inventory;
			}
			bool isLoadingSave = Application.isLoadingSave;
			HotAirBalloonEquipment hotAirBalloonEquipment = child as HotAirBalloonEquipment;
			if ((Object)(object)hotAirBalloonEquipment != (Object)null)
			{
				hotAirBalloonEquipment.Added(this, isLoadingSave);
			}
		}
	}

	protected override void OnChildRemoved(BaseEntity child)
	{
		base.OnChildRemoved(child);
		if (base.isServer)
		{
			HotAirBalloonEquipment hotAirBalloonEquipment = child as HotAirBalloonEquipment;
			if ((Object)(object)hotAirBalloonEquipment != (Object)null)
			{
				hotAirBalloonEquipment.Removed(this);
			}
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot && storageUnitInstance.IsValid(base.isServer))
		{
			storageUnitInstance.Get(base.isServer).DropItems();
		}
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.DoServerDestroy();
	}

	public bool IsValidSAMTarget(bool staticRespawn)
	{
		if (myRigidbody.IsSleeping() || myRigidbody.isKinematic)
		{
			return false;
		}
		if (staticRespawn)
		{
			return IsFullyInflated;
		}
		if (IsFullyInflated)
		{
			return !InSafeZone();
		}
		return false;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		ClearOwnerEntry();
		SetFlag(Flags.On, b: false);
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && (!OnlyOwnerAccessible() || !((Object)(object)msg.player != (Object)(object)creatorEntity)))
		{
			fuelSystem.LootFuel(player);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.hotAirBalloon = Pool.Get<HotAirBalloon>();
		info.msg.hotAirBalloon.inflationAmount = inflationLevel;
		info.msg.hotAirBalloon.sinceLastBlast = TimeSince.op_Implicit(sinceLastBlast);
		if (info.forDisk && Object.op_Implicit((Object)(object)myRigidbody))
		{
			info.msg.hotAirBalloon.velocity = myRigidbody.velocity;
		}
		info.msg.motorBoat = Pool.Get<Motorboat>();
		info.msg.motorBoat.storageid = storageUnitInstance.uid;
		info.msg.motorBoat.fuelStorageID = fuelSystem.GetInstanceID();
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		myRigidbody.centerOfMass = centerOfMass.localPosition;
		myRigidbody.isKinematic = false;
		avgTerrainHeight = TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position);
		base.ServerInit();
		bounds = collapsedBounds;
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayTick, Random.Range(30f, 60f), 60f, 6f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateIsGrounded, 0f, 3f, 0.2f);
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	public void DecayTick()
	{
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (base.healthFraction == 0f)
		{
			return;
		}
		if (IsFullyInflated)
		{
			bool flag = true;
			if (lastFailedDecayPosition != Vector3.zero && Distance(lastFailedDecayPosition) < 2f)
			{
				flag = false;
			}
			lastFailedDecayPosition = ((Component)this).transform.position;
			if (flag)
			{
				return;
			}
			myRigidbody.AddForceAtPosition(Vector3.up * (0f - Physics.gravity.y) * myRigidbody.mass * 20f, buoyancyPoint.position, (ForceMode)0);
			myRigidbody.AddForceAtPosition(Vector3Ex.WithY(Random.onUnitSphere, 0f) * 20f, buoyancyPoint.position, (ForceMode)0);
		}
		if (!(TimeSince.op_Implicit(sinceLastBlast) < 600f))
		{
			float num = 1f / outsidedecayminutes;
			if (IsOutside() || IsFullyInflated)
			{
				Hurt(MaxHealth() * num, DamageType.Decay, this, useProtection: false);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void EngineSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnHotAirBalloonToggle", (object)this, (object)msg.player) != null)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && (!OnlyOwnerAccessible() || !((Object)(object)player != (Object)(object)creatorEntity)))
		{
			bool b = msg.read.Bit();
			SetFlag(Flags.On, b);
			if (IsOn())
			{
				((FacepunchBehaviour)this).Invoke((Action)ScheduleOff, 60f);
				Interface.CallHook("OnHotAirBalloonToggled", (object)this, (object)msg.player);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ScheduleOff);
				Interface.CallHook("OnHotAirBalloonToggled", (object)this, (object)msg.player);
			}
		}
	}

	public void ScheduleOff()
	{
		SetFlag(Flags.On, b: false);
	}

	public void UpdateIsGrounded()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(((Component)groundSample).transform.position, 1.25f, list, 1218511105, (QueryTriggerInteraction)1);
		grounded = list.Count > 0;
		CheckGlobal(flags);
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			CheckGlobal(next);
			if ((Object)(object)myRigidbody != (Object)null)
			{
				myRigidbody.isKinematic = IsTransferProtected();
			}
		}
	}

	public void CheckGlobal(Flags flags)
	{
		bool wants = flags.HasFlag(Flags.On) || flags.HasFlag(Flags.Reserved2) || flags.HasFlag(Flags.Reserved1) || !grounded;
		EnableGlobalBroadcast(wants);
	}

	protected void FixedUpdate()
	{
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_0450: Unknown result type (might be due to invalid IL or missing references)
		//IL_0455: Unknown result type (might be due to invalid IL or missing references)
		//IL_045a: Unknown result type (might be due to invalid IL or missing references)
		//IL_045f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0505: Unknown result type (might be due to invalid IL or missing references)
		//IL_0516: Unknown result type (might be due to invalid IL or missing references)
		//IL_051d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0543: Unknown result type (might be due to invalid IL or missing references)
		//IL_0549: Unknown result type (might be due to invalid IL or missing references)
		if (!isSpawned || base.isClient || IsTransferProtected())
		{
			return;
		}
		if (!fuelSystem.HasFuel() || WaterLogged())
		{
			SetFlag(Flags.On, b: false);
		}
		if (IsOn())
		{
			fuelSystem.TryUseFuel(Time.fixedDeltaTime, fuelPerSec);
		}
		SetFlag(Flags.Reserved6, fuelSystem.HasFuel());
		SetFlag(Flags.Reserved7, grounded);
		SetFlag(Flags.Reserved8, CanModifyEquipment());
		bool flag = (IsFullyInflated && myRigidbody.velocity.y < 0f) || myRigidbody.velocity.y < 0.75f;
		GameObject[] array = killTriggers;
		foreach (GameObject val in array)
		{
			if (val.activeSelf != flag)
			{
				val.SetActive(flag);
			}
		}
		float num = inflationLevel;
		if (IsOn() && !IsFullyInflated)
		{
			inflationLevel = Mathf.Clamp01(inflationLevel + Time.fixedDeltaTime / 10f);
		}
		else if (grounded && inflationLevel > 0f && !IsOn() && (TimeSince.op_Implicit(sinceLastBlast) > 30f || WaterLogged()))
		{
			inflationLevel = Mathf.Clamp01(inflationLevel - Time.fixedDeltaTime / 10f);
		}
		if (num != inflationLevel)
		{
			if (IsFullyInflated)
			{
				bounds = raisedBounds;
			}
			else if (inflationLevel == 0f)
			{
				bounds = collapsedBounds;
			}
			SetFlag(Flags.Reserved1, inflationLevel > 0.3f);
			SetFlag(Flags.Reserved2, inflationLevel >= 1f);
			SendNetworkUpdate();
			_ = inflationLevel;
		}
		bool flag2 = !myRigidbody.IsSleeping() || inflationLevel > 0f;
		array = balloonColliders;
		foreach (GameObject val2 in array)
		{
			if (val2.activeSelf != flag2)
			{
				val2.SetActive(flag2);
			}
		}
		if (IsOn())
		{
			if (IsFullyInflated)
			{
				currentBuoyancy += Time.fixedDeltaTime * 0.2f;
				sinceLastBlast = TimeSince.op_Implicit(0f);
			}
		}
		else
		{
			currentBuoyancy -= Time.fixedDeltaTime * 0.1f;
		}
		currentBuoyancy = Mathf.Clamp(currentBuoyancy, 0f, 0.8f + 0.2f * base.healthFraction);
		if (inflationLevel > 0f)
		{
			float num2 = Mathf.Max(minimumAltitudeTerrain, TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position));
			avgTerrainHeight = Mathf.Lerp(avgTerrainHeight, num2, Time.deltaTime);
			float num3 = 1f - Mathf.InverseLerp(avgTerrainHeight + serviceCeiling - 20f, avgTerrainHeight + serviceCeiling, buoyancyPoint.position.y);
			myRigidbody.AddForceAtPosition(Vector3.up * (0f - Physics.gravity.y) * myRigidbody.mass * 0.5f * inflationLevel, buoyancyPoint.position, (ForceMode)0);
			myRigidbody.AddForceAtPosition(Vector3.up * liftAmount * currentBuoyancy * num3, buoyancyPoint.position, (ForceMode)0);
			Vector3 windAtPos = GetWindAtPos(buoyancyPoint.position);
			_ = ((Vector3)(ref windAtPos)).magnitude;
			float num4 = 1f;
			float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(buoyancyPoint.position, waves: false, volumes: false);
			float num5 = Mathf.InverseLerp(waterOrTerrainSurface + 20f, waterOrTerrainSurface + 60f, buoyancyPoint.position.y);
			float num6 = 1f;
			RaycastHit val3 = default(RaycastHit);
			if (Physics.SphereCast(new Ray(((Component)this).transform.position + Vector3.up * 2f, Vector3.down), 1.5f, ref val3, 5f, 1218511105))
			{
				num6 = Mathf.Clamp01(((RaycastHit)(ref val3)).distance / 5f);
			}
			num4 *= num5 * num3 * num6;
			num4 *= 0.2f + 0.8f * base.healthFraction;
			Vector3 val4 = ((Vector3)(ref windAtPos)).normalized * num4 * windForce;
			currentWindVec = Vector3.Lerp(currentWindVec, val4, Time.fixedDeltaTime * 0.25f);
			myRigidbody.AddForceAtPosition(val4 * 0.1f, buoyancyPoint.position, (ForceMode)0);
			myRigidbody.AddForce(val4 * 0.9f, (ForceMode)0);
		}
		if (OnlyOwnerAccessible() && safeAreaRadius != -1f && Vector3.Distance(((Component)this).transform.position, safeAreaOrigin) > safeAreaRadius)
		{
			ClearOwnerEntry();
		}
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)myRigidbody == (Object)null)
		{
			return Vector3.zero;
		}
		return myRigidbody.velocity;
	}

	public override Quaternion GetAngularVelocityServer()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)myRigidbody == (Object)null)
		{
			return Quaternion.identity;
		}
		return Quaternion.Euler(myRigidbody.angularVelocity * 57.29578f);
	}

	public void ClearOwnerEntry()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		creatorEntity = null;
		SetFlag(Flags.Locked, b: false);
		safeAreaRadius = -1f;
		safeAreaOrigin = Vector3.zero;
	}

	public bool IsSafe()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (OnlyOwnerAccessible())
		{
			return Vector3.Distance(safeAreaOrigin, ((Component)this).transform.position) <= safeAreaRadius;
		}
		return false;
	}

	public void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)owner != (Object)null)
		{
			creatorEntity = owner;
			base.OwnerID = owner.userID;
			bool b = true;
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(base.isServer);
			if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.safeZone)
			{
				b = false;
			}
			SetFlag(Flags.Locked, b);
			safeAreaRadius = newSafeAreaRadius;
			safeAreaOrigin = newSafeAreaOrigin;
			spawnTime = Time.realtimeSinceStartup;
		}
	}

	public bool IsDespawnEligable()
	{
		if (spawnTime != -1f)
		{
			return spawnTime + 300f < Time.realtimeSinceStartup;
		}
		return true;
	}

	public IFuelSystem GetFuelSystem()
	{
		return fuelSystem;
	}

	public int StartingFuelUnits()
	{
		return 75;
	}

	public Vector3 GetWindAtPos(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		float num = pos.y * 6f;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Sin(num * (MathF.PI / 180f)), 0f, Mathf.Cos(num * (MathF.PI / 180f)));
		return ((Vector3)(ref val)).normalized * 1f;
	}

	public bool PlayerHasEquipmentItem(BasePlayer player, int tokenItemID)
	{
		return GetEquipmentItem(player, tokenItemID) != null;
	}

	public Item GetEquipmentItem(BasePlayer player, int tokenItemID)
	{
		return player.inventory.FindItemByItemID(tokenItemID);
	}

	public override float MaxHealth()
	{
		if (base.isServer)
		{
			return base.MaxHealth();
		}
		float num = base.MaxHealth();
		float num2 = 0f;
		foreach (BaseEntity child in children)
		{
			if (child is HotAirBalloonArmor hotAirBalloonArmor)
			{
				num2 += hotAirBalloonArmor.AdditionalHealth;
			}
		}
		return num + num2;
	}

	public override List<ItemAmount> BuildCost()
	{
		List<ItemAmount> list = new List<ItemAmount>(base.BuildCost());
		foreach (BaseEntity child in children)
		{
			if (child is HotAirBalloonEquipment hotAirBalloonEquipment)
			{
				list.AddRange(hotAirBalloonEquipment.BuildCost());
			}
		}
		return list;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_ReqEquipItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		int tokenItemID = msg.read.Int32();
		Item equipmentItem = GetEquipmentItem(player, tokenItemID);
		if (equipmentItem != null)
		{
			ItemModHABEquipment component = ((Component)equipmentItem.info).GetComponent<ItemModHABEquipment>();
			if (!((Object)(object)component == (Object)null) && component.CanEquipToHAB(this))
			{
				component.ApplyToHAB(this);
				equipmentItem.UseItem();
				SendNetworkUpdateImmediate();
			}
		}
	}

	public bool IsValidHomingTarget()
	{
		if (ConVar.Server.homingMissileTargetsHab)
		{
			return flags.HasFlag(Flags.Reserved2);
		}
		return false;
	}

	public bool AdminFixUp()
	{
		if (IsDead())
		{
			return false;
		}
		GetFuelSystem()?.FillFuel();
		SetHealth(MaxHealth());
		foreach (BaseEntity child in children)
		{
			if (!(child is HotAirBalloonEquipment hotAirBalloonEquipment) || hotAirBalloonEquipment.IsDead())
			{
				continue;
			}
			foreach (BaseEntity child2 in hotAirBalloonEquipment.children)
			{
				if (child2 is Door door && !door.IsDead())
				{
					door.SetHealth(door.MaxHealth());
					door.SendNetworkUpdate();
					break;
				}
			}
			break;
		}
		SendNetworkUpdate();
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct UpgradeOption
{
	public ItemDefinition TokenItem;

	public Phrase Title;

	public Phrase Description;

	public Sprite Icon;

	public int order;
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;

public class HuntingTrophy : StorageContainer
{
	[Serializable]
	public struct TrophyRoot
	{
		public GameObjectRef SourceEntity;

		public GameObject Root;

		public uint GetSourcePrefabId()
		{
			BaseEntity entity = SourceEntity.GetEntity();
			if ((Object)(object)entity != (Object)null)
			{
				return entity.prefabID;
			}
			return 0u;
		}

		public bool Matches(HeadEntity headEnt)
		{
			BaseEntity entity = SourceEntity.GetEntity();
			bool flag = (Object)(object)entity != (Object)null && headEnt.CurrentTrophyData != null && entity.prefabID == headEnt.CurrentTrophyData.entitySource;
			if (!flag)
			{
				GameObject headSource = headEnt.GetHeadSource();
				BasePlayer basePlayer = default(BasePlayer);
				if ((Object)(object)headSource != (Object)null && headSource.TryGetComponent<BasePlayer>(ref basePlayer) && ((Component)entity).TryGetComponent<BasePlayer>(ref basePlayer))
				{
					flag = true;
				}
			}
			return flag;
		}

		public bool Matches(HeadData data)
		{
			if (data == null)
			{
				return false;
			}
			BaseEntity entity = SourceEntity.GetEntity();
			bool flag = (Object)(object)entity != (Object)null && entity.prefabID == data.entitySource;
			if (!flag)
			{
				GameObject val = null;
				val = GameManager.server.FindPrefab(data.entitySource);
				BasePlayer basePlayer = default(BasePlayer);
				if ((Object)(object)val != (Object)null && val.TryGetComponent<BasePlayer>(ref basePlayer) && ((Component)entity).TryGetComponent<BasePlayer>(ref basePlayer))
				{
					flag = true;
				}
			}
			return flag;
		}
	}

	public HeadData CurrentTrophyData;

	public PlayerModel Player;

	public GameObject MaleRope;

	public GameObject FemaleRope;

	public Renderer[] HorseRenderers;

	public Renderer[] HorseHairRenderers;

	public const uint HORSE_PREFAB_ID = 497279334u;

	public GameObject NameRoot;

	public RustText NameText;

	public TrophyRoot[] Trophies;

	public HeadData TrophyData => CurrentTrophyData;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HuntingTrophy.OnRpcMessage", 0);
		try
		{
			if (rpc == 1170506026 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerRequestClear "));
				}
				TimeWarning val2 = TimeWarning.New("ServerRequestClear", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1170506026u, "ServerRequestClear", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerRequestClear(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerRequestClear");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3878554182u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerRequestSubmit "));
				}
				TimeWarning val2 = TimeWarning.New("ServerRequestSubmit", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3878554182u, "ServerRequestSubmit", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							ServerRequestSubmit();
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerRequestSubmit");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return 0;
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if ((Object)(object)ItemModAssociatedEntity<HeadEntity>.GetAssociatedEntity(item) == (Object)null)
		{
			return false;
		}
		return base.ItemFilter(item, targetSlot);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ServerRequestSubmit()
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot == null)
		{
			return;
		}
		HeadEntity associatedEntity = ItemModAssociatedEntity<HeadEntity>.GetAssociatedEntity(slot);
		if ((Object)(object)associatedEntity != (Object)null && !CanSubmitHead(associatedEntity))
		{
			return;
		}
		if ((Object)(object)associatedEntity != (Object)null)
		{
			if (CurrentTrophyData == null)
			{
				CurrentTrophyData = Pool.Get<HeadData>();
				associatedEntity.CurrentTrophyData.CopyTo(CurrentTrophyData);
				CurrentTrophyData.count = 1u;
			}
			else
			{
				HeadData currentTrophyData = CurrentTrophyData;
				currentTrophyData.count++;
			}
		}
		for (int i = 1; i <= base.inventory.capacity; i++)
		{
			if (base.inventory.GetSlot(i) == null)
			{
				slot.MoveToContainer(base.inventory, i);
				break;
			}
		}
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ServerRequestClear(RPCMessage msg)
	{
		if (CurrentTrophyData != null)
		{
			Pool.Free<HeadData>(ref CurrentTrophyData);
			Item[] array = base.inventory.itemList.ToArray();
			foreach (Item item in array)
			{
				msg.player.GiveItem(item);
			}
			SendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (CurrentTrophyData != null)
		{
			info.msg.headData = Pool.Get<HeadData>();
			CurrentTrophyData.CopyTo(info.msg.headData);
		}
	}

	public bool CanSubmitHead(HeadEntity headEnt)
	{
		bool flag = false;
		if ((Object)(object)headEnt == (Object)null || headEnt.CurrentTrophyData == null)
		{
			return false;
		}
		bool flag2 = CurrentTrophyData != null;
		if (flag2 && headEnt.CurrentTrophyData.entitySource == CurrentTrophyData.entitySource && headEnt.CurrentTrophyData.playerId == CurrentTrophyData.playerId && headEnt.CurrentTrophyData.horseBreed == CurrentTrophyData.horseBreed)
		{
			flag = true;
		}
		if (!flag && flag2)
		{
			GameObject headSource = headEnt.GetHeadSource();
			BasePlayer basePlayer = default(BasePlayer);
			if ((Object)(object)headSource != (Object)null && headSource.TryGetComponent<BasePlayer>(ref basePlayer) && (Object)(object)GetCurrentTrophyDataSource() == (Object)(object)headSource)
			{
				flag = true;
			}
		}
		if (!flag2)
		{
			TrophyRoot[] trophies = Trophies;
			foreach (TrophyRoot trophyRoot in trophies)
			{
				if (trophyRoot.Matches(headEnt))
				{
					flag = true;
					break;
				}
			}
		}
		return flag;
		GameObject GetCurrentTrophyDataSource()
		{
			return GameManager.server.FindPrefab(CurrentTrophyData.entitySource);
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.headData != null)
		{
			if (CurrentTrophyData == null)
			{
				CurrentTrophyData = Pool.Get<HeadData>();
			}
			info.msg.headData.CopyTo(CurrentTrophyData);
		}
		else if (CurrentTrophyData != null)
		{
			Pool.Free<HeadData>(ref CurrentTrophyData);
		}
	}

	public override void ResetState()
	{
		base.ResetState();
		if (CurrentTrophyData != null)
		{
			Pool.Free<HeadData>(ref CurrentTrophyData);
		}
		TrophyRoot[] trophies = Trophies;
		for (int i = 0; i < trophies.Length; i++)
		{
			TrophyRoot trophyRoot = trophies[i];
			if ((Object)(object)trophyRoot.Root != (Object)null)
			{
				trophyRoot.Root.SetActive(false);
			}
		}
		if ((Object)(object)NameRoot != (Object)null)
		{
			NameRoot.SetActive(false);
		}
		if ((Object)(object)MaleRope != (Object)null)
		{
			MaleRope.SetActive(false);
		}
		if ((Object)(object)FemaleRope != (Object)null)
		{
			FemaleRope.SetActive(false);
		}
	}
}


using System;
using ProtoBuf;
using UnityEngine;

[Serializable]
public struct TrophyRoot
{
	public GameObjectRef SourceEntity;

	public GameObject Root;

	public uint GetSourcePrefabId()
	{
		BaseEntity entity = SourceEntity.GetEntity();
		if ((Object)(object)entity != (Object)null)
		{
			return entity.prefabID;
		}
		return 0u;
	}

	public bool Matches(HeadEntity headEnt)
	{
		BaseEntity entity = SourceEntity.GetEntity();
		bool flag = (Object)(object)entity != (Object)null && headEnt.CurrentTrophyData != null && entity.prefabID == headEnt.CurrentTrophyData.entitySource;
		if (!flag)
		{
			GameObject headSource = headEnt.GetHeadSource();
			BasePlayer basePlayer = default(BasePlayer);
			if ((Object)(object)headSource != (Object)null && headSource.TryGetComponent<BasePlayer>(ref basePlayer) && ((Component)entity).TryGetComponent<BasePlayer>(ref basePlayer))
			{
				flag = true;
			}
		}
		return flag;
	}

	public bool Matches(HeadData data)
	{
		if (data == null)
		{
			return false;
		}
		BaseEntity entity = SourceEntity.GetEntity();
		bool flag = (Object)(object)entity != (Object)null && entity.prefabID == data.entitySource;
		if (!flag)
		{
			GameObject val = null;
			val = GameManager.server.FindPrefab(data.entitySource);
			BasePlayer basePlayer = default(BasePlayer);
			if ((Object)(object)val != (Object)null && val.TryGetComponent<BasePlayer>(ref basePlayer) && ((Component)entity).TryGetComponent<BasePlayer>(ref basePlayer))
			{
				flag = true;
			}
		}
		return flag;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class ImageStorageEntity : BaseEntity
{
	private struct ImageRequest
	{
		public IImageReceiver Receiver;

		public float Time;
	}

	private List<ImageRequest> _requests;

	protected virtual FileStorage.Type StorageType => FileStorage.Type.jpg;

	protected virtual uint CrcToLoad => 0u;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ImageStorageEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 652912521 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ImageRequested "));
				}
				TimeWarning val2 = TimeWarning.New("ImageRequested", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(652912521u, "ImageRequested", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ImageRequested(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ImageRequested");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	private void ImageRequested(RPCMessage msg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)msg.player == (Object)null))
		{
			byte[] array = FileStorage.server.Get(CrcToLoad, StorageType, net.ID);
			if (array == null)
			{
				Debug.LogWarning((object)"Image entity has no image!");
				return;
			}
			SendInfo val = default(SendInfo);
			((SendInfo)(ref val))..ctor(msg.connection);
			val.method = (SendMethod)0;
			val.channel = 2;
			SendInfo sendInfo = val;
			ClientRPC(RpcTarget.SendInfo("ReceiveImage", sendInfo), (uint)array.Length, array);
		}
	}
}


private struct ImageRequest
{
	public IImageReceiver Receiver;

	public float Time;
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class IndustrialConveyor : IndustrialEntity
{
	public enum ConveyorMode
	{
		Any,
		And,
		Not
	}

	[JsonModel]
	public struct ItemFilter
	{
		[JsonIgnore]
		public ItemDefinition TargetItem;

		public ItemCategory? TargetCategory;

		public int MaxAmountInOutput;

		public int BufferAmount;

		public int MinAmountInInput;

		public bool IsBlueprint;

		public int BufferTransferRemaining;

		public string TargetItemName
		{
			get
			{
				if (!((Object)(object)TargetItem != (Object)null))
				{
					return string.Empty;
				}
				return TargetItem.shortname;
			}
			set
			{
				TargetItem = ItemManager.FindItemDefinition(value);
			}
		}

		public void CopyTo(ItemFilter target)
		{
			if ((Object)(object)TargetItem != (Object)null)
			{
				target.itemDef = TargetItem.itemid;
			}
			target.maxAmountInDestination = MaxAmountInOutput;
			if (TargetCategory.HasValue)
			{
				target.itemCategory = (int)TargetCategory.Value;
			}
			else
			{
				target.itemCategory = -1;
			}
			target.isBlueprint = (IsBlueprint ? 1 : 0);
			target.bufferAmount = BufferAmount;
			target.retainMinimum = MinAmountInInput;
			target.bufferTransferRemaining = BufferTransferRemaining;
		}

		public ItemFilter(ItemFilter from)
		{
			this = new ItemFilter
			{
				TargetItem = ItemManager.FindItemDefinition(from.itemDef),
				MaxAmountInOutput = from.maxAmountInDestination
			};
			if (from.itemCategory >= 0)
			{
				TargetCategory = (ItemCategory)from.itemCategory;
			}
			else
			{
				TargetCategory = null;
			}
			IsBlueprint = from.isBlueprint == 1;
			BufferAmount = from.bufferAmount;
			MinAmountInInput = from.retainMinimum;
			BufferTransferRemaining = from.bufferTransferRemaining;
		}
	}

	public int MaxStackSizePerMove = 128;

	public GameObjectRef FilterDialog;

	private const float ScreenUpdateRange = 30f;

	public const Flags FilterPassFlag = Flags.Reserved9;

	public const Flags FilterFailFlag = Flags.Reserved10;

	public const int MaxContainerDepth = 32;

	public SoundDefinition transferItemSoundDef;

	public SoundDefinition transferItemStartSoundDef;

	public List<ItemFilter> filterItems = new List<ItemFilter>();

	public ConveyorMode mode;

	public const int MAX_FILTER_SIZE = 30;

	public SpriteRenderer IconTransferSprite;

	private bool refreshInputOutputs;

	private IIndustrialStorage workerOutput;

	private Func<IIndustrialStorage, int, bool> filterFunc;

	private List<ContainerInputOutput> splitOutputs = new List<ContainerInputOutput>();

	private List<ContainerInputOutput> splitInputs = new List<ContainerInputOutput>();

	private bool? lastFilterState;

	private Stopwatch transferStopWatch = new Stopwatch();

	private bool multiFrameTransferInProcess;

	private int multiFrameOutputIndex;

	private int multiFrameInputIndex;

	private bool isFirstTransfer = true;

	private TimeUntil strictModeUntil;

	private bool wasOnWhenPowerLost;

	public bool strictMode { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("IndustrialConveyor.OnRpcMessage", 0);
		try
		{
			if (rpc == 617569194 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ChangeFilters "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ChangeFilters", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(617569194u, "RPC_ChangeFilters", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(617569194u, "RPC_ChangeFilters", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_ChangeFilters(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_ChangeFilters");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3731379386u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestUpToDateFilters "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestUpToDateFilters", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3731379386u, "Server_RequestUpToDateFilters", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3731379386u, "Server_RequestUpToDateFilters", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_RequestUpToDateFilters(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_RequestUpToDateFilters");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SvSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SvSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4167839872u, "SvSwitch", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4167839872u, "SvSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SvSwitch(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SvSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool flag = next.HasFlag(Flags.On);
		if (old.HasFlag(Flags.On) != flag && base.isServer)
		{
			float conveyorMoveFrequency = Server.conveyorMoveFrequency;
			if (flag && conveyorMoveFrequency > 0f)
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)ScheduleMove, conveyorMoveFrequency, conveyorMoveFrequency, conveyorMoveFrequency * 0.5f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ScheduleMove);
			}
		}
	}

	private void ScheduleMove()
	{
		((ObjectWorkQueue<IndustrialEntity>)IndustrialEntity.Queue).Add((IndustrialEntity)this);
	}

	private Item GetItemToMove(IIndustrialStorage storage, out ItemFilter associatedFilter, int slot, ItemContainer targetContainer = null)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		associatedFilter = default(ItemFilter);
		(ItemFilter, int) tuple = default((ItemFilter, int));
		if (storage == null || storage.Container == null)
		{
			return null;
		}
		if (storage.Container.IsEmpty())
		{
			return null;
		}
		Vector2i val = storage.OutputSlotRange(slot);
		for (int i = val.x; i <= val.y; i++)
		{
			Item slot2 = storage.Container.GetSlot(i);
			tuple = default((ItemFilter, int));
			if (slot2 != null && (filterItems.Count == 0 || FilterHasItem(slot2, out tuple)))
			{
				(associatedFilter, _) = tuple;
				if (targetContainer == null || !((Object)(object)associatedFilter.TargetItem != (Object)null) || associatedFilter.MaxAmountInOutput <= 0 || targetContainer.GetTotalItemAmount(slot2, val.x, val.y) < associatedFilter.MaxAmountInOutput)
				{
					return slot2;
				}
			}
		}
		return null;
	}

	private bool FilterHasItem(Item item, out (ItemFilter filter, int index) filter)
	{
		filter = default((ItemFilter, int));
		for (int i = 0; i < filterItems.Count; i++)
		{
			ItemFilter itemFilter = filterItems[i];
			if (FilterMatches(itemFilter, item))
			{
				filter = (filter: itemFilter, index: i);
				return true;
			}
		}
		return false;
	}

	private bool FilterMatches(ItemFilter filter, Item item)
	{
		if (item.IsBlueprint() && filter.IsBlueprint && (Object)(object)item.blueprintTargetDef == (Object)(object)filter.TargetItem)
		{
			return true;
		}
		if ((Object)(object)filter.TargetItem == (Object)(object)item.info && !filter.IsBlueprint)
		{
			return true;
		}
		if ((Object)(object)filter.TargetItem != (Object)null && (Object)(object)item.info.isRedirectOf == (Object)(object)filter.TargetItem)
		{
			return true;
		}
		if (filter.TargetCategory.HasValue && item.info.category == filter.TargetCategory)
		{
			return true;
		}
		return false;
	}

	private bool FilterContainerInput(IIndustrialStorage storage, int slot)
	{
		ItemFilter associatedFilter;
		return GetItemToMove(storage, out associatedFilter, slot, workerOutput?.Container) != null;
	}

	protected override void RunJob()
	{
		//IL_0a59: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a44: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a49: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aa1: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0906: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0497: Unknown result type (might be due to invalid IL or missing references)
		//IL_049e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_0447: Unknown result type (might be due to invalid IL or missing references)
		//IL_060c: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0558: Unknown result type (might be due to invalid IL or missing references)
		//IL_055f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0709: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a3: Unknown result type (might be due to invalid IL or missing references)
		base.RunJob();
		if (Server.conveyorMoveFrequency <= 0f)
		{
			return;
		}
		if (filterFunc == null)
		{
			filterFunc = FilterContainerInput;
		}
		if (refreshInputOutputs)
		{
			refreshInputOutputs = false;
			splitInputs.Clear();
			splitOutputs.Clear();
			List<IOEntity> list = Pool.Get<List<IOEntity>>();
			FindContainerSource(splitInputs, 32, input: true, list);
			list.Clear();
			FindContainerSource(splitOutputs, 32, input: false, list, -1, MaxStackSizePerMove);
			Pool.FreeUnmanaged<IOEntity>(ref list);
			multiFrameTransferInProcess = false;
			multiFrameInputIndex = 0;
			multiFrameOutputIndex = 0;
		}
		bool hasItems = CheckIfAnyInputPassesFilters(splitInputs);
		if ((!lastFilterState.HasValue || hasItems != lastFilterState) && !hasItems)
		{
			UpdateFilterPassthroughs();
		}
		if (!hasItems)
		{
			return;
		}
		transferStopWatch.Restart();
		IndustrialConveyorTransfer transfer = Pool.Get<IndustrialConveyorTransfer>();
		try
		{
			bool flag = false;
			bool flag2 = false;
			transfer.ItemTransfers = Pool.Get<List<ItemTransfer>>();
			transfer.inputEntities = Pool.Get<List<NetworkableId>>();
			transfer.outputEntities = Pool.Get<List<NetworkableId>>();
			List<int> list2 = Pool.Get<List<int>>();
			int num = 0;
			int count = splitOutputs.Count;
			bool flag3 = false;
			foreach (ContainerInputOutput splitOutput in splitOutputs)
			{
				workerOutput = splitOutput.Storage;
				if (multiFrameTransferInProcess && multiFrameOutputIndex > num)
				{
					num++;
					continue;
				}
				int num2 = 0;
				foreach (ContainerInputOutput splitInput in splitInputs)
				{
					int num3 = 0;
					num2++;
					if (multiFrameTransferInProcess && num2 < multiFrameInputIndex)
					{
						continue;
					}
					if (multiFrameTransferInProcess)
					{
						multiFrameTransferInProcess = false;
					}
					IIndustrialStorage storage = splitInput.Storage;
					if (storage == null || splitOutput.Storage == null || (Object)(object)splitInput.Storage.IndustrialEntity == (Object)(object)splitOutput.Storage.IndustrialEntity)
					{
						continue;
					}
					ItemContainer container = storage.Container;
					ItemContainer container2 = splitOutput.Storage.Container;
					if (container == null || container2 == null || storage.Container == null || storage.Container.IsEmpty())
					{
						continue;
					}
					(ItemFilter, int) filter2 = default((ItemFilter, int));
					Vector2i val = storage.OutputSlotRange(splitInput.SlotIndex);
					bool flag4 = !container2.IsFull();
					for (int i = val.x; i <= val.y; i++)
					{
						Vector2i val2 = splitOutput.Storage.InputSlotRange(splitOutput.SlotIndex);
						Item slot = storage.Container.GetSlot(i);
						if (slot == null)
						{
							continue;
						}
						bool flag5 = true;
						if (filterItems.Count > 0)
						{
							if (mode == ConveyorMode.Any || mode == ConveyorMode.And)
							{
								flag5 = FilterHasItem(slot, out filter2);
							}
							if (mode == ConveyorMode.Not)
							{
								flag5 = !FilterHasItem(slot, out filter2);
							}
						}
						if (flag5 && slot.info.stackable == 1 && !flag4)
						{
							flag5 = false;
						}
						if (flag5 && slot.info.stackable > 1 && !flag4 && !container2.HasAnyWithSpace(slot.info))
						{
							flag5 = false;
						}
						if (!flag5)
						{
							continue;
						}
						bool flag6 = mode == ConveyorMode.And || mode == ConveyorMode.Any;
						if (flag6 && (Object)(object)filter2.Item1.TargetItem != (Object)null && filter2.Item1.MaxAmountInOutput > 0 && splitOutput.Storage.Container.GetTotalItemAmount(slot, val2.x, val2.y) >= filter2.Item1.MaxAmountInOutput)
						{
							flag = true;
							continue;
						}
						int num4 = (int)((float)Mathf.Min(MaxStackSizePerMove, slot.info.stackable) / (float)count);
						if (flag6 && filter2.Item1.MinAmountInInput > 0)
						{
							if ((Object)(object)filter2.Item1.TargetItem != (Object)null && FilterMatchItem(filter2.Item1, slot))
							{
								int totalItemAmount = container.GetTotalItemAmount(slot, val.x, val.y);
								num4 = Mathf.Min(num4, totalItemAmount - filter2.Item1.MinAmountInInput);
							}
							else if (filter2.Item1.TargetCategory.HasValue)
							{
								num4 = Mathf.Min(num4, container.GetTotalCategoryAmount(filter2.Item1.TargetCategory.Value, val2.x, val2.y) - filter2.Item1.MinAmountInInput);
							}
							if (num4 == 0)
							{
								continue;
							}
						}
						if (slot.amount == 1 || (num4 <= 0 && slot.amount > 0))
						{
							num4 = 1;
						}
						if (flag6 && filter2.Item1.BufferAmount > 0)
						{
							num4 = Mathf.Min(num4, filter2.Item1.BufferTransferRemaining);
						}
						if (flag6 && filter2.Item1.MaxAmountInOutput > 0)
						{
							if ((Object)(object)filter2.Item1.TargetItem != (Object)null && FilterMatchItem(filter2.Item1, slot))
							{
								num4 = Mathf.Min(num4, filter2.Item1.MaxAmountInOutput - container2.GetTotalItemAmount(slot, val2.x, val2.y));
							}
							else if (filter2.Item1.TargetCategory.HasValue)
							{
								num4 = Mathf.Min(num4, filter2.Item1.MaxAmountInOutput - container2.GetTotalCategoryAmount(filter2.Item1.TargetCategory.Value, val2.x, val2.y));
							}
							if ((float)num4 <= 0f)
							{
								flag = true;
							}
						}
						float num5 = Mathf.Min(slot.amount, num4);
						if (num5 > 0f && num5 < 1f)
						{
							num5 = 1f;
						}
						num4 = (int)num5;
						if (num4 <= 0 || !container2.QuickIndustrialPreCheck(slot, val2, 0, out var foundSlot))
						{
							continue;
						}
						splitOutput.Storage.OnStorageItemTransferBegin();
						bool flag7 = false;
						int num6 = slot.amount;
						Item slot2 = container2.GetSlot(foundSlot);
						if (Server.industrialAllowQuickMove && foundSlot >= 0 && slot2 != null && !slot2.IsRemoved() && slot2.info.itemid == slot.info.itemid && slot2 != slot && slot.CanStack(slot2))
						{
							int num7 = Mathf.Min(num4, slot2.info.stackable - slot2.amount);
							slot2.amount += num7;
							slot.UseItem(num7);
							num6 = num7;
							slot2.MarkDirty();
							flag7 = true;
							if (slot.amount <= 0)
							{
								flag2 = true;
							}
						}
						Item item2 = null;
						if (!flag7 && slot.amount > num4)
						{
							item2 = slot.SplitItem(num4);
							num6 = item2.amount;
						}
						if (!flag7)
						{
							for (int j = val2.x; j <= val2.y; j++)
							{
								Item slot3 = container2.GetSlot(j);
								if (slot3 == null || (slot3.info.itemid == slot.info.itemid && slot3.condition == slot.condition && slot3.amount < slot3.info.stackable))
								{
									if ((item2 ?? slot).MoveToContainer(container2, j, allowStack: true, ignoreStackLimit: false, null, allowSwap: false))
									{
										flag7 = true;
										flag4 = !container2.IsFull();
										break;
									}
									flag4 = !container2.IsFull();
								}
							}
						}
						if (filter2.Item1.BufferTransferRemaining > 0)
						{
							var (value, _) = filter2;
							value.BufferTransferRemaining -= num6;
							filterItems[filter2.Item2] = value;
						}
						if (!flag7 && item2 != null)
						{
							slot.amount += item2.amount;
							slot.MarkDirty();
							item2.Remove();
							item2 = null;
						}
						if (flag7)
						{
							num3++;
							if (item2 != null)
							{
								AddTransfer(item2.info.itemid, num6, splitInput.Storage.IndustrialEntity, splitOutput.Storage.IndustrialEntity);
							}
							else
							{
								AddTransfer(slot.info.itemid, num6, splitInput.Storage.IndustrialEntity, splitOutput.Storage.IndustrialEntity);
							}
						}
						else if (!list2.Contains(num))
						{
							list2.Add(num);
						}
						splitOutput.Storage.OnStorageItemTransferEnd();
						if (strictMode && transferStopWatch.Elapsed.TotalMilliseconds >= (double)(Server.industrialFrameBudgetMs * 3f) && !isFirstTransfer)
						{
							flag3 = true;
							multiFrameTransferInProcess = true;
							multiFrameOutputIndex = num;
							multiFrameInputIndex = num2;
							break;
						}
						if (num3 >= Server.maxItemStacksMovedPerTickIndustrial)
						{
							break;
						}
					}
					if (flag3)
					{
						break;
					}
				}
				if (flag3)
				{
					break;
				}
				if (strictMode && !flag3 && transferStopWatch.Elapsed.TotalMilliseconds >= (double)(Server.industrialFrameBudgetMs * 3f) && !isFirstTransfer)
				{
					multiFrameTransferInProcess = true;
					multiFrameOutputIndex = num;
					multiFrameInputIndex = 0;
					break;
				}
				num++;
			}
			if (transfer.ItemTransfers.Count == 0 && hasItems && flag)
			{
				hasItems = false;
			}
			if (!lastFilterState.HasValue || hasItems != lastFilterState)
			{
				UpdateFilterPassthroughs();
			}
			if (Server.industrialTransferStrictTimeLimits && !strictMode)
			{
				if (transferStopWatch.Elapsed.TotalMilliseconds >= (double)(Server.industrialFrameBudgetMs * 3f))
				{
					strictMode = true;
					strictModeUntil = TimeUntil.op_Implicit(120f);
				}
			}
			else if (strictMode && TimeUntil.op_Implicit(strictModeUntil) < 0f)
			{
				strictMode = false;
			}
			Pool.FreeUnmanaged<int>(ref list2);
			if (flag2)
			{
				ItemManager.DoRemoves();
			}
			if (transfer.ItemTransfers.Count > 0)
			{
				List<Connection> list3 = Pool.Get<List<Connection>>();
				BaseNetworkable.GetCloseConnections(((Component)this).transform.position, 30f, list3);
				ClientRPC(RpcTarget.Players("ReceiveItemTransferDetails", list3), transfer);
				Pool.FreeUnmanaged<Connection>(ref list3);
			}
			isFirstTransfer = false;
		}
		finally
		{
			if (transfer != null)
			{
				((IDisposable)transfer).Dispose();
			}
		}
		if (multiFrameTransferInProcess && multiFrameOutputIndex == splitOutputs.Count)
		{
			multiFrameTransferInProcess = false;
		}
		void AddTransfer(int itemId, int amount, BaseEntity fromEntity, BaseEntity toEntity)
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			if (transfer != null && transfer.ItemTransfers != null)
			{
				if ((Object)(object)fromEntity != (Object)null && !transfer.inputEntities.Contains(fromEntity.net.ID))
				{
					transfer.inputEntities.Add(fromEntity.net.ID);
				}
				if ((Object)(object)toEntity != (Object)null && !transfer.outputEntities.Contains(toEntity.net.ID))
				{
					transfer.outputEntities.Add(toEntity.net.ID);
				}
				for (int k = 0; k < transfer.ItemTransfers.Count; k++)
				{
					ItemTransfer val3 = transfer.ItemTransfers[k];
					if (val3.itemId == itemId)
					{
						val3.amount += amount;
						transfer.ItemTransfers[k] = val3;
						return;
					}
				}
				ItemTransfer val4 = default(ItemTransfer);
				val4.itemId = itemId;
				val4.amount = amount;
				ItemTransfer item3 = val4;
				transfer.ItemTransfers.Add(item3);
			}
		}
		static bool FilterMatchItem(ItemFilter filter, Item item)
		{
			if ((Object)(object)filter.TargetItem != (Object)null && ((Object)(object)filter.TargetItem == (Object)(object)item.info || (item.IsBlueprint() == filter.IsBlueprint && (Object)(object)filter.TargetItem == (Object)(object)item.blueprintTargetDef)))
			{
				return true;
			}
			return false;
		}
		void UpdateFilterPassthroughs()
		{
			lastFilterState = hasItems;
			SetFlag(Flags.Reserved9, hasItems, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved10, !hasItems);
			ensureOutputsUpdated = true;
			MarkDirty();
		}
	}

	protected override void OnIndustrialNetworkChanged()
	{
		base.OnIndustrialNetworkChanged();
		refreshInputOutputs = true;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		refreshInputOutputs = true;
	}

	private bool CheckIfAnyInputPassesFilters(List<ContainerInputOutput> inputs)
	{
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		if (filterItems.Count == 0)
		{
			foreach (ContainerInputOutput input in inputs)
			{
				if (GetItemToMove(input.Storage, out var _, input.SlotIndex) != null)
				{
					return true;
				}
			}
		}
		else
		{
			int num = 0;
			int num2 = 0;
			if (mode == ConveyorMode.And)
			{
				foreach (ItemFilter filterItem in filterItems)
				{
					if (filterItem.BufferTransferRemaining > 0)
					{
						num2++;
					}
				}
			}
			for (int i = 0; i < filterItems.Count; i++)
			{
				ItemFilter itemFilter = filterItems[i];
				int num3 = 0;
				int num4 = 0;
				foreach (ContainerInputOutput input2 in inputs)
				{
					Vector2i val = input2.Storage.OutputSlotRange(input2.SlotIndex);
					for (int j = val.x; j <= val.y; j++)
					{
						if (input2.Storage.Container == null)
						{
							continue;
						}
						Item slot = input2.Storage.Container.GetSlot(j);
						if (slot == null)
						{
							continue;
						}
						bool flag = FilterMatches(itemFilter, slot);
						if (mode == ConveyorMode.Not)
						{
							flag = !flag;
						}
						if (!flag)
						{
							continue;
						}
						if (itemFilter.BufferAmount > 0)
						{
							num3 += slot.amount;
							if (itemFilter.BufferTransferRemaining > 0)
							{
								num++;
								break;
							}
							if (num3 >= itemFilter.BufferAmount + itemFilter.MinAmountInInput)
							{
								if (mode != ConveyorMode.And)
								{
									itemFilter.BufferTransferRemaining = itemFilter.BufferAmount;
									filterItems[i] = itemFilter;
								}
								num++;
								break;
							}
						}
						if (itemFilter.MinAmountInInput > 0)
						{
							num4 += slot.amount;
							if (num4 > itemFilter.MinAmountInInput + itemFilter.BufferAmount)
							{
								num++;
								break;
							}
						}
						if (itemFilter.BufferAmount == 0 && itemFilter.MinAmountInInput == 0)
						{
							num++;
							break;
						}
					}
					if ((mode == ConveyorMode.Any || mode == ConveyorMode.Not) && num > 0)
					{
						return true;
					}
					if (itemFilter.MinAmountInInput > 0)
					{
						num4 = 0;
					}
				}
				if (itemFilter.BufferTransferRemaining > 0 && num3 == 0)
				{
					itemFilter.BufferTransferRemaining = 0;
					filterItems[i] = itemFilter;
				}
			}
			if (mode == ConveyorMode.And && num > 0 && (num == filterItems.Count || num == num2))
			{
				if (num2 == 0)
				{
					for (int k = 0; k < filterItems.Count; k++)
					{
						ItemFilter value = filterItems[k];
						value.BufferTransferRemaining = value.BufferAmount;
						filterItems[k] = value;
					}
				}
				return true;
			}
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (filterItems.Count == 0)
		{
			return;
		}
		info.msg.industrialConveyor = Pool.Get<IndustrialConveyor>();
		info.msg.industrialConveyor.filters = Pool.Get<List<ItemFilter>>();
		info.msg.industrialConveyor.conveyorMode = (int)mode;
		foreach (ItemFilter filterItem in filterItems)
		{
			ItemFilter val = Pool.Get<ItemFilter>();
			filterItem.CopyTo(val);
			info.msg.industrialConveyor.filters.Add(val);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	private void RPC_ChangeFilters(RPCMessage msg)
	{
		if ((Object)(object)msg.player == (Object)null || !msg.player.CanBuild())
		{
			return;
		}
		mode = (ConveyorMode)msg.read.Int32();
		filterItems.Clear();
		ItemFilterList val = msg.read.Proto<ItemFilterList>((ItemFilterList)null);
		try
		{
			if (val.filters == null || Interface.CallHook("OnConveyorFiltersChange", (object)this, (object)msg.player, (object)val) != null)
			{
				return;
			}
			int num = Mathf.Min(val.filters.Count, 60);
			for (int i = 0; i < num; i++)
			{
				if (filterItems.Count >= 30)
				{
					break;
				}
				ItemFilter item = new ItemFilter(val.filters[i]);
				if ((Object)(object)item.TargetItem != (Object)null || item.TargetCategory.HasValue)
				{
					filterItems.Add(item);
				}
			}
			SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void SvSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnSwitchToggle", (object)this, (object)msg.player) == null)
		{
			SetSwitch(!IsOn());
			Interface.CallHook("OnSwitchToggled", (object)this, (object)msg.player);
		}
	}

	public virtual void SetSwitch(bool wantsOn)
	{
		if (wantsOn == IsOn())
		{
			return;
		}
		SetFlag(Flags.On, wantsOn);
		SetFlag(Flags.Busy, b: true);
		SetFlag(Flags.Reserved10, b: false);
		SetFlag(Flags.Reserved9, b: false);
		if (!wantsOn)
		{
			lastFilterState = null;
		}
		ensureOutputsUpdated = true;
		((FacepunchBehaviour)this).Invoke((Action)Unbusy, 0.5f);
		for (int i = 0; i < filterItems.Count; i++)
		{
			ItemFilter value = filterItems[i];
			if (value.BufferTransferRemaining > 0)
			{
				value.BufferTransferRemaining = 0;
				filterItems[i] = value;
			}
		}
		SendNetworkUpdateImmediate();
		MarkDirty();
	}

	public void Unbusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (inputSlot == 1)
		{
			bool flag = inputAmount >= ConsumptionAmount() && inputAmount > 0;
			if (IsPowered() && IsOn() && !flag)
			{
				wasOnWhenPowerLost = true;
			}
			SetFlag(Flags.Reserved8, flag);
			if (!flag)
			{
				SetFlag(Flags.Reserved9, b: false);
				SetFlag(Flags.Reserved10, b: false);
			}
			currentEnergy = inputAmount;
			ensureOutputsUpdated = true;
			if (inputAmount <= 0 && IsOn())
			{
				SetSwitch(wantsOn: false);
			}
			if (inputAmount > 0 && wasOnWhenPowerLost && !IsOn())
			{
				SetSwitch(wantsOn: true);
				wasOnWhenPowerLost = false;
			}
			MarkDirty();
		}
		if (inputSlot == 2 && !IsOn() && inputAmount > 0 && IsPowered())
		{
			SetSwitch(wantsOn: true);
		}
		if (inputSlot == 3 && IsOn() && inputAmount > 0)
		{
			SetSwitch(wantsOn: false);
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int result = Mathf.Min(1, GetCurrentEnergy());
		switch (outputSlot)
		{
		case 2:
			if (!HasFlag(Flags.Reserved10))
			{
				return 0;
			}
			return result;
		case 3:
			if (!HasFlag(Flags.Reserved9))
			{
				return 0;
			}
			return result;
		case 1:
			return GetCurrentEnergy();
		default:
			return 0;
		}
	}

	public override bool ShouldDrainBattery(IOEntity battery)
	{
		return IsOn();
	}

	public override bool WantsPower(int inputIndex)
	{
		return inputIndex == 1;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	private void Server_RequestUpToDateFilters(RPCMessage msg)
	{
		if (!IsOn())
		{
			return;
		}
		ItemFilterList val = Pool.Get<ItemFilterList>();
		try
		{
			val.filters = Pool.Get<List<ItemFilter>>();
			foreach (ItemFilter filterItem in filterItems)
			{
				ItemFilter val2 = Pool.Get<ItemFilter>();
				filterItem.CopyTo(val2);
				val.filters.Add(val2);
			}
			ClientRPC(RpcTarget.Player("Client_ReceiveBufferInfo", msg.player), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		filterItems.Clear();
		if (info.msg.industrialConveyor?.filters == null)
		{
			return;
		}
		mode = (ConveyorMode)info.msg.industrialConveyor.conveyorMode;
		foreach (ItemFilter filter in info.msg.industrialConveyor.filters)
		{
			ItemFilter item = new ItemFilter(filter);
			if ((Object)(object)item.TargetItem != (Object)null || item.TargetCategory.HasValue)
			{
				filterItems.Add(item);
			}
		}
	}
}


public enum ConveyorMode
{
	Any,
	And,
	Not
}


using Newtonsoft.Json;
using ProtoBuf;
using UnityEngine;

[JsonModel]
public struct ItemFilter
{
	[JsonIgnore]
	public ItemDefinition TargetItem;

	public ItemCategory? TargetCategory;

	public int MaxAmountInOutput;

	public int BufferAmount;

	public int MinAmountInInput;

	public bool IsBlueprint;

	public int BufferTransferRemaining;

	public string TargetItemName
	{
		get
		{
			if (!((Object)(object)TargetItem != (Object)null))
			{
				return string.Empty;
			}
			return TargetItem.shortname;
		}
		set
		{
			TargetItem = ItemManager.FindItemDefinition(value);
		}
	}

	public void CopyTo(ItemFilter target)
	{
		if ((Object)(object)TargetItem != (Object)null)
		{
			target.itemDef = TargetItem.itemid;
		}
		target.maxAmountInDestination = MaxAmountInOutput;
		if (TargetCategory.HasValue)
		{
			target.itemCategory = (int)TargetCategory.Value;
		}
		else
		{
			target.itemCategory = -1;
		}
		target.isBlueprint = (IsBlueprint ? 1 : 0);
		target.bufferAmount = BufferAmount;
		target.retainMinimum = MinAmountInInput;
		target.bufferTransferRemaining = BufferTransferRemaining;
	}

	public ItemFilter(ItemFilter from)
	{
		this = new ItemFilter
		{
			TargetItem = ItemManager.FindItemDefinition(from.itemDef),
			MaxAmountInOutput = from.maxAmountInDestination
		};
		if (from.itemCategory >= 0)
		{
			TargetCategory = (ItemCategory)from.itemCategory;
		}
		else
		{
			TargetCategory = null;
		}
		IsBlueprint = from.isBlueprint == 1;
		BufferAmount = from.bufferAmount;
		MinAmountInInput = from.retainMinimum;
		BufferTransferRemaining = from.bufferTransferRemaining;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class IndustrialCrafter : IndustrialEntity, IItemContainerEntity, IIdealSlotEntity, ILootableEntity, IInventoryProvider, LootPanel.IHasLootPanel, IContainerSounds, IIndustrialStorage
{
	public string LootPanelName = "generic";

	public bool NeedsBuildingPrivilegeToUse;

	public bool OnlyOneUser;

	public SoundDefinition ContainerOpenSound;

	public SoundDefinition ContainerCloseSound;

	public AnimationCurve MaterialOffsetCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public const Flags Crafting = Flags.Reserved1;

	public const Flags FullOutput = Flags.Reserved2;

	public Renderer MeshRenderer;

	public ParticleSystemContainer JobCompleteFx;

	public SoundDefinition JobCompleteSoundDef;

	public const int BlueprintSlotStart = 0;

	public const int BlueprintSlotEnd = 3;

	public ItemContainer _inventory;

	private ItemDefinition currentlyCrafting;

	private int currentlyCraftingAmount;

	private const int StorageSize = 13;

	private const int InputSlotStart = 4;

	private const int InputSlotEnd = 8;

	private const int OutputSlotStart = 9;

	private const int OutputSlotEnd = 12;

	private Phrase _lootPanelTitle = new Phrase("industrial.crafter.loot", "Industrial Crafter");

	public TimeUntilWithDuration jobFinishes { get; private set; }

	ItemContainer IItemContainerEntity.inventory => _inventory;

	Transform IItemContainerEntity.Transform => ((Component)this).transform;

	bool IItemContainerEntity.DropsLoot => true;

	float IItemContainerEntity.DestroyLootPercent => 0f;

	bool IItemContainerEntity.DropFloats { get; }

	ulong ILootableEntity.LastLootedBy { get; set; }

	BasePlayer ILootableEntity.LastLootedByPlayer { get; set; }

	ItemContainer IIndustrialStorage.Container => _inventory;

	BaseEntity IIndustrialStorage.IndustrialEntity => this;

	Phrase LootPanel.IHasLootPanel.LootPanelTitle => _lootPanelTitle;

	public SoundDefinition OpenSound => ContainerOpenSound;

	public SoundDefinition CloseSound => ContainerCloseSound;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("IndustrialCrafter.OnRpcMessage", 0);
		try
		{
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SvSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SvSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4167839872u, "SvSwitch", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4167839872u, "SvSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SvSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SvSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool flag = next.HasFlag(Flags.On);
		if (old.HasFlag(Flags.On) != flag && base.isServer)
		{
			float industrialCrafterFrequency = Server.industrialCrafterFrequency;
			if (flag && industrialCrafterFrequency > 0f)
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)CheckCraft, industrialCrafterFrequency, industrialCrafterFrequency, industrialCrafterFrequency * 0.5f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)CheckCraft);
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		DropItems(info?.Initiator);
	}

	public void DropItems(BaseEntity initiator = null)
	{
		StorageContainer.DropItems(this, initiator);
	}

	public bool ShouldDropItemsIndividually()
	{
		return false;
	}

	public void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (_inventory != null)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract())
			{
				PlayerOpenLoot(player);
			}
		}
	}

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", (object)player, (object)this) != null)
		{
			return false;
		}
		if (NeedsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if (OnlyOneUser && IsOpen())
		{
			player.ChatMessage("Already in use");
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(_inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), LootPanelName);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		CreateInventory(giveUID: true);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Pool.Free<ItemContainer>(ref _inventory);
	}

	public void CreateInventory(bool giveUID)
	{
		Debug.Assert(_inventory == null, "Double init of inventory!");
		_inventory = Pool.Get<ItemContainer>();
		_inventory.entityOwner = this;
		_inventory.canAcceptItem = CanAcceptItem;
		_inventory.ServerInitialize(null, 13);
		if (giveUID)
		{
			_inventory.GiveUID();
		}
	}

	private bool CanAcceptItem(Item item, int index)
	{
		if (index >= 0 && index <= 3 && !item.IsBlueprint())
		{
			return false;
		}
		return true;
	}

	private void CheckCraft()
	{
		((ObjectWorkQueue<IndustrialEntity>)IndustrialEntity.Queue).Add((IndustrialEntity)this);
	}

	private Item GetTargetBlueprint(int index)
	{
		if (_inventory == null)
		{
			return null;
		}
		if (index < 0 || index > 3)
		{
			return null;
		}
		Item slot = _inventory.GetSlot(index);
		if (slot == null || !slot.IsBlueprint())
		{
			return null;
		}
		return slot;
	}

	protected override void RunJob()
	{
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		base.RunJob();
		if (Server.industrialCrafterFrequency <= 0f || HasFlag(Flags.Reserved1) || (Object)(object)currentlyCrafting != (Object)null)
		{
			return;
		}
		for (int i = 0; i <= 3; i++)
		{
			Item targetBlueprint = GetTargetBlueprint(i);
			if (targetBlueprint == null || (Object)(object)GetWorkbench() == (Object)null || GetWorkbench().Workbenchlevel < targetBlueprint.blueprintTargetDef.Blueprint.GetWorkbenchLevel())
			{
				continue;
			}
			ItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;
			if (Interface.CallHook("OnItemCraft", (object)this, (object)blueprint) != null)
			{
				break;
			}
			bool flag = true;
			foreach (ItemAmount ingredient in blueprint.GetIngredients())
			{
				if ((float)GetInputAmount(ingredient.itemDef) < ingredient.amount)
				{
					flag = false;
					break;
				}
			}
			if (!flag)
			{
				continue;
			}
			flag = false;
			for (int j = 9; j <= 12; j++)
			{
				Item slot = _inventory.GetSlot(j);
				if (slot == null || ((Object)(object)slot.info == (Object)(object)targetBlueprint.blueprintTargetDef && slot.amount + blueprint.amountToCreate <= slot.MaxStackable()))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				SetFlag(Flags.Reserved2, b: true);
				continue;
			}
			SetFlag(Flags.Reserved2, b: false);
			foreach (ItemAmount ingredient2 in blueprint.GetIngredients())
			{
				ConsumeInputIngredient(ingredient2);
			}
			currentlyCrafting = targetBlueprint.blueprintTargetDef;
			currentlyCraftingAmount = blueprint.amountToCreate;
			float craftTime = blueprint.GetCraftTime();
			((FacepunchBehaviour)this).Invoke((Action)CompleteCraft, craftTime);
			jobFinishes = TimeUntilWithDuration.op_Implicit(craftTime);
			SetFlag(Flags.Reserved1, b: true);
			ClientRPC(RpcTarget.NetworkGroup("ClientUpdateCraftTimeRemaining"), TimeUntilWithDuration.op_Implicit(jobFinishes), jobFinishes.Duration);
			break;
		}
	}

	private void CompleteCraft()
	{
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		for (int i = 9; i <= 12; i++)
		{
			Item slot = _inventory.GetSlot(i);
			if (slot == null)
			{
				Item item = ItemManager.Create(currentlyCrafting, currentlyCraftingAmount, 0uL);
				item.SetItemOwnership(ItemOwnership.username, ItemOwnershipPhrases.IndustrialCrafter);
				item.position = i;
				_inventory.Insert(item);
				flag = true;
				break;
			}
			if ((Object)(object)slot.info == (Object)(object)currentlyCrafting && slot.amount + currentlyCraftingAmount <= slot.MaxStackable())
			{
				slot.amount += currentlyCraftingAmount;
				slot.MarkDirty();
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			Item item2 = ItemManager.Create(currentlyCrafting, currentlyCraftingAmount, 0uL);
			item2.SetItemOwnership(ItemOwnership.username, ItemOwnershipPhrases.IndustrialCrafter);
			item2.Drop(((Component)this).transform.position + ((Component)this).transform.forward * 0.5f, Vector3.zero);
		}
		currentlyCrafting = null;
		currentlyCraftingAmount = 0;
		SetFlag(Flags.Reserved1, b: false);
	}

	private int GetInputAmount(ItemDefinition def)
	{
		if ((Object)(object)def == (Object)null)
		{
			return 0;
		}
		int num = 0;
		for (int i = 4; i <= 8; i++)
		{
			Item slot = _inventory.GetSlot(i);
			if (slot != null && (Object)(object)def == (Object)(object)slot.info)
			{
				num += slot.amount;
			}
		}
		return num;
	}

	private bool ConsumeInputIngredient(ItemAmount am)
	{
		if ((Object)(object)am.itemDef == (Object)null)
		{
			return false;
		}
		float num = am.amount;
		for (int i = 4; i <= 8; i++)
		{
			Item slot = _inventory.GetSlot(i);
			if (slot != null && (Object)(object)am.itemDef == (Object)(object)slot.info)
			{
				float num2 = Mathf.Min(num, (float)slot.amount);
				slot.UseItem((int)num2);
				num -= num2;
				if (num2 <= 0f)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if ((Object)(object)currentlyCrafting != (Object)null)
			{
				info.msg.industrialCrafter = Pool.Get<IndustrialCrafter>();
				info.msg.industrialCrafter.currentlyCrafting = currentlyCrafting.itemid;
				info.msg.industrialCrafter.currentlyCraftingAmount = currentlyCraftingAmount;
			}
			if (_inventory != null)
			{
				info.msg.storageBox = Pool.Get<StorageBox>();
				info.msg.storageBox.contents = _inventory.Save();
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.storageBox != null && _inventory != null)
		{
			_inventory.Load(info.msg.storageBox.contents);
			_inventory.capacity = 13;
		}
		if (base.isServer && info.fromDisk && info.msg.industrialCrafter != null)
		{
			currentlyCrafting = ItemManager.FindItemDefinition(info.msg.industrialCrafter.currentlyCrafting);
			currentlyCraftingAmount = info.msg.industrialCrafter.currentlyCraftingAmount;
			CompleteCraft();
		}
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (slotIndex == 3)
		{
			return new Vector2i(0, 3);
		}
		return new Vector2i(4, 8);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (slotIndex == 1)
		{
			return new Vector2i(0, 3);
		}
		return new Vector2i(9, 12);
	}

	public void OnStorageItemTransferBegin()
	{
	}

	public void OnStorageItemTransferEnd()
	{
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (inputSlot == 1)
		{
			SetFlag(Flags.Reserved8, inputAmount >= ConsumptionAmount() && inputAmount > 0);
			currentEnergy = inputAmount;
			ensureOutputsUpdated = true;
			MarkDirty();
		}
		if (inputSlot == 1 && inputAmount <= 0 && IsOn())
		{
			SetSwitch(wantsOn: false);
		}
		if (inputSlot == 2)
		{
			if (IsOn() && inputAmount == 0)
			{
				SetSwitch(wantsOn: false);
			}
			else if (!IsOn() && inputAmount > 0 && HasFlag(Flags.Reserved8))
			{
				SetSwitch(wantsOn: true);
			}
		}
		if (inputSlot == 4 && inputAmount > 0 && HasFlag(Flags.Reserved8))
		{
			SetSwitch(wantsOn: true);
		}
		if (inputSlot == 5 && inputAmount > 0 && HasFlag(Flags.Reserved8))
		{
			SetSwitch(wantsOn: false);
		}
	}

	public override bool ShouldDrainBattery(IOEntity battery)
	{
		return IsOn();
	}

	public override bool WantsPassthroughPower()
	{
		return false;
	}

	public override bool WantsPower(int inputIndex)
	{
		return inputIndex == 1;
	}

	public virtual void SetSwitch(bool wantsOn)
	{
		if (wantsOn != IsOn())
		{
			SetFlag(Flags.On, wantsOn, recursive: false, networkupdate: false);
			SetFlag(Flags.Busy, b: true, recursive: false, networkupdate: false);
			if (!wantsOn)
			{
				SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
			}
			((FacepunchBehaviour)this).Invoke((Action)Unbusy, 0.5f);
			SendNetworkUpdateImmediate();
			MarkDirty();
		}
	}

	public void Unbusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(2uL)]
	private void SvSwitch(RPCMessage msg)
	{
		SetSwitch(!IsOn());
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (_inventory != null && _inventory.IsEmpty())
		{
			return base.CanPickup(player);
		}
		return false;
	}

	public void GetAllInventories(List<ItemContainer> list)
	{
		list.Add(_inventory);
	}

	public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return -1;
	}

	public ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return default(ItemContainerId);
	}

	public Workbench GetWorkbench()
	{
		return GetParentEntity() as Workbench;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class InstantCameraTool : HeldEntity
{
	public ItemDefinition photoItem;

	public GameObjectRef screenshotEffect;

	public SoundDefinition startPhotoSoundDef;

	public SoundDefinition finishPhotoSoundDef;

	[Range(640f, 1920f)]
	public int resolutionX = 640;

	[Range(480f, 1080f)]
	public int resolutionY = 480;

	[Range(10f, 100f)]
	public int quality = 75;

	[Range(0f, 5f)]
	public float cooldownSeconds = 3f;

	[Header("Flash")]
	public GameObjectRef flashEffect;

	public InstantCameraFlashController localFlash;

	public float flashDuration = 0.2f;

	public TimeSince _sinceLastPhoto;

	private bool hasSentAchievement;

	public const string PhotographPlayerAchievement = "SUMMER_PAPARAZZI";

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("InstantCameraTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 3122234259u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - TakePhoto "));
				}
				TimeWarning val2 = TimeWarning.New("TakePhoto", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3122234259u, "TakePhoto", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3122234259u, "TakePhoto", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							TakePhoto(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in TakePhoto");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(3uL)]
	private void TakePhoto(RPCMessage msg)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		Item item = GetItem();
		if ((Object)(object)player == (Object)null || item == null || item.condition <= 0f)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))
		{
			return;
		}
		Item item2 = ItemManager.Create(photoItem, 1, 0uL);
		if (item2 == null)
		{
			Debug.LogError((object)"Failed to create photo item");
			return;
		}
		item2.SetItemOwnership(msg.player, ItemOwnershipPhrases.Photographed);
		if (!((NetworkableId)(ref item2.instanceData.subEntity)).IsValid)
		{
			item2.Remove();
			Debug.LogError((object)"Photo has no sub-entity");
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);
		if ((Object)(object)baseNetworkable == (Object)null)
		{
			item2.Remove();
			Debug.LogError((object)"Sub-entity was not found");
		}
		else if (!(baseNetworkable is PhotoEntity photoEntity))
		{
			item2.Remove();
			Debug.LogError((object)"Sub-entity is not a photo");
		}
		else
		{
			if (Interface.CallHook("OnPhotoCapture", (object)photoEntity, (object)item, (object)player, (object)array) != null)
			{
				return;
			}
			photoEntity.SetImageData(player.userID, array);
			if (!player.inventory.GiveItem(item2))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			EffectNetwork.Send(new Effect(screenshotEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.forward, msg.connection));
			if (HasFlag(Flags.Reserved5))
			{
				EffectNetwork.Send(new Effect(flashEffect.resourcePath, ((Component)localFlash).transform.position, ((Component)localFlash).transform.forward, msg.connection));
			}
			if (!hasSentAchievement && !string.IsNullOrEmpty("SUMMER_PAPARAZZI"))
			{
				Vector3 position = GetOwnerPlayer().eyes.position;
				Vector3 val = GetOwnerPlayer().eyes.HeadForward();
				List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
				Vis.Entities(position + val * 5f, 5f, list, 131072, (QueryTriggerInteraction)2);
				foreach (BasePlayer item3 in list)
				{
					if (item3.isServer && (Object)(object)item3 != (Object)(object)GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))
					{
						hasSentAchievement = true;
						GetOwnerPlayer().GiveAchievement("SUMMER_PAPARAZZI");
						break;
					}
				}
				Pool.FreeUnmanaged<BasePlayer>(ref list);
			}
			item.LoseCondition(1f);
			Interface.CallHook("OnPhotoCaptured", (object)photoEntity, (object)item, (object)player, (object)array);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		hasSentAchievement = false;
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class InstrumentTool : HeldEntity
{
	public InstrumentKeyController KeyController;

	public SoundDefinition DeploySound;

	public Vector2 PitchClamp = new Vector2(-90f, 90f);

	public bool UseAnimationSlotEvents;

	public Transform MuzzleT;

	public bool UsableByAutoTurrets;

	private NoteBindingCollection.NoteData lastPlayedTurretData;

	public override Transform MuzzleTransform => MuzzleT;

	public override bool IsUsableByTurret => UsableByAutoTurrets;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("InstrumentTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 1625188589 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_PlayNote "));
				}
				TimeWarning val2 = TimeWarning.New("Server_PlayNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_PlayNote(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_PlayNote");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 705843933 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_StopNote "));
				}
				TimeWarning val2 = TimeWarning.New("Server_StopNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						Server_StopNote(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in Server_StopNote");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	private void Server_PlayNote(RPCMessage msg)
	{
		int arg = msg.read.Int32();
		int arg2 = msg.read.Int32();
		int arg3 = msg.read.Int32();
		float num = msg.read.Float();
		if (!FloatEx.IsNaNOrInfinity(num))
		{
			KeyController.ProcessServerPlayedNote(GetOwnerPlayer());
			ClientRPC(RpcTarget.NetworkGroup("Client_PlayNote"), arg, arg2, arg3, num);
		}
	}

	[RPC_Server]
	private void Server_StopNote(RPCMessage msg)
	{
		int arg = msg.read.Int32();
		int arg2 = msg.read.Int32();
		int arg3 = msg.read.Int32();
		ClientRPC(RpcTarget.NetworkGroup("Client_StopNote"), arg, arg2, arg3);
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		base.ServerUse(damageModifier, speedModifier, originOverride, useBulletThickness);
		if (!((FacepunchBehaviour)this).IsInvoking((Action)StopAfterTime))
		{
			lastPlayedTurretData = KeyController.Bindings.BaseBindings[Random.Range(0, KeyController.Bindings.BaseBindings.Length)];
			ClientRPC(RpcTarget.NetworkGroup("Client_PlayNote"), (int)lastPlayedTurretData.Note, (int)lastPlayedTurretData.Type, lastPlayedTurretData.NoteOctave, 1f);
			((FacepunchBehaviour)this).Invoke((Action)StopAfterTime, 0.2f);
		}
	}

	private void StopAfterTime()
	{
		ClientRPC(RpcTarget.NetworkGroup("Client_StopNote"), (int)lastPlayedTurretData.Note, (int)lastPlayedTurretData.Type, lastPlayedTurretData.NoteOctave);
	}

	public override bool IsInstrument()
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class IOEntity : DecayEntity
{
	public enum IOType
	{
		Electric,
		Fluidic,
		Kinetic,
		Generic,
		Industrial
	}

	public enum QueueType
	{
		ElectricLowPriority,
		ElectricHighPriority,
		Fluidic,
		Kinetic,
		Generic,
		Industrial
	}

	[Serializable]
	public class IORef
	{
		public EntityRef entityRef;

		public IOEntity ioEnt;

		public void Init()
		{
			if ((Object)(object)ioEnt != (Object)null && !entityRef.IsValid(serverside: true))
			{
				entityRef.Set(ioEnt);
			}
			if (entityRef.IsValid(serverside: true))
			{
				ioEnt = ((Component)entityRef.Get(serverside: true)).GetComponent<IOEntity>();
			}
		}

		public void InitClient()
		{
			if (entityRef.IsValid(serverside: false) && (Object)(object)ioEnt == (Object)null)
			{
				ioEnt = ((Component)entityRef.Get(serverside: false)).GetComponent<IOEntity>();
			}
		}

		public IOEntity Get(bool isServer = true)
		{
			if ((Object)(object)ioEnt == (Object)null && entityRef.IsValid(isServer))
			{
				ioEnt = entityRef.Get(isServer) as IOEntity;
			}
			return ioEnt;
		}

		public void Clear()
		{
			IOEntity iOEntity = ioEnt;
			ioEnt = null;
			entityRef.Set(null);
			Interface.CallHook("OnIORefCleared", (object)this, (object)iOEntity);
		}

		public void Set(IOEntity newIOEnt)
		{
			entityRef.Set(newIOEnt);
		}
	}

	[Serializable]
	public class IOSlot
	{
		public string niceName;

		public IOType type;

		public IORef connectedTo;

		public int connectedToSlot;

		public IOHandlePriority importance;

		public float ArrowOffset;

		public Vector3[] linePoints;

		public LineAnchor[] lineAnchors;

		public float[] slackLevels;

		public Vector3 worldSpaceLineEndRotation;

		[HideInInspector]
		public Vector3 originPosition;

		[HideInInspector]
		public Vector3 originRotation;

		public ClientIOLine line;

		public Vector3 handlePosition;

		public Vector3 handleDirection;

		public bool rootConnectionsOnly;

		public bool mainPowerSlot;

		public WireTool.WireColour wireColour;

		public float lineThickness;

		public void Clear()
		{
			if (connectedTo == null)
			{
				connectedTo = new IORef();
			}
			else
			{
				connectedTo.Clear();
			}
			connectedToSlot = 0;
			linePoints = null;
			lineAnchors = null;
		}

		public void Preserve(ref SprayCan.IOPreserveInfo target)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			target.connectedTo = connectedTo.Get();
			target.connectedToSlot = connectedToSlot;
			target.linePoints = linePoints;
			target.slackLevels = slackLevels;
			target.lineAnchors = lineAnchors;
			target.worldSpaceLineEndRotation = worldSpaceLineEndRotation;
			target.originPosition = originPosition;
			target.originRotation = originRotation;
			target.wireColour = wireColour;
		}

		public void Restore(SprayCan.IOPreserveInfo from)
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			connectedTo.Set(from.connectedTo);
			connectedToSlot = from.connectedToSlot;
			linePoints = from.linePoints;
			slackLevels = from.slackLevels;
			lineAnchors = from.lineAnchors;
			worldSpaceLineEndRotation = from.worldSpaceLineEndRotation;
			originPosition = from.originPosition;
			originRotation = from.originRotation;
			wireColour = from.wireColour;
		}

		public bool IsConnected()
		{
			return (Object)(object)connectedTo.Get() != (Object)null;
		}
	}

	private struct FrameTiming
	{
		public string PrefabName;

		public double Time;
	}

	public struct LineAnchor
	{
		public EntityRef<Door> entityRef;

		public string boneName;

		public int index;

		public Vector3 position;

		public LineAnchor(WireLineAnchorInfo info)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			entityRef = new EntityRef<Door>(info.parentID);
			boneName = info.boneName;
			index = (int)info.index;
			position = info.position;
		}

		public WireLineAnchorInfo ToInfo()
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Expected O, but got Unknown
			return new WireLineAnchorInfo
			{
				parentID = entityRef.Get(serverside: true).net.ID,
				boneName = boneName,
				index = index,
				position = position
			};
		}
	}

	public struct ContainerInputOutput
	{
		public IIndustrialStorage Storage;

		public int SlotIndex;

		public int MaxStackSize;

		public int ParentStorage;

		public int IndustrialSiblingCount;
	}

	[Header("IOEntity")]
	public Transform debugOrigin;

	public ItemDefinition sourceItem;

	[NonSerialized]
	public int lastResetIndex;

	[ServerVar]
	[Help("How many milliseconds to budget for processing high priority electric io entities per server frame (monuments)")]
	public static float frameBudgetElectricHighPriorityMs = 1f;

	[ServerVar]
	[Help("How many milliseconds to budget for processing low priority io entities per server frame (player placed)")]
	public static float frameBudgetElectricLowPriorityMs = 0.5f;

	[ServerVar]
	[Help("How many milliseconds to budget for processing fluid io entities per server frame")]
	public static float frameBudgetFluidMs = 0.25f;

	[ServerVar]
	[Help("How many milliseconds to budget for processing kinetic io entities per server frame (monuments)")]
	public static float frameBudgetKineticMs = 1f;

	[ServerVar]
	[Help("How many milliseconds to budget for processing generic io entities per server frame (unused for now)")]
	public static float frameBudgetGenericMs = 1f;

	[Help("How many milliseconds to budget for processing industrial entities per server frame")]
	[ServerVar]
	public static float frameBudgetIndustrialMs = 0.25f;

	[ServerVar]
	public static float responsetime = 0.1f;

	[ServerVar]
	public static int backtracking = 8;

	[ServerVar(Help = "Print out what is taking so long in the IO frame budget")]
	public static bool debugBudget = false;

	[ServerVar(Help = "Ignore frames with a lower ms than this while debugBudget is active")]
	public static float debugBudgetThreshold = 2f;

	private static bool _infinitePower = false;

	public const Flags Flag_ShortCircuit = Flags.Reserved7;

	public const Flags Flag_HasPower = Flags.Reserved8;

	public IOSlot[] inputs;

	public IOSlot[] outputs;

	public IOType ioType;

	public static Dictionary<QueueType, Queue<IOEntity>> _processQueues = new Dictionary<QueueType, Queue<IOEntity>>
	{
		{
			QueueType.ElectricHighPriority,
			new Queue<IOEntity>()
		},
		{
			QueueType.ElectricLowPriority,
			new Queue<IOEntity>()
		},
		{
			QueueType.Fluidic,
			new Queue<IOEntity>()
		},
		{
			QueueType.Kinetic,
			new Queue<IOEntity>()
		},
		{
			QueueType.Generic,
			new Queue<IOEntity>()
		},
		{
			QueueType.Industrial,
			new Queue<IOEntity>()
		}
	};

	public static Dictionary<QueueType, string> _processQueueProfilerString = new Dictionary<QueueType, string>
	{
		{
			QueueType.ElectricHighPriority,
			"HighPriorityElectric"
		},
		{
			QueueType.ElectricLowPriority,
			"LowPriorityElectric"
		},
		{
			QueueType.Fluidic,
			"Fluid"
		},
		{
			QueueType.Kinetic,
			"Kinetic"
		},
		{
			QueueType.Generic,
			"Generic"
		},
		{
			QueueType.Industrial,
			"Industrial"
		}
	};

	private static List<FrameTiming> timings = new List<FrameTiming>();

	public int cachedOutputsUsed;

	public int lastPassthroughEnergy;

	public int lastEnergy;

	public int currentEnergy;

	private int changedCount;

	private float lastChangeTime;

	public float lastUpdateTime;

	public int lastUpdateBlockedFrame;

	public bool ensureOutputsUpdated;

	public const int MaxContainerSourceCount = 32;

	private List<Collider> spawnedColliders = new List<Collider>();

	public virtual bool IsGravitySource => false;

	[ReplicatedVar(Help = "All player placed electrical entities will receive full power without needing to be plugged into anything")]
	public static bool infiniteIoPower
	{
		get
		{
			return _infinitePower;
		}
		set
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if (_infinitePower == value)
			{
				return;
			}
			_infinitePower = value;
			Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					if (!(enumerator.Current is IOEntity iOEntity) || (iOEntity.GetQueueType() != 0 && iOEntity.GetQueueType() != QueueType.Industrial))
					{
						continue;
					}
					if (infiniteIoPower)
					{
						iOEntity.ApplyInfinitePower();
						continue;
					}
					iOEntity.MarkDirtyForceUpdateOutputs();
					bool flag = false;
					IOSlot[] array = iOEntity.inputs;
					for (int i = 0; i < array.Length; i++)
					{
						if ((Object)(object)array[i].connectedTo.Get() != (Object)null)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						for (int j = 0; j < iOEntity.inputs.Length; j++)
						{
							iOEntity.UpdateFromInput(0, j);
						}
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
	}

	protected virtual bool PreventDuplicatesInQueue => false;

	private bool HasBlockedUpdatedOutputsThisFrame => Time.frameCount == lastUpdateBlockedFrame;

	public virtual bool BlockFluidDraining => false;

	protected virtual float LiquidPassthroughGravityThreshold => 1f;

	protected virtual bool DisregardGravityRestrictionsOnLiquid => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("IOEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 4161541566u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestData "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4161541566u, "Server_RequestData", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4161541566u, "Server_RequestData", this, player, 6f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_RequestData(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_RequestData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		if (base.isServer)
		{
			lastResetIndex = 0;
			cachedOutputsUsed = 0;
			lastPassthroughEnergy = 0;
			lastEnergy = 0;
			currentEnergy = 0;
			lastUpdateTime = 0f;
			ensureOutputsUpdated = false;
		}
		ClearIndustrialPreventBuilding();
	}

	public Phrase GetDisplayName()
	{
		if (!((Object)(object)sourceItem != (Object)null))
		{
			return Phrase.op_Implicit(base.ShortPrefabName);
		}
		return sourceItem.displayName;
	}

	public virtual bool IsRootEntity()
	{
		return false;
	}

	public IOEntity FindGravitySource(ref Vector3 worldHandlePosition, int depth, bool ignoreSelf)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		if (depth <= 0)
		{
			return null;
		}
		if (!ignoreSelf && IsGravitySource)
		{
			worldHandlePosition = ((Component)this).transform.TransformPoint(outputs[0].handlePosition);
			return this;
		}
		IOSlot[] array = inputs;
		for (int i = 0; i < array.Length; i++)
		{
			IOEntity iOEntity = array[i].connectedTo.Get(base.isServer);
			if ((Object)(object)iOEntity != (Object)null)
			{
				if (iOEntity.IsGravitySource)
				{
					worldHandlePosition = ((Component)iOEntity).transform.TransformPoint(iOEntity.outputs[0].handlePosition);
					return iOEntity;
				}
				iOEntity = iOEntity.FindGravitySource(ref worldHandlePosition, depth - 1, ignoreSelf: false);
				if ((Object)(object)iOEntity != (Object)null)
				{
					worldHandlePosition = ((Component)iOEntity).transform.TransformPoint(iOEntity.outputs[0].handlePosition);
					return iOEntity;
				}
			}
		}
		return null;
	}

	public virtual void SetFuelType(ItemDefinition def, IOEntity source)
	{
	}

	public virtual bool WantsPower(int inputIndex)
	{
		return true;
	}

	public virtual bool AllowWireConnections()
	{
		if ((Object)(object)((Component)this).GetComponentInParent<BaseVehicle>() != (Object)null)
		{
			return false;
		}
		return true;
	}

	public virtual bool WantsPassthroughPower()
	{
		return true;
	}

	public virtual int ConsumptionAmount()
	{
		return 1;
	}

	public virtual bool ShouldDrainBattery(IOEntity battery)
	{
		return ioType == battery.ioType;
	}

	public virtual bool ShouldBlockCircuit(IOEntity battery)
	{
		return false;
	}

	public virtual int MaximalPowerOutput()
	{
		return 0;
	}

	public virtual bool AllowDrainFrom(int outputSlot)
	{
		return true;
	}

	public QueueType GetQueueType()
	{
		switch (ioType)
		{
		case IOType.Electric:
			if ((Object)(object)sourceItem == (Object)null)
			{
				return QueueType.ElectricHighPriority;
			}
			return QueueType.ElectricLowPriority;
		case IOType.Fluidic:
			return QueueType.Fluidic;
		case IOType.Kinetic:
			return QueueType.Kinetic;
		case IOType.Generic:
			return QueueType.Generic;
		case IOType.Industrial:
			return QueueType.Industrial;
		default:
			return QueueType.ElectricLowPriority;
		}
	}

	public static float GetFrameBudgetForQueue(QueueType type)
	{
		return type switch
		{
			QueueType.ElectricLowPriority => frameBudgetElectricLowPriorityMs, 
			QueueType.ElectricHighPriority => frameBudgetElectricHighPriorityMs, 
			QueueType.Fluidic => frameBudgetFluidMs, 
			QueueType.Kinetic => frameBudgetKineticMs, 
			QueueType.Generic => frameBudgetGenericMs, 
			QueueType.Industrial => frameBudgetIndustrialMs, 
			_ => frameBudgetElectricLowPriorityMs, 
		};
	}

	public virtual bool IsPowered()
	{
		return HasFlag(Flags.Reserved8);
	}

	public bool IsConnectedToAnySlot(IOEntity entity, int slot, int depth, bool defaultReturn = false)
	{
		if (depth > 0 && slot < inputs.Length)
		{
			IOEntity iOEntity = inputs[slot].connectedTo.Get();
			if ((Object)(object)iOEntity != (Object)null)
			{
				if ((Object)(object)iOEntity == (Object)(object)entity)
				{
					return true;
				}
				if (ConsiderConnectedTo(entity))
				{
					return true;
				}
				if (iOEntity.IsConnectedTo(entity, depth - 1, defaultReturn))
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool IsConnectedTo(IOEntity entity, int slot, int depth, bool defaultReturn = false)
	{
		if (depth > 0 && slot < inputs.Length)
		{
			IOSlot iOSlot = inputs[slot];
			if (iOSlot.mainPowerSlot)
			{
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null)
				{
					if ((Object)(object)iOEntity == (Object)(object)entity)
					{
						return true;
					}
					if (ConsiderConnectedTo(entity))
					{
						return true;
					}
					if (iOEntity.IsConnectedTo(entity, depth - 1, defaultReturn))
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	public bool IsConnectedTo(IOEntity entity, int depth, bool defaultReturn = false)
	{
		if (depth > 0)
		{
			for (int i = 0; i < inputs.Length; i++)
			{
				IOSlot iOSlot = inputs[i];
				if (!iOSlot.mainPowerSlot)
				{
					continue;
				}
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null)
				{
					if ((Object)(object)iOEntity == (Object)(object)entity)
					{
						return true;
					}
					if (ConsiderConnectedTo(entity))
					{
						return true;
					}
					if (iOEntity.IsConnectedTo(entity, depth - 1, defaultReturn))
					{
						return true;
					}
				}
			}
			return false;
		}
		return defaultReturn;
	}

	protected virtual bool ConsiderConnectedTo(IOEntity entity)
	{
		return false;
	}

	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(6f)]
	private void Server_RequestData(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int slot = msg.read.Int32();
		bool input = msg.read.Int32() == 1;
		SendAdditionalData(player, slot, input);
	}

	public virtual void SendAdditionalData(BasePlayer player, int slot, bool input)
	{
		int passthroughAmountForAnySlot = GetPassthroughAmountForAnySlot(slot, input);
		ClientRPC(RpcTarget.Player("Client_ReceiveAdditionalData", player), currentEnergy, passthroughAmountForAnySlot, 0f, 0f);
	}

	protected int GetPassthroughAmountForAnySlot(int slot, bool isInputSlot)
	{
		int result = 0;
		if (isInputSlot)
		{
			if (slot >= 0 && slot < inputs.Length)
			{
				IOSlot iOSlot = inputs[slot];
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null && iOSlot.connectedToSlot >= 0 && iOSlot.connectedToSlot < iOEntity.outputs.Length)
				{
					result = iOEntity.GetPassthroughAmount(inputs[slot].connectedToSlot);
				}
			}
		}
		else if (slot >= 0 && slot < outputs.Length)
		{
			result = GetPassthroughAmount(slot);
		}
		return result;
	}

	public static void ProcessQueue()
	{
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Expected O, but got Unknown
		if (debugBudget)
		{
			timings.Clear();
		}
		double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
		foreach (KeyValuePair<QueueType, Queue<IOEntity>> processQueue in _processQueues)
		{
			double num = Time.realtimeSinceStartup;
			double num2 = GetFrameBudgetForQueue(processQueue.Key) / 1000f;
			while (processQueue.Value.Count > 0 && Time.realtimeSinceStartupAsDouble < num + num2 && !processQueue.Value.Peek().HasBlockedUpdatedOutputsThisFrame)
			{
				double realtimeSinceStartupAsDouble2 = Time.realtimeSinceStartupAsDouble;
				IOEntity iOEntity = processQueue.Value.Dequeue();
				if (iOEntity.IsValid())
				{
					iOEntity.UpdateOutputs();
				}
				if (debugBudget)
				{
					timings.Add(new FrameTiming
					{
						PrefabName = iOEntity.ShortPrefabName,
						Time = (Time.realtimeSinceStartupAsDouble - realtimeSinceStartupAsDouble2) * 1000.0
					});
				}
			}
		}
		if (debugBudget)
		{
			double num3 = Time.realtimeSinceStartupAsDouble - realtimeSinceStartupAsDouble;
			double num4 = (double)debugBudgetThreshold / 1000.0;
			if (num3 > num4)
			{
				TextTable val = new TextTable();
				val.AddColumns(new string[2] { "Prefab Name", "Time (in ms)" });
				foreach (FrameTiming timing in timings)
				{
					string[] obj = new string[2] { timing.PrefabName, null };
					double time = timing.Time;
					obj[1] = time.ToString();
					val.AddRow(obj);
				}
				val.AddRow(new string[2]
				{
					"Total time",
					(num3 * 1000.0).ToString()
				});
				Debug.Log((object)((object)val).ToString());
			}
		}
		AutoTurret.ProcessInterferenceQueue();
	}

	[ServerVar(ServerAdmin = true)]
	public static void DebugQueue(Arg arg)
	{
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		foreach (KeyValuePair<QueueType, Queue<IOEntity>> processQueue in _processQueues)
		{
			QueueType key = processQueue.Key;
			Queue<IOEntity> value = processQueue.Value;
			stringBuilder.AppendLine($"{key} queue size: {value.Count}");
			if (value.Count == 0)
			{
				continue;
			}
			var list = (from e in value
				group e by e.PrefabName into g
				select new
				{
					PrefabName = g.Key,
					Count = g.Count(),
					Entities = g.ToList()
				} into g
				orderby g.Count descending
				select g).Take(10).ToList();
			stringBuilder.AppendLine("-----Top queue occupants-----");
			foreach (var item in list)
			{
				IOEntity iOEntity = item.Entities.First();
				stringBuilder.AppendLine($"[{item.Count} times] {iOEntity.PrefabName} @ {((Component)iOEntity).transform.position}");
			}
			if (list.Count > 0)
			{
				IOEntity iOEntity2 = list.First().Entities.First();
				stringBuilder.AppendLine("-----Showing top entity-----");
				stringBuilder.AppendLine($"Entity type: {iOEntity2.ioType}");
				stringBuilder.AppendLine("Entity prefab: " + iOEntity2.PrefabName);
				stringBuilder.AppendLine($"Entity net id: {iOEntity2.net.ID}");
				stringBuilder.AppendLine($"Entity position: teleportpos {((Component)iOEntity2).transform.position}");
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	public virtual void ResetIOState()
	{
	}

	public virtual void Init()
	{
		for (int i = 0; i < outputs.Length; i++)
		{
			IOSlot iOSlot = outputs[i];
			iOSlot.connectedTo.Init();
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				int connectedToSlot = iOSlot.connectedToSlot;
				if (connectedToSlot < 0 || connectedToSlot >= iOSlot.connectedTo.Get().inputs.Length)
				{
					Debug.LogError((object)("Slot IOR Error: " + ((Object)this).name + " setting up inputs for " + ((Object)iOSlot.connectedTo.Get()).name + " slot : " + iOSlot.connectedToSlot));
				}
				else
				{
					iOSlot.connectedTo.Get().inputs[iOSlot.connectedToSlot].connectedTo.Set(this);
					iOSlot.connectedTo.Get().inputs[iOSlot.connectedToSlot].connectedToSlot = i;
					iOSlot.connectedTo.Get().inputs[iOSlot.connectedToSlot].connectedTo.Init();
				}
			}
		}
		UpdateUsedOutputs();
		if (IsRootEntity())
		{
			((FacepunchBehaviour)this).Invoke((Action)MarkDirtyForceUpdateOutputs, Random.Range(1f, 1f));
		}
		ApplyInfinitePower();
	}

	private void ApplyInfinitePower()
	{
		if (!infiniteIoPower || (GetQueueType() != 0 && GetQueueType() != QueueType.Industrial))
		{
			return;
		}
		for (int i = 0; i < inputs.Length; i++)
		{
			if (inputs[i].mainPowerSlot)
			{
				UpdateFromInput(999, i);
			}
		}
	}

	internal override void DoServerDestroy()
	{
		if (base.isServer)
		{
			Shutdown();
		}
		base.DoServerDestroy();
	}

	public void ClearConnections()
	{
		List<IOEntity> list = Pool.Get<List<IOEntity>>();
		List<IOEntity> list2 = Pool.Get<List<IOEntity>>();
		IOSlot[] array = inputs;
		foreach (IOSlot iOSlot in array)
		{
			IOEntity iOEntity = null;
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOEntity = iOSlot.connectedTo.Get();
				if (iOSlot.type == IOType.Industrial)
				{
					list2.Add(iOEntity);
				}
				IOSlot[] array2 = iOSlot.connectedTo.Get().outputs;
				foreach (IOSlot iOSlot2 in array2)
				{
					if ((Object)(object)iOSlot2.connectedTo.Get() != (Object)null && iOSlot2.connectedTo.Get().EqualNetID((BaseNetworkable)this))
					{
						iOSlot2.Clear();
					}
				}
			}
			iOSlot.Clear();
			if (Object.op_Implicit((Object)(object)iOEntity))
			{
				iOEntity.SendNetworkUpdate();
			}
		}
		array = outputs;
		foreach (IOSlot iOSlot3 in array)
		{
			if ((Object)(object)iOSlot3.connectedTo.Get() != (Object)null)
			{
				list.Add(iOSlot3.connectedTo.Get());
				if (iOSlot3.type == IOType.Industrial)
				{
					list2.Add(list[list.Count - 1]);
				}
				IOSlot[] array2 = iOSlot3.connectedTo.Get().inputs;
				foreach (IOSlot iOSlot4 in array2)
				{
					if ((Object)(object)iOSlot4.connectedTo.Get() != (Object)null && iOSlot4.connectedTo.Get().EqualNetID((BaseNetworkable)this))
					{
						iOSlot4.Clear();
					}
				}
			}
			if (Object.op_Implicit((Object)(object)iOSlot3.connectedTo.Get()))
			{
				iOSlot3.connectedTo.Get().UpdateFromInput(0, iOSlot3.connectedToSlot);
			}
			iOSlot3.Clear();
		}
		SendNetworkUpdate();
		foreach (IOEntity item in list)
		{
			if ((Object)(object)item != (Object)null)
			{
				item.MarkDirty();
				item.SendNetworkUpdate();
			}
		}
		for (int k = 0; k < inputs.Length; k++)
		{
			UpdateFromInput(0, k);
		}
		foreach (IOEntity item2 in list2)
		{
			if ((Object)(object)item2 != (Object)null)
			{
				item2.NotifyIndustrialNetworkChanged();
			}
			item2.RefreshIndustrialPreventBuilding();
		}
		Pool.FreeUnmanaged<IOEntity>(ref list);
		Pool.FreeUnmanaged<IOEntity>(ref list2);
		RefreshIndustrialPreventBuilding();
	}

	public void Shutdown()
	{
		SendChangedToRoot(forceUpdate: true);
		ClearConnections();
	}

	public void MarkDirtyForceUpdateOutputs()
	{
		ensureOutputsUpdated = true;
		MarkDirty();
	}

	public void UpdateUsedOutputs()
	{
		cachedOutputsUsed = 0;
		IOSlot[] array = outputs;
		for (int i = 0; i < array.Length; i++)
		{
			IOEntity iOEntity = array[i].connectedTo.Get();
			if ((Object)(object)iOEntity != (Object)null && !iOEntity.IsDestroyed)
			{
				cachedOutputsUsed++;
			}
		}
	}

	public virtual void MarkDirty()
	{
		if (!base.isClient)
		{
			UpdateUsedOutputs();
			TouchIOState();
		}
	}

	public virtual int DesiredPower(int inputIndex = 0)
	{
		if (!inputs[inputIndex].mainPowerSlot)
		{
			return 0;
		}
		int num = ConsumptionAmount();
		if (IsFlickering())
		{
			return num;
		}
		if (currentEnergy < num)
		{
			return 0;
		}
		return num;
	}

	public virtual int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		return inputAmount;
	}

	public virtual int GetCurrentEnergy()
	{
		return Mathf.Clamp(currentEnergy - ConsumptionAmount(), 0, currentEnergy);
	}

	public virtual int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot < 0 || outputSlot >= outputs.Length)
		{
			return 0;
		}
		int num = ((cachedOutputsUsed == 0) ? 1 : cachedOutputsUsed);
		return GetCurrentEnergy() / num;
	}

	public virtual void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, inputAmount >= ConsumptionAmount() && inputAmount > 0, recursive: false, networkupdate: false);
	}

	public void TouchInternal()
	{
		int num = GetPassthroughAmount();
		if (infiniteIoPower && GetQueueType() == QueueType.ElectricLowPriority)
		{
			num = 999;
		}
		bool num2 = lastPassthroughEnergy != num;
		lastPassthroughEnergy = num;
		if (num2)
		{
			IOStateChanged(currentEnergy, 0);
			ensureOutputsUpdated = true;
		}
		if (!PreventDuplicatesInQueue || !_processQueues[GetQueueType()].Contains(this))
		{
			_processQueues[GetQueueType()].Enqueue(this);
		}
	}

	public virtual void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (Interface.CallHook("OnInputUpdate", (object)this, (object)inputAmount, (object)inputSlot) != null)
		{
			return;
		}
		if (inputs[inputSlot].type != ioType || inputs[inputSlot].type == IOType.Industrial)
		{
			IOStateChanged(inputAmount, inputSlot);
			return;
		}
		UpdateHasPower(inputAmount, inputSlot);
		lastEnergy = currentEnergy;
		currentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);
		int num = GetPassthroughAmount();
		if (infiniteIoPower && GetQueueType() == QueueType.ElectricLowPriority)
		{
			num = 999;
		}
		bool flag = lastPassthroughEnergy != num;
		lastPassthroughEnergy = num;
		if (currentEnergy != lastEnergy || flag)
		{
			IOStateChanged(inputAmount, inputSlot);
			ensureOutputsUpdated = true;
		}
		_processQueues[GetQueueType()].Enqueue(this);
	}

	public virtual void TouchIOState()
	{
		if (!base.isClient)
		{
			TouchInternal();
		}
	}

	public virtual void SendIONetworkUpdate()
	{
		SendNetworkUpdate_Flags();
	}

	public bool IsFlickering()
	{
		if (changedCount > 5)
		{
			return Time.realtimeSinceStartup - lastChangeTime < 1f;
		}
		return false;
	}

	public virtual void IOStateChanged(int inputAmount, int inputSlot)
	{
		if (Time.realtimeSinceStartup - lastChangeTime > 1f)
		{
			changedCount = 1;
		}
		else
		{
			changedCount++;
		}
		lastChangeTime = Time.realtimeSinceStartup;
	}

	public virtual void OnCircuitChanged(bool forceUpdate)
	{
		if (forceUpdate)
		{
			MarkDirtyForceUpdateOutputs();
		}
	}

	public virtual void SendChangedToRoot(bool forceUpdate)
	{
		List<IOEntity> existing = Pool.Get<List<IOEntity>>();
		SendChangedToRootRecursive(forceUpdate, ref existing);
		Pool.FreeUnmanaged<IOEntity>(ref existing);
	}

	public virtual void SendChangedToRootRecursive(bool forceUpdate, ref List<IOEntity> existing)
	{
		bool flag = IsRootEntity();
		if (existing.Contains(this))
		{
			return;
		}
		existing.Add(this);
		bool flag2 = false;
		for (int i = 0; i < inputs.Length; i++)
		{
			IOSlot iOSlot = inputs[i];
			if (!iOSlot.mainPowerSlot)
			{
				continue;
			}
			IOEntity iOEntity = iOSlot.connectedTo.Get();
			if (!((Object)(object)iOEntity == (Object)null) && !existing.Contains(iOEntity))
			{
				flag2 = true;
				if (forceUpdate)
				{
					iOEntity.ensureOutputsUpdated = true;
				}
				iOEntity.SendChangedToRootRecursive(forceUpdate, ref existing);
			}
		}
		if (flag)
		{
			forceUpdate = forceUpdate && !flag2;
			OnCircuitChanged(forceUpdate);
		}
	}

	public void NotifyIndustrialNetworkChanged()
	{
		List<IOEntity> list = Pool.Get<List<IOEntity>>();
		OnIndustrialNetworkChanged();
		NotifyIndustrialNetworkChanged(list, input: true, 128);
		list.Clear();
		NotifyIndustrialNetworkChanged(list, input: false, 128);
		Pool.FreeUnmanaged<IOEntity>(ref list);
	}

	private void NotifyIndustrialNetworkChanged(List<IOEntity> existing, bool input, int maxDepth)
	{
		if (maxDepth <= 0 || existing.Contains(this))
		{
			return;
		}
		if (existing.Count != 0)
		{
			OnIndustrialNetworkChanged();
		}
		existing.Add(this);
		IOSlot[] array = (input ? inputs : outputs);
		foreach (IOSlot iOSlot in array)
		{
			if (iOSlot.type == IOType.Industrial && (Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().NotifyIndustrialNetworkChanged(existing, input, maxDepth - 1);
			}
		}
	}

	protected virtual void OnIndustrialNetworkChanged()
	{
	}

	public bool ShouldUpdateOutputs()
	{
		if (Time.realtimeSinceStartup - lastUpdateTime < responsetime)
		{
			lastUpdateBlockedFrame = Time.frameCount;
			_processQueues[GetQueueType()].Enqueue(this);
			return false;
		}
		lastUpdateTime = Time.realtimeSinceStartup;
		SendIONetworkUpdate();
		if (outputs.Length == 0)
		{
			ensureOutputsUpdated = false;
			return false;
		}
		return true;
	}

	public virtual void UpdateOutputs()
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnOutputUpdate", (object)this) != null || !ShouldUpdateOutputs() || !ensureOutputsUpdated)
		{
			return;
		}
		ensureOutputsUpdated = false;
		TimeWarning val = TimeWarning.New("ProcessIOOutputs", 0);
		try
		{
			for (int i = 0; i < outputs.Length; i++)
			{
				IOSlot iOSlot = outputs[i];
				bool flag = true;
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if (!((Object)(object)iOEntity != (Object)null))
				{
					continue;
				}
				if (ioType == IOType.Fluidic && !DisregardGravityRestrictionsOnLiquid && !iOEntity.DisregardGravityRestrictionsOnLiquid)
				{
					TimeWarning val2 = TimeWarning.New("FluidOutputProcessing", 0);
					try
					{
						if (!iOEntity.AllowLiquidPassthrough(this, ((Component)this).transform.TransformPoint(iOSlot.handlePosition)))
						{
							flag = false;
						}
					}
					finally
					{
						((IDisposable)val2)?.Dispose();
					}
				}
				int passthroughAmount = GetPassthroughAmount(i);
				iOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			Init();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Init();
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		Init();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.inputs = Pool.Get<List<IOConnection>>();
		info.msg.ioEntity.outputs = Pool.Get<List<IOConnection>>();
		IOSlot[] array = inputs;
		foreach (IOSlot iOSlot in array)
		{
			IOConnection val = Pool.Get<IOConnection>();
			val.connectedID = iOSlot.connectedTo.entityRef.uid;
			val.connectedToSlot = iOSlot.connectedToSlot;
			val.niceName = iOSlot.niceName;
			val.type = (int)iOSlot.type;
			val.inUse = ((NetworkableId)(ref val.connectedID)).IsValid;
			val.colour = (int)iOSlot.wireColour;
			val.lineThickness = iOSlot.lineThickness;
			val.originPosition = iOSlot.originPosition;
			val.originRotation = iOSlot.originRotation;
			info.msg.ioEntity.inputs.Add(val);
		}
		array = outputs;
		foreach (IOSlot iOSlot2 in array)
		{
			IOConnection val2 = Pool.Get<IOConnection>();
			val2.connectedID = iOSlot2.connectedTo.entityRef.uid;
			val2.connectedToSlot = iOSlot2.connectedToSlot;
			val2.niceName = iOSlot2.niceName;
			val2.type = (int)iOSlot2.type;
			val2.inUse = ((NetworkableId)(ref val2.connectedID)).IsValid;
			val2.colour = (int)iOSlot2.wireColour;
			val2.worldSpaceRotation = iOSlot2.worldSpaceLineEndRotation;
			val2.lineThickness = iOSlot2.lineThickness;
			val2.originPosition = iOSlot2.originPosition;
			val2.originRotation = iOSlot2.originRotation;
			if (iOSlot2.linePoints != null)
			{
				val2.linePointList = Pool.Get<List<LineVec>>();
				for (int j = 0; j < iOSlot2.linePoints.Length; j++)
				{
					Vector3 val3 = iOSlot2.linePoints[j];
					LineVec val4 = Pool.Get<LineVec>();
					val4.vec = Vector4.op_Implicit(val3);
					if (iOSlot2.slackLevels.Length > j)
					{
						val4.vec.w = iOSlot2.slackLevels[j];
					}
					val2.linePointList.Add(val4);
				}
			}
			if (iOSlot2.slackLevels != null)
			{
				val2.slackLevels = Pool.Get<List<float>>();
				val2.slackLevels.AddRange(iOSlot2.slackLevels);
			}
			if (iOSlot2.lineAnchors != null)
			{
				val2.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
				for (int k = 0; k < iOSlot2.lineAnchors.Length; k++)
				{
					if (iOSlot2.lineAnchors[k].entityRef.IsValid(serverside: true))
					{
						WireLineAnchorInfo item = iOSlot2.lineAnchors[k].ToInfo();
						val2.lineAnchorList.Add(item);
					}
				}
			}
			info.msg.ioEntity.outputs.Add(val2);
		}
	}

	public virtual float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot = 0)
	{
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				inputAmount = iOSlot.connectedTo.Get().IOInput(this, iOSlot.type, inputAmount, iOSlot.connectedToSlot);
			}
		}
		return inputAmount;
	}

	public bool Disconnect(int index, bool isInput)
	{
		if (index >= (isInput ? inputs.Length : outputs.Length))
		{
			return false;
		}
		IOSlot iOSlot = (isInput ? inputs[index] : outputs[index]);
		if ((Object)(object)iOSlot.connectedTo.Get() == (Object)null)
		{
			return false;
		}
		IOEntity iOEntity = iOSlot.connectedTo.Get();
		IOSlot obj = (isInput ? iOEntity.outputs[iOSlot.connectedToSlot] : iOEntity.inputs[iOSlot.connectedToSlot]);
		if (isInput)
		{
			UpdateFromInput(0, index);
		}
		else if (Object.op_Implicit((Object)(object)iOEntity))
		{
			iOEntity.UpdateFromInput(0, iOSlot.connectedToSlot);
		}
		iOSlot.Clear();
		obj.Clear();
		MarkDirtyForceUpdateOutputs();
		SendNetworkUpdateImmediate();
		RefreshIndustrialPreventBuilding();
		if ((Object)(object)iOEntity != (Object)null)
		{
			iOEntity.RefreshIndustrialPreventBuilding();
		}
		if (isInput && (Object)(object)iOEntity != (Object)null)
		{
			iOEntity.SendChangedToRoot(forceUpdate: true);
		}
		else if (!isInput)
		{
			IOSlot[] array = inputs;
			foreach (IOSlot iOSlot2 in array)
			{
				if (iOSlot2.mainPowerSlot && Object.op_Implicit((Object)(object)iOSlot2.connectedTo.Get()))
				{
					iOSlot2.connectedTo.Get().SendChangedToRoot(forceUpdate: true);
				}
			}
		}
		iOEntity.SendNetworkUpdateImmediate();
		if (ioType == IOType.Industrial)
		{
			NotifyIndustrialNetworkChanged();
		}
		if ((Object)(object)iOEntity != (Object)null && iOEntity.ioType == IOType.Industrial)
		{
			iOEntity.NotifyIndustrialNetworkChanged();
		}
		return true;
	}

	public void ConnectTo(IOEntity entity, int outputIndex, int inputIndex)
	{
		ConnectTo(entity, outputIndex, inputIndex, new List<Vector3>(), new List<float>(), new LineAnchor[0]);
	}

	public void ConnectTo(IOEntity entity, int outputIndex, int inputIndex, List<Vector3> points, List<float> slackLevels, LineAnchor[] lineAnchors, WireTool.WireColour colour = WireTool.WireColour.Gray)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		IOSlot obj = entity.inputs[inputIndex];
		obj.connectedTo.Set(this);
		obj.connectedToSlot = outputIndex;
		obj.wireColour = colour;
		obj.connectedTo.Init();
		IOSlot obj2 = outputs[outputIndex];
		obj2.connectedTo.Set(entity);
		obj2.connectedToSlot = inputIndex;
		obj2.linePoints = points.ToArray();
		obj2.slackLevels = slackLevels.ToArray();
		obj2.lineAnchors = lineAnchors;
		obj2.wireColour = colour;
		obj2.connectedTo.Init();
		obj2.worldSpaceLineEndRotation = ((Component)entity).transform.TransformDirection(entity.inputs[inputIndex].handleDirection);
		obj2.originPosition = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		obj2.originRotation = ((Quaternion)(ref rotation)).eulerAngles;
		MarkDirtyForceUpdateOutputs();
		SendNetworkUpdate();
		entity.SendNetworkUpdate();
		SendChangedToRoot(forceUpdate: true);
		RefreshIndustrialPreventBuilding();
	}

	public void FindContainerSource(List<ContainerInputOutput> found, int depth, bool input, List<IOEntity> ignoreList, int parentId = -1, int stackSize = 0)
	{
		if (depth <= 0 || found.Count >= 32)
		{
			return;
		}
		int num = 0;
		int num2 = 1;
		IOSlot[] array;
		if (!input)
		{
			num2 = 0;
			array = outputs;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].type == IOType.Industrial)
				{
					num2++;
				}
			}
		}
		List<int> list = Pool.Get<List<int>>();
		array = (input ? inputs : outputs);
		foreach (IOSlot iOSlot in array)
		{
			num++;
			if (iOSlot.type != IOType.Industrial)
			{
				continue;
			}
			IOEntity iOEntity = iOSlot.connectedTo.Get(base.isServer);
			if (!((Object)(object)iOEntity != (Object)null) || ignoreList.Contains(iOEntity))
			{
				continue;
			}
			int num3 = -1;
			if (iOEntity is IIndustrialStorage storage2)
			{
				num = iOSlot.connectedToSlot;
				if (GetExistingCount(storage2) < 2)
				{
					found.Add(new ContainerInputOutput
					{
						SlotIndex = num,
						Storage = storage2,
						ParentStorage = parentId,
						MaxStackSize = stackSize / num2
					});
					num3 = found.Count - 1;
					list.Add(num3);
				}
			}
			else
			{
				ignoreList.Add(iOEntity);
			}
			if ((!(iOEntity is IIndustrialStorage) || iOEntity is IndustrialStorageAdaptor) && !(iOEntity is IndustrialConveyor) && (Object)(object)iOEntity != (Object)null)
			{
				iOEntity.FindContainerSource(found, depth - 1, input, ignoreList, (num3 == -1) ? parentId : num3, stackSize / num2);
			}
		}
		int count = list.Count;
		foreach (int item in list)
		{
			ContainerInputOutput value = found[item];
			value.IndustrialSiblingCount = count;
			found[item] = value;
		}
		Pool.FreeUnmanaged<int>(ref list);
		int GetExistingCount(IIndustrialStorage storage)
		{
			int num4 = 0;
			foreach (ContainerInputOutput item2 in found)
			{
				if (item2.Storage == storage)
				{
					num4++;
				}
			}
			return num4;
		}
	}

	public virtual bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement = false)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (fromSource.DisregardGravityRestrictionsOnLiquid || DisregardGravityRestrictionsOnLiquid)
		{
			return true;
		}
		if (inputs.Length == 0)
		{
			return false;
		}
		Vector3 val = ((Component)this).transform.TransformPoint(inputs[0].handlePosition);
		float num = sourceWorldPosition.y - val.y;
		if (num > 0f)
		{
			return true;
		}
		if (Mathf.Abs(num) < LiquidPassthroughGravityThreshold)
		{
			return true;
		}
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_036e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0445: Unknown result type (might be due to invalid IL or missing references)
		//IL_044a: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ioEntity == null)
		{
			return;
		}
		if (!info.fromDisk && info.msg.ioEntity.inputs != null)
		{
			int count = info.msg.ioEntity.inputs.Count;
			if (inputs.Length != count)
			{
				inputs = new IOSlot[count];
			}
			for (int i = 0; i < count; i++)
			{
				if (inputs[i] == null)
				{
					inputs[i] = new IOSlot();
				}
				IOConnection val = info.msg.ioEntity.inputs[i];
				inputs[i].connectedTo = new IORef();
				inputs[i].connectedTo.entityRef.uid = val.connectedID;
				if (base.isClient)
				{
					inputs[i].connectedTo.InitClient();
				}
				inputs[i].connectedToSlot = val.connectedToSlot;
				inputs[i].niceName = val.niceName;
				inputs[i].type = (IOType)val.type;
				inputs[i].wireColour = (WireTool.WireColour)val.colour;
				inputs[i].lineThickness = val.lineThickness;
				inputs[i].originPosition = val.originPosition;
				inputs[i].originRotation = val.originRotation;
			}
		}
		if (info.msg.ioEntity.outputs != null)
		{
			int count2 = info.msg.ioEntity.outputs.Count;
			IOSlot[] array = null;
			if (outputs.Length != count2 && count2 > 0)
			{
				array = outputs;
				outputs = new IOSlot[count2];
				for (int j = 0; j < array.Length; j++)
				{
					if (j < count2)
					{
						outputs[j] = array[j];
					}
				}
			}
			for (int k = 0; k < count2; k++)
			{
				if (outputs[k] == null)
				{
					outputs[k] = new IOSlot();
				}
				IOConnection val2 = info.msg.ioEntity.outputs[k];
				if (val2.linePointList == null || val2.linePointList.Count == 0 || !((NetworkableId)(ref val2.connectedID)).IsValid)
				{
					outputs[k].Clear();
				}
				outputs[k].connectedTo = new IORef();
				outputs[k].connectedTo.entityRef.uid = val2.connectedID;
				if (base.isClient)
				{
					outputs[k].connectedTo.InitClient();
				}
				outputs[k].connectedToSlot = val2.connectedToSlot;
				outputs[k].niceName = val2.niceName;
				outputs[k].type = (IOType)val2.type;
				outputs[k].wireColour = (WireTool.WireColour)val2.colour;
				outputs[k].worldSpaceLineEndRotation = val2.worldSpaceRotation;
				outputs[k].lineThickness = val2.lineThickness;
				outputs[k].originPosition = (info.fromCopy ? ((Component)this).transform.position : val2.originPosition);
				IOSlot obj = outputs[k];
				Vector3 originRotation;
				if (!info.fromCopy)
				{
					originRotation = val2.originRotation;
				}
				else
				{
					Quaternion rotation = ((Component)this).transform.rotation;
					originRotation = ((Quaternion)(ref rotation)).eulerAngles;
				}
				obj.originRotation = originRotation;
				if (!info.fromDisk && !base.isClient)
				{
					continue;
				}
				List<LineVec> list = val2.linePointList ?? new List<LineVec>();
				if (outputs[k].linePoints == null || outputs[k].linePoints.Length != list.Count)
				{
					outputs[k].linePoints = (Vector3[])(object)new Vector3[list.Count];
				}
				if (outputs[k].slackLevels == null || outputs[k].slackLevels.Length != list.Count)
				{
					outputs[k].slackLevels = new float[list.Count];
				}
				for (int l = 0; l < list.Count; l++)
				{
					outputs[k].linePoints[l] = Vector4.op_Implicit(list[l].vec);
					outputs[k].slackLevels[l] = list[l].vec.w;
				}
				List<WireLineAnchorInfo> list2 = val2.lineAnchorList ?? new List<WireLineAnchorInfo>();
				if (outputs[k].lineAnchors == null || outputs[k].lineAnchors.Length != list2.Count)
				{
					outputs[k].lineAnchors = new LineAnchor[list2.Count];
				}
				for (int m = 0; m < list2.Count; m++)
				{
					WireLineAnchorInfo val3 = list2[m];
					if (((NetworkableId)(ref val3.parentID)).IsValid)
					{
						LineAnchor lineAnchor = new LineAnchor(val3);
						outputs[k].lineAnchors[m] = lineAnchor;
					}
				}
			}
		}
		RefreshIndustrialPreventBuilding();
	}

	public int GetConnectedInputCount()
	{
		int num = 0;
		IOSlot[] array = inputs;
		for (int i = 0; i < array.Length; i++)
		{
			if ((Object)(object)array[i].connectedTo.Get(base.isServer) != (Object)null)
			{
				num++;
			}
		}
		return num;
	}

	public int GetConnectedOutputCount()
	{
		int num = 0;
		IOSlot[] array = outputs;
		for (int i = 0; i < array.Length; i++)
		{
			if ((Object)(object)array[i].connectedTo.Get(base.isServer) != (Object)null)
			{
				num++;
			}
		}
		return num;
	}

	public bool HasConnections()
	{
		if (GetConnectedInputCount() <= 0)
		{
			return GetConnectedOutputCount() > 0;
		}
		return true;
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		ClearIndustrialPreventBuilding();
	}

	public void RefreshIndustrialPreventBuilding()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		ClearIndustrialPreventBuilding();
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		CapsuleCollider val5 = default(CapsuleCollider);
		ColliderInfo_Pipe colliderInfo_Pipe = default(ColliderInfo_Pipe);
		for (int i = 0; i < outputs.Length; i++)
		{
			IOSlot iOSlot = outputs[i];
			if (iOSlot.type != IOType.Industrial || iOSlot.linePoints == null || iOSlot.linePoints.Length <= 1)
			{
				continue;
			}
			Vector3 val = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(iOSlot.linePoints[0]);
			for (int j = 1; j < iOSlot.linePoints.Length; j++)
			{
				Vector3 val2 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(iOSlot.linePoints[j]);
				Vector3 pos = Vector3.Lerp(val2, val, 0.5f);
				float num = Vector3.Distance(val2, val);
				Vector3 val3 = val2 - val;
				Quaternion val4;
				if (!(((Vector3)(ref val3)).normalized != Vector3.zero))
				{
					val4 = Quaternion.identity;
				}
				else
				{
					val3 = val2 - val;
					val4 = Quaternion.LookRotation(((Vector3)(ref val3)).normalized);
				}
				Quaternion rot = val4;
				GameObject obj = base.gameManager.CreatePrefab("assets/prefabs/misc/ioentitypreventbuilding.prefab", pos, rot);
				obj.transform.SetParent(((Component)this).transform);
				if (obj.TryGetComponent<CapsuleCollider>(ref val5))
				{
					val5.height = num + val5.radius;
					spawnedColliders.Add((Collider)(object)val5);
				}
				if (obj.TryGetComponent<ColliderInfo_Pipe>(ref colliderInfo_Pipe))
				{
					colliderInfo_Pipe.OutputSlotIndex = i;
					colliderInfo_Pipe.ParentEntity = this;
				}
				val = val2;
			}
		}
	}

	private void ClearIndustrialPreventBuilding()
	{
		foreach (Collider spawnedCollider in spawnedColliders)
		{
			base.gameManager.Retire(((Component)spawnedCollider).gameObject);
		}
		spawnedColliders.Clear();
	}
}


public enum IOType
{
	Electric,
	Fluidic,
	Kinetic,
	Generic,
	Industrial
}


public enum QueueType
{
	ElectricLowPriority,
	ElectricHighPriority,
	Fluidic,
	Kinetic,
	Generic,
	Industrial
}


using System;
using Oxide.Core;
using UnityEngine;

[Serializable]
public class IORef
{
	public EntityRef entityRef;

	public IOEntity ioEnt;

	public void Init()
	{
		if ((Object)(object)ioEnt != (Object)null && !entityRef.IsValid(serverside: true))
		{
			entityRef.Set(ioEnt);
		}
		if (entityRef.IsValid(serverside: true))
		{
			ioEnt = ((Component)entityRef.Get(serverside: true)).GetComponent<IOEntity>();
		}
	}

	public void InitClient()
	{
		if (entityRef.IsValid(serverside: false) && (Object)(object)ioEnt == (Object)null)
		{
			ioEnt = ((Component)entityRef.Get(serverside: false)).GetComponent<IOEntity>();
		}
	}

	public IOEntity Get(bool isServer = true)
	{
		if ((Object)(object)ioEnt == (Object)null && entityRef.IsValid(isServer))
		{
			ioEnt = entityRef.Get(isServer) as IOEntity;
		}
		return ioEnt;
	}

	public void Clear()
	{
		IOEntity iOEntity = ioEnt;
		ioEnt = null;
		entityRef.Set(null);
		Interface.CallHook("OnIORefCleared", (object)this, (object)iOEntity);
	}

	public void Set(IOEntity newIOEnt)
	{
		entityRef.Set(newIOEnt);
	}
}


using System;
using UnityEngine;

[Serializable]
public class IOSlot
{
	public string niceName;

	public IOType type;

	public IORef connectedTo;

	public int connectedToSlot;

	public IOHandlePriority importance;

	public float ArrowOffset;

	public Vector3[] linePoints;

	public LineAnchor[] lineAnchors;

	public float[] slackLevels;

	public Vector3 worldSpaceLineEndRotation;

	[HideInInspector]
	public Vector3 originPosition;

	[HideInInspector]
	public Vector3 originRotation;

	public ClientIOLine line;

	public Vector3 handlePosition;

	public Vector3 handleDirection;

	public bool rootConnectionsOnly;

	public bool mainPowerSlot;

	public WireTool.WireColour wireColour;

	public float lineThickness;

	public void Clear()
	{
		if (connectedTo == null)
		{
			connectedTo = new IORef();
		}
		else
		{
			connectedTo.Clear();
		}
		connectedToSlot = 0;
		linePoints = null;
		lineAnchors = null;
	}

	public void Preserve(ref SprayCan.IOPreserveInfo target)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		target.connectedTo = connectedTo.Get();
		target.connectedToSlot = connectedToSlot;
		target.linePoints = linePoints;
		target.slackLevels = slackLevels;
		target.lineAnchors = lineAnchors;
		target.worldSpaceLineEndRotation = worldSpaceLineEndRotation;
		target.originPosition = originPosition;
		target.originRotation = originRotation;
		target.wireColour = wireColour;
	}

	public void Restore(SprayCan.IOPreserveInfo from)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		connectedTo.Set(from.connectedTo);
		connectedToSlot = from.connectedToSlot;
		linePoints = from.linePoints;
		slackLevels = from.slackLevels;
		lineAnchors = from.lineAnchors;
		worldSpaceLineEndRotation = from.worldSpaceLineEndRotation;
		originPosition = from.originPosition;
		originRotation = from.originRotation;
		wireColour = from.wireColour;
	}

	public bool IsConnected()
	{
		return (Object)(object)connectedTo.Get() != (Object)null;
	}
}


private struct FrameTiming
{
	public string PrefabName;

	public double Time;
}


using ProtoBuf;
using UnityEngine;

public struct LineAnchor
{
	public EntityRef<Door> entityRef;

	public string boneName;

	public int index;

	public Vector3 position;

	public LineAnchor(WireLineAnchorInfo info)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		entityRef = new EntityRef<Door>(info.parentID);
		boneName = info.boneName;
		index = (int)info.index;
		position = info.position;
	}

	public WireLineAnchorInfo ToInfo()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Expected O, but got Unknown
		return new WireLineAnchorInfo
		{
			parentID = entityRef.Get(serverside: true).net.ID,
			boneName = boneName,
			index = index,
			position = position
		};
	}
}


public struct ContainerInputOutput
{
	public IIndustrialStorage Storage;

	public int SlotIndex;

	public int MaxStackSize;

	public int ParentStorage;

	public int IndustrialSiblingCount;
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ItemBasedFlowRestrictor : IOEntity, IContainerSounds
{
	public ItemDefinition passthroughItem;

	public ItemContainer.ContentsType allowedContents = ItemContainer.ContentsType.Generic;

	public int maxStackSize = 1;

	public int numSlots;

	public string lootPanelName = "generic";

	public const Flags HasPassthrough = Flags.Reserved1;

	public const Flags Sparks = Flags.Reserved2;

	public float passthroughItemConditionLossPerSec = 1f;

	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	public ItemContainer inventory;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ItemBasedFlowRestrictor.OnRpcMessage", 0);
		try
		{
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetIOState()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.On, b: false);
		if (inventory != null)
		{
			inventory.GetSlot(0)?.Drop(((Component)debugOrigin).transform.position + ((Component)this).transform.forward * 0.5f, GetInheritedDropVelocity() + ((Component)this).transform.forward * 2f);
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!HasFlag(Flags.Reserved1))
		{
			return 0;
		}
		return base.GetPassthroughAmount(outputSlot);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		SetFlag(Flags.On, IsPowered());
		SetFlag(Flags.Reserved1, HasPassthroughItem());
		SetFlag(Flags.Reserved2, IsOn() && !HasFlag(Flags.Reserved1));
	}

	public virtual bool HasPassthroughItem()
	{
		if (inventory.itemList.Count <= 0)
		{
			return false;
		}
		Item slot = inventory.GetSlot(0);
		if (slot == null)
		{
			return false;
		}
		if (passthroughItemConditionLossPerSec > 0f && slot.hasCondition && slot.conditionNormalized <= 0f)
		{
			return false;
		}
		if ((Object)(object)slot.info == (Object)(object)passthroughItem)
		{
			return true;
		}
		return false;
	}

	public virtual void TickPassthroughItem()
	{
		if (inventory.itemList.Count > 0 && HasFlag(Flags.On))
		{
			Item slot = inventory.GetSlot(0);
			if (slot != null && slot.hasCondition)
			{
				slot.LoseCondition(1f);
			}
		}
	}

	public override void ServerInit()
	{
		if (inventory == null)
		{
			CreateInventory(giveUID: true);
			OnInventoryFirstCreated(inventory);
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)TickPassthroughItem, 1f, 1f, 0.015f);
		base.ServerInit();
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Pool.Free<ItemContainer>(ref inventory);
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		CreateInventory(giveUID: false);
	}

	public void CreateInventory(bool giveUID)
	{
		Debug.Assert(inventory == null, "Double init of inventory!");
		inventory = Pool.Get<ItemContainer>();
		inventory.entityOwner = this;
		inventory.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
		inventory.SetOnlyAllowedItem(passthroughItem);
		inventory.maxStackSize = maxStackSize;
		inventory.ServerInitialize(null, numSlots);
		if (giveUID)
		{
			inventory.GiveUID();
		}
		inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if (inventory != null)
			{
				info.msg.storageBox = Pool.Get<StorageBox>();
				info.msg.storageBox.contents = inventory.Save();
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.storageBox != null)
		{
			if (inventory != null)
			{
				inventory.Load(info.msg.storageBox.contents);
				inventory.capacity = numSlots;
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public virtual void OnInventoryFirstCreated(ItemContainer container)
	{
	}

	public virtual void OnItemAddedOrRemoved(Item item, bool added)
	{
		SetFlag(Flags.Reserved1, HasPassthroughItem());
		MarkDirty();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract() && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", (object)player, (object)this);
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class Jackhammer : BaseMelee
{
	public float HotspotBonusScale = 1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Jackhammer.OnRpcMessage", 0);
		try
		{
			if (rpc == 1699910227 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetEngineStatus "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetEngineStatus", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_SetEngineStatus(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_SetEngineStatus");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool HasAmmo()
	{
		return true;
	}

	[RPC_Server]
	public void Server_SetEngineStatus(RPCMessage msg)
	{
		SetEngineStatus(msg.read.Bit());
	}

	public void SetEngineStatus(bool on)
	{
		SetFlag(Flags.Reserved8, on);
	}

	public override void SetHeld(bool bHeld)
	{
		if (!bHeld)
		{
			SetEngineStatus(on: false);
		}
		base.SetHeld(bHeld);
	}
}


using System;
using System.Collections;
using Network;
using UnityEngine;

public class JunkPile : BaseEntity
{
	public GameObjectRef sinkEffect;

	public SpawnGroup[] spawngroups;

	public NPCSpawner NPCSpawn;

	private const float lifetimeMinutes = 30f;

	protected bool isSinking;

	private float timeWantingDespawn;

	private float timeBeforeDespawn = 90f;

	private float checkEmptyDelay = 30f;

	public virtual bool DespawnIfAnyLootTaken => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("JunkPile.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)TimeOut, 1800f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckEmpty, 10f, checkEmptyDelay);
		((MonoBehaviour)this).StartCoroutine(SpawnInitialCoroutine());
		isSinking = false;
	}

	internal override void DoServerDestroy()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		StabilityEntity.UpdateSurroundingsQueue updateSurroundingsQueue = StabilityEntity.updateSurroundingsQueue;
		OBB val = WorldSpaceBounds();
		((ObjectWorkQueue<Bounds>)updateSurroundingsQueue).Add(((OBB)(ref val)).ToBounds());
	}

	private IEnumerator SpawnInitialCoroutine()
	{
		yield return CoroutineEx.waitForSeconds(1f);
		SpawnGroup[] array = spawngroups;
		foreach (SpawnGroup s in array)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			s.SpawnInitial();
		}
	}

	public bool SpawnGroupsEmpty()
	{
		SpawnGroup[] array = spawngroups;
		foreach (SpawnGroup spawnGroup in array)
		{
			if (spawnGroup.DoesGroupContainNPCs())
			{
				continue;
			}
			if (DespawnIfAnyLootTaken)
			{
				if (spawnGroup.ObjectsRemoved > 0)
				{
					return true;
				}
				foreach (SpawnPointInstance spawnInstance in spawnGroup.SpawnInstances)
				{
					if (spawnInstance.Entity is LootContainer { HasBeenLooted: not false })
					{
						return true;
					}
				}
			}
			else if (spawnGroup.currentPopulation > 0)
			{
				return false;
			}
		}
		if ((Object)(object)NPCSpawn != (Object)null && NPCSpawn.currentPopulation > 0)
		{
			return false;
		}
		if (DespawnIfAnyLootTaken)
		{
			return false;
		}
		return true;
	}

	public void CheckEmpty()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (SpawnGroupsEmpty() && !BaseNetworkable.HasCloseConnections(((Component)this).transform.position, TimeoutPlayerCheckRadius()))
		{
			timeWantingDespawn += checkEmptyDelay;
			if (timeWantingDespawn >= timeBeforeDespawn)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)CheckEmpty);
				SinkAndDestroy();
			}
		}
		else
		{
			timeWantingDespawn = 0f;
		}
	}

	public virtual float TimeoutPlayerCheckRadius()
	{
		return 15f;
	}

	public void TimeOut()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (BaseNetworkable.HasCloseConnections(((Component)this).transform.position, TimeoutPlayerCheckRadius()))
		{
			((FacepunchBehaviour)this).Invoke((Action)TimeOut, 30f);
			return;
		}
		SpawnGroupsEmpty();
		SinkAndDestroy();
	}

	public void SinkAndDestroy()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SinkAndDestroy);
			SpawnGroup[] array = spawngroups;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Clear();
			}
			SetFlag(Flags.Reserved8, b: true, recursive: true);
			if ((Object)(object)NPCSpawn != (Object)null)
			{
				NPCSpawn.Clear();
			}
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_StartSink"));
			Transform transform = ((Component)this).transform;
			transform.position -= new Vector3(0f, 5f, 0f);
			isSinking = true;
			((FacepunchBehaviour)this).Invoke((Action)KillMe, 22f);
		}
	}

	public void KillMe()
	{
		Kill();
	}

	public static void NotifyLootContainerLooted(BaseEntity entity)
	{
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}
}


using System;
using Network;
using Rust;
using UnityEngine;

public class Kayak : BaseBoat, IPoolVehicle
{
	private enum PaddleDirection
	{
		Left,
		Right,
		LeftBack,
		RightBack
	}

	public ItemDefinition OarItem;

	public float maxPaddleFrequency = 0.5f;

	public float forwardPaddleForce = 5f;

	public float multiDriverPaddleForceMultiplier = 0.75f;

	public float rotatePaddleForce = 3f;

	public GameObjectRef forwardSplashEffect;

	public GameObjectRef backSplashEffect;

	public ParticleSystem moveSplashEffect;

	public float animationLerpSpeed = 6f;

	[Header("Audio")]
	public BlendedSoundLoops waterLoops;

	public float waterSoundSpeedDivisor = 10f;

	public GameObjectRef pushLandEffect;

	public GameObjectRef pushWaterEffect;

	public PlayerModel.MountPoses noPaddlePose;

	public TimeSince[] playerPaddleCooldowns = (TimeSince[])(object)new TimeSince[2];

	public TimeCachedValue<float> fixedDragUpdate;

	public TimeSince timeSinceLastUsed;

	private const float DECAY_TICK_TIME = 60f;

	private Vector3 lastTravelPos;

	private bool inCinematic;

	private Quaternion cinematicWorldRotation;

	private int lastDownhillUpdate;

	private float distanceRemainder;

	protected override bool SkipBoatForcedUpdate => buoyancy.BuoyancyPriority == Buoyancy.Priority.Low;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Kayak.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		inCinematic = false;
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)BoatDecay, Random.Range(30f, 60f), 60f, 6f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)LowPriorityCheck, 0f, 5f, 2.5f);
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		buoyancy.wavesEffect = (((Object)(object)deployedBy != (Object)null && deployedBy.IsInTutorial) ? 0f : 1f);
	}

	public override void OnPlayerMounted()
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		base.OnPlayerMounted();
		if (!((FacepunchBehaviour)this).IsInvoking((Action)TravelDistanceUpdate) && GameInfo.HasAchievements)
		{
			int num = 0;
			foreach (MountPointInfo allMountPoint in base.allMountPoints)
			{
				if ((Object)(object)allMountPoint.mountable != (Object)null && allMountPoint.mountable.AnyMounted())
				{
					num++;
				}
			}
			if (num == 2)
			{
				lastTravelPos = Vector3Ex.WithY(((Component)this).transform.position, 0f);
				((FacepunchBehaviour)this).InvokeRandomized((Action)TravelDistanceUpdate, 5f, 5f, 3f);
			}
		}
		buoyancy.LowPriorityCheck(forceHighPriority: true);
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		if (((FacepunchBehaviour)this).IsInvoking((Action)TravelDistanceUpdate))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TravelDistanceUpdate);
		}
	}

	public override void DriverInput(InputState inputState, BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		if (!IsPlayerHoldingPaddle(player))
		{
			return;
		}
		int playerSeat = GetPlayerSeat(player);
		if (!(TimeSince.op_Implicit(playerPaddleCooldowns[playerSeat]) > maxPaddleFrequency))
		{
			return;
		}
		bool flag = inputState.IsDown(BUTTON.BACKWARD);
		bool flag2 = false;
		Vector3 val = ((Component)this).transform.forward;
		if (flag)
		{
			val = -val;
		}
		float num = forwardPaddleForce;
		if (NumMounted() >= 2)
		{
			num *= multiDriverPaddleForceMultiplier;
		}
		if (inputState.IsDown(BUTTON.LEFT) || inputState.IsDown(BUTTON.FIRE_PRIMARY))
		{
			flag2 = true;
			rigidBody.AddForceAtPosition(val * num, GetPaddlePoint(playerSeat, PaddleDirection.Left), (ForceMode)1);
			Rigidbody obj = rigidBody;
			obj.angularVelocity += -((Component)this).transform.up * rotatePaddleForce;
			ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), flag ? 2 : 0, playerSeat);
		}
		else if (inputState.IsDown(BUTTON.RIGHT) || inputState.IsDown(BUTTON.FIRE_SECONDARY))
		{
			flag2 = true;
			rigidBody.AddForceAtPosition(val * num, GetPaddlePoint(playerSeat, PaddleDirection.Right), (ForceMode)1);
			Rigidbody obj2 = rigidBody;
			obj2.angularVelocity += ((Component)this).transform.up * rotatePaddleForce;
			ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), (!flag) ? 1 : 3, playerSeat);
		}
		if (flag2)
		{
			playerPaddleCooldowns[playerSeat] = TimeSince.op_Implicit(0f);
			if (!flag)
			{
				Vector3 velocity = rigidBody.velocity;
				rigidBody.velocity = Vector3.Lerp(velocity, val * ((Vector3)(ref velocity)).magnitude, 0.4f);
			}
		}
	}

	private void TravelDistanceUpdate()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.WithY(((Component)this).transform.position, 0f);
		if (GameInfo.HasAchievements)
		{
			float num = Vector3.Distance(lastTravelPos, val) + distanceRemainder;
			float num2 = Mathf.Max(Mathf.Floor(num), 0f);
			distanceRemainder = num - num2;
			foreach (MountPointInfo allMountPoint in base.allMountPoints)
			{
				if ((Object)(object)allMountPoint.mountable != (Object)null && allMountPoint.mountable.AnyMounted() && (int)num2 > 0)
				{
					allMountPoint.mountable.GetMounted().stats.Add("kayak_distance_travelled", (int)num2);
					allMountPoint.mountable.GetMounted().stats.Save(forceSteamSave: true);
				}
			}
		}
		lastTravelPos = val;
	}

	public override bool EngineOn()
	{
		return false;
	}

	public override void DoPushAction(BasePlayer player)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		if (IsFlipped())
		{
			rigidBody.AddRelativeTorque(Vector3.forward * 8f, (ForceMode)2);
		}
		else
		{
			Vector3 val = Vector3Ex.Direction2D(((Component)player).transform.position + player.eyes.BodyForward() * 3f, ((Component)player).transform.position);
			Vector3 val2 = Vector3.up * 0.1f + val;
			val = ((Vector3)(ref val2)).normalized;
			Vector3 position = ((Component)this).transform.position;
			float num = 5f;
			if (IsInWater())
			{
				num *= 0.75f;
			}
			rigidBody.AddForceAtPosition(val * num, position, (ForceMode)2);
		}
		if (IsInWater())
		{
			if (pushWaterEffect.isValid)
			{
				Effect.server.Run(pushWaterEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		else if (pushLandEffect.isValid)
		{
			Effect.server.Run(pushLandEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
		WakeUp();
	}

	public override void VehicleFixedUpdate()
	{
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Kayak.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (fixedDragUpdate == null)
			{
				fixedDragUpdate = new TimeCachedValue<float>
				{
					refreshCooldown = 0.5f,
					refreshRandomRange = 0.2f,
					updateValue = CalculateDesiredDrag
				};
			}
			if (inCinematic)
			{
				if (!rigidBody.isKinematic)
				{
					Vector3 velocity = rigidBody.velocity;
					velocity = Vector3.MoveTowards(velocity, Vector3Ex.WithZ(Vector3Ex.WithX(velocity, 0f), 0f), Time.fixedDeltaTime);
					rigidBody.velocity = velocity;
				}
				((Component)this).transform.rotation = Quaternion.RotateTowards(((Component)this).transform.rotation, cinematicWorldRotation, 180f * Time.fixedDeltaTime);
			}
			rigidBody.drag = fixedDragUpdate.Get(force: false);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float CalculateDesiredDrag()
	{
		int num = NumMounted();
		if (num == 0)
		{
			return 1f;
		}
		if (num < 2)
		{
			return 0.05f;
		}
		return 0.1f;
	}

	public void BoatDecay()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		BaseBoat.WaterVehicleDecay(this, 60f, TimeSince.op_Implicit(timeSinceLastUsed), MotorRowboat.outsidedecayminutes, MotorRowboat.deepwaterdecayminutes, MotorRowboat.decaystartdelayminutes, preventDecayIndoors);
	}

	private void LowPriorityCheck()
	{
		buoyancy.LowPriorityCheck(AnyMounted());
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (!HasDriver())
		{
			return base.CanPickup(player);
		}
		return false;
	}

	public void PrepareForTutorialCinematic(Quaternion worldRotation)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		inCinematic = true;
		cinematicWorldRotation = worldRotation;
	}

	public bool IsPlayerHoldingPaddle(BasePlayer player)
	{
		if ((Object)(object)player.GetHeldEntity() != (Object)null)
		{
			return (Object)(object)player.GetHeldEntity().GetItem().info == (Object)(object)OarItem;
		}
		return false;
	}

	public Vector3 GetPaddlePoint(int index, PaddleDirection direction)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		index = Mathf.Clamp(index, 0, mountPoints.Count);
		Vector3 pos = mountPoints[index].pos;
		switch (direction)
		{
		case PaddleDirection.Left:
			pos.x -= 1f;
			break;
		case PaddleDirection.Right:
			pos.x += 1f;
			break;
		}
		pos.y -= 0.2f;
		return ((Component)this).transform.TransformPoint(pos);
	}

	public bool IsInWater()
	{
		if (base.isServer)
		{
			return buoyancy.timeOutOfWater < 0.1f;
		}
		return false;
	}
}


private enum PaddleDirection
{
	Left,
	Right,
	LeftBack,
	RightBack
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class KeyLock : BaseLock
{
	[ItemSelector]
	public ItemDefinition keyItemType;

	public int keyCode;

	public bool firstKeyCreated;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("KeyLock.OnRpcMessage", 0);
		try
		{
			if (rpc == 4135414453u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_CreateKey "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_CreateKey", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4135414453u, "RPC_CreateKey", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_CreateKey(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_CreateKey");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 954115386 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Lock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Lock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(954115386u, "RPC_Lock", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_Lock(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Lock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1663222372 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Unlock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Unlock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1663222372u, "RPC_Unlock", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							RPC_Unlock(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_Unlock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool HasLockPermission(BasePlayer player)
	{
		if (player.IsDead())
		{
			return false;
		}
		if ((ulong)player.userID == base.OwnerID)
		{
			return true;
		}
		PooledList<Item> val = Pool.Get<PooledList<Item>>();
		try
		{
			player.inventory.FindItemsByItemID((List<Item>)(object)val, keyItemType.itemid);
			for (int i = 0; i < ((List<Item>)(object)val).Count; i++)
			{
				if (CanKeyUnlockUs(((List<Item>)(object)val)[i]))
				{
					return true;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool CanKeyUnlockUs(Item key)
	{
		if (key.instanceData == null)
		{
			return false;
		}
		if (key.instanceData.dataInt != keyCode)
		{
			return false;
		}
		return true;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.keyLock != null)
		{
			LoadKeylockData(info.msg.keyLock);
		}
	}

	public void LoadKeylockData(KeyLock keyLock)
	{
		if (keyLock != null)
		{
			keyCode = keyLock.code;
		}
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (base.OwnerID == 0L && Object.op_Implicit((Object)(object)GetParentEntity()))
		{
			base.OwnerID = GetParentEntity().OwnerID;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.keyLock = Pool.Get<KeyLock>();
			info.msg.keyLock.code = keyCode;
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		keyCode = Random.Range(1, 100000);
		Lock(deployedBy);
	}

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

	public override bool OnTryToClose(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", (object)rpc.player, (object)this) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	private void RPC_Lock(RPCMessage rpc)
	{
		Lock(rpc.player);
	}

	private void Lock(BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) && player.CanInteract() && !IsLocked() && Interface.CallHook("CanLock", (object)player, (object)this) == null && HasLockPermission(player))
		{
			LockLock(player);
			SendNetworkUpdate();
		}
	}

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void RPC_CreateKey(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || (IsLocked() && !HasLockPermission(rpc.player)))
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(keyItemType.itemid);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			Debug.LogWarning((object)("RPC_CreateKey: Itemdef is missing! " + (object)keyItemType));
			return;
		}
		ItemBlueprint bp = ItemManager.FindBlueprint(itemDefinition);
		if (rpc.player.inventory.crafting.CanCraft(bp))
		{
			InstanceData val = Pool.Get<InstanceData>();
			val.dataInt = keyCode;
			rpc.player.inventory.crafting.CraftItem(bp, rpc.player, val);
			if (!firstKeyCreated)
			{
				LockLock(rpc.player);
				SendNetworkUpdate();
				firstKeyCreated = true;
			}
		}
	}

	public void LockLock(BasePlayer player)
	{
		SetFlag(Flags.Locked, b: true);
		if (player.IsValid())
		{
			player.GiveAchievement("LOCK_LOCK");
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Landmine : BaseTrap
{
	public GameObjectRef explosionEffect;

	public GameObjectRef triggeredEffect;

	public float minExplosionRadius;

	public float explosionRadius;

	public int vibrationLevel = 1;

	public bool blocked;

	private ulong triggerPlayerID;

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Landmine.OnRpcMessage", 0);
		try
		{
			if (rpc == 1552281787 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Disarm "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Disarm", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1552281787u, "RPC_Disarm", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_Disarm(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Disarm");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool Triggered()
	{
		return HasFlag(Flags.Open);
	}

	public bool Armed()
	{
		return HasFlag(Flags.On);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.landmine = Pool.Get<Landmine>();
			info.msg.landmine.triggeredID = triggerPlayerID;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk && info.msg.landmine != null)
		{
			triggerPlayerID = info.msg.landmine.triggeredID;
		}
	}

	public override void ServerInit()
	{
		SetFlag(Flags.On, b: false);
		((FacepunchBehaviour)this).Invoke((Action)Arm, 1.5f);
		base.ServerInit();
	}

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", (object)this, (object)obj) == null)
			{
				BasePlayer ply = obj.ToBaseEntity() as BasePlayer;
				Trigger(ply);
			}
		}
	}

	public void Trigger(BasePlayer ply = null)
	{
		if ((Object)(object)ply != (Object)null)
		{
			triggerPlayerID = ply.userID;
		}
		SetFlag(Flags.Open, b: true);
		SendNetworkUpdate();
	}

	public override void OnEmpty()
	{
		if (blocked)
		{
			Arm();
			blocked = false;
		}
		else if (Triggered())
		{
			((FacepunchBehaviour)this).Invoke((Action)TryExplode, 0.05f);
		}
	}

	public virtual void Explode()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		base.health = float.PositiveInfinity;
		Effect.server.Run(explosionEffect.resourcePath, PivotPoint(), ((Component)this).transform.up, null, broadcast: true);
		DamageUtil.RadiusDamage(this, LookupPrefab(), CenterPoint(), minExplosionRadius, explosionRadius, damageTypes, 2263296, useLineOfSight: true);
		SeismicSensor.Notify(CenterPoint(), vibrationLevel);
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override void OnDied(HitInfo info)
	{
		((FacepunchBehaviour)this).Invoke((Action)Explode, Random.Range(0.1f, 0.3f));
	}

	private void OnGroundMissing()
	{
		Explode();
	}

	private void TryExplode()
	{
		if (Armed())
		{
			Explode();
		}
	}

	public override void Arm()
	{
		SetFlag(Flags.On, b: true);
		SendNetworkUpdate();
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if ((ulong)rpc.player.userID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", (object)this, (object)rpc.player) == null && Triggered())
		{
			if (Random.Range(0, 100) < 15)
			{
				((FacepunchBehaviour)this).Invoke((Action)TryExplode, 0.05f);
				return;
			}
			SetFlag(Flags.On, b: false);
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Lift : AnimatedBuildingBlock
{
	public GameObjectRef triggerPrefab;

	public string triggerBone;

	public float resetDelay = 5f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Lift.OnRpcMessage", 0);
		try
		{
			if (rpc == 2657791441u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_UseLift "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_UseLift", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2657791441u, "RPC_UseLift", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_UseLift(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_UseLift");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_UseLift(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && Interface.CallHook("OnLiftUse", (object)this, (object)rpc.player) == null)
		{
			MoveUp();
		}
	}

	private void MoveUp()
	{
		if (!IsOpen() && !IsBusy())
		{
			SetFlag(Flags.Open, b: true);
			SendNetworkUpdateImmediate();
		}
	}

	private void MoveDown()
	{
		if (IsOpen() && !IsBusy())
		{
			SetFlag(Flags.Open, b: false);
			SendNetworkUpdateImmediate();
		}
	}

	protected override void OnAnimatorDisabled()
	{
		if (base.isServer && IsOpen())
		{
			((FacepunchBehaviour)this).Invoke((Action)MoveDown, resetDelay);
		}
	}

	public override void Spawn()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(triggerPrefab.resourcePath, Vector3.zero, Quaternion.identity);
			baseEntity.Spawn();
			baseEntity.SetParent(this, triggerBone);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class LiquidContainer : ContainerIOEntity
{
	public ItemDefinition defaultLiquid;

	public int startingAmount;

	public bool autofillOutputs;

	public float autofillTickRate = 2f;

	public int autofillTickAmount = 2;

	public int maxOutputFlow = 6;

	public ItemDefinition[] ValidItems;

	private int currentDrainAmount;

	private HashSet<IOEntity> connectedList = new HashSet<IOEntity>();

	private HashSet<ContainerIOEntity> pushTargets = new HashSet<ContainerIOEntity>();

	private const int maxPushTargets = 12;

	private IOEntity considerConnectedTo;

	private Action updateDrainAmountAction;

	private Action updatePushLiquidTargetsAction;

	private Action pushLiquidAction;

	private Action deductFuelAction;

	private TimeUntil waterTransferStartTime;

	private float lastOutputDrainUpdate;

	private static HashSet<IOEntity> pushLiquidCheckEntityHash = new HashSet<IOEntity>();

	public override bool IsGravitySource => true;

	protected override bool DisregardGravityRestrictionsOnLiquid
	{
		get
		{
			if (!HasFlag(Flags.Reserved8))
			{
				return base.DisregardGravityRestrictionsOnLiquid;
			}
			return true;
		}
	}

	public override bool BlockFluidDraining => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("LiquidContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 2002733690 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVDrink "));
				}
				TimeWarning val2 = TimeWarning.New("SVDrink", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2002733690u, "SVDrink", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							SVDrink(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SVDrink");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool AllowWireConnections()
	{
		if (HasParent() && (Object)(object)parentEntity.Get(base.isServer) != (Object)null && parentEntity.Get(base.isServer) is VehicleModuleStorage)
		{
			return true;
		}
		return base.AllowWireConnections();
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	private bool CanAcceptItem(Item item, int count)
	{
		if (ValidItems == null || ValidItems.Length == 0)
		{
			return true;
		}
		ItemDefinition[] validItems = ValidItems;
		for (int i = 0; i < validItems.Length; i++)
		{
			if ((Object)(object)validItems[i] == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	public override void ServerInit()
	{
		updateDrainAmountAction = UpdateDrainAmount;
		pushLiquidAction = PushLiquidThroughOutputs;
		deductFuelAction = DeductFuel;
		updatePushLiquidTargetsAction = UpdatePushLiquidTargets;
		base.ServerInit();
		if (startingAmount > 0)
		{
			base.inventory.AddItem(defaultLiquid, startingAmount, 0uL);
		}
		if (autofillOutputs && HasLiquidItem())
		{
			UpdatePushLiquidTargets();
		}
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	public override void OnCircuitChanged(bool forceUpdate)
	{
		base.OnCircuitChanged(forceUpdate);
		ClearDrains();
		((FacepunchBehaviour)this).Invoke(updateDrainAmountAction, 0.1f);
		if (autofillOutputs && HasLiquidItem())
		{
			((FacepunchBehaviour)this).Invoke(updatePushLiquidTargetsAction, 0.1f);
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		base.OnItemAddedOrRemoved(item, added);
		UpdateOnFlag();
		MarkDirtyForceUpdateOutputs();
		((FacepunchBehaviour)this).Invoke(updateDrainAmountAction, 0.1f);
		if (connectedList.Count > 0)
		{
			List<IOEntity> list = Pool.Get<List<IOEntity>>();
			foreach (IOEntity connected in connectedList)
			{
				if ((Object)(object)connected != (Object)null)
				{
					list.Add(connected);
				}
			}
			foreach (IOEntity item2 in list)
			{
				item2.SendChangedToRoot(forceUpdate: true);
			}
			Pool.FreeUnmanaged<IOEntity>(ref list);
		}
		if (HasLiquidItem() && autofillOutputs)
		{
			((FacepunchBehaviour)this).Invoke(updatePushLiquidTargetsAction, 0.1f);
		}
		if (added)
		{
			waterTransferStartTime = TimeUntil.op_Implicit(10f);
		}
	}

	private void ClearDrains()
	{
		foreach (IOEntity connected in connectedList)
		{
			if ((Object)(object)connected != (Object)null)
			{
				connected.SetFuelType(null, null);
			}
		}
		connectedList.Clear();
	}

	public override int GetCurrentEnergy()
	{
		return Mathf.Clamp(GetLiquidCount(), 0, maxOutputFlow);
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		if (!HasLiquidItem())
		{
			return base.CalculateCurrentEnergy(inputAmount, inputSlot);
		}
		return GetCurrentEnergy();
	}

	private void UpdateDrainAmount()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		int amount = 0;
		Item liquidItem = GetLiquidItem();
		if (liquidItem != null)
		{
			IOSlot[] array = outputs;
			foreach (IOSlot iOSlot in array)
			{
				if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
				{
					CalculateDrain(iOSlot.connectedTo.Get(), ((Component)this).transform.TransformPoint(iOSlot.handlePosition), IOEntity.backtracking * 2, ref amount, this, liquidItem?.info);
				}
			}
		}
		currentDrainAmount = Mathf.Clamp(amount, 0, maxOutputFlow);
		if (currentDrainAmount <= 0 && ((FacepunchBehaviour)this).IsInvoking(deductFuelAction))
		{
			((FacepunchBehaviour)this).CancelInvoke(deductFuelAction);
		}
		else if (currentDrainAmount > 0 && !((FacepunchBehaviour)this).IsInvoking(deductFuelAction))
		{
			((FacepunchBehaviour)this).InvokeRepeating(deductFuelAction, 0f, 1f);
		}
	}

	private void CalculateDrain(IOEntity ent, Vector3 fromSlotWorld, int depth, ref int amount, IOEntity lastEntity, ItemDefinition waterType)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)(object)this || depth <= 0 || (Object)(object)ent == (Object)null || (Object)(object)lastEntity == (Object)null || ent is LiquidContainer)
		{
			return;
		}
		if (!ent.BlockFluidDraining && ent.HasFlag(Flags.On))
		{
			int num = ent.DesiredPower();
			amount += num;
			ent.SetFuelType(waterType, this);
			connectedList.Add(ent);
		}
		if (!ent.AllowLiquidPassthrough(lastEntity, fromSlotWorld))
		{
			return;
		}
		IOSlot[] array = ent.outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null && (Object)(object)iOSlot.connectedTo.Get() != (Object)(object)ent)
			{
				CalculateDrain(iOSlot.connectedTo.Get(), ((Component)ent).transform.TransformPoint(iOSlot.handlePosition), depth - 1, ref amount, ent, waterType);
			}
		}
	}

	public override void UpdateOutputs()
	{
		base.UpdateOutputs();
		if (!(Time.realtimeSinceStartup - lastOutputDrainUpdate < 0.2f))
		{
			lastOutputDrainUpdate = Time.realtimeSinceStartup;
			ClearDrains();
			((FacepunchBehaviour)this).Invoke(updateDrainAmountAction, 0.1f);
		}
	}

	private void DeductFuel()
	{
		if (HasLiquidItem())
		{
			Item liquidItem = GetLiquidItem();
			liquidItem.amount -= currentDrainAmount;
			liquidItem.MarkDirty();
			if (liquidItem.amount <= 0)
			{
				liquidItem.Remove();
			}
		}
	}

	protected void UpdateOnFlag()
	{
		SetFlag(Flags.On, base.inventory.itemList.Count > 0 && base.inventory.itemList[0].amount > 0);
	}

	public virtual void OpenTap(float duration)
	{
		if (!HasFlag(Flags.Reserved5))
		{
			SetFlag(Flags.Reserved5, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ShutTap, duration);
			SendNetworkUpdateImmediate();
		}
	}

	public virtual void ShutTap()
	{
		SetFlag(Flags.Reserved5, b: false);
		SendNetworkUpdateImmediate();
	}

	public bool HasLiquidItem()
	{
		return GetLiquidItem() != null;
	}

	public Item GetLiquidItem()
	{
		if (base.inventory.itemList.Count == 0)
		{
			return null;
		}
		return base.inventory.itemList[0];
	}

	public int GetLiquidCount()
	{
		if (!HasLiquidItem())
		{
			return 0;
		}
		return GetLiquidItem().amount;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SVDrink(RPCMessage rpc)
	{
		if (!rpc.player.metabolism.CanConsume() || Interface.CallHook("OnPlayerDrink", (object)rpc.player, (object)this) != null)
		{
			return;
		}
		foreach (Item item in base.inventory.itemList)
		{
			ItemModConsume component = ((Component)item.info).GetComponent<ItemModConsume>();
			if (!((Object)(object)component == (Object)null) && component.CanDoAction(item, rpc.player))
			{
				component.DoAction(item, rpc.player);
				break;
			}
		}
	}

	private void UpdatePushLiquidTargets()
	{
		pushTargets.Clear();
		if (!HasLiquidItem() || IsConnectedTo(this, IOEntity.backtracking * 2))
		{
			return;
		}
		Item liquidItem = GetLiquidItem();
		pushLiquidCheckEntityHash.Clear();
		TimeWarning val = TimeWarning.New("UpdatePushTargets", 0);
		try
		{
			IOSlot[] array = outputs;
			foreach (IOSlot iOSlot in array)
			{
				if (iOSlot.type == IOType.Fluidic)
				{
					IOEntity iOEntity = iOSlot.connectedTo.Get();
					if ((Object)(object)iOEntity != (Object)null)
					{
						CheckPushLiquid(iOEntity, liquidItem, this, IOEntity.backtracking * 4, pushLiquidCheckEntityHash);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (pushTargets.Count > 0)
		{
			((FacepunchBehaviour)this).InvokeRandomized(pushLiquidAction, 0f, autofillTickRate, autofillTickRate * 0.2f);
		}
	}

	private void PushLiquidThroughOutputs()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeUntil.op_Implicit(waterTransferStartTime) > 0f)
		{
			return;
		}
		if (!HasLiquidItem())
		{
			((FacepunchBehaviour)this).CancelInvoke(pushLiquidAction);
			return;
		}
		Item liquidItem = GetLiquidItem();
		if (pushTargets.Count > 0)
		{
			int num = Mathf.Clamp(autofillTickAmount, 0, liquidItem.amount) / pushTargets.Count;
			if (num == 0 && liquidItem.amount > 0)
			{
				num = liquidItem.amount;
			}
			if (Server.waterContainersLeaveWaterBehind && num == liquidItem.amount)
			{
				num--;
			}
			if (num == 0)
			{
				return;
			}
			foreach (ContainerIOEntity pushTarget in pushTargets)
			{
				if (pushTarget.inventory == null)
				{
					if (!((FacepunchBehaviour)this).IsInvoking(updatePushLiquidTargetsAction))
					{
						((FacepunchBehaviour)this).Invoke(updatePushLiquidTargetsAction, 0.1f);
					}
				}
				else if (pushTarget.inventory.CanAcceptItem(liquidItem, 0) == ItemContainer.CanAcceptResult.CanAccept && (pushTarget.inventory.CanAccept(liquidItem) || pushTarget.inventory.FindItemByItemID(liquidItem.info.itemid) != null))
				{
					int num2 = Mathf.Clamp(num, 0, pushTarget.inventory.GetMaxTransferAmount(liquidItem.info));
					pushTarget.inventory.AddItem(liquidItem.info, num2, 0uL);
					liquidItem.amount -= num2;
					liquidItem.MarkDirty();
					if (liquidItem.amount <= 0)
					{
						break;
					}
				}
			}
		}
		if (liquidItem.amount <= 0 || pushTargets.Count == 0)
		{
			if (liquidItem.amount <= 0)
			{
				liquidItem.Remove();
			}
			((FacepunchBehaviour)this).CancelInvoke(pushLiquidAction);
		}
	}

	private void CheckPushLiquid(IOEntity connected, Item ourFuel, IOEntity fromSource, int depth, HashSet<IOEntity> checkEntities)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		if (depth <= 0 || ourFuel.amount <= 0)
		{
			return;
		}
		Vector3 worldHandlePosition = Vector3.zero;
		IOEntity iOEntity = connected.FindGravitySource(ref worldHandlePosition, IOEntity.backtracking * 2, ignoreSelf: true);
		if (((Object)(object)iOEntity != (Object)null && !connected.AllowLiquidPassthrough(iOEntity, worldHandlePosition)) || (Object)(object)connected == (Object)(object)this || ConsiderConnectedTo(connected))
		{
			return;
		}
		if (connected is ContainerIOEntity containerIOEntity && !pushTargets.Contains(containerIOEntity) && containerIOEntity.inventory.CanAcceptItem(ourFuel, 0) == ItemContainer.CanAcceptResult.CanAccept)
		{
			pushTargets.Add(containerIOEntity);
			return;
		}
		IOSlot[] array = connected.outputs;
		foreach (IOSlot iOSlot in array)
		{
			IOEntity iOEntity2 = iOSlot.connectedTo.Get();
			if (!((Object)(object)iOEntity2 != (Object)null) || !((Object)(object)iOEntity2 != (Object)(object)fromSource) || !checkEntities.Add(iOEntity2))
			{
				continue;
			}
			Vector3 sourceWorldPosition = ((Component)connected).transform.TransformPoint(iOSlot.handlePosition);
			if (iOEntity2.AllowLiquidPassthrough(fromSource, sourceWorldPosition))
			{
				CheckPushLiquid(iOEntity2, ourFuel, fromSource, depth - 1, checkEntities);
				if (pushTargets.Count >= 12)
				{
					break;
				}
			}
		}
	}

	public void SetConnectedTo(IOEntity entity)
	{
		considerConnectedTo = entity;
	}

	protected override bool ConsiderConnectedTo(IOEntity entity)
	{
		return (Object)(object)entity == (Object)(object)considerConnectedTo;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class LiquidVessel : HeldEntity
{
	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("LiquidVessel.OnRpcMessage", 0);
		try
		{
			if (rpc == 4034725537u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoEmpty "));
				}
				TimeWarning val2 = TimeWarning.New("DoEmpty", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(4034725537u, "DoEmpty", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoEmpty(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoEmpty");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool CanDrink()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return false;
		}
		if (!ownerPlayer.metabolism.CanConsume())
		{
			return false;
		}
		Item item = GetItem();
		if (item == null)
		{
			return false;
		}
		if (item.contents == null)
		{
			return false;
		}
		if (item.contents.itemList == null)
		{
			return false;
		}
		if (item.contents.itemList.Count == 0)
		{
			return false;
		}
		return true;
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoEmpty(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		Item item = GetItem();
		if (item == null || item.contents == null || !msg.player.metabolism.CanConsume())
		{
			return;
		}
		using List<Item>.Enumerator enumerator = item.contents.itemList.GetEnumerator();
		if (enumerator.MoveNext())
		{
			enumerator.Current.UseItem(50);
		}
	}

	public void AddLiquid(ItemDefinition liquidType, int amount)
	{
		if (amount <= 0)
		{
			return;
		}
		Item item = GetItem();
		Item item2 = item.contents.GetSlot(0);
		ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
		if (item2 == null)
		{
			ItemManager.Create(liquidType, amount, 0uL)?.MoveToContainer(item.contents);
			return;
		}
		int num = Mathf.Clamp(item2.amount + amount, 0, component.maxStackSize);
		ItemDefinition itemDefinition = WaterResource.Merge(item2.info, liquidType);
		if ((Object)(object)itemDefinition != (Object)(object)item2.info)
		{
			item2.Remove();
			item2 = ItemManager.Create(itemDefinition, num, 0uL);
			item2.MoveToContainer(item.contents);
		}
		else
		{
			item2.amount = num;
		}
		item2.MarkDirty();
		SendNetworkUpdateImmediate();
	}

	public bool CanFillHere(Vector3 pos)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return false;
		}
		if ((double)ownerPlayer.WaterFactor() > 0.05)
		{
			return true;
		}
		return false;
	}

	public int AmountHeld()
	{
		return GetItem().contents.GetSlot(0)?.amount ?? 0;
	}

	public float HeldFraction()
	{
		return (float)AmountHeld() / (float)MaxHoldable();
	}

	public bool IsFull()
	{
		return HeldFraction() >= 1f;
	}

	public int MaxHoldable()
	{
		return ((Component)GetItem().info).GetComponent<ItemModContainer>().maxStackSize;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class LiquidWeapon : BaseLiquidVessel
{
	[Header("Liquid Weapon")]
	public float FireRate = 0.2f;

	public float MaxRange = 10f;

	public int FireAmountML = 100;

	public int MaxPressure = 100;

	public int PressureLossPerTick = 5;

	public int PressureGainedPerPump = 25;

	public float MinDmgRadius = 0.15f;

	public float MaxDmgRadius = 0.15f;

	public float SplashRadius = 2f;

	public GameObjectRef ImpactSplashEffect;

	public AnimationCurve PowerCurve;

	public List<DamageTypeEntry> Damage;

	public LiquidWeaponEffects EntityWeaponEffects;

	public bool RequiresPumping;

	public bool AutoPump;

	public bool WaitForFillAnim;

	public bool UseFalloffCurve;

	public AnimationCurve FalloffCurve;

	public float PumpingBlockDuration = 0.5f;

	public float StartFillingBlockDuration = 2f;

	public float StopFillingBlockDuration = 1f;

	public float cooldownTime;

	public bool HoldFireInput;

	public int pressure;

	public const string RadiationFightAchievement = "SUMMER_RADICAL";

	public const string SoakedAchievement = "SUMMER_SOAKED";

	public const string LiquidatorAchievement = "SUMMER_LIQUIDATOR";

	public const string NoPressureAchievement = "SUMMER_NO_PRESSURE";

	public float PressureFraction => (float)pressure / (float)MaxPressure;

	public float MinimumPressureFraction => (float)PressureGainedPerPump / (float)MaxPressure;

	public float CurrentRange
	{
		get
		{
			if (!UseFalloffCurve)
			{
				return MaxRange;
			}
			return MaxRange * FalloffCurve.Evaluate((float)(MaxPressure - pressure) / (float)MaxPressure);
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("LiquidWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 1600824953 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - PumpWater "));
				}
				TimeWarning val2 = TimeWarning.New("PumpWater", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1600824953u, "PumpWater", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							PumpWater(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in PumpWater");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3724096303u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartFiring "));
				}
				TimeWarning val2 = TimeWarning.New("StartFiring", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3724096303u, "StartFiring", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							StartFiring(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in StartFiring");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 789289044 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StopFiring "));
				}
				TimeWarning val2 = TimeWarning.New("StopFiring", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(789289044u, "StopFiring", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							StopFiring();
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in StopFiring");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void StartFiring(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (OnCooldown())
		{
			return;
		}
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		if (CanFire(player))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FireTick);
			((FacepunchBehaviour)this).InvokeRepeating((Action)FireTick, 0f, FireRate);
			SetFlag(Flags.On, b: true);
			StartCooldown(FireRate);
			if (base.isServer)
			{
				SendNetworkUpdateImmediate();
			}
			Interface.CallHook("OnLiquidWeaponFired", (object)this, (object)player);
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void StopFiring()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)FireTick);
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		SetFlag(Flags.On, b: false);
		if (base.isServer)
		{
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnLiquidWeaponFiringStopped", (object)this);
	}

	private bool CanFire(BasePlayer player)
	{
		object obj = Interface.CallHook("CanFireLiquidWeapon", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequiresPumping && pressure < PressureLossPerTick)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (HasFlag(Flags.Open))
		{
			return false;
		}
		if (AmountHeld() <= 0)
		{
			return false;
		}
		if (!player.CanInteract())
		{
			return false;
		}
		if (!player.CanAttack() || player.IsRunning())
		{
			return false;
		}
		Item item = GetItem();
		if (item == null || item.contents == null)
		{
			return false;
		}
		return true;
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void PumpWater(RPCMessage msg)
	{
		PumpWater();
	}

	private void PumpWater()
	{
		if (!((Object)(object)GetOwnerPlayer() == (Object)null) && !OnCooldown() && !Firing())
		{
			pressure += PressureGainedPerPump;
			pressure = Mathf.Min(pressure, MaxPressure);
			StartCooldown(PumpingBlockDuration);
			GetOwnerPlayer().SignalBroadcast(Signal.Reload);
			SendNetworkUpdateImmediate();
		}
	}

	private void FireTick()
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!CanFire(ownerPlayer))
		{
			StopFiring();
			return;
		}
		int num = Mathf.Min(FireAmountML, AmountHeld());
		if (num == 0)
		{
			StopFiring();
			return;
		}
		float currentRange = CurrentRange;
		pressure -= PressureLossPerTick;
		if (pressure <= 0)
		{
			StopFiring();
		}
		Ray val = ownerPlayer.eyes.BodyRay();
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val, ref val2, currentRange, 1218652417))
		{
			DoSplash(ownerPlayer, ((RaycastHit)(ref val2)).point, ((Ray)(ref val)).direction, num);
		}
		LoseWater(num);
		SendNetworkUpdate();
	}

	private void DoSplash(BasePlayer attacker, Vector3 position, Vector3 direction, int amount)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		Item contents = GetContents();
		if (contents != null && contents.amount > 0 && !((Object)(object)contents.info == (Object)null))
		{
			WaterBall.DoSplash(position, SplashRadius, contents.info, amount, funWater: true);
			DamageUtil.RadiusDamage(attacker, LookupPrefab(), position, MinDmgRadius, MaxDmgRadius, Damage, 131072, useLineOfSight: true);
		}
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		StopFiring();
	}

	private void StartCooldown(float duration)
	{
		if (Time.realtimeSinceStartup + duration > cooldownTime)
		{
			cooldownTime = Time.realtimeSinceStartup + duration;
		}
	}

	private bool OnCooldown()
	{
		return Time.realtimeSinceStartup < cooldownTime;
	}

	private bool Firing()
	{
		return HasFlag(Flags.On);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseProjectile = Pool.Get<BaseProjectile>();
		info.msg.baseProjectile.primaryMagazine = Pool.Get<Magazine>();
		info.msg.baseProjectile.primaryMagazine.contents = pressure;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.baseProjectile != null && info.msg.baseProjectile.primaryMagazine != null)
		{
			pressure = info.msg.baseProjectile.primaryMagazine.contents;
		}
	}
}


