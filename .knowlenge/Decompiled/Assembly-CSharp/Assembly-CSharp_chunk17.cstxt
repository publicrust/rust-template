private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using VLB;

[AddComponentMenu("")]
[ExecuteInEditMode]
[HelpURL("http://saladgamer.com/vlb-doc/comp-lightbeam/")]
public class BeamGeometry : MonoBehaviour
{
	private VolumetricLightBeam m_Master;

	private Matrix4x4 m_ColorGradientMatrix;

	private MeshType m_CurrentMeshType;

	public MeshRenderer meshRenderer { get; private set; }

	public MeshFilter meshFilter { get; private set; }

	public Material material { get; private set; }

	public Mesh coneMesh { get; private set; }

	public bool visible
	{
		get
		{
			return ((Renderer)meshRenderer).enabled;
		}
		set
		{
			((Renderer)meshRenderer).enabled = value;
		}
	}

	public int sortingLayerID
	{
		get
		{
			return ((Renderer)meshRenderer).sortingLayerID;
		}
		set
		{
			((Renderer)meshRenderer).sortingLayerID = value;
		}
	}

	public int sortingOrder
	{
		get
		{
			return ((Renderer)meshRenderer).sortingOrder;
		}
		set
		{
			((Renderer)meshRenderer).sortingOrder = value;
		}
	}

	private void Start()
	{
	}

	private void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)material))
		{
			Object.DestroyImmediate((Object)(object)material);
			material = null;
		}
	}

	private static bool IsUsingCustomRenderPipeline()
	{
		if (RenderPipelineManager.currentPipeline == null)
		{
			return (Object)(object)GraphicsSettings.renderPipelineAsset != (Object)null;
		}
		return true;
	}

	private void OnEnable()
	{
		if (IsUsingCustomRenderPipeline())
		{
			RenderPipelineManager.beginCameraRendering += OnBeginCameraRendering;
		}
	}

	private void OnDisable()
	{
		if (IsUsingCustomRenderPipeline())
		{
			RenderPipelineManager.beginCameraRendering -= OnBeginCameraRendering;
		}
	}

	public void Initialize(VolumetricLightBeam master, Shader shader)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Expected O, but got Unknown
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		HideFlags proceduralObjectsHideFlags = Consts.ProceduralObjectsHideFlags;
		m_Master = master;
		((Component)this).transform.SetParent(((Component)master).transform, false);
		material = new Material(shader);
		((Object)material).hideFlags = proceduralObjectsHideFlags;
		meshRenderer = ((Component)this).gameObject.GetOrAddComponent<MeshRenderer>();
		((Object)meshRenderer).hideFlags = proceduralObjectsHideFlags;
		((Renderer)meshRenderer).material = material;
		((Renderer)meshRenderer).shadowCastingMode = (ShadowCastingMode)0;
		((Renderer)meshRenderer).receiveShadows = false;
		((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)0;
		if (SortingLayer.IsValid(m_Master.sortingLayerID))
		{
			sortingLayerID = m_Master.sortingLayerID;
		}
		else
		{
			Debug.LogError((object)$"Beam '{Utils.GetPath(((Component)m_Master).transform)}' has an invalid sortingLayerID ({m_Master.sortingLayerID}). Please fix it by setting a valid layer.");
		}
		sortingOrder = m_Master.sortingOrder;
		meshFilter = ((Component)this).gameObject.GetOrAddComponent<MeshFilter>();
		((Object)meshFilter).hideFlags = proceduralObjectsHideFlags;
		((Object)((Component)this).gameObject).hideFlags = proceduralObjectsHideFlags;
	}

	public void RegenerateMesh()
	{
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		Debug.Assert(Object.op_Implicit((Object)(object)m_Master));
		((Component)this).gameObject.layer = Config.Instance.geometryLayerID;
		((Component)this).gameObject.tag = Config.Instance.geometryTag;
		if (Object.op_Implicit((Object)(object)coneMesh) && m_CurrentMeshType == MeshType.Custom)
		{
			Object.DestroyImmediate((Object)(object)coneMesh);
		}
		m_CurrentMeshType = m_Master.geomMeshType;
		switch (m_Master.geomMeshType)
		{
		case MeshType.Custom:
			coneMesh = MeshGenerator.GenerateConeZ_Radius(1f, 1f, 1f, m_Master.geomCustomSides, m_Master.geomCustomSegments, m_Master.geomCap);
			((Object)coneMesh).hideFlags = Consts.ProceduralObjectsHideFlags;
			meshFilter.mesh = coneMesh;
			break;
		case MeshType.Shared:
			coneMesh = GlobalMesh.mesh;
			meshFilter.sharedMesh = coneMesh;
			break;
		default:
			Debug.LogError((object)"Unsupported MeshType");
			break;
		}
		UpdateMaterialAndBounds();
	}

	private void ComputeLocalMatrix()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Max(m_Master.coneRadiusStart, m_Master.coneRadiusEnd);
		((Component)this).transform.localScale = new Vector3(num, num, m_Master.fadeEnd);
	}

	public void UpdateMaterialAndBounds()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		Debug.Assert(Object.op_Implicit((Object)(object)m_Master));
		material.renderQueue = Config.Instance.geometryRenderQueue;
		float num = m_Master.coneAngle * (MathF.PI / 180f) / 2f;
		material.SetVector("_ConeSlopeCosSin", Vector4.op_Implicit(new Vector2(Mathf.Cos(num), Mathf.Sin(num))));
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(Mathf.Max(m_Master.coneRadiusStart, 0.0001f), Mathf.Max(m_Master.coneRadiusEnd, 0.0001f));
		material.SetVector("_ConeRadius", Vector4.op_Implicit(val));
		float num2 = Mathf.Sign(m_Master.coneApexOffsetZ) * Mathf.Max(Mathf.Abs(m_Master.coneApexOffsetZ), 0.0001f);
		material.SetFloat("_ConeApexOffsetZ", num2);
		if (m_Master.colorMode == ColorMode.Gradient)
		{
			Utils.FloatPackingPrecision floatPackingPrecision = Utils.GetFloatPackingPrecision();
			material.EnableKeyword((floatPackingPrecision == Utils.FloatPackingPrecision.High) ? "VLB_COLOR_GRADIENT_MATRIX_HIGH" : "VLB_COLOR_GRADIENT_MATRIX_LOW");
			m_ColorGradientMatrix = m_Master.colorGradient.SampleInMatrix((int)floatPackingPrecision);
		}
		else
		{
			material.DisableKeyword("VLB_COLOR_GRADIENT_MATRIX_HIGH");
			material.DisableKeyword("VLB_COLOR_GRADIENT_MATRIX_LOW");
			material.SetColor("_ColorFlat", m_Master.color);
		}
		if (Consts.BlendingMode_AlphaAsBlack[m_Master.blendingModeAsInt])
		{
			material.EnableKeyword("ALPHA_AS_BLACK");
		}
		else
		{
			material.DisableKeyword("ALPHA_AS_BLACK");
		}
		material.SetInt("_BlendSrcFactor", (int)Consts.BlendingMode_SrcFactor[m_Master.blendingModeAsInt]);
		material.SetInt("_BlendDstFactor", (int)Consts.BlendingMode_DstFactor[m_Master.blendingModeAsInt]);
		material.SetFloat("_AlphaInside", m_Master.alphaInside);
		material.SetFloat("_AlphaOutside", m_Master.alphaOutside);
		material.SetFloat("_AttenuationLerpLinearQuad", m_Master.attenuationLerpLinearQuad);
		material.SetFloat("_DistanceFadeStart", m_Master.fadeStart);
		material.SetFloat("_DistanceFadeEnd", m_Master.fadeEnd);
		material.SetFloat("_DistanceCamClipping", m_Master.cameraClippingDistance);
		material.SetFloat("_FresnelPow", Mathf.Max(0.001f, m_Master.fresnelPow));
		material.SetFloat("_GlareBehind", m_Master.glareBehind);
		material.SetFloat("_GlareFrontal", m_Master.glareFrontal);
		material.SetFloat("_DrawCap", (float)(m_Master.geomCap ? 1 : 0));
		if (m_Master.depthBlendDistance > 0f)
		{
			material.EnableKeyword("VLB_DEPTH_BLEND");
			material.SetFloat("_DepthBlendDistance", m_Master.depthBlendDistance);
		}
		else
		{
			material.DisableKeyword("VLB_DEPTH_BLEND");
		}
		if (m_Master.noiseEnabled && m_Master.noiseIntensity > 0f && Noise3D.isSupported)
		{
			Noise3D.LoadIfNeeded();
			material.EnableKeyword("VLB_NOISE_3D");
			material.SetVector("_NoiseLocal", new Vector4(m_Master.noiseVelocityLocal.x, m_Master.noiseVelocityLocal.y, m_Master.noiseVelocityLocal.z, m_Master.noiseScaleLocal));
			material.SetVector("_NoiseParam", Vector4.op_Implicit(new Vector3(m_Master.noiseIntensity, m_Master.noiseVelocityUseGlobal ? 1f : 0f, m_Master.noiseScaleUseGlobal ? 1f : 0f)));
		}
		else
		{
			material.DisableKeyword("VLB_NOISE_3D");
		}
		ComputeLocalMatrix();
	}

	public void SetClippingPlane(Plane planeWS)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((Plane)(ref planeWS)).normal;
		material.EnableKeyword("VLB_CLIPPING_PLANE");
		material.SetVector("_ClippingPlaneWS", new Vector4(normal.x, normal.y, normal.z, ((Plane)(ref planeWS)).distance));
	}

	public void SetClippingPlaneOff()
	{
		material.DisableKeyword("VLB_CLIPPING_PLANE");
	}

	private void OnBeginCameraRendering(ScriptableRenderContext context, Camera cam)
	{
		UpdateCameraRelatedProperties(cam);
	}

	private void OnWillRenderObject()
	{
		if (!IsUsingCustomRenderPipeline())
		{
			Camera current = Camera.current;
			if ((Object)(object)current != (Object)null)
			{
				UpdateCameraRelatedProperties(current);
			}
		}
	}

	private void UpdateCameraRelatedProperties(Camera cam)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)cam) || !Object.op_Implicit((Object)(object)m_Master))
		{
			return;
		}
		if (Object.op_Implicit((Object)(object)material))
		{
			Vector3 val = ((Component)m_Master).transform.InverseTransformPoint(((Component)cam).transform.position);
			material.SetVector("_CameraPosObjectSpace", Vector4.op_Implicit(val));
			Vector3 val2 = ((Component)this).transform.InverseTransformDirection(((Component)cam).transform.forward);
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			float num = (cam.orthographic ? (-1f) : m_Master.GetInsideBeamFactorFromObjectSpacePos(val));
			material.SetVector("_CameraParams", new Vector4(normalized.x, normalized.y, normalized.z, num));
			if (m_Master.colorMode == ColorMode.Gradient)
			{
				material.SetMatrix("_ColorGradientMatrix", m_ColorGradientMatrix);
			}
		}
		if (m_Master.depthBlendDistance > 0f)
		{
			cam.depthTextureMode = (DepthTextureMode)(cam.depthTextureMode | 1);
		}
	}
}


using UnityEngine;
using UnityEngine.Serialization;
using VLB;

[HelpURL("http://saladgamer.com/vlb-doc/config/")]
public class Config : ScriptableObject
{
	public int geometryLayerID = 1;

	public string geometryTag = "Untagged";

	public int geometryRenderQueue = 3000;

	public bool forceSinglePass;

	[HighlightNull]
	[SerializeField]
	private Shader beamShader1Pass;

	[HighlightNull]
	[FormerlySerializedAs("BeamShader")]
	[SerializeField]
	[FormerlySerializedAs("beamShader")]
	private Shader beamShader2Pass;

	public int sharedMeshSides = 24;

	public int sharedMeshSegments = 5;

	[Range(0.01f, 2f)]
	public float globalNoiseScale = 0.5f;

	public Vector3 globalNoiseVelocity = Consts.NoiseVelocityDefault;

	[HighlightNull]
	public TextAsset noise3DData;

	public int noise3DSize = 64;

	[HighlightNull]
	public ParticleSystem dustParticlesPrefab;

	private static Config m_Instance;

	public Shader beamShader
	{
		get
		{
			if (!forceSinglePass)
			{
				return beamShader2Pass;
			}
			return beamShader1Pass;
		}
	}

	public Vector4 globalNoiseParam => new Vector4(globalNoiseVelocity.x, globalNoiseVelocity.y, globalNoiseVelocity.z, globalNoiseScale);

	public static Config Instance
	{
		get
		{
			if ((Object)(object)m_Instance == (Object)null)
			{
				Config[] array = Resources.LoadAll<Config>("Config");
				Debug.Assert(array.Length != 0, $"Can't find any resource of type '{typeof(Config)}'. Make sure you have a ScriptableObject of this type in a 'Resources' folder.");
				m_Instance = array[0];
			}
			return m_Instance;
		}
	}

	public void Reset()
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		geometryLayerID = 1;
		geometryTag = "Untagged";
		geometryRenderQueue = 3000;
		beamShader1Pass = Shader.Find("Hidden/VolumetricLightBeam1Pass");
		beamShader2Pass = Shader.Find("Hidden/VolumetricLightBeam2Pass");
		sharedMeshSides = 24;
		sharedMeshSegments = 5;
		globalNoiseScale = 0.5f;
		globalNoiseVelocity = Consts.NoiseVelocityDefault;
		ref TextAsset reference = ref noise3DData;
		Object obj = Resources.Load("Noise3D_64x64x64");
		reference = (TextAsset)(object)((obj is TextAsset) ? obj : null);
		noise3DSize = 64;
		ref ParticleSystem reference2 = ref dustParticlesPrefab;
		Object obj2 = Resources.Load("DustParticles", typeof(ParticleSystem));
		reference2 = (ParticleSystem)(object)((obj2 is ParticleSystem) ? obj2 : null);
	}

	public ParticleSystem NewVolumetricDustParticles()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)dustParticlesPrefab))
		{
			if (Application.isPlaying)
			{
				Debug.LogError((object)"Failed to instantiate VolumetricDustParticles prefab.");
			}
			return null;
		}
		ParticleSystem obj = Object.Instantiate<ParticleSystem>(dustParticlesPrefab);
		obj.useAutoRandomSeed = false;
		((Object)obj).name = "Dust Particles";
		((Object)((Component)obj).gameObject).hideFlags = Consts.ProceduralObjectsHideFlags;
		((Component)obj).gameObject.SetActive(true);
		return obj;
	}
}


using System;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Rendering;
using VLB;

public static class Consts
{
	private const string HelpUrlBase = "http://saladgamer.com/vlb-doc/";

	public const string HelpUrlBeam = "http://saladgamer.com/vlb-doc/comp-lightbeam/";

	public const string HelpUrlDustParticles = "http://saladgamer.com/vlb-doc/comp-dustparticles/";

	public const string HelpUrlDynamicOcclusion = "http://saladgamer.com/vlb-doc/comp-dynocclusion/";

	public const string HelpUrlTriggerZone = "http://saladgamer.com/vlb-doc/comp-triggerzone/";

	public const string HelpUrlConfig = "http://saladgamer.com/vlb-doc/config/";

	public static readonly bool ProceduralObjectsVisibleInEditor = true;

	public static readonly Color FlatColor = Color.white;

	public const ColorMode ColorModeDefault = ColorMode.Flat;

	public const float Alpha = 1f;

	public const float SpotAngleDefault = 35f;

	public const float SpotAngleMin = 0.1f;

	public const float SpotAngleMax = 179.9f;

	public const float ConeRadiusStart = 0.1f;

	public const MeshType GeomMeshType = MeshType.Shared;

	public const int GeomSidesDefault = 18;

	public const int GeomSidesMin = 3;

	public const int GeomSidesMax = 256;

	public const int GeomSegmentsDefault = 5;

	public const int GeomSegmentsMin = 0;

	public const int GeomSegmentsMax = 64;

	public const bool GeomCap = false;

	public const AttenuationEquation AttenuationEquationDefault = AttenuationEquation.Quadratic;

	public const float AttenuationCustomBlending = 0.5f;

	public const float FadeStart = 0f;

	public const float FadeEnd = 3f;

	public const float FadeMinThreshold = 0.01f;

	public const float DepthBlendDistance = 2f;

	public const float CameraClippingDistance = 0.5f;

	public const float FresnelPowMaxValue = 10f;

	public const float FresnelPow = 8f;

	public const float GlareFrontal = 0.5f;

	public const float GlareBehind = 0.5f;

	public const float NoiseIntensityMin = 0f;

	public const float NoiseIntensityMax = 1f;

	public const float NoiseIntensityDefault = 0.5f;

	public const float NoiseScaleMin = 0.01f;

	public const float NoiseScaleMax = 2f;

	public const float NoiseScaleDefault = 0.5f;

	public static readonly Vector3 NoiseVelocityDefault = new Vector3(0.07f, 0.18f, 0.05f);

	public const BlendingMode BlendingModeDefault = BlendingMode.Additive;

	public static readonly BlendMode[] BlendingMode_SrcFactor;

	public static readonly BlendMode[] BlendingMode_DstFactor;

	public static readonly bool[] BlendingMode_AlphaAsBlack;

	public const float DynOcclusionMinSurfaceRatioDefault = 0.5f;

	public const float DynOcclusionMinSurfaceRatioMin = 50f;

	public const float DynOcclusionMinSurfaceRatioMax = 100f;

	public const float DynOcclusionMaxSurfaceDotDefault = 0.25f;

	public const float DynOcclusionMaxSurfaceAngleMin = 45f;

	public const float DynOcclusionMaxSurfaceAngleMax = 90f;

	public const int ConfigGeometryLayerIDDefault = 1;

	public const string ConfigGeometryTagDefault = "Untagged";

	public const RenderQueue ConfigGeometryRenderQueueDefault = RenderQueue.Transparent;

	public const bool ConfigGeometryForceSinglePassDefault = false;

	public const int ConfigNoise3DSizeDefault = 64;

	public const int ConfigSharedMeshSides = 24;

	public const int ConfigSharedMeshSegments = 5;

	public static HideFlags ProceduralObjectsHideFlags
	{
		get
		{
			if (ProceduralObjectsVisibleInEditor)
			{
				return (HideFlags)60;
			}
			return (HideFlags)61;
		}
	}

	static Consts()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		BlendMode[] array = new BlendMode[3];
		RuntimeHelpers.InitializeArray(array, (RuntimeFieldHandle)/*OpCode not supported: LdMemberToken*/);
		BlendingMode_SrcFactor = (BlendMode[])(object)array;
		BlendMode[] array2 = new BlendMode[3];
		RuntimeHelpers.InitializeArray(array2, (RuntimeFieldHandle)/*OpCode not supported: LdMemberToken*/);
		BlendingMode_DstFactor = (BlendMode[])(object)array2;
		BlendingMode_AlphaAsBlack = new bool[3] { true, true, false };
	}
}


using System;
using UnityEngine;
using VLB;

[HelpURL("http://saladgamer.com/vlb-doc/comp-dynocclusion/")]
[RequireComponent(typeof(VolumetricLightBeam))]
[DisallowMultipleComponent]
[ExecuteInEditMode]
public class DynamicOcclusion : MonoBehaviour
{
	private enum Direction
	{
		Up,
		Right,
		Down,
		Left
	}

	public LayerMask layerMask = LayerMask.op_Implicit(-1);

	public float minOccluderArea;

	public int waitFrameCount = 3;

	public float minSurfaceRatio = 0.5f;

	public float maxSurfaceDot = 0.25f;

	public PlaneAlignment planeAlignment;

	public float planeOffset = 0.1f;

	private VolumetricLightBeam m_Master;

	private int m_FrameCountToWait;

	private float m_RangeMultiplier = 1f;

	private uint m_PrevNonSubHitDirectionId;

	private void OnValidate()
	{
		minOccluderArea = Mathf.Max(minOccluderArea, 0f);
		waitFrameCount = Mathf.Clamp(waitFrameCount, 1, 60);
	}

	private void OnEnable()
	{
		m_Master = ((Component)this).GetComponent<VolumetricLightBeam>();
		Debug.Assert(Object.op_Implicit((Object)(object)m_Master));
	}

	private void OnDisable()
	{
		SetHitNull();
	}

	private void Start()
	{
		if (Application.isPlaying)
		{
			TriggerZone component = ((Component)this).GetComponent<TriggerZone>();
			if (Object.op_Implicit((Object)(object)component))
			{
				m_RangeMultiplier = Mathf.Max(1f, component.rangeMultiplier);
			}
		}
	}

	private void LateUpdate()
	{
		if (m_FrameCountToWait <= 0)
		{
			ProcessRaycasts();
			m_FrameCountToWait = waitFrameCount;
		}
		m_FrameCountToWait--;
	}

	private Vector3 GetRandomVectorAround(Vector3 direction, float angleDiff)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		float num = angleDiff * 0.5f;
		return Quaternion.Euler(Random.Range(0f - num, num), Random.Range(0f - num, num), Random.Range(0f - num, num)) * direction;
	}

	private RaycastHit GetBestHit(Vector3 rayPos, Vector3 rayDir)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit[] array = Physics.RaycastAll(rayPos, rayDir, m_Master.fadeEnd * m_RangeMultiplier, ((LayerMask)(ref layerMask)).value);
		int num = -1;
		float num2 = float.MaxValue;
		for (int i = 0; i < array.Length; i++)
		{
			if (!((RaycastHit)(ref array[i])).collider.isTrigger && ((RaycastHit)(ref array[i])).collider.bounds.GetMaxArea2D() >= minOccluderArea && ((RaycastHit)(ref array[i])).distance < num2)
			{
				num2 = ((RaycastHit)(ref array[i])).distance;
				num = i;
			}
		}
		if (num != -1)
		{
			return array[num];
		}
		return default(RaycastHit);
	}

	private Vector3 GetDirection(uint dirInt)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		dirInt %= (uint)Enum.GetValues(typeof(Direction)).Length;
		return (Vector3)(dirInt switch
		{
			0u => ((Component)this).transform.up, 
			1u => ((Component)this).transform.right, 
			2u => -((Component)this).transform.up, 
			3u => -((Component)this).transform.right, 
			_ => Vector3.zero, 
		});
	}

	private bool IsHitValid(RaycastHit hit)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)((RaycastHit)(ref hit)).collider))
		{
			return Vector3.Dot(((RaycastHit)(ref hit)).normal, -((Component)this).transform.forward) >= maxSurfaceDot;
		}
		return false;
	}

	private void ProcessRaycasts()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit hit = GetBestHit(((Component)this).transform.position, ((Component)this).transform.forward);
		if (IsHitValid(hit))
		{
			if (minSurfaceRatio > 0.5f)
			{
				for (uint num = 0u; num < (uint)Enum.GetValues(typeof(Direction)).Length; num++)
				{
					Vector3 direction = GetDirection(num + m_PrevNonSubHitDirectionId);
					Vector3 val = ((Component)this).transform.position + direction * m_Master.coneRadiusStart * (minSurfaceRatio * 2f - 1f);
					Vector3 val2 = ((Component)this).transform.position + ((Component)this).transform.forward * m_Master.fadeEnd + direction * m_Master.coneRadiusEnd * (minSurfaceRatio * 2f - 1f);
					RaycastHit bestHit = GetBestHit(val, val2 - val);
					if (IsHitValid(bestHit))
					{
						if (((RaycastHit)(ref bestHit)).distance > ((RaycastHit)(ref hit)).distance)
						{
							hit = bestHit;
						}
						continue;
					}
					m_PrevNonSubHitDirectionId = num;
					SetHitNull();
					return;
				}
			}
			SetHit(hit);
		}
		else
		{
			SetHitNull();
		}
	}

	private void SetHit(RaycastHit hit)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		PlaneAlignment planeAlignment = this.planeAlignment;
		if (planeAlignment != 0 && planeAlignment == PlaneAlignment.Beam)
		{
			SetClippingPlane(new Plane(-((Component)this).transform.forward, ((RaycastHit)(ref hit)).point));
		}
		else
		{
			SetClippingPlane(new Plane(((RaycastHit)(ref hit)).normal, ((RaycastHit)(ref hit)).point));
		}
	}

	private void SetHitNull()
	{
		SetClippingPlaneOff();
	}

	private void SetClippingPlane(Plane planeWS)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		planeWS = planeWS.TranslateCustom(((Plane)(ref planeWS)).normal * planeOffset);
		m_Master.SetClippingPlane(planeWS);
	}

	private void SetClippingPlaneOff()
	{
		m_Master.SetClippingPlaneOff();
	}
}


private enum Direction
{
	Up,
	Right,
	Down,
	Left
}


public enum ColorMode
{
	Flat,
	Gradient
}


public enum AttenuationEquation
{
	Linear,
	Quadratic,
	Blend
}


public enum BlendingMode
{
	Additive,
	SoftAdditive,
	TraditionalTransparency
}


public enum MeshType
{
	Shared,
	Custom
}


public enum RenderQueue
{
	Custom = 0,
	Background = 1000,
	Geometry = 2000,
	AlphaTest = 2450,
	GeometryLast = 2500,
	Transparent = 3000,
	Overlay = 4000
}


public enum PlaneAlignment
{
	Surface,
	Beam
}


using UnityEngine;
using VLB;

public static class GlobalMesh
{
	private static Mesh ms_Mesh;

	public static Mesh mesh
	{
		get
		{
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)ms_Mesh == (Object)null)
			{
				ms_Mesh = MeshGenerator.GenerateConeZ_Radius(1f, 1f, 1f, Config.Instance.sharedMeshSides, Config.Instance.sharedMeshSegments, cap: true);
				((Object)ms_Mesh).hideFlags = Consts.ProceduralObjectsHideFlags;
			}
			return ms_Mesh;
		}
	}
}


using UnityEngine;

public sealed class HighlightNullAttribute : PropertyAttribute
{
}


using System;
using UnityEngine;
using VLB;

public static class MeshGenerator
{
	private const float kMinTruncatedRadius = 0.001f;

	private static bool duplicateBackFaces => Config.Instance.forceSinglePass;

	public static Mesh GenerateConeZ_RadiusAndAngle(float lengthZ, float radiusStart, float coneAngle, int numSides, int numSegments, bool cap)
	{
		Debug.Assert(lengthZ > 0f);
		Debug.Assert(coneAngle > 0f && coneAngle < 180f);
		float radiusEnd = lengthZ * Mathf.Tan(coneAngle * (MathF.PI / 180f) * 0.5f);
		return GenerateConeZ_Radius(lengthZ, radiusStart, radiusEnd, numSides, numSegments, cap);
	}

	public static Mesh GenerateConeZ_Angle(float lengthZ, float coneAngle, int numSides, int numSegments, bool cap)
	{
		return GenerateConeZ_RadiusAndAngle(lengthZ, 0f, coneAngle, numSides, numSegments, cap);
	}

	public static Mesh GenerateConeZ_Radius(float lengthZ, float radiusStart, float radiusEnd, int numSides, int numSegments, bool cap)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0472: Unknown result type (might be due to invalid IL or missing references)
		//IL_0492: Unknown result type (might be due to invalid IL or missing references)
		//IL_049d: Unknown result type (might be due to invalid IL or missing references)
		Debug.Assert(lengthZ > 0f);
		Debug.Assert(radiusStart >= 0f);
		Debug.Assert(numSides >= 3);
		Debug.Assert(numSegments >= 0);
		Mesh val = new Mesh();
		bool flag = false;
		flag = cap && radiusStart > 0f;
		radiusStart = Mathf.Max(radiusStart, 0.001f);
		int num = numSides * (numSegments + 2);
		int num2 = num;
		if (flag)
		{
			num2 += numSides + 1;
		}
		Vector3[] array = (Vector3[])(object)new Vector3[num2];
		for (int i = 0; i < numSides; i++)
		{
			float num3 = MathF.PI * 2f * (float)i / (float)numSides;
			float num4 = Mathf.Cos(num3);
			float num5 = Mathf.Sin(num3);
			for (int j = 0; j < numSegments + 2; j++)
			{
				float num6 = (float)j / (float)(numSegments + 1);
				Debug.Assert(num6 >= 0f && num6 <= 1f);
				float num7 = Mathf.Lerp(radiusStart, radiusEnd, num6);
				array[i + j * numSides] = new Vector3(num7 * num4, num7 * num5, num6 * lengthZ);
			}
		}
		if (flag)
		{
			int num8 = num;
			array[num8] = Vector3.zero;
			num8++;
			for (int k = 0; k < numSides; k++)
			{
				float num9 = MathF.PI * 2f * (float)k / (float)numSides;
				float num10 = Mathf.Cos(num9);
				float num11 = Mathf.Sin(num9);
				array[num8] = new Vector3(radiusStart * num10, radiusStart * num11, 0f);
				num8++;
			}
			Debug.Assert(num8 == array.Length);
		}
		if (!duplicateBackFaces)
		{
			val.vertices = array;
		}
		else
		{
			Vector3[] array2 = (Vector3[])(object)new Vector3[array.Length * 2];
			array.CopyTo(array2, 0);
			array.CopyTo(array2, array.Length);
			val.vertices = array2;
		}
		Vector2[] array3 = (Vector2[])(object)new Vector2[num2];
		int num12 = 0;
		for (int l = 0; l < num; l++)
		{
			array3[num12++] = Vector2.zero;
		}
		if (flag)
		{
			for (int m = 0; m < numSides + 1; m++)
			{
				array3[num12++] = new Vector2(1f, 0f);
			}
		}
		Debug.Assert(num12 == array3.Length);
		if (!duplicateBackFaces)
		{
			val.uv = array3;
		}
		else
		{
			Vector2[] array4 = (Vector2[])(object)new Vector2[array3.Length * 2];
			array3.CopyTo(array4, 0);
			array3.CopyTo(array4, array3.Length);
			for (int n = 0; n < array3.Length; n++)
			{
				Vector2 val2 = array4[n + array3.Length];
				array4[n + array3.Length] = new Vector2(val2.x, 1f);
			}
			val.uv = array4;
		}
		int num13 = numSides * 2 * Mathf.Max(numSegments + 1, 1) * 3;
		if (flag)
		{
			num13 += numSides * 3;
		}
		int[] array5 = new int[num13];
		int num14 = 0;
		for (int num15 = 0; num15 < numSides; num15++)
		{
			int num16 = num15 + 1;
			if (num16 == numSides)
			{
				num16 = 0;
			}
			for (int num17 = 0; num17 < numSegments + 1; num17++)
			{
				int num18 = num17 * numSides;
				array5[num14++] = num18 + num15;
				array5[num14++] = num18 + num16;
				array5[num14++] = num18 + num15 + numSides;
				array5[num14++] = num18 + num16 + numSides;
				array5[num14++] = num18 + num15 + numSides;
				array5[num14++] = num18 + num16;
			}
		}
		if (flag)
		{
			for (int num19 = 0; num19 < numSides - 1; num19++)
			{
				array5[num14++] = num;
				array5[num14++] = num + num19 + 2;
				array5[num14++] = num + num19 + 1;
			}
			array5[num14++] = num;
			array5[num14++] = num + 1;
			array5[num14++] = num + numSides;
		}
		Debug.Assert(num14 == array5.Length);
		if (!duplicateBackFaces)
		{
			val.triangles = array5;
		}
		else
		{
			int[] array6 = new int[array5.Length * 2];
			array5.CopyTo(array6, 0);
			for (int num20 = 0; num20 < array5.Length; num20 += 3)
			{
				array6[array5.Length + num20] = array5[num20] + num2;
				array6[array5.Length + num20 + 1] = array5[num20 + 2] + num2;
				array6[array5.Length + num20 + 2] = array5[num20 + 1] + num2;
			}
			val.triangles = array6;
		}
		Bounds bounds = default(Bounds);
		((Bounds)(ref bounds))..ctor(new Vector3(0f, 0f, lengthZ * 0.5f), new Vector3(Mathf.Max(radiusStart, radiusEnd) * 2f, Mathf.Max(radiusStart, radiusEnd) * 2f, lengthZ));
		val.bounds = bounds;
		Debug.Assert(val.vertexCount == GetVertexCount(numSides, numSegments, flag));
		Debug.Assert(val.triangles.Length == GetIndicesCount(numSides, numSegments, flag));
		return val;
	}

	public static int GetVertexCount(int numSides, int numSegments, bool geomCap)
	{
		Debug.Assert(numSides >= 2);
		Debug.Assert(numSegments >= 0);
		int num = numSides * (numSegments + 2);
		if (geomCap)
		{
			num += numSides + 1;
		}
		if (duplicateBackFaces)
		{
			num *= 2;
		}
		return num;
	}

	public static int GetIndicesCount(int numSides, int numSegments, bool geomCap)
	{
		Debug.Assert(numSides >= 2);
		Debug.Assert(numSegments >= 0);
		int num = numSides * (numSegments + 1) * 2 * 3;
		if (geomCap)
		{
			num += numSides * 3;
		}
		if (duplicateBackFaces)
		{
			num *= 2;
		}
		return num;
	}

	public static int GetSharedMeshVertexCount()
	{
		return GetVertexCount(Config.Instance.sharedMeshSides, Config.Instance.sharedMeshSegments, geomCap: true);
	}

	public static int GetSharedMeshIndicesCount()
	{
		return GetIndicesCount(Config.Instance.sharedMeshSides, Config.Instance.sharedMeshSegments, geomCap: true);
	}
}


using System;
using UnityEngine;
using VLB;

public static class Noise3D
{
	private static bool ms_IsSupportedChecked;

	private static bool ms_IsSupported;

	private static Texture3D ms_NoiseTexture;

	private const HideFlags kHideFlags = 61;

	private const int kMinShaderLevel = 35;

	public static bool isSupported
	{
		get
		{
			if (!ms_IsSupportedChecked)
			{
				ms_IsSupported = SystemInfo.graphicsShaderLevel >= 35;
				if (!ms_IsSupported)
				{
					Debug.LogWarning((object)isNotSupportedString);
				}
				ms_IsSupportedChecked = true;
			}
			return ms_IsSupported;
		}
	}

	public static bool isProperlyLoaded => (Object)(object)ms_NoiseTexture != (Object)null;

	public static string isNotSupportedString => $"3D Noise requires higher shader capabilities (Shader Model 3.5 / OpenGL ES 3.0), which are not available on the current platform: graphicsShaderLevel (current/required) = {SystemInfo.graphicsShaderLevel} / {35}";

	[RuntimeInitializeOnLoadMethod]
	private static void OnStartUp()
	{
		LoadIfNeeded();
	}

	public static void LoadIfNeeded()
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (!isSupported)
		{
			return;
		}
		if ((Object)(object)ms_NoiseTexture == (Object)null)
		{
			ms_NoiseTexture = LoadTexture3D(Config.Instance.noise3DData, Config.Instance.noise3DSize);
			if (Object.op_Implicit((Object)(object)ms_NoiseTexture))
			{
				((Object)ms_NoiseTexture).hideFlags = (HideFlags)61;
			}
		}
		Shader.SetGlobalTexture("_VLB_NoiseTex3D", (Texture)(object)ms_NoiseTexture);
		Shader.SetGlobalVector("_VLB_NoiseGlobal", Config.Instance.globalNoiseParam);
	}

	private static Texture3D LoadTexture3D(TextAsset textData, int size)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Expected O, but got Unknown
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)textData == (Object)null)
		{
			Debug.LogErrorFormat("Fail to open Noise 3D Data", Array.Empty<object>());
			return null;
		}
		byte[] bytes = textData.bytes;
		Debug.Assert(bytes != null);
		int num = Mathf.Max(0, size * size * size);
		if (bytes.Length != num)
		{
			Debug.LogErrorFormat("Noise 3D Data file has not the proper size {0}x{0}x{0}", new object[1] { size });
			return null;
		}
		Texture3D val = new Texture3D(size, size, size, (TextureFormat)1, false);
		Color[] array = (Color[])(object)new Color[num];
		for (int i = 0; i < num; i++)
		{
			array[i] = Color32.op_Implicit(new Color32((byte)0, (byte)0, (byte)0, bytes[i]));
		}
		val.SetPixels(array);
		val.Apply();
		return val;
	}
}


using UnityEngine;
using VLB;

[DisallowMultipleComponent]
[RequireComponent(typeof(VolumetricLightBeam))]
[HelpURL("http://saladgamer.com/vlb-doc/comp-triggerzone/")]
public class TriggerZone : MonoBehaviour
{
	public bool setIsTrigger = true;

	public float rangeMultiplier = 1f;

	private const int kMeshColliderNumSides = 8;

	private Mesh m_Mesh;

	private void Update()
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		VolumetricLightBeam component = ((Component)this).GetComponent<VolumetricLightBeam>();
		if (Object.op_Implicit((Object)(object)component))
		{
			MeshCollider orAddComponent = ((Component)this).gameObject.GetOrAddComponent<MeshCollider>();
			Debug.Assert(Object.op_Implicit((Object)(object)orAddComponent));
			float lengthZ = component.fadeEnd * rangeMultiplier;
			float radiusEnd = Mathf.LerpUnclamped(component.coneRadiusStart, component.coneRadiusEnd, rangeMultiplier);
			m_Mesh = MeshGenerator.GenerateConeZ_Radius(lengthZ, component.coneRadiusStart, radiusEnd, 8, 0, cap: false);
			((Object)m_Mesh).hideFlags = Consts.ProceduralObjectsHideFlags;
			orAddComponent.sharedMesh = m_Mesh;
			if (setIsTrigger)
			{
				orAddComponent.convex = true;
				((Collider)orAddComponent).isTrigger = true;
			}
			Object.Destroy((Object)(object)this);
		}
	}
}


using System;
using Unity.Mathematics;
using UnityEngine;
using VLB;

public static class Utils
{
	public enum FloatPackingPrecision
	{
		High = 64,
		Low = 8,
		Undef = 0
	}

	private static FloatPackingPrecision ms_FloatPackingPrecision;

	private const int kFloatPackingHighMinShaderLevel = 35;

	public static string GetPath(Transform current)
	{
		if ((Object)(object)current.parent == (Object)null)
		{
			return "/" + ((Object)current).name;
		}
		return GetPath(current.parent) + "/" + ((Object)current).name;
	}

	public static T NewWithComponent<T>(string name) where T : Component
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return new GameObject(name, new Type[1] { typeof(T) }).GetComponent<T>();
	}

	public static T GetOrAddComponent<T>(this GameObject self) where T : Component
	{
		T val = self.GetComponent<T>();
		if ((Object)(object)val == (Object)null)
		{
			val = self.AddComponent<T>();
		}
		return val;
	}

	public static T GetOrAddComponent<T>(this MonoBehaviour self) where T : Component
	{
		return ((Component)self).gameObject.GetOrAddComponent<T>();
	}

	public static bool HasFlag(this Enum mask, Enum flags)
	{
		return ((int)(object)mask & (int)(object)flags) == (int)(object)flags;
	}

	public static Vector2 xy(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.x, aVector.y);
	}

	public static Vector2 xz(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.x, aVector.z);
	}

	public static Vector2 yz(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.y, aVector.z);
	}

	public static Vector2 yx(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.y, aVector.x);
	}

	public static Vector2 zx(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.z, aVector.x);
	}

	public static Vector2 zy(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.z, aVector.y);
	}

	public static float GetVolumeCubic(this Bounds self)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return ((Bounds)(ref self)).size.x * ((Bounds)(ref self)).size.y * ((Bounds)(ref self)).size.z;
	}

	public static float GetMaxArea2D(this Bounds self)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Max(Mathf.Max(((Bounds)(ref self)).size.x * ((Bounds)(ref self)).size.y, ((Bounds)(ref self)).size.y * ((Bounds)(ref self)).size.z), ((Bounds)(ref self)).size.x * ((Bounds)(ref self)).size.z);
	}

	public static Color Opaque(this Color self)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return new Color(self.r, self.g, self.b, 1f);
	}

	public static void GizmosDrawPlane(Vector3 normal, Vector3 position, Color color, float size = 1f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(normal, (Mathf.Abs(Vector3.Dot(normal, Vector3.forward)) < 0.999f) ? Vector3.forward : Vector3.up);
		Vector3 val2 = ((Vector3)(ref val)).normalized * size;
		Vector3 val3 = position + val2;
		Vector3 val4 = position - val2;
		val2 = Quaternion.AngleAxis(90f, normal) * val2;
		Vector3 val5 = position + val2;
		Vector3 val6 = position - val2;
		Gizmos.matrix = Matrix4x4.identity;
		Gizmos.color = color;
		Gizmos.DrawLine(val3, val4);
		Gizmos.DrawLine(val5, val6);
		Gizmos.DrawLine(val3, val5);
		Gizmos.DrawLine(val5, val4);
		Gizmos.DrawLine(val4, val6);
		Gizmos.DrawLine(val6, val3);
	}

	public static Plane TranslateCustom(this Plane plane, Vector3 translation)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		((Plane)(ref plane)).distance = ((Plane)(ref plane)).distance + Vector3.Dot(((Vector3)(ref translation)).normalized, ((Plane)(ref plane)).normal) * ((Vector3)(ref translation)).magnitude;
		return plane;
	}

	public static bool IsValid(this Plane plane)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((Plane)(ref plane)).normal;
		return ((Vector3)(ref normal)).sqrMagnitude > 0.5f;
	}

	public static Matrix4x4 SampleInMatrix(this Gradient self, int floatPackingPrecision)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 result = default(Matrix4x4);
		for (int i = 0; i < 16; i++)
		{
			Color color = self.Evaluate(Mathf.Clamp01((float)i / 15f));
			((Matrix4x4)(ref result))[i] = color.PackToFloat(floatPackingPrecision);
		}
		return result;
	}

	public static Color[] SampleInArray(this Gradient self, int samplesCount)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[samplesCount];
		for (int i = 0; i < samplesCount; i++)
		{
			array[i] = self.Evaluate(Mathf.Clamp01((float)i / (float)(samplesCount - 1)));
		}
		return array;
	}

	private static Vector4 Vector4_Floor(Vector4 vec)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector4(Mathf.Floor(vec.x), Mathf.Floor(vec.y), Mathf.Floor(vec.z), Mathf.Floor(vec.w));
	}

	public static float4 ToFloat4(this Color color)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return new float4(color.r, color.g, color.b, color.a);
	}

	public static float PackToFloat(this Color color, int floatPackingPrecision)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Vector4 val = Vector4_Floor(Color.op_Implicit(color * (float)(floatPackingPrecision - 1)));
		return 0f + val.x * (float)floatPackingPrecision * (float)floatPackingPrecision * (float)floatPackingPrecision + val.y * (float)floatPackingPrecision * (float)floatPackingPrecision + val.z * (float)floatPackingPrecision + val.w;
	}

	public static FloatPackingPrecision GetFloatPackingPrecision()
	{
		if (ms_FloatPackingPrecision == FloatPackingPrecision.Undef)
		{
			ms_FloatPackingPrecision = ((SystemInfo.graphicsShaderLevel >= 35) ? FloatPackingPrecision.High : FloatPackingPrecision.Low);
		}
		return ms_FloatPackingPrecision;
	}

	public static void MarkCurrentSceneDirty()
	{
	}
}


public enum FloatPackingPrecision
{
	High = 64,
	Low = 8,
	Undef = 0
}


public static class Version
{
	public const int Current = 1510;
}


using System;
using UnityEngine;
using VLB;

[ExecuteInEditMode]
[RequireComponent(typeof(VolumetricLightBeam))]
[HelpURL("http://saladgamer.com/vlb-doc/comp-dustparticles/")]
[DisallowMultipleComponent]
public class VolumetricDustParticles : MonoBehaviour
{
	public enum Direction
	{
		Beam,
		Random
	}

	[Range(0f, 1f)]
	public float alpha = 0.5f;

	[Range(0.0001f, 0.1f)]
	public float size = 0.01f;

	public Direction direction = Direction.Random;

	public float speed = 0.03f;

	public float density = 5f;

	[Range(0f, 1f)]
	public float spawnMaxDistance = 0.7f;

	public bool cullingEnabled = true;

	public float cullingMaxDistance = 10f;

	public static bool isFeatureSupported = true;

	private ParticleSystem m_Particles;

	private ParticleSystemRenderer m_Renderer;

	private static bool ms_NoMainCameraLogged = false;

	private static Camera ms_MainCamera = null;

	private VolumetricLightBeam m_Master;

	public bool isCulled { get; private set; }

	public bool particlesAreInstantiated => Object.op_Implicit((Object)(object)m_Particles);

	public int particlesCurrentCount
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)m_Particles))
			{
				return 0;
			}
			return m_Particles.particleCount;
		}
	}

	public int particlesMaxCount
	{
		get
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)m_Particles))
			{
				return 0;
			}
			MainModule main = m_Particles.main;
			return ((MainModule)(ref main)).maxParticles;
		}
	}

	public Camera mainCamera
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)ms_MainCamera))
			{
				ms_MainCamera = Camera.main;
				if (!Object.op_Implicit((Object)(object)ms_MainCamera) && !ms_NoMainCameraLogged)
				{
					Debug.LogErrorFormat((Object)(object)((Component)this).gameObject, "In order to use 'VolumetricDustParticles' culling, you must have a MainCamera defined in your scene.", Array.Empty<object>());
					ms_NoMainCameraLogged = true;
				}
			}
			return ms_MainCamera;
		}
	}

	private void Start()
	{
		isCulled = false;
		m_Master = ((Component)this).GetComponent<VolumetricLightBeam>();
		Debug.Assert(Object.op_Implicit((Object)(object)m_Master));
		InstantiateParticleSystem();
		SetActiveAndPlay();
	}

	private void InstantiateParticleSystem()
	{
		ParticleSystem[] componentsInChildren = ((Component)this).GetComponentsInChildren<ParticleSystem>(true);
		for (int num = componentsInChildren.Length - 1; num >= 0; num--)
		{
			Object.DestroyImmediate((Object)(object)((Component)componentsInChildren[num]).gameObject);
		}
		m_Particles = Config.Instance.NewVolumetricDustParticles();
		if (Object.op_Implicit((Object)(object)m_Particles))
		{
			((Component)m_Particles).transform.SetParent(((Component)this).transform, false);
			m_Renderer = ((Component)m_Particles).GetComponent<ParticleSystemRenderer>();
		}
	}

	private void OnEnable()
	{
		SetActiveAndPlay();
	}

	private void SetActiveAndPlay()
	{
		if (Object.op_Implicit((Object)(object)m_Particles))
		{
			((Component)m_Particles).gameObject.SetActive(true);
			SetParticleProperties();
			m_Particles.Play(true);
		}
	}

	private void OnDisable()
	{
		if (Object.op_Implicit((Object)(object)m_Particles))
		{
			((Component)m_Particles).gameObject.SetActive(false);
		}
	}

	private void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)m_Particles))
		{
			Object.DestroyImmediate((Object)(object)((Component)m_Particles).gameObject);
		}
		m_Particles = null;
	}

	private void Update()
	{
		if (Application.isPlaying)
		{
			UpdateCulling();
		}
		SetParticleProperties();
	}

	private void SetParticleProperties()
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Expected O, but got Unknown
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)m_Particles) || !((Component)m_Particles).gameObject.activeSelf)
		{
			return;
		}
		float num = Mathf.Clamp01(1f - m_Master.fresnelPow / 10f);
		float num2 = m_Master.fadeEnd * spawnMaxDistance;
		float num3 = num2 * density;
		int maxParticles = (int)(num3 * 4f);
		MainModule main = m_Particles.main;
		MinMaxCurve startLifetime = ((MainModule)(ref main)).startLifetime;
		((MinMaxCurve)(ref startLifetime)).mode = (ParticleSystemCurveMode)3;
		((MinMaxCurve)(ref startLifetime)).constantMin = 4f;
		((MinMaxCurve)(ref startLifetime)).constantMax = 6f;
		((MainModule)(ref main)).startLifetime = startLifetime;
		MinMaxCurve startSize = ((MainModule)(ref main)).startSize;
		((MinMaxCurve)(ref startSize)).mode = (ParticleSystemCurveMode)3;
		((MinMaxCurve)(ref startSize)).constantMin = size * 0.9f;
		((MinMaxCurve)(ref startSize)).constantMax = size * 1.1f;
		((MainModule)(ref main)).startSize = startSize;
		MinMaxGradient startColor = ((MainModule)(ref main)).startColor;
		if (m_Master.colorMode == ColorMode.Flat)
		{
			((MinMaxGradient)(ref startColor)).mode = (ParticleSystemGradientMode)0;
			Color color = m_Master.color;
			color.a *= alpha;
			((MinMaxGradient)(ref startColor)).color = color;
		}
		else
		{
			((MinMaxGradient)(ref startColor)).mode = (ParticleSystemGradientMode)1;
			Gradient colorGradient = m_Master.colorGradient;
			GradientColorKey[] colorKeys = colorGradient.colorKeys;
			GradientAlphaKey[] alphaKeys = colorGradient.alphaKeys;
			for (int i = 0; i < alphaKeys.Length; i++)
			{
				alphaKeys[i].alpha *= alpha;
			}
			Gradient val = new Gradient();
			val.SetKeys(colorKeys, alphaKeys);
			((MinMaxGradient)(ref startColor)).gradient = val;
		}
		((MainModule)(ref main)).startColor = startColor;
		MinMaxCurve startSpeed = ((MainModule)(ref main)).startSpeed;
		((MinMaxCurve)(ref startSpeed)).constant = speed;
		((MainModule)(ref main)).startSpeed = startSpeed;
		((MainModule)(ref main)).maxParticles = maxParticles;
		ShapeModule shape = m_Particles.shape;
		((ShapeModule)(ref shape)).shapeType = (ParticleSystemShapeType)8;
		((ShapeModule)(ref shape)).radius = m_Master.coneRadiusStart * Mathf.Lerp(0.3f, 1f, num);
		((ShapeModule)(ref shape)).angle = m_Master.coneAngle * 0.5f * Mathf.Lerp(0.7f, 1f, num);
		((ShapeModule)(ref shape)).length = num2;
		((ShapeModule)(ref shape)).arc = 360f;
		((ShapeModule)(ref shape)).randomDirectionAmount = ((direction == Direction.Random) ? 1f : 0f);
		EmissionModule emission = m_Particles.emission;
		MinMaxCurve rateOverTime = ((EmissionModule)(ref emission)).rateOverTime;
		((MinMaxCurve)(ref rateOverTime)).constant = num3;
		((EmissionModule)(ref emission)).rateOverTime = rateOverTime;
		if (Object.op_Implicit((Object)(object)m_Renderer))
		{
			((Renderer)m_Renderer).sortingLayerID = m_Master.sortingLayerID;
			((Renderer)m_Renderer).sortingOrder = m_Master.sortingOrder;
		}
	}

	private void UpdateCulling()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)m_Particles))
		{
			return;
		}
		bool flag = true;
		if (cullingEnabled && m_Master.hasGeometry)
		{
			if (Object.op_Implicit((Object)(object)mainCamera))
			{
				float num = cullingMaxDistance * cullingMaxDistance;
				Bounds bounds = m_Master.bounds;
				flag = ((Bounds)(ref bounds)).SqrDistance(((Component)mainCamera).transform.position) <= num;
			}
			else
			{
				cullingEnabled = false;
			}
		}
		if (((Component)m_Particles).gameObject.activeSelf != flag)
		{
			((Component)m_Particles).gameObject.SetActive(flag);
			isCulled = !flag;
		}
		if (flag && !m_Particles.isPlaying)
		{
			m_Particles.Play();
		}
	}
}


public enum Direction
{
	Beam,
	Random
}


using System;
using System.Collections;
using UnityEngine;
using UnityEngine.Serialization;
using VLB;

[SelectionBase]
[ExecuteInEditMode]
[DisallowMultipleComponent]
[HelpURL("http://saladgamer.com/vlb-doc/comp-lightbeam/")]
public class VolumetricLightBeam : MonoBehaviour
{
	public bool colorFromLight = true;

	public ColorMode colorMode;

	[FormerlySerializedAs("colorValue")]
	[ColorUsage(true, true)]
	public Color color = Consts.FlatColor;

	public Gradient colorGradient;

	[Range(0f, 1f)]
	public float alphaInside = 1f;

	[FormerlySerializedAs("alpha")]
	[Range(0f, 1f)]
	public float alphaOutside = 1f;

	public BlendingMode blendingMode;

	[FormerlySerializedAs("angleFromLight")]
	public bool spotAngleFromLight = true;

	[Range(0.1f, 179.9f)]
	public float spotAngle = 35f;

	[FormerlySerializedAs("radiusStart")]
	public float coneRadiusStart = 0.1f;

	public MeshType geomMeshType;

	[FormerlySerializedAs("geomSides")]
	public int geomCustomSides = 18;

	public int geomCustomSegments = 5;

	public bool geomCap;

	public bool fadeEndFromLight = true;

	public AttenuationEquation attenuationEquation = AttenuationEquation.Quadratic;

	[Range(0f, 1f)]
	public float attenuationCustomBlending = 0.5f;

	public float fadeStart;

	public float fadeEnd = 3f;

	public float depthBlendDistance = 2f;

	public float cameraClippingDistance = 0.5f;

	[Range(0f, 1f)]
	public float glareFrontal = 0.5f;

	[Range(0f, 1f)]
	public float glareBehind = 0.5f;

	[Obsolete("Use 'glareFrontal' instead")]
	public float boostDistanceInside = 0.5f;

	[Obsolete("This property has been merged with 'fresnelPow'")]
	public float fresnelPowInside = 6f;

	[FormerlySerializedAs("fresnelPowOutside")]
	public float fresnelPow = 8f;

	public bool noiseEnabled;

	[Range(0f, 1f)]
	public float noiseIntensity = 0.5f;

	public bool noiseScaleUseGlobal = true;

	[Range(0.01f, 2f)]
	public float noiseScaleLocal = 0.5f;

	public bool noiseVelocityUseGlobal = true;

	public Vector3 noiseVelocityLocal = Consts.NoiseVelocityDefault;

	private Plane m_PlaneWS;

	[SerializeField]
	private int pluginVersion = -1;

	[SerializeField]
	[FormerlySerializedAs("trackChangesDuringPlaytime")]
	private bool _TrackChangesDuringPlaytime;

	[SerializeField]
	private int _SortingLayerID;

	[SerializeField]
	private int _SortingOrder;

	private BeamGeometry m_BeamGeom;

	private Coroutine m_CoPlaytimeUpdate;

	private Light _CachedLight;

	public float coneAngle => Mathf.Atan2(coneRadiusEnd - coneRadiusStart, fadeEnd) * 57.29578f * 2f;

	public float coneRadiusEnd => fadeEnd * Mathf.Tan(spotAngle * (MathF.PI / 180f) * 0.5f);

	public float coneVolume
	{
		get
		{
			float num = coneRadiusStart;
			float num2 = coneRadiusEnd;
			return MathF.PI / 3f * (num * num + num * num2 + num2 * num2) * fadeEnd;
		}
	}

	public float coneApexOffsetZ
	{
		get
		{
			float num = coneRadiusStart / coneRadiusEnd;
			if (num != 1f)
			{
				return fadeEnd * num / (1f - num);
			}
			return float.MaxValue;
		}
	}

	public int geomSides
	{
		get
		{
			if (geomMeshType != MeshType.Custom)
			{
				return Config.Instance.sharedMeshSides;
			}
			return geomCustomSides;
		}
		set
		{
			geomCustomSides = value;
			Debug.LogWarning((object)"The setter VLB.VolumetricLightBeam.geomSides is OBSOLETE and has been renamed to geomCustomSides.");
		}
	}

	public int geomSegments
	{
		get
		{
			if (geomMeshType != MeshType.Custom)
			{
				return Config.Instance.sharedMeshSegments;
			}
			return geomCustomSegments;
		}
		set
		{
			geomCustomSegments = value;
			Debug.LogWarning((object)"The setter VLB.VolumetricLightBeam.geomSegments is OBSOLETE and has been renamed to geomCustomSegments.");
		}
	}

	public float attenuationLerpLinearQuad
	{
		get
		{
			if (attenuationEquation == AttenuationEquation.Linear)
			{
				return 0f;
			}
			if (attenuationEquation == AttenuationEquation.Quadratic)
			{
				return 1f;
			}
			return attenuationCustomBlending;
		}
	}

	public int sortingLayerID
	{
		get
		{
			return _SortingLayerID;
		}
		set
		{
			_SortingLayerID = value;
			if (Object.op_Implicit((Object)(object)m_BeamGeom))
			{
				m_BeamGeom.sortingLayerID = value;
			}
		}
	}

	public string sortingLayerName
	{
		get
		{
			return SortingLayer.IDToName(sortingLayerID);
		}
		set
		{
			sortingLayerID = SortingLayer.NameToID(value);
		}
	}

	public int sortingOrder
	{
		get
		{
			return _SortingOrder;
		}
		set
		{
			_SortingOrder = value;
			if (Object.op_Implicit((Object)(object)m_BeamGeom))
			{
				m_BeamGeom.sortingOrder = value;
			}
		}
	}

	public bool trackChangesDuringPlaytime
	{
		get
		{
			return _TrackChangesDuringPlaytime;
		}
		set
		{
			_TrackChangesDuringPlaytime = value;
			StartPlaytimeUpdateIfNeeded();
		}
	}

	public bool isCurrentlyTrackingChanges => m_CoPlaytimeUpdate != null;

	public bool hasGeometry => (Object)(object)m_BeamGeom != (Object)null;

	public Bounds bounds
	{
		get
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)m_BeamGeom != (Object)null))
			{
				return new Bounds(Vector3.zero, Vector3.zero);
			}
			return ((Renderer)m_BeamGeom.meshRenderer).bounds;
		}
	}

	public int blendingModeAsInt => Mathf.Clamp((int)blendingMode, 0, Enum.GetValues(typeof(BlendingMode)).Length);

	public MeshRenderer Renderer
	{
		get
		{
			if (!((Object)(object)m_BeamGeom != (Object)null))
			{
				return null;
			}
			return m_BeamGeom.meshRenderer;
		}
	}

	public string meshStats
	{
		get
		{
			Mesh val = (Object.op_Implicit((Object)(object)m_BeamGeom) ? m_BeamGeom.coneMesh : null);
			if (Object.op_Implicit((Object)(object)val))
			{
				return $"Cone angle: {coneAngle:0.0} degrees\nMesh: {val.vertexCount} vertices, {val.triangles.Length / 3} triangles";
			}
			return "no mesh available";
		}
	}

	public int meshVerticesCount
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)m_BeamGeom) || !Object.op_Implicit((Object)(object)m_BeamGeom.coneMesh))
			{
				return 0;
			}
			return m_BeamGeom.coneMesh.vertexCount;
		}
	}

	public int meshTrianglesCount
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)m_BeamGeom) || !Object.op_Implicit((Object)(object)m_BeamGeom.coneMesh))
			{
				return 0;
			}
			return m_BeamGeom.coneMesh.triangles.Length / 3;
		}
	}

	private Light lightSpotAttached
	{
		get
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)_CachedLight == (Object)null)
			{
				_CachedLight = ((Component)this).GetComponent<Light>();
			}
			if (Object.op_Implicit((Object)(object)_CachedLight) && (int)_CachedLight.type == 0)
			{
				return _CachedLight;
			}
			return null;
		}
	}

	public void SetClippingPlane(Plane planeWS)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			m_BeamGeom.SetClippingPlane(planeWS);
		}
		m_PlaneWS = planeWS;
	}

	public void SetClippingPlaneOff()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			m_BeamGeom.SetClippingPlaneOff();
		}
		m_PlaneWS = default(Plane);
	}

	public bool IsColliderHiddenByDynamicOccluder(Collider collider)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Debug.Assert(Object.op_Implicit((Object)(object)collider), "You should pass a valid Collider to VLB.VolumetricLightBeam.IsColliderHiddenByDynamicOccluder");
		if (!m_PlaneWS.IsValid())
		{
			return false;
		}
		return !GeometryUtility.TestPlanesAABB((Plane[])(object)new Plane[1] { m_PlaneWS }, collider.bounds);
	}

	public float GetInsideBeamFactor(Vector3 posWS)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return GetInsideBeamFactorFromObjectSpacePos(((Component)this).transform.InverseTransformPoint(posWS));
	}

	public float GetInsideBeamFactorFromObjectSpacePos(Vector3 posOS)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (posOS.z < 0f)
		{
			return -1f;
		}
		Vector2 val = posOS.xy();
		val = new Vector2(((Vector2)(ref val)).magnitude, posOS.z + coneApexOffsetZ);
		Vector2 normalized = ((Vector2)(ref val)).normalized;
		return Mathf.Clamp((Mathf.Abs(Mathf.Sin(coneAngle * (MathF.PI / 180f) / 2f)) - Mathf.Abs(normalized.x)) / 0.1f, -1f, 1f);
	}

	[Obsolete("Use 'GenerateGeometry()' instead")]
	public void Generate()
	{
		GenerateGeometry();
	}

	public virtual void GenerateGeometry()
	{
		HandleBackwardCompatibility(pluginVersion, 1510);
		pluginVersion = 1510;
		ValidateProperties();
		if ((Object)(object)m_BeamGeom == (Object)null)
		{
			Shader beamShader = Config.Instance.beamShader;
			if (!Object.op_Implicit((Object)(object)beamShader))
			{
				Debug.LogError((object)"Invalid BeamShader set in VLB Config");
				return;
			}
			m_BeamGeom = Utils.NewWithComponent<BeamGeometry>("Beam Geometry");
			m_BeamGeom.Initialize(this, beamShader);
		}
		m_BeamGeom.RegenerateMesh();
		m_BeamGeom.visible = ((Behaviour)this).enabled;
	}

	public virtual void UpdateAfterManualPropertyChange()
	{
		ValidateProperties();
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			m_BeamGeom.UpdateMaterialAndBounds();
		}
	}

	private void Start()
	{
		GenerateGeometry();
	}

	private void OnEnable()
	{
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			m_BeamGeom.visible = true;
		}
		StartPlaytimeUpdateIfNeeded();
	}

	private void OnDisable()
	{
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			m_BeamGeom.visible = false;
		}
		m_CoPlaytimeUpdate = null;
	}

	private void StartPlaytimeUpdateIfNeeded()
	{
	}

	private IEnumerator CoPlaytimeUpdate()
	{
		while (trackChangesDuringPlaytime && ((Behaviour)this).enabled)
		{
			UpdateAfterManualPropertyChange();
			yield return null;
		}
		m_CoPlaytimeUpdate = null;
	}

	private void OnDestroy()
	{
		DestroyBeam();
	}

	private void DestroyBeam()
	{
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			Object.DestroyImmediate((Object)(object)((Component)m_BeamGeom).gameObject);
		}
		m_BeamGeom = null;
	}

	private void AssignPropertiesFromSpotLight(Light lightSpot)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)lightSpot) && (int)lightSpot.type == 0)
		{
			if (fadeEndFromLight)
			{
				fadeEnd = lightSpot.range;
			}
			if (spotAngleFromLight)
			{
				spotAngle = lightSpot.spotAngle;
			}
			if (colorFromLight)
			{
				colorMode = ColorMode.Flat;
				color = lightSpot.color;
			}
		}
	}

	private void ClampProperties()
	{
		alphaInside = Mathf.Clamp01(alphaInside);
		alphaOutside = Mathf.Clamp01(alphaOutside);
		attenuationCustomBlending = Mathf.Clamp01(attenuationCustomBlending);
		fadeEnd = Mathf.Max(0.01f, fadeEnd);
		fadeStart = Mathf.Clamp(fadeStart, 0f, fadeEnd - 0.01f);
		spotAngle = Mathf.Clamp(spotAngle, 0.1f, 179.9f);
		coneRadiusStart = Mathf.Max(coneRadiusStart, 0f);
		depthBlendDistance = Mathf.Max(depthBlendDistance, 0f);
		cameraClippingDistance = Mathf.Max(cameraClippingDistance, 0f);
		geomCustomSides = Mathf.Clamp(geomCustomSides, 3, 256);
		geomCustomSegments = Mathf.Clamp(geomCustomSegments, 0, 64);
		fresnelPow = Mathf.Max(0f, fresnelPow);
		glareBehind = Mathf.Clamp01(glareBehind);
		glareFrontal = Mathf.Clamp01(glareFrontal);
		noiseIntensity = Mathf.Clamp(noiseIntensity, 0f, 1f);
	}

	private void ValidateProperties()
	{
		AssignPropertiesFromSpotLight(lightSpotAttached);
		ClampProperties();
	}

	private void HandleBackwardCompatibility(int serializedVersion, int newVersion)
	{
		if (serializedVersion != -1 && serializedVersion != newVersion)
		{
			if (serializedVersion < 1301)
			{
				attenuationEquation = AttenuationEquation.Linear;
			}
			if (serializedVersion < 1501)
			{
				geomMeshType = MeshType.Custom;
				geomCustomSegments = 5;
			}
			Utils.MarkCurrentSceneDirty();
		}
	}
}


using UnityEngine;

public sealed class MinAttribute : PropertyAttribute
{
	public readonly float min;

	public MinAttribute(float min)
	{
		this.min = min;
	}
}


using System;
using Smaa;
using UnityEngine;

[Serializable]
public class PredicationPreset
{
	[Min(0.0001f)]
	public float Threshold = 0.01f;

	[Range(1f, 5f)]
	public float Scale = 2f;

	[Range(0f, 1f)]
	public float Strength = 0.4f;
}


using System;
using Smaa;
using UnityEngine;

[Serializable]
public class Preset
{
	public bool DiagDetection = true;

	public bool CornerDetection = true;

	[Range(0f, 0.5f)]
	public float Threshold = 0.1f;

	[Min(0.0001f)]
	public float DepthThreshold = 0.01f;

	[Range(0f, 112f)]
	public int MaxSearchSteps = 16;

	[Range(0f, 20f)]
	public int MaxSearchStepsDiag = 8;

	[Range(0f, 100f)]
	public int CornerRounding = 25;

	[Min(0f)]
	public float LocalContrastAdaptationFactor = 2f;
}


public enum EdgeDetectionMethod
{
	Luma = 1,
	Color,
	Depth
}


public enum QualityPreset
{
	Low,
	Medium,
	High,
	Ultra,
	Custom
}


public enum DebugPass
{
	Off,
	Edges,
	Weights
}


using Smaa;
using UnityEngine;

[AddComponentMenu("Image Effects/Subpixel Morphological Antialiasing")]
[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
public class SMAA : MonoBehaviour
{
	public DebugPass DebugPass;

	public QualityPreset Quality = QualityPreset.High;

	public EdgeDetectionMethod DetectionMethod = EdgeDetectionMethod.Luma;

	public bool UsePredication;

	public Preset CustomPreset;

	public PredicationPreset CustomPredicationPreset;

	public Shader Shader;

	public Texture2D AreaTex;

	public Texture2D SearchTex;

	protected Camera m_Camera;

	protected Preset m_LowPreset;

	protected Preset m_MediumPreset;

	protected Preset m_HighPreset;

	protected Preset m_UltraPreset;

	protected Material m_Material;

	public Material Material
	{
		get
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Expected O, but got Unknown
			if ((Object)(object)m_Material == (Object)null)
			{
				m_Material = new Material(Shader);
				((Object)m_Material).hideFlags = (HideFlags)61;
			}
			return m_Material;
		}
	}
}


using System;
using UnityEngine;

public class PidController
{
	private const float MaxOutput = 1000f;

	private float _integralMax;

	private float _integral;

	private float _kp;

	private float _ki;

	private float _kd;

	public float Kp
	{
		get
		{
			return _kp;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Kp must be a non-negative number.");
			}
			_kp = value;
		}
	}

	public float Ki
	{
		get
		{
			return _ki;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Ki must be a non-negative number.");
			}
			_ki = value;
			_integralMax = 1000f / Ki;
			_integral = Mathf.Clamp(_integral, 0f - _integralMax, _integralMax);
		}
	}

	public float Kd
	{
		get
		{
			return _kd;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Kd must be a non-negative number.");
			}
			_kd = value;
		}
	}

	public PidController(float kp, float ki, float kd)
	{
		if (kp < 0f)
		{
			throw new ArgumentOutOfRangeException("kp", "kp must be a non-negative number.");
		}
		if (ki < 0f)
		{
			throw new ArgumentOutOfRangeException("ki", "ki must be a non-negative number.");
		}
		if (kd < 0f)
		{
			throw new ArgumentOutOfRangeException("kd", "kd must be a non-negative number.");
		}
		Kp = kp;
		Ki = ki;
		Kd = kd;
		_integralMax = 1000f / Ki;
	}

	public float ComputeOutput(float error, float delta, float deltaTime)
	{
		_integral += error * deltaTime;
		_integral = Mathf.Clamp(_integral, 0f - _integralMax, _integralMax);
		float num = delta / deltaTime;
		return Mathf.Clamp(Kp * error + Ki * _integral + Kd * num, -1000f, 1000f);
	}
}


using System;
using UnityEngine;
using VacuumBreather;

public class PidQuaternionController
{
	private readonly PidController[] _internalController;

	public float Kp
	{
		get
		{
			return _internalController[0].Kp;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Kp must be a non-negative number.");
			}
			_internalController[0].Kp = value;
			_internalController[1].Kp = value;
			_internalController[2].Kp = value;
			_internalController[3].Kp = value;
		}
	}

	public float Ki
	{
		get
		{
			return _internalController[0].Ki;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Ki must be a non-negative number.");
			}
			_internalController[0].Ki = value;
			_internalController[1].Ki = value;
			_internalController[2].Ki = value;
			_internalController[3].Ki = value;
		}
	}

	public float Kd
	{
		get
		{
			return _internalController[0].Kd;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Kd must be a non-negative number.");
			}
			_internalController[0].Kd = value;
			_internalController[1].Kd = value;
			_internalController[2].Kd = value;
			_internalController[3].Kd = value;
		}
	}

	public PidQuaternionController(float kp, float ki, float kd)
	{
		if (kp < 0f)
		{
			throw new ArgumentOutOfRangeException("kp", "kp must be a non-negative number.");
		}
		if (ki < 0f)
		{
			throw new ArgumentOutOfRangeException("ki", "ki must be a non-negative number.");
		}
		if (kd < 0f)
		{
			throw new ArgumentOutOfRangeException("kd", "kd must be a non-negative number.");
		}
		_internalController = new PidController[4]
		{
			new PidController(kp, ki, kd),
			new PidController(kp, ki, kd),
			new PidController(kp, ki, kd),
			new PidController(kp, ki, kd)
		};
	}

	public static Quaternion MultiplyAsVector(Matrix4x4 matrix, Quaternion quaternion)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(quaternion.w, quaternion.x, quaternion.y, quaternion.z);
		Vector4 val2 = matrix * val;
		return new Quaternion(val2.y, val2.z, val2.w, val2.x);
	}

	public static Quaternion ToEulerAngleQuaternion(Vector3 eulerAngles)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return new Quaternion(eulerAngles.x, eulerAngles.y, eulerAngles.z, 0f);
	}

	public Vector3 ComputeRequiredAngularAcceleration(Quaternion currentOrientation, Quaternion desiredOrientation, Vector3 currentAngularVelocity, float deltaTime)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = QuaternionExtensions.RequiredRotation(currentOrientation, desiredOrientation);
		Quaternion error = Quaternion.identity.Subtract(val);
		Quaternion delta = ToEulerAngleQuaternion(currentAngularVelocity) * val;
		Matrix4x4 val2 = default(Matrix4x4);
		val2.m00 = (0f - val.x) * (0f - val.x) + (0f - val.y) * (0f - val.y) + (0f - val.z) * (0f - val.z);
		val2.m01 = (0f - val.x) * val.w + (0f - val.y) * (0f - val.z) + (0f - val.z) * val.y;
		val2.m02 = (0f - val.x) * val.z + (0f - val.y) * val.w + (0f - val.z) * (0f - val.x);
		val2.m03 = (0f - val.x) * (0f - val.y) + (0f - val.y) * val.x + (0f - val.z) * val.w;
		val2.m10 = val.w * (0f - val.x) + (0f - val.z) * (0f - val.y) + val.y * (0f - val.z);
		val2.m11 = val.w * val.w + (0f - val.z) * (0f - val.z) + val.y * val.y;
		val2.m12 = val.w * val.z + (0f - val.z) * val.w + val.y * (0f - val.x);
		val2.m13 = val.w * (0f - val.y) + (0f - val.z) * val.x + val.y * val.w;
		val2.m20 = val.z * (0f - val.x) + val.w * (0f - val.y) + (0f - val.x) * (0f - val.z);
		val2.m21 = val.z * val.w + val.w * (0f - val.z) + (0f - val.x) * val.y;
		val2.m22 = val.z * val.z + val.w * val.w + (0f - val.x) * (0f - val.x);
		val2.m23 = val.z * (0f - val.y) + val.w * val.x + (0f - val.x) * val.w;
		val2.m30 = (0f - val.y) * (0f - val.x) + val.x * (0f - val.y) + val.w * (0f - val.z);
		val2.m31 = (0f - val.y) * val.w + val.x * (0f - val.z) + val.w * val.y;
		val2.m32 = (0f - val.y) * val.z + val.x * val.w + val.w * (0f - val.x);
		val2.m33 = (0f - val.y) * (0f - val.y) + val.x * val.x + val.w * val.w;
		Matrix4x4 matrix = val2;
		Quaternion quaternion = ComputeOutput(error, delta, deltaTime);
		quaternion = MultiplyAsVector(matrix, quaternion);
		Quaternion val3 = quaternion.Multiply(-2f) * Quaternion.Inverse(val);
		return new Vector3(val3.x, val3.y, val3.z);
	}

	private Quaternion ComputeOutput(Quaternion error, Quaternion delta, float deltaTime)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		Quaternion result = default(Quaternion);
		result.x = _internalController[0].ComputeOutput(error.x, delta.x, deltaTime);
		result.y = _internalController[1].ComputeOutput(error.y, delta.y, deltaTime);
		result.z = _internalController[2].ComputeOutput(error.z, delta.z, deltaTime);
		result.w = _internalController[3].ComputeOutput(error.w, delta.w, deltaTime);
		return result;
	}
}


using UnityEngine;

public static class QuaternionExtensions
{
	public static Quaternion Multiply(this Quaternion quaternion, float scalar)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return new Quaternion((float)((double)quaternion.x * (double)scalar), (float)((double)quaternion.y * (double)scalar), (float)((double)quaternion.z * (double)scalar), (float)((double)quaternion.w * (double)scalar));
	}

	public static Quaternion RequiredRotation(Quaternion from, Quaternion to)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = to * Quaternion.Inverse(from);
		if (val.w < 0f)
		{
			val.x *= -1f;
			val.y *= -1f;
			val.z *= -1f;
			val.w *= -1f;
		}
		return val;
	}

	public static Quaternion Subtract(this Quaternion lhs, Quaternion rhs)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		return new Quaternion((float)((double)lhs.x - (double)rhs.x), (float)((double)lhs.y - (double)rhs.y), (float)((double)lhs.z - (double)rhs.z), (float)((double)lhs.w - (double)rhs.w));
	}
}


using FIMSpace;
using UnityEngine;

public static class FAnimatorMethods
{
	public static void LerpFloatValue(this Animator animator, string name = "RunWalk", float value = 0f, float deltaSpeed = 8f)
	{
		float @float = animator.GetFloat(name);
		@float = Mathf.Lerp(@float, value, Time.deltaTime * deltaSpeed);
		animator.SetFloat(name, @float);
	}

	public static bool CheckAnimationEnd(this Animator animator, int layer = 0, bool reverse = false, bool checkAnimLoop = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(layer);
		if (!animator.IsInTransition(layer))
		{
			if (checkAnimLoop)
			{
				if (!((AnimatorStateInfo)(ref currentAnimatorStateInfo)).loop && !reverse)
				{
					if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime > 0.98f)
					{
						return true;
					}
					if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime < 0.02f)
					{
						return true;
					}
				}
			}
			else if (!reverse)
			{
				if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime > 0.98f)
				{
					return true;
				}
				if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime < 0.02f)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static void ResetLayersWeights(this Animator animator, float speed = 10f)
	{
		for (int i = 1; i < animator.layerCount; i++)
		{
			animator.SetLayerWeight(i, animator.GetLayerWeight(i).Lerp(0f, Time.deltaTime * speed));
		}
	}

	public static void LerpLayerWeight(this Animator animator, int layer = 0, float newValue = 1f, float speed = 8f)
	{
		float num = animator.GetLayerWeight(layer);
		num.Lerp(newValue, Time.deltaTime * speed);
		if (newValue == 1f && num > 0.999f)
		{
			num = 1f;
		}
		if (newValue == 0f && num < 0.01f)
		{
			num = 0f;
		}
		animator.SetLayerWeight(layer, num);
	}

	public static bool StateExists(this Animator animator, string clipName, int layer = 0)
	{
		int num = Animator.StringToHash(clipName);
		return animator.HasState(layer, num);
	}
}


using System.Globalization;
using FIMSpace;
using UnityEngine;

public static class FColorMethods
{
	public static Color ChangeColorAlpha(this Color color, float alpha)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		return new Color(color.r, color.g, color.b, alpha);
	}

	public static Color ToGammaSpace(Color hdrColor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		float num = hdrColor.r;
		if (hdrColor.g > num)
		{
			num = hdrColor.g;
		}
		if (hdrColor.b > num)
		{
			num = hdrColor.b;
		}
		if (hdrColor.a > num)
		{
			num = hdrColor.a;
		}
		if (num <= 0f)
		{
			return Color.clear;
		}
		return hdrColor / num;
	}

	public static Color ChangeColorsValue(this Color color, float brightenOrDarken = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		return new Color(color.r + brightenOrDarken, color.g + brightenOrDarken, color.b + brightenOrDarken, color.a);
	}

	public static Color32 HexToColor(this string hex)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(hex))
		{
			Debug.Log((object)"<color=red>Trying convert from hex to color empty string!</color>");
			return Color32.op_Implicit(Color.white);
		}
		uint result = 255u;
		hex = hex.Replace("#", "");
		hex = hex.Replace("0x", "");
		if (!uint.TryParse(hex, NumberStyles.HexNumber, null, out result))
		{
			Debug.Log((object)"Error during converting hex string.");
			return Color32.op_Implicit(Color.white);
		}
		return new Color32((byte)((result & -16777216) >> 24), (byte)((result & 0xFF0000) >> 16), (byte)((result & 0xFF00) >> 8), (byte)(result & 0xFF));
	}

	public static string ColorToHex(this Color32 color, bool addHash = true)
	{
		string text = "";
		if (addHash)
		{
			text = "#";
		}
		return text + string.Format("{0}{1}{2}{3}", (color.r.ToString("X").Length == 1) ? string.Format("0{0}", color.r.ToString("X")) : color.r.ToString("X"), (color.g.ToString("X").Length == 1) ? string.Format("0{0}", color.g.ToString("X")) : color.g.ToString("X"), (color.b.ToString("X").Length == 1) ? string.Format("0{0}", color.b.ToString("X")) : color.b.ToString("X"), (color.a.ToString("X").Length == 1) ? string.Format("0{0}", color.a.ToString("X")) : color.a.ToString("X"));
	}

	public static string ColorToHex(this Color color, bool addHash = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		return FColorMethods.ColorToHex(new Color32((byte)(color.r * 255f), (byte)(color.g * 255f), (byte)(color.b * 255f), (byte)(color.a * 255f)), addHash);
	}

	public static void LerpMaterialColor(this Material mat, string property, Color targetColor, float deltaMultiplier = 8f)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)mat == (Object)null))
		{
			if (!mat.HasProperty(property))
			{
				Debug.LogError((object)("Material " + ((Object)mat).name + " don't have property '" + property + "'  in shader " + ((Object)mat.shader).name));
			}
			else
			{
				Color color = mat.GetColor(property);
				mat.SetColor(property, Color.Lerp(color, targetColor, Time.deltaTime * deltaMultiplier));
			}
		}
	}
}


using System.Diagnostics;
using UnityEngine;

public static class FDebug
{
	private static readonly Stopwatch _debugWatch = new Stopwatch();

	public static long _LastMeasureMilliseconds = 0L;

	public static long _LastMeasureTicks = 0L;

	public static void Log(string log)
	{
		Debug.Log((object)("LOG: " + log));
	}

	public static void Log(string log, string category)
	{
		Debug.Log((object)(MarkerColor("#1A6600") + "[" + category + "]" + EndColorMarker() + " " + log));
	}

	public static void LogRed(string log)
	{
		Debug.Log((object)(MarkerColor("red") + log + EndColorMarker()));
	}

	public static void LogOrange(string log)
	{
		Debug.Log((object)(MarkerColor("#D1681D") + log + EndColorMarker()));
	}

	public static void LogYellow(string log)
	{
		Debug.Log((object)(MarkerColor("#E0D300") + log + EndColorMarker()));
	}

	public static void StartMeasure()
	{
		_debugWatch.Reset();
		_debugWatch.Start();
	}

	public static void PauseMeasure()
	{
		_debugWatch.Stop();
	}

	public static void ResumeMeasure()
	{
		_debugWatch.Start();
	}

	public static void EndMeasureAndLog(string v)
	{
		_debugWatch.Stop();
		_LastMeasureMilliseconds = _debugWatch.ElapsedMilliseconds;
		_LastMeasureTicks = _debugWatch.ElapsedTicks;
		Debug.Log((object)("Measure " + v + ": " + _debugWatch.ElapsedTicks + " ticks   " + _debugWatch.ElapsedMilliseconds + "ms"));
	}

	public static long EndMeasureAndGetTicks()
	{
		_debugWatch.Stop();
		_LastMeasureMilliseconds = _debugWatch.ElapsedMilliseconds;
		_LastMeasureTicks = _debugWatch.ElapsedTicks;
		return _debugWatch.ElapsedTicks;
	}

	public static string MarkerColor(string color)
	{
		return "<color='" + color + "'>";
	}

	public static string EndColorMarker()
	{
		return "</color>";
	}

	public static void DrawBounds2D(this Bounds b, Color c, float y = 0f, float scale = 1f, float duration = 1.1f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = new Vector3(((Bounds)(ref b)).max.x, y, ((Bounds)(ref b)).max.z) * scale;
		Vector3 val2 = new Vector3(((Bounds)(ref b)).max.x, y, ((Bounds)(ref b)).min.z) * scale;
		Vector3 val3 = new Vector3(((Bounds)(ref b)).min.x, y, ((Bounds)(ref b)).min.z) * scale;
		Vector3 val4 = new Vector3(((Bounds)(ref b)).min.x, y, ((Bounds)(ref b)).max.z) * scale;
		Debug.DrawLine(val, val2, c, duration);
		Debug.DrawLine(val2, val3, c, duration);
		Debug.DrawLine(val2, val3, c, duration);
		Debug.DrawLine(val3, val4, c, duration);
		Debug.DrawLine(val4, val, c, duration);
	}

	public static void DrawBounds3D(this Bounds b, Color c, float scale = 1f, float time = 1.01f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = new Vector3(((Bounds)(ref b)).max.x, ((Bounds)(ref b)).min.y, ((Bounds)(ref b)).max.z) * scale;
		Vector3 val2 = new Vector3(((Bounds)(ref b)).max.x, ((Bounds)(ref b)).min.y, ((Bounds)(ref b)).min.z) * scale;
		Vector3 val3 = new Vector3(((Bounds)(ref b)).min.x, ((Bounds)(ref b)).min.y, ((Bounds)(ref b)).min.z) * scale;
		Vector3 val4 = new Vector3(((Bounds)(ref b)).min.x, ((Bounds)(ref b)).min.y, ((Bounds)(ref b)).max.z) * scale;
		Debug.DrawLine(val, val2, c, time);
		Debug.DrawLine(val2, val3, c, time);
		Debug.DrawLine(val2, val3, c, time);
		Debug.DrawLine(val3, val4, c, time);
		Debug.DrawLine(val4, val, c, time);
		Vector3 val5 = new Vector3(((Bounds)(ref b)).max.x, ((Bounds)(ref b)).max.y, ((Bounds)(ref b)).max.z) * scale;
		Vector3 val6 = new Vector3(((Bounds)(ref b)).max.x, ((Bounds)(ref b)).max.y, ((Bounds)(ref b)).min.z) * scale;
		Vector3 val7 = new Vector3(((Bounds)(ref b)).min.x, ((Bounds)(ref b)).max.y, ((Bounds)(ref b)).min.z) * scale;
		Vector3 val8 = new Vector3(((Bounds)(ref b)).min.x, ((Bounds)(ref b)).max.y, ((Bounds)(ref b)).max.z) * scale;
		Debug.DrawLine(val5, val6, c, time);
		Debug.DrawLine(val6, val7, c, time);
		Debug.DrawLine(val6, val7, c, time);
		Debug.DrawLine(val7, val8, c, time);
		Debug.DrawLine(val8, val5, c, time);
		Debug.DrawLine(val, val, c, time);
		Debug.DrawLine(val6, val2, c, time);
		Debug.DrawLine(val3, val7, c, time);
		Debug.DrawLine(val4, val8, c, time);
	}
}


public static class FStringMethods
{
	public static string IntToString(this int value, int signs)
	{
		string text = value.ToString();
		int num = signs - text.Length;
		if (num > 0)
		{
			string text2 = "0";
			for (int i = 1; i < num; i++)
			{
				text2 += 0;
			}
			text = text2 + text;
		}
		return text;
	}

	public static string CapitalizeOnlyFirstLetter(this string text)
	{
		if (string.IsNullOrEmpty(text))
		{
			return text;
		}
		return text[0].ToString().ToUpper() + ((text.Length > 1) ? text.Substring(1) : "");
	}

	public static string CapitalizeFirstLetter(this string text)
	{
		if (string.IsNullOrEmpty(text))
		{
			return text;
		}
		return text[0].ToString().ToUpper() + text.Substring(1);
	}

	public static string ReplaceSpacesWithUnderline(this string text)
	{
		if (text.Contains(" "))
		{
			text = text.Replace(" ", "_");
		}
		return text;
	}

	public static string GetEndOfStringFromSeparator(this string source, char[] separators, int which = 1, bool fromEnd = false)
	{
		bool flag = false;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		for (num3 = source.Length - 1; num3 >= 0; num3--)
		{
			num2++;
			for (int i = 0; i < separators.Length; i++)
			{
				if (source[num3] == separators[i])
				{
					num++;
					if (num == which)
					{
						num3++;
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				break;
			}
		}
		if (flag)
		{
			if (!fromEnd)
			{
				return source.Substring(0, source.Length - num2);
			}
			return source.Substring(num3, source.Length - num3);
		}
		return "";
	}

	public static string GetEndOfStringFromStringSeparator(this string source, string[] separators, int which = 1, bool rest = false)
	{
		bool flag = false;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		for (num3 = 0; num3 < source.Length; num3++)
		{
			num2++;
			for (int i = 0; i < separators.Length && num3 + separators[i].Length <= source.Length; i++)
			{
				if (source.Substring(num3, separators[i].Length) == separators[i])
				{
					num++;
					if (num == which)
					{
						num3++;
						num3 += separators[i].Length - 1;
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				break;
			}
		}
		if (flag)
		{
			if (rest)
			{
				return source.Substring(0, source.Length - num2);
			}
			return source.Substring(num3, source.Length - num3);
		}
		return "";
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class FEngineering
{
	private static Plane axis2DProjection;

	private static PhysicMaterial _slidingMat;

	private static PhysicMaterial _frictMat;

	private static PhysicsMaterial2D _slidingMat2D;

	private static PhysicsMaterial2D _frictMat2D;

	public static PhysicMaterial PMSliding
	{
		get
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			if (Object.op_Implicit((Object)(object)_slidingMat))
			{
				return _slidingMat;
			}
			_slidingMat = new PhysicMaterial("Slide");
			_slidingMat.frictionCombine = (PhysicMaterialCombine)2;
			_slidingMat.dynamicFriction = 0f;
			_slidingMat.staticFriction = 0f;
			return _slidingMat;
		}
	}

	public static PhysicMaterial PMFrict
	{
		get
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			if (Object.op_Implicit((Object)(object)_frictMat))
			{
				return _frictMat;
			}
			_frictMat = new PhysicMaterial("Friction");
			_frictMat.frictionCombine = (PhysicMaterialCombine)3;
			_frictMat.dynamicFriction = 10f;
			_frictMat.staticFriction = 10f;
			return _frictMat;
		}
	}

	public static PhysicsMaterial2D PMSliding2D
	{
		get
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			if (Object.op_Implicit((Object)(object)_slidingMat2D))
			{
				return _slidingMat2D;
			}
			_slidingMat2D = new PhysicsMaterial2D("Slide2D");
			_slidingMat2D.friction = 0f;
			return _slidingMat2D;
		}
	}

	public static PhysicsMaterial2D PMFrict2D
	{
		get
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			if (Object.op_Implicit((Object)(object)_frictMat2D))
			{
				return _frictMat2D;
			}
			_frictMat2D = new PhysicsMaterial2D("Friction2D");
			_frictMat2D.friction = 5f;
			return _frictMat2D;
		}
	}

	public static bool VIsZero(this Vector3 vec)
	{
		if (((Vector3)(ref vec)).sqrMagnitude == 0f)
		{
			return true;
		}
		return false;
	}

	public static bool VIsSame(this Vector3 vec1, Vector3 vec2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (vec1.x != vec2.x)
		{
			return false;
		}
		if (vec1.y != vec2.y)
		{
			return false;
		}
		if (vec1.z != vec2.z)
		{
			return false;
		}
		return true;
	}

	public static Vector3 TransformVector(this Quaternion parentRot, Vector3 parentLossyScale, Vector3 childLocalPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return parentRot * Vector3.Scale(childLocalPos, parentLossyScale);
	}

	public static Vector3 TransformInDirection(this Quaternion childRotation, Vector3 parentLossyScale, Vector3 childLocalPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		return childRotation * Vector3.Scale(childLocalPos, new Vector3((float)((parentLossyScale.x > 0f) ? 1 : (-1)), (float)((parentLossyScale.y > 0f) ? 1 : (-1)), (float)((parentLossyScale.y > 0f) ? 1 : (-1))));
	}

	public static Vector3 InverseTransformVector(this Quaternion tRotation, Vector3 tLossyScale, Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		worldPos = Quaternion.Inverse(tRotation) * worldPos;
		return new Vector3(worldPos.x / tLossyScale.x, worldPos.y / tLossyScale.y, worldPos.z / tLossyScale.z);
	}

	public static Vector3 VAxis2DLimit(this Transform parent, Vector3 parentPos, Vector3 childPos, int axis = 3)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		switch (axis)
		{
		case 3:
			((Plane)(ref axis2DProjection)).SetNormalAndPosition(parent.forward, parentPos);
			break;
		case 2:
			((Plane)(ref axis2DProjection)).SetNormalAndPosition(parent.up, parentPos);
			break;
		default:
			((Plane)(ref axis2DProjection)).SetNormalAndPosition(parent.right, parentPos);
			break;
		}
		return ((Plane)(ref axis2DProjection)).normal * ((Plane)(ref axis2DProjection)).GetDistanceToPoint(childPos);
	}

	public static Quaternion QToLocal(this Quaternion parentRotation, Quaternion worldRotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Inverse(parentRotation) * worldRotation;
	}

	public static Quaternion QToWorld(this Quaternion parentRotation, Quaternion localRotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return parentRotation * localRotation;
	}

	public static Quaternion QRotateChild(this Quaternion offset, Quaternion parentRot, Quaternion childLocalRot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return offset * parentRot * childLocalRot;
	}

	public static Quaternion ClampRotation(this Vector3 current, Vector3 bounds)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		WrapVector(current);
		if (current.x < 0f - bounds.x)
		{
			current.x = 0f - bounds.x;
		}
		else if (current.x > bounds.x)
		{
			current.x = bounds.x;
		}
		if (current.y < 0f - bounds.y)
		{
			current.y = 0f - bounds.y;
		}
		else if (current.y > bounds.y)
		{
			current.y = bounds.y;
		}
		if (current.z < 0f - bounds.z)
		{
			current.z = 0f - bounds.z;
		}
		else if (current.z > bounds.z)
		{
			current.z = bounds.z;
		}
		return Quaternion.Euler(current);
	}

	public static Vector3 QToAngularVelocity(this Quaternion deltaRotation, bool fix = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return QToAngularVelocity(deltaRotation, fix ? (1f / Time.fixedDeltaTime) : 1f);
	}

	public static Vector3 QToAngularVelocity(this Quaternion deltaRotation, float multiplyAngle)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		float num = default(float);
		Vector3 val = default(Vector3);
		((Quaternion)(ref deltaRotation)).ToAngleAxis(ref num, ref val);
		if (num != 0f)
		{
			num = Mathf.DeltaAngle(0f, num);
			val *= num * (MathF.PI / 180f) * multiplyAngle;
			if (float.IsNaN(val.x))
			{
				return Vector3.zero;
			}
			if (float.IsNaN(val.y))
			{
				return Vector3.zero;
			}
			if (float.IsNaN(val.z))
			{
				return Vector3.zero;
			}
			return val;
		}
		return Vector3.zero;
	}

	public static Vector3 QToAngularVelocity(this Quaternion currentRotation, Quaternion targetRotation, bool fix = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return QToAngularVelocity(targetRotation * Quaternion.Inverse(currentRotation), fix);
	}

	public static Vector3 QToAngularVelocity(this Quaternion currentRotation, Quaternion targetRotation, float multiply)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return QToAngularVelocity(targetRotation * Quaternion.Inverse(currentRotation), multiply);
	}

	public static bool QIsZero(this Quaternion rot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (rot.x != 0f)
		{
			return false;
		}
		if (rot.y != 0f)
		{
			return false;
		}
		if (rot.z != 0f)
		{
			return false;
		}
		return true;
	}

	public static bool QIsSame(this Quaternion rot1, Quaternion rot2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (rot1.x != rot2.x)
		{
			return false;
		}
		if (rot1.y != rot2.y)
		{
			return false;
		}
		if (rot1.z != rot2.z)
		{
			return false;
		}
		if (rot1.w != rot2.w)
		{
			return false;
		}
		return true;
	}

	public static float WrapAngle(float angle)
	{
		angle %= 360f;
		if (angle > 180f)
		{
			return angle - 360f;
		}
		return angle;
	}

	public static Vector3 WrapVector(Vector3 angles)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(WrapAngle(angles.x), WrapAngle(angles.y), WrapAngle(angles.z));
	}

	public static float UnwrapAngle(float angle)
	{
		if (angle >= 0f)
		{
			return angle;
		}
		angle = (0f - angle) % 360f;
		return 360f - angle;
	}

	public static Vector3 UnwrapVector(Vector3 angles)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(UnwrapAngle(angles.x), UnwrapAngle(angles.y), UnwrapAngle(angles.z));
	}

	public static Quaternion SmoothDampRotation(this Quaternion current, Quaternion target, ref Quaternion velocityRef, float duration, float delta)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return SmoothDampRotation(current, target, ref velocityRef, duration, float.PositiveInfinity, delta);
	}

	public static Quaternion SmoothDampRotation(this Quaternion current, Quaternion target, ref Quaternion velocityRef, float duration, float maxSpeed, float delta)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Quaternion.Dot(current, target) > 0f) ? 1f : (-1f));
		target.x *= num;
		target.y *= num;
		target.z *= num;
		target.w *= num;
		Vector4 val = new Vector4(Mathf.SmoothDamp(current.x, target.x, ref velocityRef.x, duration, maxSpeed, delta), Mathf.SmoothDamp(current.y, target.y, ref velocityRef.y, duration, maxSpeed, delta), Mathf.SmoothDamp(current.z, target.z, ref velocityRef.z, duration, maxSpeed, delta), Mathf.SmoothDamp(current.w, target.w, ref velocityRef.w, duration, maxSpeed, delta));
		Vector4 normalized = ((Vector4)(ref val)).normalized;
		Vector4 val2 = Vector4.Project(new Vector4(velocityRef.x, velocityRef.y, velocityRef.z, velocityRef.w), normalized);
		velocityRef.x -= val2.x;
		velocityRef.y -= val2.y;
		velocityRef.z -= val2.z;
		velocityRef.w -= val2.w;
		return new Quaternion(normalized.x, normalized.y, normalized.z, normalized.w);
	}

	public static float PerlinNoise3D(float x, float y, float z)
	{
		y += 1f;
		z += 2f;
		float num = Mathf.Sin(MathF.PI * Mathf.PerlinNoise(x, y));
		float num2 = Mathf.Sin(MathF.PI * Mathf.PerlinNoise(x, z));
		float num3 = Mathf.Sin(MathF.PI * Mathf.PerlinNoise(y, z));
		float num4 = Mathf.Sin(MathF.PI * Mathf.PerlinNoise(y, x));
		float num5 = Mathf.Sin(MathF.PI * Mathf.PerlinNoise(z, x));
		float num6 = Mathf.Sin(MathF.PI * Mathf.PerlinNoise(z, y));
		return num * num2 * num3 * num4 * num5 * num6;
	}

	public static float PerlinNoise3D(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return PerlinNoise3D(pos.x, pos.y, pos.z);
	}

	public static bool SameDirection(this float a, float b)
	{
		if (!(a > 0f) || !(b > 0f))
		{
			if (a < 0f)
			{
				return b < 0f;
			}
			return false;
		}
		return true;
	}

	public static float PointDisperse01(int index, int baseV = 2)
	{
		float num = 0f;
		float num2 = 1f / (float)baseV;
		int num3 = index;
		while (num3 > 0)
		{
			num += num2 * (float)(num3 % baseV);
			num3 = Mathf.FloorToInt((float)(num3 / baseV));
			num2 /= (float)baseV;
		}
		return num;
	}

	public static float PointDisperse(int index, int baseV = 2)
	{
		float num = 0f;
		float num2 = 1f / (float)baseV;
		int num3 = index;
		while (num3 > 0)
		{
			num += num2 * (float)(num3 % baseV);
			num3 = Mathf.FloorToInt((float)(num3 / baseV));
			num2 /= (float)baseV;
		}
		return num - 0.5f;
	}

	public static float GetScaler(this Transform transform)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (transform.lossyScale.x > transform.lossyScale.y)
		{
			if (transform.lossyScale.y > transform.lossyScale.z)
			{
				return transform.lossyScale.y;
			}
			return transform.lossyScale.z;
		}
		return transform.lossyScale.x;
	}

	public static Vector3 PosFromMatrix(this Matrix4x4 m)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector4.op_Implicit(((Matrix4x4)(ref m)).GetColumn(3));
	}

	public static Quaternion RotFromMatrix(this Matrix4x4 m)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.LookRotation(Vector4.op_Implicit(((Matrix4x4)(ref m)).GetColumn(2)), Vector4.op_Implicit(((Matrix4x4)(ref m)).GetColumn(1)));
	}

	public static Vector3 ScaleFromMatrix(this Matrix4x4 m)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		Vector4 column = ((Matrix4x4)(ref m)).GetColumn(0);
		float magnitude = ((Vector4)(ref column)).magnitude;
		column = ((Matrix4x4)(ref m)).GetColumn(1);
		float magnitude2 = ((Vector4)(ref column)).magnitude;
		column = ((Matrix4x4)(ref m)).GetColumn(2);
		return new Vector3(magnitude, magnitude2, ((Vector4)(ref column)).magnitude);
	}

	public static Bounds TransformBounding(Bounds b, Transform by)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return TransformBounding(b, by.localToWorldMatrix);
	}

	public static Bounds TransformBounding(Bounds b, Matrix4x4 mx)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Matrix4x4)(ref mx)).MultiplyPoint(((Bounds)(ref b)).min);
		Vector3 val2 = ((Matrix4x4)(ref mx)).MultiplyPoint(((Bounds)(ref b)).max);
		Vector3 val3 = ((Matrix4x4)(ref mx)).MultiplyPoint(new Vector3(((Bounds)(ref b)).max.x, ((Bounds)(ref b)).center.y, ((Bounds)(ref b)).min.z));
		Vector3 val4 = ((Matrix4x4)(ref mx)).MultiplyPoint(new Vector3(((Bounds)(ref b)).min.x, ((Bounds)(ref b)).center.y, ((Bounds)(ref b)).max.z));
		((Bounds)(ref b))..ctor(val, Vector3.zero);
		((Bounds)(ref b)).Encapsulate(val);
		((Bounds)(ref b)).Encapsulate(val2);
		((Bounds)(ref b)).Encapsulate(val3);
		((Bounds)(ref b)).Encapsulate(val4);
		return b;
	}

	public static Bounds RotateBoundsByMatrix(this Bounds b, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (QIsZero(rotation))
		{
			return b;
		}
		Matrix4x4 val = Matrix4x4.Rotate(rotation);
		Bounds result = default(Bounds);
		Vector3 val2 = ((Matrix4x4)(ref val)).MultiplyPoint(new Vector3(((Bounds)(ref b)).max.x, ((Bounds)(ref b)).min.y, ((Bounds)(ref b)).max.z));
		Vector3 val3 = ((Matrix4x4)(ref val)).MultiplyPoint(new Vector3(((Bounds)(ref b)).max.x, ((Bounds)(ref b)).min.y, ((Bounds)(ref b)).min.z));
		Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyPoint(new Vector3(((Bounds)(ref b)).min.x, ((Bounds)(ref b)).min.y, ((Bounds)(ref b)).min.z));
		Vector3 val5 = ((Matrix4x4)(ref val)).MultiplyPoint(new Vector3(((Bounds)(ref b)).min.x, ((Bounds)(ref b)).min.y, ((Bounds)(ref b)).max.z));
		((Bounds)(ref result)).Encapsulate(val2);
		((Bounds)(ref result)).Encapsulate(val3);
		((Bounds)(ref result)).Encapsulate(val4);
		((Bounds)(ref result)).Encapsulate(val5);
		Vector3 val6 = ((Matrix4x4)(ref val)).MultiplyPoint(new Vector3(((Bounds)(ref b)).max.x, ((Bounds)(ref b)).max.y, ((Bounds)(ref b)).max.z));
		Vector3 val7 = ((Matrix4x4)(ref val)).MultiplyPoint(new Vector3(((Bounds)(ref b)).max.x, ((Bounds)(ref b)).max.y, ((Bounds)(ref b)).min.z));
		Vector3 val8 = ((Matrix4x4)(ref val)).MultiplyPoint(new Vector3(((Bounds)(ref b)).min.x, ((Bounds)(ref b)).max.y, ((Bounds)(ref b)).min.z));
		Vector3 val9 = ((Matrix4x4)(ref val)).MultiplyPoint(new Vector3(((Bounds)(ref b)).min.x, ((Bounds)(ref b)).max.y, ((Bounds)(ref b)).max.z));
		((Bounds)(ref result)).Encapsulate(val6);
		((Bounds)(ref result)).Encapsulate(val7);
		((Bounds)(ref result)).Encapsulate(val8);
		((Bounds)(ref result)).Encapsulate(val9);
		return result;
	}

	public static Bounds RotateLocalBounds(this Bounds b, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		float num = Quaternion.Angle(rotation, Quaternion.identity);
		if (num > 45f && num < 135f)
		{
			((Bounds)(ref b)).size = new Vector3(((Bounds)(ref b)).size.z, ((Bounds)(ref b)).size.y, ((Bounds)(ref b)).size.x);
		}
		if (num < 315f && num > 225f)
		{
			((Bounds)(ref b)).size = new Vector3(((Bounds)(ref b)).size.z, ((Bounds)(ref b)).size.y, ((Bounds)(ref b)).size.x);
		}
		return b;
	}

	public static int[] GetLayermaskValues(int mask, int optionsCount)
	{
		List<int> list = new List<int>();
		for (int i = 0; i < optionsCount; i++)
		{
			int num = 1 << i;
			if ((mask & num) != 0)
			{
				list.Add(i);
			}
		}
		return list.ToArray();
	}

	public static LayerMask GetLayerMaskUsingPhysicsProjectSettingsMatrix(int maskForLayer)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		LayerMask val = LayerMask.op_Implicit(0);
		for (int i = 0; i < 32; i++)
		{
			if (!Physics.GetIgnoreLayerCollision(maskForLayer, i))
			{
				val = LayerMask.op_Implicit(LayerMask.op_Implicit(val) | (1 << i));
			}
		}
		return val;
	}

	public static float DistanceTo_2D(Vector3 aPos, Vector3 bPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.Distance(new Vector2(aPos.x, aPos.z), new Vector2(bPos.x, bPos.z));
	}

	public static float DistanceTo_2DSqrt(Vector3 aPos, Vector3 bPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.SqrMagnitude(new Vector2(aPos.x, aPos.z) - new Vector2(bPos.x, bPos.z));
	}

	public static Vector2 GetAngleDirection2D(float angle)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		float num = angle * (MathF.PI / 180f);
		return new Vector2(Mathf.Sin(num), Mathf.Cos(num));
	}

	public static Vector3 GetAngleDirection(float angle)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		float num = angle * (MathF.PI / 180f);
		return new Vector3(Mathf.Sin(num), 0f, Mathf.Cos(num));
	}

	public static Vector3 GetAngleDirectionXZ(float angle)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetAngleDirection(angle);
	}

	public static Vector3 GetAngleDirectionZX(float angle)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		float num = angle * (MathF.PI / 180f);
		return new Vector3(Mathf.Cos(num), 0f, Mathf.Sin(num));
	}

	public static Vector3 GetAngleDirectionXY(float angle, float radOffset = 0f, float secAxisRadOffset = 0f)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		float num = angle * (MathF.PI / 180f);
		return new Vector3(Mathf.Sin(num + radOffset), Mathf.Cos(num + secAxisRadOffset), 0f);
	}

	public static Vector3 GetAngleDirectionYX(float angle, float firstAxisRadOffset = 0f, float secAxisRadOffset = 0f)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		float num = angle * (MathF.PI / 180f);
		return new Vector3(Mathf.Cos(num + secAxisRadOffset), Mathf.Sin(num + firstAxisRadOffset), 0f);
	}

	public static Vector3 GetAngleDirectionYZ(float angle)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		float num = angle * (MathF.PI / 180f);
		return new Vector3(0f, Mathf.Sin(num), Mathf.Cos(num));
	}

	public static Vector3 GetAngleDirectionZY(float angle)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		float num = angle * (MathF.PI / 180f);
		return new Vector3(0f, Mathf.Cos(num), Mathf.Sin(num));
	}

	public static Vector3 V2ToV3TopDown(Vector2 v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(v.x, 0f, v.y);
	}

	public static Vector2 V3ToV2(Vector3 a)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(a.x, a.z);
	}

	public static Vector2 V3TopDownDiff(Vector3 target, Vector3 me)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return V3ToV2(target) - V3ToV2(me);
	}

	public static float GetAngleDeg(Vector3 v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return GetAngleDeg(v.x, v.z);
	}

	public static float GetAngleDeg(Vector2 v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return GetAngleDeg(v.x, v.y);
	}

	public static float GetAngleDeg(float x, float z)
	{
		return GetAngleRad(x, z) * 57.29578f;
	}

	public static float GetAngleRad(float x, float z)
	{
		return Mathf.Atan2(x, z);
	}

	public static float Rnd(float val, int dec = 0)
	{
		if (dec <= 0)
		{
			return Mathf.Round(val);
		}
		return (float)Math.Round(val, dec);
	}

	internal static float ManhattanTopDown2D(Vector3 probePos, Vector3 worldPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float num = probePos.x - worldPosition.x;
		if (num < 0f)
		{
			num = 0f - num;
		}
		float num2 = probePos.z - worldPosition.z;
		if (num2 < 0f)
		{
			num2 = 0f - num2;
		}
		return num + num2;
	}

	internal static bool IsInSqureBounds2D(Vector3 probePos, Vector3 boundsPos, float boundsRange)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		if (boundsRange <= 0f)
		{
			return false;
		}
		if (probePos.x > boundsPos.x - boundsRange && probePos.x < boundsPos.x + boundsRange && probePos.z > boundsPos.z - boundsRange && probePos.z < boundsPos.z + boundsRange)
		{
			return true;
		}
		return false;
	}

	internal static bool IsInSqureBounds2D(Vector3 boundsAPos, float boundsAHalfRange, Vector3 boundsBPos, float boundsBHRange)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (boundsAPos.x - boundsAHalfRange <= boundsBPos.x + boundsBHRange && boundsAPos.x + boundsAHalfRange >= boundsBPos.x - boundsBHRange && boundsAPos.z - boundsAHalfRange <= boundsBPos.z + boundsBHRange)
		{
			return boundsAPos.z + boundsAHalfRange >= boundsBPos.z - boundsBHRange;
		}
		return false;
	}

	internal static Vector3 GetDirectionTowards(Vector3 me, Vector3 target)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(target.x - me.x, 0f, target.z - me.z);
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class FLogicMethods
{
	public static float Lerp(this float from, float to, float value)
	{
		if (to != from)
		{
			return Mathf.Clamp((value - from) / (to - from), -1f, 1f);
		}
		return 0f;
	}

	public static float InverseLerp(float from, float to, float value)
	{
		if (to != from)
		{
			return Mathf.Clamp((value - from) / (to - from), -1f, 1f);
		}
		return 0f;
	}

	public static float InverseLerpUnclamped(float xx, float yy, float value)
	{
		if (yy - xx == 0f)
		{
			return 0f;
		}
		return (value - xx) / (yy - xx);
	}

	public static float FLerp(float a, float b, float t, float factor = 0.01f)
	{
		float num = b;
		b = ((!(num > a)) ? (b - factor) : (b + factor));
		float num2 = Mathf.LerpUnclamped(a, b, t);
		if (num > a)
		{
			if (num2 >= num)
			{
				return num;
			}
		}
		else if (num2 <= num)
		{
			return num;
		}
		return num2;
	}

	public static int IntLerp(int a, int b, float t)
	{
		int source = 0;
		IntLerp(ref source, a, b, t);
		return source;
	}

	public static void IntLerp(ref int source, int a, int b, float t)
	{
		source = Mathf.RoundToInt((float)a * (1f - t)) + Mathf.RoundToInt((float)b * t);
	}

	public static void IntLerp(ref int source, int b, float t)
	{
		IntLerp(ref source, source, b, t);
	}

	public static float FAbs(this float value)
	{
		if (value < 0f)
		{
			value = 0f - value;
		}
		return value;
	}

	public static float HyperCurve(this float value)
	{
		return 0f - 1f / (3.2f * value - 4f) - 0.25f;
	}

	public static float TopDownDistanceManhattan(this Vector3 a, Vector3 b)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		return 0f + FAbs(a.x - b.x) + FAbs(a.z - b.z);
	}

	public static float TopDownDistance(this Vector3 a, Vector3 b)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		a.y = a.z;
		b.y = b.z;
		return Vector2.Distance(Vector2.op_Implicit(a), Vector2.op_Implicit(b));
	}

	public static float DistanceManhattan(this Vector3 a, Vector3 b)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		return 0f + FAbs(a.x - b.x) + FAbs(a.y - b.y) + FAbs(a.z - b.z);
	}

	public static float WrapAngle(float angle)
	{
		angle %= 360f;
		if (angle > 180f)
		{
			return angle - 360f;
		}
		return angle;
	}

	public static Vector3 WrapVector(Vector3 angles)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(WrapAngle(angles.x), WrapAngle(angles.y), WrapAngle(angles.z));
	}

	public static float UnwrapAngle(float angle)
	{
		if (angle >= 0f)
		{
			return angle;
		}
		angle = (0f - angle) % 360f;
		return 360f - angle;
	}

	public static Vector3 UnwrapVector(Vector3 angles)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(UnwrapAngle(angles.x), UnwrapAngle(angles.y), UnwrapAngle(angles.z));
	}

	public static bool IsAlmostEqual(float val, float to, int afterComma = 2, float addRange = 0f)
	{
		float num = 1f / Mathf.Pow(10f, (float)afterComma) + addRange;
		if ((val > to - num && val < to + num) || val == to)
		{
			return true;
		}
		return false;
	}

	public static Quaternion TopDownAngle(Vector3 from, Vector3 to)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		from.y = 0f;
		to.y = 0f;
		return Quaternion.LookRotation(to - from);
	}

	public static Quaternion TopDownAnglePosition2D(Vector2 from, Vector2 to, float offset = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = to - from;
		return Quaternion.AngleAxis(Mathf.Atan2(val.y, val.x) * 57.29578f + offset, Vector3.forward);
	}

	public static bool ContainsIndex<T>(this List<T> list, int i, bool falseIfNull = true) where T : class
	{
		if (list == null)
		{
			return false;
		}
		if (i < 0)
		{
			return false;
		}
		if (i >= list.Count)
		{
			return false;
		}
		if (falseIfNull && list[i] == null)
		{
			return false;
		}
		return true;
	}

	public static bool ContainsIndex<T>(this List<T> list, int i) where T : struct
	{
		if (list == null)
		{
			return false;
		}
		if (i < 0)
		{
			return false;
		}
		if (i >= list.Count)
		{
			return false;
		}
		return true;
	}

	public static bool ContainsIndex<T>(this T[] list, int i, bool falseIfNull) where T : class
	{
		if (list == null)
		{
			return false;
		}
		if (i < 0)
		{
			return false;
		}
		if (i >= list.Length)
		{
			return false;
		}
		if (falseIfNull && list[i] == null)
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class FTransformMethods
{
	public static Transform FindChildByNameInDepth(string name, Transform transform, bool findInDeactivated = true, string[] additionalContains = null)
	{
		if (((Object)transform).name == name)
		{
			return transform;
		}
		Transform[] componentsInChildren = ((Component)transform).GetComponentsInChildren<Transform>(findInDeactivated);
		foreach (Transform val in componentsInChildren)
		{
			if (!((Object)val).name.ToLower().Contains(name.ToLower()))
			{
				continue;
			}
			bool flag = false;
			if (additionalContains == null || additionalContains.Length == 0)
			{
				flag = true;
			}
			else
			{
				for (int j = 0; j < additionalContains.Length; j++)
				{
					if (((Object)val).name.ToLower().Contains(additionalContains[j].ToLower()))
					{
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				return val;
			}
		}
		return null;
	}

	public static List<T> FindComponentsInAllChildren<T>(Transform transformToSearchIn, bool includeInactive = false, bool tryGetMultipleOutOfSingleObject = false) where T : Component
	{
		List<T> list = new List<T>();
		T[] components = ((Component)transformToSearchIn).GetComponents<T>();
		foreach (T val in components)
		{
			if (Object.op_Implicit((Object)(object)val))
			{
				list.Add(val);
			}
		}
		Transform[] componentsInChildren = ((Component)transformToSearchIn).GetComponentsInChildren<Transform>(includeInactive);
		foreach (Transform val2 in componentsInChildren)
		{
			if (!tryGetMultipleOutOfSingleObject)
			{
				T component = ((Component)val2).GetComponent<T>();
				if (Object.op_Implicit((Object)(object)component) && !list.Contains(component))
				{
					list.Add(component);
				}
				continue;
			}
			components = ((Component)val2).GetComponents<T>();
			foreach (T val3 in components)
			{
				if (Object.op_Implicit((Object)(object)val3) && !list.Contains(val3))
				{
					list.Add(val3);
				}
			}
		}
		return list;
	}

	public static T FindComponentInAllChildren<T>(Transform transformToSearchIn) where T : Component
	{
		Transform[] componentsInChildren = ((Component)transformToSearchIn).GetComponentsInChildren<Transform>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			T component = ((Component)componentsInChildren[i]).GetComponent<T>();
			if (Object.op_Implicit((Object)(object)component))
			{
				return component;
			}
		}
		return default(T);
	}

	public static T FindComponentInAllParents<T>(Transform transformToSearchIn) where T : Component
	{
		Transform parent = transformToSearchIn.parent;
		for (int i = 0; i < 100; i++)
		{
			T component = ((Component)parent).GetComponent<T>();
			if (Object.op_Implicit((Object)(object)component))
			{
				return component;
			}
			parent = parent.parent;
			if ((Object)(object)parent == (Object)null)
			{
				return default(T);
			}
		}
		return default(T);
	}

	public static void ChangeActiveChildrenInside(Transform parentOfThem, bool active)
	{
		for (int i = 0; i < parentOfThem.childCount; i++)
		{
			((Component)parentOfThem.GetChild(i)).gameObject.SetActive(active);
		}
	}

	public static void ChangeActiveThroughParentTo(Transform start, Transform end, bool active, bool changeParentsChildrenActivation = false)
	{
		((Component)start).gameObject.SetActive(active);
		Transform parent = start.parent;
		for (int i = 0; i < 100; i++)
		{
			if ((Object)(object)parent == (Object)(object)end)
			{
				break;
			}
			if ((Object)(object)parent == (Object)null)
			{
				break;
			}
			if (changeParentsChildrenActivation)
			{
				ChangeActiveChildrenInside(parent, active);
			}
			parent = parent.parent;
		}
	}

	public static Transform GetObjectByPath(Transform root, string path)
	{
		if ((Object)(object)root == (Object)null)
		{
			return null;
		}
		string[] array = path.Split('/');
		Transform val = root;
		for (int i = 0; i < array.Length; i++)
		{
			Transform val2 = val.Find(array[i]);
			if ((Object)(object)val2 == (Object)null)
			{
				return null;
			}
			val = val2;
		}
		return val;
	}

	public static string CalculateTransformPath(Transform child, Transform root)
	{
		if ((Object)(object)child.parent == (Object)null)
		{
			return "";
		}
		string text = "";
		bool flag = true;
		while ((Object)(object)child != (Object)(object)root)
		{
			if ((Object)(object)child == (Object)null)
			{
				return "";
			}
			text = ((!flag) ? (((Object)child).name + "/" + text) : ((Object)child).name);
			flag = false;
			child = child.parent;
		}
		return text;
	}
}


using UnityEngine;

public static class FVectorMethods
{
	public static Vector3 RandomVector(float rangeA, float rangeB)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(Random.Range(rangeA, rangeB), Random.Range(rangeA, rangeB), Random.Range(rangeA, rangeB));
	}

	public static float VectorSum(Vector3 vector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return vector.x + vector.y + vector.z;
	}

	public static Vector3 RandomVectorNoY(float rangeA, float rangeB)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(Random.Range(rangeA, rangeB), 0f, Random.Range(rangeA, rangeB));
	}

	public static Vector3 RandomVectorMinMax(float min, float max)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f;
		if (Random.Range(0, 2) == 1)
		{
			num = -1f;
		}
		float num2 = 1f;
		if (Random.Range(0, 2) == 1)
		{
			num2 = -1f;
		}
		float num3 = 1f;
		if (Random.Range(0, 2) == 1)
		{
			num3 = -1f;
		}
		return new Vector3(Random.Range(min, max) * num, Random.Range(min, max) * num2, Random.Range(min, max) * num3);
	}

	public static Vector3 RandomVectorNoYMinMax(float min, float max)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f;
		if (Random.Range(0, 2) == 1)
		{
			num = -1f;
		}
		float num2 = 1f;
		if (Random.Range(0, 2) == 1)
		{
			num2 = -1f;
		}
		return new Vector3(Random.Range(min, max) * num, 0f, Random.Range(min, max) * num2);
	}

	public static Vector3 GetUIPositionFromWorldPosition(Vector3 position, Camera camera, RectTransform canvas)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = camera.WorldToViewportPoint(position);
		result.x *= canvas.sizeDelta.x;
		result.y *= canvas.sizeDelta.y;
		result.x -= canvas.sizeDelta.x * canvas.pivot.x;
		result.y -= canvas.sizeDelta.y * canvas.pivot.y;
		return result;
	}

	public static Vector2 XOZ(this Vector3 toBeFlattened)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(toBeFlattened.x, toBeFlattened.z);
	}

	public static Vector3 XOZ(this Vector3 toBeFlattened, float yValue = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(toBeFlattened.x, yValue, toBeFlattened.z);
	}

	public static float DistanceTopDown(Vector3 from, Vector3 to)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.Distance(XOZ(from), XOZ(to));
	}

	public static float DistanceTopDownManhattan(Vector3 from, Vector3 to)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Abs(from.x - to.x) + Mathf.Abs(from.z - to.z);
	}

	public static float BoundsSizeOnAxis(this Bounds bounds, Vector3 normalized)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Scale(((Bounds)(ref bounds)).size, normalized);
		return ((Vector3)(ref val)).magnitude;
	}

	public static Vector3 ChooseDominantAxis(Vector3 axis)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Abs(axis.x), Mathf.Abs(axis.y), Mathf.Abs(axis.z));
		if (val.x > val.y)
		{
			if (val.z > val.x)
			{
				return new Vector3(0f, 0f, (axis.z > 0f) ? 1f : (-1f));
			}
			return new Vector3((axis.x > 0f) ? 1f : (-1f), 0f, 0f);
		}
		if (val.z > val.y)
		{
			return new Vector3(0f, 0f, (axis.z > 0f) ? 1f : (-1f));
		}
		return new Vector3(0f, (axis.y > 0f) ? 1f : (-1f), 0f);
	}

	public static Vector3 GetRounded(Vector3 dir)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(Mathf.Round(dir.x), Mathf.Round(dir.y), Mathf.Round(dir.z));
	}

	public static Vector3 GetCounterAxis(Vector3 axis)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(axis.z, axis.x, axis.y);
	}

	public static Color GetAxisColor(Vector3 axis, float alpha = 0.75f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		return new Color(axis.z, axis.x, axis.y, alpha);
	}

	public static Vector3 FlattenVector(Vector3 v, float to = 90f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		v.x = Mathf.Round(v.x / to) * to;
		v.y = Mathf.Round(v.y / to) * to;
		v.z = Mathf.Round(v.z / to) * to;
		return v;
	}

	public static Vector3 FlattenVectorFlr(Vector3 v, float to = 90f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		v.x = Mathf.Floor(v.x / to) * to;
		v.y = Mathf.Floor(v.y / to) * to;
		v.z = Mathf.Floor(v.z / to) * to;
		return v;
	}

	public static Vector3 FlattenVectorCeil(Vector3 v, float to = 90f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		v.x = Mathf.Ceil(v.x / to) * to;
		v.y = Mathf.Ceil(v.y / to) * to;
		v.z = Mathf.Ceil(v.z / to) * to;
		return v;
	}

	public static Vector3 FlattenVector(Vector3 v, Vector3 to)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		v.x = Mathf.Round(v.x / to.x) * to.x;
		v.y = Mathf.Round(v.y / to.y) * to.y;
		v.z = Mathf.Round(v.z / to.z) * to.z;
		return v;
	}

	public static Vector3Int V3toV3Int(Vector3 v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3Int(Mathf.RoundToInt(v.x), Mathf.RoundToInt(v.y), Mathf.RoundToInt(v.z));
	}

	public static Vector3 FlattenNormal(Quaternion orientation, Vector3? forward = null, float to = 90f)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((!forward.HasValue) ? Vector3.forward : forward.Value);
		return Quaternion.Euler(FlattenVector(((Quaternion)(ref orientation)).eulerAngles, to)) * val;
	}

	public static Vector3 EqualVector(float valueAll)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(valueAll, valueAll, valueAll);
	}

	public static Quaternion FlattenRotation(Quaternion orientation, float to = 90f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Euler(FlattenVector(((Quaternion)(ref orientation)).eulerAngles, to));
	}
}


using FIMSpace;
using UnityEngine;

public abstract class FImp_ColliderData_Base
{
	public enum EFColliderType
	{
		Box,
		Sphere,
		Capsule,
		Mesh,
		Terrain
	}

	public bool Is2D;

	protected Vector3 previousPosition = Vector3.zero;

	protected Quaternion previousRotation = Quaternion.identity;

	protected Vector3 previousScale = Vector3.one;

	public Transform Transform { get; protected set; }

	public Collider Collider { get; protected set; }

	public Collider2D Collider2D { get; protected set; }

	public bool IsStatic { get; private set; }

	public EFColliderType ColliderType { get; protected set; }

	public static FImp_ColliderData_Base GetColliderDataFor(Collider collider)
	{
		SphereCollider val = (SphereCollider)(object)((collider is SphereCollider) ? collider : null);
		if (Object.op_Implicit((Object)(object)val))
		{
			return new FImp_ColliderData_Sphere(val);
		}
		CapsuleCollider val2 = (CapsuleCollider)(object)((collider is CapsuleCollider) ? collider : null);
		if (Object.op_Implicit((Object)(object)val2))
		{
			return new FImp_ColliderData_Capsule(val2);
		}
		BoxCollider val3 = (BoxCollider)(object)((collider is BoxCollider) ? collider : null);
		if (Object.op_Implicit((Object)(object)val3))
		{
			return new FImp_ColliderData_Box(val3);
		}
		MeshCollider val4 = (MeshCollider)(object)((collider is MeshCollider) ? collider : null);
		if (Object.op_Implicit((Object)(object)val4))
		{
			return new FImp_ColliderData_Mesh(val4);
		}
		TerrainCollider val5 = (TerrainCollider)(object)((collider is TerrainCollider) ? collider : null);
		if (Object.op_Implicit((Object)(object)val5))
		{
			return new FImp_ColliderData_Terrain(val5);
		}
		CharacterController val6 = (CharacterController)(object)((collider is CharacterController) ? collider : null);
		if (Object.op_Implicit((Object)(object)val6))
		{
			return new FImp_ColliderData_CharacterCapsule(val6);
		}
		return null;
	}

	public static FImp_ColliderData_Base GetColliderDataFor(Collider2D collider)
	{
		CircleCollider2D val = (CircleCollider2D)(object)((collider is CircleCollider2D) ? collider : null);
		if (Object.op_Implicit((Object)(object)val))
		{
			return new FImp_ColliderData_Sphere(val);
		}
		CapsuleCollider2D val2 = (CapsuleCollider2D)(object)((collider is CapsuleCollider2D) ? collider : null);
		if (Object.op_Implicit((Object)(object)val2))
		{
			return new FImp_ColliderData_Capsule(val2);
		}
		BoxCollider2D val3 = (BoxCollider2D)(object)((collider is BoxCollider2D) ? collider : null);
		if (Object.op_Implicit((Object)(object)val3))
		{
			return new FImp_ColliderData_Box(val3);
		}
		PolygonCollider2D val4 = (PolygonCollider2D)(object)((collider is PolygonCollider2D) ? collider : null);
		if (Object.op_Implicit((Object)(object)val4))
		{
			return new FImp_ColliderData_Mesh(val4);
		}
		return null;
	}

	public virtual void RefreshColliderData()
	{
		if (((Component)Transform).gameObject.isStatic)
		{
			IsStatic = true;
		}
		else
		{
			IsStatic = false;
		}
	}

	public virtual bool PushIfInside(ref Vector3 point, float pointRadius, Vector3 pointOffset)
	{
		Collider collider = Collider;
		if (Object.op_Implicit((Object)(object)((collider is SphereCollider) ? collider : null)))
		{
			Debug.Log((object)"It shouldn't appear");
		}
		return false;
	}

	public virtual bool PushIfInside2D(ref Vector3 point, float pointRadius, Vector3 pointOffset)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return PushIfInside(ref point, pointRadius, pointOffset);
	}

	public static bool VIsSame(Vector3 vec1, Vector3 vec2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (vec1.x != vec2.x)
		{
			return false;
		}
		if (vec1.y != vec2.y)
		{
			return false;
		}
		if (vec1.z != vec2.z)
		{
			return false;
		}
		return true;
	}
}


public enum EFColliderType
{
	Box,
	Sphere,
	Capsule,
	Mesh,
	Terrain
}


using FIMSpace;
using UnityEngine;

public class FImp_ColliderData_Box : FImp_ColliderData_Base
{
	private Vector3 boxCenter;

	private Vector3 right;

	private Vector3 up;

	private Vector3 forward;

	private Vector3 rightN;

	private Vector3 upN;

	private Vector3 forwardN;

	private Vector3 scales;

	public BoxCollider Box { get; private set; }

	public BoxCollider2D Box2D { get; private set; }

	public FImp_ColliderData_Box(BoxCollider collider)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		Is2D = false;
		base.Collider = (Collider)(object)collider;
		base.Transform = ((Component)collider).transform;
		Box = collider;
		base.ColliderType = EFColliderType.Box;
		RefreshColliderData();
		previousPosition = base.Transform.position + Vector3.forward * Mathf.Epsilon;
	}

	public FImp_ColliderData_Box(BoxCollider2D collider2D)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		Is2D = true;
		base.Collider2D = (Collider2D)(object)collider2D;
		base.Transform = ((Component)collider2D).transform;
		Box2D = collider2D;
		base.ColliderType = EFColliderType.Box;
		RefreshColliderData();
		previousPosition = base.Transform.position + Vector3.forward * Mathf.Epsilon;
	}

	public override void RefreshColliderData()
	{
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		if (base.IsStatic)
		{
			return;
		}
		if ((Object)(object)base.Collider2D == (Object)null)
		{
			bool flag = false;
			if (!base.Transform.position.VIsSame(previousPosition))
			{
				flag = true;
			}
			else if (!base.Transform.rotation.QIsSame(previousRotation))
			{
				flag = true;
			}
			if (flag)
			{
				right = ((Component)Box).transform.TransformVector(Vector3.right / 2f * Box.size.x);
				up = ((Component)Box).transform.TransformVector(Vector3.up / 2f * Box.size.y);
				forward = ((Component)Box).transform.TransformVector(Vector3.forward / 2f * Box.size.z);
				rightN = ((Vector3)(ref right)).normalized;
				upN = ((Vector3)(ref up)).normalized;
				forwardN = ((Vector3)(ref forward)).normalized;
				boxCenter = GetBoxCenter(Box);
				scales = Vector3.Scale(Box.size, ((Component)Box).transform.lossyScale);
				((Vector3)(ref scales)).Normalize();
			}
		}
		else
		{
			bool flag2 = false;
			if (Vector2.Distance(Vector2.op_Implicit(base.Transform.position), Vector2.op_Implicit(previousPosition)) > Mathf.Epsilon)
			{
				flag2 = true;
			}
			else if (!base.Transform.rotation.QIsSame(previousRotation))
			{
				flag2 = true;
			}
			if (flag2)
			{
				right = ((Component)Box2D).transform.TransformVector(Vector3.right / 2f * Box2D.size.x);
				up = ((Component)Box2D).transform.TransformVector(Vector3.up / 2f * Box2D.size.y);
				rightN = ((Vector3)(ref right)).normalized;
				upN = ((Vector3)(ref up)).normalized;
				boxCenter = GetBoxCenter(Box2D);
				boxCenter.z = 0f;
				Vector3 lossyScale = base.Transform.lossyScale;
				lossyScale.z = 1f;
				scales = Vector3.Scale(Vector2.op_Implicit(Box2D.size), lossyScale);
				((Vector3)(ref scales)).Normalize();
			}
		}
		base.RefreshColliderData();
		previousPosition = base.Transform.position;
		previousRotation = base.Transform.rotation;
	}

	public override bool PushIfInside(ref Vector3 segmentPosition, float segmentRadius, Vector3 segmentOffset)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		Vector3 val = Vector3.zero;
		Vector3 val2 = segmentPosition + segmentOffset;
		float planeDistance = PlaneDistance(boxCenter + up, upN, val2);
		if (SphereInsidePlane(planeDistance, segmentRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentRadius))
		{
			num++;
			val = up;
		}
		planeDistance = PlaneDistance(boxCenter - up, -upN, val2);
		if (SphereInsidePlane(planeDistance, segmentRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentRadius))
		{
			num++;
			val = -up;
		}
		planeDistance = PlaneDistance(boxCenter - right, -rightN, val2);
		if (SphereInsidePlane(planeDistance, segmentRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentRadius))
		{
			num++;
			val = -right;
		}
		planeDistance = PlaneDistance(boxCenter + right, rightN, val2);
		if (SphereInsidePlane(planeDistance, segmentRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentRadius))
		{
			num++;
			val = right;
		}
		bool flag = false;
		if ((Object)(object)base.Collider2D == (Object)null)
		{
			planeDistance = PlaneDistance(boxCenter + forward, forwardN, val2);
			if (SphereInsidePlane(planeDistance, segmentRadius))
			{
				num++;
			}
			else if (SphereIntersectsPlane(planeDistance, segmentRadius))
			{
				num++;
				val = forward;
			}
			planeDistance = PlaneDistance(boxCenter - forward, -forwardN, val2);
			if (SphereInsidePlane(planeDistance, segmentRadius))
			{
				num++;
			}
			else if (SphereIntersectsPlane(planeDistance, segmentRadius))
			{
				num++;
				val = -forward;
			}
			if (num == 6)
			{
				flag = true;
			}
		}
		else if (num == 4)
		{
			flag = true;
		}
		if (flag)
		{
			bool flag2 = false;
			if (((Vector3)(ref val)).sqrMagnitude == 0f)
			{
				flag2 = true;
			}
			else if ((Object)(object)base.Collider2D == (Object)null)
			{
				if (IsInsideBoxCollider(Box, val2))
				{
					flag2 = true;
				}
			}
			else if (IsInsideBoxCollider(Box2D, val2))
			{
				flag2 = true;
			}
			Vector3 val3 = GetNearestPoint(val2) - val2;
			val3 = ((!flag2) ? (val3 - ((Vector3)(ref val3)).normalized * segmentRadius) : (val3 + ((Vector3)(ref val3)).normalized * segmentRadius));
			if (flag2)
			{
				segmentPosition += val3;
			}
			else if (((Vector3)(ref val3)).sqrMagnitude > 0f)
			{
				segmentPosition += val3;
			}
			return true;
		}
		return false;
	}

	public static void PushOutFromBoxCollider(BoxCollider box, Collision collision, float segmentColliderRadius, ref Vector3 segmentPosition, bool is2D = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)box).transform.TransformVector(Vector3.right / 2f * box.size.x + box.center.x * Vector3.right);
		Vector3 val2 = ((Component)box).transform.TransformVector(Vector3.up / 2f * box.size.y + box.center.y * Vector3.up);
		Vector3 val3 = ((Component)box).transform.TransformVector(Vector3.forward / 2f * box.size.z + box.center.z * Vector3.forward);
		Vector3 val4 = Vector3.Scale(box.size, ((Component)box).transform.lossyScale);
		((Vector3)(ref val4)).Normalize();
		PushOutFromBoxCollider(box, collision, segmentColliderRadius, ref segmentPosition, val, val2, val3, val4, is2D);
	}

	public static void PushOutFromBoxCollider(BoxCollider box, float segmentColliderRadius, ref Vector3 segmentPosition, bool is2D = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)box).transform.TransformVector(Vector3.right / 2f * box.size.x + box.center.x * Vector3.right);
		Vector3 val2 = ((Component)box).transform.TransformVector(Vector3.up / 2f * box.size.y + box.center.y * Vector3.up);
		Vector3 val3 = ((Component)box).transform.TransformVector(Vector3.forward / 2f * box.size.z + box.center.z * Vector3.forward);
		Vector3 val4 = Vector3.Scale(box.size, ((Component)box).transform.lossyScale);
		((Vector3)(ref val4)).Normalize();
		Vector3 val5 = GetBoxCenter(box);
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		Vector3 normalized2 = ((Vector3)(ref val)).normalized;
		Vector3 normalized3 = ((Vector3)(ref val3)).normalized;
		int num = 0;
		Vector3 val6 = Vector3.zero;
		float planeDistance = PlaneDistance(val5 + val2, normalized, segmentPosition);
		if (SphereInsidePlane(planeDistance, segmentColliderRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentColliderRadius))
		{
			num++;
			val6 = val2;
		}
		planeDistance = PlaneDistance(val5 - val2, -normalized, segmentPosition);
		if (SphereInsidePlane(planeDistance, segmentColliderRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentColliderRadius))
		{
			num++;
			val6 = -val2;
		}
		planeDistance = PlaneDistance(val5 - val, -normalized2, segmentPosition);
		if (SphereInsidePlane(planeDistance, segmentColliderRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentColliderRadius))
		{
			num++;
			val6 = -val;
		}
		planeDistance = PlaneDistance(val5 + val, normalized2, segmentPosition);
		if (SphereInsidePlane(planeDistance, segmentColliderRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentColliderRadius))
		{
			num++;
			val6 = val;
		}
		planeDistance = PlaneDistance(val5 + val3, normalized3, segmentPosition);
		if (SphereInsidePlane(planeDistance, segmentColliderRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentColliderRadius))
		{
			num++;
			val6 = val3;
		}
		planeDistance = PlaneDistance(val5 - val3, -normalized3, segmentPosition);
		if (SphereInsidePlane(planeDistance, segmentColliderRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentColliderRadius))
		{
			num++;
			val6 = -val3;
		}
		if (num == 6)
		{
			bool flag = false;
			if (((Vector3)(ref val6)).sqrMagnitude == 0f)
			{
				flag = true;
			}
			else if (IsInsideBoxCollider(box, segmentPosition))
			{
				flag = true;
			}
			Vector3 val7 = GetNearestPoint(segmentPosition, val5, val, val2, val3, is2D) - segmentPosition;
			val7 = ((!flag) ? (val7 - ((Vector3)(ref val7)).normalized * segmentColliderRadius * 1.01f) : (val7 + ((Vector3)(ref val7)).normalized * segmentColliderRadius * 1.01f));
			if (flag)
			{
				segmentPosition += val7;
			}
			else if (((Vector3)(ref val7)).sqrMagnitude > 0f)
			{
				segmentPosition += val7;
			}
		}
	}

	public static void PushOutFromBoxCollider(BoxCollider box, Collision collision, float segmentColliderRadius, ref Vector3 pos, Vector3 right, Vector3 up, Vector3 forward, Vector3 scales, bool is2D = false)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((ContactPoint)(ref collision.contacts[0])).point;
		Vector3 val2 = pos - val;
		Vector3 val3 = GetBoxCenter(box);
		if (((Vector3)(ref val2)).sqrMagnitude == 0f)
		{
			val2 = pos - val3;
		}
		float num = 1f;
		if (IsInsideBoxCollider(box, pos))
		{
			float boxAverageScale = GetBoxAverageScale(box);
			Vector3 targetPlaneNormal = GetTargetPlaneNormal(box, pos, right, up, forward, scales);
			Vector3 normalized = ((Vector3)(ref targetPlaneNormal)).normalized;
			RaycastHit val4 = default(RaycastHit);
			val = ((!((Collider)box).Raycast(new Ray(pos - normalized * boxAverageScale * 3f, normalized), ref val4, boxAverageScale * 4f)) ? GetIntersectOnBoxFromInside(box, val3, pos, targetPlaneNormal) : ((RaycastHit)(ref val4)).point);
			val2 = val - pos;
			num = 100f;
		}
		Vector3 val5 = pos - (val2 / num + ((Vector3)(ref val2)).normalized * 1.15f) / 2f * segmentColliderRadius;
		val5 = val - val5;
		float sqrMagnitude = ((Vector3)(ref val5)).sqrMagnitude;
		if (sqrMagnitude > 0f && sqrMagnitude < segmentColliderRadius * segmentColliderRadius * num)
		{
			pos += val5;
		}
	}

	public static void PushOutFromBoxCollider(BoxCollider2D box2D, float segmentColliderRadius, ref Vector3 segmentPosition)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = Vector2.op_Implicit(((Component)box2D).transform.TransformVector(Vector3.right / 2f * box2D.size.x + ((Collider2D)box2D).offset.x * Vector3.right));
		Vector2 val2 = Vector2.op_Implicit(((Component)box2D).transform.TransformVector(Vector3.up / 2f * box2D.size.y + ((Collider2D)box2D).offset.y * Vector3.up));
		Vector3 lossyScale = ((Component)box2D).transform.lossyScale;
		lossyScale.z = 1f;
		Vector2 val3 = Vector2.op_Implicit(Vector3.Scale(Vector2.op_Implicit(box2D.size), lossyScale));
		((Vector2)(ref val3)).Normalize();
		Vector2 val4 = Vector2.op_Implicit(GetBoxCenter(box2D));
		Vector2 normalized = ((Vector2)(ref val2)).normalized;
		Vector2 normalized2 = ((Vector2)(ref val)).normalized;
		int num = 0;
		Vector3 val5 = Vector3.zero;
		float planeDistance = PlaneDistance(Vector2.op_Implicit(val4 + val2), Vector2.op_Implicit(normalized), segmentPosition);
		if (SphereInsidePlane(planeDistance, segmentColliderRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentColliderRadius))
		{
			num++;
			val5 = Vector2.op_Implicit(val2);
		}
		planeDistance = PlaneDistance(Vector2.op_Implicit(val4 - val2), Vector2.op_Implicit(-normalized), segmentPosition);
		if (SphereInsidePlane(planeDistance, segmentColliderRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentColliderRadius))
		{
			num++;
			val5 = Vector2.op_Implicit(-val2);
		}
		planeDistance = PlaneDistance(Vector2.op_Implicit(val4 - val), Vector2.op_Implicit(-normalized2), segmentPosition);
		if (SphereInsidePlane(planeDistance, segmentColliderRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentColliderRadius))
		{
			num++;
			val5 = Vector2.op_Implicit(-val);
		}
		planeDistance = PlaneDistance(Vector2.op_Implicit(val4 + val), Vector2.op_Implicit(normalized2), segmentPosition);
		if (SphereInsidePlane(planeDistance, segmentColliderRadius))
		{
			num++;
		}
		else if (SphereIntersectsPlane(planeDistance, segmentColliderRadius))
		{
			num++;
			val5 = Vector2.op_Implicit(val);
		}
		if (num == 4)
		{
			bool flag = false;
			if (((Vector3)(ref val5)).sqrMagnitude == 0f)
			{
				flag = true;
			}
			else if (IsInsideBoxCollider(box2D, segmentPosition))
			{
				flag = true;
			}
			Vector3 val6 = GetNearestPoint2D(Vector2.op_Implicit(segmentPosition), val4, val, val2) - segmentPosition;
			val6 = ((!flag) ? (val6 - ((Vector3)(ref val6)).normalized * segmentColliderRadius * 1.01f) : (val6 + ((Vector3)(ref val6)).normalized * segmentColliderRadius * 1.01f));
			if (flag)
			{
				segmentPosition += val6;
			}
			else if (((Vector3)(ref val6)).sqrMagnitude > 0f)
			{
				segmentPosition += val6;
			}
		}
	}

	private Vector3 GetNearestPoint(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = point;
		Vector3 one = Vector3.one;
		one.x = PlaneDistance(boxCenter + right, rightN, point);
		one.y = PlaneDistance(boxCenter + up, upN, point);
		if ((Object)(object)base.Collider2D == (Object)null)
		{
			one.z = PlaneDistance(boxCenter + forward, forwardN, point);
		}
		Vector3 one2 = Vector3.one;
		one2.x = PlaneDistance(boxCenter - right, -rightN, point);
		one2.y = PlaneDistance(boxCenter - up, -upN, point);
		if ((Object)(object)base.Collider2D == (Object)null)
		{
			one2.z = PlaneDistance(boxCenter - forward, -forwardN, point);
		}
		float num = 1f;
		float num2 = 1f;
		float num3 = 1f;
		float x;
		if (one.x > one2.x)
		{
			x = one.x;
			num = -1f;
		}
		else
		{
			x = one2.x;
			num = 1f;
		}
		float y;
		if (one.y > one2.y)
		{
			y = one.y;
			num2 = -1f;
		}
		else
		{
			y = one2.y;
			num2 = 1f;
		}
		if ((Object)(object)base.Collider2D == (Object)null)
		{
			float z;
			if (one.z > one2.z)
			{
				z = one.z;
				num3 = -1f;
			}
			else
			{
				z = one2.z;
				num3 = 1f;
			}
			if (x > z)
			{
				if (x > y)
				{
					return ProjectPointOnPlane(right * num, point, x);
				}
				return ProjectPointOnPlane(up * num2, point, y);
			}
			if (z > y)
			{
				return ProjectPointOnPlane(forward * num3, point, z);
			}
			return ProjectPointOnPlane(up * num2, point, y);
		}
		if (x > y)
		{
			return ProjectPointOnPlane(right * num, point, x);
		}
		return ProjectPointOnPlane(up * num2, point, y);
	}

	private static Vector3 GetNearestPoint(Vector3 point, Vector3 boxCenter, Vector3 right, Vector3 up, Vector3 forward, bool is2D = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = point;
		Vector3 one = Vector3.one;
		one.x = PlaneDistance(boxCenter + right, ((Vector3)(ref right)).normalized, point);
		one.y = PlaneDistance(boxCenter + up, ((Vector3)(ref up)).normalized, point);
		if (!is2D)
		{
			one.z = PlaneDistance(boxCenter + forward, ((Vector3)(ref forward)).normalized, point);
		}
		Vector3 one2 = Vector3.one;
		one2.x = PlaneDistance(boxCenter - right, -((Vector3)(ref right)).normalized, point);
		one2.y = PlaneDistance(boxCenter - up, -((Vector3)(ref up)).normalized, point);
		if (!is2D)
		{
			one2.z = PlaneDistance(boxCenter - forward, -((Vector3)(ref forward)).normalized, point);
		}
		float num = 1f;
		float num2 = 1f;
		float num3 = 1f;
		float x;
		if (one.x > one2.x)
		{
			x = one.x;
			num = -1f;
		}
		else
		{
			x = one2.x;
			num = 1f;
		}
		float y;
		if (one.y > one2.y)
		{
			y = one.y;
			num2 = -1f;
		}
		else
		{
			y = one2.y;
			num2 = 1f;
		}
		if (!is2D)
		{
			float z;
			if (one.z > one2.z)
			{
				z = one.z;
				num3 = -1f;
			}
			else
			{
				z = one2.z;
				num3 = 1f;
			}
			if (x > z)
			{
				if (x > y)
				{
					return ProjectPointOnPlane(right * num, point, x);
				}
				return ProjectPointOnPlane(up * num2, point, y);
			}
			if (z > y)
			{
				return ProjectPointOnPlane(forward * num3, point, z);
			}
			return ProjectPointOnPlane(up * num2, point, y);
		}
		if (x > y)
		{
			return ProjectPointOnPlane(right * num, point, x);
		}
		return ProjectPointOnPlane(up * num2, point, y);
	}

	private static Vector3 GetNearestPoint2D(Vector2 point, Vector2 boxCenter, Vector2 right, Vector2 up)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector2.op_Implicit(point);
		Vector3 one = Vector3.one;
		one.x = PlaneDistance(Vector2.op_Implicit(boxCenter + right), Vector2.op_Implicit(((Vector2)(ref right)).normalized), Vector2.op_Implicit(point));
		one.y = PlaneDistance(Vector2.op_Implicit(boxCenter + up), Vector2.op_Implicit(((Vector2)(ref up)).normalized), Vector2.op_Implicit(point));
		Vector3 one2 = Vector3.one;
		one2.x = PlaneDistance(Vector2.op_Implicit(boxCenter - right), Vector2.op_Implicit(-((Vector2)(ref right)).normalized), Vector2.op_Implicit(point));
		one2.y = PlaneDistance(Vector2.op_Implicit(boxCenter - up), Vector2.op_Implicit(-((Vector2)(ref up)).normalized), Vector2.op_Implicit(point));
		float num = 1f;
		float num2 = 1f;
		float x;
		if (one.x > one2.x)
		{
			x = one.x;
			num = -1f;
		}
		else
		{
			x = one2.x;
			num = 1f;
		}
		float y;
		if (one.y > one2.y)
		{
			y = one.y;
			num2 = -1f;
		}
		else
		{
			y = one2.y;
			num2 = 1f;
		}
		if (x > y)
		{
			return ProjectPointOnPlane(Vector2.op_Implicit(right * num), Vector2.op_Implicit(point), x);
		}
		return ProjectPointOnPlane(Vector2.op_Implicit(up * num2), Vector2.op_Implicit(point), y);
	}

	public static Vector3 GetNearestPointOnBox(BoxCollider boxCollider, Vector3 point, bool is2D = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)boxCollider).transform.TransformVector(Vector3.right / 2f);
		Vector3 val2 = ((Component)boxCollider).transform.TransformVector(Vector3.up / 2f);
		Vector3 val3 = Vector3.forward;
		if (!is2D)
		{
			val3 = ((Component)boxCollider).transform.TransformVector(Vector3.forward / 2f);
		}
		Vector3 val4 = point;
		Vector3 val5 = GetBoxCenter(boxCollider);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 normalized2 = ((Vector3)(ref val2)).normalized;
		Vector3 normalized3 = ((Vector3)(ref val3)).normalized;
		Vector3 one = Vector3.one;
		one.x = PlaneDistance(val5 + val, normalized, point);
		one.y = PlaneDistance(val5 + val2, normalized2, point);
		if (!is2D)
		{
			one.z = PlaneDistance(val5 + val3, normalized3, point);
		}
		Vector3 one2 = Vector3.one;
		one2.x = PlaneDistance(val5 - val, -normalized, point);
		one2.y = PlaneDistance(val5 - val2, -normalized2, point);
		if (!is2D)
		{
			one2.z = PlaneDistance(val5 - val3, -normalized3, point);
		}
		float num = 1f;
		float num2 = 1f;
		float num3 = 1f;
		float x;
		if (one.x > one2.x)
		{
			x = one.x;
			num = -1f;
		}
		else
		{
			x = one2.x;
			num = 1f;
		}
		float y;
		if (one.y > one2.y)
		{
			y = one.y;
			num2 = -1f;
		}
		else
		{
			y = one2.y;
			num2 = 1f;
		}
		if (!is2D)
		{
			float z;
			if (one.z > one2.z)
			{
				z = one.z;
				num3 = -1f;
			}
			else
			{
				z = one2.z;
				num3 = 1f;
			}
			if (x > z)
			{
				if (x > y)
				{
					return ProjectPointOnPlane(val * num, point, x);
				}
				return ProjectPointOnPlane(val2 * num2, point, y);
			}
			if (z > y)
			{
				return ProjectPointOnPlane(val3 * num3, point, z);
			}
			return ProjectPointOnPlane(val2 * num2, point, y);
		}
		if (x > y)
		{
			return ProjectPointOnPlane(val * num, point, x);
		}
		return ProjectPointOnPlane(val2 * num2, point, y);
	}

	private static float PlaneDistance(Vector3 planeCenter, Vector3 planeNormal, Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Dot(point - planeCenter, planeNormal);
	}

	private static Vector3 ProjectPointOnPlane(Vector3 planeNormal, Vector3 point, float distance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Vector3)(ref planeNormal)).normalized * distance;
		return point + val;
	}

	private static bool SphereInsidePlane(float planeDistance, float pointRadius)
	{
		return 0f - planeDistance > pointRadius;
	}

	private static bool SphereOutsidePlane(float planeDistance, float pointRadius)
	{
		return planeDistance > pointRadius;
	}

	private static bool SphereIntersectsPlane(float planeDistance, float pointRadius)
	{
		return Mathf.Abs(planeDistance) <= pointRadius;
	}

	public static bool IsInsideBoxCollider(BoxCollider collider, Vector3 point, bool is2D = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		point = ((Component)collider).transform.InverseTransformPoint(point) - collider.center;
		float num = collider.size.x * 0.5f;
		float num2 = collider.size.y * 0.5f;
		float num3 = collider.size.z * 0.5f;
		if (point.x < num && point.x > 0f - num && point.y < num2 && point.y > 0f - num2 && point.z < num3)
		{
			return point.z > 0f - num3;
		}
		return false;
	}

	public static bool IsInsideBoxCollider(BoxCollider2D collider, Vector3 point)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		point = Vector2.op_Implicit(Vector2.op_Implicit(((Component)collider).transform.InverseTransformPoint(point)) - ((Collider2D)collider).offset);
		float num = collider.size.x * 0.5f;
		float num2 = collider.size.y * 0.5f;
		if (point.x < num && point.x > 0f - num && point.y < num2)
		{
			return point.y > 0f - num2;
		}
		return false;
	}

	protected static float GetBoxAverageScale(BoxCollider box)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lossyScale = ((Component)box).transform.lossyScale;
		lossyScale = Vector3.Scale(lossyScale, box.size);
		return (lossyScale.x + lossyScale.y + lossyScale.z) / 3f;
	}

	protected static Vector3 GetBoxCenter(BoxCollider box)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)box).transform.position + ((Component)box).transform.TransformVector(box.center);
	}

	protected static Vector3 GetBoxCenter(BoxCollider2D box)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)box).transform.position + ((Component)box).transform.TransformVector(Vector2.op_Implicit(((Collider2D)box).offset));
	}

	protected static Vector3 GetTargetPlaneNormal(BoxCollider boxCollider, Vector3 point, bool is2D = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)boxCollider).transform.TransformVector(Vector3.right / 2f * boxCollider.size.x);
		Vector3 val2 = ((Component)boxCollider).transform.TransformVector(Vector3.up / 2f * boxCollider.size.y);
		Vector3 val3 = Vector3.forward;
		if (!is2D)
		{
			val3 = ((Component)boxCollider).transform.TransformVector(Vector3.forward / 2f * boxCollider.size.z);
		}
		Vector3 val4 = Vector3.Scale(boxCollider.size, ((Component)boxCollider).transform.lossyScale);
		((Vector3)(ref val4)).Normalize();
		return GetTargetPlaneNormal(boxCollider, point, val, val2, val3, val4, is2D);
	}

	protected static Vector3 GetTargetPlaneNormal(BoxCollider boxCollider, Vector3 point, Vector3 right, Vector3 up, Vector3 forward, Vector3 scales, bool is2D = false)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = GetBoxCenter(boxCollider) - point;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = default(Vector3);
		val2.x = Vector3.Dot(normalized, ((Vector3)(ref right)).normalized);
		val2.y = Vector3.Dot(normalized, ((Vector3)(ref up)).normalized);
		val2.x = val2.x * scales.y * scales.z;
		val2.y = val2.y * scales.x * scales.z;
		if (!is2D)
		{
			val2.z = Vector3.Dot(normalized, ((Vector3)(ref forward)).normalized);
			val2.z = val2.z * scales.y * scales.x;
		}
		else
		{
			val2.z = 0f;
		}
		((Vector3)(ref val2)).Normalize();
		Vector3 val3 = val2;
		if (val2.x < 0f)
		{
			val3.x = 0f - val2.x;
		}
		if (val2.y < 0f)
		{
			val3.y = 0f - val2.y;
		}
		if (val2.z < 0f)
		{
			val3.z = 0f - val2.z;
		}
		if (val3.x > val3.y)
		{
			if (val3.x > val3.z || is2D)
			{
				return right * Mathf.Sign(val2.x);
			}
			return forward * Mathf.Sign(val2.z);
		}
		if (val3.y > val3.z || is2D)
		{
			return up * Mathf.Sign(val2.y);
		}
		return forward * Mathf.Sign(val2.z);
	}

	protected static Vector3 GetTargetPlaneNormal(BoxCollider2D boxCollider, Vector2 point, Vector2 right, Vector2 up, Vector2 scales)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = Vector2.op_Implicit(GetBoxCenter(boxCollider)) - point;
		Vector2 normalized = ((Vector2)(ref val)).normalized;
		Vector2 val2 = default(Vector2);
		val2.x = Vector3.Dot(Vector2.op_Implicit(normalized), Vector2.op_Implicit(((Vector2)(ref right)).normalized));
		val2.y = Vector3.Dot(Vector2.op_Implicit(normalized), Vector2.op_Implicit(((Vector2)(ref up)).normalized));
		val2.x *= scales.y;
		val2.y *= scales.x;
		((Vector2)(ref val2)).Normalize();
		Vector2 val3 = val2;
		if (val2.x < 0f)
		{
			val3.x = 0f - val2.x;
		}
		if (val2.y < 0f)
		{
			val3.y = 0f - val2.y;
		}
		if (val3.x > val3.y)
		{
			return Vector2.op_Implicit(right * Mathf.Sign(val2.x));
		}
		return Vector2.op_Implicit(up * Mathf.Sign(val2.y));
	}

	protected static Vector3 GetIntersectOnBoxFromInside(BoxCollider boxCollider, Vector3 from, Vector3 to, Vector3 planeNormal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = to - from;
		Plane val2 = default(Plane);
		((Plane)(ref val2))..ctor(-planeNormal, GetBoxCenter(boxCollider) + planeNormal);
		Vector3 result = to;
		float num = 0f;
		Ray val3 = default(Ray);
		((Ray)(ref val3))..ctor(from, val);
		if (((Plane)(ref val2)).Raycast(val3, ref num))
		{
			result = ((Ray)(ref val3)).GetPoint(num);
		}
		return result;
	}
}


using FIMSpace;
using UnityEngine;

public class FImp_ColliderData_Capsule : FImp_ColliderData_Base
{
	private Vector3 Top;

	private Vector3 Bottom;

	private Vector3 Direction;

	private float radius;

	private float scaleFactor;

	private float preRadius;

	public CapsuleCollider Capsule { get; private set; }

	public CapsuleCollider2D Capsule2D { get; private set; }

	public FImp_ColliderData_Capsule(CapsuleCollider collider)
	{
		Is2D = false;
		base.Transform = ((Component)collider).transform;
		base.Collider = (Collider)(object)collider;
		base.Transform = ((Component)collider).transform;
		Capsule = collider;
		base.ColliderType = EFColliderType.Capsule;
		CalculateCapsuleParameters(Capsule, ref Direction, ref radius, ref scaleFactor);
		RefreshColliderData();
	}

	public FImp_ColliderData_Capsule(CapsuleCollider2D collider)
	{
		Is2D = true;
		base.Transform = ((Component)collider).transform;
		base.Collider2D = (Collider2D)(object)collider;
		base.Transform = ((Component)collider).transform;
		Capsule2D = collider;
		base.ColliderType = EFColliderType.Capsule;
		CalculateCapsuleParameters(Capsule2D, ref Direction, ref radius, ref scaleFactor);
		RefreshColliderData();
	}

	public override void RefreshColliderData()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		if (base.IsStatic)
		{
			return;
		}
		bool flag = false;
		if (!previousPosition.VIsSame(base.Transform.position))
		{
			flag = true;
		}
		else if (!base.Transform.rotation.QIsSame(previousRotation))
		{
			flag = true;
		}
		else if (!Is2D)
		{
			if (preRadius != Capsule.radius || !previousScale.VIsSame(base.Transform.lossyScale))
			{
				CalculateCapsuleParameters(Capsule, ref Direction, ref radius, ref scaleFactor);
			}
		}
		else if (preRadius != GetCapsule2DRadius(Capsule2D) || !previousScale.VIsSame(base.Transform.lossyScale))
		{
			CalculateCapsuleParameters(Capsule2D, ref Direction, ref radius, ref scaleFactor);
		}
		if (flag)
		{
			if (!Is2D)
			{
				GetCapsuleHeadsPositions(Capsule, ref Top, ref Bottom, Direction, radius, scaleFactor);
			}
			else
			{
				GetCapsuleHeadsPositions(Capsule2D, ref Top, ref Bottom, Direction, radius, scaleFactor);
			}
		}
		base.RefreshColliderData();
		previousPosition = base.Transform.position;
		previousRotation = base.Transform.rotation;
		previousScale = base.Transform.lossyScale;
		if (!Is2D)
		{
			preRadius = Capsule.radius;
		}
		else
		{
			preRadius = GetCapsule2DRadius(Capsule2D);
		}
	}

	public override bool PushIfInside(ref Vector3 point, float pointRadius, Vector3 pointOffset)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return PushOutFromCapsuleCollider(pointRadius, ref point, Top, Bottom, radius, pointOffset, Is2D);
	}

	public static bool PushOutFromCapsuleCollider(CapsuleCollider capsule, float segmentColliderRadius, ref Vector3 pos, Vector3 segmentOffset)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 direction = Vector3.zero;
		float trueRadius = capsule.radius;
		float scalerFactor = 1f;
		CalculateCapsuleParameters(capsule, ref direction, ref trueRadius, ref scalerFactor);
		Vector3 upper = Vector3.zero;
		Vector3 bottom = Vector3.zero;
		GetCapsuleHeadsPositions(capsule, ref upper, ref bottom, direction, trueRadius, scalerFactor);
		return PushOutFromCapsuleCollider(segmentColliderRadius, ref pos, upper, bottom, trueRadius, segmentOffset);
	}

	public static bool PushOutFromCapsuleCollider(float segmentColliderRadius, ref Vector3 segmentPos, Vector3 capSphereCenter1, Vector3 capSphereCenter2, float capsuleRadius, Vector3 segmentOffset, bool is2D = false)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		float num = capsuleRadius + segmentColliderRadius;
		Vector3 val = capSphereCenter2 - capSphereCenter1;
		Vector3 val2 = segmentPos + segmentOffset - capSphereCenter1;
		if (is2D)
		{
			val.z = 0f;
			val2.z = 0f;
		}
		float num2 = Vector3.Dot(val2, val);
		if (num2 <= 0f)
		{
			float sqrMagnitude = ((Vector3)(ref val2)).sqrMagnitude;
			if (sqrMagnitude > 0f && sqrMagnitude < num * num)
			{
				segmentPos = capSphereCenter1 - segmentOffset + val2 * (num / Mathf.Sqrt(sqrMagnitude));
				return true;
			}
		}
		else
		{
			float sqrMagnitude2 = ((Vector3)(ref val)).sqrMagnitude;
			if (num2 >= sqrMagnitude2)
			{
				val2 = segmentPos + segmentOffset - capSphereCenter2;
				float sqrMagnitude3 = ((Vector3)(ref val2)).sqrMagnitude;
				if (sqrMagnitude3 > 0f && sqrMagnitude3 < num * num)
				{
					segmentPos = capSphereCenter2 - segmentOffset + val2 * (num / Mathf.Sqrt(sqrMagnitude3));
					return true;
				}
			}
			else if (sqrMagnitude2 > 0f)
			{
				val2 -= val * (num2 / sqrMagnitude2);
				float sqrMagnitude4 = ((Vector3)(ref val2)).sqrMagnitude;
				if (sqrMagnitude4 > 0f && sqrMagnitude4 < num * num)
				{
					float num3 = Mathf.Sqrt(sqrMagnitude4);
					segmentPos += val2 * ((num - num3) / num3);
					return true;
				}
			}
		}
		return false;
	}

	protected static void CalculateCapsuleParameters(CapsuleCollider capsule, ref Vector3 direction, ref float trueRadius, ref float scalerFactor)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)capsule).transform;
		float num;
		if (capsule.direction == 1)
		{
			direction = Vector3.up;
			scalerFactor = transform.lossyScale.y;
			num = ((transform.lossyScale.x > transform.lossyScale.z) ? transform.lossyScale.x : transform.lossyScale.z);
		}
		else if (capsule.direction == 0)
		{
			direction = Vector3.right;
			scalerFactor = transform.lossyScale.x;
			num = ((transform.lossyScale.y > transform.lossyScale.z) ? transform.lossyScale.y : transform.lossyScale.z);
		}
		else
		{
			direction = Vector3.forward;
			scalerFactor = transform.lossyScale.z;
			num = ((transform.lossyScale.y > transform.lossyScale.x) ? transform.lossyScale.y : transform.lossyScale.x);
		}
		trueRadius = capsule.radius * num;
	}

	private static float GetCapsule2DRadius(CapsuleCollider2D capsule)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if ((int)capsule.direction == 0)
		{
			return capsule.size.x / 2f;
		}
		return capsule.size.y / 2f;
	}

	private static float GetCapsule2DHeight(CapsuleCollider2D capsule)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if ((int)capsule.direction == 0)
		{
			return capsule.size.y / 2f;
		}
		return capsule.size.x / 2f;
	}

	protected static void CalculateCapsuleParameters(CapsuleCollider2D capsule, ref Vector3 direction, ref float trueRadius, ref float scalerFactor)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Invalid comparison between Unknown and I4
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)capsule).transform;
		if ((int)capsule.direction == 0)
		{
			direction = Vector3.up;
			scalerFactor = transform.lossyScale.y;
			float num = ((transform.lossyScale.x > transform.lossyScale.z) ? transform.lossyScale.x : transform.lossyScale.z);
			trueRadius = capsule.size.x / 2f * num;
		}
		else if ((int)capsule.direction == 1)
		{
			direction = Vector3.right;
			scalerFactor = transform.lossyScale.x;
			float num = ((transform.lossyScale.y > transform.lossyScale.z) ? transform.lossyScale.y : transform.lossyScale.z);
			trueRadius = capsule.size.y / 2f * num;
		}
	}

	protected static void GetCapsuleHeadsPositions(CapsuleCollider capsule, ref Vector3 upper, ref Vector3 bottom, Vector3 direction, float radius, float scalerFactor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = direction * (capsule.height / 2f * scalerFactor - radius);
		upper = ((Component)capsule).transform.position + ((Component)capsule).transform.TransformDirection(val) + ((Component)capsule).transform.TransformVector(capsule.center);
		Vector3 val2 = -direction * (capsule.height / 2f * scalerFactor - radius);
		bottom = ((Component)capsule).transform.position + ((Component)capsule).transform.TransformDirection(val2) + ((Component)capsule).transform.TransformVector(capsule.center);
	}

	protected static void GetCapsuleHeadsPositions(CapsuleCollider2D capsule, ref Vector3 upper, ref Vector3 bottom, Vector3 direction, float radius, float scalerFactor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = direction * (GetCapsule2DHeight(capsule) * scalerFactor - radius);
		upper = ((Component)capsule).transform.position + ((Component)capsule).transform.TransformDirection(val) + ((Component)capsule).transform.TransformVector(Vector2.op_Implicit(((Collider2D)capsule).offset));
		upper.z = 0f;
		Vector3 val2 = -direction * (GetCapsule2DHeight(capsule) * scalerFactor - radius);
		bottom = ((Component)capsule).transform.position + ((Component)capsule).transform.TransformDirection(val2) + ((Component)capsule).transform.TransformVector(Vector2.op_Implicit(((Collider2D)capsule).offset));
		bottom.z = 0f;
	}
}


using FIMSpace;
using UnityEngine;

public class FImp_ColliderData_CharacterCapsule : FImp_ColliderData_Base
{
	private Vector3 Top;

	private Vector3 Bottom;

	private Vector3 Direction;

	private float radius;

	private float scaleFactor;

	private float preRadius;

	public CharacterController Capsule { get; private set; }

	public FImp_ColliderData_CharacterCapsule(CharacterController collider)
	{
		Is2D = false;
		base.Transform = ((Component)collider).transform;
		base.Collider = (Collider)(object)collider;
		base.Transform = ((Component)collider).transform;
		Capsule = collider;
		base.ColliderType = EFColliderType.Capsule;
		CalculateCapsuleParameters(Capsule, ref Direction, ref radius, ref scaleFactor);
		RefreshColliderData();
	}

	public override void RefreshColliderData()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsStatic)
		{
			bool flag = false;
			if (!previousPosition.VIsSame(base.Transform.position))
			{
				flag = true;
			}
			else if (!base.Transform.rotation.QIsSame(previousRotation))
			{
				flag = true;
			}
			else if (preRadius != Capsule.radius || !previousScale.VIsSame(base.Transform.lossyScale))
			{
				CalculateCapsuleParameters(Capsule, ref Direction, ref radius, ref scaleFactor);
			}
			if (flag)
			{
				GetCapsuleHeadsPositions(Capsule, ref Top, ref Bottom, Direction, radius, scaleFactor);
			}
			base.RefreshColliderData();
			previousPosition = base.Transform.position;
			previousRotation = base.Transform.rotation;
			previousScale = base.Transform.lossyScale;
			preRadius = Capsule.radius;
		}
	}

	public override bool PushIfInside(ref Vector3 point, float pointRadius, Vector3 pointOffset)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return PushOutFromCapsuleCollider(pointRadius, ref point, Top, Bottom, radius, pointOffset);
	}

	public static bool PushOutFromCapsuleCollider(float segmentColliderRadius, ref Vector3 segmentPos, Vector3 capSphereCenter1, Vector3 capSphereCenter2, float capsuleRadius, Vector3 segmentOffset, bool is2D = false)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		float num = capsuleRadius + segmentColliderRadius;
		Vector3 val = capSphereCenter2 - capSphereCenter1;
		Vector3 val2 = segmentPos + segmentOffset - capSphereCenter1;
		float num2 = Vector3.Dot(val2, val);
		if (num2 <= 0f)
		{
			float sqrMagnitude = ((Vector3)(ref val2)).sqrMagnitude;
			if (sqrMagnitude > 0f && sqrMagnitude < num * num)
			{
				segmentPos = capSphereCenter1 - segmentOffset + val2 * (num / Mathf.Sqrt(sqrMagnitude));
				return true;
			}
		}
		else
		{
			float sqrMagnitude2 = ((Vector3)(ref val)).sqrMagnitude;
			if (num2 >= sqrMagnitude2)
			{
				val2 = segmentPos + segmentOffset - capSphereCenter2;
				float sqrMagnitude3 = ((Vector3)(ref val2)).sqrMagnitude;
				if (sqrMagnitude3 > 0f && sqrMagnitude3 < num * num)
				{
					segmentPos = capSphereCenter2 - segmentOffset + val2 * (num / Mathf.Sqrt(sqrMagnitude3));
					return true;
				}
			}
			else if (sqrMagnitude2 > 0f)
			{
				val2 -= val * (num2 / sqrMagnitude2);
				float sqrMagnitude4 = ((Vector3)(ref val2)).sqrMagnitude;
				if (sqrMagnitude4 > 0f && sqrMagnitude4 < num * num)
				{
					float num3 = Mathf.Sqrt(sqrMagnitude4);
					segmentPos += val2 * ((num - num3) / num3);
					return true;
				}
			}
		}
		return false;
	}

	protected static void CalculateCapsuleParameters(CharacterController capsule, ref Vector3 direction, ref float trueRadius, ref float scalerFactor)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)capsule).transform;
		direction = Vector3.up;
		scalerFactor = transform.lossyScale.y;
		float num = ((transform.lossyScale.x > transform.lossyScale.z) ? transform.lossyScale.x : transform.lossyScale.z);
		trueRadius = capsule.radius * num;
	}

	protected static void GetCapsuleHeadsPositions(CharacterController capsule, ref Vector3 upper, ref Vector3 bottom, Vector3 direction, float radius, float scalerFactor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = direction * (capsule.height / 2f * scalerFactor - radius);
		upper = ((Component)capsule).transform.position + ((Component)capsule).transform.TransformDirection(val) + ((Component)capsule).transform.TransformVector(capsule.center);
		Vector3 val2 = -direction * (capsule.height / 2f * scalerFactor - radius);
		bottom = ((Component)capsule).transform.position + ((Component)capsule).transform.TransformDirection(val2) + ((Component)capsule).transform.TransformVector(capsule.center);
	}
}


using FIMSpace;
using UnityEngine;

public class FImp_ColliderData_Mesh : FImp_ColliderData_Base
{
	private ContactFilter2D filter;

	private RaycastHit2D[] r;

	public MeshCollider Mesh { get; private set; }

	public PolygonCollider2D Poly2D { get; private set; }

	public FImp_ColliderData_Mesh(MeshCollider collider)
	{
		Is2D = false;
		base.Transform = ((Component)collider).transform;
		base.Collider = (Collider)(object)collider;
		Mesh = collider;
		base.ColliderType = EFColliderType.Mesh;
	}

	public FImp_ColliderData_Mesh(PolygonCollider2D collider)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		Is2D = true;
		base.Transform = ((Component)collider).transform;
		Poly2D = collider;
		base.Collider2D = (Collider2D)(object)collider;
		base.ColliderType = EFColliderType.Mesh;
		filter = default(ContactFilter2D);
		filter.useTriggers = false;
		filter.useDepth = false;
		r = (RaycastHit2D[])(object)new RaycastHit2D[1];
	}

	public override bool PushIfInside(ref Vector3 segmentPosition, float segmentRadius, Vector3 segmentOffset)
	{
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0409: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_041d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0422: Unknown result type (might be due to invalid IL or missing references)
		//IL_0427: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3;
		Bounds bounds;
		if (!Is2D)
		{
			if (!Mesh.convex)
			{
				float num = 0f;
				Vector3 val = segmentPosition + segmentOffset;
				Vector3 val2 = ((Collider)Mesh).ClosestPointOnBounds(val);
				val3 = val2 - ((Component)Mesh).transform.position;
				num = ((Vector3)(ref val3)).magnitude;
				bool flag = false;
				float num2 = 1f;
				if (val2 == val)
				{
					flag = true;
					num2 = 7f;
					val2 = ((Component)Mesh).transform.position;
				}
				Vector3 val4 = val2 - val;
				Vector3 normalized = ((Vector3)(ref val4)).normalized;
				float num3 = segmentRadius * 2f;
				bounds = ((Collider)Mesh).bounds;
				val3 = ((Bounds)(ref bounds)).extents;
				Vector3 val5 = val - normalized * (num3 + ((Vector3)(ref val3)).magnitude);
				float num4 = ((Vector3)(ref val4)).magnitude + segmentRadius * 2f + num;
				bounds = ((Collider)Mesh).bounds;
				val3 = ((Bounds)(ref bounds)).extents;
				float num5 = num4 + ((Vector3)(ref val3)).magnitude;
				val3 = val - val2;
				if (((Vector3)(ref val3)).magnitude < segmentRadius * num2)
				{
					Ray val6 = default(Ray);
					((Ray)(ref val6))..ctor(val5, normalized);
					RaycastHit val7 = default(RaycastHit);
					if (((Collider)Mesh).Raycast(val6, ref val7, num5))
					{
						val3 = val - ((RaycastHit)(ref val7)).point;
						if (((Vector3)(ref val3)).magnitude < segmentRadius * num2)
						{
							Vector3 val8 = ((RaycastHit)(ref val7)).point - val;
							Vector3 val9 = ((!flag) ? (val8 - ((Vector3)(ref val8)).normalized * segmentRadius) : (val8 + ((Vector3)(ref val8)).normalized * segmentRadius));
							val3 = ((RaycastHit)(ref val7)).point - val;
							float num6 = Vector3.Dot(((Vector3)(ref val3)).normalized, normalized);
							if (flag && num6 > 0f)
							{
								val9 = val8 - ((Vector3)(ref val8)).normalized * segmentRadius;
							}
							segmentPosition += val9;
							return true;
						}
					}
				}
				return false;
			}
			Vector3 val10 = segmentPosition + segmentOffset;
			float num7 = 1f;
			Vector3 val11 = Physics.ClosestPoint(val10, (Collider)(object)Mesh, ((Component)Mesh).transform.position, ((Component)Mesh).transform.rotation);
			if (Vector3.Distance(val11, val10) > segmentRadius * 1.01f)
			{
				return false;
			}
			Vector3 val12 = val11 - val10;
			if (val12 == Vector3.zero)
			{
				return false;
			}
			RaycastHit val13 = default(RaycastHit);
			((Collider)Mesh).Raycast(new Ray(val10, ((Vector3)(ref val12)).normalized), ref val13, segmentRadius * num7);
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val13)).transform))
			{
				segmentPosition = ((RaycastHit)(ref val13)).point + ((RaycastHit)(ref val13)).normal * segmentRadius;
				return true;
			}
		}
		else
		{
			Vector2 val14 = Vector2.op_Implicit(segmentPosition + segmentOffset);
			Vector2 val18;
			if (((Collider2D)Poly2D).OverlapPoint(val14))
			{
				bounds = ((Collider2D)Poly2D).bounds;
				Vector3 val15 = ((Bounds)(ref bounds)).center - Vector2.op_Implicit(val14);
				val15.z = 0f;
				bounds = ((Collider2D)Poly2D).bounds;
				Vector3 center = ((Bounds)(ref bounds)).center;
				Vector3 val16 = val15;
				bounds = ((Collider2D)Poly2D).bounds;
				val3 = ((Bounds)(ref bounds)).max;
				Ray val17 = default(Ray);
				((Ray)(ref val17))..ctor(center - val16 * ((Vector3)(ref val3)).magnitude, val15);
				float num8 = 0f;
				bounds = ((Collider2D)Poly2D).bounds;
				((Bounds)(ref bounds)).IntersectRay(val17, ref num8);
				val18 = ((!(num8 > 0f)) ? ((Collider2D)Poly2D).ClosestPoint(val14) : ((Collider2D)Poly2D).ClosestPoint(Vector2.op_Implicit(((Ray)(ref val17)).GetPoint(num8))));
			}
			else
			{
				val18 = ((Collider2D)Poly2D).ClosestPoint(val14);
			}
			Vector2 val19 = val18 - val14;
			Vector2 normalized2 = ((Vector2)(ref val19)).normalized;
			if (Physics2D.Raycast(val14, normalized2, filter, r, segmentRadius) > 0 && (Object)(object)((RaycastHit2D)(ref r[0])).transform == (Object)(object)base.Transform)
			{
				segmentPosition = Vector2.op_Implicit(val18 + ((RaycastHit2D)(ref r[0])).normal * segmentRadius);
				return true;
			}
		}
		return false;
	}

	public static void PushOutFromMeshCollider(MeshCollider mesh, Collision collision, float segmentColliderRadius, ref Vector3 pos)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		Vector3 point = ((ContactPoint)(ref collision.contacts[0])).point;
		Vector3 val = ((ContactPoint)(ref collision.contacts[0])).normal;
		RaycastHit val2 = default(RaycastHit);
		if (((Collider)mesh).Raycast(new Ray(pos + val * segmentColliderRadius * 2f, -val), ref val2, segmentColliderRadius * 5f))
		{
			val = ((RaycastHit)(ref val2)).point - pos;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude > 0f && sqrMagnitude < segmentColliderRadius * segmentColliderRadius)
			{
				pos = ((RaycastHit)(ref val2)).point - val * (segmentColliderRadius / Mathf.Sqrt(sqrMagnitude)) * 0.9f;
			}
		}
		else
		{
			val = point - pos;
			float sqrMagnitude2 = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude2 > 0f && sqrMagnitude2 < segmentColliderRadius * segmentColliderRadius)
			{
				pos = point - val * (segmentColliderRadius / Mathf.Sqrt(sqrMagnitude2)) * 0.9f;
			}
		}
	}

	public static void PushOutFromMesh(MeshCollider mesh, Collision collision, float pointRadius, ref Vector3 point)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		Vector3 val = ((Collider)mesh).ClosestPointOnBounds(point);
		Vector3 val2 = val - ((Component)mesh).transform.position;
		num = ((Vector3)(ref val2)).magnitude;
		bool flag = false;
		float num2 = 1f;
		if (val == point)
		{
			flag = true;
			num2 = 7f;
			val = ((Component)mesh).transform.position;
		}
		Vector3 val3 = val - point;
		Vector3 normalized = ((Vector3)(ref val3)).normalized;
		Vector3 val4 = point;
		float num3 = pointRadius * 2f;
		Bounds bounds = ((Collider)mesh).bounds;
		val2 = ((Bounds)(ref bounds)).extents;
		Vector3 val5 = val4 - normalized * (num3 + ((Vector3)(ref val2)).magnitude);
		float num4 = ((Vector3)(ref val3)).magnitude + pointRadius * 2f + num;
		bounds = ((Collider)mesh).bounds;
		val2 = ((Bounds)(ref bounds)).extents;
		float num5 = num4 + ((Vector3)(ref val2)).magnitude;
		val2 = point - val;
		if (!(((Vector3)(ref val2)).magnitude < pointRadius * num2))
		{
			return;
		}
		Vector3 val6;
		if (!flag)
		{
			val6 = ((ContactPoint)(ref collision.contacts[0])).point;
		}
		else
		{
			Ray val7 = default(Ray);
			((Ray)(ref val7))..ctor(val5, normalized);
			RaycastHit val8 = default(RaycastHit);
			val6 = ((!((Collider)mesh).Raycast(val7, ref val8, num5)) ? ((ContactPoint)(ref collision.contacts[0])).point : ((RaycastHit)(ref val8)).point);
		}
		val2 = point - val6;
		if (((Vector3)(ref val2)).magnitude < pointRadius * num2)
		{
			Vector3 val9 = val6 - point;
			Vector3 val10 = ((!flag) ? (val9 - ((Vector3)(ref val9)).normalized * pointRadius) : (val9 + ((Vector3)(ref val9)).normalized * pointRadius));
			val2 = val6 - point;
			float num6 = Vector3.Dot(((Vector3)(ref val2)).normalized, normalized);
			if (flag && num6 > 0f)
			{
				val10 = val9 - ((Vector3)(ref val9)).normalized * pointRadius;
			}
			point += val10;
		}
	}
}


using FIMSpace;
using UnityEngine;

public class FImp_ColliderData_Sphere : FImp_ColliderData_Base
{
	private float SphereRadius;

	public SphereCollider Sphere { get; private set; }

	public CircleCollider2D Sphere2D { get; private set; }

	public FImp_ColliderData_Sphere(SphereCollider collider)
	{
		Is2D = false;
		base.Transform = ((Component)collider).transform;
		base.Collider = (Collider)(object)collider;
		Sphere = collider;
		base.ColliderType = EFColliderType.Sphere;
		RefreshColliderData();
	}

	public FImp_ColliderData_Sphere(CircleCollider2D collider)
	{
		Is2D = true;
		base.Transform = ((Component)collider).transform;
		base.Collider2D = (Collider2D)(object)collider;
		Sphere2D = collider;
		base.ColliderType = EFColliderType.Sphere;
		RefreshColliderData();
	}

	public override void RefreshColliderData()
	{
		if (!base.IsStatic)
		{
			if ((Object)(object)Sphere2D == (Object)null)
			{
				SphereRadius = CalculateTrueRadiusOfSphereCollider(((Component)Sphere).transform, Sphere.radius);
				base.RefreshColliderData();
			}
			else
			{
				SphereRadius = CalculateTrueRadiusOfSphereCollider(((Component)Sphere2D).transform, Sphere2D.radius);
				base.RefreshColliderData();
			}
		}
	}

	public override bool PushIfInside(ref Vector3 point, float pointRadius, Vector3 pointOffset)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (!Is2D)
		{
			return PushOutFromSphereCollider(Sphere, pointRadius, ref point, SphereRadius, pointOffset);
		}
		return PushOutFromSphereCollider(Sphere2D, pointRadius, ref point, SphereRadius, pointOffset);
	}

	public static bool PushOutFromSphereCollider(SphereCollider sphere, float segmentColliderRadius, ref Vector3 segmentPos, Vector3 segmentOffset)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return PushOutFromSphereCollider(sphere, segmentColliderRadius, ref segmentPos, CalculateTrueRadiusOfSphereCollider(sphere), segmentOffset);
	}

	public static bool PushOutFromSphereCollider(SphereCollider sphere, float segmentColliderRadius, ref Vector3 segmentPos, float collidingSphereRadius, Vector3 segmentOffset)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)sphere).transform.position + ((Component)sphere).transform.TransformVector(sphere.center);
		float num = collidingSphereRadius + segmentColliderRadius;
		Vector3 val2 = segmentPos + segmentOffset - val;
		float sqrMagnitude = ((Vector3)(ref val2)).sqrMagnitude;
		if (sqrMagnitude > 0f && sqrMagnitude < num * num)
		{
			segmentPos = val - segmentOffset + val2 * (num / Mathf.Sqrt(sqrMagnitude));
			return true;
		}
		return false;
	}

	public static bool PushOutFromSphereCollider(CircleCollider2D sphere, float segmentColliderRadius, ref Vector3 segmentPos, float collidingSphereRadius, Vector3 segmentOffset)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)sphere).transform.position + ((Component)sphere).transform.TransformVector(Vector2.op_Implicit(((Collider2D)sphere).offset));
		val.z = 0f;
		float num = collidingSphereRadius + segmentColliderRadius;
		Vector3 val2 = segmentPos;
		val2.z = 0f;
		Vector3 val3 = val2 + segmentOffset - val;
		float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
		if (sqrMagnitude > 0f && sqrMagnitude < num * num)
		{
			segmentPos = val - segmentOffset + val3 * (num / Mathf.Sqrt(sqrMagnitude));
			return true;
		}
		return false;
	}

	public static float CalculateTrueRadiusOfSphereCollider(SphereCollider sphere)
	{
		return CalculateTrueRadiusOfSphereCollider(((Component)sphere).transform, sphere.radius);
	}

	public static float CalculateTrueRadiusOfSphereCollider(CircleCollider2D sphere)
	{
		return CalculateTrueRadiusOfSphereCollider(((Component)sphere).transform, sphere.radius);
	}

	public static float CalculateTrueRadiusOfSphereCollider(Transform transform, float componentRadius)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		float num = componentRadius;
		if (transform.lossyScale.x > transform.lossyScale.y)
		{
			if (transform.lossyScale.x > transform.lossyScale.z)
			{
				return num * transform.lossyScale.x;
			}
			return num * transform.lossyScale.z;
		}
		if (transform.lossyScale.y > transform.lossyScale.z)
		{
			return num * transform.lossyScale.y;
		}
		return num * transform.lossyScale.z;
	}
}


using FIMSpace;
using UnityEngine;

public class FImp_ColliderData_Terrain : FImp_ColliderData_Base
{
	public TerrainCollider TerrCollider { get; private set; }

	public Terrain TerrainComponent { get; private set; }

	public FImp_ColliderData_Terrain(TerrainCollider collider)
	{
		base.Collider = (Collider)(object)collider;
		base.Transform = ((Component)collider).transform;
		TerrCollider = collider;
		base.ColliderType = EFColliderType.Terrain;
		TerrainComponent = ((Component)collider).GetComponent<Terrain>();
	}

	public override bool PushIfInside(ref Vector3 segmentPosition, float segmentRadius, Vector3 segmentOffset)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		if (segmentPosition.x + segmentRadius < TerrainComponent.GetPosition().x - segmentRadius || segmentPosition.x > TerrainComponent.GetPosition().x + TerrainComponent.terrainData.size.x || segmentPosition.z + segmentRadius < TerrainComponent.GetPosition().z - segmentRadius || segmentPosition.z > TerrainComponent.GetPosition().z + TerrainComponent.terrainData.size.z)
		{
			return false;
		}
		Vector3 val = segmentPosition + segmentOffset;
		Vector3 val2 = val;
		val2.y = ((Component)TerrCollider).transform.position.y + TerrainComponent.SampleHeight(val);
		Vector3 val3 = val - val2;
		float magnitude = ((Vector3)(ref val3)).magnitude;
		float num = 1f;
		if (val.y < val2.y)
		{
			num = 4f;
		}
		else if (val.y + segmentRadius * 2f < val2.y)
		{
			num = 8f;
		}
		if (magnitude < segmentRadius * num)
		{
			Vector3 val4 = val2 - val;
			Vector3 val5 = ((!(num > 1f)) ? (val4 - ((Vector3)(ref val4)).normalized * segmentRadius) : (val4 + ((Vector3)(ref val4)).normalized * segmentRadius));
			segmentPosition += val5;
			return true;
		}
		return false;
	}

	public static void PushOutFromTerrain(TerrainCollider terrainCollider, float segmentRadius, ref Vector3 point)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		Terrain component = ((Component)terrainCollider).GetComponent<Terrain>();
		Vector3 val = point;
		val.y = ((Component)terrainCollider).transform.position.y + component.SampleHeight(point) + segmentRadius;
		Ray val2 = default(Ray);
		((Ray)(ref val2))..ctor(val, Vector3.down);
		RaycastHit val3 = default(RaycastHit);
		if (((Collider)terrainCollider).Raycast(val2, ref val3, segmentRadius * 2f))
		{
			Vector3 val4 = point - ((RaycastHit)(ref val3)).point;
			float magnitude = ((Vector3)(ref val4)).magnitude;
			float num = 1f;
			if (((RaycastHit)(ref val3)).point.y > point.y + segmentRadius * 0.9f)
			{
				num = 8f;
			}
			else if (((RaycastHit)(ref val3)).point.y > point.y)
			{
				num = 4f;
			}
			if (magnitude < segmentRadius * num)
			{
				Vector3 val5 = ((RaycastHit)(ref val3)).point - point;
				Vector3 val6 = ((!(num > 1f)) ? (val5 - ((Vector3)(ref val5)).normalized * segmentRadius) : (val5 + ((Vector3)(ref val5)).normalized * segmentRadius));
				point += val6;
			}
		}
	}
}


using UnityEngine;

public class FDebug_PerformanceTest
{
	public void ResetMinMax()
	{
	}

	public void Start(GameObject owner, bool onlyIfSelected = true)
	{
	}

	public void Pause()
	{
	}

	public void Continue()
	{
	}

	public void Finish(bool onlyIfSelected = true)
	{
	}
}


using System;
using System.Diagnostics;
using UnityEngine;

public static class FEditor_OneShotLog
{
	public static bool CanDrawLog(string id, int delayToNextCallInSeconds = int.MaxValue, int callLimitBeforeTimeMove = 1, int logSeparation = 0)
	{
		int id2 = Process.GetCurrentProcess().Id;
		if (PlayerPrefs.GetInt(id + "s", 0) != id2)
		{
			PlayerPrefs.SetInt(id + "s", id2);
			PlayerPrefs.SetString(id + "acc", DateTime.Now.ToBinary().ToString());
			PlayerPrefs.SetInt(id + "counter", 0);
			PlayerPrefs.SetInt(id + "sep", logSeparation);
			if (delayToNextCallInSeconds == int.MaxValue)
			{
				return true;
			}
		}
		else if (delayToNextCallInSeconds == int.MaxValue)
		{
			return false;
		}
		string @string = PlayerPrefs.GetString(id + "acc");
		int num = PlayerPrefs.GetInt(id + "counter");
		int @int = PlayerPrefs.GetInt(id + "sep");
		if (long.TryParse(@string, out var result))
		{
			DateTime value = DateTime.FromBinary(result);
			if (DateTime.Now.Subtract(value).TotalSeconds > (double)delayToNextCallInSeconds)
			{
				PlayerPrefs.SetInt(id + "counter", 0);
				num = 0;
				PlayerPrefs.SetString(id + "acc", DateTime.Now.ToBinary().ToString());
			}
			@int++;
			PlayerPrefs.SetInt(id + "sep", @int);
			if (@int >= logSeparation)
			{
				@int = 0;
				PlayerPrefs.SetInt(id + "sep", @int);
				num++;
				PlayerPrefs.SetInt(id + "counter", num);
				if (num - 1 < callLimitBeforeTimeMove)
				{
					return true;
				}
			}
			return false;
		}
		return false;
	}

	public static bool EditorCanDrawLog(string id, int delayToNextCallInSeconds = int.MaxValue, int callLimitBeforeTimeMove = 1, int logSeparation = 0)
	{
		return false;
	}
}


using UnityEngine;

public class FEditor_StylesIn
{
	public static GUIStyle GrayBackground => Style(Color32.op_Implicit(new Color32((byte)128, (byte)128, (byte)127, (byte)76)));

	public static GUIStyle LGrayBackground => Style(Color32.op_Implicit(new Color32((byte)128, (byte)128, (byte)127, (byte)36)));

	public static GUIStyle LBlueBackground => Style(Color32.op_Implicit(new Color32((byte)0, (byte)128, byte.MaxValue, (byte)12)));

	public static GUIStyle LNavy => Style(Color32.op_Implicit(new Color32((byte)167, (byte)228, (byte)243, (byte)44)));

	public static GUIStyle Emerald => Style(Color32.op_Implicit(new Color32((byte)0, (byte)200, (byte)100, (byte)44)));

	public static GUIStyle GreenBackground => Style(Color32.op_Implicit(new Color32((byte)0, (byte)225, (byte)86, (byte)45)));

	public static GUIStyle BlueBackground => Style(Color32.op_Implicit(new Color32((byte)0, (byte)128, byte.MaxValue, (byte)76)));

	public static GUIStyle RedBackground => Style(Color32.op_Implicit(new Color32((byte)225, (byte)72, (byte)72, (byte)45)));

	public static GUIStyle YellowBackground => Style(Color32.op_Implicit(new Color32((byte)225, (byte)244, (byte)11, (byte)45)));

	public static GUIStyle Style(Color bgColor)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Expected O, but got Unknown
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		GUIStyle val = new GUIStyle(GUI.skin.box);
		Color[] pixels = (Color[])(object)new Color[1] { bgColor };
		Texture2D val2 = new Texture2D(1, 1);
		val2.SetPixels(pixels);
		val2.Apply();
		val.normal.background = val2;
		return val;
	}

	public static void DrawUILine(Color color, int thickness = 2, int padding = 10)
	{
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class FGUI_Finders
{
	public static Component FoundAnimator;

	private static bool checkForAnim = true;

	private static int clicks = 0;

	public static void ResetFinders(bool resetClicks = true)
	{
		checkForAnim = true;
		FoundAnimator = null;
		if (resetClicks)
		{
			clicks = 0;
		}
	}

	public static bool CheckForAnimator(GameObject root, bool needAnimatorBox = true, bool drawInactiveWarning = true, int clicksTohide = 1)
	{
		bool flag = false;
		if (checkForAnim)
		{
			FoundAnimator = SearchForParentWithAnimator(root);
		}
		if (Object.op_Implicit((Object)(object)FoundAnimator))
		{
			Component foundAnimator = FoundAnimator;
			Animation val = (Animation)(object)((foundAnimator is Animation) ? foundAnimator : null);
			Component foundAnimator2 = FoundAnimator;
			Animator val2 = (Animator)(object)((foundAnimator2 is Animator) ? foundAnimator2 : null);
			if (Object.op_Implicit((Object)(object)val) && ((Behaviour)val).enabled)
			{
				flag = true;
			}
			if (Object.op_Implicit((Object)(object)val2))
			{
				if (((Behaviour)val2).enabled)
				{
					flag = true;
				}
				if ((Object)(object)val2.runtimeAnimatorController == (Object)null)
				{
					drawInactiveWarning = false;
					flag = false;
				}
			}
			if (needAnimatorBox && drawInactiveWarning && flag)
			{
			}
		}
		else if (needAnimatorBox)
		{
			_ = clicks;
		}
		checkForAnim = false;
		return flag;
	}

	public static Component SearchForParentWithAnimator(GameObject root)
	{
		Animation componentInChildren = root.GetComponentInChildren<Animation>();
		if (Object.op_Implicit((Object)(object)componentInChildren))
		{
			return (Component)(object)componentInChildren;
		}
		Animator componentInChildren2 = root.GetComponentInChildren<Animator>();
		if (Object.op_Implicit((Object)(object)componentInChildren2))
		{
			return (Component)(object)componentInChildren2;
		}
		if ((Object)(object)root.transform.parent != (Object)null)
		{
			Transform parent = root.transform.parent;
			while ((Object)(object)parent != (Object)null)
			{
				componentInChildren = ((Component)parent).GetComponent<Animation>();
				if (Object.op_Implicit((Object)(object)componentInChildren))
				{
					return (Component)(object)componentInChildren;
				}
				componentInChildren2 = ((Component)parent).GetComponent<Animator>();
				if (Object.op_Implicit((Object)(object)componentInChildren2))
				{
					return (Component)(object)componentInChildren2;
				}
				parent = parent.parent;
			}
		}
		return null;
	}

	public static SkinnedMeshRenderer GetBoneSearchArray(Transform root)
	{
		List<SkinnedMeshRenderer> list = new List<SkinnedMeshRenderer>();
		SkinnedMeshRenderer val = null;
		Transform[] componentsInChildren = ((Component)root).GetComponentsInChildren<Transform>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			SkinnedMeshRenderer component = ((Component)componentsInChildren[i]).GetComponent<SkinnedMeshRenderer>();
			if (Object.op_Implicit((Object)(object)component))
			{
				list.Add(component);
			}
		}
		if (list.Count == 0)
		{
			Transform val2 = root;
			while ((Object)(object)val2 != (Object)null && !((Object)(object)val2.parent == (Object)null))
			{
				val2 = val2.parent;
			}
			componentsInChildren = ((Component)val2).GetComponentsInChildren<Transform>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				SkinnedMeshRenderer component2 = ((Component)componentsInChildren[i]).GetComponent<SkinnedMeshRenderer>();
				if (!list.Contains(component2) && Object.op_Implicit((Object)(object)component2))
				{
					list.Add(component2);
				}
			}
		}
		if (list.Count > 1)
		{
			val = list[0];
			for (int j = 1; j < list.Count; j++)
			{
				if (list[j].bones.Length > val.bones.Length)
				{
					val = list[j];
				}
			}
		}
		else if (list.Count > 0)
		{
			val = list[0];
		}
		if ((Object)(object)val == (Object)null)
		{
			return null;
		}
		return val;
	}

	public static bool IsChildOf(Transform child, Transform rootParent)
	{
		Transform val = child;
		while ((Object)(object)val != (Object)null && (Object)(object)val != (Object)(object)rootParent)
		{
			val = val.parent;
		}
		if ((Object)(object)val == (Object)null)
		{
			return false;
		}
		return true;
	}

	public static Transform GetLastChild(Transform rootParent)
	{
		Transform val = rootParent;
		while (val.childCount > 0)
		{
			val = val.GetChild(0);
		}
		return val;
	}

	public static bool? IsRightOrLeft(string name, bool includeNotSure = false)
	{
		string text = name.ToLower();
		if (text.Contains("right"))
		{
			return true;
		}
		if (text.Contains("left"))
		{
			return false;
		}
		if (text.StartsWith("r_"))
		{
			return true;
		}
		if (text.StartsWith("l_"))
		{
			return false;
		}
		if (text.EndsWith("_r"))
		{
			return true;
		}
		if (text.EndsWith("_l"))
		{
			return false;
		}
		if (text.StartsWith("r."))
		{
			return true;
		}
		if (text.StartsWith("l."))
		{
			return false;
		}
		if (text.EndsWith(".r"))
		{
			return true;
		}
		if (text.EndsWith(".l"))
		{
			return false;
		}
		if (includeNotSure)
		{
			if (text.Contains("r_"))
			{
				return true;
			}
			if (text.Contains("l_"))
			{
				return false;
			}
			if (text.Contains("_r"))
			{
				return true;
			}
			if (text.Contains("_l"))
			{
				return false;
			}
			if (text.Contains("r."))
			{
				return true;
			}
			if (text.Contains("l."))
			{
				return false;
			}
			if (text.Contains(".r"))
			{
				return true;
			}
			if (text.Contains(".l"))
			{
				return false;
			}
		}
		return null;
	}

	public static bool? IsRightOrLeft(Transform child, Transform itsRoot)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = itsRoot.InverseTransformPoint(child.position);
		if (val.x < 0f)
		{
			return false;
		}
		if (val.x > 0f)
		{
			return true;
		}
		return null;
	}

	public static bool HaveKey(string text, string[] keys)
	{
		for (int i = 0; i < keys.Length; i++)
		{
			if (text.Contains(keys[i]))
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public abstract class FIK_ProcessorBase
{
	[Range(0f, 1f)]
	public float IKWeight = 1f;

	public Vector3 IKTargetPosition;

	public Quaternion IKTargetRotation;

	public Vector3 LastLocalDirection;

	public Vector3 LocalDirection;

	[NonSerialized]
	public bool CallPreCalibrate = true;

	public float fullLength { get; protected set; }

	public bool Initialized { get; protected set; }

	public FIK_IKBoneBase[] Bones { get; protected set; }

	public FIK_IKBoneBase StartBone => Bones[0];

	public FIK_IKBoneBase EndBone => Bones[Bones.Length - 1];

	public Quaternion StartBoneRotationOffset { get; set; } = Quaternion.identity;

	public virtual void Init(Transform root)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		StartBoneRotationOffset = Quaternion.identity;
	}

	public virtual void PreCalibrate()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (CallPreCalibrate)
		{
			for (FIK_IKBoneBase fIK_IKBoneBase = Bones[0]; fIK_IKBoneBase != null; fIK_IKBoneBase = fIK_IKBoneBase.Child)
			{
				fIK_IKBoneBase.transform.localRotation = fIK_IKBoneBase.InitialLocalRotation;
			}
		}
	}

	public virtual void Update()
	{
	}

	public static float EaseInOutQuint(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value * value * value + 2f) + start;
	}
}


using System;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public abstract class FIK_IKBoneBase
{
	public float sqrMagn = 0.1f;

	public float BoneLength = 0.1f;

	public float MotionWeight = 1f;

	public Vector3 InitialLocalPosition;

	public Quaternion InitialLocalRotation;

	public Quaternion LastKeyLocalRotation;

	public FIK_IKBoneBase Child { get; private set; }

	public Transform transform { get; protected set; }

	public FIK_IKBoneBase(Transform t)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		transform = t;
		if (Object.op_Implicit((Object)(object)transform))
		{
			InitialLocalPosition = transform.localPosition;
			InitialLocalRotation = transform.localRotation;
			LastKeyLocalRotation = t.localRotation;
		}
	}

	public virtual void SetChild(FIK_IKBoneBase child)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (child != null)
		{
			Child = child;
			Vector3 val = child.transform.position - transform.position;
			sqrMagn = ((Vector3)(ref val)).sqrMagnitude;
			val = child.transform.position - transform.position;
			BoneLength = ((Vector3)(ref val)).sqrMagnitude;
		}
	}
}


using System;
using FIMSpace;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class FIK_CCDProcessor : FIK_ProcessorBase
{
	[Serializable]
	public class CCDIKBone : FIK_IKBoneBase
	{
		[Range(0f, 180f)]
		public float AngleLimit = 45f;

		[Range(0f, 180f)]
		public float TwistAngleLimit = 5f;

		public Vector3 ForwardOrientation;

		public float FrameWorldLength = 1f;

		public Vector2 HingeLimits = Vector2.zero;

		public Quaternion PreviousHingeRotation;

		public float PreviousHingeAngle;

		public Vector3 LastIKLocPosition;

		public Quaternion LastIKLocRotation;

		public CCDIKBone IKParent { get; private set; }

		public CCDIKBone IKChild { get; private set; }

		public CCDIKBone(Transform t)
			: base(t)
		{
		}//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)


		public void Init(CCDIKBone child, CCDIKBone parent)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			LastIKLocPosition = base.transform.localPosition;
			IKParent = parent;
			if (child != null)
			{
				SetChild(child);
			}
			IKChild = child;
		}

		public override void SetChild(FIK_IKBoneBase child)
		{
			base.SetChild(child);
		}

		public void AngleLimiting()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			Quaternion val = Quaternion.Inverse(LastKeyLocalRotation) * base.transform.localRotation;
			Quaternion val2 = val;
			if (Vector2.op_Implicit(HingeLimits).VIsZero())
			{
				if (AngleLimit < 180f)
				{
					val2 = LimitSpherical(val2);
				}
				if (TwistAngleLimit < 180f)
				{
					val2 = LimitZ(val2);
				}
			}
			else
			{
				val2 = LimitHinge(val2);
			}
			if (!val2.QIsSame(val))
			{
				base.transform.localRotation = LastKeyLocalRotation * val2;
			}
		}

		private Quaternion LimitSpherical(Quaternion rotation)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			if (rotation.QIsZero())
			{
				return rotation;
			}
			Vector3 val = rotation * ForwardOrientation;
			Quaternion val2 = Quaternion.RotateTowards(Quaternion.identity, Quaternion.FromToRotation(ForwardOrientation, val), AngleLimit);
			return Quaternion.FromToRotation(val, val2 * ForwardOrientation) * rotation;
		}

		private Quaternion LimitZ(Quaternion currentRotation)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(ForwardOrientation.y, ForwardOrientation.z, ForwardOrientation.x);
			Vector3 val2 = currentRotation * ForwardOrientation;
			Vector3 val3 = val;
			Vector3.OrthoNormalize(ref val2, ref val3);
			val = currentRotation * val;
			Vector3.OrthoNormalize(ref val2, ref val);
			Quaternion val4 = Quaternion.FromToRotation(val, val3) * currentRotation;
			if (TwistAngleLimit <= 0f)
			{
				return val4;
			}
			return Quaternion.RotateTowards(val4, currentRotation, TwistAngleLimit);
		}

		private Quaternion LimitHinge(Quaternion rotation)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			Quaternion val = Quaternion.FromToRotation(rotation * ForwardOrientation, ForwardOrientation) * rotation * Quaternion.Inverse(PreviousHingeRotation);
			float num = Quaternion.Angle(Quaternion.identity, val);
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(ForwardOrientation.z, ForwardOrientation.x, ForwardOrientation.y);
			Vector3 val3 = Vector3.Cross(val2, ForwardOrientation);
			if (Vector3.Dot(val * val2, val3) > 0f)
			{
				num = 0f - num;
			}
			PreviousHingeAngle = Mathf.Clamp(PreviousHingeAngle + num, HingeLimits.x, HingeLimits.y);
			PreviousHingeRotation = Quaternion.AngleAxis(PreviousHingeAngle, ForwardOrientation);
			return PreviousHingeRotation;
		}
	}

	public CCDIKBone[] IKBones;

	public bool ContinousSolving = true;

	[Range(0f, 1f)]
	public float SyncWithAnimator = 1f;

	[Range(1f, 12f)]
	public int ReactionQuality = 2;

	[Range(0f, 1f)]
	public float Smoothing;

	[Range(0f, 1.5f)]
	public float StretchToTarget;

	public AnimationCurve StretchCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public bool Use2D;

	public bool Invert;

	public CCDIKBone StartIKBone => IKBones[0];

	public CCDIKBone EndIKBone => IKBones[IKBones.Length - 1];

	public float ActiveLength { get; private set; }

	public FIK_CCDProcessor(Transform[] bonesChain)
	{
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		IKBones = new CCDIKBone[bonesChain.Length];
		FIK_IKBoneBase[] bones = new CCDIKBone[IKBones.Length];
		base.Bones = bones;
		for (int i = 0; i < bonesChain.Length; i++)
		{
			IKBones[i] = new CCDIKBone(bonesChain[i]);
			base.Bones[i] = IKBones[i];
		}
		IKTargetPosition = base.EndBone.transform.position;
		IKTargetRotation = base.EndBone.transform.rotation;
	}

	public override void Init(Transform root)
	{
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		if (base.Initialized)
		{
			return;
		}
		base.fullLength = 0f;
		for (int i = 0; i < base.Bones.Length; i++)
		{
			CCDIKBone cCDIKBone = IKBones[i];
			CCDIKBone child = null;
			CCDIKBone parent = null;
			if (i > 0)
			{
				parent = IKBones[i - 1];
			}
			if (i < base.Bones.Length - 1)
			{
				child = IKBones[i + 1];
			}
			if (i < base.Bones.Length - 1)
			{
				IKBones[i].Init(child, parent);
				base.fullLength += cCDIKBone.BoneLength;
				cCDIKBone.ForwardOrientation = Quaternion.Inverse(cCDIKBone.transform.rotation) * (IKBones[i + 1].transform.position - cCDIKBone.transform.position);
			}
			else
			{
				IKBones[i].Init(child, parent);
				cCDIKBone.ForwardOrientation = Quaternion.Inverse(cCDIKBone.transform.rotation) * (IKBones[IKBones.Length - 1].transform.position - IKBones[0].transform.position);
			}
		}
		base.Initialized = true;
	}

	public override void Update()
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_065a: Unknown result type (might be due to invalid IL or missing references)
		//IL_065f: Unknown result type (might be due to invalid IL or missing references)
		//IL_066b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0670: Unknown result type (might be due to invalid IL or missing references)
		//IL_0676: Unknown result type (might be due to invalid IL or missing references)
		//IL_067c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0681: Unknown result type (might be due to invalid IL or missing references)
		//IL_0686: Unknown result type (might be due to invalid IL or missing references)
		//IL_068b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0694: Unknown result type (might be due to invalid IL or missing references)
		//IL_0699: Unknown result type (might be due to invalid IL or missing references)
		//IL_069c: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0523: Unknown result type (might be due to invalid IL or missing references)
		//IL_052e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0533: Unknown result type (might be due to invalid IL or missing references)
		//IL_0538: Unknown result type (might be due to invalid IL or missing references)
		//IL_053c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0541: Unknown result type (might be due to invalid IL or missing references)
		//IL_0549: Unknown result type (might be due to invalid IL or missing references)
		//IL_054e: Unknown result type (might be due to invalid IL or missing references)
		//IL_055b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0560: Unknown result type (might be due to invalid IL or missing references)
		//IL_0562: Unknown result type (might be due to invalid IL or missing references)
		//IL_0564: Unknown result type (might be due to invalid IL or missing references)
		//IL_0566: Unknown result type (might be due to invalid IL or missing references)
		//IL_056b: Unknown result type (might be due to invalid IL or missing references)
		//IL_056f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0574: Unknown result type (might be due to invalid IL or missing references)
		//IL_0576: Unknown result type (might be due to invalid IL or missing references)
		//IL_0578: Unknown result type (might be due to invalid IL or missing references)
		//IL_0310: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0606: Unknown result type (might be due to invalid IL or missing references)
		//IL_060b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0610: Unknown result type (might be due to invalid IL or missing references)
		//IL_0615: Unknown result type (might be due to invalid IL or missing references)
		//IL_0621: Unknown result type (might be due to invalid IL or missing references)
		//IL_0623: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_0415: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_0428: Unknown result type (might be due to invalid IL or missing references)
		//IL_0430: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_0449: Unknown result type (might be due to invalid IL or missing references)
		//IL_0450: Unknown result type (might be due to invalid IL or missing references)
		//IL_046a: Unknown result type (might be due to invalid IL or missing references)
		//IL_046f: Unknown result type (might be due to invalid IL or missing references)
		//IL_047a: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Initialized || IKWeight <= 0f)
		{
			return;
		}
		CCDIKBone cCDIKBone = IKBones[0];
		if (ContinousSolving)
		{
			while (cCDIKBone != null)
			{
				cCDIKBone.LastKeyLocalRotation = cCDIKBone.transform.localRotation;
				cCDIKBone.transform.localPosition = cCDIKBone.LastIKLocPosition;
				cCDIKBone.transform.localRotation = cCDIKBone.LastIKLocRotation;
				cCDIKBone = cCDIKBone.IKChild;
			}
		}
		else if (SyncWithAnimator > 0f)
		{
			while (cCDIKBone != null)
			{
				cCDIKBone.LastKeyLocalRotation = cCDIKBone.transform.localRotation;
				cCDIKBone = cCDIKBone.IKChild;
			}
		}
		if (ReactionQuality < 0)
		{
			ReactionQuality = 1;
		}
		Vector3 val = Vector3.zero;
		if (ReactionQuality > 1)
		{
			val = GetGoalPivotOffset();
		}
		for (int i = 0; i < ReactionQuality && (i < 1 || ((Vector3)(ref val)).sqrMagnitude != 0f || !(Smoothing > 0f) || !(GetVelocityDifference() < Smoothing * Smoothing)); i++)
		{
			LastLocalDirection = RefreshLocalDirection();
			Vector3 val2 = IKTargetPosition + val;
			cCDIKBone = IKBones[IKBones.Length - 2];
			if (!Use2D)
			{
				if (!Invert)
				{
					while (cCDIKBone != null)
					{
						float num = cCDIKBone.MotionWeight * IKWeight;
						if (num > 0f)
						{
							Quaternion val3 = Quaternion.FromToRotation(base.Bones[base.Bones.Length - 1].transform.position - cCDIKBone.transform.position, val2 - cCDIKBone.transform.position) * cCDIKBone.transform.rotation;
							if (num < 1f)
							{
								cCDIKBone.transform.rotation = Quaternion.Lerp(cCDIKBone.transform.rotation, val3, num);
							}
							else
							{
								cCDIKBone.transform.rotation = val3;
							}
						}
						cCDIKBone.AngleLimiting();
						cCDIKBone = cCDIKBone.IKParent;
					}
					continue;
				}
				while (cCDIKBone != null)
				{
					cCDIKBone.AngleLimiting();
					cCDIKBone = cCDIKBone.IKParent;
				}
				for (cCDIKBone = IKBones[0]; cCDIKBone != null; cCDIKBone = cCDIKBone.IKChild)
				{
					float num2 = cCDIKBone.MotionWeight * IKWeight;
					if (num2 > 0f)
					{
						Quaternion val4 = Quaternion.FromToRotation(base.Bones[base.Bones.Length - 1].transform.position - cCDIKBone.transform.position, val2 - cCDIKBone.transform.position) * cCDIKBone.transform.rotation;
						if (num2 < 1f)
						{
							cCDIKBone.transform.rotation = Quaternion.Lerp(cCDIKBone.transform.rotation, val4, num2);
						}
						else
						{
							cCDIKBone.transform.rotation = val4;
						}
					}
				}
				continue;
			}
			if (!Invert)
			{
				while (cCDIKBone != null)
				{
					float num3 = cCDIKBone.MotionWeight * IKWeight;
					if (num3 > 0f)
					{
						Vector3 val5 = base.Bones[base.Bones.Length - 1].transform.position - cCDIKBone.transform.position;
						Vector3 val6 = val2 - cCDIKBone.transform.position;
						cCDIKBone.transform.rotation = Quaternion.AngleAxis(Mathf.DeltaAngle(Mathf.Atan2(val5.x, val5.y) * 57.29578f, Mathf.Atan2(val6.x, val6.y) * 57.29578f) * num3, Vector3.back) * cCDIKBone.transform.rotation;
					}
					cCDIKBone.AngleLimiting();
					cCDIKBone = cCDIKBone.IKParent;
				}
				continue;
			}
			while (cCDIKBone != null)
			{
				cCDIKBone.AngleLimiting();
				cCDIKBone = cCDIKBone.IKParent;
			}
			for (cCDIKBone = IKBones[0]; cCDIKBone != null; cCDIKBone = cCDIKBone.IKChild)
			{
				float num4 = cCDIKBone.MotionWeight * IKWeight;
				if (num4 > 0f)
				{
					Vector3 val7 = base.Bones[base.Bones.Length - 1].transform.position - cCDIKBone.transform.position;
					Vector3 val8 = val2 - cCDIKBone.transform.position;
					cCDIKBone.transform.rotation = Quaternion.AngleAxis(Mathf.DeltaAngle(Mathf.Atan2(val7.x, val7.y) * 57.29578f, Mathf.Atan2(val8.x, val8.y) * 57.29578f) * num4, Vector3.back) * cCDIKBone.transform.rotation;
				}
			}
		}
		LastLocalDirection = RefreshLocalDirection();
		if (StretchToTarget > 0f)
		{
			Vector3 val9 = IKTargetPosition - EndIKBone.transform.position;
			float num5 = ((Vector3)(ref val9)).magnitude;
			ActiveLength = Mathf.Epsilon;
			cCDIKBone = IKBones[0];
			int num6 = 0;
			float num7 = Mathf.Max(1f, StretchToTarget);
			while (cCDIKBone.IKChild != null && !(num5 <= 0f))
			{
				Vector3 val10 = IKTargetPosition - cCDIKBone.transform.position;
				Vector3 normalized = ((Vector3)(ref val10)).normalized;
				Vector3 position = cCDIKBone.transform.position;
				Vector3 position2 = cCDIKBone.IKChild.transform.position;
				Vector3 val11 = position2 - position;
				Vector3 normalized2 = ((Vector3)(ref val11)).normalized;
				float num8 = Vector3.Dot(normalized2, normalized);
				if (num8 > 0f)
				{
					float num9 = cCDIKBone.BoneLength * num7 * num8;
					if (num9 > num5)
					{
						num9 = num5;
					}
					Vector3 val12 = position2 + normalized2 * num9;
					cCDIKBone.IKChild.transform.position = Vector3.Lerp(position2, val12, StretchToTarget);
					cCDIKBone.transform.rotation = cCDIKBone.transform.rotation * Quaternion.FromToRotation(position2 - position, cCDIKBone.Child.transform.position - cCDIKBone.transform.position);
					num5 -= Vector3.Distance(position2, val12);
				}
				cCDIKBone = cCDIKBone.IKChild;
				num6++;
			}
		}
		for (cCDIKBone = IKBones[0]; cCDIKBone != null; cCDIKBone = cCDIKBone.IKChild)
		{
			cCDIKBone.LastIKLocRotation = cCDIKBone.transform.localRotation;
			cCDIKBone.LastIKLocPosition = cCDIKBone.transform.localPosition;
			Quaternion val13 = cCDIKBone.LastIKLocRotation * Quaternion.Inverse(cCDIKBone.InitialLocalRotation);
			cCDIKBone.transform.localRotation = Quaternion.Lerp(cCDIKBone.LastIKLocRotation, val13 * cCDIKBone.LastKeyLocalRotation, SyncWithAnimator);
			if (IKWeight < 1f)
			{
				cCDIKBone.transform.localRotation = Quaternion.Lerp(cCDIKBone.LastKeyLocalRotation, cCDIKBone.transform.localRotation, IKWeight);
			}
		}
	}

	protected Vector3 GetGoalPivotOffset()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if (!GoalPivotOffsetDetected())
		{
			return Vector3.zero;
		}
		Vector3 val = IKTargetPosition - IKBones[0].transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(normalized.y, normalized.z, normalized.x);
		if (IKBones[IKBones.Length - 2].AngleLimit < 180f || IKBones[IKBones.Length - 2].TwistAngleLimit < 180f)
		{
			val2 = IKBones[IKBones.Length - 2].transform.rotation * IKBones[IKBones.Length - 2].ForwardOrientation;
		}
		return Vector3.Cross(normalized, val2) * IKBones[IKBones.Length - 2].BoneLength * 0.5f;
	}

	private bool GoalPivotOffsetDetected()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Initialized)
		{
			return false;
		}
		Vector3 val = base.Bones[base.Bones.Length - 1].transform.position - base.Bones[0].transform.position;
		Vector3 val2 = IKTargetPosition - base.Bones[0].transform.position;
		float magnitude = ((Vector3)(ref val)).magnitude;
		float magnitude2 = ((Vector3)(ref val2)).magnitude;
		if (magnitude2 == 0f)
		{
			return false;
		}
		if (magnitude == 0f)
		{
			return false;
		}
		if (magnitude < magnitude2)
		{
			return false;
		}
		if (magnitude < base.fullLength - base.Bones[base.Bones.Length - 2].BoneLength * 0.1f)
		{
			return false;
		}
		if (magnitude2 > magnitude)
		{
			return false;
		}
		if (Vector3.Dot(val / magnitude, val2 / magnitude2) < 0.999f)
		{
			return false;
		}
		return true;
	}

	private Vector3 RefreshLocalDirection()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		LocalDirection = base.Bones[0].transform.InverseTransformDirection(base.Bones[base.Bones.Length - 1].transform.position - base.Bones[0].transform.position);
		return LocalDirection;
	}

	private float GetVelocityDifference()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.SqrMagnitude(LocalDirection - LastLocalDirection);
	}

	public void AutoLimitAngle(float angleLimit = 60f, float twistAngleLimit = 50f)
	{
		if (IKBones == null)
		{
			return;
		}
		float num = 1f / (float)IKBones.Length;
		if (Invert)
		{
			for (int i = 0; i < IKBones.Length; i++)
			{
				IKBones[i].AngleLimit = angleLimit * Mathf.Min(1f, (1f - (float)(i + 1) * num) * 3f);
				IKBones[i].TwistAngleLimit = twistAngleLimit * Mathf.Min(1f, (1f - (float)(i + 1) * num) * 4.5f);
			}
		}
		else
		{
			for (int j = 0; j < IKBones.Length; j++)
			{
				IKBones[j].AngleLimit = angleLimit * Mathf.Min(1f, (float)(j + 1) * num * 3f);
				IKBones[j].TwistAngleLimit = twistAngleLimit * Mathf.Min(1f, (float)(j + 1) * num * 4.5f);
			}
		}
	}

	public void AutoWeightBones(float baseValue = 1f)
	{
		float num = baseValue / ((float)base.Bones.Length * 1.3f);
		if (Invert)
		{
			for (int i = 0; i < base.Bones.Length; i++)
			{
				base.Bones[i].MotionWeight = 1f - (baseValue - num * (float)i);
			}
		}
		else
		{
			for (int j = 0; j < base.Bones.Length; j++)
			{
				base.Bones[j].MotionWeight = baseValue - num * (float)j;
			}
		}
	}

	public void AutoWeightBones(AnimationCurve weightCurve)
	{
		if (Invert)
		{
			for (int i = 0; i < base.Bones.Length; i++)
			{
				base.Bones[i].MotionWeight = Mathf.Clamp(1f - weightCurve.Evaluate((float)i / (float)base.Bones.Length), 0f, 1f);
			}
		}
		else
		{
			for (int j = 0; j < base.Bones.Length; j++)
			{
				base.Bones[j].MotionWeight = Mathf.Clamp(weightCurve.Evaluate((float)j / (float)base.Bones.Length), 0f, 1f);
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class CCDIKBone : FIK_IKBoneBase
{
	[Range(0f, 180f)]
	public float AngleLimit = 45f;

	[Range(0f, 180f)]
	public float TwistAngleLimit = 5f;

	public Vector3 ForwardOrientation;

	public float FrameWorldLength = 1f;

	public Vector2 HingeLimits = Vector2.zero;

	public Quaternion PreviousHingeRotation;

	public float PreviousHingeAngle;

	public Vector3 LastIKLocPosition;

	public Quaternion LastIKLocRotation;

	public CCDIKBone IKParent { get; private set; }

	public CCDIKBone IKChild { get; private set; }

	public CCDIKBone(Transform t)
		: base(t)
	{
	}//IL_0022: Unknown result type (might be due to invalid IL or missing references)
	//IL_0027: Unknown result type (might be due to invalid IL or missing references)


	public void Init(CCDIKBone child, CCDIKBone parent)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		LastIKLocPosition = base.transform.localPosition;
		IKParent = parent;
		if (child != null)
		{
			SetChild(child);
		}
		IKChild = child;
	}

	public override void SetChild(FIK_IKBoneBase child)
	{
		base.SetChild(child);
	}

	public void AngleLimiting()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.Inverse(LastKeyLocalRotation) * base.transform.localRotation;
		Quaternion val2 = val;
		if (Vector2.op_Implicit(HingeLimits).VIsZero())
		{
			if (AngleLimit < 180f)
			{
				val2 = LimitSpherical(val2);
			}
			if (TwistAngleLimit < 180f)
			{
				val2 = LimitZ(val2);
			}
		}
		else
		{
			val2 = LimitHinge(val2);
		}
		if (!val2.QIsSame(val))
		{
			base.transform.localRotation = LastKeyLocalRotation * val2;
		}
	}

	private Quaternion LimitSpherical(Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (rotation.QIsZero())
		{
			return rotation;
		}
		Vector3 val = rotation * ForwardOrientation;
		Quaternion val2 = Quaternion.RotateTowards(Quaternion.identity, Quaternion.FromToRotation(ForwardOrientation, val), AngleLimit);
		return Quaternion.FromToRotation(val, val2 * ForwardOrientation) * rotation;
	}

	private Quaternion LimitZ(Quaternion currentRotation)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(ForwardOrientation.y, ForwardOrientation.z, ForwardOrientation.x);
		Vector3 val2 = currentRotation * ForwardOrientation;
		Vector3 val3 = val;
		Vector3.OrthoNormalize(ref val2, ref val3);
		val = currentRotation * val;
		Vector3.OrthoNormalize(ref val2, ref val);
		Quaternion val4 = Quaternion.FromToRotation(val, val3) * currentRotation;
		if (TwistAngleLimit <= 0f)
		{
			return val4;
		}
		return Quaternion.RotateTowards(val4, currentRotation, TwistAngleLimit);
	}

	private Quaternion LimitHinge(Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.FromToRotation(rotation * ForwardOrientation, ForwardOrientation) * rotation * Quaternion.Inverse(PreviousHingeRotation);
		float num = Quaternion.Angle(Quaternion.identity, val);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(ForwardOrientation.z, ForwardOrientation.x, ForwardOrientation.y);
		Vector3 val3 = Vector3.Cross(val2, ForwardOrientation);
		if (Vector3.Dot(val * val2, val3) > 0f)
		{
			num = 0f - num;
		}
		PreviousHingeAngle = Mathf.Clamp(PreviousHingeAngle + num, HingeLimits.x, HingeLimits.y);
		PreviousHingeRotation = Quaternion.AngleAxis(PreviousHingeAngle, ForwardOrientation);
		return PreviousHingeRotation;
	}
}


using System;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class FimpIK_Limb : FIK_ProcessorBase
{
	public class IKBone : FIK_IKBoneBase
	{
		[SerializeField]
		private Quaternion targetToLocalSpace;

		[SerializeField]
		private Vector3 defaultLocalPoleNormal;

		public Vector3 right { get; private set; }

		public Vector3 up { get; private set; }

		public Vector3 forward { get; private set; }

		public Vector3 srcPosition { get; private set; }

		public Quaternion srcRotation { get; private set; }

		public IKBone(Transform t)
			: base(t)
		{
		}

		public void Init(Transform root, Vector3 childPosition, Vector3 orientationNormal)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			RefreshOrientations(childPosition, orientationNormal);
			Vector3 val = childPosition - base.transform.position;
			sqrMagn = ((Vector3)(ref val)).sqrMagnitude;
			LastKeyLocalRotation = base.transform.localRotation;
			right = base.transform.InverseTransformDirection(root.right);
			up = base.transform.InverseTransformDirection(root.up);
			forward = base.transform.InverseTransformDirection(root.forward);
			CaptureSourceAnimation();
		}

		public void RefreshOrientations(Vector3 childPosition, Vector3 orientationNormal)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			if (!(orientationNormal == Vector3.zero))
			{
				Vector3 val = childPosition - base.transform.position;
				((Vector3)(ref val)).Normalize();
				if (!(val == Vector3.zero))
				{
					Quaternion rotation = Quaternion.LookRotation(val, orientationNormal);
					targetToLocalSpace = RotationToLocal(base.transform.rotation, rotation);
					defaultLocalPoleNormal = Quaternion.Inverse(base.transform.rotation) * orientationNormal;
				}
			}
		}

		public void CaptureSourceAnimation()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			srcPosition = base.transform.position;
			srcRotation = base.transform.rotation;
		}

		public static Quaternion RotationToLocal(Quaternion parent, Quaternion rotation)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return Quaternion.Inverse(Quaternion.Inverse(parent) * rotation);
		}

		public Quaternion GetRotation(Vector3 direction, Vector3 orientationNormal)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			return Quaternion.LookRotation(direction, orientationNormal) * targetToLocalSpace;
		}

		public Vector3 GetCurrentOrientationNormal()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return base.transform.rotation * defaultLocalPoleNormal;
		}
	}

	public enum FIK_HintMode
	{
		Default,
		MiddleForward,
		MiddleBack,
		OnGoal,
		EndForward,
		Leg,
		UnityHumanoidIK
	}

	[NonSerialized]
	[Tooltip("3-Bones limb array")]
	private IKBone[] IKBones;

	[Range(0f, 1f)]
	[Space(4f)]
	[Tooltip("Blend value for goal position")]
	public float IKPositionWeight = 1f;

	[Range(0f, 1f)]
	[Tooltip("Blend value for end bone rotation")]
	public float FootRotationWeight = 1f;

	[Tooltip("Flex style algorithm for different limbs")]
	public FIK_HintMode AutoHintMode = FIK_HintMode.MiddleForward;

	protected Vector3 targetElbowNormal = Vector3.right;

	protected Quaternion lateEndBoneRotation;

	protected Quaternion postIKAnimatorEndBoneRot;

	public Vector3 ExtraHintAdjustementOffset = Vector3.zero;

	public bool InverseHint;

	[NonSerialized]
	public float FeetStretchWeight = 1f;

	[NonSerialized]
	public float FeetStretchSensitivity = 1f;

	[NonSerialized]
	public float FeetStretchLimit = 1f;

	[NonSerialized]
	public float FeetFadeQuicker = 1f;

	[NonSerialized]
	public bool disableFeet;

	private float maxFeetAngle;

	private float maxFeetAngleFactor;

	private Vector3 ankleToFeet;

	[NonSerialized]
	public Animator HumanoidAnimator;

	[NonSerialized]
	public bool IsRight;

	private bool everyIsChild = true;

	private bool hasFeet;

	private bool hasRoot;

	[HideInInspector]
	[Range(0f, 1f)]
	public float ManualHintPositionWeight;

	[HideInInspector]
	public Vector3 IKManualHintPosition = Vector3.zero;

	[NonSerialized]
	public bool UseEndBoneMapping = true;

	private float internalRotationWeightMul = 1f;

	public Quaternion EndBoneMapping { get; protected set; }

	public IKBone FeetIKBone => IKBones[3];

	public float ScaleReference { get; protected set; }

	public Transform Root { get; protected set; }

	public IKBone StartIKBone => IKBones[0];

	public IKBone MiddleIKBone => IKBones[1];

	public IKBone EndIKBone => IKBones[2];

	public IKBone EndParentIKBone { get; private set; }

	public int BonesCount => IKBones.Length;

	public override void Update()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Initialized)
		{
			return;
		}
		Refresh();
		float num = IKPositionWeight * IKWeight;
		IKBone startIKBone = StartIKBone;
		Vector3 val = MiddleIKBone.transform.position - StartIKBone.transform.position;
		startIKBone.sqrMagn = ((Vector3)(ref val)).sqrMagnitude;
		IKBone middleIKBone = MiddleIKBone;
		val = EndIKBone.transform.position - MiddleIKBone.transform.position;
		middleIKBone.sqrMagn = ((Vector3)(ref val)).sqrMagnitude;
		targetElbowNormal = GetDefaultFlexNormal();
		if (ExtraHintAdjustementOffset != Vector3.zero)
		{
			val = Vector3.Lerp(targetElbowNormal, CalculateElbowNormalToPosition(EndIKBone.transform.position + EndIKBone.transform.rotation * ExtraHintAdjustementOffset), ((Vector3)(ref ExtraHintAdjustementOffset)).magnitude);
			targetElbowNormal = ((Vector3)(ref val)).normalized;
		}
		Vector3 val2 = GetOrientationDirection(IKTargetPosition, InverseHint ? (-targetElbowNormal) : targetElbowNormal);
		if (val2 == Vector3.zero)
		{
			val2 = MiddleIKBone.transform.position - StartIKBone.transform.position;
		}
		if (num > 0f)
		{
			Quaternion val3 = StartIKBone.GetRotation(val2, targetElbowNormal) * base.StartBoneRotationOffset;
			if (num < 1f)
			{
				val3 = Quaternion.LerpUnclamped(StartIKBone.srcRotation, val3, num);
			}
			StartIKBone.transform.rotation = val3;
			Quaternion val4 = MiddleIKBone.GetRotation(IKTargetPosition - MiddleIKBone.transform.position, MiddleIKBone.GetCurrentOrientationNormal());
			if (num < 1f)
			{
				val4 = Quaternion.LerpUnclamped(MiddleIKBone.srcRotation, val4, num);
			}
			MiddleIKBone.transform.rotation = val4;
		}
		postIKAnimatorEndBoneRot = EndIKBone.transform.rotation;
		EndBoneRotation();
	}

	private Vector3 GetAutomaticFlexNormal()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		Vector3 currentOrientationNormal = StartIKBone.GetCurrentOrientationNormal();
		switch (AutoHintMode)
		{
		case FIK_HintMode.Leg:
		{
			Vector3 val2 = IKTargetRotation * (EndIKBone.forward * internalRotationWeightMul * 2f);
			if (hasRoot)
			{
				val2 += Root.forward * 0.06f;
				Vector3 val3 = Root.InverseTransformPoint(IKTargetPosition);
				val3.y = 0f;
				val2 += (Root.TransformPoint(val3) - Root.position) * 0.025f;
			}
			float num = Vector3.Distance(MiddleIKBone.transform.position, EndIKBone.transform.position) * 0.1f;
			Vector3 val4 = CalculateElbowNormalToPosition(MiddleIKBone.srcPosition + val2 * num);
			return Vector3.LerpUnclamped(((Vector3)(ref currentOrientationNormal)).normalized, val4, 0.85f);
		}
		case FIK_HintMode.MiddleForward:
			return Vector3.LerpUnclamped(((Vector3)(ref currentOrientationNormal)).normalized, MiddleIKBone.srcRotation * MiddleIKBone.right, 0.5f);
		case FIK_HintMode.MiddleBack:
			return MiddleIKBone.srcRotation * -MiddleIKBone.right;
		case FIK_HintMode.EndForward:
		{
			Vector3 val = Vector3.Cross(MiddleIKBone.srcPosition + EndIKBone.srcRotation * EndIKBone.forward - StartIKBone.srcPosition, IKTargetPosition - StartIKBone.srcPosition);
			if (val == Vector3.zero)
			{
				return currentOrientationNormal;
			}
			return val;
		}
		case FIK_HintMode.OnGoal:
			return Vector3.LerpUnclamped(currentOrientationNormal, lateEndBoneRotation * EndIKBone.right, 0.5f);
		case FIK_HintMode.UnityHumanoidIK:
			if (Object.op_Implicit((Object)(object)HumanoidAnimator))
			{
				HumanoidAnimator.logWarnings = false;
				return CalculateElbowNormalToPosition(HumanoidAnimator.GetIKHintPosition((AvatarIKHint)(IsRight ? 1 : 0)));
			}
			break;
		}
		return currentOrientationNormal;
	}

	public void OnDrawGizmos()
	{
		_ = base.Initialized;
	}

	public virtual void SetRootReference(Transform mainParentTransform)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Root = mainParentTransform;
		EndBoneMapping = Quaternion.FromToRotation(EndIKBone.right, Vector3.right);
		EndBoneMapping *= Quaternion.FromToRotation(EndIKBone.up, Vector3.up);
		if (Object.op_Implicit((Object)(object)mainParentTransform))
		{
			hasRoot = true;
		}
	}

	public void RefreshLength()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = StartIKBone.transform.position - MiddleIKBone.transform.position;
		ScaleReference = ((Vector3)(ref val)).magnitude;
	}

	public void RefreshScaleReference()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = StartIKBone.transform.position - MiddleIKBone.transform.position;
		ScaleReference = ((Vector3)(ref val)).magnitude;
	}

	private float GetCurrentLegToAnkleLength()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		float epsilon = Mathf.Epsilon;
		Vector3 val = StartIKBone.transform.position - MiddleIKBone.transform.position;
		float num = epsilon + ((Vector3)(ref val)).magnitude;
		val = MiddleIKBone.transform.position - EndIKBone.transform.position;
		return num + ((Vector3)(ref val)).magnitude;
	}

	public float GetStretchValue(Vector3 targetPos)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = StartIKBone.transform.position - targetPos;
		return ((Vector3)(ref val)).magnitude / GetCurrentLegToAnkleLength();
	}

	public Vector3 GetNotStretchedPositionTowards(Vector3 targetPos, float maxStretch)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = targetPos - StartIKBone.transform.position;
		return StartIKBone.transform.position + ((Vector3)(ref val)).normalized * (GetCurrentLegToAnkleLength() * maxStretch);
	}

	public void ApplyMaxStretchingPreprocessing(float maxStretch, float allowIKRotationFadeout = 2f)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		if (!(maxStretch < 1.1f))
		{
			return;
		}
		Vector3 val = StartIKBone.transform.position - IKTargetPosition;
		float magnitude = ((Vector3)(ref val)).magnitude;
		float currentLegToAnkleLength = GetCurrentLegToAnkleLength();
		float num = magnitude / currentLegToAnkleLength;
		if (num > maxStretch)
		{
			if (hasFeet && FeetStretchWeight > 0f)
			{
				if (maxFeetAngle > 0f)
				{
					Vector3 val2 = IKTargetPosition - StartIKBone.transform.position;
					((Vector3)(ref val2)).Normalize();
					Vector3 val3 = FeetIKBone.transform.position - EndIKBone.transform.position;
					((Vector3)(ref val3)).Normalize();
					float num2 = Vector3.Dot(val2, val3);
					num2 = Mathf.Clamp01(num2);
					val = FeetIKBone.transform.position - EndIKBone.transform.position;
					float magnitude2 = ((Vector3)(ref val)).magnitude;
					float num3 = magnitude - currentLegToAnkleLength * Mathf.Min(maxStretch, 1f);
					num3 /= magnitude2 * FeetFadeQuicker;
					float num4 = num3;
					num3 *= maxFeetAngleFactor * FeetStretchSensitivity;
					if (num3 > 1f)
					{
						num3 = 1f;
					}
					if (num4 < 1f)
					{
						num4 = 1f;
					}
					else
					{
						if (num4 > 2f)
						{
							num4 = 2f;
						}
						num4 -= 1f;
						num4 *= num4;
						num4 = 1f - num4;
					}
					float num5 = Mathf.Min(FeetStretchLimit, (1f - num2) * (90f / maxFeetAngle) * num3 * FeetStretchWeight);
					if (num > 1.09f)
					{
						num4 *= 1f - Mathf.InverseLerp(1.09f, 1.23f, num);
					}
					if (num5 != 0f)
					{
						OffsetHeel(num5, num4);
					}
					val = StartIKBone.transform.position - IKTargetPosition;
					magnitude = ((Vector3)(ref val)).magnitude;
					num = magnitude / currentLegToAnkleLength;
				}
				if (num > maxStretch)
				{
					float num6 = maxStretch * currentLegToAnkleLength;
					Vector3 position = StartIKBone.transform.position;
					val = IKTargetPosition - StartIKBone.transform.position;
					IKTargetPosition = position + ((Vector3)(ref val)).normalized * num6;
				}
			}
			else
			{
				float num7 = maxStretch * currentLegToAnkleLength;
				Vector3 position2 = StartIKBone.transform.position;
				val = IKTargetPosition - StartIKBone.transform.position;
				IKTargetPosition = position2 + ((Vector3)(ref val)).normalized * num7;
			}
			if (allowIKRotationFadeout > 0f)
			{
				float num8 = num - maxStretch;
				num8 = Mathf.Clamp01(num8 * allowIKRotationFadeout);
				internalRotationWeightMul = 1f - num8;
			}
		}
		else
		{
			internalRotationWeightMul = 1f;
		}
	}

	private void PrepareFeet()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = EndIKBone.transform.position - MiddleIKBone.transform.position;
		((Vector3)(ref val)).Normalize();
		ankleToFeet = FeetIKBone.transform.position - EndIKBone.transform.position;
		((Vector3)(ref ankleToFeet)).Normalize();
		maxFeetAngle = Vector3.Angle(ankleToFeet, val);
		maxFeetAngleFactor = 90f / maxFeetAngle;
	}

	internal void OffsetHeel(float heelRot, float feetCompensate = 1f)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		if (!hasFeet || disableFeet)
		{
			return;
		}
		Quaternion iKTargetRotation = IKTargetRotation;
		Vector3 val = FeetIKBone.transform.position - EndIKBone.transform.position;
		Vector3 val2 = Quaternion.Inverse(iKTargetRotation) * val;
		Vector3 val3 = ((!UseEndBoneMapping) ? (IKTargetRotation * EndIKBone.right) : (IKTargetRotation * Vector3.right));
		Quaternion val4 = Quaternion.AngleAxis(heelRot * maxFeetAngle, val3);
		val2 = (IKTargetRotation = val4 * iKTargetRotation) * val2 - val;
		if (feetCompensate > 0f)
		{
			Quaternion val5 = Quaternion.Inverse(val4) * FeetIKBone.transform.rotation;
			if (feetCompensate >= 1f)
			{
				FeetIKBone.transform.rotation = val5;
			}
			else
			{
				FeetIKBone.transform.rotation = Quaternion.Lerp(FeetIKBone.transform.rotation, val5, feetCompensate);
			}
		}
		IKTargetPosition -= val2;
	}

	public IKBone GetBone(int index)
	{
		return IKBones[index];
	}

	public override void Init(Transform root)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Initialized)
		{
			Vector3 val = Vector3.Cross(MiddleIKBone.transform.position - StartIKBone.transform.position, EndIKBone.transform.position - MiddleIKBone.transform.position);
			if (val != Vector3.zero)
			{
				targetElbowNormal = val;
			}
			base.fullLength = 0f;
			StartIKBone.Init(root, MiddleIKBone.transform.position, targetElbowNormal);
			MiddleIKBone.Init(root, EndIKBone.transform.position, targetElbowNormal);
			EndIKBone.Init(root, EndIKBone.transform.position + (EndIKBone.transform.position - MiddleIKBone.transform.position), targetElbowNormal);
			base.fullLength = base.Bones[0].BoneLength + base.Bones[1].BoneLength;
			RefreshDefaultFlexNormal();
			if ((Object)(object)EndIKBone.transform.parent != (Object)(object)MiddleIKBone.transform)
			{
				everyIsChild = false;
			}
			else if ((Object)(object)MiddleIKBone.transform.parent != (Object)(object)StartIKBone.transform)
			{
				everyIsChild = false;
			}
			else
			{
				everyIsChild = true;
			}
			SetRootReference(root);
			if (Application.isPlaying)
			{
				base.Initialized = true;
			}
			if (hasFeet)
			{
				PrepareFeet();
			}
			if (everyIsChild)
			{
				EndParentIKBone = MiddleIKBone;
			}
			else
			{
				EndParentIKBone = new IKBone(EndIKBone.transform.parent);
			}
		}
	}

	public void SetBones(Transform startBone, Transform midBone, Transform endBone)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		IKBones = new IKBone[3];
		IKBones[0] = new IKBone(startBone);
		IKBones[1] = new IKBone(midBone);
		IKBones[2] = new IKBone(endBone);
		base.Bones = new FIK_IKBoneBase[3]
		{
			IKBones[0],
			IKBones[1],
			IKBones[2]
		};
		IKBones[0].SetChild(IKBones[1]);
		IKBones[1].SetChild(IKBones[2]);
		IKTargetPosition = endBone.position;
		IKTargetRotation = endBone.rotation;
	}

	public void SetLegWithFeet(Transform startBone, Transform midBone, Transform endBone, Transform feet)
	{
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		IKBones = new IKBone[4];
		IKBones[0] = new IKBone(startBone);
		IKBones[1] = new IKBone(midBone);
		IKBones[2] = new IKBone(endBone);
		IKBones[3] = new IKBone(feet);
		base.Bones = new FIK_IKBoneBase[4]
		{
			IKBones[0],
			IKBones[1],
			IKBones[2],
			IKBones[3]
		};
		IKBones[0].SetChild(IKBones[1]);
		IKBones[1].SetChild(IKBones[2]);
		IKBones[2].SetChild(IKBones[3]);
		IKTargetPosition = endBone.position;
		IKTargetRotation = endBone.rotation;
		hasFeet = true;
	}

	public void SetBones(Transform startBone, Transform endBone)
	{
		SetBones(startBone, endBone.parent, endBone);
	}

	protected virtual void Refresh()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		RefreshAnimatorCoords();
		if (!everyIsChild)
		{
			MiddleIKBone.RefreshOrientations(EndIKBone.transform.position, targetElbowNormal);
		}
	}

	protected virtual void EndBoneRotation()
	{
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		float num = FootRotationWeight * IKWeight * internalRotationWeightMul;
		if (num > 0f)
		{
			if (UseEndBoneMapping)
			{
				if (num < 1f)
				{
					EndIKBone.transform.rotation = Quaternion.SlerpUnclamped(postIKAnimatorEndBoneRot, IKTargetRotation * EndBoneMapping, num);
				}
				else
				{
					EndIKBone.transform.rotation = IKTargetRotation * EndBoneMapping;
				}
			}
			else if (num < 1f)
			{
				EndIKBone.transform.rotation = Quaternion.SlerpUnclamped(postIKAnimatorEndBoneRot, IKTargetRotation, num);
			}
			else
			{
				EndIKBone.transform.rotation = IKTargetRotation;
			}
		}
		lateEndBoneRotation = EndIKBone.transform.rotation;
	}

	public override void PreCalibrate()
	{
		base.PreCalibrate();
		RefreshScaleReference();
	}

	public void RefreshAnimatorCoords()
	{
		StartIKBone.CaptureSourceAnimation();
		MiddleIKBone.CaptureSourceAnimation();
		EndIKBone.CaptureSourceAnimation();
		if (!everyIsChild && MiddleIKBone != EndParentIKBone)
		{
			EndParentIKBone.CaptureSourceAnimation();
		}
	}

	protected Vector3 GetDefaultFlexNormal()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (ManualHintPositionWeight > 0f)
		{
			if (ManualHintPositionWeight >= 1f)
			{
				return CalculateElbowNormalToPosition(IKManualHintPosition);
			}
			Vector3 automaticFlexNormal = GetAutomaticFlexNormal();
			return Vector3.LerpUnclamped(((Vector3)(ref automaticFlexNormal)).normalized, CalculateElbowNormalToPosition(IKManualHintPosition), ManualHintPositionWeight);
		}
		return GetAutomaticFlexNormal();
	}

	public Vector3 CalculateElbowNormalToPosition(Vector3 targetElbowPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Cross(targetElbowPos - StartIKBone.transform.position, EndIKBone.transform.position - StartIKBone.transform.position);
	}

	public void RefreshDefaultFlexNormal()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(MiddleIKBone.transform.position - StartIKBone.transform.position, EndIKBone.transform.position - MiddleIKBone.transform.position);
		if (val != Vector3.zero)
		{
			targetElbowNormal = val;
		}
	}

	protected Vector3 GetOrientationDirection(Vector3 ikPosition, Vector3 orientationNormal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ikPosition - StartIKBone.transform.position;
		if (val == Vector3.zero)
		{
			return Vector3.zero;
		}
		float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
		float num = Mathf.Sqrt(sqrMagnitude);
		float num2 = (sqrMagnitude + StartIKBone.sqrMagn - MiddleIKBone.sqrMagn) / 2f / num;
		float num3 = Mathf.Sqrt(Mathf.Clamp(StartIKBone.sqrMagn - num2 * num2, 0f, float.PositiveInfinity));
		Vector3 val2 = Vector3.Cross(val / num, orientationNormal);
		return Quaternion.LookRotation(val, val2) * new Vector3(0f, num3, num2);
	}
}


using UnityEngine;

public class IKBone : FIK_IKBoneBase
{
	[SerializeField]
	private Quaternion targetToLocalSpace;

	[SerializeField]
	private Vector3 defaultLocalPoleNormal;

	public Vector3 right { get; private set; }

	public Vector3 up { get; private set; }

	public Vector3 forward { get; private set; }

	public Vector3 srcPosition { get; private set; }

	public Quaternion srcRotation { get; private set; }

	public IKBone(Transform t)
		: base(t)
	{
	}

	public void Init(Transform root, Vector3 childPosition, Vector3 orientationNormal)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		RefreshOrientations(childPosition, orientationNormal);
		Vector3 val = childPosition - base.transform.position;
		sqrMagn = ((Vector3)(ref val)).sqrMagnitude;
		LastKeyLocalRotation = base.transform.localRotation;
		right = base.transform.InverseTransformDirection(root.right);
		up = base.transform.InverseTransformDirection(root.up);
		forward = base.transform.InverseTransformDirection(root.forward);
		CaptureSourceAnimation();
	}

	public void RefreshOrientations(Vector3 childPosition, Vector3 orientationNormal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (!(orientationNormal == Vector3.zero))
		{
			Vector3 val = childPosition - base.transform.position;
			((Vector3)(ref val)).Normalize();
			if (!(val == Vector3.zero))
			{
				Quaternion rotation = Quaternion.LookRotation(val, orientationNormal);
				targetToLocalSpace = RotationToLocal(base.transform.rotation, rotation);
				defaultLocalPoleNormal = Quaternion.Inverse(base.transform.rotation) * orientationNormal;
			}
		}
	}

	public void CaptureSourceAnimation()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		srcPosition = base.transform.position;
		srcRotation = base.transform.rotation;
	}

	public static Quaternion RotationToLocal(Quaternion parent, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Inverse(Quaternion.Inverse(parent) * rotation);
	}

	public Quaternion GetRotation(Vector3 direction, Vector3 orientationNormal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.LookRotation(direction, orientationNormal) * targetToLocalSpace;
	}

	public Vector3 GetCurrentOrientationNormal()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return base.transform.rotation * defaultLocalPoleNormal;
	}
}


public enum FIK_HintMode
{
	Default,
	MiddleForward,
	MiddleBack,
	OnGoal,
	EndForward,
	Leg,
	UnityHumanoidIK
}


using FIMSpace.FTools;
using UnityEngine;

public class FElasticTransform
{
	public Transform transform;

	private FElasticTransform elChild;

	private FElasticTransform elParent;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float RotationRapidness = 0.1f;

	private Quaternion proceduralRotation;

	private float delta = 0.01f;

	public FMuscle_Vector3 PositionMuscle { get; private set; }

	public Vector3 ProceduralPosition { get; private set; }

	public Vector3 sourceAnimationPosition { get; private set; }

	public void Initialize(Transform transform)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)transform == (Object)null))
		{
			this.transform = transform;
			ProceduralPosition = transform.position;
			proceduralRotation = transform.rotation;
			sourceAnimationPosition = transform.position;
			PositionMuscle = new FMuscle_Vector3();
			PositionMuscle.Initialize(transform.position);
		}
	}

	public void OverrideProceduralPosition(Vector3 newPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		ProceduralPosition = newPos;
	}

	public void OverrideProceduralPositionHard(Vector3 newPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		ProceduralPosition = newPos;
		PositionMuscle.OverrideProceduralPosition(newPos);
		sourceAnimationPosition = newPos;
	}

	public void OverrideProceduralRotation(Quaternion newRot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		proceduralRotation = newRot;
	}

	public void CaptureSourceAnimation()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		sourceAnimationPosition = transform.position;
	}

	public void SetChild(FElasticTransform child)
	{
		elChild = child;
	}

	public FElasticTransform GetElasticChild()
	{
		return elChild;
	}

	public void SetParent(FElasticTransform parent)
	{
		elParent = parent;
	}

	public void UpdateElasticPosition(float delta)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		this.delta = delta;
		if (elParent != null)
		{
			FElasticTransform obj = (((Object)(object)elParent.transform == (Object)null) ? elParent.elParent : elParent);
			Quaternion rotation = obj.transform.rotation;
			Vector3 desired = obj.ProceduralPosition + rotation * transform.localPosition;
			PositionMuscle.Update(delta, desired);
			ProceduralPosition = PositionMuscle.ProceduralPosition;
		}
		else
		{
			ProceduralPosition = transform.position;
		}
	}

	public void UpdateElasticPosition(float delta, Vector3 influenceOffset)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		this.delta = delta;
		if (elParent != null)
		{
			PositionMuscle.MotionInfluence(influenceOffset);
			UpdateElasticPosition(delta);
		}
		else
		{
			ProceduralPosition = transform.position;
		}
	}

	public void UpdateElasticRotation(float blending)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		if (elChild != null)
		{
			Quaternion val = ((!(blending < 1f)) ? GetTargetRotation(elChild.ProceduralPosition, transform.TransformDirection(elChild.transform.localPosition), ProceduralPosition) : GetTargetRotation(elChild.BlendVector(elChild.ProceduralPosition, blending), transform.TransformDirection(elChild.transform.localPosition), blending));
			if (RotationRapidness < 1f)
			{
				proceduralRotation = Quaternion.Lerp(proceduralRotation, val, Mathf.Min(1f, delta * (10f + RotationRapidness * 50f)));
				transform.rotation = proceduralRotation;
			}
			else
			{
				transform.rotation = val;
			}
		}
	}

	public Vector3 BlendVector(Vector3 target, float blend)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.LerpUnclamped(sourceAnimationPosition, target, blend);
	}

	public Quaternion GetTargetRotation(Vector3 lookPos, Vector3 localOffset, float blending)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = lookPos - BlendVector(ProceduralPosition, blending);
		return Quaternion.FromToRotation(localOffset, ((Vector3)(ref val)).normalized) * transform.rotation;
	}

	public Quaternion GetTargetRotation(Vector3 lookPos, Vector3 localOffset, Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = lookPos - pos;
		return Quaternion.FromToRotation(localOffset, ((Vector3)(ref val)).normalized) * transform.rotation;
	}
}


using UnityEngine;

public abstract class FMuscle_Motor
{
	protected float proceduralValue;

	protected float dampingAcceleration;

	protected float dynamicAcceleration;

	protected float accelerationSign;

	public float OutValue { get; protected set; }

	public bool IsWorking()
	{
		return dynamicAcceleration != 0f;
	}

	public void Push(float value)
	{
		dynamicAcceleration += value;
	}

	public void Initialize(float initValue)
	{
		OutValue = initValue;
		proceduralValue = initValue;
		dampingAcceleration = 0f;
		dynamicAcceleration = 0f;
		accelerationSign = 0f;
	}

	protected abstract float GetDiff(float current, float desired);

	public void Update(float delta, float current, float desired, float acceleration, float accelerationLimit, float damping, float brakePower)
	{
		float diff = GetDiff(current, desired);
		accelerationSign = Mathf.Sign(diff);
		dampingAcceleration = diff;
		dampingAcceleration = Mathf.Clamp(dampingAcceleration, 0f - damping, damping) * damping;
		float num = dampingAcceleration * delta;
		if (diff > 0f)
		{
			if (num > diff)
			{
				num = diff;
			}
		}
		else if (num < diff)
		{
			num = diff;
		}
		proceduralValue += num;
		float num2 = 1f;
		if (Mathf.Sign(dynamicAcceleration) != accelerationSign)
		{
			num2 = 1f + Mathf.Abs(diff) / ((1f - brakePower) * 10f + 8f);
		}
		float num3 = diff;
		if (num3 < 0f)
		{
			num3 = 0f - num3;
		}
		float num4 = 5f + (1f - brakePower) * 85f;
		if (num3 < num4)
		{
			num2 *= Mathf.Min(1f, num3 / num4);
		}
		if (num2 < 0f)
		{
			num2 = 0f - num2;
		}
		if (delta > 0.04f)
		{
			delta = 0.04f;
		}
		dynamicAcceleration += acceleration * accelerationSign * delta * num2;
		dynamicAcceleration = Mathf.Clamp(dynamicAcceleration, 0f - accelerationLimit, accelerationLimit);
		if (dynamicAcceleration < 5E-06f && dynamicAcceleration > -5E-06f)
		{
			dynamicAcceleration = 0f;
		}
		proceduralValue += dynamicAcceleration * delta;
		OutValue = proceduralValue;
	}

	public void OverrideValue(float newValue)
	{
		proceduralValue = newValue;
	}

	public void OffsetValue(float off)
	{
		proceduralValue += off;
	}
}


using FIMSpace.FTools;

public class FMuscle_Float : FMuscle_Motor
{
	protected override float GetDiff(float current, float desired)
	{
		return desired - current;
	}
}


using FIMSpace.FTools;
using UnityEngine;

public class FMuscle_Angle : FMuscle_Motor
{
	protected override float GetDiff(float current, float desired)
	{
		return Mathf.DeltaAngle(current, desired);
	}
}


using System;
using System.Collections;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class FMuscle_Vector3
{
	[HideInInspector]
	public Vector3 DesiredPosition;

	private FMuscle_Float x;

	private FMuscle_Float y;

	private FMuscle_Float z;

	[FPD_Suffix(0f, 10000f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float Acceleration = 10000f;

	[FPD_Suffix(0f, 10000f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float AccelerationLimit = 5000f;

	[FPD_Suffix(0f, 50f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float Damping = 10f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float BrakePower = 0.2f;

	public Vector3 ProceduralPosition { get; private set; }

	public bool Initialized { get; private set; }

	public void Initialize(Vector3 initPosition)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		x = new FMuscle_Float();
		y = new FMuscle_Float();
		z = new FMuscle_Float();
		x.Initialize(initPosition.x);
		y.Initialize(initPosition.y);
		z.Initialize(initPosition.z);
		ProceduralPosition = initPosition;
		Initialized = true;
	}

	public bool IsWorking()
	{
		if (!x.IsWorking() && !y.IsWorking())
		{
			return z.IsWorking();
		}
		return true;
	}

	public void Push(Vector3 value)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		x.Push(value.x);
		y.Push(value.y);
		z.Push(value.z);
	}

	public void Reset(Vector3 value)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		x.Initialize(value.x);
		y.Initialize(value.y);
		z.Initialize(value.z);
	}

	public void Push(float v)
	{
		x.Push(v);
		y.Push(v);
		z.Push(v);
	}

	public void MotionInfluence(Vector3 offset)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		x.OffsetValue(offset.x);
		y.OffsetValue(offset.y);
		z.OffsetValue(offset.z);
		ProceduralPosition += offset;
	}

	public void Update(float delta, Vector3 desired, float acceleration, float accelerationLimit, float damping, float brakePower)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		x.Update(delta, ProceduralPosition.x, desired.x, acceleration, accelerationLimit, damping, brakePower);
		y.Update(delta, ProceduralPosition.y, desired.y, acceleration, accelerationLimit, damping, brakePower);
		z.Update(delta, ProceduralPosition.z, desired.z, acceleration, accelerationLimit, damping, brakePower);
		ProceduralPosition = new Vector3(x.OutValue, y.OutValue, z.OutValue);
	}

	public Vector3 Update(float delta, Vector3 desired)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		x.Update(delta, ProceduralPosition.x, desired.x, Acceleration, AccelerationLimit, Damping, BrakePower);
		y.Update(delta, ProceduralPosition.y, desired.y, Acceleration, AccelerationLimit, Damping, BrakePower);
		z.Update(delta, ProceduralPosition.z, desired.z, Acceleration, AccelerationLimit, Damping, BrakePower);
		ProceduralPosition = new Vector3(x.OutValue, y.OutValue, z.OutValue);
		return ProceduralPosition;
	}

	public IEnumerator PushImpulseCoroutine(Vector3 power, float duration, bool fadeOutPower = false, float delay = 0f)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (delay > 0f)
		{
			yield return (object)new WaitForSeconds(delay);
		}
		float elapsed = 0f;
		Push(0.0001f);
		while (elapsed / duration < 1f)
		{
			if (!fadeOutPower)
			{
				Push(power * Time.deltaTime * 60f);
			}
			else
			{
				Push(power * (1f - elapsed / duration) * Time.deltaTime * 60f);
			}
			elapsed += Time.deltaTime;
			yield return null;
		}
	}

	public static void Lerp(ref FMuscle_Vector3 source, FMuscle_Vector3 a, FMuscle_Vector3 b, float t)
	{
		if (a != null && b != null && source != null)
		{
			source.Acceleration = Mathf.LerpUnclamped(a.Acceleration, b.Acceleration, t);
			source.AccelerationLimit = Mathf.LerpUnclamped(a.AccelerationLimit, b.AccelerationLimit, t);
			source.BrakePower = Mathf.LerpUnclamped(a.BrakePower, b.BrakePower, t);
			source.Damping = Mathf.LerpUnclamped(a.Damping, b.Damping, t);
		}
	}

	public void OverrideProceduralPosition(Vector3 newPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		ProceduralPosition = newPos;
		DesiredPosition = newPos;
		x.OverrideValue(newPos.x);
		y.OverrideValue(newPos.y);
		z.OverrideValue(newPos.z);
	}
}


using System;
using System.Collections;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class FMuscle_Quaternion
{
	[HideInInspector]
	public Quaternion DesiredRotation;

	private FMuscle_Float x;

	private FMuscle_Float y;

	private FMuscle_Float z;

	private FMuscle_Float w;

	[FPD_Suffix(0f, 10000f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float Acceleration = 5000f;

	[FPD_Suffix(0f, 10000f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float AccelerationLimit = 1000f;

	[FPD_Suffix(0f, 50f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float Damping = 10f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float BrakePower = 0.2f;

	public Quaternion ProceduralRotation { get; private set; }

	public bool IsCorrect => x != null;

	public void Initialize(Quaternion initRotation)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		x = new FMuscle_Float();
		y = new FMuscle_Float();
		z = new FMuscle_Float();
		w = new FMuscle_Float();
		x.Initialize(initRotation.x);
		y.Initialize(initRotation.y);
		z.Initialize(initRotation.z);
		w.Initialize(initRotation.w);
		ProceduralRotation = initRotation;
	}

	public bool IsWorking()
	{
		if (!x.IsWorking() && !y.IsWorking() && !z.IsWorking())
		{
			return w.IsWorking();
		}
		return true;
	}

	public void Push(Quaternion value)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		x.Push(value.x);
		y.Push(value.y);
		z.Push(value.z);
		w.Push(value.w);
	}

	public void Push(float v)
	{
		x.Push(v);
		y.Push(v);
		z.Push(v);
		w.Push(v);
	}

	public void Push(Quaternion value, float multiply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		x.Push(value.x * multiply);
		y.Push(value.y * multiply);
		z.Push(value.z * multiply);
		w.Push(value.w * multiply);
	}

	public void Update(float delta, Quaternion desired, float acceleration, float accelerationLimit, float damping, float brakePower)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		x.Update(delta, ProceduralRotation.x, desired.x, acceleration, accelerationLimit, damping, brakePower);
		y.Update(delta, ProceduralRotation.y, desired.y, acceleration, accelerationLimit, damping, brakePower);
		z.Update(delta, ProceduralRotation.z, desired.z, acceleration, accelerationLimit, damping, brakePower);
		w.Update(delta, ProceduralRotation.w, desired.w, acceleration, accelerationLimit, damping, brakePower);
		ProceduralRotation = new Quaternion(x.OutValue, y.OutValue, z.OutValue, w.OutValue);
	}

	public void Update(float delta, Quaternion desired)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		x.Update(delta, ProceduralRotation.x, desired.x, Acceleration, AccelerationLimit, Damping, BrakePower);
		y.Update(delta, ProceduralRotation.y, desired.y, Acceleration, AccelerationLimit, Damping, BrakePower);
		z.Update(delta, ProceduralRotation.z, desired.z, Acceleration, AccelerationLimit, Damping, BrakePower);
		w.Update(delta, ProceduralRotation.w, desired.w, Acceleration, AccelerationLimit, Damping, BrakePower);
		ProceduralRotation = new Quaternion(x.OutValue, y.OutValue, z.OutValue, w.OutValue);
	}

	public void UpdateEnsured(float delta, Quaternion desired)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		Update(delta, EnsureQuaternionContinuity(ProceduralRotation, desired));
	}

	public static Quaternion EnsureQuaternionContinuity(Quaternion latestRot, Quaternion targetRot)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = default(Quaternion);
		((Quaternion)(ref val))..ctor(0f - targetRot.x, 0f - targetRot.y, 0f - targetRot.z, 0f - targetRot.w);
		Quaternion val2 = default(Quaternion);
		((Quaternion)(ref val2))..ctor(Mathf.LerpUnclamped(latestRot.x, targetRot.x, 0.5f), Mathf.LerpUnclamped(latestRot.y, targetRot.y, 0.5f), Mathf.LerpUnclamped(latestRot.z, targetRot.z, 0.5f), Mathf.LerpUnclamped(latestRot.w, targetRot.w, 0.5f));
		Quaternion val3 = default(Quaternion);
		((Quaternion)(ref val3))..ctor(Mathf.LerpUnclamped(latestRot.x, val.x, 0.5f), Mathf.LerpUnclamped(latestRot.y, val.y, 0.5f), Mathf.LerpUnclamped(latestRot.z, val.z, 0.5f), Mathf.LerpUnclamped(latestRot.w, val.w, 0.5f));
		float num = Quaternion.Angle(latestRot, val2);
		if (!(Quaternion.Angle(latestRot, val3) < num))
		{
			return targetRot;
		}
		return val;
	}

	public IEnumerator PushImpulseCoroutine(Quaternion power, float duration, bool fadeOutPower = false, float delay = 0f)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (delay > 0f)
		{
			yield return (object)new WaitForSeconds(delay);
		}
		float elapsed = 0f;
		Push(0.001f);
		while (elapsed / duration < 1f)
		{
			if (!fadeOutPower)
			{
				Push(power, Time.deltaTime * 60f);
			}
			else
			{
				Push(power, (1f - elapsed / duration) * Time.deltaTime * 60f);
			}
			elapsed += Time.deltaTime;
			yield return null;
		}
	}

	public static void Lerp(ref FMuscle_Quaternion source, FMuscle_Quaternion a, FMuscle_Quaternion b, float t)
	{
		if (a != null && b != null && source != null)
		{
			source.Acceleration = Mathf.LerpUnclamped(a.Acceleration, b.Acceleration, t);
			source.AccelerationLimit = Mathf.LerpUnclamped(a.AccelerationLimit, b.AccelerationLimit, t);
			source.BrakePower = Mathf.LerpUnclamped(a.BrakePower, b.BrakePower, t);
			source.Damping = Mathf.LerpUnclamped(a.Damping, b.Damping, t);
		}
	}

	public void OverrideProceduralRotation(Quaternion rotation)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		ProceduralRotation = rotation;
		DesiredRotation = rotation;
		x.OverrideValue(rotation.x);
		y.OverrideValue(rotation.y);
		z.OverrideValue(rotation.z);
		w.OverrideValue(rotation.w);
	}
}


using System;
using System.Collections;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class FMuscle_Eulers
{
	[HideInInspector]
	public Vector3 DesiredEulerAngles;

	private FMuscle_Angle x;

	private FMuscle_Angle y;

	private FMuscle_Angle z;

	[FPD_Suffix(0f, 10000f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float Acceleration = 5000f;

	[FPD_Suffix(0f, 10000f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float AccelerationLimit = 1000f;

	[FPD_Suffix(0f, 50f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float Damping = 10f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float BrakePower = 0.2f;

	public Vector3 ProceduralEulerAngles { get; private set; }

	public Quaternion ProceduralRotation => Quaternion.Euler(ProceduralEulerAngles);

	public void Initialize(Vector3 initEulerAngles)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		x = new FMuscle_Angle();
		y = new FMuscle_Angle();
		z = new FMuscle_Angle();
		x.Initialize(initEulerAngles.x);
		y.Initialize(initEulerAngles.y);
		z.Initialize(initEulerAngles.z);
		ProceduralEulerAngles = initEulerAngles;
	}

	public void Initialize(Quaternion initRotation)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Initialize(((Quaternion)(ref initRotation)).eulerAngles);
	}

	public bool IsWorking()
	{
		if (!x.IsWorking() && !y.IsWorking())
		{
			return z.IsWorking();
		}
		return true;
	}

	public void Push(Vector3 value)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		x.Push(value.x);
		y.Push(value.y);
		z.Push(value.z);
	}

	public void Push(float v)
	{
		x.Push(v);
		y.Push(v);
		z.Push(v);
	}

	public void Push(Vector3 value, float multiply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		x.Push(value.x * multiply);
		y.Push(value.y * multiply);
		z.Push(value.z * multiply);
	}

	public void Update(float delta, Vector3 desired, float acceleration, float accelerationLimit, float damping, float brakePower)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		x.Update(delta, ProceduralEulerAngles.x, desired.x, acceleration, accelerationLimit, damping, brakePower);
		y.Update(delta, ProceduralEulerAngles.y, desired.y, acceleration, accelerationLimit, damping, brakePower);
		z.Update(delta, ProceduralEulerAngles.z, desired.z, acceleration, accelerationLimit, damping, brakePower);
		ProceduralEulerAngles = new Vector3(x.OutValue, y.OutValue, z.OutValue);
	}

	public Vector3 Update(float delta, Vector3 desired)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		x.Update(delta, ProceduralEulerAngles.x, desired.x, Acceleration, AccelerationLimit, Damping, BrakePower);
		y.Update(delta, ProceduralEulerAngles.y, desired.y, Acceleration, AccelerationLimit, Damping, BrakePower);
		z.Update(delta, ProceduralEulerAngles.z, desired.z, Acceleration, AccelerationLimit, Damping, BrakePower);
		ProceduralEulerAngles = new Vector3(x.OutValue, y.OutValue, z.OutValue);
		return ProceduralEulerAngles;
	}

	public void Update(float delta, Quaternion desired)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		Update(delta, ((Quaternion)(ref desired)).eulerAngles);
	}

	public IEnumerator PushImpulseCoroutine(Vector3 power, float duration, bool fadeOutPower = false, float delay = 0f)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (delay > 0f)
		{
			yield return (object)new WaitForSeconds(delay);
		}
		float elapsed = 0f;
		Push(0.001f);
		while (elapsed / duration < 1f)
		{
			if (!fadeOutPower)
			{
				Push(power, Time.deltaTime * 60f);
			}
			else
			{
				Push(power, (1f - elapsed / duration) * Time.deltaTime * 60f);
			}
			elapsed += Time.deltaTime;
			yield return null;
		}
	}

	public static void Lerp(ref FMuscle_Eulers source, FMuscle_Eulers a, FMuscle_Eulers b, float t)
	{
		if (a != null && b != null && source != null)
		{
			source.Acceleration = Mathf.LerpUnclamped(a.Acceleration, b.Acceleration, t);
			source.AccelerationLimit = Mathf.LerpUnclamped(a.AccelerationLimit, b.AccelerationLimit, t);
			source.BrakePower = Mathf.LerpUnclamped(a.BrakePower, b.BrakePower, t);
			source.Damping = Mathf.LerpUnclamped(a.Damping, b.Damping, t);
		}
	}
}


using FIMSpace;
using FIMSpace.FTools;
using UnityEngine;

public class UniRotateBone
{
	private Vector3 dynamicUpReference = Vector3.up;

	public Transform transform { get; protected set; }

	public Vector3 initialLocalPosition { get; protected set; }

	public Quaternion initialLocalRotation { get; protected set; }

	public Vector3 initialLocalPositionInRootSpace { get; protected set; }

	public Quaternion initialLocalRotationInRootSpace { get; protected set; }

	public Vector3 right { get; protected set; }

	public Vector3 up { get; protected set; }

	public Vector3 forward { get; protected set; }

	public Vector3 dright { get; protected set; }

	public Vector3 dup { get; protected set; }

	public Vector3 dforward { get; protected set; }

	public Vector3 fromParentForward { get; protected set; }

	public Vector3 fromParentCross { get; protected set; }

	public Vector3 keyframedPosition { get; protected set; }

	public Quaternion keyframedRotation { get; protected set; }

	public Quaternion mapping { get; protected set; }

	public Quaternion dmapping { get; protected set; }

	public Transform root { get; protected set; }

	public Vector3 forwardReference { get; private set; }

	public Vector3 upReference { get; private set; }

	public Vector3 rightCrossReference { get; private set; }

	public UniRotateBone(Transform t, Transform root)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		transform = t;
		initialLocalPosition = transform.localPosition;
		initialLocalRotation = transform.localRotation;
		if (Object.op_Implicit((Object)(object)root))
		{
			initialLocalPositionInRootSpace = root.InverseTransformPoint(t.position);
			initialLocalRotationInRootSpace = root.rotation.QToLocal(t.rotation);
		}
		forward = transform.InverseTransformDirection(root.forward);
		up = transform.InverseTransformDirection(root.up);
		right = transform.InverseTransformDirection(root.right);
		dforward = Quaternion.FromToRotation(forward, Vector3.forward) * Vector3.forward;
		dup = Quaternion.FromToRotation(up, Vector3.up) * Vector3.up;
		dright = Quaternion.FromToRotation(right, Vector3.right) * Vector3.right;
		if (Object.op_Implicit((Object)(object)t.parent))
		{
			Vector3 val = GetFromParentForward();
			fromParentForward = ((Vector3)(ref val)).normalized;
		}
		else
		{
			fromParentForward = forward;
		}
		fromParentCross = -Vector3.Cross(fromParentForward, forward);
		mapping = Quaternion.FromToRotation(right, Vector3.right);
		mapping *= Quaternion.FromToRotation(up, Vector3.up);
		dmapping = Quaternion.FromToRotation(fromParentForward, Vector3.right);
		dmapping *= Quaternion.FromToRotation(up, Vector3.up);
		this.root = root;
	}

	public Vector3 GetFromParentForward()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		return transform.InverseTransformDirection(transform.position - transform.parent.position);
	}

	public Quaternion GetRootCompensateRotation(Quaternion initPelvisInWorld, Quaternion currInWorld, float armsRootCompensate)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Quaternion localRotation;
		if (armsRootCompensate > 0f)
		{
			localRotation = currInWorld.QToLocal(transform.parent.rotation);
			localRotation = initPelvisInWorld.QToWorld(localRotation);
			if (armsRootCompensate < 1f)
			{
				localRotation = Quaternion.Lerp(transform.parent.rotation, localRotation, armsRootCompensate);
			}
		}
		else
		{
			localRotation = transform.parent.rotation;
		}
		return localRotation;
	}

	public void RefreshCustomAxis(Vector3 up, Vector3 forward)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)transform == (Object)null))
		{
			forwardReference = Quaternion.Inverse(transform.parent.rotation) * root.rotation * forward;
			upReference = Quaternion.Inverse(transform.parent.rotation) * root.rotation * up;
			rightCrossReference = Vector3.Cross(upReference, forwardReference);
		}
	}

	public void RefreshCustomAxis(Vector3 up, Vector3 forward, Quaternion customParentRot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		forwardReference = Quaternion.Inverse(customParentRot) * root.rotation * forward;
		upReference = Quaternion.Inverse(customParentRot) * root.rotation * up;
		rightCrossReference = Vector3.Cross(upReference, forwardReference);
	}

	public Quaternion RotateCustomAxis(float x, float y, UniRotateBone oRef)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Quaternion.AngleAxis(y, oRef.upReference) * Quaternion.AngleAxis(x, rightCrossReference) * oRef.forwardReference;
		Vector3 val2 = oRef.upReference;
		Vector3.OrthoNormalize(ref val, ref val2);
		Vector3 val3 = val;
		dynamicUpReference = val2;
		Vector3.OrthoNormalize(ref val3, ref dynamicUpReference);
		return transform.parent.rotation * Quaternion.LookRotation(val3, dynamicUpReference) * Quaternion.Inverse(transform.parent.rotation * Quaternion.LookRotation(oRef.forwardReference, oRef.upReference));
	}

	internal Quaternion GetSourcePoseRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return root.rotation.QToWorld(initialLocalRotationInRootSpace);
	}

	public Vector2 GetCustomLookAngles(Vector3 direction, UniRotateBone orientationsReference)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Quaternion.Inverse(transform.parent.rotation) * ((Vector3)(ref direction)).normalized;
		Vector2 zero = Vector2.zero;
		zero.y = AngleAroundAxis(orientationsReference.forwardReference, val, orientationsReference.upReference);
		Vector3 axis = Vector3.Cross(orientationsReference.upReference, val);
		Vector3 firstDirection = val - Vector3.Project(val, orientationsReference.upReference);
		zero.x = AngleAroundAxis(firstDirection, val, axis);
		return zero;
	}

	public static float AngleAroundAxis(Vector3 firstDirection, Vector3 secondDirection, Vector3 axis)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		firstDirection -= Vector3.Project(firstDirection, axis);
		secondDirection -= Vector3.Project(secondDirection, axis);
		return Vector3.Angle(firstDirection, secondDirection) * (float)((!(Vector3.Dot(axis, Vector3.Cross(firstDirection, secondDirection)) < 0f)) ? 1 : (-1));
	}

	public Quaternion DynamicMapping()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.FromToRotation(right, transform.InverseTransformDirection(root.right)) * Quaternion.FromToRotation(up, transform.InverseTransformDirection(root.up));
	}

	public void CaptureKeyframeAnimation()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		keyframedPosition = transform.position;
		keyframedRotation = transform.rotation;
	}

	public void RotateBy(float x, float y, float z)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = transform.rotation;
		if (x != 0f)
		{
			val *= Quaternion.AngleAxis(x, right);
		}
		if (y != 0f)
		{
			val *= Quaternion.AngleAxis(y, up);
		}
		if (z != 0f)
		{
			val *= Quaternion.AngleAxis(z, forward);
		}
		transform.rotation = val;
	}

	public void RotateBy(Vector3 angles)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		RotateBy(angles.x, angles.y, angles.z);
	}

	public void RotateBy(Vector3 angles, float blend)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		RotateBy(BlendAngle(angles.x, blend), BlendAngle(angles.y, blend), BlendAngle(angles.z, blend));
	}

	public void RotateByDynamic(Vector3 angles)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		RotateByDynamic(angles.x, angles.y, angles.z);
	}

	public void RotateByDynamic(float x, float y, float z)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = transform.rotation;
		if (x != 0f)
		{
			val *= Quaternion.AngleAxis(x, transform.InverseTransformDirection(root.right));
		}
		if (y != 0f)
		{
			val *= Quaternion.AngleAxis(y, transform.InverseTransformDirection(root.up));
		}
		if (z != 0f)
		{
			val *= Quaternion.AngleAxis(z, transform.InverseTransformDirection(root.forward));
		}
		transform.rotation = val;
	}

	public Quaternion GetAngleRotation(float x, float y, float z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.identity;
		if (x != 0f)
		{
			val *= Quaternion.AngleAxis(x, right);
		}
		if (y != 0f)
		{
			val *= Quaternion.AngleAxis(y, up);
		}
		if (z != 0f)
		{
			val *= Quaternion.AngleAxis(z, forward);
		}
		return val;
	}

	public Quaternion GetAngleRotationDynamic(float x, float y, float z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.identity;
		if (x != 0f)
		{
			val *= Quaternion.AngleAxis(x, transform.InverseTransformDirection(root.right));
		}
		if (y != 0f)
		{
			val *= Quaternion.AngleAxis(y, transform.InverseTransformDirection(root.up));
		}
		if (z != 0f)
		{
			val *= Quaternion.AngleAxis(z, transform.InverseTransformDirection(root.forward));
		}
		return val;
	}

	public Quaternion GetAngleRotationDynamic(Vector3 angles)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		return GetAngleRotationDynamic(angles.x, angles.y, angles.z);
	}

	public void RotateByDynamic(Vector3 angles, float blend)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		RotateByDynamic(BlendAngle(angles.x, blend), BlendAngle(angles.y, blend), BlendAngle(angles.z, blend));
	}

	public void RotateByDynamic(float x, float y, float z, float blend)
	{
		RotateByDynamic(BlendAngle(x, blend), BlendAngle(y, blend), BlendAngle(z, blend));
	}

	public void RotateByDynamic(float x, float y, float z, Quaternion orientation)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = transform.rotation;
		if (x != 0f)
		{
			val *= Quaternion.AngleAxis(x, transform.InverseTransformDirection(orientation * Vector3.right));
		}
		if (y != 0f)
		{
			val *= Quaternion.AngleAxis(y, transform.InverseTransformDirection(orientation * Vector3.up));
		}
		if (z != 0f)
		{
			val *= Quaternion.AngleAxis(z, transform.InverseTransformDirection(orientation * Vector3.forward));
		}
		transform.rotation = val;
	}

	public void RotateXBy(float angle)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Transform obj = transform;
		obj.rotation *= Quaternion.AngleAxis(angle, right);
	}

	public void RotateYBy(float angle)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Transform obj = transform;
		obj.rotation *= Quaternion.AngleAxis(angle, up);
	}

	public void RotateZBy(float angle)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Transform obj = transform;
		obj.rotation *= Quaternion.AngleAxis(angle, forward);
	}

	public void PreCalibrate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		transform.localPosition = initialLocalPosition;
		transform.localRotation = initialLocalRotation;
	}

	public Quaternion RotationTowards(Vector3 toDir)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = transform.TransformDirection(fromParentForward);
		return Quaternion.FromToRotation(((Vector3)(ref val)).normalized, ((Vector3)(ref toDir)).normalized) * transform.rotation;
	}

	public Quaternion RotationTowardsDynamic(Vector3 toDir)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = transform.position - transform.parent.position;
		return Quaternion.FromToRotation(((Vector3)(ref val)).normalized, ((Vector3)(ref toDir)).normalized) * transform.rotation;
	}

	public static float BlendAngle(float angle, float blend)
	{
		return Mathf.LerpAngle(0f, angle, blend);
	}

	public Vector3 Dir(Vector3 forward)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return transform.TransformDirection(forward);
	}

	public Vector3 IDir(Vector3 forward)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return transform.InverseTransformDirection(forward);
	}
}


using UnityEngine;

public class FBasic_Rotator : MonoBehaviour
{
	public Vector3 RotationAxis = new Vector3(0f, 1f, 0f);

	public float RotationSpeed = 100f;

	public bool UnscaledDeltaTime;

	protected virtual void Update()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		float num = ((!UnscaledDeltaTime) ? Time.deltaTime : Time.unscaledDeltaTime);
		Transform transform = ((Component)this).transform;
		transform.localRotation *= Quaternion.AngleAxis(num * RotationSpeed, RotationAxis);
	}
}


using UnityEngine;

public class FBasic_FreeCameraBehaviour : MonoBehaviour
{
	[Header("> Hold right mouse button to rotate camera <")]
	[Tooltip("How fast camera should fly")]
	public float SpeedMultiplier = 10f;

	[Tooltip("Value of acceleration smoothness")]
	public float AccelerationSmothnessValue = 10f;

	[Tooltip("Value of rotation smoothness")]
	public float RotationSmothnessValue = 10f;

	public float MouseSensitivity = 5f;

	private float turboModeMultiply = 5f;

	private Vector3 speeds;

	private float ySpeed;

	private Vector3 rotation;

	private float turbo = 1f;

	private void Start()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		speeds = Vector3.zero;
		ySpeed = 0f;
		Quaternion val = ((Component)this).transform.rotation;
		rotation = ((Quaternion)(ref val)).eulerAngles;
	}

	private void Update()
	{
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		float axis = Input.GetAxis("Vertical");
		float axis2 = Input.GetAxis("Horizontal");
		float num = axis * Time.smoothDeltaTime * SpeedMultiplier;
		float num2 = axis2 * Time.smoothDeltaTime * SpeedMultiplier;
		if (Input.GetKey((KeyCode)304))
		{
			turbo = Mathf.Lerp(turbo, turboModeMultiply, Time.smoothDeltaTime * 5f);
		}
		else
		{
			turbo = Mathf.Lerp(turbo, 1f, Time.smoothDeltaTime * 5f);
		}
		num *= turbo;
		num2 *= turbo;
		if (Input.GetMouseButton(1))
		{
			rotation.x -= Input.GetAxis("Mouse Y") * 1f * MouseSensitivity;
			rotation.y += Input.GetAxis("Mouse X") * 1f * MouseSensitivity;
		}
		speeds.z = Mathf.Lerp(speeds.z, num, Time.smoothDeltaTime * AccelerationSmothnessValue);
		speeds.x = Mathf.Lerp(speeds.x, num2, Time.smoothDeltaTime * AccelerationSmothnessValue);
		Transform transform = ((Component)this).transform;
		transform.position += ((Component)this).transform.forward * speeds.z;
		Transform transform2 = ((Component)this).transform;
		transform2.position += ((Component)this).transform.right * speeds.x;
		Transform transform3 = ((Component)this).transform;
		transform3.position += ((Component)this).transform.up * speeds.y;
		((Component)this).transform.rotation = Quaternion.Slerp(((Component)this).transform.rotation, Quaternion.Euler(rotation), Time.smoothDeltaTime * RotationSmothnessValue);
		if (Input.GetKey((KeyCode)306))
		{
			ySpeed = Mathf.Lerp(ySpeed, 1f, Time.smoothDeltaTime * AccelerationSmothnessValue);
		}
		else if (Input.GetButton("Jump"))
		{
			ySpeed = Mathf.Lerp(ySpeed, -1f, Time.smoothDeltaTime * AccelerationSmothnessValue);
		}
		else
		{
			ySpeed = Mathf.Lerp(ySpeed, 0f, Time.smoothDeltaTime * AccelerationSmothnessValue);
		}
		Transform transform4 = ((Component)this).transform;
		transform4.position += Vector3.down * ySpeed * turbo * Time.smoothDeltaTime * SpeedMultiplier;
	}

	public void FixedUpdate()
	{
		if (Input.GetMouseButton(1))
		{
			Cursor.lockState = (CursorLockMode)1;
			Cursor.visible = false;
		}
		else
		{
			Cursor.lockState = (CursorLockMode)0;
			Cursor.visible = true;
		}
	}
}


using FIMSpace.Basics;
using UnityEngine;

[DefaultExecutionOrder(1000)]
public class FBasic_TPPCameraBehaviour : MonoBehaviour
{
	[Header("Transform to be followed by camera")]
	public Transform ToFollow;

	[Header("Offset in position in reference to target transform (focus point)")]
	public Vector3 FollowingOffset = new Vector3(0f, 1.5f, 0f);

	[Header("Offset in position in reference to camera orientation")]
	public Vector3 FollowingOffsetDirection = new Vector3(0f, 0f, 0f);

	[Header("Clamp values for zoom of camera")]
	public Vector2 DistanceRanges = new Vector2(5f, 10f);

	private float targetDistance;

	private float animatedDistance;

	public Vector2 RotationRanges = new Vector2(-5f, 60f);

	private Vector2 targetSphericRotation = new Vector2(0f, 0f);

	private Vector2 animatedSphericRotation = new Vector2(0f, 0f);

	[Space(10f)]
	[Tooltip("Sensitivity value for rotating camera around following object")]
	public float RotationSensitivity = 10f;

	[Range(0.1f, 1f)]
	[Header("If you want camera rotation to be smooth")]
	public float RotationSpeed = 1f;

	[Header("If you want camera to follow target with some smoothness")]
	[Range(0f, 1f)]
	public float HardFollowValue = 1f;

	[Header("If you want to hold cursor (cursor switch on TAB)")]
	public bool LockCursor = true;

	private bool rotateCamera = true;

	private RaycastHit sightObstacleHit;

	[Header("Layer mask to check obstacles in sight ray")]
	public LayerMask SightLayerMask;

	private Vector3 targetPosition;

	[Header("How far forward raycast should check collision for camera")]
	public float CollisionOffset = 1f;

	public EFUpdateClock UpdateClock;

	private void Start()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		targetDistance = (DistanceRanges.x + DistanceRanges.y) / 2f;
		animatedDistance = DistanceRanges.y;
		targetSphericRotation = new Vector2(((Component)this).transform.eulerAngles.y, ((Component)this).transform.eulerAngles.x);
		animatedSphericRotation = targetSphericRotation;
	}

	private void UpdateMethods()
	{
		InputCalculations();
		ZoomCalculations();
		FollowCalculations();
		RaycastCalculations();
		SwitchCalculations();
	}

	private void LateUpdate()
	{
		if (UpdateClock == EFUpdateClock.LateUpdate)
		{
			UpdateMethods();
		}
	}

	private void Update()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Invalid comparison between Unknown and I4
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Invalid comparison between Unknown and I4
		if (Input.GetMouseButtonDown(1) && (int)Cursor.lockState != 1)
		{
			HelperSwitchCursor();
		}
		if ((Input.GetKey((KeyCode)27) || Input.GetKeyDown((KeyCode)9)) && (int)Cursor.lockState == 1)
		{
			HelperSwitchCursor();
		}
		if (UpdateClock == EFUpdateClock.Update)
		{
			UpdateMethods();
		}
	}

	private void FixedUpdate()
	{
		if (UpdateClock == EFUpdateClock.FixedUpdate)
		{
			UpdateMethods();
		}
	}

	private void InputCalculations()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Invalid comparison between Unknown and I4
		targetDistance -= Input.GetAxis("Mouse ScrollWheel") * 5f;
		if (rotateCamera && (int)Cursor.lockState == 1)
		{
			targetSphericRotation.x += Input.GetAxis("Mouse X") * RotationSensitivity;
			targetSphericRotation.y -= Input.GetAxis("Mouse Y") * RotationSensitivity;
		}
	}

	private void ZoomCalculations()
	{
		if (!Object.op_Implicit((Object)(object)((RaycastHit)(ref sightObstacleHit)).transform))
		{
			targetDistance = Mathf.Clamp(targetDistance, DistanceRanges.x, DistanceRanges.y);
		}
		animatedDistance = Mathf.Lerp(animatedDistance, targetDistance, Time.deltaTime * 8f);
	}

	private void FollowCalculations()
	{
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		targetSphericRotation.y = HelperClampAngle(targetSphericRotation.y, RotationRanges.x, RotationRanges.y);
		if (RotationSpeed < 1f)
		{
			animatedSphericRotation = new Vector2(Mathf.LerpAngle(animatedSphericRotation.x, targetSphericRotation.x, Time.deltaTime * 30f * RotationSpeed), Mathf.LerpAngle(animatedSphericRotation.y, targetSphericRotation.y, Time.deltaTime * 30f * RotationSpeed));
		}
		else
		{
			animatedSphericRotation = targetSphericRotation;
		}
		Quaternion rotation = Quaternion.Euler(animatedSphericRotation.y, animatedSphericRotation.x, 0f);
		((Component)this).transform.rotation = rotation;
		Vector3 val = ((Component)ToFollow).transform.position + FollowingOffset;
		if (HardFollowValue < 1f)
		{
			float num = Mathf.Lerp(0.5f, 40f, HardFollowValue);
			val = Vector3.Lerp(targetPosition, val, Time.deltaTime * num);
		}
		targetPosition = val;
	}

	private void RaycastCalculations()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)ToFollow).transform.position + FollowingOffset + ((Component)this).transform.TransformVector(FollowingOffsetDirection);
		Quaternion val2 = Quaternion.Euler(targetSphericRotation.y, targetSphericRotation.x, 0f);
		Ray val3 = default(Ray);
		((Ray)(ref val3))..ctor(val, val2 * -Vector3.forward);
		if (Physics.Raycast(val3, ref sightObstacleHit, targetDistance + CollisionOffset, LayerMask.op_Implicit(SightLayerMask), (QueryTriggerInteraction)1))
		{
			((Component)this).transform.position = ((RaycastHit)(ref sightObstacleHit)).point - ((Ray)(ref val3)).direction * CollisionOffset;
			return;
		}
		Vector3 val4 = ((Component)this).transform.rotation * -Vector3.forward * animatedDistance;
		((Component)this).transform.position = targetPosition + val4 + ((Component)this).transform.TransformVector(FollowingOffsetDirection);
	}

	private void SwitchCalculations()
	{
		if (LockCursor && Input.GetKeyDown((KeyCode)9))
		{
			HelperSwitchCursor();
			if (Cursor.visible)
			{
				rotateCamera = false;
			}
			else
			{
				rotateCamera = true;
			}
		}
	}

	private float HelperClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}

	private void HelperSwitchCursor()
	{
		if (Cursor.visible)
		{
			if (Application.isFocused)
			{
				Cursor.lockState = (CursorLockMode)1;
				Cursor.visible = false;
			}
		}
		else
		{
			Cursor.lockState = (CursorLockMode)0;
			Cursor.visible = true;
		}
	}
}


using UnityEngine;

public abstract class FBasic_MaterialScriptBase : MonoBehaviour
{
	protected Material RendererMaterial;

	protected Renderer ObjectRenderer;

	protected Material GetRendererMaterial()
	{
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Expected O, but got Unknown
		if (!Application.isPlaying && (Object)(object)ObjectRenderer != (Object)null && (Object)(object)ObjectRenderer.sharedMaterial != (Object)(object)RendererMaterial)
		{
			RendererMaterial = null;
		}
		if ((Object)(object)RendererMaterial == (Object)null || (Object)(object)ObjectRenderer == (Object)null)
		{
			Renderer val = ((Component)this).gameObject.GetComponent<Renderer>();
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)this).gameObject.GetComponentInChildren<Renderer>();
			}
			if ((Object)(object)val == (Object)null)
			{
				Debug.Log((object)("<color=red>No renderer in " + ((Object)((Component)this).gameObject).name + "!</color>"));
				return null;
			}
			ObjectRenderer = val;
			if (Application.isPlaying)
			{
				RendererMaterial = val.material;
			}
			else
			{
				RendererMaterial = new Material(val.sharedMaterial);
			}
		}
		return RendererMaterial;
	}
}


using FIMSpace.Basics;
using UnityEngine;

public class FBasic_DuplicateObjects : MonoBehaviour
{
	public enum FEDuplicateDirection
	{
		GoIterative,
		GoFromCenter
	}

	public enum FEDuplicateOrigin
	{
		FromToDuplicate,
		FromComponent
	}

	[Tooltip("Put here object which you want duplicate")]
	public GameObject ToDuplicate;

	[Tooltip("How many copies in which axis")]
	public Vector3 DuplicatesCount = new Vector3(3f, 1f, 3f);

	[Tooltip("How far from each other should be created copies")]
	public Vector3 Offsets = new Vector3(3f, 0f, 3f);

	public Vector3 Randomize = new Vector3(0f, 0f, 0f);

	public Vector3 RandomRotate = new Vector3(0f, 0f, 0f);

	public Vector3 RandomScale = new Vector3(0f, 0f, 0f);

	public int Seed;

	[Tooltip("If you want raycast from up and put objects for example on terrain")]
	public bool PlaceOnGround;

	[Tooltip("Duplicates will be created when entered playmode")]
	public bool DuplicateAtStart;

	public float GizmosSize = 1f;

	public FEDuplicateDirection DuplicationType;

	public FEDuplicateOrigin DuplicationOrigin;

	private void Start()
	{
		if (DuplicateAtStart)
		{
			Duplicate();
		}
	}

	private void Reset()
	{
		Seed = Random.Range(-2147483646, 2147483646);
	}

	public void Duplicate()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_0315: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_0471: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0484: Unknown result type (might be due to invalid IL or missing references)
		//IL_049a: Unknown result type (might be due to invalid IL or missing references)
		//IL_049f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04dc: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ToDuplicate == (Object)null)
		{
			return;
		}
		Random.InitState(Seed);
		Vector3 val = ((DuplicationOrigin != FEDuplicateOrigin.FromComponent) ? ToDuplicate.transform.position : ((Component)this).transform.position);
		if (DuplicationType == FEDuplicateDirection.GoIterative)
		{
			RaycastHit val4 = default(RaycastHit);
			for (int i = 0; (float)i < DuplicatesCount.x; i++)
			{
				for (int j = 0; (float)j < DuplicatesCount.y; j++)
				{
					for (int k = 0; (float)k < DuplicatesCount.z; k++)
					{
						if (DuplicationOrigin == FEDuplicateOrigin.FromToDuplicate && i == 0 && j == 0 && k == 0)
						{
							continue;
						}
						Vector3 val2 = val;
						val2.x += (float)i * Offsets.x;
						val2.y += (float)j * Offsets.y;
						val2.z += (float)k * Offsets.z;
						GameObject val3 = Object.Instantiate<GameObject>(ToDuplicate);
						val3.transform.position = val2 + GetRandomVector();
						Transform transform = val3.transform;
						transform.rotation *= Quaternion.Euler(Random.Range(0f - RandomRotate.x, RandomRotate.x), Random.Range(0f - RandomRotate.y, RandomRotate.y), Random.Range(0f - RandomRotate.z, RandomRotate.z));
						Vector3 localScale = val3.transform.localScale + new Vector3(Random.Range(0f - RandomScale.x, RandomScale.x), Random.Range(0f - RandomScale.y, RandomScale.y), Random.Range(0f - RandomScale.z, RandomScale.z));
						val3.transform.localScale = localScale;
						if (PlaceOnGround)
						{
							Physics.Raycast(val3.transform.position + Vector3.up * 100f, Vector3.down, ref val4, 200f);
							if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val4)).transform))
							{
								val3.transform.position = ((RaycastHit)(ref val4)).point;
							}
						}
					}
				}
			}
		}
		else
		{
			if (DuplicationType != FEDuplicateDirection.GoFromCenter)
			{
				return;
			}
			Vector3 val5 = default(Vector3);
			RaycastHit val8 = default(RaycastHit);
			for (int l = 0; (float)l < DuplicatesCount.x; l++)
			{
				for (int m = 0; (float)m < DuplicatesCount.y; m++)
				{
					for (int n = 0; (float)n < DuplicatesCount.z; n++)
					{
						float num = 1f;
						float num2 = 1f;
						float num3 = 1f;
						if (l % 2 == 1)
						{
							num = -1f;
						}
						if (m % 2 == 1)
						{
							num2 = -1f;
						}
						if (n % 2 == 1)
						{
							num3 = -1f;
						}
						((Vector3)(ref val5))..ctor((float)l, (float)m, (float)n);
						if (l == 0)
						{
							val5.x = 0.5f;
						}
						if (m == 0)
						{
							val5.y = 0.5f;
						}
						if (n == 0)
						{
							val5.z = 0.5f;
						}
						Vector3 val6 = val;
						val6.x += val5.x * Offsets.x * num;
						val6.y += val5.y * Offsets.y * num2;
						val6.z += val5.z * Offsets.z * num3;
						GameObject val7 = Object.Instantiate<GameObject>(ToDuplicate);
						val7.transform.position = val6 + GetRandomVector();
						Transform transform2 = val7.transform;
						transform2.rotation *= Quaternion.Euler(Random.Range(0f - RandomRotate.x, RandomRotate.x), Random.Range(0f - RandomRotate.y, RandomRotate.y), Random.Range(0f - RandomRotate.z, RandomRotate.z));
						Vector3 localScale2 = val7.transform.localScale + new Vector3(Random.Range(0f - RandomScale.x, RandomScale.x), Random.Range(0f - RandomScale.y, RandomScale.y), Random.Range(0f - RandomScale.z, RandomScale.z));
						val7.transform.localScale = localScale2;
						if (PlaceOnGround)
						{
							Physics.Raycast(val7.transform.position + Vector3.up * 100f, Vector3.down, ref val8, 200f);
							if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val8)).transform))
							{
								val7.transform.position = ((RaycastHit)(ref val8)).point;
							}
						}
					}
				}
			}
		}
	}

	private void OnDrawGizmos()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ToDuplicate == (Object)null)
		{
			return;
		}
		Random.InitState(Seed);
		Vector3 val = ((DuplicationOrigin != FEDuplicateOrigin.FromComponent) ? ToDuplicate.transform.position : ((Component)this).transform.position);
		Gizmos.color = new Color(0.2f, 0.7f, 0.2f, 0.6f);
		if (DuplicationType == FEDuplicateDirection.GoIterative)
		{
			for (int i = 0; (float)i < DuplicatesCount.x; i++)
			{
				for (int j = 0; (float)j < DuplicatesCount.y; j++)
				{
					for (int k = 0; (float)k < DuplicatesCount.z; k++)
					{
						Vector3 val2 = val;
						val2.x += (float)i * Offsets.x;
						val2.y += (float)j * Offsets.y;
						val2.z += (float)k * Offsets.z;
						Gizmos.DrawCube(val2 + GetRandomVector(), Vector3.one * 0.25f * GizmosSize);
					}
				}
			}
		}
		else
		{
			if (DuplicationType != FEDuplicateDirection.GoFromCenter)
			{
				return;
			}
			Vector3 val3 = default(Vector3);
			for (int l = 0; (float)l < DuplicatesCount.x; l++)
			{
				for (int m = 0; (float)m < DuplicatesCount.y; m++)
				{
					for (int n = 0; (float)n < DuplicatesCount.z; n++)
					{
						float num = 1f;
						float num2 = 1f;
						float num3 = 1f;
						if (l % 2 == 1)
						{
							num = -1f;
						}
						if (m % 2 == 1)
						{
							num2 = -1f;
						}
						if (n % 2 == 1)
						{
							num3 = -1f;
						}
						((Vector3)(ref val3))..ctor((float)l, (float)m, (float)n);
						if (l == 0)
						{
							val3.x = 0.5f;
						}
						if (m == 0)
						{
							val3.y = 0.5f;
						}
						if (n == 0)
						{
							val3.z = 0.5f;
						}
						Vector3 val4 = val;
						val4.x += val3.x * Offsets.x * num;
						val4.y += val3.y * Offsets.y * num2;
						val4.z += val3.z * Offsets.z * num3;
						Gizmos.DrawCube(val4 + GetRandomVector(), Vector3.one * 0.25f * GizmosSize);
					}
				}
			}
		}
	}

	private Vector3 GetRandomVector()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (Randomize == Vector3.zero)
		{
			return Randomize;
		}
		return new Vector3(Random.Range(0f - Randomize.x, Randomize.x), Random.Range(0f - Randomize.y, Randomize.y), Random.Range(0f - Randomize.z, Randomize.z));
	}
}


public enum FEDuplicateDirection
{
	GoIterative,
	GoFromCenter
}


public enum FEDuplicateOrigin
{
	FromToDuplicate,
	FromComponent
}


using FIMSpace.Basics;
using UnityEngine;

public class FBasic_MaterialTiler : FBasic_MaterialScriptBase
{
	[Header("When you scale object change")]
	[Header("something in script to apply")]
	[Space(10f)]
	[Tooltip("Texture identificator in shader")]
	public string TextureProperty = "_MainTex";

	[Tooltip("How much tiles should be multiplied according to gameObject's scale")]
	public Vector2 ScaleValues = new Vector2(1f, 1f);

	[Tooltip("When scale on Y should be same as X")]
	public bool EqualDimensions;

	private void OnValidate()
	{
		GetRendererMaterial();
		if (EqualDimensions)
		{
			ScaleValues.y = ScaleValues.x;
		}
		TileMaterialToScale();
	}

	private void TileMaterialToScale()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)RendererMaterial == (Object)null) && !((Object)(object)ObjectRenderer == (Object)null))
		{
			Vector2 scaleValues = ScaleValues;
			scaleValues.x *= ((Component)this).transform.localScale.x;
			scaleValues.y *= ((Component)this).transform.localScale.z;
			RendererMaterial.SetTextureScale("_MainTex", scaleValues);
			ObjectRenderer.material = RendererMaterial;
		}
	}
}


using System.Collections.Generic;
using FIMSpace;
using UnityEngine;

public class FAnimationClips : Dictionary<string, int>
{
	public readonly Animator Animator;

	public int Layer;

	public string CurrentAnimation { get; private set; }

	public string PreviousAnimation { get; private set; }

	public FAnimationClips(Animator animator)
	{
		Animator = animator;
		CurrentAnimation = "";
		PreviousAnimation = "";
	}

	public void Add(string clipName, bool exactClipName = false)
	{
		AddClip(clipName, exactClipName);
	}

	public void AddClip(string clipName, bool exactClipName = false)
	{
		AddClip(Animator, clipName, exactClipName);
	}

	public void AddClip(Animator animator, string clipName, bool exactClipName = false)
	{
		if (!Object.op_Implicit((Object)(object)animator))
		{
			Debug.LogError((object)"No animator!");
			return;
		}
		string text = "";
		if (!exactClipName)
		{
			if (animator.StateExists(clipName, Layer))
			{
				text = clipName;
			}
			else if (animator.StateExists(clipName.CapitalizeFirstLetter()))
			{
				text = clipName.CapitalizeFirstLetter();
			}
			else if (animator.StateExists(clipName.ToLower(), Layer))
			{
				text = clipName.ToLower();
			}
			else if (animator.StateExists(clipName.ToUpper(), Layer))
			{
				text = clipName.ToUpper();
			}
		}
		else if (animator.StateExists(clipName, Layer))
		{
			text = clipName;
		}
		if (text == "")
		{
			Debug.LogWarning((object)("Clip with name " + clipName + " not exists in animator from game object " + ((Object)((Component)animator).gameObject).name));
		}
		else if (!ContainsKey(clipName))
		{
			Add(clipName, Animator.StringToHash(text));
		}
	}

	public void CrossFadeInFixedTime(string clip, float transitionTime = 0.25f, float timeOffset = 0f, bool startOver = false)
	{
		if (ContainsKey(clip))
		{
			RefreshClipMemory(clip);
			if (startOver)
			{
				Animator.CrossFadeInFixedTime(base[clip], transitionTime, Layer, timeOffset);
			}
			else if (!IsPlaying(clip))
			{
				Animator.CrossFadeInFixedTime(base[clip], transitionTime, Layer, timeOffset);
			}
		}
	}

	public void CrossFade(string clip, float transitionTime = 0.25f, float timeOffset = 0f, bool startOver = false)
	{
		if (ContainsKey(clip))
		{
			RefreshClipMemory(clip);
			if (startOver)
			{
				Animator.CrossFade(base[clip], transitionTime, Layer, timeOffset);
			}
			else if (!IsPlaying(clip))
			{
				Animator.CrossFade(base[clip], transitionTime, Layer, timeOffset);
			}
		}
	}

	private void RefreshClipMemory(string name)
	{
		if (name != CurrentAnimation)
		{
			PreviousAnimation = CurrentAnimation;
			CurrentAnimation = name;
		}
	}

	public void SetFloat(string parameter, float value = 0f, float deltaSpeed = 60f)
	{
		float @float = Animator.GetFloat(parameter);
		@float = ((!(deltaSpeed >= 60f)) ? FLogicMethods.FLerp(@float, value, Time.deltaTime * deltaSpeed) : value);
		Animator.SetFloat(parameter, @float);
	}

	public void SetFloatUnscaledDelta(string parameter, float value = 0f, float deltaSpeed = 60f)
	{
		float @float = Animator.GetFloat(parameter);
		@float = ((!(deltaSpeed >= 60f)) ? FLogicMethods.FLerp(@float, value, Time.unscaledDeltaTime * deltaSpeed) : value);
		Animator.SetFloat(parameter, @float);
	}

	internal bool IsPlaying(string clip)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		AnimatorStateInfo val;
		if (Animator.IsInTransition(Layer))
		{
			val = Animator.GetNextAnimatorStateInfo(Layer);
			if (((AnimatorStateInfo)(ref val)).shortNameHash == base[clip])
			{
				return true;
			}
		}
		else
		{
			val = Animator.GetCurrentAnimatorStateInfo(Layer);
			if (((AnimatorStateInfo)(ref val)).shortNameHash == base[clip])
			{
				return true;
			}
		}
		return false;
	}
}


using FIMSpace;
using UnityEngine;

public class FAnimator
{
	public readonly Animator Animator;

	public string CurrentAnimation { get; private set; }

	public string PreviousAnimation { get; private set; }

	public int Layer { get; private set; }

	public FAnimator(Animator animator, int layer = 0)
	{
		Animator = animator;
		CurrentAnimation = "";
		PreviousAnimation = "";
		Layer = layer;
	}

	public bool ContainsClip(string clipName, bool exactClipName = false)
	{
		if (!Object.op_Implicit((Object)(object)Animator))
		{
			Debug.LogError((object)"No animator!");
			return false;
		}
		string text = "";
		if (!exactClipName)
		{
			if (Animator.StateExists(clipName, Layer))
			{
				text = clipName;
			}
			else if (Animator.StateExists(clipName.CapitalizeFirstLetter()))
			{
				text = clipName.CapitalizeFirstLetter();
			}
			else if (Animator.StateExists(clipName.ToLower(), Layer))
			{
				text = clipName.ToLower();
			}
			else if (Animator.StateExists(clipName.ToUpper(), Layer))
			{
				text = clipName.ToUpper();
			}
		}
		else if (Animator.StateExists(clipName, Layer))
		{
			text = clipName;
		}
		if (text == "")
		{
			Debug.LogWarning((object)("Clip with name " + clipName + " not exists in animator from game object " + ((Object)((Component)Animator).gameObject).name));
			return false;
		}
		return true;
	}

	public void CrossFadeInFixedTime(string clip, float transitionTime = 0.25f, float timeOffset = 0f, bool startOver = false)
	{
		RefreshClipMemory(clip);
		if (startOver)
		{
			Animator.CrossFadeInFixedTime(clip, transitionTime, Layer, timeOffset);
		}
		else if (!IsPlaying(clip))
		{
			Animator.CrossFadeInFixedTime(clip, transitionTime, Layer, timeOffset);
		}
	}

	public void CrossFade(string clip, float transitionTime = 0.25f, float timeOffset = 0f, bool startOver = false)
	{
		RefreshClipMemory(clip);
		if (startOver)
		{
			Animator.CrossFade(clip, transitionTime, Layer, timeOffset);
		}
		else if (!IsPlaying(clip))
		{
			Animator.CrossFade(clip, transitionTime, Layer, timeOffset);
		}
	}

	private void RefreshClipMemory(string name)
	{
		if (name != CurrentAnimation)
		{
			PreviousAnimation = CurrentAnimation;
			CurrentAnimation = name;
		}
	}

	public void SetFloat(string parameter, float value = 0f, float deltaSpeed = 60f)
	{
		float @float = Animator.GetFloat(parameter);
		@float = ((!(deltaSpeed >= 60f)) ? FLogicMethods.FLerp(@float, value, Time.deltaTime * deltaSpeed) : value);
		Animator.SetFloat(parameter, @float);
	}

	public void SetFloatUnscaledDelta(string parameter, float value = 0f, float deltaSpeed = 60f)
	{
		float @float = Animator.GetFloat(parameter);
		@float = ((!(deltaSpeed >= 60f)) ? FLogicMethods.FLerp(@float, value, Time.unscaledDeltaTime * deltaSpeed) : value);
		Animator.SetFloat(parameter, @float);
	}

	internal bool IsPlaying(string clip)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		AnimatorStateInfo val;
		if (Animator.IsInTransition(Layer))
		{
			val = Animator.GetNextAnimatorStateInfo(Layer);
			if (((AnimatorStateInfo)(ref val)).shortNameHash == Animator.StringToHash(clip))
			{
				return true;
			}
		}
		else
		{
			val = Animator.GetCurrentAnimatorStateInfo(Layer);
			if (((AnimatorStateInfo)(ref val)).shortNameHash == Animator.StringToHash(clip))
			{
				return true;
			}
		}
		return false;
	}
}


public enum EFUpdateClock
{
	Update,
	LateUpdate,
	FixedUpdate
}


using UnityEngine;

public static class AnimationGenerateUtils
{
	public static AnimationCurve ReduceKeyframes(AnimationCurve curve, float maxError)
	{
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Expected O, but got Unknown
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		Keyframe[] array = curve.keys;
		int num = 1;
		while (array.Length > 2 && num < array.Length - 1)
		{
			Keyframe[] array2 = (Keyframe[])(object)new Keyframe[array.Length - 1];
			int num2 = 0;
			for (int i = 0; i < array.Length; i++)
			{
				if (num != i)
				{
					array2[num2] = new Keyframe(((Keyframe)(ref array[i])).time, ((Keyframe)(ref array[i])).value, ((Keyframe)(ref array[i])).inTangent, ((Keyframe)(ref array[i])).outTangent);
					num2++;
				}
			}
			AnimationCurve val = new AnimationCurve
			{
				keys = array2
			};
			float num3 = Mathf.Abs(val.Evaluate(((Keyframe)(ref array[num])).time) - ((Keyframe)(ref array[num])).value);
			float num4 = ((Keyframe)(ref array[num])).time + (((Keyframe)(ref array[num - 1])).time - ((Keyframe)(ref array[num])).time) * 0.5f;
			float num5 = ((Keyframe)(ref array[num])).time + (((Keyframe)(ref array[num + 1])).time - ((Keyframe)(ref array[num])).time) * 0.5f;
			float num6 = Mathf.Abs(val.Evaluate(num4) - curve.Evaluate(num4));
			float num7 = Mathf.Abs(val.Evaluate(num5) - curve.Evaluate(num5));
			if (num3 < maxError && num6 < maxError && num7 < maxError)
			{
				array = array2;
			}
			else
			{
				num++;
			}
		}
		return new AnimationCurve(array);
	}

	public static void LoopCurve(ref AnimationCurve curve, bool averageBoth = false, float? endTime = null)
	{
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		if (curve.keys.Length != 0)
		{
			num = ((Keyframe)(ref curve.keys[0])).value;
		}
		if (!endTime.HasValue)
		{
			if (curve.keys.Length == 0)
			{
				curve.AddKey(new Keyframe(0f, num));
				curve.AddKey(new Keyframe(1f, num));
				return;
			}
			if (curve.keys.Length == 1)
			{
				curve.AddKey(new Keyframe(Mathf.Max(1f, ((Keyframe)(ref curve.keys[0])).time + 0.5f), num));
				return;
			}
			float num2 = num;
			if (averageBoth)
			{
				num2 = Mathf.Lerp(num, ((Keyframe)(ref curve.keys[curve.keys.Length - 1])).value, 0.5f);
			}
			curve.MoveKey(0, new Keyframe(((Keyframe)(ref curve.keys[0])).time, num2));
			curve.MoveKey(curve.keys.Length - 1, new Keyframe(((Keyframe)(ref curve.keys[curve.keys.Length - 1])).time, num2));
			return;
		}
		float value = endTime.Value;
		if (curve.keys.Length == 0)
		{
			curve.AddKey(new Keyframe(0f, num));
			curve.AddKey(new Keyframe(value, num));
			return;
		}
		if (curve.keys.Length == 1)
		{
			curve.AddKey(new Keyframe(value, num));
			return;
		}
		float num3 = num;
		if (averageBoth)
		{
			num3 = Mathf.Lerp(num, ((Keyframe)(ref curve.keys[curve.keys.Length - 1])).value, 0.5f);
		}
		Keyframe val = curve.keys[curve.keys.Length - 1];
		float num4 = ((Keyframe)(ref val)).time;
		if (num4 != value && num4 < value && value - num4 < value * 0.1f)
		{
			num4 = value;
		}
		curve.MoveKey(0, new Keyframe(((Keyframe)(ref curve.keys[0])).time, num3));
		curve.MoveKey(curve.keys.Length - 1, new Keyframe(num4, num3));
	}

	public static void DistrubuteCurveOnTime(ref AnimationCurve curve, float startTime, float endTime)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Expected O, but got Unknown
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		float time = ((Keyframe)(ref curve.keys[0])).time;
		float time2 = ((Keyframe)(ref curve.keys[curve.keys.Length - 1])).time;
		Keyframe[] array = (Keyframe[])(object)new Keyframe[curve.keys.Length];
		curve.keys.CopyTo(array, 0);
		AnimationCurve val = new AnimationCurve(array);
		while (curve.keys.Length != 0)
		{
			curve.RemoveKey(curve.keys.Length - 1);
		}
		for (int i = 0; i < val.keys.Length; i++)
		{
			Keyframe val2 = val.keys[i];
			Keyframe val3 = val2;
			((Keyframe)(ref val3)).time = Mathf.Lerp(startTime, endTime, Mathf.InverseLerp(time, time2, ((Keyframe)(ref val2)).time));
			curve.AddKey(val3);
		}
	}

	public static Quaternion EnsureQuaternionContinuity(Quaternion latestRot, Quaternion targetRot, bool normalize = false)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = default(Quaternion);
		((Quaternion)(ref val))..ctor(0f - targetRot.x, 0f - targetRot.y, 0f - targetRot.z, 0f - targetRot.w);
		Quaternion val2 = default(Quaternion);
		((Quaternion)(ref val2))..ctor(Mathf.LerpUnclamped(latestRot.x, targetRot.x, 0.5f), Mathf.LerpUnclamped(latestRot.y, targetRot.y, 0.5f), Mathf.LerpUnclamped(latestRot.z, targetRot.z, 0.5f), Mathf.LerpUnclamped(latestRot.w, targetRot.w, 0.5f));
		Quaternion val3 = default(Quaternion);
		((Quaternion)(ref val3))..ctor(Mathf.LerpUnclamped(latestRot.x, val.x, 0.5f), Mathf.LerpUnclamped(latestRot.y, val.y, 0.5f), Mathf.LerpUnclamped(latestRot.z, val.z, 0.5f), Mathf.LerpUnclamped(latestRot.w, val.w, 0.5f));
		float num = Quaternion.Angle(latestRot, val2);
		float num2 = Quaternion.Angle(latestRot, val3);
		if (normalize)
		{
			if (!(num2 < num))
			{
				return ((Quaternion)(ref targetRot)).normalized;
			}
			return ((Quaternion)(ref val)).normalized;
		}
		if (!(num2 < num))
		{
			return targetRot;
		}
		return val;
	}

	public static void UpdateHumanoidIKPreview(Animator mecanim, AnimationClip clip, float time, bool restoreAnimator = true)
	{
	}
}


using System.Collections.Generic;
using FIMSpace.AnimationTools;
using UnityEngine;

public static class SkeletonRecognize
{
	public enum EWhatIsIt
	{
		Unknown,
		Humanoidal,
		Quadroped,
		Creature
	}

	public class SkeletonInfo
	{
		public Transform AnimatorTransform;

		public float LowestVsHighestLen;

		public float MostLeftVsMostRightLen;

		public float MostForwVsMostBackLen;

		public float AverageLen;

		public Transform ProbablyRootBone;

		public Transform ProbablyHips;

		public Transform ProbablyChest;

		public Transform ProbablyHead;

		public List<Transform> TrReachingGround = new List<Transform>();

		public List<Transform> TrReachingSides = new List<Transform>();

		public List<Transform> TrEnds = new List<Transform>();

		public List<Transform> ProbablySpineChain = new List<Transform>();

		public List<Transform> ProbablySpineChainShort = new List<Transform>();

		public List<List<Transform>> ProbablyRightArms = new List<List<Transform>>();

		public List<List<Transform>> ProbablyLeftArms = new List<List<Transform>>();

		public List<List<Transform>> ProbablyLeftLegs = new List<List<Transform>>();

		public List<Transform> ProbablyLeftLegRoot = new List<Transform>();

		public List<List<Transform>> ProbablyRightLegs = new List<List<Transform>>();

		public List<Transform> ProbablyRightLegRoot = new List<Transform>();

		public Vector3 LocalSpaceHighest = Vector3.zero;

		public Vector3 LocalSpaceMostRight = Vector3.zero;

		public Vector3 LocalSpaceMostForward = Vector3.zero;

		public Vector3 LocalSpaceMostBack = Vector3.zero;

		public Vector3 LocalSpaceMostLeft = Vector3.zero;

		public Vector3 LocalSpaceLowest = Vector3.zero;

		public EWhatIsIt WhatIsIt;

		public int SpineChainLength => ProbablySpineChain.Count;

		public int LeftArms => ProbablyLeftArms.Count;

		public int LeftLegs => ProbablyLeftLegs.Count;

		public int RightArms => ProbablyRightArms.Count;

		public int RightLegs => ProbablyRightLegs.Count;

		public int Legs => RightLegs + LeftLegs;

		public int Arms => LeftArms + RightArms;

		public SkeletonInfo(Transform t, List<Transform> checkOnly = null, Transform pelvisHelp = null)
		{
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_0119: Unknown result type (might be due to invalid IL or missing references)
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_0129: Unknown result type (might be due to invalid IL or missing references)
			//IL_012b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01da: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_0214: Unknown result type (might be due to invalid IL or missing references)
			//IL_020b: Unknown result type (might be due to invalid IL or missing references)
			//IL_020d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0230: Unknown result type (might be due to invalid IL or missing references)
			//IL_0229: Unknown result type (might be due to invalid IL or missing references)
			//IL_022b: Unknown result type (might be due to invalid IL or missing references)
			//IL_024e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0245: Unknown result type (might be due to invalid IL or missing references)
			//IL_0247: Unknown result type (might be due to invalid IL or missing references)
			//IL_0263: Unknown result type (might be due to invalid IL or missing references)
			//IL_0265: Unknown result type (might be due to invalid IL or missing references)
			//IL_058c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0591: Unknown result type (might be due to invalid IL or missing references)
			//IL_0593: Unknown result type (might be due to invalid IL or missing references)
			//IL_05cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_05ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_0603: Unknown result type (might be due to invalid IL or missing references)
			//IL_1027: Unknown result type (might be due to invalid IL or missing references)
			//IL_102c: Unknown result type (might be due to invalid IL or missing references)
			//IL_1053: Unknown result type (might be due to invalid IL or missing references)
			//IL_1058: Unknown result type (might be due to invalid IL or missing references)
			//IL_105d: Unknown result type (might be due to invalid IL or missing references)
			//IL_1085: Unknown result type (might be due to invalid IL or missing references)
			//IL_108a: Unknown result type (might be due to invalid IL or missing references)
			//IL_10a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_10ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_10b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_10da: Unknown result type (might be due to invalid IL or missing references)
			//IL_10df: Unknown result type (might be due to invalid IL or missing references)
			//IL_10fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_1102: Unknown result type (might be due to invalid IL or missing references)
			//IL_1107: Unknown result type (might be due to invalid IL or missing references)
			//IL_0777: Unknown result type (might be due to invalid IL or missing references)
			//IL_077c: Unknown result type (might be due to invalid IL or missing references)
			//IL_077e: Unknown result type (might be due to invalid IL or missing references)
			//IL_068e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0693: Unknown result type (might be due to invalid IL or missing references)
			//IL_0695: Unknown result type (might be due to invalid IL or missing references)
			//IL_079f: Unknown result type (might be due to invalid IL or missing references)
			//IL_06ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_09a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_09b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_07b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_09ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_09f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a96: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a9b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a9d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ab3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ac8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0acf: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a28: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a2d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a2f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b39: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b45: Unknown result type (might be due to invalid IL or missing references)
			//IL_0adb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ae0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a45: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a5d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a67: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a73: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a78: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d29: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d2e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e56: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e5b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0dd9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0f05: Unknown result type (might be due to invalid IL or missing references)
			AnimatorTransform = t;
			Transform[] array;
			if (checkOnly != null)
			{
				array = (Transform[])(object)new Transform[checkOnly.Count];
				for (int i = 0; i < checkOnly.Count; i++)
				{
					array[i] = checkOnly[i];
				}
			}
			else
			{
				array = ((Component)AnimatorTransform).GetComponentsInChildren<Transform>(true);
			}
			if (array.Length != 0)
			{
				LocalSpaceLowest = (LocalSpaceMostLeft = (LocalSpaceMostBack = (LocalSpaceMostForward = (LocalSpaceMostRight = (LocalSpaceHighest = AnimatorTransform.InverseTransformPoint(array[0].position))))));
			}
			List<Transform> list = new List<Transform>();
			foreach (Transform val in array)
			{
				if (!((Object)(object)((Component)val).GetComponentInChildren<SkinnedMeshRenderer>() != (Object)null))
				{
					list.Add(val);
				}
			}
			for (int k = 0; k < list.Count; k++)
			{
				Transform val2 = list[k];
				if (!Object.op_Implicit((Object)(object)((Component)val2).GetComponent<SkinnedMeshRenderer>()))
				{
					Vector3 val3 = AnimatorTransform.InverseTransformPoint(val2.position);
					if (val3.x > LocalSpaceMostRight.x)
					{
						LocalSpaceMostRight = val3;
					}
					else if (val3.x < LocalSpaceMostLeft.x)
					{
						LocalSpaceMostLeft = val3;
					}
					if (val3.z > LocalSpaceMostForward.z)
					{
						LocalSpaceMostForward = val3;
					}
					else if (val3.z < LocalSpaceMostBack.z)
					{
						LocalSpaceMostBack = val3;
					}
					if (val3.y > LocalSpaceHighest.y)
					{
						LocalSpaceHighest = val3;
					}
					else if (val3.y < LocalSpaceLowest.y)
					{
						LocalSpaceLowest = val3;
					}
				}
			}
			LowestVsHighestLen = Mathf.Abs(LocalSpaceLowest.y - LocalSpaceHighest.y);
			MostLeftVsMostRightLen = Mathf.Abs(LocalSpaceMostLeft.x - LocalSpaceMostRight.x);
			MostForwVsMostBackLen = Mathf.Abs(LocalSpaceMostForward.z - LocalSpaceMostBack.z);
			AverageLen = (LowestVsHighestLen + MostLeftVsMostRightLen + MostForwVsMostBackLen) / 3f;
			_ = LowestVsHighestLen;
			for (int l = 0; l < list.Count; l++)
			{
				Transform val4 = list[l];
				if (NameContains(((Object)val4).name, ShouldersNames))
				{
					Transform bottomMostChildTransform = GetBottomMostChildTransform(val4);
					if (NotContainedYetByLimbs(bottomMostChildTransform))
					{
						TrReachingSides.Add(bottomMostChildTransform);
					}
				}
				else if (NameContains(((Object)val4).name, ElbowNames))
				{
					Transform bottomMostChildTransform2 = GetBottomMostChildTransform(val4);
					if (NotContainedYetByLimbs(bottomMostChildTransform2))
					{
						TrReachingSides.Add(bottomMostChildTransform2);
					}
				}
			}
			for (int m = 0; m < list.Count; m++)
			{
				Transform val5 = list[m];
				if (NameContains(((Object)val5).name, UpperLegNames))
				{
					Transform bottomMostChildTransform3 = GetBottomMostChildTransform(val5);
					if (NotContainedYetByLimbs(bottomMostChildTransform3))
					{
						TrReachingGround.Add(bottomMostChildTransform3);
					}
				}
				else if (NameContains(((Object)val5).name, KneeNames))
				{
					Transform bottomMostChildTransform4 = GetBottomMostChildTransform(val5);
					if (NotContainedYetByLimbs(bottomMostChildTransform4))
					{
						TrReachingGround.Add(bottomMostChildTransform4);
					}
				}
			}
			bool flag = false;
			for (int n = 0; n < list.Count; n++)
			{
				Transform val6 = list[n];
				if (NameContains(((Object)val6).name, PelvisNames))
				{
					flag = true;
					ProbablyHips = val6;
					break;
				}
			}
			bool flag2 = false;
			for (int num = 0; num < list.Count; num++)
			{
				Transform val7 = list[num];
				if (NameContains(((Object)val7).name, ChestNames))
				{
					flag2 = true;
					ProbablyChest = val7;
					break;
				}
			}
			bool flag3 = false;
			for (int num2 = 0; num2 < list.Count; num2++)
			{
				Transform val8 = list[num2];
				if (NameContains(((Object)val8).name, HeadNames))
				{
					flag3 = true;
					ProbablyHead = val8;
					break;
				}
			}
			if ((Object)(object)ProbablyHead != (Object)null && (Object)(object)ProbablyHips != (Object)null && !IsChildOf(ProbablyHead, ProbablyHips))
			{
				ProbablyHead = null;
			}
			for (int num3 = 0; num3 < list.Count; num3++)
			{
				Transform val9 = list[num3];
				if (NameContains(((Object)val9).name, RootNames))
				{
					ProbablyRootBone = val9;
					break;
				}
			}
			if (list.Count > 2)
			{
				for (int num4 = 1; num4 < list.Count; num4++)
				{
					Transform val10 = list[num4];
					if (val10.childCount != 0)
					{
						continue;
					}
					TrEnds.Add(val10);
					Vector3 val11 = Loc(val10);
					if (val11.y < LocalSpaceLowest.y + LowestVsHighestLen * 0.1f)
					{
						if (NotContainedYetByLimbs(val10))
						{
							TrReachingGround.Add(val10);
						}
					}
					else if (val11.y > LocalSpaceLowest.y + LowestVsHighestLen * 0.2f && (val11.x < MostLeftVsMostRightLen * -0.1f || val11.x > MostLeftVsMostRightLen * 0.1f) && NotContainedYetByLimbs(val10))
					{
						TrReachingSides.Add(val10);
					}
				}
			}
			if (!flag2)
			{
				List<Transform> list2 = new List<Transform>();
				for (int num5 = 0; num5 < TrReachingSides.Count; num5++)
				{
					if (Object.op_Implicit((Object)(object)((Component)list[num5]).GetComponent<SkinnedMeshRenderer>()))
					{
						continue;
					}
					Transform parent = TrReachingSides[num5].parent;
					while ((Object)(object)parent != (Object)null)
					{
						if (parent.childCount > 2)
						{
							Vector3 val12 = Loc(parent);
							if (val12.x > (0f - MostLeftVsMostRightLen) * 0.03f && val12.x < MostLeftVsMostRightLen * 0.03f)
							{
								list2.Add(parent);
								break;
							}
						}
						parent = parent.parent;
					}
				}
				if (list2.Count == 1)
				{
					ProbablyChest = list2[0];
				}
				else if (list2.Count > 1 && (Object)(object)list2[0] == (Object)(object)list2[1])
				{
					ProbablyChest = list2[0];
				}
			}
			if (!flag)
			{
				List<Transform> list3 = new List<Transform>();
				for (int num6 = 0; num6 < TrReachingGround.Count; num6++)
				{
					Transform parent2 = TrReachingGround[num6].parent;
					while ((Object)(object)parent2 != (Object)null)
					{
						if (parent2.childCount > 2)
						{
							Vector3 val13 = Loc(parent2);
							if (val13.y > LocalSpaceLowest.y + LowestVsHighestLen * 0.04f && val13.x > (0f - MostLeftVsMostRightLen) * 0.02f && val13.x < MostLeftVsMostRightLen * 0.02f)
							{
								list3.Add(parent2);
								break;
							}
						}
						parent2 = parent2.parent;
					}
				}
				if (list3.Count == 1)
				{
					ProbablyChest = list3[0];
				}
				else if (list3.Count > 1 && (Object)(object)list3[0] == (Object)(object)list3[1])
				{
					ProbablyHips = list3[0];
				}
			}
			if ((Object)(object)ProbablyHips == (Object)null)
			{
				ProbablyHips = pelvisHelp;
			}
			if (((Object)(object)ProbablyChest == (Object)null || (Object)(object)ProbablyChest == (Object)(object)ProbablyHips || ((Object)(object)ProbablyHips != (Object)null && !IsChildOf(ProbablyChest, ProbablyHips))) && Object.op_Implicit((Object)(object)ProbablyHips) && Object.op_Implicit((Object)(object)ProbablyHead))
			{
				Transform parent3 = ProbablyHead.parent;
				bool flag4 = false;
				while ((Object)(object)parent3.parent != (Object)null && (Object)(object)parent3.parent != (Object)(object)ProbablyHips)
				{
					if (parent3.childCount > 2)
					{
						for (int num7 = 0; num7 < TrReachingSides.Count; num7++)
						{
							if (IsChildOf(TrReachingSides[num7], parent3))
							{
								flag4 = true;
								break;
							}
						}
					}
					if (flag4)
					{
						break;
					}
					parent3 = parent3.parent;
				}
				if (flag4)
				{
					ProbablyChest = parent3;
				}
			}
			if ((Object)(object)ProbablyHips == (Object)null)
			{
				ProbablyHips = pelvisHelp;
			}
			if (Object.op_Implicit((Object)(object)ProbablyChest) && Object.op_Implicit((Object)(object)ProbablyHips))
			{
				if (MostForwVsMostBackLen > LowestVsHighestLen * 0.9f && Loc(ProbablyChest).z < Loc(ProbablyHips).z)
				{
					Transform probablyChest = ProbablyChest;
					ProbablyChest = ProbablyHips;
					ProbablyHips = probablyChest;
					Debug.Log((object)"Hips - Chest - Reversed Detection Swap!");
				}
				if (!flag3)
				{
					Vector3 val14 = Vector3.zero;
					for (int num8 = 0; num8 < ProbablyChest.childCount; num8++)
					{
						Transform child = ProbablyChest.GetChild(num8);
						Vector3 val15;
						if (child.childCount > 0)
						{
							for (int num9 = 0; num9 < child.childCount; num9++)
							{
								Transform child2 = child.GetChild(num9);
								val15 = Loc(child2);
								if (val15.x > (0f - MostLeftVsMostRightLen) * 0.04f && val15.x < MostLeftVsMostRightLen * 0.04f && Loc(child2).y > val14.y)
								{
									val14 = Loc(child2);
									ProbablyHead = child2;
								}
							}
						}
						val15 = Loc(child);
						if (val15.x > (0f - MostLeftVsMostRightLen) * 0.04f && val15.x < MostLeftVsMostRightLen * 0.04f && val15.y > val14.y)
						{
							val14 = Loc(child);
							ProbablyHead = child;
						}
					}
					if (Object.op_Implicit((Object)(object)ProbablyChest) && Object.op_Implicit((Object)(object)ProbablyHead) && Object.op_Implicit((Object)(object)ProbablyHips))
					{
						float num10 = Vector3.Distance(Loc(ProbablyChest), Loc(ProbablyHips));
						if ((ProbablyChest.childCount < 3 || num10 < AverageLen * 0.12f) && ProbablyHead.childCount > 1)
						{
							ProbablyChest = ProbablyHead;
							ProbablyHead = GetHighestChild(ProbablyHead, AnimatorTransform, MostLeftVsMostRightLen * 0.05f);
							if ((Object)(object)ProbablyHead == (Object)(object)ProbablyChest)
							{
								ProbablyHead = ProbablyChest.GetChild(0);
							}
						}
					}
				}
				if (Object.op_Implicit((Object)(object)ProbablyHead))
				{
					for (int num11 = TrReachingSides.Count - 1; num11 >= 0; num11--)
					{
						if (IsChildOf(TrReachingSides[num11], ProbablyHead))
						{
							TrReachingSides.RemoveAt(num11);
						}
					}
				}
				for (int num12 = TrReachingSides.Count - 1; num12 >= 0; num12--)
				{
					if (GetDepth(TrReachingSides[num12], AnimatorTransform) < 5)
					{
						TrReachingSides.RemoveAt(num12);
					}
				}
				Transform val16 = null;
				if (Object.op_Implicit((Object)(object)ProbablyHead))
				{
					ProbablySpineChain.Add(ProbablyHead);
					val16 = ProbablyHead.parent;
				}
				while ((Object)(object)val16 != (Object)null && (Object)(object)val16 != (Object)(object)ProbablyHips)
				{
					ProbablySpineChain.Add(val16);
					val16 = val16.parent;
				}
				ProbablySpineChain.Reverse();
				for (int num13 = 0; num13 < Mathf.Min(4, ProbablySpineChain.Count); num13++)
				{
					ProbablySpineChainShort.Add(ProbablySpineChain[num13]);
				}
				List<Transform> list4 = new List<Transform>();
				for (int num14 = 0; num14 < TrReachingGround.Count; num14++)
				{
					Transform val17 = TrReachingGround[num14];
					Vector3 val18 = Loc(val17);
					List<Transform> list5 = new List<Transform>();
					Transform val19 = val17;
					while ((Object)(object)val19 != (Object)null && (Object)(object)val19 != (Object)(object)ProbablyHips && (Object)(object)val19 != (Object)(object)ProbablyChest)
					{
						list5.Add(val19);
						val19 = val19.parent;
					}
					if (list5.Count >= 3)
					{
						List<Transform> item = new List<Transform>
						{
							list5[list5.Count - 1],
							list5[list5.Count - 2],
							list5[list5.Count - 3]
						};
						list4.Add(val17);
						if (val18.x < MostLeftVsMostRightLen * 0.02f)
						{
							ProbablyLeftLegs.Add(item);
							ProbablyLeftLegRoot.Add(val19);
						}
						else
						{
							ProbablyRightLegs.Add(item);
							ProbablyRightLegRoot.Add(val19);
						}
					}
				}
				for (int num15 = 0; num15 < TrReachingSides.Count; num15++)
				{
					Transform val20 = TrReachingSides[num15];
					Vector3 val21 = Loc(val20);
					List<Transform> list6 = new List<Transform>();
					Transform val22 = val20;
					while ((Object)(object)val22 != (Object)null && (Object)(object)val22 != (Object)(object)ProbablyChest)
					{
						list6.Add(val22);
						val22 = val22.parent;
					}
					if (list6.Count >= 4)
					{
						List<Transform> item2 = new List<Transform>
						{
							list6[list6.Count - 1],
							list6[list6.Count - 2],
							list6[list6.Count - 3],
							list6[list6.Count - 4]
						};
						if (val21.x < MostLeftVsMostRightLen * 0.02f)
						{
							ProbablyLeftArms.Add(item2);
						}
						else
						{
							ProbablyRightArms.Add(item2);
						}
					}
				}
				ClearDuplicates(ProbablyLeftArms, null);
				ClearDuplicates(ProbablyRightArms, null);
				ClearDuplicates(ProbablyLeftLegs, ProbablyLeftLegRoot);
				ClearDuplicates(ProbablyRightLegs, ProbablyRightLegRoot);
				if (Legs == 2 && Arms == 2)
				{
					WhatIsIt = EWhatIsIt.Humanoidal;
				}
				else if (Legs == 4 && Arms == 0)
				{
					WhatIsIt = EWhatIsIt.Quadroped;
				}
				else if (Legs > 0 || Arms > 0)
				{
					WhatIsIt = EWhatIsIt.Creature;
				}
				else
				{
					WhatIsIt = EWhatIsIt.Unknown;
				}
			}
			float num16 = Mathf.Lerp(LocalSpaceLowest.y, LocalSpaceHighest.y, 0.5f);
			Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, LocalSpaceHighest.y, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, LocalSpaceLowest.y, LocalSpaceMostForward.z)), Color.green, 12f);
			Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, num16, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostRight.x, num16, LocalSpaceMostForward.z)), Color.red, 12f);
			Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostRight.x, num16, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostRight.x, num16, LocalSpaceMostBack.z)), Color.blue, 12f);
		}

		private bool NotContainedYetByAny(Transform t)
		{
			if (!TrReachingSides.Contains(t) && !TrReachingGround.Contains(t) && !TrEnds.Contains(t) && (Object)(object)t != (Object)(object)ProbablyChest && (Object)(object)t != (Object)(object)ProbablyHips && (Object)(object)t != (Object)(object)ProbablyHead && (Object)(object)t != (Object)(object)ProbablyChest && (Object)(object)t != (Object)(object)ProbablyRootBone)
			{
				return (Object)(object)t != (Object)(object)AnimatorTransform;
			}
			return false;
		}

		private bool NotContainedYetByLimbs(Transform t)
		{
			if (!TrReachingSides.Contains(t))
			{
				return !TrReachingGround.Contains(t);
			}
			return false;
		}

		public Transform GetHighestChild(Transform t, Transform root, float inCenterRangeFactor)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)t == (Object)null)
			{
				return null;
			}
			Transform result = t;
			Vector3 val = root.InverseTransformPoint(t.position);
			Transform[] componentsInChildren = ((Component)t).GetComponentsInChildren<Transform>(true);
			foreach (Transform val2 in componentsInChildren)
			{
				Vector3 val3 = root.InverseTransformPoint(val2.position);
				if (val3.x > 0f - inCenterRangeFactor && val3.x < inCenterRangeFactor && val3.y > val.y)
				{
					val.y = val3.y;
					result = val2;
				}
			}
			return result;
		}

		private void ClearDuplicates(List<List<Transform>> limbs, List<Transform> roots)
		{
			if (limbs.Count <= 1)
			{
				return;
			}
			for (int i = 0; i < limbs.Count && i < limbs.Count; i++)
			{
				List<Transform> list = limbs[i];
				for (int num = limbs.Count - 1; num >= 0; num--)
				{
					if (num != i)
					{
						List<Transform> list2 = limbs[num];
						bool flag = false;
						for (int j = 0; j < list2.Count; j++)
						{
							if (list.Contains(list2[j]))
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							limbs.RemoveAt(num);
						}
					}
				}
			}
		}

		private Vector3 Loc(Transform t)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return AnimatorTransform.InverseTransformPoint(t.position);
		}

		public string GetLog()
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			string text = "< " + ((Object)AnimatorTransform).name + " >\n";
			text += "\nGenerate Guides:\n";
			string text2 = text;
			Vector3 val = LocalSpaceHighest;
			text = text2 + "Highest: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
			string text3 = text;
			val = LocalSpaceLowest;
			text = text3 + "Lowest: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
			string text4 = text;
			val = LocalSpaceMostLeft;
			text = text4 + "Left: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
			string text5 = text;
			val = LocalSpaceMostRight;
			text = text5 + "Right: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
			string text6 = text;
			val = LocalSpaceMostForward;
			text = text6 + "Forward: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
			string text7 = text;
			val = LocalSpaceMostBack;
			text = text7 + "Back: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
			text += "\n\nGenerated Helper Measurements: \n";
			text = text + "UpDown: " + LowestVsHighestLen + "     ";
			text = text + "LeftRight: " + MostLeftVsMostRightLen + "     ";
			text = text + "ForwBack: " + MostForwVsMostBackLen + "     ";
			text = text + "Avr: " + AverageLen + "     ";
			text += "\n\nDetected Propabilities: \n";
			text = text + "ProbablyHips: " + ((object)ProbablyHips)?.ToString() + "     ";
			text = text + "ProbablyChest: " + ((object)ProbablyChest)?.ToString() + "     ";
			text = text + "ProbablyHead: " + ((object)ProbablyHead)?.ToString() + "     ";
			text += "\n\nLimb End Detections: \n";
			text = text + "Reaching Ground: " + TrReachingGround.Count + "     ";
			text = text + "Reaching Sides: " + TrReachingSides.Count + "     ";
			text = text + "Spine Chain Length: " + ProbablySpineChain.Count + " (" + ProbablySpineChainShort.Count + ")     ";
			text += "\n\nDetected Propabilities: \n";
			text = text + "Probably Left Arms: " + ProbablyLeftArms.Count + "     ";
			text = text + "Probably Right Arms: " + ProbablyRightArms.Count + "     ";
			text = text + "Probably Left Legs: " + ProbablyLeftLegs.Count + "     ";
			text = text + "Probably Right Legs: " + ProbablyRightLegs.Count + "     ";
			text += "\n\n\nTr Ends: \n";
			for (int i = 0; i < TrEnds.Count; i++)
			{
				if (!((Object)(object)TrEnds[i] == (Object)null))
				{
					text = text + ((Object)TrEnds[i]).name + "     ";
				}
			}
			text += "\n\nTr Reaching Ground: \n";
			for (int j = 0; j < TrReachingGround.Count; j++)
			{
				if (!((Object)(object)TrReachingGround[j] == (Object)null))
				{
					text = text + ((Object)TrReachingGround[j]).name + "     ";
				}
			}
			text += "\n\nTr Reaching Sides: \n";
			for (int k = 0; k < TrReachingSides.Count; k++)
			{
				if (!((Object)(object)TrReachingSides[k] == (Object)null))
				{
					text = text + ((Object)TrReachingSides[k]).name + "     ";
				}
			}
			if (ProbablyLeftArms.Count > 0)
			{
				text += "\n\nDebug Left Arms: \n";
				for (int l = 0; l < ProbablyLeftArms.Count; l++)
				{
					if (ProbablyLeftArms[l] != null)
					{
						text = text + "[" + l + "] ";
						for (int m = 0; m < ProbablyLeftArms[l].Count; m++)
						{
							text = text + ((Object)ProbablyLeftArms[l][m]).name + "  ";
						}
						text += "\n";
					}
				}
			}
			if (ProbablySpineChainShort.Count > 0)
			{
				text += "\n\nDebug Spine Chain: \n";
				for (int n = 0; n < ProbablySpineChainShort.Count; n++)
				{
					if (!((Object)(object)ProbablySpineChainShort[n] == (Object)null))
					{
						text = text + ((Object)ProbablySpineChainShort[n]).name + "  ";
					}
				}
			}
			return text + "\n\n";
		}

		public static int GetDepth(Transform t, Transform skelRootBone)
		{
			int num = 0;
			if ((Object)(object)t == (Object)(object)skelRootBone)
			{
				return 0;
			}
			if ((Object)(object)t == (Object)null)
			{
				return 0;
			}
			if ((Object)(object)t.parent == (Object)null)
			{
				return 0;
			}
			while ((Object)(object)t != (Object)null && (Object)(object)t != (Object)(object)skelRootBone)
			{
				t = t.parent;
				num++;
			}
			return num;
		}
	}

	public static Component FoundAnimator;

	private static bool checkForAnim = true;

	private static int clicks = 0;

	public static readonly string[] SpineNames = new string[1] { "spine" };

	public static readonly string[] NeckNames = new string[1] { "neck" };

	public static readonly string[] HeadNames = new string[1] { "head" };

	public static readonly string[] RootNames = new string[3] { "root", "origin", "skel" };

	public static readonly string[] PelvisNames = new string[3] { "pelvis", "hips", "pelv" };

	public static readonly string[] ChestNames = new string[2] { "chest", "upperspine" };

	public static readonly string[] ShouldersNames = new string[3] { "shoulde", "collarbon", "clavicl" };

	public static readonly string[] UpperLegNames = new string[2] { "upperleg", "thigh" };

	public static readonly string[] KneeNames = new string[3] { "knee", "calf", "lowerleg" };

	public static readonly string[] ElbowNames = new string[2] { "elbow", "lowerarm" };

	public static bool IsChildOf(Transform child, Transform parent)
	{
		Transform val = child;
		while ((Object)(object)val != (Object)null)
		{
			if ((Object)(object)val == (Object)(object)parent)
			{
				return true;
			}
			val = val.parent;
		}
		return false;
	}

	public static Transform GetBottomMostChildTransform(Transform parent)
	{
		Transform[] componentsInChildren = ((Component)parent).GetComponentsInChildren<Transform>(true);
		int num = 0;
		Transform result = parent;
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (!((Object)(object)componentsInChildren[i] == (Object)(object)parent))
			{
				Transform val = componentsInChildren[i];
				int num2 = 0;
				while ((Object)(object)val.parent != (Object)(object)parent && (Object)(object)val.parent != (Object)null)
				{
					num2++;
					val = val.parent;
				}
				if (num2 > num)
				{
					num = num2;
					result = componentsInChildren[i];
				}
			}
		}
		return result;
	}

	public static Transform GetContinousChildTransform(Transform root)
	{
		Transform result = null;
		if (root.childCount > 0)
		{
			if (root.childCount == 1)
			{
				return root.GetChild(0);
			}
			int num = 0;
			Transform child = root.GetChild(0);
			for (int i = 0; i < root.childCount; i++)
			{
				int num2 = CountChildChainLength(root.GetChild(i));
				if (num2 > num)
				{
					num = num2;
					child = root.GetChild(i);
				}
			}
			result = child;
		}
		return result;
	}

	public static int CountChildChainLength(Transform root)
	{
		if ((Object)(object)root == (Object)null)
		{
			return 0;
		}
		if (root.childCount == 0)
		{
			return 0;
		}
		return GetDepth(GetBottomMostChildTransform(root), root);
	}

	public static int GetDepth(Transform t, Transform skelRootBone)
	{
		int num = 0;
		if ((Object)(object)t == (Object)(object)skelRootBone)
		{
			return 0;
		}
		if ((Object)(object)t == (Object)null)
		{
			return 0;
		}
		if ((Object)(object)t.parent == (Object)null)
		{
			return 0;
		}
		while ((Object)(object)t != (Object)null && (Object)(object)t != (Object)(object)skelRootBone)
		{
			t = t.parent;
			num++;
		}
		return num;
	}

	public static Transform GetParent(Transform start, int depth)
	{
		if ((Object)(object)start == (Object)null)
		{
			return null;
		}
		Transform parent = start.parent;
		for (int i = 0; i < depth; i++)
		{
			if ((Object)(object)parent == (Object)null)
			{
				break;
			}
			parent = parent.parent;
		}
		return parent;
	}

	public static Transform GetLastChild(Transform rootParent)
	{
		Transform val = rootParent;
		while (val.childCount > 0)
		{
			val = val.GetChild(0);
		}
		return val;
	}

	public static bool? IsRightOrLeft(string name, bool includeNotSure = false)
	{
		string text = name.ToLower();
		if (text.Contains("right"))
		{
			return true;
		}
		if (text.Contains("left"))
		{
			return false;
		}
		if (text.StartsWith("r_"))
		{
			return true;
		}
		if (text.StartsWith("l_"))
		{
			return false;
		}
		if (text.EndsWith("_r"))
		{
			return true;
		}
		if (text.EndsWith("_l"))
		{
			return false;
		}
		if (text.StartsWith("r."))
		{
			return true;
		}
		if (text.StartsWith("l."))
		{
			return false;
		}
		if (text.EndsWith(".r"))
		{
			return true;
		}
		if (text.EndsWith(".l"))
		{
			return false;
		}
		if (includeNotSure)
		{
			if (text.Contains("r_"))
			{
				return true;
			}
			if (text.Contains("l_"))
			{
				return false;
			}
			if (text.Contains("_r"))
			{
				return true;
			}
			if (text.Contains("_l"))
			{
				return false;
			}
			if (text.Contains("r."))
			{
				return true;
			}
			if (text.Contains("l."))
			{
				return false;
			}
			if (text.Contains(".r"))
			{
				return true;
			}
			if (text.Contains(".l"))
			{
				return false;
			}
		}
		return null;
	}

	public static bool? IsRightOrLeft(Transform child, Transform itsRoot)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = itsRoot.InverseTransformPoint(child.position);
		if (val.x < 0f)
		{
			return false;
		}
		if (val.x > 0f)
		{
			return true;
		}
		return null;
	}

	public static void ResetFinders(bool resetClicks = true)
	{
		checkForAnim = true;
		FoundAnimator = null;
		if (resetClicks)
		{
			clicks = 0;
		}
	}

	public static bool CheckForAnimator(GameObject root, bool needAnimatorBox = true, bool drawInactiveWarning = true, int clicksTohide = 1)
	{
		bool flag = false;
		if (checkForAnim)
		{
			FoundAnimator = SearchForParentWithAnimator(root);
		}
		if (Object.op_Implicit((Object)(object)FoundAnimator))
		{
			Component foundAnimator = FoundAnimator;
			Animation val = (Animation)(object)((foundAnimator is Animation) ? foundAnimator : null);
			Component foundAnimator2 = FoundAnimator;
			Animator val2 = (Animator)(object)((foundAnimator2 is Animator) ? foundAnimator2 : null);
			if (Object.op_Implicit((Object)(object)val) && ((Behaviour)val).enabled)
			{
				flag = true;
			}
			if (Object.op_Implicit((Object)(object)val2))
			{
				if (((Behaviour)val2).enabled)
				{
					flag = true;
				}
				if ((Object)(object)val2.runtimeAnimatorController == (Object)null)
				{
					drawInactiveWarning = false;
					flag = false;
				}
			}
			if (needAnimatorBox && drawInactiveWarning && flag)
			{
			}
		}
		else if (needAnimatorBox)
		{
			_ = clicks;
		}
		checkForAnim = false;
		return flag;
	}

	public static Component SearchForParentWithAnimator(GameObject root)
	{
		Animation componentInChildren = root.GetComponentInChildren<Animation>();
		if (Object.op_Implicit((Object)(object)componentInChildren))
		{
			return (Component)(object)componentInChildren;
		}
		Animator componentInChildren2 = root.GetComponentInChildren<Animator>();
		if (Object.op_Implicit((Object)(object)componentInChildren2))
		{
			return (Component)(object)componentInChildren2;
		}
		if ((Object)(object)root.transform.parent != (Object)null)
		{
			Transform parent = root.transform.parent;
			while ((Object)(object)parent != (Object)null)
			{
				componentInChildren = ((Component)parent).GetComponent<Animation>();
				if (Object.op_Implicit((Object)(object)componentInChildren))
				{
					return (Component)(object)componentInChildren;
				}
				componentInChildren2 = ((Component)parent).GetComponent<Animator>();
				if (Object.op_Implicit((Object)(object)componentInChildren2))
				{
					return (Component)(object)componentInChildren2;
				}
				parent = parent.parent;
			}
		}
		return null;
	}

	public static SkinnedMeshRenderer GetBoneSearchArray(Transform root)
	{
		List<SkinnedMeshRenderer> list = new List<SkinnedMeshRenderer>();
		SkinnedMeshRenderer val = null;
		Transform[] componentsInChildren = ((Component)root).GetComponentsInChildren<Transform>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			SkinnedMeshRenderer component = ((Component)componentsInChildren[i]).GetComponent<SkinnedMeshRenderer>();
			if (Object.op_Implicit((Object)(object)component))
			{
				list.Add(component);
			}
		}
		if (list.Count == 0)
		{
			Transform val2 = root;
			while ((Object)(object)val2 != (Object)null && !((Object)(object)val2.parent == (Object)null))
			{
				val2 = val2.parent;
			}
			componentsInChildren = ((Component)val2).GetComponentsInChildren<Transform>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				SkinnedMeshRenderer component2 = ((Component)componentsInChildren[i]).GetComponent<SkinnedMeshRenderer>();
				if (!list.Contains(component2) && Object.op_Implicit((Object)(object)component2))
				{
					list.Add(component2);
				}
			}
		}
		if (list.Count > 1)
		{
			val = list[0];
			for (int j = 1; j < list.Count; j++)
			{
				if (list[j].bones.Length > val.bones.Length)
				{
					val = list[j];
				}
			}
		}
		else if (list.Count > 0)
		{
			val = list[0];
		}
		if ((Object)(object)val == (Object)null)
		{
			return null;
		}
		return val;
	}

	public static bool HaveKey(string text, string[] keys)
	{
		for (int i = 0; i < keys.Length; i++)
		{
			if (text.Contains(keys[i]))
			{
				return true;
			}
		}
		return false;
	}

	public static bool NameContains(string name, string[] names)
	{
		string text = name.ToLower();
		text = text.Replace("-", "");
		text = text.Replace(" ", "");
		text = text.Replace("_", "");
		text = text.Replace("|", "");
		text = text.Replace("@", "");
		for (int i = 0; i < names.Length; i++)
		{
			if (text.Contains(names[i]))
			{
				return true;
			}
		}
		return false;
	}
}


public enum EWhatIsIt
{
	Unknown,
	Humanoidal,
	Quadroped,
	Creature
}


using System.Collections.Generic;
using UnityEngine;

public class SkeletonInfo
{
	public Transform AnimatorTransform;

	public float LowestVsHighestLen;

	public float MostLeftVsMostRightLen;

	public float MostForwVsMostBackLen;

	public float AverageLen;

	public Transform ProbablyRootBone;

	public Transform ProbablyHips;

	public Transform ProbablyChest;

	public Transform ProbablyHead;

	public List<Transform> TrReachingGround = new List<Transform>();

	public List<Transform> TrReachingSides = new List<Transform>();

	public List<Transform> TrEnds = new List<Transform>();

	public List<Transform> ProbablySpineChain = new List<Transform>();

	public List<Transform> ProbablySpineChainShort = new List<Transform>();

	public List<List<Transform>> ProbablyRightArms = new List<List<Transform>>();

	public List<List<Transform>> ProbablyLeftArms = new List<List<Transform>>();

	public List<List<Transform>> ProbablyLeftLegs = new List<List<Transform>>();

	public List<Transform> ProbablyLeftLegRoot = new List<Transform>();

	public List<List<Transform>> ProbablyRightLegs = new List<List<Transform>>();

	public List<Transform> ProbablyRightLegRoot = new List<Transform>();

	public Vector3 LocalSpaceHighest = Vector3.zero;

	public Vector3 LocalSpaceMostRight = Vector3.zero;

	public Vector3 LocalSpaceMostForward = Vector3.zero;

	public Vector3 LocalSpaceMostBack = Vector3.zero;

	public Vector3 LocalSpaceMostLeft = Vector3.zero;

	public Vector3 LocalSpaceLowest = Vector3.zero;

	public EWhatIsIt WhatIsIt;

	public int SpineChainLength => ProbablySpineChain.Count;

	public int LeftArms => ProbablyLeftArms.Count;

	public int LeftLegs => ProbablyLeftLegs.Count;

	public int RightArms => ProbablyRightArms.Count;

	public int RightLegs => ProbablyRightLegs.Count;

	public int Legs => RightLegs + LeftLegs;

	public int Arms => LeftArms + RightArms;

	public SkeletonInfo(Transform t, List<Transform> checkOnly = null, Transform pelvisHelp = null)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_058c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_0593: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0603: Unknown result type (might be due to invalid IL or missing references)
		//IL_1027: Unknown result type (might be due to invalid IL or missing references)
		//IL_102c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1053: Unknown result type (might be due to invalid IL or missing references)
		//IL_1058: Unknown result type (might be due to invalid IL or missing references)
		//IL_105d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1085: Unknown result type (might be due to invalid IL or missing references)
		//IL_108a: Unknown result type (might be due to invalid IL or missing references)
		//IL_10a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_10ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_10da: Unknown result type (might be due to invalid IL or missing references)
		//IL_10df: Unknown result type (might be due to invalid IL or missing references)
		//IL_10fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1102: Unknown result type (might be due to invalid IL or missing references)
		//IL_1107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0777: Unknown result type (might be due to invalid IL or missing references)
		//IL_077c: Unknown result type (might be due to invalid IL or missing references)
		//IL_077e: Unknown result type (might be due to invalid IL or missing references)
		//IL_068e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0693: Unknown result type (might be due to invalid IL or missing references)
		//IL_0695: Unknown result type (might be due to invalid IL or missing references)
		//IL_079f: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_09b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_09f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a96: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a9d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ac8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0acf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a28: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b39: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b45: Unknown result type (might be due to invalid IL or missing references)
		//IL_0adb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ae0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a45: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a67: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a73: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a78: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d29: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e56: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dd9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f05: Unknown result type (might be due to invalid IL or missing references)
		AnimatorTransform = t;
		Transform[] array;
		if (checkOnly != null)
		{
			array = (Transform[])(object)new Transform[checkOnly.Count];
			for (int i = 0; i < checkOnly.Count; i++)
			{
				array[i] = checkOnly[i];
			}
		}
		else
		{
			array = ((Component)AnimatorTransform).GetComponentsInChildren<Transform>(true);
		}
		if (array.Length != 0)
		{
			LocalSpaceLowest = (LocalSpaceMostLeft = (LocalSpaceMostBack = (LocalSpaceMostForward = (LocalSpaceMostRight = (LocalSpaceHighest = AnimatorTransform.InverseTransformPoint(array[0].position))))));
		}
		List<Transform> list = new List<Transform>();
		foreach (Transform val in array)
		{
			if (!((Object)(object)((Component)val).GetComponentInChildren<SkinnedMeshRenderer>() != (Object)null))
			{
				list.Add(val);
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			Transform val2 = list[k];
			if (!Object.op_Implicit((Object)(object)((Component)val2).GetComponent<SkinnedMeshRenderer>()))
			{
				Vector3 val3 = AnimatorTransform.InverseTransformPoint(val2.position);
				if (val3.x > LocalSpaceMostRight.x)
				{
					LocalSpaceMostRight = val3;
				}
				else if (val3.x < LocalSpaceMostLeft.x)
				{
					LocalSpaceMostLeft = val3;
				}
				if (val3.z > LocalSpaceMostForward.z)
				{
					LocalSpaceMostForward = val3;
				}
				else if (val3.z < LocalSpaceMostBack.z)
				{
					LocalSpaceMostBack = val3;
				}
				if (val3.y > LocalSpaceHighest.y)
				{
					LocalSpaceHighest = val3;
				}
				else if (val3.y < LocalSpaceLowest.y)
				{
					LocalSpaceLowest = val3;
				}
			}
		}
		LowestVsHighestLen = Mathf.Abs(LocalSpaceLowest.y - LocalSpaceHighest.y);
		MostLeftVsMostRightLen = Mathf.Abs(LocalSpaceMostLeft.x - LocalSpaceMostRight.x);
		MostForwVsMostBackLen = Mathf.Abs(LocalSpaceMostForward.z - LocalSpaceMostBack.z);
		AverageLen = (LowestVsHighestLen + MostLeftVsMostRightLen + MostForwVsMostBackLen) / 3f;
		_ = LowestVsHighestLen;
		for (int l = 0; l < list.Count; l++)
		{
			Transform val4 = list[l];
			if (NameContains(((Object)val4).name, ShouldersNames))
			{
				Transform bottomMostChildTransform = GetBottomMostChildTransform(val4);
				if (NotContainedYetByLimbs(bottomMostChildTransform))
				{
					TrReachingSides.Add(bottomMostChildTransform);
				}
			}
			else if (NameContains(((Object)val4).name, ElbowNames))
			{
				Transform bottomMostChildTransform2 = GetBottomMostChildTransform(val4);
				if (NotContainedYetByLimbs(bottomMostChildTransform2))
				{
					TrReachingSides.Add(bottomMostChildTransform2);
				}
			}
		}
		for (int m = 0; m < list.Count; m++)
		{
			Transform val5 = list[m];
			if (NameContains(((Object)val5).name, UpperLegNames))
			{
				Transform bottomMostChildTransform3 = GetBottomMostChildTransform(val5);
				if (NotContainedYetByLimbs(bottomMostChildTransform3))
				{
					TrReachingGround.Add(bottomMostChildTransform3);
				}
			}
			else if (NameContains(((Object)val5).name, KneeNames))
			{
				Transform bottomMostChildTransform4 = GetBottomMostChildTransform(val5);
				if (NotContainedYetByLimbs(bottomMostChildTransform4))
				{
					TrReachingGround.Add(bottomMostChildTransform4);
				}
			}
		}
		bool flag = false;
		for (int n = 0; n < list.Count; n++)
		{
			Transform val6 = list[n];
			if (NameContains(((Object)val6).name, PelvisNames))
			{
				flag = true;
				ProbablyHips = val6;
				break;
			}
		}
		bool flag2 = false;
		for (int num = 0; num < list.Count; num++)
		{
			Transform val7 = list[num];
			if (NameContains(((Object)val7).name, ChestNames))
			{
				flag2 = true;
				ProbablyChest = val7;
				break;
			}
		}
		bool flag3 = false;
		for (int num2 = 0; num2 < list.Count; num2++)
		{
			Transform val8 = list[num2];
			if (NameContains(((Object)val8).name, HeadNames))
			{
				flag3 = true;
				ProbablyHead = val8;
				break;
			}
		}
		if ((Object)(object)ProbablyHead != (Object)null && (Object)(object)ProbablyHips != (Object)null && !IsChildOf(ProbablyHead, ProbablyHips))
		{
			ProbablyHead = null;
		}
		for (int num3 = 0; num3 < list.Count; num3++)
		{
			Transform val9 = list[num3];
			if (NameContains(((Object)val9).name, RootNames))
			{
				ProbablyRootBone = val9;
				break;
			}
		}
		if (list.Count > 2)
		{
			for (int num4 = 1; num4 < list.Count; num4++)
			{
				Transform val10 = list[num4];
				if (val10.childCount != 0)
				{
					continue;
				}
				TrEnds.Add(val10);
				Vector3 val11 = Loc(val10);
				if (val11.y < LocalSpaceLowest.y + LowestVsHighestLen * 0.1f)
				{
					if (NotContainedYetByLimbs(val10))
					{
						TrReachingGround.Add(val10);
					}
				}
				else if (val11.y > LocalSpaceLowest.y + LowestVsHighestLen * 0.2f && (val11.x < MostLeftVsMostRightLen * -0.1f || val11.x > MostLeftVsMostRightLen * 0.1f) && NotContainedYetByLimbs(val10))
				{
					TrReachingSides.Add(val10);
				}
			}
		}
		if (!flag2)
		{
			List<Transform> list2 = new List<Transform>();
			for (int num5 = 0; num5 < TrReachingSides.Count; num5++)
			{
				if (Object.op_Implicit((Object)(object)((Component)list[num5]).GetComponent<SkinnedMeshRenderer>()))
				{
					continue;
				}
				Transform parent = TrReachingSides[num5].parent;
				while ((Object)(object)parent != (Object)null)
				{
					if (parent.childCount > 2)
					{
						Vector3 val12 = Loc(parent);
						if (val12.x > (0f - MostLeftVsMostRightLen) * 0.03f && val12.x < MostLeftVsMostRightLen * 0.03f)
						{
							list2.Add(parent);
							break;
						}
					}
					parent = parent.parent;
				}
			}
			if (list2.Count == 1)
			{
				ProbablyChest = list2[0];
			}
			else if (list2.Count > 1 && (Object)(object)list2[0] == (Object)(object)list2[1])
			{
				ProbablyChest = list2[0];
			}
		}
		if (!flag)
		{
			List<Transform> list3 = new List<Transform>();
			for (int num6 = 0; num6 < TrReachingGround.Count; num6++)
			{
				Transform parent2 = TrReachingGround[num6].parent;
				while ((Object)(object)parent2 != (Object)null)
				{
					if (parent2.childCount > 2)
					{
						Vector3 val13 = Loc(parent2);
						if (val13.y > LocalSpaceLowest.y + LowestVsHighestLen * 0.04f && val13.x > (0f - MostLeftVsMostRightLen) * 0.02f && val13.x < MostLeftVsMostRightLen * 0.02f)
						{
							list3.Add(parent2);
							break;
						}
					}
					parent2 = parent2.parent;
				}
			}
			if (list3.Count == 1)
			{
				ProbablyChest = list3[0];
			}
			else if (list3.Count > 1 && (Object)(object)list3[0] == (Object)(object)list3[1])
			{
				ProbablyHips = list3[0];
			}
		}
		if ((Object)(object)ProbablyHips == (Object)null)
		{
			ProbablyHips = pelvisHelp;
		}
		if (((Object)(object)ProbablyChest == (Object)null || (Object)(object)ProbablyChest == (Object)(object)ProbablyHips || ((Object)(object)ProbablyHips != (Object)null && !IsChildOf(ProbablyChest, ProbablyHips))) && Object.op_Implicit((Object)(object)ProbablyHips) && Object.op_Implicit((Object)(object)ProbablyHead))
		{
			Transform parent3 = ProbablyHead.parent;
			bool flag4 = false;
			while ((Object)(object)parent3.parent != (Object)null && (Object)(object)parent3.parent != (Object)(object)ProbablyHips)
			{
				if (parent3.childCount > 2)
				{
					for (int num7 = 0; num7 < TrReachingSides.Count; num7++)
					{
						if (IsChildOf(TrReachingSides[num7], parent3))
						{
							flag4 = true;
							break;
						}
					}
				}
				if (flag4)
				{
					break;
				}
				parent3 = parent3.parent;
			}
			if (flag4)
			{
				ProbablyChest = parent3;
			}
		}
		if ((Object)(object)ProbablyHips == (Object)null)
		{
			ProbablyHips = pelvisHelp;
		}
		if (Object.op_Implicit((Object)(object)ProbablyChest) && Object.op_Implicit((Object)(object)ProbablyHips))
		{
			if (MostForwVsMostBackLen > LowestVsHighestLen * 0.9f && Loc(ProbablyChest).z < Loc(ProbablyHips).z)
			{
				Transform probablyChest = ProbablyChest;
				ProbablyChest = ProbablyHips;
				ProbablyHips = probablyChest;
				Debug.Log((object)"Hips - Chest - Reversed Detection Swap!");
			}
			if (!flag3)
			{
				Vector3 val14 = Vector3.zero;
				for (int num8 = 0; num8 < ProbablyChest.childCount; num8++)
				{
					Transform child = ProbablyChest.GetChild(num8);
					Vector3 val15;
					if (child.childCount > 0)
					{
						for (int num9 = 0; num9 < child.childCount; num9++)
						{
							Transform child2 = child.GetChild(num9);
							val15 = Loc(child2);
							if (val15.x > (0f - MostLeftVsMostRightLen) * 0.04f && val15.x < MostLeftVsMostRightLen * 0.04f && Loc(child2).y > val14.y)
							{
								val14 = Loc(child2);
								ProbablyHead = child2;
							}
						}
					}
					val15 = Loc(child);
					if (val15.x > (0f - MostLeftVsMostRightLen) * 0.04f && val15.x < MostLeftVsMostRightLen * 0.04f && val15.y > val14.y)
					{
						val14 = Loc(child);
						ProbablyHead = child;
					}
				}
				if (Object.op_Implicit((Object)(object)ProbablyChest) && Object.op_Implicit((Object)(object)ProbablyHead) && Object.op_Implicit((Object)(object)ProbablyHips))
				{
					float num10 = Vector3.Distance(Loc(ProbablyChest), Loc(ProbablyHips));
					if ((ProbablyChest.childCount < 3 || num10 < AverageLen * 0.12f) && ProbablyHead.childCount > 1)
					{
						ProbablyChest = ProbablyHead;
						ProbablyHead = GetHighestChild(ProbablyHead, AnimatorTransform, MostLeftVsMostRightLen * 0.05f);
						if ((Object)(object)ProbablyHead == (Object)(object)ProbablyChest)
						{
							ProbablyHead = ProbablyChest.GetChild(0);
						}
					}
				}
			}
			if (Object.op_Implicit((Object)(object)ProbablyHead))
			{
				for (int num11 = TrReachingSides.Count - 1; num11 >= 0; num11--)
				{
					if (IsChildOf(TrReachingSides[num11], ProbablyHead))
					{
						TrReachingSides.RemoveAt(num11);
					}
				}
			}
			for (int num12 = TrReachingSides.Count - 1; num12 >= 0; num12--)
			{
				if (GetDepth(TrReachingSides[num12], AnimatorTransform) < 5)
				{
					TrReachingSides.RemoveAt(num12);
				}
			}
			Transform val16 = null;
			if (Object.op_Implicit((Object)(object)ProbablyHead))
			{
				ProbablySpineChain.Add(ProbablyHead);
				val16 = ProbablyHead.parent;
			}
			while ((Object)(object)val16 != (Object)null && (Object)(object)val16 != (Object)(object)ProbablyHips)
			{
				ProbablySpineChain.Add(val16);
				val16 = val16.parent;
			}
			ProbablySpineChain.Reverse();
			for (int num13 = 0; num13 < Mathf.Min(4, ProbablySpineChain.Count); num13++)
			{
				ProbablySpineChainShort.Add(ProbablySpineChain[num13]);
			}
			List<Transform> list4 = new List<Transform>();
			for (int num14 = 0; num14 < TrReachingGround.Count; num14++)
			{
				Transform val17 = TrReachingGround[num14];
				Vector3 val18 = Loc(val17);
				List<Transform> list5 = new List<Transform>();
				Transform val19 = val17;
				while ((Object)(object)val19 != (Object)null && (Object)(object)val19 != (Object)(object)ProbablyHips && (Object)(object)val19 != (Object)(object)ProbablyChest)
				{
					list5.Add(val19);
					val19 = val19.parent;
				}
				if (list5.Count >= 3)
				{
					List<Transform> item = new List<Transform>
					{
						list5[list5.Count - 1],
						list5[list5.Count - 2],
						list5[list5.Count - 3]
					};
					list4.Add(val17);
					if (val18.x < MostLeftVsMostRightLen * 0.02f)
					{
						ProbablyLeftLegs.Add(item);
						ProbablyLeftLegRoot.Add(val19);
					}
					else
					{
						ProbablyRightLegs.Add(item);
						ProbablyRightLegRoot.Add(val19);
					}
				}
			}
			for (int num15 = 0; num15 < TrReachingSides.Count; num15++)
			{
				Transform val20 = TrReachingSides[num15];
				Vector3 val21 = Loc(val20);
				List<Transform> list6 = new List<Transform>();
				Transform val22 = val20;
				while ((Object)(object)val22 != (Object)null && (Object)(object)val22 != (Object)(object)ProbablyChest)
				{
					list6.Add(val22);
					val22 = val22.parent;
				}
				if (list6.Count >= 4)
				{
					List<Transform> item2 = new List<Transform>
					{
						list6[list6.Count - 1],
						list6[list6.Count - 2],
						list6[list6.Count - 3],
						list6[list6.Count - 4]
					};
					if (val21.x < MostLeftVsMostRightLen * 0.02f)
					{
						ProbablyLeftArms.Add(item2);
					}
					else
					{
						ProbablyRightArms.Add(item2);
					}
				}
			}
			ClearDuplicates(ProbablyLeftArms, null);
			ClearDuplicates(ProbablyRightArms, null);
			ClearDuplicates(ProbablyLeftLegs, ProbablyLeftLegRoot);
			ClearDuplicates(ProbablyRightLegs, ProbablyRightLegRoot);
			if (Legs == 2 && Arms == 2)
			{
				WhatIsIt = EWhatIsIt.Humanoidal;
			}
			else if (Legs == 4 && Arms == 0)
			{
				WhatIsIt = EWhatIsIt.Quadroped;
			}
			else if (Legs > 0 || Arms > 0)
			{
				WhatIsIt = EWhatIsIt.Creature;
			}
			else
			{
				WhatIsIt = EWhatIsIt.Unknown;
			}
		}
		float num16 = Mathf.Lerp(LocalSpaceLowest.y, LocalSpaceHighest.y, 0.5f);
		Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, LocalSpaceHighest.y, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, LocalSpaceLowest.y, LocalSpaceMostForward.z)), Color.green, 12f);
		Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, num16, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostRight.x, num16, LocalSpaceMostForward.z)), Color.red, 12f);
		Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostRight.x, num16, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostRight.x, num16, LocalSpaceMostBack.z)), Color.blue, 12f);
	}

	private bool NotContainedYetByAny(Transform t)
	{
		if (!TrReachingSides.Contains(t) && !TrReachingGround.Contains(t) && !TrEnds.Contains(t) && (Object)(object)t != (Object)(object)ProbablyChest && (Object)(object)t != (Object)(object)ProbablyHips && (Object)(object)t != (Object)(object)ProbablyHead && (Object)(object)t != (Object)(object)ProbablyChest && (Object)(object)t != (Object)(object)ProbablyRootBone)
		{
			return (Object)(object)t != (Object)(object)AnimatorTransform;
		}
		return false;
	}

	private bool NotContainedYetByLimbs(Transform t)
	{
		if (!TrReachingSides.Contains(t))
		{
			return !TrReachingGround.Contains(t);
		}
		return false;
	}

	public Transform GetHighestChild(Transform t, Transform root, float inCenterRangeFactor)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)t == (Object)null)
		{
			return null;
		}
		Transform result = t;
		Vector3 val = root.InverseTransformPoint(t.position);
		Transform[] componentsInChildren = ((Component)t).GetComponentsInChildren<Transform>(true);
		foreach (Transform val2 in componentsInChildren)
		{
			Vector3 val3 = root.InverseTransformPoint(val2.position);
			if (val3.x > 0f - inCenterRangeFactor && val3.x < inCenterRangeFactor && val3.y > val.y)
			{
				val.y = val3.y;
				result = val2;
			}
		}
		return result;
	}

	private void ClearDuplicates(List<List<Transform>> limbs, List<Transform> roots)
	{
		if (limbs.Count <= 1)
		{
			return;
		}
		for (int i = 0; i < limbs.Count && i < limbs.Count; i++)
		{
			List<Transform> list = limbs[i];
			for (int num = limbs.Count - 1; num >= 0; num--)
			{
				if (num != i)
				{
					List<Transform> list2 = limbs[num];
					bool flag = false;
					for (int j = 0; j < list2.Count; j++)
					{
						if (list.Contains(list2[j]))
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						limbs.RemoveAt(num);
					}
				}
			}
		}
	}

	private Vector3 Loc(Transform t)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return AnimatorTransform.InverseTransformPoint(t.position);
	}

	public string GetLog()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		string text = "< " + ((Object)AnimatorTransform).name + " >\n";
		text += "\nGenerate Guides:\n";
		string text2 = text;
		Vector3 val = LocalSpaceHighest;
		text = text2 + "Highest: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
		string text3 = text;
		val = LocalSpaceLowest;
		text = text3 + "Lowest: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
		string text4 = text;
		val = LocalSpaceMostLeft;
		text = text4 + "Left: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
		string text5 = text;
		val = LocalSpaceMostRight;
		text = text5 + "Right: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
		string text6 = text;
		val = LocalSpaceMostForward;
		text = text6 + "Forward: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
		string text7 = text;
		val = LocalSpaceMostBack;
		text = text7 + "Back: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString() + "     ";
		text += "\n\nGenerated Helper Measurements: \n";
		text = text + "UpDown: " + LowestVsHighestLen + "     ";
		text = text + "LeftRight: " + MostLeftVsMostRightLen + "     ";
		text = text + "ForwBack: " + MostForwVsMostBackLen + "     ";
		text = text + "Avr: " + AverageLen + "     ";
		text += "\n\nDetected Propabilities: \n";
		text = text + "ProbablyHips: " + ((object)ProbablyHips)?.ToString() + "     ";
		text = text + "ProbablyChest: " + ((object)ProbablyChest)?.ToString() + "     ";
		text = text + "ProbablyHead: " + ((object)ProbablyHead)?.ToString() + "     ";
		text += "\n\nLimb End Detections: \n";
		text = text + "Reaching Ground: " + TrReachingGround.Count + "     ";
		text = text + "Reaching Sides: " + TrReachingSides.Count + "     ";
		text = text + "Spine Chain Length: " + ProbablySpineChain.Count + " (" + ProbablySpineChainShort.Count + ")     ";
		text += "\n\nDetected Propabilities: \n";
		text = text + "Probably Left Arms: " + ProbablyLeftArms.Count + "     ";
		text = text + "Probably Right Arms: " + ProbablyRightArms.Count + "     ";
		text = text + "Probably Left Legs: " + ProbablyLeftLegs.Count + "     ";
		text = text + "Probably Right Legs: " + ProbablyRightLegs.Count + "     ";
		text += "\n\n\nTr Ends: \n";
		for (int i = 0; i < TrEnds.Count; i++)
		{
			if (!((Object)(object)TrEnds[i] == (Object)null))
			{
				text = text + ((Object)TrEnds[i]).name + "     ";
			}
		}
		text += "\n\nTr Reaching Ground: \n";
		for (int j = 0; j < TrReachingGround.Count; j++)
		{
			if (!((Object)(object)TrReachingGround[j] == (Object)null))
			{
				text = text + ((Object)TrReachingGround[j]).name + "     ";
			}
		}
		text += "\n\nTr Reaching Sides: \n";
		for (int k = 0; k < TrReachingSides.Count; k++)
		{
			if (!((Object)(object)TrReachingSides[k] == (Object)null))
			{
				text = text + ((Object)TrReachingSides[k]).name + "     ";
			}
		}
		if (ProbablyLeftArms.Count > 0)
		{
			text += "\n\nDebug Left Arms: \n";
			for (int l = 0; l < ProbablyLeftArms.Count; l++)
			{
				if (ProbablyLeftArms[l] != null)
				{
					text = text + "[" + l + "] ";
					for (int m = 0; m < ProbablyLeftArms[l].Count; m++)
					{
						text = text + ((Object)ProbablyLeftArms[l][m]).name + "  ";
					}
					text += "\n";
				}
			}
		}
		if (ProbablySpineChainShort.Count > 0)
		{
			text += "\n\nDebug Spine Chain: \n";
			for (int n = 0; n < ProbablySpineChainShort.Count; n++)
			{
				if (!((Object)(object)ProbablySpineChainShort[n] == (Object)null))
				{
					text = text + ((Object)ProbablySpineChainShort[n]).name + "  ";
				}
			}
		}
		return text + "\n\n";
	}

	public static int GetDepth(Transform t, Transform skelRootBone)
	{
		int num = 0;
		if ((Object)(object)t == (Object)(object)skelRootBone)
		{
			return 0;
		}
		if ((Object)(object)t == (Object)null)
		{
			return 0;
		}
		if ((Object)(object)t.parent == (Object)null)
		{
			return 0;
		}
		while ((Object)(object)t != (Object)null && (Object)(object)t != (Object)(object)skelRootBone)
		{
			t = t.parent;
			num++;
		}
		return num;
	}
}


using System;
using System.Collections.Generic;
using FIMSpace.Generating;
using UnityEngine;

public static class FGenerators
{
	public class DefinedRandom
	{
		private Random random;

		public int Seed { get; private set; }

		public DefinedRandom(int seed)
		{
			random = new Random(seed);
		}

		public void ReInitializeSeed(int seed)
		{
			random = new Random(seed);
		}

		public float GetRandom()
		{
			return FGenerators.GetRandom(random);
		}

		public float GetRandom(float from, float to)
		{
			return FGenerators.GetRandom(from, to, random);
		}

		public float GetRandomPlusMinus(float range)
		{
			return FGenerators.GetRandomPlusMinus(range, random);
		}

		public int GetRandom(int from, int to)
		{
			return FGenerators.GetRandom(from, to, random);
		}

		public int GetRandomInclusive(int from, int to)
		{
			return FGenerators.GetRandomInclusive(from, to, random);
		}

		public int GetRandom(FIMSpace.Generating.MinMax minMax)
		{
			return FGenerators.GetRandom(minMax, random);
		}

		public bool GetRandomFlip()
		{
			return FGenerators.GetRandomFlip(random);
		}
	}

	private static Random random = new Random();

	public static string lastPath = "";

	private static float _editorUiScaling;

	public static readonly Color Color_Remove = new Color(1f, 0.825f, 0.825f, 1f);

	public static Random GlobalRandomInstance => random;

	public static int LatestSeed { get; private set; }

	public static string GetLastPath => lastPath;

	public static float EditorUIScale => GetEditorUIScale();

	public static GameObject InstantiateObject(GameObject obj)
	{
		return Object.Instantiate<GameObject>(obj);
	}

	public static void ClearGenerated<T>(List<T> generated) where T : Object
	{
		if (generated == null)
		{
			return;
		}
		for (int i = 0; i < generated.Count; i++)
		{
			if (!((Object)(object)generated[i] == (Object)null))
			{
				if (generated[i] is Component)
				{
					object obj = generated[i];
					DestroyObject((Object)((obj is Component) ? obj : null));
				}
				else
				{
					DestroyObject((Object)(object)generated[i]);
				}
			}
		}
		generated.Clear();
	}

	public static bool CheckIfIsNull(object o)
	{
		if (o == null)
		{
			return true;
		}
		return false;
	}

	public static bool Exists(object o)
	{
		return CheckIfExist_NOTNULL(o);
	}

	public static bool NotNull(object o)
	{
		return CheckIfExist_NOTNULL(o);
	}

	public static bool IsNull(object o)
	{
		return CheckIfIsNull(o);
	}

	public static bool CheckIfExist_NOTNULL(object o)
	{
		return !CheckIfIsNull(o);
	}

	public static bool IsChildOf(Transform child, Transform rootParent)
	{
		Transform val = child;
		while ((Object)(object)val != (Object)null && (Object)(object)val != (Object)(object)rootParent)
		{
			val = val.parent;
		}
		if ((Object)(object)val == (Object)null)
		{
			return false;
		}
		return true;
	}

	public static void DestroyObject(Object obj, bool allowDestroyAssets = false)
	{
		if (!(obj == (Object)null))
		{
			Object.Destroy(obj);
		}
	}

	public static bool RefIsNull(object varMat)
	{
		if (CheckIfIsNull(varMat))
		{
			return true;
		}
		if (varMat == null)
		{
			return true;
		}
		if (varMat == null)
		{
			return true;
		}
		if (varMat.Equals(null))
		{
			return true;
		}
		return false;
	}

	public static void SetSeed(int seed)
	{
		random = new Random(seed);
		LatestSeed = seed;
	}

	public static bool GetRandomFlip()
	{
		return GetRandomFlip(random);
	}

	public static bool GetRandomFlip(Random rand)
	{
		return GetRandom(0, 2, rand) == 1;
	}

	public static float GetRandom()
	{
		return GetRandom(random);
	}

	public static int GetRandomInclusive(int from, int to)
	{
		return GetRandomInclusive(from, to, random);
	}

	public static int GetRandomInclusive(int from, int to, Random rand)
	{
		return rand.Next(from, to + 1);
	}

	public static float GetRandom(Random rand)
	{
		return (float)rand.NextDouble();
	}

	public static Vector2 SwampToBeRising(Vector2 minMax)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (minMax.y < minMax.x)
		{
			float x = minMax.x;
			minMax.x = minMax.y;
			minMax.y = x;
		}
		return minMax;
	}

	public static float GetRandomSwap(float from, float to, Random rand)
	{
		if (from > to)
		{
			float num = from;
			from = to;
			to = num;
		}
		return GetRandom(from, to, rand);
	}

	public static float GetRandomSwap(float from, float to)
	{
		return GetRandomSwap(from, to, random);
	}

	public static float GetRandomPlusMinus(float plusminus)
	{
		return GetRandomPlusMinus(plusminus, random);
	}

	public static float GetRandomPlusMinus(float plusminus, Random rand)
	{
		return GetRandom(0f - plusminus, plusminus, rand);
	}

	public static float GetRandom(float from, float to)
	{
		return GetRandom(from, to, random);
	}

	public static float GetRandom(float from, float to, Random rand)
	{
		return from + (float)rand.NextDouble() * (to - from);
	}

	public static Vector3 GetRandom(Vector3 plusMinusRangesPerAxis)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return GetRandom(plusMinusRangesPerAxis, random);
	}

	public static Vector3 GetRandom(Vector3 plusMinusRangesPerAxis, Random rand)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = plusMinusRangesPerAxis;
		val.x = GetRandom(0f - val.x, val.x, rand);
		val.y = GetRandom(0f - val.y, val.y, rand);
		val.z = GetRandom(0f - val.z, val.z, rand);
		return val;
	}

	public static int GetRandom(int from, int to)
	{
		return GetRandom(from, to, random);
	}

	public static int GetRandom(int from, int to, Random rand)
	{
		return rand.Next(from, to);
	}

	public static int GetRandom(FIMSpace.Generating.MinMax minMax)
	{
		return GetRandom(minMax, random);
	}

	public static int GetRandom(FIMSpace.Generating.MinMax minMax, Random rand)
	{
		return (int)((float)minMax.Min + (float)rand.NextDouble() * (float)(minMax.Max + 1 - minMax.Min));
	}

	public static void GetIncrementalTo<T>(List<T> list) where T : Object
	{
	}

	public static void GetSimilarTo<T>(List<T> list) where T : Object
	{
	}

	public static int IndexOfFirstNumber(string name)
	{
		for (int i = 0; i < name.Length; i++)
		{
			if (int.TryParse(name[i].ToString(), out var _))
			{
				return i;
			}
		}
		return -1;
	}

	public static List<T> CopyList<T>(List<T> cellsInstructions)
	{
		List<T> list = new List<T>();
		for (int i = 0; i < cellsInstructions.Count; i++)
		{
			list.Add(cellsInstructions[i]);
		}
		return list;
	}

	public static bool IsRightMouseButton()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Invalid comparison between Unknown and I4
		if (Event.current == null)
		{
			return false;
		}
		if ((int)Event.current.type == 12 && Event.current.button == 1)
		{
			return true;
		}
		return false;
	}

	public static float InspectorViewWidth()
	{
		return 0f;
	}

	public static Rect GUILastRect()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return default(Rect);
	}

	public static void ResetCoords(this Transform t)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		t.localPosition = Vector3.zero;
		t.localRotation = Quaternion.identity;
		t.localScale = Vector3.one;
	}

	public static Vector2 GetEventMousePosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.zero;
	}

	public static ScriptableObject GenerateScriptable(ScriptableObject reference, string exampleFilename = "", string playerPrefId = "LastFGenSaveDir")
	{
		return reference;
	}

	public static void DrawScriptableModificatorList<T>(List<T> toDraw, GUIStyle style, string title, ref bool foldout, bool newButton = false, bool moveButtons = false, Object toDirty = null, string first = "[Base]", string defaultFilename = "New Scriptable File") where T : ScriptableObject
	{
	}

	public static void AddScriptableToSimple(ScriptableObject parent, ScriptableObject toAdd, bool reload = true)
	{
	}

	public static bool AssetContainsAsset(Object subAsset, Object parentAsset)
	{
		return false;
	}

	public static void AddScriptableTo(ScriptableObject toAdd, Object parentAsset, bool checkIfAlreadyContains = true, bool reload = true)
	{
	}

	public static bool IsAssetSaved(Object asset)
	{
		return false;
	}

	public static void SwapElements<T>(List<T> list, int index1, int index2, bool loop = false)
	{
		if (index1 == index2)
		{
			return;
		}
		if (loop)
		{
			if (index1 >= list.Count)
			{
				index1 -= list.Count;
			}
			if (index1 < 0)
			{
				index1 += list.Count;
			}
			if (index2 >= list.Count)
			{
				index2 -= list.Count;
			}
			if (index2 < 0)
			{
				index2 += list.Count;
			}
		}
		T value = list[index1];
		list[index1] = list[index2];
		list[index2] = value;
	}

	public static void SwapElements<T>(T[] list, int index1, int index2)
	{
		if (index1 != index2)
		{
			T val = list[index1];
			list[index1] = list[index2];
			list[index2] = val;
		}
	}

	public static void CheckForNulls<T>(List<T> classes)
	{
		for (int num = classes.Count - 1; num >= 0; num--)
		{
			if (classes[num] == null)
			{
				classes.RemoveAt(num);
			}
		}
	}

	public static bool IndexInListRange<T>(List<T> list, int index)
	{
		if (list == null)
		{
			return false;
		}
		if (index < 0)
		{
			return false;
		}
		if (index >= list.Count)
		{
			return false;
		}
		return true;
	}

	public static T GetListElementOrNull<T>(this List<T> list, int index) where T : class
	{
		if (list == null)
		{
			return null;
		}
		if (index < 0)
		{
			return null;
		}
		if (index >= list.Count)
		{
			return null;
		}
		if (CheckIfIsNull(list[index]))
		{
			return null;
		}
		return list[index];
	}

	public static void AdjustCount<T>(List<T> list, int targetCount, bool addNulls = false) where T : class, new()
	{
		if (list.Count == targetCount)
		{
			return;
		}
		if (list.Count < targetCount)
		{
			if (addNulls)
			{
				while (list.Count < targetCount)
				{
					list.Add(null);
				}
			}
			else
			{
				while (list.Count < targetCount)
				{
					list.Add(new T());
				}
			}
		}
		else
		{
			while (list.Count > targetCount)
			{
				list.RemoveAt(list.Count - 1);
			}
		}
	}

	public static void Shuffle<T>(this IList<T> list)
	{
		list.Shuffle(random);
	}

	public static void Shuffle<T>(this IList<T> list, Random random)
	{
		int num = list.Count;
		while (num > 1)
		{
			num--;
			int index = random.Next(num + 1);
			T value = list[index];
			list[index] = list[num];
			list[num] = value;
		}
	}

	public static float GetEditorUIScale()
	{
		return 1f;
	}
}


using System;

public class DefinedRandom
{
	private Random random;

	public int Seed { get; private set; }

	public DefinedRandom(int seed)
	{
		random = new Random(seed);
	}

	public void ReInitializeSeed(int seed)
	{
		random = new Random(seed);
	}

	public float GetRandom()
	{
		return FGenerators.GetRandom(random);
	}

	public float GetRandom(float from, float to)
	{
		return FGenerators.GetRandom(from, to, random);
	}

	public float GetRandomPlusMinus(float range)
	{
		return FGenerators.GetRandomPlusMinus(range, random);
	}

	public int GetRandom(int from, int to)
	{
		return FGenerators.GetRandom(from, to, random);
	}

	public int GetRandomInclusive(int from, int to)
	{
		return FGenerators.GetRandomInclusive(from, to, random);
	}

	public int GetRandom(MinMax minMax)
	{
		return FGenerators.GetRandom(minMax, random);
	}

	public bool GetRandomFlip()
	{
		return FGenerators.GetRandomFlip(random);
	}
}


using System;
using System.Collections.Generic;
using FIMSpace;
using FIMSpace.Generating;
using UnityEngine;

[Serializable]
public class PrefabReference
{
	[SerializeField]
	private GameObject Prefab;

	private GameObject tempReplacePrefab;

	[SerializeField]
	private Collider MainCollider;

	private Collider tempReplaceCollider;

	private int id;

	public int subID;

	private Texture tex;

	public static GUILayoutOption[] opt;

	public static GUILayoutOption[] opt2;

	public static GUILayoutOption[] opt3;

	public static bool StopReloadLayoutOptions;

	[HideInInspector]
	[SerializeField]
	protected Mesh _refMesh;

	[HideInInspector]
	[SerializeField]
	protected Collider _refCol;

	public GameObject CoreGameObject => Prefab;

	public Collider CoreCollider => MainCollider;

	public GameObject GameObject
	{
		get
		{
			if ((Object)(object)tempReplacePrefab != (Object)null)
			{
				return tempReplacePrefab;
			}
			return Prefab;
		}
	}

	public Collider Collider
	{
		get
		{
			if ((Object)(object)tempReplaceCollider != (Object)null)
			{
				return tempReplaceCollider;
			}
			return MainCollider;
		}
	}

	public Texture Preview
	{
		get
		{
			if ((Object)(object)Prefab == (Object)null)
			{
				tex = null;
				return null;
			}
			if ((Object)(object)tex == (Object)null || id != ((Object)Prefab).GetInstanceID())
			{
				id = ((Object)Prefab).GetInstanceID();
			}
			return tex;
		}
	}

	protected virtual void DrawGUIWithPrefab(Color color, int previewSize = 72, string predicate = "", Action clickCallback = null, Action removeCallback = null, bool drawThumbnail = true, bool drawPrefabField = true)
	{
	}

	protected virtual void DrawGUIWithoutPrefab(int previewSize = 72, string predicate = "", Action removeCallback = null, bool drawPrefabField = true)
	{
	}

	public virtual void OnPrefabChanges()
	{
	}

	public static void DrawPrefabField(PrefabReference prefabRef, Color defaultColor, string predicate = "", int previewSize = 72, Action clickCallback = null, Action removeCallback = null, bool drawThumbnail = true, Object toDiry = null, bool drawPrefabField = true, bool drawAdditionalButtons = true)
	{
	}

	public static void DrawPrefabsList<T>(List<T> list, ref bool foldout, ref int selected, ref bool thumbnails, Color defaultC, Color selectedC, float viewWidth = 500f, int previewSize = 72, bool searchButtons = false, Object toDirty = null, bool allowAdding = true) where T : PrefabReference, new()
	{
	}

	public Mesh GetMesh(bool refresh = false)
	{
		if ((Object)(object)Prefab == (Object)null)
		{
			return null;
		}
		if (refresh)
		{
			_refMesh = null;
		}
		else if (Object.op_Implicit((Object)(object)_refMesh))
		{
			if ((Object)(object)MainCollider == (Object)null)
			{
				GetCollider();
			}
			return _refMesh;
		}
		List<SkinnedMeshRenderer> list = FTransformMethods.FindComponentsInAllChildren<SkinnedMeshRenderer>(Prefab.transform, includeInactive: false, tryGetMultipleOutOfSingleObject: false);
		for (int i = 0; i < list.Count; i++)
		{
			if (Object.op_Implicit((Object)(object)list[i]) && Object.op_Implicit((Object)(object)list[i].sharedMesh))
			{
				_refMesh = list[i].sharedMesh;
				if ((Object)(object)MainCollider == (Object)null)
				{
					GetCollider();
				}
				return _refMesh;
			}
		}
		List<MeshFilter> list2 = FTransformMethods.FindComponentsInAllChildren<MeshFilter>(Prefab.transform, includeInactive: false, tryGetMultipleOutOfSingleObject: false);
		for (int j = 0; j < list2.Count; j++)
		{
			if (Object.op_Implicit((Object)(object)list2[j]) && Object.op_Implicit((Object)(object)list2[j].sharedMesh))
			{
				_refMesh = list2[j].sharedMesh;
				if ((Object)(object)MainCollider == (Object)null)
				{
					GetCollider();
				}
				return _refMesh;
			}
		}
		if ((Object)(object)MainCollider == (Object)null)
		{
			MainCollider = FTransformMethods.FindComponentInAllChildren<Collider>(Prefab.transform);
		}
		return _refMesh;
	}

	public Collider GetCollider()
	{
		if ((Object)(object)Prefab == (Object)null)
		{
			return null;
		}
		if (Object.op_Implicit((Object)(object)_refCol))
		{
			if ((Object)(object)MainCollider == (Object)null)
			{
				MainCollider = _refCol;
			}
			return _refCol;
		}
		List<Collider> list = FTransformMethods.FindComponentsInAllChildren<Collider>(Prefab.transform, includeInactive: false, tryGetMultipleOutOfSingleObject: false);
		for (int i = 0; i < list.Count; i++)
		{
			if (Object.op_Implicit((Object)(object)list[i]))
			{
				_refCol = list[i];
				if ((Object)(object)MainCollider == (Object)null)
				{
					MainCollider = _refCol;
				}
				return _refCol;
			}
		}
		if ((Object)(object)_refCol == (Object)null)
		{
			_refCol = Prefab.GetComponent<Collider>();
		}
		if ((Object)(object)MainCollider == (Object)null)
		{
			MainCollider = _refCol;
		}
		return _refCol;
	}

	public void SetPrefab(GameObject pf)
	{
		Prefab = pf;
	}

	public void SetCollider(Collider pf)
	{
		MainCollider = pf;
	}

	public void TemporaryReplace(GameObject tempRepl)
	{
		if ((Object)(object)tempRepl == (Object)null)
		{
			tempReplacePrefab = null;
			tempReplaceCollider = null;
		}
		else
		{
			tempReplacePrefab = tempRepl;
			tempReplaceCollider = tempRepl.GetComponentInChildren<Collider>();
		}
	}
}


using System;
using FIMSpace.Generating;
using UnityEngine;

[Serializable]
public struct MinMax
{
	public int Min;

	public int Max;

	public bool IsZero
	{
		get
		{
			if (Min == 0)
			{
				return Max == 0;
			}
			return false;
		}
	}

	public static FIMSpace.Generating.MinMax zero => new FIMSpace.Generating.MinMax(0, 0);

	public Vector2 ToVector2 => new Vector2((float)Min, (float)Max);

	public Vector2Int ToVector2Int => new Vector2Int(Min, Max);

	public MinMax(int min, int max)
	{
		Min = min;
		Max = max;
	}

	public int GetRandom()
	{
		return (int)((float)Min + FGenerators.GetRandom() * (float)(Max + 1 - Min));
	}
}


using System;

[Serializable]
public struct MinMaxF
{
	public float Min;

	public float Max;

	public MinMaxF(float min, float max)
	{
		Min = min;
		Max = max;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using FIMSpace;
using FIMSpace.FTail;
using FIMSpace.FTools;
using UnityEngine;
using UnityEngine.EventSystems;

[HelpURL("https://assetstore.unity.com/packages/tools/animation/tail-animator-121819")]
[AddComponentMenu("FImpossible Creations/Tail Animator 2")]
[DefaultExecutionOrder(-4)]
public class TailAnimator2 : MonoBehaviour, IDropHandler, IEventSystemHandler, IFHierarchyIcon, IClientComponent
{
	[Serializable]
	public class TailSegment
	{
		public Vector3 ProceduralPosition = Vector3.zero;

		public Vector3 ProceduralPositionWeightBlended = Vector3.zero;

		public Quaternion TrueTargetRotation = Quaternion.identity;

		public Quaternion PosRefRotation = Quaternion.identity;

		public Quaternion PreviousPosReferenceRotation = Quaternion.identity;

		public Vector3 PreviousPosition;

		public float BlendValue = 1f;

		public Vector3 BoneDimensionsScaled;

		public float BoneLengthScaled;

		public Vector3 InitialLocalPosition = Vector3.zero;

		public Vector3 InitialLocalPositionInRoot = Vector3.zero;

		public Quaternion InitialLocalRotationInRoot = Quaternion.identity;

		public Vector3 LocalOffset = Vector3.zero;

		public Quaternion InitialLocalRotation = Quaternion.identity;

		public float ColliderRadius = 1f;

		public bool CollisionContactFlag;

		public float CollisionContactRelevancy = -1f;

		public Collision collisionContacts;

		public Vector3 VelocityHelper = Vector3.zero;

		public Quaternion QVelocityHelper = Quaternion.identity;

		public Vector3 PreviousPush = Vector3.zero;

		public Quaternion Curving = Quaternion.identity;

		public Vector3 Gravity = Vector3.zero;

		public Vector3 GravityLookOffset = Vector3.zero;

		public float LengthMultiplier = 1f;

		public float PositionSpeed = 1f;

		public float RotationSpeed = 1f;

		public float Springiness;

		public float Slithery = 1f;

		public float Curling = 0.5f;

		public float Slippery = 1f;

		public Quaternion LastKeyframeLocalRotation;

		public Vector3 LastKeyframeLocalPosition;

		private float deflectionSmoothVelo;

		public TailSegment ParentBone { get; private set; }

		public TailSegment ChildBone { get; private set; }

		public Transform transform { get; private set; }

		public int Index { get; private set; }

		public float IndexOverlLength { get; private set; }

		public float BoneLength { get; private set; }

		public TailCollisionHelper CollisionHelper { get; internal set; }

		public bool IsDetachable { get; private set; }

		public Vector3 LastFinalPosition { get; private set; }

		public Quaternion LastFinalRotation { get; private set; }

		public float DeflectionFactor { get; private set; }

		public Vector3 Deflection { get; private set; }

		public float DeflectionSmooth { get; private set; }

		public Vector3 DeflectionWorldPosition { get; private set; }

		public int DeflectionRelevancy { get; private set; }

		public FImp_ColliderData_Base LatestSelectiveCollision { get; internal set; }

		public TailSegment()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0126: Unknown result type (might be due to invalid IL or missing references)
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0142: Unknown result type (might be due to invalid IL or missing references)
			Index = -1;
			Curving = Quaternion.identity;
			Gravity = Vector3.zero;
			LengthMultiplier = 1f;
			Deflection = Vector3.zero;
			DeflectionFactor = 0f;
			DeflectionRelevancy = -1;
			deflectionSmoothVelo = 0f;
		}

		public TailSegment(Transform transform)
			: this()
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)transform == (Object)null))
			{
				this.transform = transform;
				ProceduralPosition = transform.position;
				PreviousPosition = transform.position;
				PosRefRotation = transform.rotation;
				PreviousPosReferenceRotation = PosRefRotation;
				TrueTargetRotation = PosRefRotation;
				ReInitializeLocalPosRot(transform.localPosition, transform.localRotation);
				BoneLength = 0.1f;
			}
		}

		public TailSegment(TailSegment copyFrom)
			: this(copyFrom.transform)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			transform = copyFrom.transform;
			Index = copyFrom.Index;
			IndexOverlLength = copyFrom.IndexOverlLength;
			ProceduralPosition = copyFrom.ProceduralPosition;
			PreviousPosition = copyFrom.PreviousPosition;
			ProceduralPositionWeightBlended = copyFrom.ProceduralPosition;
			PosRefRotation = copyFrom.PosRefRotation;
			PreviousPosReferenceRotation = PosRefRotation;
			TrueTargetRotation = copyFrom.TrueTargetRotation;
			ReInitializeLocalPosRot(copyFrom.InitialLocalPosition, copyFrom.InitialLocalRotation);
		}

		public void ReInitializeLocalPosRot(Vector3 initLocalPos, Quaternion initLocalRot)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			InitialLocalPosition = initLocalPos;
			InitialLocalRotation = initLocalRot;
		}

		public void SetIndex(int i, int tailSegments)
		{
			Index = i;
			if (i < 0)
			{
				IndexOverlLength = 0f;
			}
			else
			{
				IndexOverlLength = (float)i / (float)tailSegments;
			}
		}

		public void SetParentRef(TailSegment parent)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			ParentBone = parent;
			Vector3 val = ProceduralPosition - ParentBone.ProceduralPosition;
			BoneLength = ((Vector3)(ref val)).magnitude;
		}

		public void SetChildRef(TailSegment child)
		{
			ChildBone = child;
		}

		public float GetRadiusScaled()
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return ColliderRadius * transform.lossyScale.x;
		}

		public void AssignDetachedRootCoords(Transform root)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			InitialLocalPositionInRoot = root.InverseTransformPoint(transform.position);
			InitialLocalRotationInRoot = root.rotation.QToLocal(transform.rotation);
			IsDetachable = true;
		}

		internal Vector3 BlendMotionWeight(Vector3 newPosition)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			return Vector3.LerpUnclamped(ParentBone.ProceduralPosition + ParentBone.LastKeyframeLocalRotation.TransformVector(ParentBone.transform.lossyScale, LastKeyframeLocalPosition), newPosition, BlendValue);
		}

		internal void PreCalibrate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			transform.localPosition = InitialLocalPosition;
			transform.localRotation = InitialLocalRotation;
		}

		internal void Validate()
		{
			if (BoneLength == 0f)
			{
				BoneLength = 0.001f;
			}
		}

		public void RefreshKeyLocalPosition()
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)transform))
			{
				LastKeyframeLocalRotation = transform.localRotation;
			}
			else
			{
				LastKeyframeLocalRotation = InitialLocalRotation;
			}
		}

		public void RefreshKeyLocalPositionAndRotation()
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)transform))
			{
				RefreshKeyLocalPositionAndRotation(transform.localPosition, transform.localRotation);
			}
			else
			{
				RefreshKeyLocalPositionAndRotation(InitialLocalPosition, InitialLocalRotation);
			}
		}

		public void RefreshKeyLocalPositionAndRotation(Vector3 p, Quaternion r)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			LastKeyframeLocalPosition = p;
			LastKeyframeLocalRotation = r;
		}

		internal Vector3 ParentToFrontOffset()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			return ParentBone.LastKeyframeLocalRotation.TransformVector(ParentBone.transform.lossyScale, LastKeyframeLocalPosition);
		}

		public void RefreshFinalPos(Vector3 pos)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			LastFinalPosition = pos;
		}

		public void RefreshFinalRot(Quaternion rot)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			LastFinalRotation = rot;
		}

		public bool CheckDeflectionState(float zeroWhenLower, float smoothTime, float delta)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = LastKeyframeLocalPosition - ParentBone.transform.InverseTransformVector(ProceduralPosition - ParentBone.ProceduralPosition);
			DeflectionFactor = Vector3.Dot(((Vector3)(ref LastKeyframeLocalPosition)).normalized, ((Vector3)(ref val)).normalized);
			if (DeflectionFactor < zeroWhenLower)
			{
				if (smoothTime <= Mathf.Epsilon)
				{
					DeflectionSmooth = 0f;
				}
				else
				{
					DeflectionSmooth = Mathf.SmoothDamp(DeflectionSmooth, 0f - Mathf.Epsilon, ref deflectionSmoothVelo, smoothTime / 1.5f, float.PositiveInfinity, delta);
				}
			}
			else if (smoothTime <= Mathf.Epsilon)
			{
				DeflectionSmooth = 1f;
			}
			else
			{
				DeflectionSmooth = Mathf.SmoothDamp(DeflectionSmooth, 1f, ref deflectionSmoothVelo, smoothTime, float.PositiveInfinity, delta);
			}
			if (DeflectionSmooth <= Mathf.Epsilon)
			{
				return true;
			}
			if (ChildBone.ChildBone != null)
			{
				DeflectionWorldPosition = ChildBone.ChildBone.ProceduralPosition;
			}
			else
			{
				DeflectionWorldPosition = ChildBone.ProceduralPosition;
			}
			return false;
		}

		public bool DeflectionRelevant()
		{
			if (DeflectionRelevancy == -1)
			{
				DeflectionRelevancy = 3;
				return true;
			}
			DeflectionRelevancy = 3;
			return false;
		}

		public bool? DeflectionRestoreState()
		{
			if (DeflectionRelevancy > 0)
			{
				DeflectionRelevancy--;
				if (DeflectionRelevancy == 0)
				{
					DeflectionRelevancy = -1;
					return null;
				}
				return true;
			}
			return false;
		}

		internal void ParamsFrom(TailSegment other)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			BlendValue = other.BlendValue;
			ColliderRadius = other.ColliderRadius;
			Gravity = other.Gravity;
			LengthMultiplier = other.LengthMultiplier;
			BoneLength = other.BoneLength;
			BoneLengthScaled = other.BoneLengthScaled;
			BoneDimensionsScaled = other.BoneDimensionsScaled;
			collisionContacts = other.collisionContacts;
			CollisionHelper = other.CollisionHelper;
			PositionSpeed = other.PositionSpeed;
			RotationSpeed = other.RotationSpeed;
			Springiness = other.Springiness;
			Slithery = other.Slithery;
			Curling = other.Curling;
			Slippery = other.Slippery;
		}

		internal void ParamsFromAll(TailSegment other)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00da: Unknown result type (might be due to invalid IL or missing references)
			ParamsFrom(other);
			InitialLocalPosition = other.InitialLocalPosition;
			InitialLocalRotation = other.InitialLocalRotation;
			LastFinalPosition = other.LastFinalPosition;
			LastFinalRotation = other.LastFinalRotation;
			ProceduralPosition = other.ProceduralPosition;
			ProceduralPositionWeightBlended = other.ProceduralPositionWeightBlended;
			TrueTargetRotation = other.TrueTargetRotation;
			PosRefRotation = other.PosRefRotation;
			PreviousPosReferenceRotation = other.PreviousPosReferenceRotation;
			PreviousPosition = other.PreviousPosition;
			BoneLength = other.BoneLength;
			BoneDimensionsScaled = other.BoneDimensionsScaled;
			BoneLengthScaled = other.BoneLengthScaled;
			LocalOffset = other.LocalOffset;
			ColliderRadius = other.ColliderRadius;
			VelocityHelper = other.VelocityHelper;
			QVelocityHelper = other.QVelocityHelper;
			PreviousPush = other.PreviousPush;
		}

		internal void User_ReassignTransform(Transform t)
		{
			transform = t;
		}

		public void Reset()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			PreviousPush = Vector3.zero;
			VelocityHelper = Vector3.zero;
			QVelocityHelper = Quaternion.identity;
			if (Object.op_Implicit((Object)(object)transform))
			{
				ProceduralPosition = transform.position;
				PosRefRotation = transform.rotation;
				PreviousPosReferenceRotation = transform.rotation;
			}
			else if (Object.op_Implicit((Object)(object)ParentBone.transform))
			{
				ProceduralPosition = ParentBone.transform.position + ParentToFrontOffset();
			}
			PreviousPosition = ProceduralPosition;
			ProceduralPositionWeightBlended = ProceduralPosition;
		}
	}

	public enum ECollisionSpace
	{
		World_Slow,
		Selective_Fast
	}

	public enum ECollisionMode
	{
		m_3DCollision,
		m_2DCollision
	}

	[Serializable]
	public class IKBoneSettings
	{
		[Range(0f, 181f)]
		public float AngleLimit = 45f;

		[Range(0f, 181f)]
		public float TwistAngleLimit = 5f;

		public bool UseInChain = true;
	}

	public enum FEWavingType
	{
		Simple,
		Advanced
	}

	public enum EFDeltaType
	{
		DeltaTime,
		SmoothDeltaTime,
		UnscaledDeltaTime,
		FixedDeltaTime,
		SafeDelta
	}

	public enum EAnimationStyle
	{
		Quick,
		Accelerating,
		Linear
	}

	public enum ETailCategory
	{
		Setup,
		Tweak,
		Features,
		Shaping
	}

	public enum ETailFeaturesCategory
	{
		Main,
		Collisions,
		IK,
		Experimental
	}

	public enum EFixedMode
	{
		None,
		Basic,
		Late
	}

	[Tooltip("Using some simple calculations to make tail bend on colliders")]
	public bool UseCollision;

	[Tooltip("How collision should be detected, world gives you collision on all world colliders but with more use of cpu (using unity's rigidbodies), 'Selective' gives you possibility to detect collision on selected colliders without using Rigidbodies, it also gives smoother motion (deactivated colliders will still detect collision, unless its game object is disabled)")]
	public ECollisionSpace CollisionSpace = ECollisionSpace.Selective_Fast;

	public ECollisionMode CollisionMode;

	[Tooltip("If you want to stop checking collision if segment collides with one collider\n\nSegment collision with two or more colliders in the same time with this option enabled can result in stuttery motion")]
	public bool CheapCollision;

	[Tooltip("Using trigger collider to include encountered colliders into collide with list")]
	public bool DynamicWorldCollidersInclusion;

	[Tooltip("Radius of trigger collider for dynamic inclusion of colliders")]
	public float InclusionRadius = 1f;

	public bool IgnoreMeshColliders = true;

	public List<Collider> IncludedColliders;

	public List<Collider2D> IncludedColliders2D;

	protected List<FImp_ColliderData_Base> IncludedCollidersData;

	protected List<FImp_ColliderData_Base> CollidersDataToCheck;

	[Tooltip("Capsules can give much more precise collision detection")]
	public int CollidersType;

	public bool CollideWithOtherTails;

	[Tooltip("Collision with colliders even if they're disabled (but game object must be enabled)\nHelpful to setup character limbs collisions without need to create new Layer")]
	public bool CollideWithDisabledColliders = true;

	[Range(0f, 1f)]
	public float CollisionSlippery = 1f;

	[Range(0f, 1f)]
	[Tooltip("If tail colliding objects should fit to colliders (0) or be reflect from them (Reflecting Only with 'Slithery' parameter greater than ~0.2)")]
	public float ReflectCollision;

	public AnimationCurve CollidersScaleCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	public float CollidersScaleMul = 6.5f;

	[Range(0f, 1f)]
	public float CollisionsAutoCurve = 0.5f;

	public List<Collider> IgnoredColliders;

	public List<Collider2D> IgnoredColliders2D;

	public bool CollidersSameLayer = true;

	[Tooltip("If you add rigidbodies to each tail segment's collider, collision will work on everything but it will be less optimal, you don't have to add here rigidbodies but then you must have not kinematic rigidbodies on objects segments can collide")]
	public bool CollidersAddRigidbody = true;

	public float RigidbodyMass = 1f;

	[FPD_Layers]
	public int CollidersLayer;

	public bool UseSlitheryCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1.2f, 0.1f, 0.8f, 1f, 0.9f)]
	public AnimationCurve SlitheryCurve = AnimationCurve.EaseInOut(0f, 0.75f, 1f, 1f);

	private float lastSlithery = -1f;

	private Keyframe[] lastSlitheryCurvKeys;

	public bool UseCurlingCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.65f, 0.4f, 1f, 0.9f)]
	public AnimationCurve CurlingCurve = AnimationCurve.EaseInOut(0f, 0.7f, 1f, 0.3f);

	private float lastCurling = -1f;

	private Keyframe[] lastCurlingCurvKeys;

	public bool UseSpringCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.9f, 0.7f, 0.2f, 0.9f)]
	public AnimationCurve SpringCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);

	private float lastSpringiness = -1f;

	private Keyframe[] lastSpringCurvKeys;

	public bool UseSlipperyCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.2f, 0.9f, 0.6f, 0.9f)]
	public AnimationCurve SlipperyCurve = AnimationCurve.EaseInOut(0f, 0.7f, 1f, 1f);

	private float lastSlippery = -1f;

	private Keyframe[] lastSlipperyCurvKeys;

	public bool UsePosSpeedCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.2f, 1f, 0.3f, 0.9f)]
	public AnimationCurve PosCurve = AnimationCurve.EaseInOut(0f, 0.7f, 1f, 1f);

	private float lastPosSpeeds = -1f;

	private Keyframe[] lastPosCurvKeys;

	public bool UseRotSpeedCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.7f, 0.7f, 0.7f, 0.9f)]
	public AnimationCurve RotCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0.9f);

	private float lastRotSpeeds = -1f;

	private Keyframe[] lastRotCurvKeys;

	[Tooltip("Spreading Tail Animator motion weight over bones")]
	public bool UsePartialBlend;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.2f, 0.5f, 0.85f, 1f)]
	public AnimationCurve BlendCurve = AnimationCurve.EaseInOut(0f, 0.95f, 1f, 0.45f);

	private float lastTailAnimatorAmount = -1f;

	private Keyframe[] lastBlendCurvKeys;

	private TailSegment _ex_bone;

	public bool UseIK;

	private bool ikInitialized;

	[SerializeField]
	private FIK_CCDProcessor IK;

	[Tooltip("Target object to follow by IK")]
	public Transform IKTarget;

	public bool IKAutoWeights = true;

	[Range(0f, 1f)]
	public float IKBaseReactionWeight = 0.65f;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.2f, 0.5f, 0.85f, 1f)]
	public AnimationCurve IKReactionWeightCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0.25f);

	public bool IKAutoAngleLimits = true;

	[FPD_Suffix(0f, 181f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "", true, 0)]
	public float IKAutoAngleLimit = 40f;

	[Tooltip("If ik process should work referencing to previously computed CCDIK pose (can be more precise but need more adjusting in weights and angle limits)")]
	public bool IKContinousSolve;

	[Tooltip("Inverting ik iteration order to generate different pose results - more straight towards target")]
	public bool IkInvertOrder;

	[Tooltip("How much IK motion sohuld be used in tail animator motion -> 0: turned off")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float IKBlend = 1f;

	[Tooltip("If syncing with animator then applying motion of keyframe animation for IK")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float IKAnimatorBlend = 0.5f;

	[Range(1f, 32f)]
	[Tooltip("How much iterations should do CCDIK algorithm in one frame")]
	public int IKReactionQuality = 2;

	[Tooltip("Smoothing reactions in CCD IK algorithm")]
	[Range(0f, 1f)]
	public float IKSmoothing;

	[Range(0f, 1.5f)]
	public float IKStretchToTarget;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.9f, 0.4f, 0.5f, 1f)]
	public AnimationCurve IKStretchCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public List<IKBoneSettings> IKLimitSettings;

	public bool IKSelectiveChain;

	private Vector3? _IKCustomPos;

	private List<TailSegment> _pp_reference;

	private TailSegment _pp_ref_rootParent;

	private TailSegment _pp_ref_lastChild;

	private bool _pp_initialized;

	[Tooltip("Rotation offset for tail (just first (root) bone is rotated)")]
	public Quaternion RotationOffset = Quaternion.identity;

	[Tooltip("Rotate each segment a bit to create curving effect")]
	public Quaternion Curving = Quaternion.identity;

	[Tooltip("Spread curving rotation offset weight over tail segments")]
	public bool UseCurvingCurve;

	[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0.75f, 0.75f, 0.75f, 0.85f)]
	public AnimationCurve CurvCurve = AnimationCurve.EaseInOut(0f, 0.75f, 1f, 1f);

	private Quaternion lastCurving = Quaternion.identity;

	private Keyframe[] lastCurvingKeys;

	[Tooltip("Make tail longer or shorter")]
	public float LengthMultiplier = 1f;

	[Tooltip("Spread length multiplier weight over tail segments")]
	public bool UseLengthMulCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 3f, 0f, 1f, 1f, 1f)]
	public AnimationCurve LengthMulCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	private float lastLengthMul = 1f;

	private Keyframe[] lastLengthKeys;

	[Tooltip("Spread gravity weight over tail segments")]
	public bool UseGravityCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.85f, 0.35f, 0.25f, 0.85f)]
	[Tooltip("Spread gravity weight over tail segments")]
	public AnimationCurve GravityCurve = AnimationCurve.EaseInOut(0f, 0.65f, 1f, 1f);

	[Tooltip("Simulate gravity weight for tail logics")]
	public Vector3 Gravity = Vector3.zero;

	private Vector3 lastGravity = Vector3.zero;

	private Keyframe[] lastGravityKeys;

	[Tooltip("Using auto waving option to give floating effect")]
	public bool UseWaving = true;

	[Tooltip("Adding some variation to waving animation")]
	public bool CosinusAdd;

	[Tooltip("If you want few tails to wave in the same way you can set this sinus period cycle value")]
	public float FixedCycle;

	[Tooltip("How frequent swings should be")]
	public float WavingSpeed = 3f;

	[Tooltip("How big swings should be")]
	public float WavingRange = 0.8f;

	[Tooltip("What rotation axis should be used in auto waving")]
	public Vector3 WavingAxis = new Vector3(1f, 1f, 1f);

	[Tooltip("Type of waving animation algorithm, it can be simple trigonometric wave or animation based on noises (advanced)")]
	public FEWavingType WavingType = FEWavingType.Advanced;

	[Tooltip("Offsetting perlin noise to generate different variation of tail rotations")]
	public float AlternateWave = 1f;

	private float _waving_waveTime;

	private float _waving_cosTime;

	private Vector3 _waving_sustain = Vector3.zero;

	public bool UseWind;

	[FPD_Suffix(0f, 2.5f, FPD_SuffixAttribute.SuffixMode.PercentageUnclamped, "%", true, 0)]
	public float WindEffectPower = 1f;

	[FPD_Suffix(0f, 2.5f, FPD_SuffixAttribute.SuffixMode.PercentageUnclamped, "%", true, 0)]
	public float WindTurbulencePower = 1f;

	[FPD_Suffix(0f, 1.5f, FPD_SuffixAttribute.SuffixMode.PercentageUnclamped, "%", true, 0)]
	public float WindWorldNoisePower = 0.5f;

	public Vector3 WindEffect = Vector3.zero;

	public List<TailSegment> TailSegments;

	[SerializeField]
	private TailSegment GhostParent;

	[SerializeField]
	private TailSegment GhostChild;

	private Vector3 _limiting_limitPosition = Vector3.zero;

	private Vector3 _limiting_influenceOffset = Vector3.zero;

	private float _limiting_stretchingHelperTooLong;

	private float _limiting_stretchingHelperTooShort;

	private Quaternion _limiting_angle_ToTargetRot;

	private Quaternion _limiting_angle_targetInLocal;

	private Quaternion _limiting_angle_newLocal;

	private Vector3 _tc_segmentGravityOffset = Vector3.zero;

	private Vector3 _tc_segmentGravityToParentDir = Vector3.zero;

	private Vector3 _tc_preGravOff = Vector3.zero;

	[Tooltip("If you want to use max distance fade option to smoothly disable tail animator when object is going far away from camera")]
	public bool UseMaxDistance;

	[Tooltip("(By default camera transform) Measuring distance from this object to define if object is too far and not need to update tail animator")]
	public Transform DistanceFrom;

	[HideInInspector]
	public Transform _distanceFrom_Auto;

	[Tooltip("Max distance to main camera / target object to smoothly turn off tail animator.")]
	public float MaximumDistance = 35f;

	[Range(0f, 1f)]
	[Tooltip("If object in range should be detected only when is nearer than 'MaxDistance' to avoid stuttery enabled - disable switching")]
	public float MaxOutDistanceFactor;

	[Tooltip("If distance should be measured not using Up (y) axis")]
	public bool DistanceWithoutY;

	[Tooltip("Offsetting point from which we want to measure distance to target")]
	public Vector3 DistanceMeasurePoint;

	[Range(0.25f, 2f)]
	[Tooltip("Disable fade duration in seconds")]
	public float FadeDuration = 0.75f;

	private bool maxDistanceExceed;

	private Transform finalDistanceFrom;

	private bool wasCameraSearch;

	private float distanceWeight = 1f;

	private int _tc_startI;

	private int _tc_startII = 1;

	private TailSegment _tc_rootBone;

	private Quaternion _tc_lookRot = Quaternion.identity;

	private Quaternion _tc_targetParentRot = Quaternion.identity;

	private Quaternion _tc_startBoneRotOffset = Quaternion.identity;

	private float _tc_tangle = 1f;

	private float _sg_springVelo = 0.5f;

	private float _sg_curly = 0.5f;

	private Vector3 _sg_push;

	private Vector3 _sg_targetPos;

	private Vector3 _sg_targetChildWorldPosInParentFront;

	private Vector3 _sg_dirToTargetParentFront;

	private Quaternion _sg_orientation;

	private float _sg_slitFactor = 0.5f;

	private bool wasDisabled = true;

	private float justDelta = 0.016f;

	private float secPeriodDelta = 0.5f;

	private float deltaForLerps = 0.016f;

	private float rateDelta = 0.016f;

	protected float collectedDelta;

	protected int framesToSimulate = 1;

	protected int previousframesToSimulate = 1;

	private bool updateTailAnimator;

	private int startAfterTPoseCounter;

	private bool fixedUpdated;

	private bool lateFixedIsRunning;

	private bool fixedAllow = true;

	[Range(0f, 1f)]
	[Tooltip("Making tail segment deflection influence back segments")]
	public float Deflection;

	[FPD_Suffix(1f, 89f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "", true, 0)]
	public float DeflectionStartAngle = 10f;

	[Range(0f, 1f)]
	public float DeflectionSmooth;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.65f, 0.4f, 1f, 0.9f)]
	public AnimationCurve DeflectionFalloff = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	[Tooltip("Deflection can be triggered every time tail is waving but you not always would want this feature be enabled (different behaviour of tail motion)")]
	public bool DeflectOnlyCollisions = true;

	private List<TailSegment> _defl_source;

	private float _defl_treshold = 0.01f;

	private bool _forceDisable;

	private float _forceDisableElapsed;

	public ETailCategory _Editor_Category;

	public ETailFeaturesCategory _Editor_FeaturesCategory;

	public bool DrawGizmos = true;

	[Tooltip("First bone of tail motion chain")]
	public Transform StartBone;

	[Tooltip("Finish bone of tail motion chain")]
	public Transform EndBone;

	[Tooltip("Adjusting end point for end tail bone motion")]
	public Vector3 EndBoneJointOffset = Vector3.zero;

	public List<Transform> _TransformsGhostChain;

	public int _GhostChainInitCount = -1;

	protected bool initialized;

	[Tooltip("Target FPS update rate for Tail Animator.\n\nIf you want Tail Animator to behave the same in low/high fps, set this value for example to 60.\nIt also can help optimizing if your game have more than 60 fps.")]
	public int UpdateRate;

	[Tooltip("If your character Unity's Animator have update mode set to 'Animate Physics' you should enable it here too")]
	public EFixedMode AnimatePhysics;

	[Tooltip("When using target fps rate you can interpolate coordinates for smoother effect when object with tail is moving a lot")]
	public bool InterpolateRate;

	[Tooltip("Simulating tail motion at initiation to prevent jiggle start")]
	public bool Prewarm;

	internal float OverrideWeight = 1f;

	protected float conditionalWeight = 1f;

	protected bool collisionInitialized;

	protected bool forceRefreshCollidersData;

	private Vector3 previousWorldPosition;

	protected Transform rootTransform;

	protected bool preAutoCorrect;

	[Tooltip("Blending Slithery - smooth & soft tentacle like movement (value = 1)\nwith more stiff & springy motion (value = 0)\n\n0: Stiff somewhat like tree branch\n1: Soft like squid tentacle / Animal tail")]
	[Range(0f, 1.2f)]
	public float Slithery = 1f;

	[Tooltip("How curly motion should be applied to tail segments")]
	[Range(0f, 1f)]
	public float Curling = 0.5f;

	[Tooltip("Elastic spring effect making motion more 'meaty'")]
	[Range(0f, 1f)]
	public float Springiness;

	[Tooltip("If you want to limit stretching/gumminess of position motion when object moves fast. Recommended adjust to go with it under 0.3 value.\nValue = 1: Unlimited stretching")]
	[Range(0f, 1f)]
	public float MaxStretching = 0.375f;

	[Tooltip("Limiting max rotation angle for each tail segment")]
	[FPD_Suffix(1f, 181f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "", true, 0)]
	public float AngleLimit = 181f;

	[Tooltip("If you need specific axis to be limited.\nLeave unchanged to limit all axes.")]
	public Vector3 AngleLimitAxis = Vector3.zero;

	[Tooltip("If you want limit axes symmetrically leave this parameter unchanged, if you want limit one direction of axis more than reversed, tweak this parameter")]
	public Vector2 LimitAxisRange = Vector2.zero;

	[Tooltip("If limiting shouldn't be too rapidly performed")]
	[Range(0f, 1f)]
	public float LimitSmoothing = 0.5f;

	[Tooltip("If your object moves very fast making tail influenced by speed too much then you can controll it with this parameter")]
	[FPD_Suffix(0f, 1.5f, FPD_SuffixAttribute.SuffixMode.PercentageUnclamped, "%", true, 0)]
	public float MotionInfluence = 1f;

	[Tooltip("Additional Y influence controll useful when your character is jumping (works only when MotionInfluence value is other than 100%)")]
	[Range(0f, 1f)]
	public float MotionInfluenceInY = 1f;

	[Tooltip("If first bone of chain should also be affected with whole chain")]
	public bool IncludeParent = true;

	[Range(0f, 1f)]
	[Tooltip("By basic algorithm of Tail Animator different sized tails with different number of bones would animate with different bending thanks to this toggle every setup bends in very similar amount.\n\nShort tails will bend more and longer oner with bigger amount of bones less with this option enabled.")]
	public float UnifyBendiness;

	[Tooltip("Reaction Speed is defining how fast tail segments will return to target position, it gives animation more underwater/floaty feeling if it's lower")]
	[Range(0f, 1f)]
	public float ReactionSpeed = 0.9f;

	[Range(0f, 1f)]
	[Tooltip("Sustain is similar to reaction speed in reverse, but providing sustain motion effect when increased")]
	public float Sustain;

	[Tooltip("Rotation speed is defining how fast tail segments will return to target rotation, it gives animation more lazy feeling if it's lower")]
	[Range(0f, 1f)]
	public float RotationRelevancy = 1f;

	[Tooltip("Smoothing motion values change over time style to be applied for 'Reaction Speed' and 'Rotation Relevancy' parameters")]
	public EAnimationStyle SmoothingStyle = EAnimationStyle.Accelerating;

	[Tooltip("Slowmo or speedup tail animation reaction")]
	public float TimeScale = 1f;

	[Tooltip("Delta time type to be used by algorithm")]
	public EFDeltaType DeltaType = EFDeltaType.SafeDelta;

	[Tooltip("Useful when you use other components to affect bones hierarchy and you want this component to follow other component's changes\n\nIt can be really useful when working with 'Spine Animator'")]
	public bool UpdateAsLast = true;

	[Tooltip("Checking if keyframed animation has some empty keyframes which could cause unwanted twisting errors")]
	public bool DetectZeroKeyframes = true;

	[Tooltip("Initializing Tail Animator after first frames of game to not initialize with model's T-Pose but after playing some other animation")]
	public bool StartAfterTPose = true;

	[Tooltip("If you want Tail Animator to stop computing when choosed mesh is not visible in any camera view (editor's scene camera is detecting it too)")]
	public Renderer OptimizeWithMesh;

	[Tooltip("If you want to check multiple meshes visibility on screen to define if you want to disable tail animator. (useful when using LOD for skinned mesh renderer)")]
	public Renderer[] OptimizeWithMeshes;

	[Tooltip("Blend Source Animation (keyframed / unanimated) and Tail Animator")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float TailAnimatorAmount = 1f;

	[Tooltip("Removing transforms hierachy structure to optimize Unity's calculations on Matrixes.\nIt can give very big boost in performance for long tails but it can't work with animated models!")]
	public bool DetachChildren;

	[Tooltip("If tail movement should not move in depth you can use this parameter")]
	public int Axis2D;

	[Tooltip("[Experimental: Works only with Slithery Blend set to >= 1] Making each segment go to target pose in front of parent segment creating new animation effect")]
	[Range(-1f, 1f)]
	public float Tangle;

	[Tooltip("Making tail animate also roll rotation like it was done in Tail Animator V1 ! Use Rotation Relevancy Parameter (set lower than 0.5) !")]
	public bool AnimateRoll;

	[Tooltip("Overriding keyframe animation with just Tail Animator option (keyframe animation treated as t-pose bones rotations)")]
	[Range(0f, 1f)]
	public float OverrideKeyframeAnimation;

	private Transform _baseTransform;

	public List<Component> DynamicAlwaysInclude { get; private set; }

	public Quaternion WavingRotationOffset { get; private set; }

	public float _TC_TailLength { get; private set; }

	public string EditorIconPath
	{
		get
		{
			if (PlayerPrefs.GetInt("AnimsH", 1) == 0)
			{
				return "";
			}
			return "Tail Animator/Tail Animator Icon Small";
		}
	}

	public bool IsInitialized => initialized;

	public Transform BaseTransform
	{
		get
		{
			if (Object.op_Implicit((Object)(object)_baseTransform))
			{
				return _baseTransform;
			}
			if (_TransformsGhostChain != null && _TransformsGhostChain.Count > 0)
			{
				_baseTransform = _TransformsGhostChain[0];
			}
			if ((Object)(object)_baseTransform != (Object)null)
			{
				return _baseTransform;
			}
			return ((Component)this).transform;
		}
	}

	private void RefreshSegmentsColliders()
	{
		if (CollisionSpace == ECollisionSpace.Selective_Fast && TailSegments != null && TailSegments.Count > 1)
		{
			for (int i = 0; i < TailSegments.Count; i++)
			{
				TailSegments[i].ColliderRadius = GetColliderSphereRadiusFor(i);
			}
		}
	}

	private void BeginCollisionsUpdate()
	{
		if (CollisionSpace != ECollisionSpace.Selective_Fast)
		{
			return;
		}
		RefreshIncludedCollidersDataList();
		CollidersDataToCheck.Clear();
		for (int i = 0; i < IncludedCollidersData.Count; i++)
		{
			if ((Object)(object)IncludedCollidersData[i].Transform == (Object)null)
			{
				forceRefreshCollidersData = true;
				break;
			}
			if (!((Component)IncludedCollidersData[i].Transform).gameObject.activeInHierarchy)
			{
				continue;
			}
			if (CollideWithDisabledColliders)
			{
				IncludedCollidersData[i].RefreshColliderData();
				CollidersDataToCheck.Add(IncludedCollidersData[i]);
			}
			else if (CollisionMode == ECollisionMode.m_3DCollision)
			{
				if ((Object)(object)IncludedCollidersData[i].Collider == (Object)null)
				{
					forceRefreshCollidersData = true;
					break;
				}
				if (IncludedCollidersData[i].Collider.enabled)
				{
					IncludedCollidersData[i].RefreshColliderData();
					CollidersDataToCheck.Add(IncludedCollidersData[i]);
				}
			}
			else
			{
				if ((Object)(object)IncludedCollidersData[i].Collider2D == (Object)null)
				{
					forceRefreshCollidersData = true;
					break;
				}
				if (((Behaviour)IncludedCollidersData[i].Collider2D).enabled)
				{
					IncludedCollidersData[i].RefreshColliderData();
					CollidersDataToCheck.Add(IncludedCollidersData[i]);
				}
			}
		}
	}

	private void SetupSphereColliders()
	{
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_040e: Unknown result type (might be due to invalid IL or missing references)
		if (CollisionSpace == ECollisionSpace.World_Slow)
		{
			for (int i = 1; i < _TransformsGhostChain.Count; i++)
			{
				if (CollidersSameLayer)
				{
					((Component)_TransformsGhostChain[i]).gameObject.layer = ((Component)this).gameObject.layer;
				}
				else
				{
					((Component)_TransformsGhostChain[i]).gameObject.layer = CollidersLayer;
				}
			}
			if (CollidersType != 0)
			{
				for (int j = 1; j < _TransformsGhostChain.Count - 1; j++)
				{
					CapsuleCollider val = ((Component)_TransformsGhostChain[j]).gameObject.AddComponent<CapsuleCollider>();
					TailCollisionHelper tailCollisionHelper = ((Component)_TransformsGhostChain[j]).gameObject.AddComponent<TailCollisionHelper>().Init(CollidersAddRigidbody, RigidbodyMass);
					tailCollisionHelper.TailCollider = (Collider)(object)val;
					tailCollisionHelper.Index = j;
					tailCollisionHelper.ParentTail = this;
					val.radius = GetColliderSphereRadiusFor(_TransformsGhostChain, j);
					val.direction = 2;
					Vector3 val2 = _TransformsGhostChain[j].position - _TransformsGhostChain[j + 1].position;
					val.height = ((Vector3)(ref val2)).magnitude * 2f - val.radius;
					val.center = _TransformsGhostChain[j].InverseTransformPoint(Vector3.Lerp(_TransformsGhostChain[j].position, _TransformsGhostChain[j + 1].position, 0.5f));
					TailSegments[j].ColliderRadius = val.radius;
					TailSegments[j].CollisionHelper = tailCollisionHelper;
				}
			}
			else
			{
				for (int k = 1; k < _TransformsGhostChain.Count; k++)
				{
					SphereCollider val3 = ((Component)_TransformsGhostChain[k]).gameObject.AddComponent<SphereCollider>();
					TailCollisionHelper tailCollisionHelper2 = ((Component)_TransformsGhostChain[k]).gameObject.AddComponent<TailCollisionHelper>().Init(CollidersAddRigidbody, RigidbodyMass);
					tailCollisionHelper2.TailCollider = (Collider)(object)val3;
					tailCollisionHelper2.Index = k;
					tailCollisionHelper2.ParentTail = this;
					val3.radius = GetColliderSphereRadiusFor(_TransformsGhostChain, k);
					TailSegments[k].ColliderRadius = val3.radius;
					TailSegments[k].CollisionHelper = tailCollisionHelper2;
				}
			}
		}
		else
		{
			for (int l = 0; l < _TransformsGhostChain.Count; l++)
			{
				TailSegments[l].ColliderRadius = GetColliderSphereRadiusFor(l);
			}
			IncludedCollidersData = new List<FImp_ColliderData_Base>();
			CollidersDataToCheck = new List<FImp_ColliderData_Base>();
			if (DynamicWorldCollidersInclusion)
			{
				if (CollisionMode == ECollisionMode.m_3DCollision)
				{
					for (int m = 0; m < IncludedColliders.Count; m++)
					{
						DynamicAlwaysInclude.Add((Component)(object)IncludedColliders[m]);
					}
				}
				else
				{
					for (int n = 0; n < IncludedColliders2D.Count; n++)
					{
						DynamicAlwaysInclude.Add((Component)(object)IncludedColliders2D[n]);
					}
				}
				Transform transform = TailSegments[TailSegments.Count / 2].transform;
				float num = Vector3.Distance(_TransformsGhostChain[0].position, _TransformsGhostChain[_TransformsGhostChain.Count - 1].position);
				TailCollisionHelper tailCollisionHelper3 = ((Component)transform).gameObject.AddComponent<TailCollisionHelper>();
				tailCollisionHelper3.ParentTail = this;
				SphereCollider val4 = null;
				CircleCollider2D val5 = null;
				if (CollisionMode == ECollisionMode.m_3DCollision)
				{
					val4 = ((Component)transform).gameObject.AddComponent<SphereCollider>();
					((Collider)val4).isTrigger = true;
					tailCollisionHelper3.TailCollider = (Collider)(object)val4;
				}
				else
				{
					val5 = ((Component)transform).gameObject.AddComponent<CircleCollider2D>();
					((Collider2D)val5).isTrigger = true;
					tailCollisionHelper3.TailCollider2D = (Collider2D)(object)val5;
				}
				tailCollisionHelper3.Init(addRigidbody: true, 1f, kinematic: true);
				float num2 = Mathf.Abs(((Component)transform).transform.lossyScale.z);
				if (num2 == 0f)
				{
					num2 = 1f;
				}
				if ((Object)(object)val4 != (Object)null)
				{
					val4.radius = num / num2;
				}
				else
				{
					val5.radius = num / num2;
				}
				if (CollidersSameLayer)
				{
					((Component)transform).gameObject.layer = ((Component)this).gameObject.layer;
				}
				else
				{
					((Component)transform).gameObject.layer = CollidersLayer;
				}
			}
			RefreshIncludedCollidersDataList();
		}
		collisionInitialized = true;
	}

	internal void CollisionDetection(int index, Collision collision)
	{
		TailSegments[index].collisionContacts = collision;
	}

	internal void ExitCollision(int index)
	{
		TailSegments[index].collisionContacts = null;
	}

	protected bool UseCollisionContact(int index, ref Vector3 pos)
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		if (TailSegments[index].collisionContacts == null)
		{
			return false;
		}
		if (TailSegments[index].collisionContacts.contacts.Length == 0)
		{
			return false;
		}
		Collision collisionContacts = TailSegments[index].collisionContacts;
		float num = FImp_ColliderData_Sphere.CalculateTrueRadiusOfSphereCollider(TailSegments[index].transform, TailSegments[index].ColliderRadius) * 0.95f;
		if (Object.op_Implicit((Object)(object)collisionContacts.collider))
		{
			Collider collider = collisionContacts.collider;
			SphereCollider val = (SphereCollider)(object)((collider is SphereCollider) ? collider : null);
			if (Object.op_Implicit((Object)(object)val))
			{
				FImp_ColliderData_Sphere.PushOutFromSphereCollider(val, num, ref pos, Vector3.zero);
			}
			else
			{
				Collider collider2 = collisionContacts.collider;
				CapsuleCollider val2 = (CapsuleCollider)(object)((collider2 is CapsuleCollider) ? collider2 : null);
				if (Object.op_Implicit((Object)(object)val2))
				{
					FImp_ColliderData_Capsule.PushOutFromCapsuleCollider(val2, num, ref pos, Vector3.zero);
				}
				else
				{
					Collider collider3 = collisionContacts.collider;
					BoxCollider val3 = (BoxCollider)(object)((collider3 is BoxCollider) ? collider3 : null);
					if (Object.op_Implicit((Object)(object)val3))
					{
						if (Object.op_Implicit((Object)(object)TailSegments[index].CollisionHelper.RigBody))
						{
							if (Object.op_Implicit((Object)(object)((Collider)val3).attachedRigidbody))
							{
								if (TailSegments[index].CollisionHelper.RigBody.mass > 1f)
								{
									FImp_ColliderData_Box.PushOutFromBoxCollider(val3, collisionContacts, num, ref pos);
									Vector3 val4 = pos;
									FImp_ColliderData_Box.PushOutFromBoxCollider(val3, num, ref pos);
									pos = Vector3.Lerp(pos, val4, TailSegments[index].CollisionHelper.RigBody.mass / 5f);
								}
								else
								{
									FImp_ColliderData_Box.PushOutFromBoxCollider(val3, num, ref pos);
								}
							}
							else
							{
								FImp_ColliderData_Box.PushOutFromBoxCollider(val3, num, ref pos);
							}
						}
						else
						{
							FImp_ColliderData_Box.PushOutFromBoxCollider(val3, num, ref pos);
						}
					}
					else
					{
						Collider collider4 = collisionContacts.collider;
						MeshCollider val5 = (MeshCollider)(object)((collider4 is MeshCollider) ? collider4 : null);
						if (Object.op_Implicit((Object)(object)val5))
						{
							FImp_ColliderData_Mesh.PushOutFromMeshCollider(val5, collisionContacts, num, ref pos);
						}
						else
						{
							Collider collider5 = collisionContacts.collider;
							FImp_ColliderData_Terrain.PushOutFromTerrain((TerrainCollider)(object)((collider5 is TerrainCollider) ? collider5 : null), num, ref pos);
						}
					}
				}
			}
		}
		return true;
	}

	public void RefreshIncludedCollidersDataList()
	{
		bool flag = false;
		if (CollisionMode == ECollisionMode.m_3DCollision)
		{
			if (IncludedColliders.Count != IncludedCollidersData.Count || forceRefreshCollidersData)
			{
				IncludedCollidersData.Clear();
				for (int num = IncludedColliders.Count - 1; num >= 0; num--)
				{
					if ((Object)(object)IncludedColliders[num] == (Object)null)
					{
						IncludedColliders.RemoveAt(num);
					}
					else
					{
						FImp_ColliderData_Base colliderDataFor = FImp_ColliderData_Base.GetColliderDataFor(IncludedColliders[num]);
						IncludedCollidersData.Add(colliderDataFor);
					}
				}
				flag = true;
			}
		}
		else if (IncludedColliders2D.Count != IncludedCollidersData.Count || forceRefreshCollidersData)
		{
			IncludedCollidersData.Clear();
			for (int num2 = IncludedColliders2D.Count - 1; num2 >= 0; num2--)
			{
				if ((Object)(object)IncludedColliders2D[num2] == (Object)null)
				{
					IncludedColliders2D.RemoveAt(num2);
				}
				else
				{
					FImp_ColliderData_Base colliderDataFor2 = FImp_ColliderData_Base.GetColliderDataFor(IncludedColliders2D[num2]);
					IncludedCollidersData.Add(colliderDataFor2);
				}
			}
			flag = true;
		}
		if (flag)
		{
			forceRefreshCollidersData = false;
		}
	}

	public bool PushIfSegmentInsideCollider(TailSegment bone, ref Vector3 targetPoint)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (!CheapCollision)
		{
			for (int i = 0; i < CollidersDataToCheck.Count; i++)
			{
				bool flag2 = CollidersDataToCheck[i].PushIfInside(ref targetPoint, bone.GetRadiusScaled(), Vector3.zero);
				if (!flag && flag2)
				{
					flag = true;
					bone.LatestSelectiveCollision = CollidersDataToCheck[i];
				}
			}
		}
		else
		{
			for (int j = 0; j < CollidersDataToCheck.Count; j++)
			{
				if (CollidersDataToCheck[j].PushIfInside(ref targetPoint, bone.GetRadiusScaled(), Vector3.zero))
				{
					bone.LatestSelectiveCollision = CollidersDataToCheck[j];
					return true;
				}
			}
		}
		return flag;
	}

	protected float GetColliderSphereRadiusFor(int i)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		_ = TailSegments[i];
		float num = 1f;
		if (i >= _TransformsGhostChain.Count)
		{
			return num;
		}
		if (_TransformsGhostChain.Count > 1)
		{
			num = Vector3.Distance(_TransformsGhostChain[1].position, _TransformsGhostChain[0].position);
		}
		float num2 = num;
		if (i != 0)
		{
			num2 = Mathf.Lerp(num, Vector3.Distance(_TransformsGhostChain[i - 1].position, _TransformsGhostChain[i].position) * 0.5f, CollisionsAutoCurve);
		}
		float num3 = _TransformsGhostChain.Count - 1;
		if (num3 <= 0f)
		{
			num3 = 1f;
		}
		float num4 = 1f / num3;
		return 0.5f * num2 * CollidersScaleMul * CollidersScaleCurve.Evaluate(num4 * (float)i);
	}

	protected float GetColliderSphereRadiusFor(List<Transform> transforms, int i)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f;
		if (transforms.Count > 1)
		{
			num = Vector3.Distance(_TransformsGhostChain[1].position, _TransformsGhostChain[0].position);
		}
		float num2 = num;
		if (i != 0)
		{
			num2 = Vector3.Distance(_TransformsGhostChain[i - 1].position, _TransformsGhostChain[i].position);
		}
		float num3 = Mathf.Lerp(num, num2 * 0.5f, CollisionsAutoCurve);
		float num4 = 1f / (float)(transforms.Count - 1);
		return 0.5f * num3 * CollidersScaleMul * CollidersScaleCurve.Evaluate(num4 * (float)i);
	}

	public void AddCollider(Collider collider)
	{
		if (!IncludedColliders.Contains(collider))
		{
			IncludedColliders.Add(collider);
		}
	}

	public void AddCollider(Collider2D collider)
	{
		if (!IncludedColliders2D.Contains(collider))
		{
			IncludedColliders2D.Add(collider);
		}
	}

	public void CheckForColliderDuplicatesAndNulls()
	{
		for (int i = 0; i < IncludedColliders.Count; i++)
		{
			Collider col = IncludedColliders[i];
			if (IncludedColliders.Count((Collider o) => (Object)(object)o == (Object)(object)col) > 1)
			{
				IncludedColliders.RemoveAll((Collider o) => (Object)(object)o == (Object)(object)col);
				IncludedColliders.Add(col);
			}
		}
		for (int num = IncludedColliders.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)IncludedColliders[num] == (Object)null)
			{
				IncludedColliders.RemoveAt(num);
			}
		}
	}

	public void CheckForColliderDuplicatesAndNulls2D()
	{
		for (int i = 0; i < IncludedColliders2D.Count; i++)
		{
			Collider2D col = IncludedColliders2D[i];
			if (IncludedColliders2D.Count((Collider2D o) => (Object)(object)o == (Object)(object)col) > 1)
			{
				IncludedColliders2D.RemoveAll((Collider2D o) => (Object)(object)o == (Object)(object)col);
				IncludedColliders2D.Add(col);
			}
		}
	}

	private void TailCalculations_ComputeSegmentCollisions(TailSegment bone, ref Vector3 position)
	{
		if (bone.CollisionContactFlag)
		{
			bone.CollisionContactFlag = false;
		}
		else if (bone.CollisionContactRelevancy > 0f)
		{
			bone.CollisionContactRelevancy -= justDelta;
		}
		if (CollisionSpace == ECollisionSpace.Selective_Fast)
		{
			if (PushIfSegmentInsideCollider(bone, ref position))
			{
				bone.CollisionContactFlag = true;
				bone.CollisionContactRelevancy = justDelta * 7f;
				bone.ChildBone.CollisionContactRelevancy = Mathf.Max(bone.ChildBone.CollisionContactRelevancy, justDelta * 3.5f);
				if (bone.ChildBone.ChildBone != null)
				{
					bone.ChildBone.ChildBone.CollisionContactRelevancy = Mathf.Max(bone.ChildBone.CollisionContactRelevancy, justDelta * 3f);
				}
			}
		}
		else if (UseCollisionContact(bone.Index, ref position))
		{
			bone.CollisionContactFlag = true;
			bone.CollisionContactRelevancy = justDelta * 7f;
			bone.ChildBone.CollisionContactRelevancy = Mathf.Max(bone.ChildBone.CollisionContactRelevancy, justDelta * 3.5f);
			if (bone.ChildBone.ChildBone != null)
			{
				bone.ChildBone.ChildBone.CollisionContactRelevancy = Mathf.Max(bone.ChildBone.CollisionContactRelevancy, justDelta * 3f);
			}
		}
	}

	private void ExpertParamsUpdate()
	{
		Expert_UpdatePosSpeed();
		Expert_UpdateRotSpeed();
		Expert_UpdateSpringiness();
		Expert_UpdateSlithery();
		Expert_UpdateCurling();
		Expert_UpdateSlippery();
		Expert_UpdateBlending();
	}

	private void ExpertCurvesEndUpdate()
	{
		lastPosSpeeds = ReactionSpeed;
		if (!UsePosSpeedCurve && lastPosCurvKeys != null)
		{
			lastPosCurvKeys = null;
			lastPosSpeeds += 0.001f;
		}
		lastRotSpeeds = RotationRelevancy;
		if (!UseRotSpeedCurve && lastRotCurvKeys != null)
		{
			lastRotCurvKeys = null;
			lastRotSpeeds += 0.001f;
		}
		lastSpringiness = Springiness;
		if (!UseSpringCurve && lastSpringCurvKeys != null)
		{
			lastSpringCurvKeys = null;
			lastSpringiness += 0.001f;
		}
		lastSlithery = Slithery;
		if (!UseSlitheryCurve && lastSlitheryCurvKeys != null)
		{
			lastSlitheryCurvKeys = null;
			lastSlithery += 0.001f;
		}
		lastCurling = Curling;
		if (!UseCurlingCurve && lastCurlingCurvKeys != null)
		{
			lastCurlingCurvKeys = null;
			lastCurling += 0.001f;
		}
		lastSlippery = CollisionSlippery;
		if (!UseSlipperyCurve && lastSlipperyCurvKeys != null)
		{
			lastSlipperyCurvKeys = null;
			lastSlippery += 0.001f;
		}
		lastTailAnimatorAmount = TailAnimatorAmount;
		if (!UsePartialBlend && lastBlendCurvKeys != null)
		{
			lastBlendCurvKeys = null;
			lastTailAnimatorAmount += 0.001f;
		}
	}

	private void Expert_UpdatePosSpeed()
	{
		if (UsePosSpeedCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.PositionSpeed = PosCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastPosSpeeds != ReactionSpeed)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.PositionSpeed = ReactionSpeed;
			}
		}
	}

	private void Expert_UpdateRotSpeed()
	{
		if (UseRotSpeedCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.RotationSpeed = RotCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastRotSpeeds != RotationRelevancy)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.RotationSpeed = RotationRelevancy;
			}
		}
	}

	private void Expert_UpdateSpringiness()
	{
		if (UseSpringCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Springiness = SpringCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastSpringiness != Springiness)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Springiness = Springiness;
			}
		}
	}

	private void Expert_UpdateSlithery()
	{
		if (UseSlitheryCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Slithery = SlitheryCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastSlithery != Slithery)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Slithery = Slithery;
			}
		}
	}

	private void Expert_UpdateCurling()
	{
		if (UseCurlingCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Curling = CurlingCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastCurling != Curling)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Curling = Curling;
			}
		}
	}

	private void Expert_UpdateSlippery()
	{
		if (UseSlipperyCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Slippery = SlipperyCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastSlippery != CollisionSlippery)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Slippery = CollisionSlippery;
			}
		}
	}

	private void Expert_UpdateBlending()
	{
		if (UsePartialBlend)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.BlendValue = BlendCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastTailAnimatorAmount != TailAnimatorAmount)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.BlendValue = TailAnimatorAmount;
			}
		}
	}

	private void InitIK()
	{
		if (!IKSelectiveChain)
		{
			IK = new FIK_CCDProcessor(_TransformsGhostChain.ToArray());
		}
		else
		{
			List<Transform> list = new List<Transform>();
			if (IKLimitSettings.Count != _TransformsGhostChain.Count)
			{
				list = _TransformsGhostChain;
			}
			else
			{
				for (int i = 0; i < _TransformsGhostChain.Count; i++)
				{
					if (IKLimitSettings[i].UseInChain)
					{
						list.Add(_TransformsGhostChain[i]);
					}
				}
			}
			IK = new FIK_CCDProcessor(list.ToArray());
		}
		if (IKAutoWeights)
		{
			IK.AutoWeightBones(IKBaseReactionWeight);
		}
		else
		{
			IK.AutoWeightBones(IKReactionWeightCurve);
		}
		if (IKAutoAngleLimits)
		{
			IK.AutoLimitAngle(IKAutoAngleLimit, 4f + IKAutoAngleLimit / 15f);
		}
		if (!IKSelectiveChain)
		{
			IK.Init(_TransformsGhostChain[0]);
		}
		else
		{
			IK.Init(IK.Bones[0].transform);
		}
		ikInitialized = true;
		IK_ApplyLimitBoneSettings();
	}

	public void IKSetCustomPosition(Vector3? tgt)
	{
		_IKCustomPos = tgt;
	}

	private void UpdateIK()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		if (!ikInitialized)
		{
			InitIK();
		}
		if (IKBlend <= Mathf.Epsilon)
		{
			return;
		}
		if (_IKCustomPos.HasValue)
		{
			IK.IKTargetPosition = _IKCustomPos.Value;
		}
		else if ((Object)(object)IKTarget == (Object)null)
		{
			IK.IKTargetPosition = TailSegments[TailSegments.Count - 1].ProceduralPosition;
		}
		else
		{
			IK.IKTargetPosition = IKTarget.position;
		}
		IK.Invert = IkInvertOrder;
		IK.IKWeight = IKBlend;
		IK.SyncWithAnimator = IKAnimatorBlend;
		IK.ReactionQuality = IKReactionQuality;
		IK.Smoothing = IKSmoothing;
		IK.StretchToTarget = IKStretchToTarget;
		IK.StretchCurve = IKStretchCurve;
		IK.ContinousSolving = IKContinousSolve;
		if (IK.StretchToTarget > 0f)
		{
			IK.ContinousSolving = false;
		}
		if (Axis2D == 3)
		{
			IK.Use2D = true;
		}
		else
		{
			IK.Use2D = false;
		}
		IK.Update();
		if (DetachChildren)
		{
			TailSegment tailSegment = TailSegments[0];
			tailSegment = TailSegments[1];
			if (!IncludeParent)
			{
				tailSegment.RefreshKeyLocalPositionAndRotation(tailSegment.InitialLocalPosition, tailSegment.InitialLocalRotation);
				tailSegment = TailSegments[2];
			}
			while (tailSegment != GhostChild)
			{
				tailSegment.RefreshKeyLocalPositionAndRotation(tailSegment.InitialLocalPosition, tailSegment.InitialLocalRotation);
				tailSegment = tailSegment.ChildBone;
			}
		}
		else
		{
			for (TailSegment tailSegment2 = TailSegments[0]; tailSegment2 != GhostChild; tailSegment2 = tailSegment2.ChildBone)
			{
				tailSegment2.RefreshKeyLocalPositionAndRotation();
			}
		}
	}

	public void IK_ApplyLimitBoneSettings()
	{
		if (!IKAutoAngleLimits)
		{
			if (IKLimitSettings.Count != _TransformsGhostChain.Count)
			{
				IK_RefreshLimitSettingsContainer();
			}
			if (IK.IKBones.Length != IKLimitSettings.Count)
			{
				Debug.Log((object)"[TAIL ANIMATOR IK] Wrong IK bone count!");
				return;
			}
			if (!IKAutoAngleLimits)
			{
				for (int i = 0; i < IKLimitSettings.Count; i++)
				{
					IK.IKBones[i].AngleLimit = IKLimitSettings[i].AngleLimit;
					IK.IKBones[i].TwistAngleLimit = IKLimitSettings[i].TwistAngleLimit;
				}
			}
		}
		if (ikInitialized)
		{
			if (IKAutoWeights)
			{
				IK.AutoWeightBones(IKBaseReactionWeight);
			}
			else
			{
				IK.AutoWeightBones(IKReactionWeightCurve);
			}
		}
		if (IKAutoAngleLimits)
		{
			IK.AutoLimitAngle(IKAutoAngleLimit, 10f + IKAutoAngleLimit / 10f);
		}
	}

	public void IK_RefreshLimitSettingsContainer()
	{
		IKLimitSettings = new List<IKBoneSettings>();
		for (int i = 0; i < _TransformsGhostChain.Count; i++)
		{
			IKLimitSettings.Add(new IKBoneSettings());
		}
	}

	private bool PostProcessingNeeded()
	{
		if (Deflection > Mathf.Epsilon)
		{
			return true;
		}
		return false;
	}

	private void PostProcessing_Begin()
	{
		TailSegments_UpdateCoordsForRootBone(_pp_reference[_tc_startI]);
		if (Deflection > Mathf.Epsilon)
		{
			Deflection_BeginUpdate();
		}
	}

	private void PostProcessing_ReferenceUpdate()
	{
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		TailSegment tailSegment;
		for (tailSegment = _pp_reference[_tc_startI]; tailSegment != _pp_ref_lastChild; tailSegment = tailSegment.ChildBone)
		{
			tailSegment.ParamsFrom(TailSegments[tailSegment.Index]);
			TailSegment_PrepareVelocity(tailSegment);
		}
		TailSegment_PrepareMotionParameters(_pp_ref_lastChild);
		TailSegment_PrepareVelocity(_pp_ref_lastChild);
		tailSegment = _pp_reference[_tc_startII];
		if (!DetachChildren)
		{
			while (tailSegment != _pp_ref_lastChild)
			{
				TailSegment_PrepareRotation(tailSegment);
				TailSegment_BaseSwingProcessing(tailSegment);
				TailCalculations_SegmentPreProcessingStack(tailSegment);
				TailSegment_PreRotationPositionBlend(tailSegment);
				tailSegment = tailSegment.ChildBone;
			}
		}
		else
		{
			while (tailSegment != _pp_ref_lastChild)
			{
				TailSegment_PrepareRotationDetached(tailSegment);
				TailSegment_BaseSwingProcessing(tailSegment);
				TailCalculations_SegmentPreProcessingStack(tailSegment);
				TailSegment_PreRotationPositionBlend(tailSegment);
				tailSegment = tailSegment.ChildBone;
			}
		}
		TailCalculations_UpdateArtificialChildBone(_pp_ref_lastChild);
		for (tailSegment = _pp_reference[_tc_startII]; tailSegment != _pp_ref_lastChild; tailSegment = tailSegment.ChildBone)
		{
			TailCalculations_SegmentRotation(tailSegment, tailSegment.LastKeyframeLocalPosition);
		}
		TailCalculations_SegmentRotation(tailSegment, tailSegment.LastKeyframeLocalPosition);
		tailSegment.ParentBone.RefreshFinalRot(tailSegment.ParentBone.TrueTargetRotation);
	}

	private void ShapingParamsUpdate()
	{
		Shaping_UpdateCurving();
		Shaping_UpdateGravity();
		Shaping_UpdateLengthMultiplier();
	}

	private void Shaping_UpdateCurving()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		if (!Curving.QIsZero())
		{
			if (UseCurvingCurve)
			{
				for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
				{
					_ex_bone.Curving = Quaternion.LerpUnclamped(Quaternion.identity, Curving, CurvCurve.Evaluate(_ex_bone.IndexOverlLength));
				}
			}
			else if (!Curving.QIsSame(lastCurving))
			{
				for (int i = 0; i < TailSegments.Count; i++)
				{
					TailSegments[i].Curving = Curving;
				}
			}
		}
		else if (!Curving.QIsSame(lastCurving))
		{
			for (int j = 0; j < TailSegments.Count; j++)
			{
				TailSegments[j].Curving = Quaternion.identity;
			}
		}
	}

	private void Shaping_UpdateGravity()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		if (!Gravity.VIsZero())
		{
			if (UseGravityCurve)
			{
				for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
				{
					_ex_bone.Gravity = Gravity * 40f * GravityCurve.Evaluate(_ex_bone.IndexOverlLength);
				}
			}
			else if (!Gravity.VIsSame(lastGravity))
			{
				for (int i = 0; i < TailSegments.Count; i++)
				{
					TailSegments[i].Gravity = Gravity / 40f;
					TailSegment tailSegment = TailSegments[i];
					tailSegment.Gravity *= 1f + (float)TailSegments[i].Index / 2f * (1f - TailSegments[i].Slithery);
				}
			}
		}
		else if (!Gravity.VIsSame(lastGravity))
		{
			for (int j = 0; j < TailSegments.Count; j++)
			{
				TailSegments[j].Gravity = Vector3.zero;
				TailSegments[j].GravityLookOffset = Vector3.zero;
			}
		}
	}

	private void Shaping_UpdateLengthMultiplier()
	{
		if (UseLengthMulCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.LengthMultiplier = LengthMulCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastLengthMul != LengthMultiplier)
		{
			for (int i = 0; i < TailSegments.Count; i++)
			{
				TailSegments[i].LengthMultiplier = LengthMultiplier;
			}
		}
	}

	private void ShapingEndUpdate()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		lastCurving = Curving;
		if (!UseCurvingCurve && lastCurvingKeys != null)
		{
			lastCurvingKeys = null;
			lastCurving.x += 0.001f;
		}
		lastGravity = Gravity;
		if (!UseGravityCurve && lastGravityKeys != null)
		{
			lastGravityKeys = null;
			lastGravity.x += 0.001f;
		}
		lastLengthMul = LengthMultiplier;
		if (!UseLengthMulCurve && lastLengthKeys != null)
		{
			lastLengthKeys = null;
			lastLengthMul += 0.0001f;
		}
	}

	private void Waving_Initialize()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (FixedCycle == 0f)
		{
			_waving_waveTime = Random.Range(-MathF.PI, MathF.PI) * 100f;
			_waving_cosTime = Random.Range(-MathF.PI, MathF.PI) * 50f;
		}
		else
		{
			_waving_waveTime = FixedCycle;
			_waving_cosTime = FixedCycle;
		}
		_waving_sustain = Vector3.zero;
	}

	private void Waving_AutoSwingUpdate()
	{
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		_waving_waveTime += justDelta * (2f * WavingSpeed);
		if (WavingType == FEWavingType.Simple)
		{
			float num = Mathf.Sin(_waving_waveTime) * (30f * WavingRange);
			if (CosinusAdd)
			{
				_waving_cosTime += justDelta * (2.535f * WavingSpeed);
				num += Mathf.Cos(_waving_cosTime) * (27f * WavingRange);
			}
			WavingRotationOffset = Quaternion.Euler(num * WavingAxis * TailSegments[0].BlendValue);
		}
		else
		{
			float num2 = _waving_waveTime * 0.23f;
			float num3 = AlternateWave * -5f;
			float num4 = AlternateWave * 100f;
			float num5 = AlternateWave * 20f;
			float num6 = Mathf.PerlinNoise(num2, num3) * 2f - 1f;
			float num7 = Mathf.PerlinNoise(num4 + num2, num2 + num4) * 2f - 1f;
			float num8 = Mathf.PerlinNoise(num5, num2) * 2f - 1f;
			WavingRotationOffset = Quaternion.Euler(Vector3.Scale(WavingAxis * WavingRange * 35f * TailSegments[0].BlendValue, new Vector3(num6, num7, num8)));
		}
	}

	private void Waving_SustainUpdate()
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		TailSegment tailSegment = TailSegments[0];
		float num = _TC_TailLength / (float)TailSegments.Count;
		num = Mathf.Pow(num, 1.65f);
		num = _sg_curly / num / 6f;
		if (num < 0.1f)
		{
			num = 0.1f;
		}
		else if (num > 1f)
		{
			num = 1f;
		}
		int num2 = (int)Mathf.LerpUnclamped((float)TailSegments.Count * 0.4f, (float)TailSegments.Count * 0.6f, Sustain);
		float end = FEasing.EaseOutExpo(1f, 0.09f, Sustain);
		float num3 = 1.5f;
		num3 *= 1f - TailSegments[0].Curling / 8f;
		num3 *= 1.5f - num / 1.65f;
		num3 *= Mathf.Lerp(0.7f, 1.2f, tailSegment.Slithery);
		num3 *= FEasing.EaseOutExpo(1f, end, tailSegment.Springiness);
		Vector3 val = TailSegments[num2].PreviousPush;
		if (num2 + 1 < TailSegments.Count)
		{
			val += TailSegments[num2 + 1].PreviousPush;
		}
		if (num2 - 1 > TailSegments.Count)
		{
			val += TailSegments[num2 - 1].PreviousPush;
		}
		_waving_sustain = val * Sustain * num3 * 2f;
	}

	private void WindEffectUpdate()
	{
		if (Object.op_Implicit((Object)(object)TailAnimatorWind.Instance))
		{
			TailAnimatorWind.Instance.AffectTailWithWind(this);
		}
	}

	protected virtual void Init()
	{
		//IL_0571: Unknown result type (might be due to invalid IL or missing references)
		//IL_0576: Unknown result type (might be due to invalid IL or missing references)
		//IL_057c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0404: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0414: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0430: Unknown result type (might be due to invalid IL or missing references)
		//IL_0435: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0461: Unknown result type (might be due to invalid IL or missing references)
		//IL_0477: Unknown result type (might be due to invalid IL or missing references)
		//IL_047c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0488: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		if (initialized)
		{
			return;
		}
		if (_TransformsGhostChain == null || _TransformsGhostChain.Count == 0)
		{
			_TransformsGhostChain = new List<Transform>();
			GetGhostChain();
		}
		TailSegments = new List<TailSegment>();
		for (int i = 0; i < _TransformsGhostChain.Count; i++)
		{
			if ((Object)(object)_TransformsGhostChain[i] == (Object)null)
			{
				Debug.Log((object)("[Tail Animator] Null bones in " + ((Object)this).name + " !"));
				continue;
			}
			TailSegment tailSegment = new TailSegment(_TransformsGhostChain[i]);
			tailSegment.SetIndex(i, _TransformsGhostChain.Count);
			TailSegments.Add(tailSegment);
		}
		if (TailSegments.Count == 0)
		{
			Debug.Log((object)("[Tail Animator] Could not create tail bones chain in " + ((Object)this).name + " !"));
			return;
		}
		_TC_TailLength = 0f;
		_baseTransform = _TransformsGhostChain[0];
		for (int j = 0; j < TailSegments.Count; j++)
		{
			TailSegment tailSegment2 = TailSegments[j];
			TailSegment tailSegment3;
			if (j == 0)
			{
				if (Object.op_Implicit((Object)(object)tailSegment2.transform.parent))
				{
					tailSegment3 = new TailSegment(tailSegment2.transform.parent);
					tailSegment3.SetParentRef(new TailSegment(tailSegment3.transform.parent));
				}
				else
				{
					tailSegment3 = new TailSegment(tailSegment2.transform);
					Vector3 val;
					if (_TransformsGhostChain.Count > 1)
					{
						val = _TransformsGhostChain[0].position - _TransformsGhostChain[1].position;
						if (((Vector3)(ref val)).magnitude == 0f)
						{
							val = ((Component)this).transform.position - _TransformsGhostChain[1].position;
						}
					}
					else
					{
						val = tailSegment2.transform.position - _TransformsGhostChain[0].position;
					}
					if (((Vector3)(ref val)).magnitude == 0f)
					{
						val = ((Component)this).transform.position - _TransformsGhostChain[0].position;
					}
					if (((Vector3)(ref val)).magnitude == 0f)
					{
						val = ((Component)this).transform.forward;
					}
					tailSegment3.LocalOffset = tailSegment3.transform.InverseTransformPoint(tailSegment3.transform.position + val);
					tailSegment3.SetParentRef(new TailSegment(tailSegment2.transform));
				}
				GhostParent = tailSegment3;
				GhostParent.Validate();
				tailSegment2.SetParentRef(GhostParent);
			}
			else
			{
				tailSegment3 = TailSegments[j - 1];
				tailSegment2.ReInitializeLocalPosRot(tailSegment3.transform.InverseTransformPoint(tailSegment2.transform.position), tailSegment2.transform.localRotation);
			}
			if (j == TailSegments.Count - 1)
			{
				Transform transform = null;
				if (tailSegment2.transform.childCount > 0)
				{
					transform = tailSegment2.transform.GetChild(0);
				}
				GhostChild = new TailSegment(transform);
				Vector3 val2 = ((!EndBoneJointOffset.VIsZero()) ? tailSegment2.transform.TransformVector(EndBoneJointOffset) : (Object.op_Implicit((Object)(object)tailSegment2.transform.parent) ? (tailSegment2.transform.position - tailSegment2.transform.parent.position) : ((tailSegment2.transform.childCount <= 0) ? (tailSegment2.transform.TransformDirection(Vector3.forward) * 0.05f) : (tailSegment2.transform.GetChild(0).position - tailSegment2.transform.position))));
				GhostChild.ProceduralPosition = tailSegment2.transform.position + val2;
				GhostChild.ProceduralPositionWeightBlended = GhostChild.ProceduralPosition;
				GhostChild.PreviousPosition = GhostChild.ProceduralPosition;
				GhostChild.PosRefRotation = Quaternion.identity;
				GhostChild.PreviousPosReferenceRotation = Quaternion.identity;
				GhostChild.ReInitializeLocalPosRot(tailSegment2.transform.InverseTransformPoint(GhostChild.ProceduralPosition), Quaternion.identity);
				GhostChild.RefreshFinalPos(GhostChild.ProceduralPosition);
				GhostChild.RefreshFinalRot(GhostChild.PosRefRotation);
				GhostChild.TrueTargetRotation = GhostChild.PosRefRotation;
				tailSegment2.TrueTargetRotation = tailSegment2.transform.rotation;
				tailSegment2.SetChildRef(GhostChild);
				GhostChild.SetParentRef(tailSegment2);
			}
			else
			{
				tailSegment2.SetChildRef(TailSegments[j + 1]);
			}
			tailSegment2.SetParentRef(tailSegment3);
			_TC_TailLength += Vector3.Distance(tailSegment2.ProceduralPosition, tailSegment3.ProceduralPosition);
			if ((Object)(object)tailSegment2.transform != (Object)(object)_baseTransform)
			{
				tailSegment2.AssignDetachedRootCoords(BaseTransform);
			}
		}
		GhostParent.SetIndex(-1, TailSegments.Count);
		GhostChild.SetIndex(TailSegments.Count, TailSegments.Count);
		GhostParent.SetChildRef(TailSegments[0]);
		previousWorldPosition = BaseTransform.position;
		WavingRotationOffset = Quaternion.identity;
		if (CollidersDataToCheck == null)
		{
			CollidersDataToCheck = new List<FImp_ColliderData_Base>();
		}
		DynamicAlwaysInclude = new List<Component>();
		if (UseCollision)
		{
			SetupSphereColliders();
		}
		if (_defl_source == null)
		{
			_defl_source = new List<TailSegment>();
		}
		Waving_Initialize();
		if (DetachChildren)
		{
			DetachChildrenTransforms();
		}
		initialized = true;
		if (TailSegments.Count == 1 && (Object)(object)TailSegments[0].transform.parent == (Object)null)
		{
			Debug.Log((object)"[Tail Animator] Can't initialize one-bone length chain on bone which don't have any parent!");
			Debug.LogError((object)"[Tail Animator] Can't initialize one-bone length chain on bone which don't have any parent!");
			TailAnimatorAmount = 0f;
			initialized = false;
			return;
		}
		if (UseWind)
		{
			TailAnimatorWind.Refresh();
		}
		if (PostProcessingNeeded() && !_pp_initialized)
		{
			InitializePostProcessing();
		}
		if (!Prewarm)
		{
			return;
		}
		ShapingParamsUpdate();
		ExpertParamsUpdate();
		Update();
		LateUpdate();
		justDelta = rateDelta;
		secPeriodDelta = 1f;
		deltaForLerps = secPeriodDelta;
		rateDelta = 1f / 60f;
		CheckIfTailAnimatorShouldBeUpdated();
		if (updateTailAnimator)
		{
			int num = 60 + TailSegments.Count / 2;
			for (int k = 0; k < num; k++)
			{
				PreCalibrateBones();
				LateUpdate();
			}
		}
	}

	public void DetachChildrenTransforms()
	{
		int num = ((!IncludeParent) ? 1 : 0);
		for (int num2 = TailSegments.Count - 1; num2 >= num; num2--)
		{
			if (Object.op_Implicit((Object)(object)TailSegments[num2].transform))
			{
				TailSegments[num2].transform.DetachChildren();
			}
		}
	}

	private void InitializePostProcessing()
	{
		_pp_reference = new List<TailSegment>();
		_pp_ref_rootParent = new TailSegment(GhostParent);
		for (int i = 0; i < TailSegments.Count; i++)
		{
			TailSegment item = new TailSegment(TailSegments[i]);
			_pp_reference.Add(item);
		}
		_pp_ref_lastChild = new TailSegment(GhostChild);
		_pp_ref_rootParent.SetChildRef(_pp_reference[0]);
		_pp_ref_rootParent.SetParentRef(new TailSegment(GhostParent.ParentBone.transform));
		for (int j = 0; j < _pp_reference.Count; j++)
		{
			TailSegment tailSegment = _pp_reference[j];
			tailSegment.SetIndex(j, TailSegments.Count);
			if (j == 0)
			{
				tailSegment.SetParentRef(_pp_ref_rootParent);
				tailSegment.SetChildRef(_pp_reference[j + 1]);
			}
			else if (j == _pp_reference.Count - 1)
			{
				tailSegment.SetParentRef(_pp_reference[j - 1]);
				tailSegment.SetChildRef(_pp_ref_lastChild);
			}
			else
			{
				tailSegment.SetParentRef(_pp_reference[j - 1]);
				tailSegment.SetChildRef(_pp_reference[j + 1]);
			}
		}
		_pp_ref_lastChild.SetParentRef(_pp_reference[_pp_reference.Count - 1]);
		_pp_initialized = true;
	}

	protected void StretchingLimiting(TailSegment bone)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = bone.ParentBone.ProceduralPosition - bone.ProceduralPosition;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (!(magnitude > 0f))
		{
			return;
		}
		float num = bone.BoneLengthScaled + bone.BoneLengthScaled * 2.5f * MaxStretching;
		if (magnitude > num)
		{
			if (MaxStretching == 0f)
			{
				_limiting_limitPosition = bone.ProceduralPosition + val * ((magnitude - bone.BoneLengthScaled) / magnitude);
				bone.ProceduralPosition = _limiting_limitPosition;
				return;
			}
			_limiting_limitPosition = bone.ParentBone.ProceduralPosition - ((Vector3)(ref val)).normalized * num;
			float num2 = Mathf.InverseLerp(magnitude, 0f, num) + _limiting_stretchingHelperTooLong;
			if (num2 > 0.999f)
			{
				num2 = 0.99f;
			}
			if (ReactionSpeed < 0.5f)
			{
				num2 *= deltaForLerps * (10f + ReactionSpeed * 30f);
			}
			bone.ProceduralPosition = Vector3.Lerp(bone.ProceduralPosition, _limiting_limitPosition, num2);
			return;
		}
		num = bone.BoneLengthScaled + bone.BoneLengthScaled * 1.1f * MaxStretching;
		if (magnitude < num)
		{
			_limiting_limitPosition = bone.ProceduralPosition + val * ((magnitude - bone.BoneLengthScaled) / magnitude);
			if (MaxStretching == 0f)
			{
				bone.ProceduralPosition = _limiting_limitPosition;
			}
			else
			{
				bone.ProceduralPosition = Vector3.LerpUnclamped(bone.ProceduralPosition, _limiting_limitPosition, Mathf.InverseLerp(magnitude, 0f, num) + _limiting_stretchingHelperTooShort);
			}
		}
	}

	protected Vector3 AngleLimiting(TailSegment child, Vector3 targetPos)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		_limiting_limitPosition = targetPos;
		_limiting_angle_ToTargetRot = Quaternion.FromToRotation(child.ParentBone.transform.TransformDirection(child.LastKeyframeLocalPosition), targetPos - child.ParentBone.ProceduralPosition) * child.ParentBone.transform.rotation;
		_limiting_angle_targetInLocal = child.ParentBone.transform.rotation.QToLocal(_limiting_angle_ToTargetRot);
		float num2 = 0f;
		if (((Vector3)(ref AngleLimitAxis)).sqrMagnitude == 0f)
		{
			num2 = Quaternion.Angle(_limiting_angle_targetInLocal, child.LastKeyframeLocalRotation);
		}
		else
		{
			((Vector3)(ref AngleLimitAxis)).Normalize();
			Vector3 val;
			if (LimitAxisRange.x == LimitAxisRange.y)
			{
				val = Vector3.Scale(((Quaternion)(ref child.InitialLocalRotation)).eulerAngles, AngleLimitAxis);
				float magnitude = ((Vector3)(ref val)).magnitude;
				val = Vector3.Scale(((Quaternion)(ref _limiting_angle_targetInLocal)).eulerAngles, AngleLimitAxis);
				num2 = Mathf.DeltaAngle(magnitude, ((Vector3)(ref val)).magnitude);
				if (num2 < 0f)
				{
					num2 = 0f - num2;
				}
			}
			else
			{
				val = Vector3.Scale(((Quaternion)(ref child.InitialLocalRotation)).eulerAngles, AngleLimitAxis);
				float magnitude2 = ((Vector3)(ref val)).magnitude;
				val = Vector3.Scale(((Quaternion)(ref _limiting_angle_targetInLocal)).eulerAngles, AngleLimitAxis);
				num2 = Mathf.DeltaAngle(magnitude2, ((Vector3)(ref val)).magnitude);
				if (num2 > LimitAxisRange.x && num2 < LimitAxisRange.y)
				{
					num2 = 0f;
				}
				if (num2 < 0f)
				{
					num2 = 0f - num2;
				}
			}
		}
		if (num2 > AngleLimit)
		{
			float num3 = Mathf.Abs(Mathf.DeltaAngle(num2, AngleLimit));
			num = Mathf.InverseLerp(0f, AngleLimit, num3);
			if (LimitSmoothing > Mathf.Epsilon)
			{
				float num4 = Mathf.Lerp(55f, 15f, LimitSmoothing);
				_limiting_angle_newLocal = Quaternion.SlerpUnclamped(_limiting_angle_targetInLocal, child.LastKeyframeLocalRotation, deltaForLerps * num4 * num);
			}
			else
			{
				_limiting_angle_newLocal = Quaternion.SlerpUnclamped(_limiting_angle_targetInLocal, child.LastKeyframeLocalRotation, num);
			}
			_limiting_angle_ToTargetRot = child.ParentBone.transform.rotation.QToWorld(_limiting_angle_newLocal);
			_limiting_limitPosition = child.ParentBone.ProceduralPosition + _limiting_angle_ToTargetRot * Vector3.Scale(child.transform.lossyScale, child.LastKeyframeLocalPosition);
		}
		if (num > Mathf.Epsilon)
		{
			return _limiting_limitPosition;
		}
		return targetPos;
	}

	private void MotionInfluenceLimiting()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		if (MotionInfluence != 1f)
		{
			_limiting_influenceOffset = (BaseTransform.position - previousWorldPosition) * (1f - MotionInfluence);
			if (MotionInfluenceInY < 1f)
			{
				_limiting_influenceOffset.y = (BaseTransform.position.y - previousWorldPosition.y) * (1f - MotionInfluenceInY);
			}
			for (int i = 0; i < TailSegments.Count; i++)
			{
				TailSegment tailSegment = TailSegments[i];
				tailSegment.ProceduralPosition += _limiting_influenceOffset;
				TailSegment tailSegment2 = TailSegments[i];
				tailSegment2.PreviousPosition += _limiting_influenceOffset;
			}
			TailSegment ghostChild = GhostChild;
			ghostChild.ProceduralPosition += _limiting_influenceOffset;
			TailSegment ghostChild2 = GhostChild;
			ghostChild2.PreviousPosition += _limiting_influenceOffset;
		}
	}

	private void CalculateGravityPositionOffsetForSegment(TailSegment bone)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		_tc_segmentGravityOffset = (bone.Gravity + WindEffect) * bone.BoneLengthScaled;
		_tc_segmentGravityToParentDir = bone.ProceduralPosition - bone.ParentBone.ProceduralPosition;
		Vector3 val = _tc_segmentGravityToParentDir + _tc_segmentGravityOffset;
		_tc_preGravOff = ((Vector3)(ref val)).normalized * ((Vector3)(ref _tc_segmentGravityToParentDir)).magnitude;
		bone.ProceduralPosition = bone.ParentBone.ProceduralPosition + _tc_preGravOff;
	}

	private void Axis2DLimit(TailSegment child)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		child.ProceduralPosition -= child.ParentBone.transform.VAxis2DLimit(child.ParentBone.ProceduralPosition, child.ProceduralPosition, Axis2D);
	}

	public float GetDistanceMeasure(Vector3 targetPosition)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (DistanceWithoutY)
		{
			Vector3 val = BaseTransform.position + BaseTransform.TransformVector(DistanceMeasurePoint);
			return Vector2.Distance(new Vector2(val.x, val.z), new Vector2(targetPosition.x, targetPosition.z));
		}
		return Vector3.Distance(BaseTransform.position + BaseTransform.TransformVector(DistanceMeasurePoint), targetPosition);
	}

	private void MaxDistanceCalculations()
	{
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)DistanceFrom != (Object)null)
		{
			finalDistanceFrom = DistanceFrom;
		}
		else if ((Object)(object)finalDistanceFrom == (Object)null)
		{
			if ((Object)(object)_distanceFrom_Auto == (Object)null)
			{
				Camera main = Camera.main;
				if (Object.op_Implicit((Object)(object)main))
				{
					_distanceFrom_Auto = ((Component)main).transform;
				}
				else if (!wasCameraSearch)
				{
					main = Object.FindObjectOfType<Camera>();
					if (Object.op_Implicit((Object)(object)main))
					{
						_distanceFrom_Auto = ((Component)main).transform;
					}
					wasCameraSearch = true;
				}
			}
			finalDistanceFrom = _distanceFrom_Auto;
		}
		if (MaximumDistance > 0f && (Object)(object)finalDistanceFrom != (Object)null)
		{
			if (!maxDistanceExceed)
			{
				if (GetDistanceMeasure(finalDistanceFrom.position) > MaximumDistance + MaximumDistance * MaxOutDistanceFactor)
				{
					maxDistanceExceed = true;
				}
				distanceWeight += Time.unscaledDeltaTime * (1f / FadeDuration);
				if (distanceWeight > 1f)
				{
					distanceWeight = 1f;
				}
			}
			else
			{
				if (GetDistanceMeasure(finalDistanceFrom.position) <= MaximumDistance)
				{
					maxDistanceExceed = false;
				}
				distanceWeight -= Time.unscaledDeltaTime * (1f / FadeDuration);
				if (distanceWeight < 0f)
				{
					distanceWeight = 0f;
				}
			}
		}
		else
		{
			maxDistanceExceed = false;
			distanceWeight = 1f;
		}
	}

	private Vector3 TailCalculations_SmoothPosition(Vector3 from, Vector3 to, TailSegment bone)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (SmoothingStyle == EAnimationStyle.Accelerating)
		{
			return TailCalculations_SmoothPositionSmoothDamp(from, to, ref bone.VelocityHelper, bone.PositionSpeed);
		}
		if (SmoothingStyle == EAnimationStyle.Quick)
		{
			return TailCalculations_SmoothPositionLerp(from, to, bone.PositionSpeed);
		}
		return TailCalculations_SmoothPositionLinear(from, to, bone.PositionSpeed);
	}

	private Vector3 TailCalculations_SmoothPositionLerp(Vector3 from, Vector3 to, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Lerp(from, to, secPeriodDelta * speed);
	}

	private Vector3 TailCalculations_SmoothPositionSmoothDamp(Vector3 from, Vector3 to, ref Vector3 velo, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.SmoothDamp(from, to, ref velo, Mathf.LerpUnclamped(0.08f, 0.0001f, Mathf.Sqrt(Mathf.Sqrt(speed))), float.PositiveInfinity, rateDelta);
	}

	private Vector3 TailCalculations_SmoothPositionLinear(Vector3 from, Vector3 to, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.MoveTowards(from, to, deltaForLerps * speed * 45f);
	}

	private Quaternion TailCalculations_SmoothRotation(Quaternion from, Quaternion to, TailSegment bone)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (SmoothingStyle == EAnimationStyle.Accelerating)
		{
			return TailCalculations_SmoothRotationSmoothDamp(from, to, ref bone.QVelocityHelper, bone.RotationSpeed);
		}
		if (SmoothingStyle == EAnimationStyle.Quick)
		{
			return TailCalculations_SmoothRotationLerp(from, to, bone.RotationSpeed);
		}
		return TailCalculations_SmoothRotationLinear(from, to, bone.RotationSpeed);
	}

	private Quaternion TailCalculations_SmoothRotationLerp(Quaternion from, Quaternion to, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Lerp(from, to, secPeriodDelta * speed);
	}

	private Quaternion TailCalculations_SmoothRotationSmoothDamp(Quaternion from, Quaternion to, ref Quaternion velo, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		return from.SmoothDampRotation(to, ref velo, Mathf.LerpUnclamped(0.25f, 0.0001f, Mathf.Sqrt(Mathf.Sqrt(speed))), rateDelta);
	}

	private Quaternion TailCalculations_SmoothRotationLinear(Quaternion from, Quaternion to, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.RotateTowards(from, to, speed * deltaForLerps * 1600f);
	}

	private void TailCalculations_Begin()
	{
		if (IncludeParent)
		{
			_tc_startI = 0;
			_tc_rootBone = TailSegments[0];
		}
		else
		{
			_tc_startI = 1;
			if (TailSegments.Count > 1)
			{
				_tc_rootBone = TailSegments[1];
			}
			else
			{
				_tc_rootBone = TailSegments[0];
				_tc_startI = -1;
			}
		}
		_tc_startII = _tc_startI + 1;
		if (_tc_startII > TailSegments.Count - 1)
		{
			_tc_startII = -1;
		}
		if (Deflection > Mathf.Epsilon && !_pp_initialized)
		{
			InitializePostProcessing();
		}
		if (Tangle < 0f)
		{
			_tc_tangle = Mathf.LerpUnclamped(1f, 1.5f, Tangle + 1f);
		}
		else
		{
			_tc_tangle = Mathf.LerpUnclamped(1f, -4f, Tangle);
		}
	}

	private void TailSegments_UpdateRootFeatures()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (UseWaving)
		{
			Waving_AutoSwingUpdate();
			_tc_startBoneRotOffset = WavingRotationOffset * RotationOffset;
		}
		else
		{
			_tc_startBoneRotOffset = RotationOffset;
		}
		if (Sustain > Mathf.Epsilon)
		{
			Waving_SustainUpdate();
		}
		if (PostProcessingNeeded())
		{
			PostProcessing_Begin();
		}
	}

	private void TailCalculations_SegmentPreProcessingStack(TailSegment child)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		if (!UseCollision)
		{
			if (AngleLimit < 181f)
			{
				child.ProceduralPosition = AngleLimiting(child, child.ProceduralPosition);
			}
			if (child.PositionSpeed < 1f)
			{
				child.ProceduralPosition = TailCalculations_SmoothPosition(child.PreviousPosition, child.ProceduralPosition, child);
			}
		}
		else
		{
			if (child.PositionSpeed < 1f)
			{
				child.ProceduralPosition = TailCalculations_SmoothPosition(child.PreviousPosition, child.ProceduralPosition, child);
			}
			TailCalculations_ComputeSegmentCollisions(child, ref child.ProceduralPosition);
			if (AngleLimit < 181f)
			{
				child.ProceduralPosition = AngleLimiting(child, child.ProceduralPosition);
			}
		}
		if (MaxStretching < 1f)
		{
			StretchingLimiting(child);
		}
		if (!child.Gravity.VIsZero() || UseWind)
		{
			CalculateGravityPositionOffsetForSegment(child);
		}
		if (Axis2D > 0)
		{
			Axis2DLimit(child);
		}
	}

	private void TailCalculations_SegmentPostProcessing(TailSegment bone)
	{
		if (Deflection > Mathf.Epsilon)
		{
			Deflection_SegmentOffsetSimple(bone, ref bone.ProceduralPosition);
		}
	}

	private void TailCalculations_SegmentRotation(TailSegment child, Vector3 localOffset)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		_tc_lookRot = Quaternion.FromToRotation(child.ParentBone.transform.TransformDirection(localOffset), child.ProceduralPositionWeightBlended - child.ParentBone.ProceduralPositionWeightBlended);
		_tc_targetParentRot = _tc_lookRot * child.ParentBone.transform.rotation;
		if (AnimateRoll)
		{
			_tc_targetParentRot = Quaternion.Lerp(child.ParentBone.TrueTargetRotation, _tc_targetParentRot, deltaForLerps * Mathf.LerpUnclamped(10f, 60f, child.RotationSpeed));
		}
		child.ParentBone.TrueTargetRotation = _tc_targetParentRot;
		child.ParentBone.PreviousPosReferenceRotation = child.ParentBone.PosRefRotation;
		if (!AnimateRoll && child.RotationSpeed < 1f)
		{
			_tc_targetParentRot = TailCalculations_SmoothRotation(child.ParentBone.PosRefRotation, _tc_targetParentRot, child);
		}
		child.ParentBone.PosRefRotation = _tc_targetParentRot;
	}

	private void TailCalculations_SegmentRotationDetached(TailSegment child, Vector3 localOffset)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		_tc_lookRot = Quaternion.FromToRotation(child.ParentBone.transform.TransformDirection(localOffset), child.ProceduralPositionWeightBlended - child.ParentBone.ProceduralPositionWeightBlended);
		_tc_targetParentRot = _tc_lookRot * child.transform.rotation;
		if (AnimateRoll)
		{
			_tc_targetParentRot = Quaternion.Lerp(child.ParentBone.TrueTargetRotation, _tc_targetParentRot, deltaForLerps * Mathf.LerpUnclamped(10f, 60f, child.RotationSpeed));
		}
		child.ParentBone.TrueTargetRotation = _tc_targetParentRot;
		child.ParentBone.PreviousPosReferenceRotation = child.ParentBone.PosRefRotation;
		if (!AnimateRoll && child.RotationSpeed < 1f)
		{
			_tc_targetParentRot = TailCalculations_SmoothRotation(child.ParentBone.PosRefRotation, _tc_targetParentRot, child);
		}
		child.ParentBone.PosRefRotation = _tc_targetParentRot;
	}

	private void TailCalculations_ApplySegmentMotion(TailSegment child)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		child.ParentBone.transform.rotation = child.ParentBone.TrueTargetRotation;
		child.transform.position = child.ProceduralPositionWeightBlended;
		child.RefreshFinalPos(child.ProceduralPositionWeightBlended);
		child.ParentBone.RefreshFinalRot(child.ParentBone.TrueTargetRotation);
	}

	private void TailSegment_PrepareBoneLength(TailSegment child)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		child.BoneDimensionsScaled = Vector3.Scale(child.ParentBone.transform.lossyScale * child.LengthMultiplier, child.LastKeyframeLocalPosition);
		child.BoneLengthScaled = ((Vector3)(ref child.BoneDimensionsScaled)).magnitude;
	}

	private void TailSegment_PrepareMotionParameters(TailSegment child)
	{
		_sg_curly = Mathf.LerpUnclamped(0.5f, 0.125f, child.Curling);
		_sg_springVelo = Mathf.LerpUnclamped(0.65f, 0.9f, child.Springiness);
		_sg_curly = Mathf.Lerp(_sg_curly, Mathf.LerpUnclamped(0.95f, 0.135f, child.Curling), child.Slithery);
		_sg_springVelo = Mathf.Lerp(_sg_springVelo, Mathf.LerpUnclamped(0.1f, 0.85f, child.Springiness), child.Slithery);
	}

	private void TailSegment_PrepareVelocity(TailSegment child)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		_sg_push = child.ProceduralPosition - child.PreviousPosition;
		child.PreviousPosition = child.ProceduralPosition;
		float num = _sg_springVelo;
		if (child.CollisionContactFlag)
		{
			num *= child.Slippery;
		}
		child.ProceduralPosition += _sg_push * num;
		child.PreviousPush = _sg_push;
	}

	private void TailSegment_PrepareRotation(TailSegment child)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		_sg_targetChildWorldPosInParentFront = child.ParentBone.ProceduralPosition + TailSegment_GetSwingRotation(child, _sg_slitFactor) * child.BoneDimensionsScaled;
	}

	private void TailSegment_PrepareRotationDetached(TailSegment child)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		_sg_targetChildWorldPosInParentFront = child.ParentBone.ProceduralPosition + TailSegment_GetSwingRotationDetached(child, _sg_slitFactor) * child.BoneDimensionsScaled;
	}

	private void TailSegment_BaseSwingProcessing(TailSegment child)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		_sg_slitFactor = child.Slithery;
		if (child.CollisionContactRelevancy > 0f)
		{
			_sg_slitFactor = ReflectCollision;
		}
		_sg_dirToTargetParentFront = _sg_targetChildWorldPosInParentFront - child.ProceduralPosition;
		if (UnifyBendiness > 0f)
		{
			child.ProceduralPosition += _sg_dirToTargetParentFront * secPeriodDelta * _sg_curly * TailSegment_GetUnifiedBendinessMultiplier(child);
		}
		else
		{
			child.ProceduralPosition += _sg_dirToTargetParentFront * _sg_curly * secPeriodDelta;
		}
		if (Tangle != 0f && child.Slithery >= 1f)
		{
			child.ProceduralPosition = Vector3.LerpUnclamped(child.ProceduralPosition, _sg_targetChildWorldPosInParentFront, _tc_tangle);
		}
	}

	private void TailSegment_PreRotationPositionBlend(TailSegment child)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (child.BlendValue * conditionalWeight < 1f)
		{
			child.ProceduralPositionWeightBlended = Vector3.LerpUnclamped(child.transform.position, child.ProceduralPosition, child.BlendValue * conditionalWeight);
		}
		else
		{
			child.ProceduralPositionWeightBlended = child.ProceduralPosition;
		}
	}

	private Quaternion TailSegment_RotationSlithery(TailSegment child)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (!child.Curving.QIsZero())
		{
			return GetSlitheryReferenceRotation(child) * child.Curving * child.ParentBone.LastKeyframeLocalRotation;
		}
		return GetSlitheryReferenceRotation(child) * child.ParentBone.LastKeyframeLocalRotation;
	}

	private Quaternion TailSegment_RotationSlitheryDetached(TailSegment child)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (!child.Curving.QIsZero())
		{
			return GetSlitheryReferenceRotation(child) * child.Curving * child.ParentBone.InitialLocalRotation;
		}
		return GetSlitheryReferenceRotation(child) * child.ParentBone.InitialLocalRotation;
	}

	private Quaternion GetSlitheryReferenceRotation(TailSegment child)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (child.Slithery <= 1f)
		{
			return child.ParentBone.ParentBone.PosRefRotation;
		}
		return Quaternion.LerpUnclamped(child.ParentBone.ParentBone.PosRefRotation, child.ParentBone.ParentBone.PreviousPosReferenceRotation, (child.Slithery - 1f) * 5f);
	}

	private Quaternion TailSegment_RotationStiff(TailSegment child)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (!child.Curving.QIsZero())
		{
			return child.ParentBone.transform.rotation * MultiplyQ(child.Curving, (float)child.Index * 2f);
		}
		return child.ParentBone.transform.rotation;
	}

	private Quaternion TailSegment_GetSwingRotation(TailSegment child, float curlFactor)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (curlFactor >= 1f)
		{
			return TailSegment_RotationSlithery(child);
		}
		if (curlFactor > Mathf.Epsilon)
		{
			return Quaternion.LerpUnclamped(TailSegment_RotationStiff(child), TailSegment_RotationSlithery(child), curlFactor);
		}
		return TailSegment_RotationStiff(child);
	}

	private Quaternion TailSegment_GetSwingRotationDetached(TailSegment child, float curlFactor)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (curlFactor >= 1f)
		{
			return TailSegment_RotationSlitheryDetached(child);
		}
		if (curlFactor > Mathf.Epsilon)
		{
			return Quaternion.LerpUnclamped(TailSegment_RotationStiff(child), TailSegment_RotationSlitheryDetached(child), curlFactor);
		}
		return TailSegment_RotationStiff(child);
	}

	private float TailSegment_GetUnifiedBendinessMultiplier(TailSegment child)
	{
		float num = child.BoneLength / _TC_TailLength;
		num = Mathf.Pow(num, 0.5f);
		if (num == 0f)
		{
			num = 1f;
		}
		float num2 = _sg_curly / num / 2f;
		num2 = Mathf.LerpUnclamped(_sg_curly, num2, UnifyBendiness);
		if (num2 < 0.15f)
		{
			num2 = 0.15f;
		}
		else if (num2 > 1.4f)
		{
			num2 = 1.4f;
		}
		return num2;
	}

	public void TailSegments_UpdateCoordsForRootBone(TailSegment parent)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		TailSegment tailSegment = TailSegments[0];
		tailSegment.transform.localRotation = tailSegment.LastKeyframeLocalRotation * _tc_startBoneRotOffset;
		parent.PreviousPosReferenceRotation = parent.PosRefRotation;
		parent.PosRefRotation = parent.transform.rotation;
		parent.PreviousPosition = parent.ProceduralPosition;
		parent.ProceduralPosition = parent.transform.position;
		if (DetachChildren)
		{
			tailSegment.TrueTargetRotation = tailSegment.transform.rotation;
		}
		parent.RefreshFinalPos(parent.transform.position);
		parent.ProceduralPositionWeightBlended = parent.ProceduralPosition;
		if ((Object)(object)parent.ParentBone.transform != (Object)null)
		{
			parent.ParentBone.PreviousPosReferenceRotation = parent.ParentBone.PosRefRotation;
			parent.ParentBone.PreviousPosition = parent.ParentBone.ProceduralPosition;
			parent.ParentBone.ProceduralPosition = parent.ParentBone.transform.position;
			parent.ParentBone.PosRefRotation = parent.ParentBone.transform.rotation;
			parent.ParentBone.ProceduralPositionWeightBlended = parent.ParentBone.ProceduralPosition;
		}
		TailSegment childBone = TailSegments[_tc_startI].ChildBone;
		childBone.PreviousPosition += _waving_sustain;
		tailSegment.RefreshKeyLocalPosition();
	}

	public void TailCalculations_UpdateArtificialChildBone(TailSegment child)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		if (DetachChildren)
		{
			TailSegment_PrepareRotationDetached(child);
		}
		else
		{
			TailSegment_PrepareRotation(child);
		}
		TailSegment_BaseSwingProcessing(child);
		if (child.PositionSpeed < 1f)
		{
			child.ProceduralPosition = TailCalculations_SmoothPosition(child.PreviousPosition, child.ProceduralPosition, child);
		}
		if (MaxStretching < 1f)
		{
			StretchingLimiting(child);
		}
		if (!child.Gravity.VIsZero() || UseWind)
		{
			CalculateGravityPositionOffsetForSegment(child);
		}
		if (Axis2D > 0)
		{
			Axis2DLimit(child);
		}
		child.CollisionContactRelevancy = -1f;
		if (child.BlendValue * conditionalWeight < 1f)
		{
			child.ProceduralPositionWeightBlended = Vector3.LerpUnclamped(child.ParentBone.transform.TransformPoint(child.LastKeyframeLocalPosition), child.ProceduralPosition, child.BlendValue * conditionalWeight);
		}
		else
		{
			child.ProceduralPositionWeightBlended = child.ProceduralPosition;
		}
	}

	public void Editor_TailCalculations_RefreshArtificialParentBone()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		GhostParent.ProceduralPosition = GhostParent.transform.position + GhostParent.transform.rotation.TransformVector(GhostParent.transform.lossyScale, GhostParent.LocalOffset);
	}

	private void SimulateTailMotionFrame(bool pp)
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		TailSegments_UpdateRootFeatures();
		TailSegments_UpdateCoordsForRootBone(_tc_rootBone);
		if (pp)
		{
			PostProcessing_ReferenceUpdate();
		}
		if (_tc_startI > -1)
		{
			TailSegment tailSegment = TailSegments[_tc_startI];
			if (!DetachChildren)
			{
				while (tailSegment != GhostChild)
				{
					tailSegment.BoneDimensionsScaled = Vector3.Scale(tailSegment.ParentBone.transform.lossyScale * tailSegment.LengthMultiplier, tailSegment.LastKeyframeLocalPosition);
					tailSegment.BoneLengthScaled = ((Vector3)(ref tailSegment.BoneDimensionsScaled)).magnitude;
					TailSegment_PrepareBoneLength(tailSegment);
					TailSegment_PrepareMotionParameters(tailSegment);
					TailSegment_PrepareVelocity(tailSegment);
					tailSegment = tailSegment.ChildBone;
				}
			}
			else
			{
				while (tailSegment != GhostChild)
				{
					tailSegment.BoneDimensionsScaled = Vector3.Scale(tailSegment.ParentBone.transform.lossyScale * tailSegment.LengthMultiplier, tailSegment.InitialLocalPosition);
					tailSegment.BoneLengthScaled = ((Vector3)(ref tailSegment.BoneDimensionsScaled)).magnitude;
					TailSegment_PrepareMotionParameters(tailSegment);
					TailSegment_PrepareVelocity(tailSegment);
					tailSegment = tailSegment.ChildBone;
				}
			}
		}
		TailSegment_PrepareBoneLength(GhostChild);
		TailSegment_PrepareMotionParameters(GhostChild);
		TailSegment_PrepareVelocity(GhostChild);
		if (_tc_startII > -1)
		{
			TailSegment tailSegment2 = TailSegments[_tc_startII];
			if (!DetachChildren)
			{
				while (tailSegment2 != GhostChild)
				{
					TailSegment_PrepareRotation(tailSegment2);
					TailSegment_BaseSwingProcessing(tailSegment2);
					TailCalculations_SegmentPreProcessingStack(tailSegment2);
					if (pp)
					{
						TailCalculations_SegmentPostProcessing(tailSegment2);
					}
					TailSegment_PreRotationPositionBlend(tailSegment2);
					tailSegment2 = tailSegment2.ChildBone;
				}
			}
			else
			{
				while (tailSegment2 != GhostChild)
				{
					TailSegment_PrepareRotationDetached(tailSegment2);
					TailSegment_BaseSwingProcessing(tailSegment2);
					TailCalculations_SegmentPreProcessingStack(tailSegment2);
					if (pp)
					{
						TailCalculations_SegmentPostProcessing(tailSegment2);
					}
					TailSegment_PreRotationPositionBlend(tailSegment2);
					tailSegment2 = tailSegment2.ChildBone;
				}
			}
		}
		TailCalculations_UpdateArtificialChildBone(GhostChild);
	}

	private void UpdateTailAlgorithm()
	{
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		TailCalculations_Begin();
		if (framesToSimulate != 0)
		{
			if (UseCollision)
			{
				BeginCollisionsUpdate();
			}
			bool pp = PostProcessingNeeded();
			MotionInfluenceLimiting();
			for (int i = 0; i < framesToSimulate; i++)
			{
				SimulateTailMotionFrame(pp);
			}
			TailSegments[_tc_startI].transform.position = TailSegments[_tc_startI].ProceduralPositionWeightBlended;
			TailSegments[_tc_startI].RefreshFinalPos(TailSegments[_tc_startI].ProceduralPositionWeightBlended);
			if (!DetachChildren)
			{
				if (_tc_startII > -1)
				{
					for (TailSegment tailSegment = TailSegments[_tc_startII]; tailSegment != GhostChild; tailSegment = tailSegment.ChildBone)
					{
						TailCalculations_SegmentRotation(tailSegment, tailSegment.LastKeyframeLocalPosition);
						TailCalculations_ApplySegmentMotion(tailSegment);
					}
				}
			}
			else if (_tc_startII > -1)
			{
				for (TailSegment tailSegment2 = TailSegments[_tc_startII]; tailSegment2 != GhostChild; tailSegment2 = tailSegment2.ChildBone)
				{
					TailCalculations_SegmentRotation(tailSegment2, tailSegment2.InitialLocalPosition);
					TailCalculations_ApplySegmentMotion(tailSegment2);
				}
			}
			TailCalculations_SegmentRotation(GhostChild, GhostChild.LastKeyframeLocalPosition);
			GhostChild.ParentBone.transform.rotation = GhostChild.ParentBone.TrueTargetRotation;
			GhostChild.ParentBone.RefreshFinalRot(GhostChild.ParentBone.TrueTargetRotation);
			if (Object.op_Implicit((Object)(object)GhostChild.transform))
			{
				GhostChild.RefreshFinalPos(GhostChild.transform.position);
				GhostChild.RefreshFinalRot(GhostChild.transform.rotation);
			}
		}
		else if (InterpolateRate)
		{
			secPeriodDelta = rateDelta / 24f;
			deltaForLerps = secPeriodDelta;
			SimulateTailMotionFrame(PostProcessingNeeded());
			if (_tc_startII > -1)
			{
				for (TailSegment tailSegment3 = TailSegments[_tc_startII]; tailSegment3 != GhostChild; tailSegment3 = tailSegment3.ChildBone)
				{
					TailCalculations_SegmentRotation(tailSegment3, tailSegment3.LastKeyframeLocalPosition);
					TailCalculations_ApplySegmentMotion(tailSegment3);
				}
			}
			TailCalculations_SegmentRotation(GhostChild, GhostChild.LastKeyframeLocalPosition);
			GhostChild.ParentBone.transform.rotation = GhostChild.ParentBone.TrueTargetRotation;
			GhostChild.ParentBone.RefreshFinalRot(GhostChild.ParentBone.TrueTargetRotation);
		}
		else if (_tc_startI > -1)
		{
			TailSegment tailSegment4 = TailSegments[_tc_startI];
			while (tailSegment4 != null && Object.op_Implicit((Object)(object)tailSegment4.transform))
			{
				tailSegment4.transform.position = tailSegment4.LastFinalPosition;
				tailSegment4.transform.rotation = tailSegment4.LastFinalRotation;
				tailSegment4 = tailSegment4.ChildBone;
			}
		}
	}

	private void CheckIfTailAnimatorShouldBeUpdated()
	{
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			if (StartAfterTPose)
			{
				startAfterTPoseCounter++;
				if (startAfterTPoseCounter > 6)
				{
					Init();
				}
			}
			updateTailAnimator = false;
			return;
		}
		if (UseMaxDistance)
		{
			MaxDistanceCalculations();
			conditionalWeight = OverrideWeight * distanceWeight;
		}
		else
		{
			conditionalWeight = OverrideWeight;
		}
		if (_forceDisable)
		{
			if (FadeDuration > 0f)
			{
				_forceDisableElapsed += Time.unscaledDeltaTime * (1f / FadeDuration);
				if (_forceDisableElapsed > 1f)
				{
					_forceDisableElapsed = 1f;
				}
			}
			else
			{
				_forceDisableElapsed = 1f;
			}
			conditionalWeight *= 1f - _forceDisableElapsed;
		}
		else if (_forceDisableElapsed > 0f && FadeDuration > 0f)
		{
			_forceDisableElapsed -= Time.unscaledDeltaTime * (1f / FadeDuration);
			if (_forceDisableElapsed < 0f)
			{
				_forceDisableElapsed = 0f;
			}
			conditionalWeight *= 1f - _forceDisableElapsed;
		}
		if (DisabledByInvisibility())
		{
			return;
		}
		if (UseCollision && !collisionInitialized)
		{
			SetupSphereColliders();
		}
		if (TailSegments.Count == 0)
		{
			Debug.LogError((object)("[TAIL ANIMATOR] No tail bones defined in " + ((Object)this).name + " !"));
			initialized = false;
			updateTailAnimator = false;
			return;
		}
		if (TailAnimatorAmount * conditionalWeight <= Mathf.Epsilon)
		{
			wasDisabled = true;
			updateTailAnimator = false;
			return;
		}
		if (wasDisabled)
		{
			User_ReposeTail();
			previousWorldPosition = ((Component)this).transform.position;
			wasDisabled = false;
		}
		if (IncludeParent && TailSegments.Count > 0 && !Object.op_Implicit((Object)(object)TailSegments[0].transform.parent))
		{
			IncludeParent = false;
		}
		if (TailSegments.Count < 1)
		{
			updateTailAnimator = false;
		}
		else
		{
			updateTailAnimator = true;
		}
	}

	public bool DisabledByInvisibility()
	{
		if ((Object)(object)OptimizeWithMesh != (Object)null)
		{
			bool flag = false;
			if (OptimizeWithMesh.isVisible)
			{
				flag = true;
			}
			else if (OptimizeWithMeshes != null && OptimizeWithMeshes.Length != 0)
			{
				for (int i = 0; i < OptimizeWithMeshes.Length; i++)
				{
					if (!((Object)(object)OptimizeWithMeshes[i] == (Object)null) && OptimizeWithMeshes[i].isVisible)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				updateTailAnimator = false;
				return true;
			}
		}
		return false;
	}

	private void DeltaTimeCalculations()
	{
		if (UpdateRate > 0)
		{
			switch (DeltaType)
			{
			case EFDeltaType.DeltaTime:
			case EFDeltaType.SafeDelta:
				justDelta = Time.deltaTime / Mathf.Clamp(Time.timeScale, 0.01f, 1f);
				break;
			case EFDeltaType.SmoothDeltaTime:
				justDelta = Time.smoothDeltaTime;
				break;
			case EFDeltaType.UnscaledDeltaTime:
				justDelta = Time.unscaledDeltaTime;
				break;
			case EFDeltaType.FixedDeltaTime:
				justDelta = Time.fixedDeltaTime;
				break;
			}
			justDelta *= TimeScale;
			secPeriodDelta = 1f;
			deltaForLerps = secPeriodDelta;
			rateDelta = 1f / (float)UpdateRate;
			StableUpdateRateCalculations();
			return;
		}
		switch (DeltaType)
		{
		case EFDeltaType.SafeDelta:
			justDelta = Mathf.Lerp(justDelta, GetClampedSmoothDelta(), 0.075f);
			break;
		case EFDeltaType.DeltaTime:
			justDelta = Time.deltaTime;
			break;
		case EFDeltaType.SmoothDeltaTime:
			justDelta = Time.smoothDeltaTime;
			break;
		case EFDeltaType.UnscaledDeltaTime:
			justDelta = Time.unscaledDeltaTime;
			break;
		case EFDeltaType.FixedDeltaTime:
			justDelta = Time.fixedDeltaTime;
			break;
		}
		rateDelta = justDelta;
		deltaForLerps = Mathf.Pow(secPeriodDelta, 0.1f) * 0.02f;
		justDelta *= TimeScale;
		secPeriodDelta = Mathf.Min(1f, justDelta * 60f);
		framesToSimulate = 1;
		previousframesToSimulate = 1;
	}

	private void StableUpdateRateCalculations()
	{
		previousframesToSimulate = framesToSimulate;
		collectedDelta += justDelta;
		framesToSimulate = 0;
		while (collectedDelta >= rateDelta)
		{
			collectedDelta -= rateDelta;
			framesToSimulate++;
			if (framesToSimulate >= 3)
			{
				collectedDelta = 0f;
				break;
			}
		}
	}

	private void PreCalibrateBones()
	{
		for (TailSegment tailSegment = TailSegments[0]; tailSegment != GhostChild; tailSegment = tailSegment.ChildBone)
		{
			tailSegment.PreCalibrate();
		}
	}

	private void CalibrateBones()
	{
		if (UseIK && IKBlend > 0f)
		{
			UpdateIK();
		}
		_limiting_stretchingHelperTooLong = Mathf.Lerp(0.4f, 0f, MaxStretching);
		_limiting_stretchingHelperTooShort = _limiting_stretchingHelperTooLong * 1.5f;
	}

	public void CheckForNullsInGhostChain()
	{
		if (_TransformsGhostChain == null)
		{
			_TransformsGhostChain = new List<Transform>();
		}
		for (int num = _TransformsGhostChain.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)_TransformsGhostChain[num] == (Object)null)
			{
				_TransformsGhostChain.RemoveAt(num);
			}
		}
	}

	private float GetClampedSmoothDelta()
	{
		return Mathf.Clamp(Time.smoothDeltaTime, 0f, 0.25f);
	}

	private Quaternion MultiplyQ(Quaternion rotation, float times)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.AngleAxis(rotation.x * 57.29578f * times, Vector3.right) * Quaternion.AngleAxis(rotation.z * 57.29578f * times, Vector3.forward) * Quaternion.AngleAxis(rotation.y * 57.29578f * times, Vector3.up);
	}

	public float GetValueFromCurve(int i, AnimationCurve c)
	{
		if (!initialized)
		{
			return c.Evaluate((float)i / (float)_TransformsGhostChain.Count);
		}
		return c.Evaluate(TailSegments[i].IndexOverlLength);
	}

	public AnimationCurve ClampCurve(AnimationCurve a, float timeStart, float timeEnd, float lowest, float highest)
	{
		Keyframe[] keys = a.keys;
		for (int i = 0; i < keys.Length; i++)
		{
			if (((Keyframe)(ref keys[i])).time < timeStart)
			{
				((Keyframe)(ref keys[i])).time = timeStart;
			}
			else if (((Keyframe)(ref keys[i])).time > timeEnd)
			{
				((Keyframe)(ref keys[i])).time = timeEnd;
			}
			if (((Keyframe)(ref keys[i])).value < lowest)
			{
				((Keyframe)(ref keys[i])).value = lowest;
			}
			else if (((Keyframe)(ref keys[i])).value > highest)
			{
				((Keyframe)(ref keys[i])).value = highest;
			}
		}
		a.keys = keys;
		return a;
	}

	public void RefreshTransformsList()
	{
		if (_TransformsGhostChain == null)
		{
			_TransformsGhostChain = new List<Transform>();
			return;
		}
		for (int num = _TransformsGhostChain.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)_TransformsGhostChain[0] == (Object)null)
			{
				_TransformsGhostChain.RemoveAt(num);
			}
		}
	}

	public TailSegment GetGhostChild()
	{
		return GhostChild;
	}

	private IEnumerator LateFixed()
	{
		lateFixedIsRunning = true;
		while (true)
		{
			yield return CoroutineEx.waitForFixedUpdate;
			PreCalibrateBones();
			fixedAllow = true;
		}
	}

	private void Deflection_BeginUpdate()
	{
		_defl_treshold = DeflectionStartAngle / 90f;
		float smoothTime = DeflectionSmooth / 9f;
		for (int i = _tc_startII; i < TailSegments.Count; i++)
		{
			TailSegment tailSegment = _pp_reference[i];
			if (!tailSegment.CheckDeflectionState(_defl_treshold, smoothTime, rateDelta))
			{
				bool flag = true;
				if (DeflectOnlyCollisions && tailSegment.CollisionContactRelevancy <= 0f)
				{
					flag = false;
				}
				if (flag)
				{
					Deflection_AddDeflectionSource(tailSegment);
				}
				else
				{
					Deflection_RemoveDeflectionSource(tailSegment);
				}
			}
			else
			{
				Deflection_RemoveDeflectionSource(tailSegment);
			}
		}
	}

	private void Deflection_RemoveDeflectionSource(TailSegment child)
	{
		if (!child.DeflectionRestoreState().HasValue && _defl_source.Contains(child))
		{
			_defl_source.Remove(child);
		}
	}

	private void Deflection_AddDeflectionSource(TailSegment child)
	{
		if (child.DeflectionRelevant() && !_defl_source.Contains(child))
		{
			_defl_source.Add(child);
		}
	}

	private void Deflection_SegmentOffsetSimple(TailSegment child, ref Vector3 position)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		if (child.Index == _tc_startI)
		{
			return;
		}
		float num = 0f;
		for (int i = 0; i < _defl_source.Count; i++)
		{
			if (child.Index <= _defl_source[i].Index && child.Index != _defl_source[i].Index && !(_defl_source[i].DeflectionFactor < num))
			{
				num = _defl_source[i].DeflectionFactor;
				float num2 = 0f;
				if (i > 0)
				{
					num2 = _defl_source[i].Index;
				}
				float num3 = Mathf.InverseLerp(num2, (float)_defl_source[i].Index, (float)child.Index);
				Vector3 val = _defl_source[i].DeflectionWorldPosition - child.ParentBone.ProceduralPosition;
				Vector3 proceduralPosition = child.ParentBone.ProceduralPosition;
				proceduralPosition += ((Vector3)(ref val)).normalized * child.BoneLengthScaled;
				child.ProceduralPosition = Vector3.LerpUnclamped(child.ProceduralPosition, proceduralPosition, Deflection * DeflectionFalloff.Evaluate(num3) * _defl_source[i].DeflectionSmooth);
			}
		}
	}

	public void User_SetTailTransforms(List<Transform> list)
	{
		StartBone = list[0];
		EndBone = list[list.Count - 1];
		_TransformsGhostChain = list;
		StartAfterTPose = false;
		initialized = false;
		Init();
	}

	public TailSegment User_AddTailTransform(Transform transform)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		TailSegment tailSegment = new TailSegment(transform);
		TailSegment tailSegment2 = TailSegments[TailSegments.Count - 1];
		tailSegment.ParamsFromAll(tailSegment2);
		tailSegment.RefreshFinalPos(tailSegment.transform.position);
		tailSegment.RefreshFinalRot(tailSegment.transform.rotation);
		tailSegment.ProceduralPosition = tailSegment.transform.position;
		tailSegment.PosRefRotation = tailSegment.transform.rotation;
		_TransformsGhostChain.Add(transform);
		TailSegments.Add(tailSegment);
		tailSegment2.SetChildRef(tailSegment);
		tailSegment.SetParentRef(tailSegment2);
		tailSegment.SetChildRef(GhostChild);
		GhostChild.SetParentRef(tailSegment);
		for (int i = 0; i < TailSegments.Count; i++)
		{
			TailSegments[i].SetIndex(i, TailSegments.Count);
		}
		return tailSegment;
	}

	public void User_CutEndSegmentsTo(int fromLastTo)
	{
		if (fromLastTo < TailSegments.Count)
		{
			GhostChild = TailSegments[fromLastTo];
			GhostChild.SetChildRef(null);
			for (int num = TailSegments.Count - 1; num >= fromLastTo; num--)
			{
				TailSegments.RemoveAt(num);
				_TransformsGhostChain.RemoveAt(num);
			}
		}
		else
		{
			Debug.Log((object)("[Tail Animator Cutting] Wrong index, you want cut from end to " + fromLastTo + " segment but there are only " + TailSegments.Count + " segments!"));
		}
	}

	public void User_ReposeTail()
	{
		GhostParent.Reset();
		for (int i = 0; i < TailSegments.Count; i++)
		{
			TailSegments[i].Reset();
		}
		GhostChild.Reset();
	}

	public void User_ForceDisabled(bool disable)
	{
		_forceDisable = disable;
	}

	public void OnDrop(PointerEventData data)
	{
	}

	private void OnValidate()
	{
		if (UpdateRate < 0)
		{
			UpdateRate = 0;
		}
		if (Application.isPlaying)
		{
			RefreshSegmentsColliders();
			if (UseIK)
			{
				IK_ApplyLimitBoneSettings();
			}
		}
		if (UsePartialBlend)
		{
			ClampCurve(BlendCurve, 0f, 1f, 0f, 1f);
		}
	}

	public void GetGhostChain()
	{
		if (_TransformsGhostChain == null)
		{
			_TransformsGhostChain = new List<Transform>();
		}
		if ((Object)(object)EndBone == (Object)null)
		{
			_TransformsGhostChain.Clear();
			Transform val = StartBone;
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)this).transform;
			}
			_TransformsGhostChain.Add(val);
			while (val.childCount > 0)
			{
				val = val.GetChild(0);
				if (!_TransformsGhostChain.Contains(val))
				{
					_TransformsGhostChain.Add(val);
				}
			}
			_GhostChainInitCount = _TransformsGhostChain.Count;
			return;
		}
		List<Transform> list = new List<Transform>();
		Transform val2 = StartBone;
		if ((Object)(object)val2 == (Object)null)
		{
			val2 = ((Component)this).transform;
		}
		Transform val3 = EndBone;
		list.Add(val3);
		while ((Object)(object)val3 != (Object)null && (Object)(object)val3 != (Object)(object)StartBone)
		{
			val3 = val3.parent;
			if (!list.Contains(val3))
			{
				list.Add(val3);
			}
		}
		if ((Object)(object)val3 == (Object)null)
		{
			Debug.Log((object)("[Tail Animator Editor] " + ((Object)EndBone).name + " is not child of " + ((Object)val2).name + "!"));
			Debug.LogError((object)("[Tail Animator Editor] " + ((Object)EndBone).name + " is not child of " + ((Object)val2).name + "!"));
		}
		else
		{
			if (!list.Contains(val3))
			{
				list.Add(val3);
			}
			_TransformsGhostChain.Clear();
			_TransformsGhostChain = list;
			_TransformsGhostChain.Reverse();
			_GhostChainInitCount = _TransformsGhostChain.Count;
		}
	}

	private void Start()
	{
		if (UpdateAsLast)
		{
			((Behaviour)this).enabled = false;
			((Behaviour)this).enabled = true;
		}
		if (StartAfterTPose)
		{
			startAfterTPoseCounter = 6;
		}
		else
		{
			Init();
		}
	}

	private void Reset()
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Expected O, but got Unknown
		Keyframe val = default(Keyframe);
		((Keyframe)(ref val))..ctor(0f, 0f, 0.1f, 0.1f, 0f, 0.5f);
		Keyframe val2 = default(Keyframe);
		((Keyframe)(ref val2))..ctor(1f, 1f, 5f, 0f, 0.1f, 0f);
		DeflectionFalloff = new AnimationCurve((Keyframe[])(object)new Keyframe[2] { val, val2 });
	}

	private void Update()
	{
		TimeWarning val = TimeWarning.New("TailAnimator2:Update", 0);
		try
		{
			CheckIfTailAnimatorShouldBeUpdated();
			DeltaTimeCalculations();
			if (UseWind)
			{
				WindEffectUpdate();
			}
			if (AnimatePhysics != 0 || !updateTailAnimator)
			{
				return;
			}
			if (DetachChildren)
			{
				if (_tc_rootBone != null && Object.op_Implicit((Object)(object)_tc_rootBone.transform))
				{
					_tc_rootBone.PreCalibrate();
				}
			}
			else if (OverrideKeyframeAnimation < 1f)
			{
				PreCalibrateBones();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FixedUpdate()
	{
		TimeWarning val = TimeWarning.New("TailAnimator2:FixedUpdate", 0);
		try
		{
			if (AnimatePhysics != EFixedMode.Basic || !updateTailAnimator)
			{
				return;
			}
			if (DetachChildren)
			{
				if (_tc_rootBone != null && Object.op_Implicit((Object)(object)_tc_rootBone.transform))
				{
					_tc_rootBone.PreCalibrate();
				}
			}
			else
			{
				fixedUpdated = true;
				PreCalibrateBones();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void LateUpdate()
	{
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TailAnimator2:LateUpdate", 0);
		try
		{
			if (!updateTailAnimator)
			{
				return;
			}
			if (AnimatePhysics == EFixedMode.Late)
			{
				if (!lateFixedIsRunning)
				{
					((MonoBehaviour)this).StartCoroutine(LateFixed());
				}
				if (!fixedAllow)
				{
					return;
				}
				fixedAllow = false;
			}
			else
			{
				if (lateFixedIsRunning)
				{
					((MonoBehaviour)this).StopCoroutine(LateFixed());
					lateFixedIsRunning = false;
				}
				if (AnimatePhysics == EFixedMode.Basic)
				{
					if (!fixedUpdated)
					{
						return;
					}
					fixedUpdated = false;
				}
			}
			if (DetachChildren)
			{
				TailSegment tailSegment = TailSegments[0];
				TailSegments[0].RefreshKeyLocalPositionAndRotation(tailSegment.InitialLocalPosition, tailSegment.InitialLocalRotation);
				TailSegments[0].PreCalibrate();
				tailSegment = TailSegments[1];
				if (!IncludeParent)
				{
					tailSegment.RefreshKeyLocalPositionAndRotation(tailSegment.InitialLocalPosition, tailSegment.InitialLocalRotation);
					tailSegment.PreCalibrate();
					tailSegment = TailSegments[2];
				}
				while (tailSegment != GhostChild)
				{
					tailSegment.RefreshKeyLocalPositionAndRotation(tailSegment.InitialLocalPosition, tailSegment.InitialLocalRotation);
					tailSegment.transform.position = _baseTransform.TransformPoint(tailSegment.InitialLocalPositionInRoot);
					tailSegment.transform.rotation = _baseTransform.rotation.QToWorld(tailSegment.InitialLocalRotationInRoot);
					tailSegment = tailSegment.ChildBone;
				}
			}
			else if (OverrideKeyframeAnimation > 0f)
			{
				if (OverrideKeyframeAnimation >= 1f)
				{
					PreCalibrateBones();
					for (TailSegment tailSegment2 = TailSegments[0]; tailSegment2 != GhostChild; tailSegment2 = tailSegment2.ChildBone)
					{
						tailSegment2.RefreshKeyLocalPositionAndRotation();
					}
				}
				else
				{
					for (TailSegment tailSegment3 = TailSegments[0]; tailSegment3 != GhostChild; tailSegment3 = tailSegment3.ChildBone)
					{
						tailSegment3.transform.localPosition = Vector3.LerpUnclamped(tailSegment3.transform.localPosition, tailSegment3.InitialLocalPosition, OverrideKeyframeAnimation);
						tailSegment3.transform.localRotation = Quaternion.LerpUnclamped(tailSegment3.transform.localRotation, tailSegment3.InitialLocalRotation, OverrideKeyframeAnimation);
						tailSegment3.RefreshKeyLocalPositionAndRotation();
					}
				}
			}
			else
			{
				for (TailSegment tailSegment4 = TailSegments[0]; tailSegment4 != GhostChild; tailSegment4 = tailSegment4.ChildBone)
				{
					tailSegment4.RefreshKeyLocalPositionAndRotation();
				}
			}
			ExpertParamsUpdate();
			ShapingParamsUpdate();
			CalibrateBones();
			UpdateTailAlgorithm();
			EndUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void EndUpdate()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ShapingEndUpdate();
		ExpertCurvesEndUpdate();
		previousWorldPosition = BaseTransform.position;
	}
}


using System;
using UnityEngine;

[Serializable]
public class TailSegment
{
	public Vector3 ProceduralPosition = Vector3.zero;

	public Vector3 ProceduralPositionWeightBlended = Vector3.zero;

	public Quaternion TrueTargetRotation = Quaternion.identity;

	public Quaternion PosRefRotation = Quaternion.identity;

	public Quaternion PreviousPosReferenceRotation = Quaternion.identity;

	public Vector3 PreviousPosition;

	public float BlendValue = 1f;

	public Vector3 BoneDimensionsScaled;

	public float BoneLengthScaled;

	public Vector3 InitialLocalPosition = Vector3.zero;

	public Vector3 InitialLocalPositionInRoot = Vector3.zero;

	public Quaternion InitialLocalRotationInRoot = Quaternion.identity;

	public Vector3 LocalOffset = Vector3.zero;

	public Quaternion InitialLocalRotation = Quaternion.identity;

	public float ColliderRadius = 1f;

	public bool CollisionContactFlag;

	public float CollisionContactRelevancy = -1f;

	public Collision collisionContacts;

	public Vector3 VelocityHelper = Vector3.zero;

	public Quaternion QVelocityHelper = Quaternion.identity;

	public Vector3 PreviousPush = Vector3.zero;

	public Quaternion Curving = Quaternion.identity;

	public Vector3 Gravity = Vector3.zero;

	public Vector3 GravityLookOffset = Vector3.zero;

	public float LengthMultiplier = 1f;

	public float PositionSpeed = 1f;

	public float RotationSpeed = 1f;

	public float Springiness;

	public float Slithery = 1f;

	public float Curling = 0.5f;

	public float Slippery = 1f;

	public Quaternion LastKeyframeLocalRotation;

	public Vector3 LastKeyframeLocalPosition;

	private float deflectionSmoothVelo;

	public TailSegment ParentBone { get; private set; }

	public TailSegment ChildBone { get; private set; }

	public Transform transform { get; private set; }

	public int Index { get; private set; }

	public float IndexOverlLength { get; private set; }

	public float BoneLength { get; private set; }

	public TailCollisionHelper CollisionHelper { get; internal set; }

	public bool IsDetachable { get; private set; }

	public Vector3 LastFinalPosition { get; private set; }

	public Quaternion LastFinalRotation { get; private set; }

	public float DeflectionFactor { get; private set; }

	public Vector3 Deflection { get; private set; }

	public float DeflectionSmooth { get; private set; }

	public Vector3 DeflectionWorldPosition { get; private set; }

	public int DeflectionRelevancy { get; private set; }

	public FImp_ColliderData_Base LatestSelectiveCollision { get; internal set; }

	public TailSegment()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		Index = -1;
		Curving = Quaternion.identity;
		Gravity = Vector3.zero;
		LengthMultiplier = 1f;
		Deflection = Vector3.zero;
		DeflectionFactor = 0f;
		DeflectionRelevancy = -1;
		deflectionSmoothVelo = 0f;
	}

	public TailSegment(Transform transform)
		: this()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)transform == (Object)null))
		{
			this.transform = transform;
			ProceduralPosition = transform.position;
			PreviousPosition = transform.position;
			PosRefRotation = transform.rotation;
			PreviousPosReferenceRotation = PosRefRotation;
			TrueTargetRotation = PosRefRotation;
			ReInitializeLocalPosRot(transform.localPosition, transform.localRotation);
			BoneLength = 0.1f;
		}
	}

	public TailSegment(TailSegment copyFrom)
		: this(copyFrom.transform)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		transform = copyFrom.transform;
		Index = copyFrom.Index;
		IndexOverlLength = copyFrom.IndexOverlLength;
		ProceduralPosition = copyFrom.ProceduralPosition;
		PreviousPosition = copyFrom.PreviousPosition;
		ProceduralPositionWeightBlended = copyFrom.ProceduralPosition;
		PosRefRotation = copyFrom.PosRefRotation;
		PreviousPosReferenceRotation = PosRefRotation;
		TrueTargetRotation = copyFrom.TrueTargetRotation;
		ReInitializeLocalPosRot(copyFrom.InitialLocalPosition, copyFrom.InitialLocalRotation);
	}

	public void ReInitializeLocalPosRot(Vector3 initLocalPos, Quaternion initLocalRot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		InitialLocalPosition = initLocalPos;
		InitialLocalRotation = initLocalRot;
	}

	public void SetIndex(int i, int tailSegments)
	{
		Index = i;
		if (i < 0)
		{
			IndexOverlLength = 0f;
		}
		else
		{
			IndexOverlLength = (float)i / (float)tailSegments;
		}
	}

	public void SetParentRef(TailSegment parent)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		ParentBone = parent;
		Vector3 val = ProceduralPosition - ParentBone.ProceduralPosition;
		BoneLength = ((Vector3)(ref val)).magnitude;
	}

	public void SetChildRef(TailSegment child)
	{
		ChildBone = child;
	}

	public float GetRadiusScaled()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return ColliderRadius * transform.lossyScale.x;
	}

	public void AssignDetachedRootCoords(Transform root)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		InitialLocalPositionInRoot = root.InverseTransformPoint(transform.position);
		InitialLocalRotationInRoot = root.rotation.QToLocal(transform.rotation);
		IsDetachable = true;
	}

	internal Vector3 BlendMotionWeight(Vector3 newPosition)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.LerpUnclamped(ParentBone.ProceduralPosition + ParentBone.LastKeyframeLocalRotation.TransformVector(ParentBone.transform.lossyScale, LastKeyframeLocalPosition), newPosition, BlendValue);
	}

	internal void PreCalibrate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		transform.localPosition = InitialLocalPosition;
		transform.localRotation = InitialLocalRotation;
	}

	internal void Validate()
	{
		if (BoneLength == 0f)
		{
			BoneLength = 0.001f;
		}
	}

	public void RefreshKeyLocalPosition()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)transform))
		{
			LastKeyframeLocalRotation = transform.localRotation;
		}
		else
		{
			LastKeyframeLocalRotation = InitialLocalRotation;
		}
	}

	public void RefreshKeyLocalPositionAndRotation()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)transform))
		{
			RefreshKeyLocalPositionAndRotation(transform.localPosition, transform.localRotation);
		}
		else
		{
			RefreshKeyLocalPositionAndRotation(InitialLocalPosition, InitialLocalRotation);
		}
	}

	public void RefreshKeyLocalPositionAndRotation(Vector3 p, Quaternion r)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		LastKeyframeLocalPosition = p;
		LastKeyframeLocalRotation = r;
	}

	internal Vector3 ParentToFrontOffset()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return ParentBone.LastKeyframeLocalRotation.TransformVector(ParentBone.transform.lossyScale, LastKeyframeLocalPosition);
	}

	public void RefreshFinalPos(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		LastFinalPosition = pos;
	}

	public void RefreshFinalRot(Quaternion rot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		LastFinalRotation = rot;
	}

	public bool CheckDeflectionState(float zeroWhenLower, float smoothTime, float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = LastKeyframeLocalPosition - ParentBone.transform.InverseTransformVector(ProceduralPosition - ParentBone.ProceduralPosition);
		DeflectionFactor = Vector3.Dot(((Vector3)(ref LastKeyframeLocalPosition)).normalized, ((Vector3)(ref val)).normalized);
		if (DeflectionFactor < zeroWhenLower)
		{
			if (smoothTime <= Mathf.Epsilon)
			{
				DeflectionSmooth = 0f;
			}
			else
			{
				DeflectionSmooth = Mathf.SmoothDamp(DeflectionSmooth, 0f - Mathf.Epsilon, ref deflectionSmoothVelo, smoothTime / 1.5f, float.PositiveInfinity, delta);
			}
		}
		else if (smoothTime <= Mathf.Epsilon)
		{
			DeflectionSmooth = 1f;
		}
		else
		{
			DeflectionSmooth = Mathf.SmoothDamp(DeflectionSmooth, 1f, ref deflectionSmoothVelo, smoothTime, float.PositiveInfinity, delta);
		}
		if (DeflectionSmooth <= Mathf.Epsilon)
		{
			return true;
		}
		if (ChildBone.ChildBone != null)
		{
			DeflectionWorldPosition = ChildBone.ChildBone.ProceduralPosition;
		}
		else
		{
			DeflectionWorldPosition = ChildBone.ProceduralPosition;
		}
		return false;
	}

	public bool DeflectionRelevant()
	{
		if (DeflectionRelevancy == -1)
		{
			DeflectionRelevancy = 3;
			return true;
		}
		DeflectionRelevancy = 3;
		return false;
	}

	public bool? DeflectionRestoreState()
	{
		if (DeflectionRelevancy > 0)
		{
			DeflectionRelevancy--;
			if (DeflectionRelevancy == 0)
			{
				DeflectionRelevancy = -1;
				return null;
			}
			return true;
		}
		return false;
	}

	internal void ParamsFrom(TailSegment other)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		BlendValue = other.BlendValue;
		ColliderRadius = other.ColliderRadius;
		Gravity = other.Gravity;
		LengthMultiplier = other.LengthMultiplier;
		BoneLength = other.BoneLength;
		BoneLengthScaled = other.BoneLengthScaled;
		BoneDimensionsScaled = other.BoneDimensionsScaled;
		collisionContacts = other.collisionContacts;
		CollisionHelper = other.CollisionHelper;
		PositionSpeed = other.PositionSpeed;
		RotationSpeed = other.RotationSpeed;
		Springiness = other.Springiness;
		Slithery = other.Slithery;
		Curling = other.Curling;
		Slippery = other.Slippery;
	}

	internal void ParamsFromAll(TailSegment other)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		ParamsFrom(other);
		InitialLocalPosition = other.InitialLocalPosition;
		InitialLocalRotation = other.InitialLocalRotation;
		LastFinalPosition = other.LastFinalPosition;
		LastFinalRotation = other.LastFinalRotation;
		ProceduralPosition = other.ProceduralPosition;
		ProceduralPositionWeightBlended = other.ProceduralPositionWeightBlended;
		TrueTargetRotation = other.TrueTargetRotation;
		PosRefRotation = other.PosRefRotation;
		PreviousPosReferenceRotation = other.PreviousPosReferenceRotation;
		PreviousPosition = other.PreviousPosition;
		BoneLength = other.BoneLength;
		BoneDimensionsScaled = other.BoneDimensionsScaled;
		BoneLengthScaled = other.BoneLengthScaled;
		LocalOffset = other.LocalOffset;
		ColliderRadius = other.ColliderRadius;
		VelocityHelper = other.VelocityHelper;
		QVelocityHelper = other.QVelocityHelper;
		PreviousPush = other.PreviousPush;
	}

	internal void User_ReassignTransform(Transform t)
	{
		transform = t;
	}

	public void Reset()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		PreviousPush = Vector3.zero;
		VelocityHelper = Vector3.zero;
		QVelocityHelper = Quaternion.identity;
		if (Object.op_Implicit((Object)(object)transform))
		{
			ProceduralPosition = transform.position;
			PosRefRotation = transform.rotation;
			PreviousPosReferenceRotation = transform.rotation;
		}
		else if (Object.op_Implicit((Object)(object)ParentBone.transform))
		{
			ProceduralPosition = ParentBone.transform.position + ParentToFrontOffset();
		}
		PreviousPosition = ProceduralPosition;
		ProceduralPositionWeightBlended = ProceduralPosition;
	}
}


public enum ECollisionSpace
{
	World_Slow,
	Selective_Fast
}


public enum ECollisionMode
{
	m_3DCollision,
	m_2DCollision
}


using System;
using UnityEngine;

[Serializable]
public class IKBoneSettings
{
	[Range(0f, 181f)]
	public float AngleLimit = 45f;

	[Range(0f, 181f)]
	public float TwistAngleLimit = 5f;

	public bool UseInChain = true;
}


public enum FEWavingType
{
	Simple,
	Advanced
}


public enum EFDeltaType
{
	DeltaTime,
	SmoothDeltaTime,
	UnscaledDeltaTime,
	FixedDeltaTime,
	SafeDelta
}


public enum EAnimationStyle
{
	Quick,
	Accelerating,
	Linear
}


public enum ETailCategory
{
	Setup,
	Tweak,
	Features,
	Shaping
}


public enum ETailFeaturesCategory
{
	Main,
	Collisions,
	IK,
	Experimental
}


public enum EFixedMode
{
	None,
	Basic,
	Late
}


using System.Collections.Generic;
using FIMSpace;
using FIMSpace.FTail;
using UnityEngine;

public static class FTail_Skinning
{
	public static FTail_SkinningVertexData[] CalculateVertexWeightingData(Mesh baseMesh, Transform[] bonesCoords, Vector3 spreadOffset, int weightBoneLimit = 2, float spreadValue = 0.8f, float spreadPower = 0.185f)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[bonesCoords.Length];
		Quaternion[] array2 = (Quaternion[])(object)new Quaternion[bonesCoords.Length];
		for (int i = 0; i < bonesCoords.Length; i++)
		{
			array[i] = bonesCoords[0].parent.InverseTransformPoint(bonesCoords[i].position);
			array2[i] = bonesCoords[0].parent.rotation.QToLocal(bonesCoords[i].rotation);
		}
		return CalculateVertexWeightingData(baseMesh, array, array2, spreadOffset, weightBoneLimit, spreadValue, spreadPower);
	}

	public static FTail_SkinningVertexData[] CalculateVertexWeightingData(Mesh baseMesh, Vector3[] bonesPos, Quaternion[] bonesRot, Vector3 spreadOffset, int weightBoneLimit = 2, float spreadValue = 0.8f, float spreadPower = 0.185f)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		if (weightBoneLimit < 1)
		{
			weightBoneLimit = 1;
		}
		if (weightBoneLimit > 2)
		{
			weightBoneLimit = 2;
		}
		int vertexCount = baseMesh.vertexCount;
		FTail_SkinningVertexData[] array = new FTail_SkinningVertexData[vertexCount];
		Vector3[] array2 = (Vector3[])(object)new Vector3[bonesPos.Length];
		for (int i = 0; i < bonesPos.Length - 1; i++)
		{
			array2[i] = bonesPos[i + 1] - bonesPos[i];
		}
		if (array2.Length > 1)
		{
			array2[^1] = array2[^2];
		}
		for (int j = 0; j < vertexCount; j++)
		{
			array[j] = new FTail_SkinningVertexData(baseMesh.vertices[j]);
			array[j].CalculateVertexParameters(bonesPos, bonesRot, array2, weightBoneLimit, spreadValue, spreadOffset, spreadPower);
		}
		return array;
	}

	public static SkinnedMeshRenderer SkinMesh(Mesh baseMesh, Transform skinParent, Transform[] bonesStructure, FTail_SkinningVertexData[] vertData)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[bonesStructure.Length];
		Quaternion[] array2 = (Quaternion[])(object)new Quaternion[bonesStructure.Length];
		for (int i = 0; i < bonesStructure.Length; i++)
		{
			array[i] = skinParent.InverseTransformPoint(bonesStructure[i].position);
			array2[i] = skinParent.rotation.QToLocal(bonesStructure[i].rotation);
		}
		return SkinMesh(baseMesh, array, array2, vertData);
	}

	public static SkinnedMeshRenderer SkinMesh(Mesh baseMesh, Vector3[] bonesPositions, Quaternion[] bonesRotations, FTail_SkinningVertexData[] vertData)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		if (bonesPositions == null)
		{
			return null;
		}
		if (bonesRotations == null)
		{
			return null;
		}
		if ((Object)(object)baseMesh == (Object)null)
		{
			return null;
		}
		if (vertData == null)
		{
			return null;
		}
		Mesh val = Object.Instantiate<Mesh>(baseMesh);
		((Object)val).name = ((Object)baseMesh).name + " [FSKINNED]";
		Transform transform = new GameObject(((Object)baseMesh).name + " [FSKINNED]").transform;
		SkinnedMeshRenderer val2 = ((Component)transform).gameObject.AddComponent<SkinnedMeshRenderer>();
		Transform[] array = (Transform[])(object)new Transform[bonesPositions.Length];
		Matrix4x4[] array2 = (Matrix4x4[])(object)new Matrix4x4[bonesPositions.Length];
		string text = ((((Object)baseMesh).name.Length >= 6) ? ((Object)baseMesh).name.Substring(0, 5) : ((Object)baseMesh).name);
		for (int i = 0; i < bonesPositions.Length; i++)
		{
			array[i] = new GameObject("BoneF-" + text + "[" + i + "]").transform;
			if (i == 0)
			{
				array[i].SetParent(transform, true);
			}
			else
			{
				array[i].SetParent(array[i - 1], true);
			}
			((Component)array[i]).transform.position = bonesPositions[i];
			((Component)array[i]).transform.rotation = bonesRotations[i];
			array2[i] = array[i].worldToLocalMatrix * transform.localToWorldMatrix;
		}
		BoneWeight[] array3 = (BoneWeight[])(object)new BoneWeight[val.vertexCount];
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j] = default(BoneWeight);
		}
		for (int k = 0; k < vertData.Length; k++)
		{
			for (int l = 0; l < vertData[k].weights.Length; l++)
			{
				array3[k] = SetWeightIndex(array3[k], l, vertData[k].bonesIndexes[l]);
				array3[k] = SetWeightToBone(array3[k], l, vertData[k].weights[l]);
			}
		}
		val.bindposes = array2;
		val.boneWeights = array3;
		List<Vector3> list = new List<Vector3>();
		List<Vector4> list2 = new List<Vector4>();
		baseMesh.GetNormals(list);
		baseMesh.GetTangents(list2);
		val.SetNormals(list);
		val.SetTangents(list2);
		val.bounds = baseMesh.bounds;
		val2.sharedMesh = val;
		val2.rootBone = array[0];
		val2.bones = array;
		return val2;
	}

	public static BoneWeight SetWeightIndex(BoneWeight weight, int bone = 0, int index = 0)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		switch (bone)
		{
		case 1:
			((BoneWeight)(ref weight)).boneIndex1 = index;
			break;
		case 2:
			((BoneWeight)(ref weight)).boneIndex2 = index;
			break;
		case 3:
			((BoneWeight)(ref weight)).boneIndex3 = index;
			break;
		default:
			((BoneWeight)(ref weight)).boneIndex0 = index;
			break;
		}
		return weight;
	}

	public static BoneWeight SetWeightToBone(BoneWeight weight, int bone = 0, float value = 1f)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		switch (bone)
		{
		case 1:
			((BoneWeight)(ref weight)).weight1 = value;
			break;
		case 2:
			((BoneWeight)(ref weight)).weight2 = value;
			break;
		case 3:
			((BoneWeight)(ref weight)).weight3 = value;
			break;
		default:
			((BoneWeight)(ref weight)).weight0 = value;
			break;
		}
		return weight;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class FTail_SkinningVertexData
{
	public Vector3 position;

	public int[] bonesIndexes;

	public int allMeshBonesCount;

	public float[] weights;

	public float[] debugDists;

	public float[] debugDistWeights;

	public float[] debugWeights;

	public FTail_SkinningVertexData(Vector3 pos)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		position = pos;
	}

	public float DistanceToLine(Vector3 pos, Vector3 lineStart, Vector3 lineEnd)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - lineStart;
		Vector3 val2 = lineEnd - lineStart;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		float num = Vector3.Distance(lineStart, lineEnd);
		float num2 = Vector3.Dot(normalized, val);
		if (num2 <= 0f)
		{
			return Vector3.Distance(pos, lineStart);
		}
		if (num2 >= num)
		{
			return Vector3.Distance(pos, lineEnd);
		}
		Vector3 val3 = normalized * num2;
		Vector3 val4 = lineStart + val3;
		return Vector3.Distance(pos, val4);
	}

	public void CalculateVertexParameters(Vector3[] bonesPos, Quaternion[] bonesRot, Vector3[] boneAreas, int maxWeightedBones, float spread, Vector3 spreadOffset, float spreadPower = 1f)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		allMeshBonesCount = bonesPos.Length;
		List<Vector2> list = new List<Vector2>();
		for (int i = 0; i < bonesPos.Length; i++)
		{
			Vector3 val = ((i == bonesPos.Length - 1) ? Vector3.Lerp(bonesPos[i], bonesPos[i] + (bonesPos[i] - bonesPos[i - 1]), 0.9f) : Vector3.Lerp(bonesPos[i], bonesPos[i + 1], 0.9f));
			val += bonesRot[i] * spreadOffset;
			float num = DistanceToLine(position, bonesPos[i], val);
			list.Add(new Vector2((float)i, num));
		}
		list.Sort((Vector2 a, Vector2 b) => a.y.CompareTo(b.y));
		int num2 = Mathf.Min(maxWeightedBones, bonesPos.Length);
		bonesIndexes = new int[num2];
		float[] array = new float[num2];
		for (int j = 0; j < num2; j++)
		{
			bonesIndexes[j] = (int)list[j].x;
			array[j] = list[j].y;
		}
		float[] array2 = new float[num2];
		AutoSetBoneWeights(array2, array, spread, spreadPower, boneAreas);
		float num3 = 1f;
		weights = new float[num2];
		for (int k = 0; k < num2 && (spread != 0f || k <= 0); k++)
		{
			if (num3 <= 0f)
			{
				weights[k] = 0f;
				continue;
			}
			float num4 = array2[k];
			num3 -= num4;
			if (num3 <= 0f)
			{
				num4 += num3;
			}
			else if (k == num2 - 1)
			{
				num4 += num3;
			}
			weights[k] = num4;
		}
	}

	public void AutoSetBoneWeights(float[] weightForBone, float[] distToBone, float spread, float spreadPower, Vector3[] boneAreas)
	{
		int num = weightForBone.Length;
		float[] array = new float[num];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = ((Vector3)(ref boneAreas[i])).magnitude;
		}
		float[] array2 = new float[num];
		for (int j = 0; j < weightForBone.Length; j++)
		{
			weightForBone[j] = 0f;
		}
		float num2 = 0f;
		for (int k = 0; k < num; k++)
		{
			num2 += distToBone[k];
		}
		for (int l = 0; l < num; l++)
		{
			array2[l] = 1f - distToBone[l] / num2;
		}
		debugDists = distToBone;
		if (num == 1 || spread == 0f)
		{
			weightForBone[0] = 1f;
			return;
		}
		if (num == 2)
		{
			float num3 = 1f;
			weightForBone[0] = 1f;
			float num4 = Mathf.InverseLerp(distToBone[0] + array[0] / 1.25f * spread, distToBone[0], distToBone[1]);
			debugDists[0] = num4;
			num3 += (weightForBone[1] = DistributionIn(Mathf.Lerp(0f, 1f, num4), Mathf.Lerp(1.5f, 16f, spreadPower)));
			debugDistWeights = new float[weightForBone.Length];
			weightForBone.CopyTo(debugDistWeights, 0);
			for (int m = 0; m < num; m++)
			{
				weightForBone[m] /= num3;
			}
			debugWeights = weightForBone;
			return;
		}
		float num5 = array[0] / 10f;
		float num6 = array[0] / 2f;
		float num7 = 0f;
		for (int n = 0; n < num; n++)
		{
			float num8 = Mathf.InverseLerp(0f, num5 + num6 * spread, distToBone[n]);
			float num9 = Mathf.Lerp(1f, 0f, num8);
			if (n == 0 && num9 == 0f)
			{
				num9 = 1f;
			}
			weightForBone[n] = num9;
			num7 += num9;
		}
		debugDistWeights = new float[weightForBone.Length];
		weightForBone.CopyTo(debugDistWeights, 0);
		for (int num10 = 0; num10 < num; num10++)
		{
			weightForBone[num10] /= num7;
		}
		debugWeights = weightForBone;
	}

	public static float DistributionIn(float k, float power)
	{
		return Mathf.Pow(k, power + 1f);
	}

	public static Color GetBoneIndicatorColor(int boneIndex, int bonesCount, float s = 0.9f, float v = 0.9f)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return Color.HSVToRGB(((float)boneIndex * 1.125f / (float)bonesCount + 0.125f * (float)boneIndex + 0.3f) % 1f, s, v);
	}

	public Color GetWeightColor()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		Color val = GetBoneIndicatorColor(bonesIndexes[0], allMeshBonesCount, 1f, 1f);
		for (int i = 1; i < bonesIndexes.Length; i++)
		{
			val = Color.Lerp(val, GetBoneIndicatorColor(bonesIndexes[i], allMeshBonesCount, 1f, 1f), weights[i]);
		}
		return val;
	}
}


